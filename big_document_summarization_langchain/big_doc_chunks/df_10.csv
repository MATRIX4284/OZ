,page,img_cnt,img_npy_lst,text,tables,entities,relationships,summary_rel,summary,highlights
100,189,0,[],"157
Summary
First, make sure you’re connecting to the service’s cluster IP from within the
cluster, not from the outside.
Don’t bother pinging the service IP to figure out if the service is accessible
(remember, the service’s cluster IP is a virtual IP and pinging it will never work).
If you’ve defined a readiness probe, make sure it’s succeeding; otherwise the
pod won’t be part of the service.
To confirm that a pod is part of the service, examine the corresponding End-
points object with kubectl get endpoints.
If you’re trying to access the service through its FQDN or a part of it (for exam-
ple, myservice.mynamespace.svc.cluster.local or myservice.mynamespace) and
it doesn’t work, see if you can access it using its cluster IP instead of the FQDN.
Check whether you’re connecting to the port exposed by the service and not
the target port.
Try connecting to the pod IP directly to confirm your pod is accepting connec-
tions on the correct port.
If you can’t even access your app through the pod’s IP, make sure your app isn’t
only binding to localhost.
This should help you resolve most of your service-related problems. You’ll learn much
more about how services work in chapter 11. By understanding exactly how they’re
implemented, it should be much easier for you to troubleshoot them.
5.8
Summary
In this chapter, you’ve learned how to create Kubernetes Service resources to expose
the services available in your application, regardless of how many pod instances are
providing each service. You’ve learned how Kubernetes
Exposes multiple pods that match a certain label selector under a single, stable
IP address and port
Makes services accessible from inside the cluster by default, but allows you to
make the service accessible from outside the cluster by setting its type to either
NodePort or LoadBalancer
Enables pods to discover services together with their IP addresses and ports by
looking up environment variables
Allows discovery of and communication with services residing outside the
cluster by creating a Service resource without specifying a selector, by creating
an associated Endpoints resource instead
Provides a DNS CNAME alias for external services with the ExternalName ser-
vice type
Exposes multiple HTTP services through a single Ingress (consuming a sin-
gle IP)
 
",[],"[{'entity': 'cluster IP', 'description': 'A virtual IP address assigned to a service within a Kubernetes cluster.', 'category': 'network'}, {'entity': 'readiness probe', 'description': 'A mechanism in Kubernetes that checks if a pod is ready to receive traffic.', 'category': 'process'}, {'entity': 'Endpoints object', 'description': 'A Kubernetes resource that lists the IP addresses and ports of pods associated with a service.', 'category': 'database'}, {'entity': 'FQDN', 'description': 'Fully Qualified Domain Name, used to access a service through its DNS name.', 'category': 'network'}, {'entity': 'cluster IP', 'description': 'A virtual IP address assigned to a service within a Kubernetes cluster.', 'category': 'network'}, {'entity': 'port exposed by the service', 'description': 'The port number that a service exposes to clients.', 'category': 'application'}, {'entity': 'target port', 'description': 'The port number that a pod uses to receive traffic from a service.', 'category': 'application'}, {'entity': 'pod IP', 'description': 'The IP address of a pod within a Kubernetes cluster.', 'category': 'network'}, {'entity': 'localhost', 'description': 'A special hostname that refers to the local machine.', 'category': 'hardware'}, {'entity': 'Kubernetes Service resources', 'description': 'A type of resource in Kubernetes that exposes services available in an application.', 'category': 'application'}, {'entity': 'label selector', 'description': 'A mechanism in Kubernetes that selects pods based on labels attached to them.', 'category': 'process'}, {'entity': 'NodePort', 'description': 'A type of service in Kubernetes that makes a service accessible from outside the cluster by exposing it on a specific port on each node.', 'category': 'network'}, {'entity': 'LoadBalancer', 'description': 'A type of service in Kubernetes that makes a service accessible from outside the cluster by using an external load balancer.', 'category': 'network'}, {'entity': 'environment variables', 'description': ""Variables that can be set in a pod's environment to provide information about services and their IP addresses."", 'category': 'process'}, {'entity': 'Service resource', 'description': 'A Kubernetes resource that defines a service and its properties.', 'category': 'database'}, {'entity': 'Endpoints resource', 'description': 'A Kubernetes resource that lists the IP addresses and ports of pods associated with a service.', 'category': 'database'}, {'entity': 'ExternalName service type', 'description': 'A type of service in Kubernetes that provides a DNS CNAME alias for external services.', 'category': 'network'}, {'entity': 'Ingress', 'description': 'A mechanism in Kubernetes that exposes multiple HTTP services through a single IP address.', 'category': 'application'}]","[{'source_entity': 'Kubernetes Service resources', 'description': 'provides network identity and load balancing', 'destination_entity': 'applications in a cluster'}, {'source_entity': 'Service resource', 'description': 'describes the desired state of a service', 'destination_entity': 'pods based on labels'}, {'source_entity': 'Ingress', 'description': 'manages external access to services through HTTP requests', 'destination_entity': 'services in a cluster'}, {'source_entity': 'Environment variables', 'description': 'pass configuration information to containers', 'destination_entity': 'containers running inside a pod'}, {'source_entity': 'Endpoints object', 'description': 'provides a list of IP addresses and ports for accessing a service', 'destination_entity': 'service'}, {'source_entity': 'LoadBalancer', 'description': 'exposes the service to external traffic', 'destination_entity': 'service'}, {'source_entity': 'NodePort', 'description': 'exposes a port on each node in the cluster', 'destination_entity': 'cluster'}, {'source_entity': 'target port', 'description': 'is exposed by the service', 'destination_entity': 'service'}, {'source_entity': 'FQDN', 'description': 'resolves to a Service resource', 'destination_entity': 'Service resource'}, {'source_entity': 'port exposed by the service', 'description': 'is accessible through an Ingress', 'destination_entity': 'Ingress'}, {'source_entity': 'readiness probe', 'description': 'checks if a pod is ready to receive traffic', 'destination_entity': 'pod'}, {'source_entity': 'ExternalName service type', 'description': 'resolves to an external DNS name', 'destination_entity': 'external DNS name'}, {'source_entity': 'cluster IP', 'description': 'is used by a Service resource', 'destination_entity': 'Service resource'}, {'source_entity': 'Endpoints object', 'description': 'provides a list of IP addresses and ports for accessing a service', 'destination_entity': 'service'}, {'source_entity': 'label selector', 'description': 'selects pods based on labels', 'destination_entity': 'pods'}, {'source_entity': 'pod IP', 'description': 'is used by an Endpoints object', 'destination_entity': 'Endpoints object'}, {'source_entity': 'Endpoints resource', 'description': 'provides a list of IP addresses and ports for accessing a service', 'destination_entity': 'service'}]","['[\n  {\n    ""source"": ""Kubernetes Service resources"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""provides network identity and load balancing"",\n    ""summary_er"": ""A Kubernetes Service provides a network identity and load balancing for pods, enabling communication between them.""\n  }\n]', '[\n  {\n    ""source"": ""Service resource"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""describes the desired state of a service"",\n    ""summary_er"": ""A Service resource defines the desired state of a pod, which can be used to select pods based on labels.""\n  },\n  {\n    ""source"": ""pod"",\n    ""destination"": ""Service resource"",\n    ""relation_description"": ""based on labels"",\n    ""summary_er"": ""Pods are selected by a Service resource based on their labels, allowing for dynamic service discovery and routing.""\n  }\n]', '[\n  {\n    ""source"": ""Ingress"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""manages external access to services through HTTP requests"",\n    ""summary_er"": ""Ingress manages external access to services, allowing HTTP requests to reach pods in a cluster.""\n  },\n  {\n    ""source"": ""services"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""in a cluster"",\n    ""summary_er"": ""Services are deployed in a pod, providing a way to group and manage related containers within the cluster.""\n  }\n]', '[\n  {\n    ""source"": ""Environment variables"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""pass configuration information to containers"",\n    ""summary_er"": ""Environment variables are used to pass configuration information from a pod to its running containers, allowing for centralized management of settings.""\n  },\n  {\n    ""source"": ""containers"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""running inside a pod"",\n    ""summary_er"": ""Containers run within a shared environment provided by a pod, sharing resources and network connectivity.""\n  }\n]', '[\n  {\n    ""source"": ""Endpoints"",\n    ""destination"": ""Pod"",\n    ""relation_description"": ""provides a list of IP addresses and ports for accessing a service"",\n    ""summary_er"": ""An Endpoints object provides a list of IP addresses and ports to access a Pod\'s service, enabling communication between services.""\n  }\n]', '[\n  {\n    ""source"": ""LoadBalancer"",\n    ""destination"": ""service"",\n    ""relation_description"": ""exposes the service to external traffic"",\n    ""summary_er"": ""The LoadBalancer exposes a service to external traffic, making it accessible from outside the cluster.""\n  }\n]', '[\n  {\n    ""source"": ""NodePort"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""exposes a port on each node in the cluster"",\n    ""summary_er"": ""NodePort exposes a port on each node in the cluster, allowing external access to a pod\'s services.""\n  }\n]', '[\n  {\n    ""source"": ""target port"",\n    ""destination"": ""service"",\n    ""relation_description"": ""is exposed by"",\n    ""summary_er"": ""The target port is made accessible to clients through the service, allowing external access.""\n  },\n  {\n    ""source"": ""service"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""exposes"",\n    ""summary_er"": ""The service provides a layer of abstraction and exposes the functionality of the pod to clients.""\n  }\n]', '[\n  {\n    ""source"": ""FQDN"",\n    ""destination"": ""Service resource"",\n    ""relation_description"": ""resolves to"",\n    ""summary_er"": ""A Fully Qualified Domain Name (FQDN) resolves to a Service resource, which provides a network identity and load balancing for accessing a group of pods.""\n  },\n  {\n    ""source"": ""Service resource"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""accessing a group of"",\n    ""summary_er"": ""A Service resource is used to access a group of pods, providing a stable network identity and load balancing for incoming traffic.""\n  }\n]', '[\n  {\n    ""source"": ""Service"",\n    ""destination"": ""Pod"",\n    ""relation_description"": ""exposed port"",\n    ""summary_er"": ""A service exposes a port that is accessible through an Ingress, which directs traffic to a Pod.""\n  }\n]', '[\n  {\n    ""source"": ""readiness probe"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""checks if a pod is ready to receive traffic"",\n    ""summary_er"": ""The readiness probe ensures a pod is prepared to handle incoming requests, verifying its readiness before allowing traffic.""\n  }\n]', '[\n  {\n    ""source"": ""ExternalName service"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""resolves to an external DNS name"",\n    ""summary_er"": ""An ExternalName service resolves to an external DNS name, which is used by a pod.""\n  }\n]', '[\n  {\n    ""source"": ""cluster IP"",\n    ""destination"": ""Service resource"",\n    ""relation_description"": ""is used by"",\n    ""summary_er"": ""A cluster IP is used by a Service resource to provide a stable IP address for pods.""\n  },\n  {\n    ""source"": ""Service resource"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""is used by"",\n    ""summary_er"": ""A Service resource is used by a pod to provide network connectivity and load balancing.""\n  }\n]', '[\n  {\n    ""source"": ""Endpoints"",\n    ""destination"": ""Pod"",\n    ""relation_description"": ""provides a list of IP addresses and ports for accessing a service"",\n    ""summary_er"": ""The Endpoints object provides a list of accessible IP addresses and ports for a Pod, enabling service access.""\n  }\n]', '[\n  {\n    ""source"": ""label selector"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""selects pods based on labels"",\n    ""summary_er"": ""A label selector is used to filter pods based on their labels, allowing for targeted management and deployment of resources.""\n  }\n]', '[\n  {\n    ""source"": ""pod IP"",\n    ""destination"": ""Endpoints object"",\n    ""relation_description"": ""is used by"",\n    ""summary_er"": ""The pod IP is utilized by an Endpoints object to provide network connectivity and service discovery.""\n  },\n  {\n    ""source"": ""Endpoints object"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""is associated with"",\n    ""summary_er"": ""An Endpoints object is linked to a pod, enabling the management of network endpoints and services.""\n  }\n]', '[\n  {\n    ""source"": ""Endpoints resource"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""provides a list of IP addresses and ports for accessing a service"",\n    ""summary_er"": ""The Endpoints resource provides a list of IP addresses and ports for accessing a pod, enabling communication with the service.""\n  }\n]']","Make sure to access Kubernetes service from within the cluster and not outside. Check if readiness probe is succeeding, examine Endpoints object, and try accessing service using its cluster IP or FQDN. Ensure correct port is exposed and target port is not used. Connect directly to pod IP to confirm connections are being accepted. If still issues persist, check if app is binding only to localhost.","[{'highlight': 'First, make sure you’re connecting to the service’s cluster IP from within the cluster, not from the outside.'}, {'highlight': 'If you’ve defined a readiness probe, make sure it’s succeeding; otherwise the pod won’t be part of the service.'}, {'highlight': 'To confirm that a pod is part of the service, examine the corresponding End-points object with kubectl get endpoints.'}, {'highlight': 'Kubernetes Exposes multiple pods that match a certain label selector under a single, stable IP address and port'}, {'highlight': 'Kubernetes Enables pods to discover services together with their IP addresses and ports by looking up environment variables'}]"
101,190,0,[],"158
CHAPTER 5
Services: enabling clients to discover and talk to pods
Uses a pod container’s readiness probe to determine whether a pod should or
shouldn’t be included as a service endpoint
Enables discovery of pod IPs through DNS when you create a headless service
Along with getting a better understanding of services, you’ve also learned how to
Troubleshoot them
Modify firewall rules in Google Kubernetes/Compute Engine
Execute commands in pod containers through kubectl exec 
Run a bash shell in an existing pod’s container
Modify Kubernetes resources through the kubectl apply command
Run an unmanaged ad hoc pod with kubectl run --generator=run-pod/v1
 
",[],"[{'entity': 'Services', 'description': 'enabling clients to discover and talk to pods', 'category': 'application'}, {'entity': 'pod container', 'description': ""a pod's readiness probe is used to determine whether a pod should or shouldn't be included as a service endpoint"", 'category': 'container'}, {'entity': 'DNS', 'description': 'used for discovery of pod IPs when creating a headless service', 'category': 'network'}, {'entity': 'kubectl exec', 'description': 'executing commands in pod containers', 'category': 'command'}, {'entity': 'bash shell', 'description': ""running a bash shell in an existing pod's container"", 'category': 'process'}, {'entity': 'kubectl apply', 'description': 'modifying Kubernetes resources through the kubectl apply command', 'category': 'command'}, {'entity': 'kubernetes resources', 'description': 'managed by kubectl apply command', 'category': 'application'}, {'entity': 'pod IPs', 'description': 'discovered through DNS when creating a headless service', 'category': 'network'}, {'entity': 'readiness probe', 'description': ""used to determine whether a pod should or shouldn't be included as a service endpoint"", 'category': 'process'}]","[{'source_entity': '""Kubernetes Resources""', 'description': 'are managed by', 'destination_entity': '""kubectl apply""'}, {'source_entity': '""kubectl apply""', 'description': 'is used to deploy', 'destination_entity': '""pod container""'}, {'source_entity': '""kubectl apply""', 'description': 'creates a new instance of', 'destination_entity': '""Services""'}, {'source_entity': '""readiness probe""', 'description': 'is used to check the health of', 'destination_entity': '""pod container""'}, {'source_entity': '""DNS""', 'description': 'is used by', 'destination_entity': '""pod IPs""'}, {'source_entity': '""kubectl exec""', 'description': 'allows to execute commands on', 'destination_entity': '""bash shell""'}, {'source_entity': '""kubectl exec""', 'description': 'is used to interact with', 'destination_entity': '""pod container""'}]","['[\n  {\n    ""source"": ""Kubernetes Resources"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""are managed by"",\n    ""summary_er"": ""Kubernetes resources, such as deployments and services, are managed by pods, which serve as the basic execution unit in Kubernetes.""\n  },\n  {\n    ""source"": ""kubectl apply"",\n    ""destination"": ""Kubernetes Resources"",\n    ""relation_description"": """",\n    ""summary_er"": ""The \'kubectl apply\' command is used to deploy or update Kubernetes resources, such as deployments and services, into a cluster.""\n  }\n]', '[\n  {\n    ""source"": ""kubectl apply"",\n    ""destination"": ""pod container"",\n    ""relation_description"": ""is used to deploy"",\n    ""summary_er"": ""Kubectl apply command deploys a pod or container by applying configuration files, such as YAML or JSON manifests.""\n  }\n]', '[\n  {\n    ""source"": ""kubectl apply"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""creates a new instance of"",\n    ""summary_er"": ""The \'kubectl apply\' command creates a new instance of a pod in Kubernetes, deploying an application or service.""\n  },\n  {\n    ""source"": ""Services"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""exposes to"",\n    ""summary_er"": ""Kubernetes Services expose a pod\'s IP address and port to other pods, enabling communication between them.""\n  }\n]', '[\n  {\n    ""source"": ""Readiness Probe"",\n    ""destination"": ""Pod Container"",\n    ""relation_description"": ""is used to check the health of"",\n    ""summary_er"": ""The Readiness Probe is a mechanism that checks the health of a Pod Container, ensuring it\'s ready for use.""\n  }\n]', '[\n  {\n    ""source"": ""DNS"",\n    ""destination"": ""pod IPs"",\n    ""relation_description"": ""is used by"",\n    ""summary_er"": ""DNS is used to resolve IP addresses for pods, allowing communication between them.""\n  }\n]', '[\n  {\n    ""source"": ""kubectl exec"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""allows to execute commands on"",\n    ""summary_er"": ""Executes bash shell commands directly on a running pod, providing low-level access for troubleshooting and debugging.""\n  }\n]', '[\n  {\n    ""source"": ""kubectl"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""exec"",\n    ""summary_er"": ""Interact with a running pod using kubectl exec command, allowing for execution of commands within the container.""\n  },\n  {\n    ""source"": ""container"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""container"",\n    ""summary_er"": ""A container is an instance of a pod, providing isolation and resource allocation for applications.""\n  }\n]']","Services enable clients to discover and talk to pods using a pod's readiness probe, enabling discovery of pod IPs through DNS for headless services. Additionally, troubleshooting and modifying firewall rules in Google Kubernetes/Compute Engine, executing commands in pod containers, running bash shells in existing pods, and modifying resources with kubectl apply can be performed.","[{'highlight': 'Uses a pod container’s readiness probe to determine whether a pod should or shouldn’t be included as a service endpoint'}, {'highlight': 'Enables discovery of pod IPs through DNS when you create a headless service'}, {'highlight': 'Troubleshoot services, modify firewall rules in Google Kubernetes/Compute Engine, and execute commands in pod containers through kubectl exec'}, {'highlight': 'Modify Kubernetes resources through the kubectl apply command'}, {'highlight': 'Run an unmanaged ad hoc pod with kubectl run --generator=run-pod/v1'}]"
102,191,0,[],"159
Volumes: attaching
disk storage to containers
In the previous three chapters, we introduced pods and other Kubernetes resources
that interact with them, namely ReplicationControllers, ReplicaSets, DaemonSets,
Jobs, and Services. Now, we’re going back inside the pod to learn how its containers
can access external disk storage and/or share storage between them.
 We’ve said that pods are similar to logical hosts where processes running inside
them share resources such as CPU, RAM, network interfaces, and others. One
would expect the processes to also share disks, but that’s not the case. You’ll remem-
ber that each container in a pod has its own isolated filesystem, because the file-
system comes from the container’s image.
This chapter covers
Creating multi-container pods
Creating a volume to share disk storage between 
containers
Using a Git repository inside a pod
Attaching persistent storage such as a GCE 
Persistent Disk to pods
Using pre-provisioned persistent storage
Dynamic provisioning of persistent storage
 
",[],"[{'entity': 'Volumes', 'description': 'attaching disk storage to containers', 'category': 'software'}, {'entity': 'Kubernetes', 'description': 'container orchestration system', 'category': 'software'}, {'entity': 'Pods', 'description': 'logical hosts where processes share resources', 'category': 'software'}, {'entity': 'ReplicationControllers', 'description': 'manages replicas of a pod', 'category': 'software'}, {'entity': 'ReplicaSets', 'description': 'manages replicas of a pod', 'category': 'software'}, {'entity': 'DaemonSets', 'description': 'runs a container on each node in the cluster', 'category': 'software'}, {'entity': 'Jobs', 'description': 'runs a batch job and ensures it completes successfully', 'category': 'software'}, {'entity': 'Services', 'description': 'exposes an application to the outside world', 'category': 'software'}, {'entity': 'Containers', 'description': 'isolated filesystems for each process', 'category': 'software'}, {'entity': 'Disk storage', 'description': 'persistent storage for containers', 'category': 'hardware'}, {'entity': 'Git repository', 'description': 'version control system used inside a pod', 'category': 'software'}, {'entity': 'GCE Persistent Disk', 'description': 'persistent storage solution for Google Cloud', 'category': 'hardware'}, {'entity': 'Persistent storage', 'description': 'shared disk storage between containers', 'category': 'hardware'}]","[{'source_entity': 'Kubernetes', 'description': 'manages', 'destination_entity': 'ReplicaSets'}, {'source_entity': 'Kubernetes', 'description': 'orchestrates', 'destination_entity': 'Pods'}, {'source_entity': 'Kubernetes', 'description': 'deploys', 'destination_entity': 'Containers'}, {'source_entity': 'Kubernetes', 'description': 'manages', 'destination_entity': 'Services'}, {'source_entity': 'Kubernetes', 'description': 'orchestrates', 'destination_entity': 'Jobs'}, {'source_entity': 'Kubernetes', 'description': 'deploys', 'destination_entity': 'ReplicationControllers'}, {'source_entity': 'Kubernetes', 'description': 'manages', 'destination_entity': 'DaemonSets'}, {'source_entity': 'Kubernetes', 'description': 'orchestrates', 'destination_entity': 'Volumes'}, {'source_entity': 'Kubernetes', 'description': 'uses', 'destination_entity': 'GCE Persistent Disk'}, {'source_entity': 'Kubernetes', 'description': 'utilizes', 'destination_entity': 'Persistent storage'}, {'source_entity': 'Kubernetes', 'description': 'manages', 'destination_entity': 'Disk storage'}, {'source_entity': 'Git repository', 'description': 'stores', 'destination_entity': 'code'}, {'source_entity': 'Git repository', 'description': 'hosts', 'destination_entity': 'Containers'}, {'source_entity': 'ReplicaSets', 'description': 'ensures', 'destination_entity': 'high availability'}, {'source_entity': 'Services', 'description': 'provides', 'destination_entity': 'load balancing'}, {'source_entity': 'Pods', 'description': 'runs', 'destination_entity': 'Containers'}, {'source_entity': 'Jobs', 'description': 'executes', 'destination_entity': 'tasks'}, {'source_entity': 'ReplicationControllers', 'description': 'ensures', 'destination_entity': 'replication'}, {'source_entity': 'DaemonSets', 'description': 'deploys', 'destination_entity': 'Containers'}, {'source_entity': 'Volumes', 'description': 'provides', 'destination_entity': 'persistent storage'}]","['[\n  {\n    ""source"": ""Kubernetes"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""manages"",\n    ""summary_er"": ""Kubernetes manages pods, ensuring they run as expected.""\n  },\n  {\n    ""source"": ""Kubernetes"",\n    ""destination"": ""ReplicaSets"",\n    ""relation_description"": ""manages"",\n    ""summary_er"": ""Kubernetes manages ReplicaSets, maintaining desired replica counts.""\n  }\n]', '[\n  {\n    ""source"": ""Kubernetes"",\n    ""destination"": ""Pods"",\n    ""relation_description"": ""orchestrates"",\n    ""summary_er"": ""Kubernetes manages and coordinates multiple pods, ensuring efficient resource utilization and scalability.""\n  }\n]', '[\n  {\n    ""source"": ""Kubernetes"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""deploys"",\n    ""summary_er"": ""Kubernetes deploys containers to pods, managing their lifecycle and resources.""\n  }\n]', '[{\n  ""source"": ""Kubernetes"",\n  ""destination"": ""pod"",\n  ""relation_description"": ""manages"",\n  ""summary_er"": ""Kubernetes manages and orchestrates containerized applications, including pods, which are the basic execution unit in a Kubernetes cluster.""\n}]', '[\n  {\n    ""source"": ""Kubernetes"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""orchestrates"",\n    ""summary_er"": ""Kubernetes manages and orchestrates containerized applications, including pods, which are the basic execution unit in a Kubernetes cluster.""\n  }\n]', '[\n  {\n    ""source"": ""Kubernetes"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""deploys"",\n    ""summary_er"": ""Kubernetes deploys pods, which are the basic execution units in a containerized application.""\n  }\n]', '[\n  {\n    ""source"": ""Kubernetes"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""manages"",\n    ""summary_er"": ""Kubernetes manages pods by scheduling them on worker nodes, ensuring efficient resource utilization.""\n  }\n]', '[\n  {\n    ""source"": ""Kubernetes"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""orchestrates"",\n    ""summary_er"": ""Kubernetes manages and coordinates the execution of pods, ensuring efficient resource utilization and scalability.""\n  },\n  {\n    ""source"": ""Kubernetes"",\n    ""destination"": ""Volumes"",\n    ""relation_description"": ""manages"",\n    ""summary_er"": ""Kubernetes provides a way to manage persistent data storage for applications through volumes, ensuring data persistence across pod restarts or failures.""\n  }\n]', '[\n  {\n    ""source"": ""Kubernetes"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""uses"",\n    ""summary_er"": ""Kubernetes manages and orchestrates containerized applications, including pods, which are the basic execution unit in Kubernetes.""\n  },\n  {\n    ""source"": ""Kubernetes"",\n    ""destination"": ""GCE Persistent Disk"",\n    ""relation_description"": ""uses"",\n    ""summary_er"": ""Kubernetes can utilize GCE Persistent Disks as persistent storage solutions for its applications, ensuring data durability and high availability.""\n  }\n]', '[\n  {\n    ""source"": ""Kubernetes"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""utilizes"",\n    ""summary_er"": ""Kubernetes manages and orchestrates pods, utilizing their resources to run containerized applications.""\n  },\n  {\n    ""source"": ""Kubernetes"",\n    ""destination"": ""Persistent storage"",\n    ""relation_description"": ""utilizes"",\n    ""summary_er"": ""Kubernetes utilizes persistent storage for pod data persistence, ensuring that data is retained even after pod termination.""\n  }\n]', '[\n  {\n    ""source"": ""Kubernetes"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""manages"",\n    ""summary_er"": ""Kubernetes manages containerized applications and services, including pods, which are the basic execution unit in a Kubernetes cluster.""\n  }\n]', '[\n  {\n    ""source"": ""Git repository"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""stores"",\n    ""summary_er"": ""A Git repository stores its code in a pod, which is a containerized environment for running applications.""\n  }\n]', '[\n  {\n    ""source"": ""Git repository"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""hosts"",\n    ""summary_er"": ""A Git repository is hosted on a pod, which is a containerized environment that runs containers.""\n  },\n  {\n    ""source"": ""pod"",\n    ""destination"": ""Containers"",\n    ""relation_description"": ""runs"",\n    ""summary_er"": ""A pod runs one or more containers, which are lightweight and portable execution environments.""\n  }\n]', '[\n  {\n    ""source"": ""ReplicaSets"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""ensures"",\n    ""summary_er"": ""ReplicaSets ensure high availability of pods by maintaining a specified number of replicas, guaranteeing that a minimum number of pods are running at any given time.""\n  }\n]', '[\n  {\n    ""source"": ""Services"",\n    ""destination"": ""Pod"",\n    ""relation_description"": ""provides"",\n    ""summary_er"": ""Services provide a load balancer to distribute traffic across multiple Pods, ensuring efficient resource utilization and high availability.""\n  }\n]', '[\n  {\n    ""source"": ""Pods"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""runs"",\n    ""summary_er"": ""A Pod is a logical host for one or more containers, providing shared resources such as network and storage.""\n  }\n]', '[\n  {\n    ""source"": ""Jobs"",\n    ""destination"": ""Pods"",\n    ""relation_description"": ""executes"",\n    ""summary_er"": ""Jobs execute tasks by running containers, which are managed by Pods in a Kubernetes cluster.""\n  }\n]', '[\n  {\n    ""source"": ""ReplicationControllers"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""ensures"",\n    ""summary_er"": ""Replication Controllers guarantee a specified number of replicas (identical copies) of a Pod are running at any given time.""\n  }\n]', '[\n  {\n    ""source"": ""DaemonSets"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""deploys"",\n    ""summary_er"": ""A DaemonSet ensures a specified number of replicas (i.e., copies) of a pod are deployed across all nodes in a cluster.""\n  }\n]', '[{\n  ""source"": ""Volumes"",\n  ""destination"": ""pod"",\n  ""relation_description"": ""provides"",\n  ""summary_er"": ""Volumes provide persistent storage to pods, allowing them to access and utilize shared data.""\n}]']","This chapter explores how containers in a pod can access external disk storage and share storage between them. Containers have isolated file systems, but volumes allow sharing disk space. Topics include creating multi-container pods, using Git repositories inside pods, attaching persistent storage, and dynamic provisioning of persistent storage.","[{'highlight': ""Pods have isolated filesystems, with each container having its own filesystem because it comes from the container's image.""}, {'highlight': 'Volumes can be used to share disk storage between containers in a pod, allowing them to access external disk storage and/or share storage between them.'}, {'highlight': 'Kubernetes provides various ways to attach persistent storage to pods, including creating a volume, using a Git repository inside a pod, attaching a GCE Persistent Disk, and dynamic provisioning of persistent storage.'}, {'highlight': 'Multi-container pods can be created in Kubernetes, allowing multiple containers to run together within a single pod.'}, {'highlight': 'Persistent storage can be pre-provisioned or dynamically provisioned in Kubernetes, providing flexibility for containerized applications that require disk storage.'}]"
103,192,0,[],"160
CHAPTER 6
Volumes: attaching disk storage to containers
 Every new container starts off with the exact set of files that was added to the image
at build time. Combine this with the fact that containers in a pod get restarted (either
because the process died or because the liveness probe signaled to Kubernetes that
the container wasn’t healthy anymore) and you’ll realize that the new container will
not see anything that was written to the filesystem by the previous container, even
though the newly started container runs in the same pod.
 In certain scenarios you want the new container to continue where the last one fin-
ished, such as when restarting a process on a physical machine. You may not need (or
want) the whole filesystem to be persisted, but you do want to preserve the directories
that hold actual data.
 Kubernetes provides this by defining storage volumes. They aren’t top-level resources
like pods, but are instead defined as a part of a pod and share the same lifecycle as the
pod. This means a volume is created when the pod is started and is destroyed when
the pod is deleted. Because of this, a volume’s contents will persist across container
restarts. After a container is restarted, the new container can see all the files that were
written to the volume by the previous container. Also, if a pod contains multiple con-
tainers, the volume can be used by all of them at once. 
6.1
Introducing volumes
Kubernetes volumes are a component of a pod and are thus defined in the pod’s spec-
ification—much like containers. They aren’t a standalone Kubernetes object and can-
not be created or deleted on their own. A volume is available to all containers in the
pod, but it must be mounted in each container that needs to access it. In each con-
tainer, you can mount the volume in any location of its filesystem.
6.1.1
Explaining volumes in an example
Imagine you have a pod with three containers (shown in figure 6.1). One container
runs a web server that serves HTML pages from the /var/htdocs directory and stores
the access log to /var/logs. The second container runs an agent that creates HTML
files and stores them in /var/html. The third container processes the logs it finds in
the /var/logs directory (rotates them, compresses them, analyzes them, or whatever).
 Each container has a nicely defined single responsibility, but on its own each con-
tainer wouldn’t be of much use. Creating a pod with these three containers without
them sharing disk storage doesn’t make any sense, because the content generator
would write the generated HTML files inside its own container and the web server
couldn’t access those files, as it runs in a separate isolated container. Instead, it would
serve an empty directory or whatever you put in the /var/htdocs directory in its con-
tainer image. Similarly, the log rotator would never have anything to do, because its
/var/logs directory would always remain empty with nothing writing logs there. A pod
with these three containers and no volumes basically does nothing.
 But if you add two volumes to the pod and mount them at appropriate paths inside
the three containers, as shown in figure 6.2, you’ve created a system that’s much more
 
",[],"[{'entity': 'container', 'description': 'A lightweight and standalone executable package of software', 'category': 'software'}, {'entity': 'pod', 'description': 'The basic execution unit in Kubernetes, consisting of one or more containers', 'category': 'application'}, {'entity': 'volume', 'description': 'A component of a pod that provides persistent storage for containers', 'category': 'database'}, {'entity': 'filesystem', 'description': 'A system of organizing and storing files on a computer', 'category': 'hardware'}, {'entity': 'image', 'description': ""A snapshot of a container's filesystem at a particular point in time"", 'category': 'software'}, {'entity': 'liveness probe', 'description': 'A mechanism for detecting whether a container is running correctly or not', 'category': 'process'}, {'entity': 'Kubernetes', 'description': 'An open-source container orchestration system', 'category': 'application'}, {'entity': '/var/htdocs', 'description': 'A directory in the filesystem used by containers to serve HTML pages', 'category': 'filesystem'}, {'entity': '/var/logs', 'description': 'A directory in the filesystem used by containers to store logs', 'category': 'filesystem'}, {'entity': '/var/html', 'description': 'A directory in the filesystem used by containers to create and store HTML files', 'category': 'filesystem'}, {'entity': 'web server', 'description': 'A software application that serves HTTP requests and returns web pages', 'category': 'application'}, {'entity': 'agent', 'description': 'A software component that performs a specific task or function', 'category': 'process'}, {'entity': 'log rotator', 'description': 'A software component that rotates, compresses, and analyzes logs', 'category': 'process'}]","[{'source_entity': '""container""', 'description': 'runs on', 'destination_entity': '""Kubernetes""'}, {'source_entity': '""image""', 'description': 'is based on', 'destination_entity': '""container""'}, {'source_entity': '""liveness probe""', 'description': 'monitors the health of', 'destination_entity': '""pod""'}, {'source_entity': '""volume""', 'description': 'stores data for', 'destination_entity': '""container""'}, {'source_entity': '""log rotator""', 'description': 'manages logs for', 'destination_entity': '""web server""'}, {'source_entity': '""agent""', 'description': 'collects data from', 'destination_entity': '""filesystem""'}, {'source_entity': '""Kubernetes""', 'description': 'orchestrates the deployment of', 'destination_entity': '""pod""'}, {'source_entity': '""web server""', 'description': 'serves content from', 'destination_entity': '""/var/html""'}, {'source_entity': '""log rotator""', 'description': 'rotates logs for', 'destination_entity': '""/var/logs""'}, {'source_entity': '""container""', 'description': 'uses', 'destination_entity': '""volume""'}, {'source_entity': '""pod""', 'description': 'runs a', 'destination_entity': '""container""'}]","['[\n  {\n    ""source"": ""container"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""runs on"",\n    ""summary_er"": ""A container executes its code within a pod, utilizing shared resources and networking.""\n  },\n  {\n    ""source"": ""Kubernetes"",\n    ""destination"": ""container"",\n    ""relation_description"": ""hosts"",\n    ""summary_er"": ""Kubernetes manages containers, providing orchestration, scaling, and resource allocation.""\n  }\n]', '[\n  {\n    ""source"": ""image"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""is based on"",\n    ""summary_er"": ""An image is used as a base for creating a container, which is then run inside a pod.""\n  },\n  {\n    ""source"": ""container"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""runs inside"",\n    ""summary_er"": ""A container runs within a pod, sharing the same network and storage resources.""\n  }\n]', '[\n  {\n    ""source"": ""liveness probe"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""monitors the health of"",\n    ""summary_er"": ""The liveness probe ensures a container\'s health by periodically checking its responsiveness, restarting it if necessary to maintain pod stability.""\n  }\n]', '[\n  {\n    ""source"": ""volume"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""stores data for"",\n    ""summary_er"": ""A volume provides persistent storage for a pod, allowing it to store and retrieve data even after it\'s deleted.""\n  }\n]', '[\n  {\n    ""source"": ""log rotator"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""manages logs for"",\n    ""summary_er"": ""The log rotator manages logs for a pod, ensuring efficient storage and retrieval of log data.""\n  },\n  {\n    ""source"": ""web server"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""serves web content to"",\n    ""summary_er"": ""A web server serves web content to a pod, providing users with access to web-based applications and services.""\n  }\n]', '[\n  {\n    ""source"": ""agent"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""collects data from"",\n    ""summary_er"": ""The agent collects data from a pod, utilizing its resources to gather information.""\n  },\n  {\n    ""source"": ""pod"",\n    ""destination"": ""filesystem"",\n    ""relation_description"": ""stores data in"",\n    ""summary_er"": ""A pod stores data in the filesystem, ensuring secure and organized storage of collected information.""\n  }\n]', '[\n  {\n    ""source"": ""Kubernetes"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""orchestrates the deployment of"",\n    ""summary_er"": ""Kubernetes manages the lifecycle of pods, ensuring efficient resource utilization and scalability.""\n  }\n]', '[\n  {\n    ""source"": ""web server"",\n    ""destination"": ""/var/html"",\n    ""relation_description"": ""serves content from"",\n    ""summary_er"": ""The web server serves static HTML content from the /var/html directory.""\n  }\n]', '[\n  {\n    ""source"": ""log rotator"",\n    ""destination"": ""/var/logs"",\n    ""relation_description"": ""rotates logs for"",\n    ""summary_er"": ""The log rotator periodically rotates and manages log files in the /var/logs directory to maintain disk space and improve system performance.""\n  }\n]', '[\n  {\n    ""source"": ""container"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""uses"",\n    ""summary_er"": ""A container utilizes a pod\'s resources, running as an application within it.""\n  },\n  {\n    ""source"": ""volume"",\n    ""destination"": ""pod"",\n    ""relation_description"": """",\n    ""summary_er"": ""A volume is mounted to a pod, providing persistent storage for its applications.""\n  }\n]', '[\n  {\n    ""source"": ""pod"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""runs a"",\n    ""summary_er"": ""A pod in Kubernetes runs one or more containers, which are the actual running processes.""\n  },\n  {\n    ""source"": ""container"",\n    ""destination"": ""pod"",\n    ""relation_description"": """",\n    ""summary_er"": ""A container is a lightweight and portable way to run an application, which can be deployed within a pod in Kubernetes.""\n  }\n]']","Kubernetes provides storage volumes that allow new containers to continue where the last one finished, preserving directories with actual data across container restarts. Volumes are defined in a pod's specification and must be mounted in each container that needs to access it, allowing multiple containers to share disk storage and enabling them to work together effectively.","[{'highlight': 'Kubernetes provides storage volumes to preserve directories that hold actual data across container restarts.'}, {'highlight': 'Volumes are a component of a pod and must be mounted in each container that needs to access it.'}, {'highlight': 'A pod with multiple containers can share the same volume, allowing them to access and write files together.'}, {'highlight': 'Each container in a pod has its own filesystem, but volumes provide a shared storage space for all containers.'}, {'highlight': 'Volumes are created when the pod is started and destroyed when the pod is deleted, preserving their contents across restarts.'}]"
104,193,0,[],"161
Introducing volumes
Pod
Container: WebServer
Filesystem
Webserver
process
Writes
Reads
/
var/
htdocs/
logs/
Container: ContentAgent
Filesystem
ContentAgent
process
Writes
/
var/
html/
Container: LogRotator
Filesystem
LogRotator
process
Reads
/
var/
logs/
Figure 6.1
Three containers of the 
same pod without shared storage
Pod
Container: WebServer
Filesystem
/
var/
htdocs/
logs/
Container: ContentAgent
Filesystem
/
var/
html/
Container: LogRotator
Filesystem
/
var/
logs/
Volume:
publicHtml
Volume:
logVol
Figure 6.2
Three containers sharing two 
volumes mounted at various mount paths
 
",[],"[{'entity': 'Pod', 'description': 'A group of one or more containers that share resources and networking', 'category': 'container'}, {'entity': 'Container: WebServer', 'description': 'A container running a web server process', 'category': 'application'}, {'entity': 'Filesystem', 'description': 'An abstraction layer for accessing files on disk', 'category': 'software'}, {'entity': 'Webserver', 'description': 'A process running a web server application', 'category': 'process'}, {'entity': 'writes', 'description': 'The act of writing data to a file or storage device', 'category': 'process'}, {'entity': 'reads', 'description': 'The act of reading data from a file or storage device', 'category': 'process'}, {'entity': '/', 'description': 'The root directory of the filesystem', 'category': 'filesystem'}, {'entity': '/var/', 'description': 'A subdirectory of the filesystem for storing variable data', 'category': 'filesystem'}, {'entity': '/htdocs/', 'description': 'A subdirectory of the filesystem for storing web server files', 'category': 'filesystem'}, {'entity': '/logs/', 'description': 'A subdirectory of the filesystem for storing log files', 'category': 'filesystem'}, {'entity': 'Container: ContentAgent', 'description': 'A container running a content agent process', 'category': 'application'}, {'entity': 'Filesystem', 'description': 'An abstraction layer for accessing files on disk', 'category': 'software'}, {'entity': 'ContentAgent', 'description': 'A process running a content agent application', 'category': 'process'}, {'entity': 'writes', 'description': 'The act of writing data to a file or storage device', 'category': 'process'}, {'entity': '/var/', 'description': 'A subdirectory of the filesystem for storing variable data', 'category': 'filesystem'}, {'entity': '/html/', 'description': 'A subdirectory of the filesystem for storing HTML files', 'category': 'filesystem'}, {'entity': 'Container: LogRotator', 'description': 'A container running a log rotator process', 'category': 'application'}, {'entity': 'Filesystem', 'description': 'An abstraction layer for accessing files on disk', 'category': 'software'}, {'entity': 'LogRotator', 'description': 'A process running a log rotator application', 'category': 'process'}, {'entity': 'reads', 'description': 'The act of reading data from a file or storage device', 'category': 'process'}, {'entity': '/var/', 'description': 'A subdirectory of the filesystem for storing variable data', 'category': 'filesystem'}, {'entity': '/logs/', 'description': 'A subdirectory of the filesystem for storing log files', 'category': 'filesystem'}, {'entity': 'Volume: publicHtml', 'description': 'A shared storage volume for web server files', 'category': 'storage'}, {'entity': 'Volume: logVol', 'description': 'A shared storage volume for log files', 'category': 'storage'}]","[{'source_entity': 'ContentAgent', 'description': 'writes to', 'destination_entity': '/var/'}, {'source_entity': 'Container: ContentAgent', 'description': 'contains', 'destination_entity': '/var/'}, {'source_entity': 'Pod', 'description': 'hosts', 'destination_entity': 'Container: ContentAgent'}, {'source_entity': 'ContentAgent', 'description': 'writes to', 'destination_entity': '/html/'}, {'source_entity': 'Container: WebServer', 'description': 'contains', 'destination_entity': '/html/'}, {'source_entity': 'Pod', 'description': 'hosts', 'destination_entity': 'Container: WebServer'}, {'source_entity': 'ContentAgent', 'description': 'reads from', 'destination_entity': '/htdocs/'}, {'source_entity': 'Container: ContentAgent', 'description': 'contains', 'destination_entity': '/htdocs/'}, {'source_entity': 'Pod', 'description': 'hosts', 'destination_entity': 'Container: ContentAgent'}, {'source_entity': 'ContentAgent', 'description': 'reads from', 'destination_entity': '/'}, {'source_entity': 'Webserver', 'description': 'uses', 'destination_entity': '/'}, {'source_entity': 'Container: LogRotator', 'description': 'contains', 'destination_entity': '/logs/'}, {'source_entity': 'Pod', 'description': 'hosts', 'destination_entity': 'Container: LogRotator'}, {'source_entity': 'ContentAgent', 'description': 'writes to', 'destination_entity': '/logs/'}, {'source_entity': 'Container: LogRotator', 'description': 'contains', 'destination_entity': '/logs/'}, {'source_entity': 'Pod', 'description': 'hosts', 'destination_entity': 'Container: LogRotator'}, {'source_entity': 'Webserver', 'description': 'uses', 'destination_entity': 'Volume: logVol'}]","['[\n  {\n    ""source"": ""ContentAgent"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""writes to"",\n    ""summary_er"": ""A content agent writes data to a containerized application running in a pod, storing it in the /var directory.""\n  }\n]', '[\n  {\n    ""source"": ""ContentAgent"",\n    ""destination"": ""/var/"",\n    ""relation_description"": ""contains"",\n    ""summary_er"": ""The ContentAgent contains data stored in the /var/ directory of a container.""\n  }\n]', '[\n  {\n    ""source"": ""Pod"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""hosts"",\n    ""summary_er"": ""A Pod in Kubernetes hosts one or more containers, including the Container: ContentAgent.""\n  },\n  {\n    ""source"": ""Container"",\n    ""destination"": ""ContentAgent"",\n    ""relation_description"": """",\n    ""summary_er"": """"\n  }\n]', '[\n  {\n    ""source"": ""ContentAgent"",\n    ""destination"": ""/html/"",\n    ""relation_description"": ""writes to"",\n    ""summary_er"": ""A content agent generates HTML content by writing to a pod.""\n  }\n]', '[\n  {\n    ""source"": ""Container"",\n    ""destination"": ""WebServer"",\n    ""relation_description"": ""contains"",\n    ""summary_er"": ""A container named WebServer that holds HTML files.""\n  }\n]', '[\n  {\n    ""source"": ""Pod"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""hosts"",\n    ""summary_er"": ""A Pod is a logical host for one or more containers, providing shared resources and isolation.""\n  },\n  {\n    ""source"": ""Container"",\n    ""destination"": ""WebServer"",\n    ""relation_description"": """",\n    ""summary_er"": ""A WebServer container runs a web server application, handling HTTP requests and serving responses.""\n  }\n]', '[\n  {\n    ""source"": ""ContentAgent"",\n    ""destination"": ""/htdocs/"",\n    ""relation_description"": ""reads from"",\n    ""summary_er"": ""A content agent retrieves data from a web server directory, specifically /htdocs/, to serve web pages.""\n  }\n]', '[\n  {\n    ""source"": ""ContentAgent"",\n    ""destination"": ""/htdocs/"",\n    ""relation_description"": ""contains"",\n    ""summary_er"": ""The ContentAgent contains files in the /htdocs/ directory, which is a standard location for web server content.""\n  }\n]', '[\n  {\n    ""source"": ""Pod"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""hosts"",\n    ""summary_er"": ""A Pod hosts one or more containers, providing a shared environment for them to run in.""\n  },\n  {\n    ""source"": ""Container"",\n    ""destination"": ""ContentAgent"",\n    ""relation_description"": """",\n    ""summary_er"": """"\n  }\n]', '[\n  {\n    ""source"": ""ContentAgent"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""reads from"",\n    ""summary_er"": ""A content agent, such as a user or application, reads data from a pod in Kubernetes.""\n  }\n]', '[\n  {\n    ""source"": ""Webserver"",\n    ""destination"": ""/"",\n    ""relation_description"": ""uses"",\n    ""summary_er"": ""The webserver utilizes the root directory \'/\' to serve HTTP requests.""\n  }\n]', '[\n  {\n    ""source"": ""LogRotator"",\n    ""destination"": ""/logs/"",\n    ""relation_description"": ""contains"",\n    ""summary_er"": ""The LogRotator container holds log files in the /logs/ directory, ensuring efficient storage and management of logs.""\n  }\n]', '[\n  {\n    ""source"": ""Pod"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""hosts"",\n    ""summary_er"": ""A Pod hosts one or more containers, providing a shared environment for them to run in.""\n  },\n  {\n    ""source"": ""Container"",\n    ""destination"": ""LogRotator"",\n    ""relation_description"": """",\n    ""summary_er"": ""LogRotator is a container that manages and rotates logs within a Kubernetes cluster.""\n  }\n]', '[\n  {\n    ""source"": ""ContentAgent"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""writes to"",\n    ""summary_er"": ""A content agent generates logs in a pod, writing data to the /logs/ directory.""\n  }\n]', '[\n  {\n    ""source"": ""LogRotator"",\n    ""destination"": ""/logs/"",\n    ""relation_description"": ""contains"",\n    ""summary_er"": ""LogRotator is a container that stores logs in the /logs/ directory, containing log files.""\n  }\n]', '[\n  {\n    ""source"": ""Pod"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""hosts"",\n    ""summary_er"": ""A Pod hosts one or more containers, providing a shared environment for their execution.""\n  },\n  {\n    ""source"": ""Container"",\n    ""destination"": ""LogRotator"",\n    ""relation_description"": """",\n    ""summary_er"": ""A LogRotator is a type of container that manages and rotates log files in a Kubernetes cluster.""\n  }\n]', '[\n  {\n    ""source"": ""Webserver"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""uses"",\n    ""summary_er"": ""A web server utilizes a pod to provide dynamic content and services.""\n  },\n  {\n    ""source"": ""Volume"",\n    ""destination"": ""logVol"",\n    ""relation_description"": ""uses"",\n    ""summary_er"": ""A volume named logVol is utilized by the system for logging purposes.""\n  }\n]']","The document introduces the concept of volumes in Kubernetes, where multiple containers within a pod can share storage without relying on shared filesystems. Three containers are used as examples: WebServer, ContentAgent, and LogRotator, each with its own filesystem but sharing two volumes, publicHtml and logVol, mounted at different paths to illustrate this concept.","[{'highlight': 'Introducing volumes'}, {'highlight': 'Pod: Container: WebServer, Filesystem: /var/htdocs/logs/'}, {'highlight': 'Container: ContentAgent, Filesystem: /var/html/, Writes to /var/html/'}, {'highlight': 'Container: LogRotator, Filesystem: /var/logs/, Reads from /var/logs/'}, {'highlight': 'Two volumes (publicHtml and logVol) shared among three containers'}]"
105,194,0,[],"162
CHAPTER 6
Volumes: attaching disk storage to containers
than the sum of its parts. Linux allows you to mount a filesystem at arbitrary locations
in the file tree. When you do that, the contents of the mounted filesystem are accessi-
ble in the directory it’s mounted into. By mounting the same volume into two contain-
ers, they can operate on the same files. In your case, you’re mounting two volumes in
three containers. By doing this, your three containers can work together and do some-
thing useful. Let me explain how.
 First, the pod has a volume called publicHtml. This volume is mounted in the Web-
Server container at /var/htdocs, because that’s the directory the web server serves
files from. The same volume is also mounted in the ContentAgent container, but at
/var/html, because that’s where the agent writes the files to. By mounting this single vol-
ume like that, the web server will now serve the content generated by the content agent.
 Similarly, the pod also has a volume called logVol for storing logs. This volume is
mounted at /var/logs in both the WebServer and the LogRotator containers. Note
that it isn’t mounted in the ContentAgent container. The container cannot access its
files, even though the container and the volume are part of the same pod. It’s not
enough to define a volume in the pod; you need to define a VolumeMount inside the
container’s spec also, if you want the container to be able to access it.
 The two volumes in this example can both initially be empty, so you can use a type
of volume called emptyDir. Kubernetes also supports other types of volumes that are
either populated during initialization of the volume from an external source, or an
existing directory is mounted inside the volume. This process of populating or mount-
ing a volume is performed before the pod’s containers are started. 
 A volume is bound to the lifecycle of a pod and will stay in existence only while the
pod exists, but depending on the volume type, the volume’s files may remain intact
even after the pod and volume disappear, and can later be mounted into a new vol-
ume. Let’s see what types of volumes exist.
6.1.2
Introducing available volume types
A wide variety of volume types is available. Several are generic, while others are spe-
cific to the actual storage technologies used underneath. Don’t worry if you’ve never
heard of those technologies—I hadn’t heard of at least half of them. You’ll probably
only use volume types for the technologies you already know and use. Here’s a list of
several of the available volume types:

emptyDir—A simple empty directory used for storing transient data.

hostPath—Used for mounting directories from the worker node’s filesystem
into the pod.

gitRepo—A volume initialized by checking out the contents of a Git repository.

nfs—An NFS share mounted into the pod.

gcePersistentDisk (Google Compute Engine Persistent Disk), awsElastic-
BlockStore (Amazon Web Services Elastic Block Store Volume), azureDisk
(Microsoft Azure Disk Volume)—Used for mounting cloud provider-specific
storage.
 
",[],"[{'entity': 'Linux', 'description': 'Operating System', 'category': 'software'}, {'entity': 'filesystem', 'description': 'A storage system that organizes files and directories', 'category': 'hardware'}, {'entity': 'volume', 'description': 'A directory or file system mounted into a container', 'category': 'software'}, {'entity': 'container', 'description': 'A lightweight and standalone execution environment', 'category': 'software'}, {'entity': 'pod', 'description': 'The basic execution unit in Kubernetes', 'category': 'software'}, {'entity': 'Web-Server container', 'description': 'A container running a web server', 'category': 'software'}, {'entity': 'ContentAgent container', 'description': 'A container generating content for the web server', 'category': 'software'}, {'entity': 'LogRotator container', 'description': 'A container rotating logs for the web server', 'category': 'software'}, {'entity': 'publicHtml volume', 'description': 'A shared directory between containers serving HTML files', 'category': 'software'}, {'entity': 'logVol volume', 'description': 'A shared directory for storing logs', 'category': 'software'}, {'entity': 'emptyDir', 'description': 'A type of volume initialized as an empty directory', 'category': 'software'}, {'entity': 'hostPath', 'description': 'A type of volume mounting directories from the host filesystem', 'category': 'software'}, {'entity': 'gitRepo', 'description': 'A type of volume initialized by checking out a Git repository', 'category': 'software'}, {'entity': 'nfs', 'description': 'A type of volume mounting an NFS share', 'category': 'software'}, {'entity': 'gcePersistentDisk', 'description': 'A type of volume for Google Compute Engine Persistent Disk storage', 'category': 'hardware'}, {'entity': 'awsElastic-BlockStore', 'description': 'A type of volume for Amazon Web Services Elastic Block Store Volume storage', 'category': 'hardware'}, {'entity': 'azureDisk', 'description': 'A type of volume for Microsoft Azure Disk Volume storage', 'category': 'hardware'}]","[{'source_entity': '""container""', 'description': 'is deployed using', 'destination_entity': '""Kubernetes""'}, {'source_entity': '""Linux""', 'description': 'is used as the operating system for', 'destination_entity': '""container""'}, {'source_entity': '""awsElastic-BlockStore""', 'description': 'provides persistent storage for', 'destination_entity': '""pod""'}, {'source_entity': '""publicHtml volume""', 'description': 'is used to store web content for', 'destination_entity': '""Web-Server container""'}, {'source_entity': '""gitRepo""', 'description': 'stores the source code for', 'destination_entity': '""ContentAgent container""'}, {'source_entity': '""volume""', 'description': 'is used to store data for', 'destination_entity': '""LogRotator container""'}, {'source_entity': '""gcePersistentDisk""', 'description': 'provides persistent storage for', 'destination_entity': '""pod""'}, {'source_entity': '""filesystem""', 'description': 'is used to store data for', 'destination_entity': '""container""'}, {'source_entity': '""LogRotator container""', 'description': 'rotates logs for', 'destination_entity': '""Web-Server container""'}, {'source_entity': '""pod""', 'description': 'is managed by', 'destination_entity': '""Kubernetes""'}, {'source_entity': '""azureDisk""', 'description': 'provides persistent storage for', 'destination_entity': '""pod""'}, {'source_entity': '""hostPath""', 'description': 'is used to store data on the host machine for', 'destination_entity': '""container""'}, {'source_entity': '""nfs""', 'description': 'provides network file system access for', 'destination_entity': '""container""'}, {'source_entity': '""Web-Server container""', 'description': 'serves web content from', 'destination_entity': '""publicHtml volume""'}, {'source_entity': '""ContentAgent container""', 'description': 'manages content for', 'destination_entity': '""gitRepo""'}, {'source_entity': '""logVol volume""', 'description': 'is used to store logs for', 'destination_entity': '""LogRotator container""'}, {'source_entity': '""emptyDir""', 'description': 'is used as a temporary storage for', 'destination_entity': '""container""'}]","['[\n  {\n    ""source"": ""container"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""is deployed using"",\n    ""summary_er"": ""A container is deployed within a pod in Kubernetes, utilizing the pod\'s resources and providing isolation for the container.""\n  }\n]', '[\n  {\n    ""source"": ""Linux"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""is used as the operating system for"",\n    ""summary_er"": ""Linux is the underlying OS for a pod, providing essential services and functionality.""\n  },\n  {\n    ""source"": ""pod"",\n    ""destination"": ""container"",\n    ""relation_description"": ""is run within"",\n    ""summary_er"": ""A container is executed within a pod, sharing resources and dependencies.""\n  }\n]', '[\n  {\n    ""source"": ""awsElastic-BlockStore"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""provides persistent storage for"",\n    ""summary_er"": ""AWS Elastic Block Store provides persistent storage for pods, enabling them to maintain data even after restarts or terminations.""\n  }\n]', '[\n  {\n    ""source"": ""publicHtml volume"",\n    ""destination"": ""Web-Server container"",\n    ""relation_description"": ""is used to store web content for"",\n    ""summary_er"": ""The public HTML volume stores web content within the Web-Server container, serving as a storage unit for dynamic website data.""\n  }\n]', '[\n  {\n    ""source"": ""gitRepo"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""stores the source code for"",\n    ""summary_er"": ""A git repository stores its source code within a pod, enabling version control and deployment.""\n  },\n  {\n    ""source"": ""ContentAgent container"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""runs inside"",\n    ""summary_er"": ""A ContentAgent container runs inside a pod, providing a runtime environment for content processing.""\n  }\n]', '[\n  {\n    ""source"": ""volume"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""is used to store data for"",\n    ""summary_er"": ""A volume is a storage entity that stores data for a pod, providing persistent storage and access to files.""\n  },\n  {\n    ""source"": ""LogRotator container"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""is used to"",\n    ""summary_er"": ""The LogRotator container is used within a pod to manage and rotate logs, ensuring efficient log management and cleanup.""\n  }\n]', '[\n  {\n    ""source"": ""gcePersistentDisk"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""provides persistent storage for"",\n    ""summary_er"": ""A Google Compute Engine Persistent Disk provides persistent storage for a pod, allowing it to store data even after it is deleted.""\n  }\n]', '[\n  {\n    ""source"": ""filesystem"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""is used to store data for"",\n    ""summary_er"": ""A filesystem is utilized by a pod to store its data, enabling efficient management and access.""\n  },\n  {\n    ""source"": ""container"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""is used to run"",\n    ""summary_er"": ""A container is executed within a pod to provide isolation and resource allocation for the application.""\n  }\n]', '[\n  {\n    ""source"": ""LogRotator container"",\n    ""destination"": ""Web-Server container"",\n    ""relation_description"": ""rotates logs for"",\n    ""summary_er"": ""The LogRotator container rotates logs for the Web-Server container to maintain log cleanliness and prevent disk space issues.""\n  }\n]', '[\n  {\n    ""source"": ""Kubernetes"",\n    ""destination"": ""Pod"",\n    ""relation_description"": ""is managed by"",\n    ""summary_er"": ""Kubernetes manages pods, ensuring they run smoothly and efficiently.""\n  }\n]', '[\n  {\n    ""source"": ""azureDisk"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""provides persistent storage for"",\n    ""summary_er"": ""Azure Disk provides persistent storage for pods, enabling them to store data even after they are deleted.""\n  }\n]', '[\n  {\n    ""source"": ""hostPath"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""is used to store data on the host machine for"",\n    ""summary_er"": ""HostPath is a Kubernetes volume type that allows storing data directly on the host machine, making it accessible to pods.""\n  },\n  {\n    ""source"": ""container"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""is a runtime environment for"",\n    ""summary_er"": ""A container is a lightweight and isolated process that runs within a pod, providing a consistent and reliable execution environment.""\n  }\n]', '[\n  {\n    ""source"": ""nfs"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""provides network file system access for"",\n    ""summary_er"": ""The NFS provides a shared file system for pods to access, enabling them to share files and data.""\n  }\n]', '[\n  {\n    ""source"": ""Web-Server container"",\n    ""destination"": ""publicHtml volume"",\n    ""relation_description"": ""serves web content from"",\n    ""summary_er"": ""The Web-Server container serves web content from the publicHtml volume, providing a connection between the application\'s code and its data.""\n  }\n]', '[\n  {\n    ""source"": ""ContentAgent container"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""manages content for"",\n    ""summary_er"": ""The ContentAgent container manages content within a pod, ensuring its proper functioning and maintenance.""\n  }\n]', '[\n  {\n    ""source"": ""logVol"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""is used to store logs for"",\n    ""summary_er"": ""The log volume is utilized by a pod to store its logs, enabling logging functionality.""\n  }\n]', '[\n  {\n    ""source"": ""emptyDir"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""temporary storage"",\n    ""summary_er"": ""Empty Dir is used as a temporary storage for pods in Kubernetes.""\n  },\n  {\n    ""source"": ""container"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""execution environment"",\n    ""summary_er"": ""Container provides an execution environment for applications running inside a pod in Kubernetes.""\n  }\n]']","Volumes in Kubernetes allow attaching disk storage to containers, enabling them to operate on the same files. A volume is bound to a pod's lifecycle and can be mounted at arbitrary locations within the file tree. Various types of volumes are available, including emptyDir, hostPath, gitRepo, nfs, gcePersistentDisk, awsElasticBlockStore, and azureDisk, each with its own purpose and use case. To access a volume from within a container, a VolumeMount must be defined in the container's spec.","[{'highlight': ""A volume is bound to the lifecycle of a pod and will stay in existence only while the pod exists, but depending on the volume type, the volume's files may remain intact even after the pod and volume disappear, and can later be mounted into a new volume.""}, {'highlight': ""To access a volume inside a container, you need to define a VolumeMount inside the container's spec, in addition to defining the volume in the pod.""}, {'highlight': 'Kubernetes supports several types of volumes, including emptyDir, hostPath, gitRepo, nfs, gcePersistentDisk, awsElasticBlockStore, and azureDisk, each with its own specific use case.'}, {'highlight': 'Volumes can be used to share data between containers in the same pod, allowing them to work together and perform useful tasks.'}, {'highlight': 'The lifecycle of a volume is tied to the lifecycle of the pod it belongs to, but depending on the volume type, its files may persist even after the pod is deleted.'}]"
106,195,0,[],"163
Using volumes to share data between containers

cinder, cephfs, iscsi, flocker, glusterfs, quobyte, rbd, flexVolume, vsphere-
Volume, photonPersistentDisk, scaleIO—Used for mounting other types of
network storage.

configMap, secret, downwardAPI—Special types of volumes used to expose cer-
tain Kubernetes resources and cluster information to the pod.

persistentVolumeClaim—A way to use a pre- or dynamically provisioned per-
sistent storage. (We’ll talk about them in the last section of this chapter.)
These volume types serve various purposes. You’ll learn about some of them in the
following sections. Special types of volumes (secret, downwardAPI, configMap) are
covered in the next two chapters, because they aren’t used for storing data, but for
exposing Kubernetes metadata to apps running in the pod. 
 A single pod can use multiple volumes of different types at the same time, and, as
we’ve mentioned before, each of the pod’s containers can either have the volume
mounted or not.
6.2
Using volumes to share data between containers
Although a volume can prove useful even when used by a single container, let’s first
focus on how it’s used for sharing data between multiple containers in a pod.
6.2.1
Using an emptyDir volume
The simplest volume type is the emptyDir volume, so let’s look at it in the first exam-
ple of how to define a volume in a pod. As the name suggests, the volume starts out as
an empty directory. The app running inside the pod can then write any files it needs
to it. Because the volume’s lifetime is tied to that of the pod, the volume’s contents are
lost when the pod is deleted.
 An emptyDir volume is especially useful for sharing files between containers
running in the same pod. But it can also be used by a single container for when a con-
tainer needs to write data to disk temporarily, such as when performing a sort
operation on a large dataset, which can’t fit into the available memory. The data could
also be written to the container’s filesystem itself (remember the top read-write layer
in a container?), but subtle differences exist between the two options. A container’s
filesystem may not even be writable (we’ll talk about this toward the end of the book),
so writing to a mounted volume might be the only option. 
USING AN EMPTYDIR VOLUME IN A POD
Let’s revisit the previous example where a web server, a content agent, and a log rota-
tor share two volumes, but let’s simplify a bit. You’ll build a pod with only the web
server container and the content agent and a single volume for the HTML. 
 You’ll use Nginx as the web server and the UNIX fortune command to generate
the HTML content. The fortune command prints out a random quote every time you
run it. You’ll create a script that invokes the fortune command every 10 seconds and
stores its output in index.html. You’ll find an existing Nginx image available on
 
",[],"[{'entity': 'cinder', 'description': 'Used for mounting other types of network storage.', 'category': 'software'}, {'entity': 'cephfs', 'description': 'Used for mounting other types of network storage.', 'category': 'software'}, {'entity': 'iscsi', 'description': 'Used for mounting other types of network storage.', 'category': 'software'}, {'entity': 'flocker', 'description': 'Used for mounting other types of network storage.', 'category': 'software'}, {'entity': 'glusterfs', 'description': 'Used for mounting other types of network storage.', 'category': 'software'}, {'entity': 'quobyte', 'description': 'Used for mounting other types of network storage.', 'category': 'software'}, {'entity': 'rbd', 'description': 'Used for mounting other types of network storage.', 'category': 'software'}, {'entity': 'flexVolume', 'description': 'Used for mounting other types of network storage.', 'category': 'software'}, {'entity': 'vsphere-Volume', 'description': 'Used for mounting other types of network storage.', 'category': 'software'}, {'entity': 'photonPersistentDisk', 'description': 'Used for mounting other types of network storage.', 'category': 'software'}, {'entity': 'scaleIO', 'description': 'Used for mounting other types of network storage.', 'category': 'software'}, {'entity': 'configMap', 'description': 'Special type of volume used to expose certain Kubernetes resources and cluster information to the pod.', 'category': 'software'}, {'entity': 'secret', 'description': 'Special type of volume used to expose certain Kubernetes resources and cluster information to the pod.', 'category': 'software'}, {'entity': 'downwardAPI', 'description': 'Special type of volume used to expose certain Kubernetes resources and cluster information to the pod.', 'category': 'software'}, {'entity': 'persistentVolumeClaim', 'description': 'A way to use a pre- or dynamically provisioned persistent storage.', 'category': 'software'}, {'entity': 'emptyDir', 'description': 'The simplest volume type, which starts out as an empty directory.', 'category': 'software'}, {'entity': 'pod', 'description': 'A logical host that can run one or more containers.', 'category': 'application'}, {'entity': 'container', 'description': 'A lightweight and standalone executable package of software.', 'category': 'application'}, {'entity': 'Nginx', 'description': 'A web server image available on Docker Hub.', 'category': 'software'}, {'entity': 'UNIX fortune command', 'description': 'A command that generates a random quote every time it is run.', 'category': 'software'}]","[{'source_entity': 'photonPersistentDisk', 'description': 'provides persistent storage for Photon containers', 'destination_entity': 'container'}, {'source_entity': 'flocker', 'description': 'manages and provisions persistent volumes for Flocker clusters', 'destination_entity': 'persistentVolumeClaim'}, {'source_entity': 'rbd', 'description': 'provides a block-level storage system for RBD volumes', 'destination_entity': 'persistentVolumeClaim'}, {'source_entity': 'cinder', 'description': 'manages and provisions persistent volumes for Cinder clusters', 'destination_entity': 'persistentVolumeClaim'}, {'source_entity': 'scaleIO', 'description': 'provides a block-level storage system for ScaleIO volumes', 'destination_entity': 'persistentVolumeClaim'}, {'source_entity': 'glusterfs', 'description': 'manages and provisions persistent volumes for GlusterFS clusters', 'destination_entity': 'persistentVolumeClaim'}, {'source_entity': 'cephfs', 'description': 'provides a distributed file system for CephFS volumes', 'destination_entity': 'persistentVolumeClaim'}, {'source_entity': 'vsphere-Volume', 'description': 'manages and provisions persistent volumes for vSphere clusters', 'destination_entity': 'persistentVolumeClaim'}, {'source_entity': 'Nginx', 'description': 'serves as a reverse proxy and load balancer for Nginx containers', 'destination_entity': 'container'}, {'source_entity': 'UNIX fortune command', 'description': 'generates random fortunes for users', 'destination_entity': 'user'}, {'source_entity': 'configMap', 'description': 'manages and provisions configuration data for ConfigMaps', 'destination_entity': 'pod'}, {'source_entity': 'downwardAPI', 'description': 'provides a way to expose pod information to containers', 'destination_entity': 'container'}, {'source_entity': 'flexVolume', 'description': 'manages and provisions persistent volumes for FlexVolumes', 'destination_entity': 'persistentVolumeClaim'}, {'source_entity': 'quobyte', 'description': 'provides a block-level storage system for Quobyte volumes', 'destination_entity': 'persistentVolumeClaim'}, {'source_entity': 'pod', 'description': 'runs as a container within the Kubernetes cluster', 'destination_entity': 'container'}, {'source_entity': 'secret', 'description': 'manages and provisions sensitive data for Secrets', 'destination_entity': 'pod'}, {'source_entity': 'emptyDir', 'description': 'provides a temporary directory for pods', 'destination_entity': 'pod'}]","['[\n  {\n    ""source"": ""photonPersistentDisk"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""provides persistent storage"",\n    ""summary_er"": ""Photon Persistent Disk provides persistent storage for Photon containers within a pod.""\n  }\n]', '[\n  {\n    ""source"": ""Flocker"",\n    ""destination"": ""PersistentVolumeClaim"",\n    ""relation_description"": ""manages and provisions"",\n    ""summary_er"": ""Flocker manages and provisions persistent volumes for clusters, which are claimed by PersistentVolumeClaim.""\n  }\n]', '[\n  {\n    ""source"": ""rbd"",\n    ""destination"": ""persistentVolumeClaim"",\n    ""relation_description"": ""provides a block-level storage system for RBD volumes"",\n    ""summary_er"": ""RBD provides block-level storage for persistent volume claims, enabling efficient data management and access.""\n  }\n]', '[\n  {\n    ""source"": ""cinder"",\n    ""destination"": ""persistentVolumeClaim"",\n    ""relation_description"": ""manages and provisions persistent volumes"",\n    ""summary_er"": ""Cinder manages persistent volumes for clusters, provisioning them as needed.""\n  }\n]', '[\n  {\n    ""source"": ""ScaleIO"",\n    ""destination"": ""persistentVolumeClaim"",\n    ""relation_description"": ""provides a block-level storage system"",\n    ""summary_er"": ""ScaleIO provides a scalable, high-performance storage solution for persistent volumes.""\n  }\n]', '[\n  {\n    ""source"": ""glusterfs"",\n    ""destination"": ""persistentVolumeClaim"",\n    ""relation_description"": ""manages and provisions persistent volumes for GlusterFS clusters"",\n    ""summary_er"": ""GlusterFS manages persistent volumes for pods, fulfilling claims made by applications.""\n  }\n]', '[\n  {\n    ""source"": ""cephfs"",\n    ""destination"": ""persistentVolumeClaim"",\n    ""relation_description"": ""provides a distributed file system for CephFS volumes"",\n    ""summary_er"": ""CephFS provides a distributed file system for persistent volume claims, enabling scalable and fault-tolerant storage.""\n  }\n]', '[\n  {\n    ""source"": ""vsphere-Volume"",\n    ""destination"": ""persistentVolumeClaim"",\n    ""relation_description"": ""manages and provisions persistent volumes for vSphere clusters"",\n    ""summary_er"": ""vsphere-Volume manages persistent storage for vSphere clusters, provisioning claims for pods.""\n  }\n]', '[\n  {\n    ""source"": ""Nginx"",\n    ""destination"": ""container"",\n    ""relation_description"": ""serves as a reverse proxy and load balancer"",\n    ""summary_er"": ""Nginx serves as a reverse proxy and load balancer for containers, ensuring efficient traffic management.""\n  }\n]', '[\n  {\n    ""source"": ""UNIX fortune command"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""generates random fortunes for users"",\n    ""summary_er"": ""The UNIX fortune command generates random fortunes for users, which are then displayed in a pod.""\n  }\n]', '[\n  {\n    ""source"": ""configMap"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""manages and provisions configuration data for ConfigMaps"",\n    ""summary_er"": ""ConfigMap manages configuration data for Pods, providing a centralized way to store and retrieve config values.""\n  }\n]', '[\n  {\n    ""source"": ""downwardAPI"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""provides a way to expose pod information to containers"",\n    ""summary_er"": ""Downward API exposes pod info to containers, enabling dynamic configuration.""\n  },\n  {\n    ""source"": ""pod"",\n    ""destination"": ""container"",\n    ""relation_description"": ""related to"",\n    ""summary_er"": ""A pod contains one or more containers, which share resources and run applications.""\n  }\n]', '[\n  {\n    ""source"": ""flexVolume"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""manages and provisions persistent volumes for FlexVolumes"",\n    ""summary_er"": ""FlexVolume manages persistent storage for pods, provisioning and configuring volumes as needed.""\n  }\n]', '[\n  {\n    ""source"": ""quobyte"",\n    ""destination"": ""persistentVolumeClaim"",\n    ""relation_description"": ""provides a block-level storage system"",\n    ""summary_er"": ""Quobyte provides a block-level storage system for Quobyte volumes, enabling persistent storage for pod\'s persistentVolumeClaim.""\n  }\n]', '[\n  {\n    ""source"": ""pod"",\n    ""destination"": ""container"",\n    ""relation_description"": ""runs as a container within the Kubernetes cluster"",\n    ""summary_er"": ""A pod runs a container within a Kubernetes cluster, utilizing its resources and management features.""\n  }\n]', '[\n  {\n    ""source"": ""secret"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""manages and provisions sensitive data for Secrets"",\n    ""summary_er"": ""Secrets manage and provision sensitive data for Pods, ensuring secure configuration and access control.""\n  }\n]', '[\n  {\n    ""source"": ""emptyDir"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""provides a temporary directory for pods"",\n    ""summary_er"": ""Empty Dir provides ephemeral storage for Pods, allowing them to use temporary files without persisting data.""\n  }\n]']","Volumes in Kubernetes can be used to share data between containers or for exposing Kubernetes resources and cluster information. Special types of volumes like secret, downwardAPI, and configMap are used to expose metadata to apps running in a pod. A single pod can use multiple volumes of different types at the same time, with each container having the option to mount or not. An emptyDir volume is useful for sharing files between containers or for temporary data storage by a single container.","[{'highlight': ""A single pod can use multiple volumes of different types at the same time, and each of the pod's containers can either have the volume mounted or not.""}, {'highlight': 'An emptyDir volume is especially useful for sharing files between containers running in the same pod.'}, {'highlight': ""A container's filesystem may not even be writable, so writing to a mounted volume might be the only option.""}, {'highlight': ""You'll use Nginx as the web server and the UNIX fortune command to generate the HTML content.""}, {'highlight': 'The emptyDir volume starts out as an empty directory, and its contents are lost when the pod is deleted.'}]"
107,196,0,[],"164
CHAPTER 6
Volumes: attaching disk storage to containers
Docker Hub, but you’ll need to either create the fortune image yourself or use the
one I’ve already built and pushed to Docker Hub under luksa/fortune. If you want a
refresher on how to build Docker images, refer to the sidebar.
CREATING THE POD
Now that you have the two images required to run your pod, it’s time to create the pod
manifest. Create a file called fortune-pod.yaml with the contents shown in the follow-
ing listing.
apiVersion: v1
kind: Pod
metadata:
  name: fortune
spec:
  containers:
Building the fortune container image
Here’s how to build the image. Create a new directory called fortune and then inside
it, create a fortuneloop.sh shell script with the following contents:
#!/bin/bash
trap ""exit"" SIGINT
mkdir /var/htdocs
while :
do
  echo $(date) Writing fortune to /var/htdocs/index.html
  /usr/games/fortune > /var/htdocs/index.html
  sleep 10
done
Then, in the same directory, create a file called Dockerfile containing the following:
FROM ubuntu:latest
RUN apt-get update ; apt-get -y install fortune
ADD fortuneloop.sh /bin/fortuneloop.sh
ENTRYPOINT /bin/fortuneloop.sh
The image is based on the ubuntu:latest image, which doesn’t include the fortune
binary by default. That’s why in the second line of the Dockerfile you install it with
apt-get. After that, you add the fortuneloop.sh script to the image’s /bin folder.
In the last line of the Dockerfile, you specify that the fortuneloop.sh script should
be executed when the image is run.
After preparing both files, build and upload the image to Docker Hub with the following
two commands (replace luksa with your own Docker Hub user ID):
$ docker build -t luksa/fortune .
$ docker push luksa/fortune
Listing 6.1
A pod with two containers sharing the same volume: fortune-pod.yaml
 
",[],"[{'entity': 'Docker Hub', 'description': 'A registry service for Docker images', 'category': 'software'}, {'entity': 'fortune image', 'description': 'A Docker image that generates fortunes', 'category': 'software'}, {'entity': 'ubuntu:latest', 'description': 'A Docker image based on Ubuntu Linux', 'category': 'software'}, {'entity': 'apt-get', 'description': 'A package manager for Debian-based systems', 'category': 'software'}, {'entity': 'fortune binary', 'description': 'A program that generates fortunes', 'category': 'software'}, {'entity': 'fortuneloop.sh', 'description': 'A shell script that runs the fortune program', 'category': 'software'}, {'entity': 'Dockerfile', 'description': 'A text file that contains instructions for building a Docker image', 'category': 'software'}, {'entity': 'pod manifest', 'description': 'A YAML file that defines a pod and its containers', 'category': 'software'}, {'entity': 'fortune-pod.yaml', 'description': 'The name of the pod manifest file', 'category': 'software'}, {'entity': 'containers', 'description': 'A component of a pod that runs an application or service', 'category': 'hardware/software'}, {'entity': 'volumes', 'description': 'A way to persist data in a container', 'category': 'hardware/software'}, {'entity': 'disk storage', 'description': 'A type of persistent storage for containers', 'category': 'hardware'}]","[{'source_entity': 'apt-get', 'description': 'installs', 'destination_entity': 'fortune binary'}, {'source_entity': 'Dockerfile', 'description': 'builds', 'destination_entity': 'fortune image'}, {'source_entity': 'Docker Hub', 'description': 'hosts', 'destination_entity': 'fortune image'}, {'source_entity': 'containers', 'description': 'runs', 'destination_entity': 'fortune-pod.yaml'}, {'source_entity': 'ubuntu:latest', 'description': 'uses as base', 'destination_entity': 'fortune image'}, {'source_entity': 'Dockerfile', 'description': 'specifies', 'destination_entity': 'volumes'}, {'source_entity': 'apt-get', 'description': 'installs', 'destination_entity': 'containers'}, {'source_entity': 'fortuneloop.sh', 'description': 'executes', 'destination_entity': 'fortune binary'}, {'source_entity': 'pod manifest', 'description': 'defines', 'destination_entity': 'fortune-pod.yaml'}]","['[\n  {\n    ""source"": ""apt-get"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""installs"",\n    ""summary_er"": ""Apt-get is used to install the Fortune binary on a Kubernetes pod.""\n  }\n]', '[\n  {\n    ""source"": ""Dockerfile"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""builds"",\n    ""summary_er"": ""A Dockerfile is used to build a Docker image, which is then run as a pod in Kubernetes.""\n  }\n]', '[\n  {\n    ""source"": ""Docker Hub"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""hosts"",\n    ""summary_er"": ""Docker Hub hosts a pod containing the Fortune image, providing a centralized registry for containerized applications.""\n  }\n]', '[\n  {\n    ""source"": ""containers"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""runs"",\n    ""summary_er"": ""A container runs within a pod, providing isolation and resource sharing.""\n  }\n]', '[\n  {\n    ""source"": ""ubuntu:latest"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""uses as base"",\n    ""summary_er"": ""Ubuntu is used as a base image for creating custom Docker images.""\n  },\n  {\n    ""source"": ""fortune image"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""runs inside"",\n    ""summary_er"": ""The Fortune image runs inside the pod, providing a service to users.""\n  }\n]', '[\n  {\n    ""source"": ""Dockerfile"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""specifies"",\n    ""summary_er"": ""The Dockerfile specifies the configuration for a pod, including volumes and other settings.""\n  }\n]', '[\n  {\n    ""source"": ""apt-get"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""installs"",\n    ""summary_er"": ""Apt-get is used to install packages, which are then deployed as containers within a Kubernetes pod.""\n  }\n]', '[\n  {\n    ""source"": ""fortuneloop.sh"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""executes"",\n    ""summary_er"": ""The fortuneloop.sh script executes within a pod, utilizing its resources to run the fortune binary.""\n  }\n]', '[\n  {\n    ""source"": ""pod manifest"",\n    ""destination"": ""fortune-pod.yaml"",\n    ""relation_description"": ""defines"",\n    ""summary_er"": ""The pod manifest file, fortune-pod.yaml, defines the configuration for a Kubernetes pod named Fortune.""\n  }\n]']","To create a pod that uses a shared volume, you need to build a Docker image with the required binary (fortune) and script (fortuneloop.sh). The image is based on ubuntu:latest, installs fortune, adds the script to /bin folder, and sets it as the ENTRYPOINT. You then create a pod manifest (fortune-pod.yaml) that specifies two containers sharing the same volume. Finally, you can run the pod using kubectl apply -f fortune-pod.yaml","[{'highlight': 'To run a pod that displays fortunes, you need to create a pod manifest file called fortune-pod.yaml with the contents shown in Listing 6.1.'}]"
108,197,0,[],"165
Using volumes to share data between containers
  - image: luksa/fortune                   
    name: html-generator                   
    volumeMounts:                          
    - name: html                           
      mountPath: /var/htdocs               
  - image: nginx:alpine                   
    name: web-server                      
    volumeMounts:                         
    - name: html                          
      mountPath: /usr/share/nginx/html    
      readOnly: true                      
    ports:
    - containerPort: 80
      protocol: TCP
  volumes:                 
  - name: html             
    emptyDir: {}           
The pod contains two containers and a single volume that’s mounted in both of
them, yet at different paths. When the html-generator container starts, it starts writ-
ing the output of the fortune command to the /var/htdocs/index.html file every 10
seconds. Because the volume is mounted at /var/htdocs, the index.html file is writ-
ten to the volume instead of the container’s top layer. As soon as the web-server con-
tainer starts, it starts serving whatever HTML files are in the /usr/share/nginx/html
directory (this is the default directory Nginx serves files from). Because you mounted
the volume in that exact location, Nginx will serve the index.html file written there
by the container running the fortune loop. The end effect is that a client sending an
HTTP request to the pod on port 80 will receive the current fortune message as
the response. 
SEEING THE POD IN ACTION
To see the fortune message, you need to enable access to the pod. You’ll do that by
forwarding a port from your local machine to the pod:
$ kubectl port-forward fortune 8080:80
Forwarding from 127.0.0.1:8080 -> 80
Forwarding from [::1]:8080 -> 80
NOTE
As an exercise, you can also expose the pod through a service instead
of using port forwarding.
Now you can access the Nginx server through port 8080 of your local machine. Use
curl to do that:
$ curl http://localhost:8080
Beware of a tall blond man with one black shoe.
If you wait a few seconds and send another request, you should receive a different
message. By combining two containers, you created a simple app to see how a volume
can glue together two containers and enhance what each of them does.
The first container is called html-generator 
and runs the luksa/fortune image.
The volume called html is mounted 
at /var/htdocs in the container.
The second container is called web-server 
and runs the nginx:alpine image.
The same volume as above is 
mounted at /usr/share/nginx/html 
as read-only.
A single emptyDir volume 
called html that’s mounted 
in the two containers above
 
",[],"[{'entity': 'volumes', 'description': 'a way to share data between containers', 'category': 'docker'}, {'entity': 'html-generator', 'description': 'the first container that runs the luksa/fortune image', 'category': 'container'}, {'entity': 'luksa/fortune', 'description': 'the Docker image used by html-generator container', 'category': 'image'}, {'entity': '/var/htdocs', 'description': 'the mount path of the volume in html-generator container', 'category': 'path'}, {'entity': 'html', 'description': 'the name of the volume shared between containers', 'category': 'volume'}, {'entity': 'emptyDir', 'description': 'the type of volume used to share data between containers', 'category': 'docker'}, {'entity': 'web-server', 'description': 'the second container that runs the nginx:alpine image', 'category': 'container'}, {'entity': 'nginx:alpine', 'description': 'the Docker image used by web-server container', 'category': 'image'}, {'entity': '/usr/share/nginx/html', 'description': 'the mount path of the volume in web-server container', 'category': 'path'}, {'entity': 'read-only', 'description': 'the mode of the volume mounted in web-server container', 'category': 'docker'}, {'entity': 'ports', 'description': 'a way to expose a port from a container to the host machine', 'category': 'docker'}, {'entity': 'containerPort', 'description': 'a key used to specify the port exposed by a container', 'category': 'docker'}, {'entity': 'TCP', 'description': 'the protocol used for communication between containers and the host machine', 'category': 'protocol'}, {'entity': 'kubectl', 'description': 'the command-line tool used to manage Kubernetes resources', 'category': 'tool'}, {'entity': 'port-forward', 'description': 'a way to forward a port from the host machine to a container', 'category': 'docker'}, {'entity': 'fortune', 'description': 'the name of the pod that contains two containers and a shared volume', 'category': 'pod'}, {'entity': 'curl', 'description': 'the command-line tool used to send HTTP requests from the host machine', 'category': 'tool'}]","[{'source_entity': '""kubectl""', 'description': 'deploys', 'destination_entity': '""nginx:alpine""'}, {'source_entity': '""port-forward""', 'description': 'exposes', 'destination_entity': '""containerPort""'}, {'source_entity': '""curl""', 'description': 'requests', 'destination_entity': '""html-generator""'}, {'source_entity': '""nginx:alpine""', 'description': 'serves', 'destination_entity': '""/usr/share/nginx/html""'}, {'source_entity': '""port-forward""', 'description': 'exposes', 'destination_entity': '""TCP""'}, {'source_entity': '""html-generator""', 'description': 'generates', 'destination_entity': '""html""'}, {'source_entity': '""nginx:alpine""', 'description': 'serves', 'destination_entity': '""/var/htdocs""'}, {'source_entity': '""luksa/fortune""', 'description': 'provides', 'destination_entity': '""fortune""'}, {'source_entity': '""read-only""', 'description': 'mounts', 'destination_entity': '""emptyDir""'}]","['[\n  {\n    ""source"": ""kubectl"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""deploys"",\n    ""summary_er"": ""Kubernetes command-line tool deploys a pod, which is a container running an application.""\n  },\n  {\n    ""source"": ""nginx:alpine"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""runs as"",\n    ""summary_er"": ""Nginx web server runs as a process within the pod, utilizing the Alpine Linux image for efficiency.""\n  }\n]', '[\n  {\n    ""source"": ""port-forward"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""exposes"",\n    ""summary_er"": ""Port forwarding allows exposing a container\'s port to the host machine, enabling external access to the pod.""\n  }\n]', '[\n  {\n    ""source"": ""curl"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""requests"",\n    ""summary_er"": ""The curl command sends HTTP requests to a pod, which is a container running on a Kubernetes cluster.""\n  }\n]', '[\n  {\n    ""source"": ""nginx:alpine"",\n    ""destination"": ""/usr/share/nginx/html"",\n    ""relation_description"": ""serves"",\n    ""summary_er"": ""The nginx:alpine image serves content from /usr/share/nginx/html.""\n  }\n]', '[\n  {\n    ""source"": ""port-forward"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""exposes"",\n    ""summary_er"": ""Port forwarding allows a local machine to access a container\'s exposed port, enabling communication between the host and container.""\n  }\n]', '[\n  {\n    ""source"": ""html-generator"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""generates"",\n    ""summary_er"": ""The html-generator entity generates a pod, which is a containerized application in Kubernetes.""\n  }\n]', '[\n  {\n    ""source"": ""nginx:alpine"",\n    ""destination"": ""/var/htdocs"",\n    ""relation_description"": ""serves"",\n    ""summary_er"": ""The nginx:alpine image serves content from /var/htdocs, providing a lightweight web server for the pod.""\n  }\n]', '[\n  {\n    ""source"": ""luksa/fortune"",\n    ""destination"": ""fortune"",\n    ""relation_description"": ""provides"",\n    ""summary_er"": ""The luksa/fortune container provides a fortune-telling service.""\n  }\n]', '[\n  {\n    ""source"": ""read-only"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""mounts"",\n    ""summary_er"": ""A read-only file system is mounted to a pod, providing a shared view of data without allowing modifications.""\n  },\n  {\n    ""source"": ""emptyDir"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""mounts"",\n    ""summary_er"": ""An empty directory is mounted to a pod, providing a temporary storage space for ephemeral data.""\n  }\n]']","A pod contains two containers and a shared volume between them. The html-generator container writes to the volume every 10 seconds, while the web-server container serves files from it. By forwarding port 80 on the local machine to the pod's port, users can access the Nginx server through localhost:8080 and receive a different fortune message with each request.","[{'highlight': 'The pod contains two containers and a single volume that’s mounted in both of them, yet at different paths.'}, {'highlight': 'When the html-generator container starts, it starts writing the output of the fortune command to the /var/htdocs/index.html file every 10 seconds.'}, {'highlight': 'Because you mounted the volume in that exact location, Nginx will serve the index.html file written there by the container running the fortune loop.'}, {'highlight': 'You can access the Nginx server through port 8080 of your local machine using curl: $ curl http://localhost:8080'}, {'highlight': 'By combining two containers, you created a simple app to see how a volume can glue together two containers and enhance what each of them does.'}]"
109,198,1,[],"166
CHAPTER 6
Volumes: attaching disk storage to containers
SPECIFYING THE MEDIUM TO USE FOR THE EMPTYDIR
The emptyDir you used as the volume was created on the actual disk of the worker
node hosting your pod, so its performance depends on the type of the node’s disks.
But you can tell Kubernetes to create the emptyDir on a tmpfs filesystem (in memory
instead of on disk). To do this, set the emptyDir’s medium to Memory like this:
volumes:
  - name: html
    emptyDir:
      medium: Memory    
An emptyDir volume is the simplest type of volume, but other types build upon it.
After the empty directory is created, they populate it with data. One such volume type
is the gitRepo volume type, which we’ll introduce next.
6.2.2
Using a Git repository as the starting point for a volume 
A gitRepo volume is basically an emptyDir volume that gets populated by cloning a
Git repository and checking out a specific revision when the pod is starting up (but
before its containers are created). Figure 6.3 shows how this unfolds.
NOTE
After the gitRepo volume is created, it isn’t kept in sync with the repo
it’s referencing. The files in the volume will not be updated when you push
additional commits to the Git repository. However, if your pod is managed by
a ReplicationController, deleting the pod will result in a new pod being cre-
ated and this new pod’s volume will then contain the latest commits. 
For example, you can use a Git repository to store static HTML files of your website
and create a pod containing a web server container and a gitRepo volume. Every time
the pod is created, it pulls the latest version of your website and starts serving it. The
This emptyDir’s 
files should be 
stored in memory.
Pod
Container
User
gitRepo
volume
1. User (or a replication
controller) creates pod
with gitRepo volume
2. Kubernetes creates
an empty directory and
clones the speciﬁed Git
repository into it
3. The pod’s container is started
(with the volume mounted at
the mount path)
Repository
Figure 6.3
A gitRepo volume is an emptyDir volume initially populated with the contents of a 
Git repository.
 
",[],"[{'entity': 'emptyDir', 'description': 'a type of volume that gets created on the actual disk of the worker node hosting your pod', 'category': 'software'}, {'entity': 'tmpfs filesystem', 'description': 'a filesystem that stores data in memory instead of on disk', 'category': 'hardware'}, {'entity': 'Kubernetes', 'description': 'an open-source container orchestration system for automating the deployment, scaling, and management of containers', 'category': 'software'}, {'entity': 'volumes', 'description': 'a way to attach disk storage to containers in Kubernetes', 'category': 'software'}, {'entity': 'gitRepo volume', 'description': 'an emptyDir volume that gets populated by cloning a Git repository and checking out a specific revision when the pod is starting up', 'category': 'software'}, {'entity': 'pod', 'description': 'a logical host in Kubernetes where one or more containers can run', 'category': 'software'}, {'entity': 'container', 'description': 'a lightweight and standalone execution environment for an application', 'category': 'software'}, {'entity': 'ReplicationController', 'description': 'a Kubernetes object that ensures a specified number of replicas (identical copies) of a pod are running at any given time', 'category': 'software'}, {'entity': 'Git repository', 'description': 'a version control system for tracking changes in code', 'category': 'software'}]","[{'source_entity': 'Kubernetes', 'description': 'manages', 'destination_entity': 'ReplicationController'}, {'source_entity': 'Kubernetes', 'description': 'uses', 'destination_entity': 'container'}, {'source_entity': 'Kubernetes', 'description': 'mounts', 'destination_entity': 'volumes'}, {'source_entity': 'ReplicationController', 'description': 'deploys', 'destination_entity': 'pod'}, {'source_entity': 'pod', 'description': 'uses', 'destination_entity': 'tmpfs filesystem'}, {'source_entity': 'pod', 'description': 'mounts', 'destination_entity': 'emptyDir'}, {'source_entity': 'Kubernetes', 'description': 'pulls from', 'destination_entity': 'Git repository'}, {'source_entity': 'Kubernetes', 'description': 'uses', 'destination_entity': 'gitRepo volume'}]","['[{\n  ""source"": ""Kubernetes"",\n  ""destination"": ""pod"",\n  ""relation_description"": ""manages"",\n  ""summary_er"": ""Kubernetes manages pods, ensuring they are running and scaled as needed.""\n}]', '[\n  {\n    ""source"": ""Kubernetes"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""uses"",\n    ""summary_er"": ""Kubernetes manages and orchestrates multiple containers within a pod, utilizing its resources efficiently.""\n  }\n]', '[\n  {\n    ""source"": ""Kubernetes"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""volumes"",\n    ""summary_er"": ""Kubernetes manages pod\'s storage needs through volumes, ensuring data persistence and access.""\n  },\n  {\n    ""source"": ""Kubernetes"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""mounts"",\n    ""summary_er"": ""Kubernetes mounts volumes to pods, providing a way to share data between containers and the host system.""\n  }\n]', '[\n  {\n    ""source"": ""ReplicationController"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""deploys"",\n    ""summary_er"": ""A ReplicationController ensures a specified number of replicas (identical copies) of a pod are running at any given time, deploying and managing them as needed.""\n  }\n]', '[\n  {\n    ""source"": ""pod"",\n    ""destination"": ""tmpfs filesystem"",\n    ""relation_description"": ""uses"",\n    ""summary_er"": ""A Kubernetes pod utilizes a tmpfs filesystem for ephemeral storage, providing a temporary file system that persists only during the pod\'s lifetime.""\n  }\n]', '[\n  {\n    ""source"": ""pod"",\n    ""destination"": ""emptyDir"",\n    ""relation_description"": ""mounts"",\n    ""summary_er"": ""A Kubernetes Pod uses an Empty Dir volume to mount a temporary file system, providing ephemeral storage for containers.""\n  }\n]', '[\n  {\n    ""source"": ""Kubernetes"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""pulls from"",\n    ""summary_er"": ""Kubernetes pulls container images from a registry, which can be a Docker Hub repository or a private Git repository.""\n  }\n]', '[\n  {\n    ""source"": ""Kubernetes"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""uses"",\n    ""summary_er"": ""Kubernetes utilizes pods as its primary execution units, leveraging their flexibility and scalability to manage containerized applications.""\n  },\n  {\n    ""source"": ""Kubernetes"",\n    ""destination"": ""gitRepo volume"",\n    ""relation_description"": ""mounts"",\n    ""summary_er"": ""Kubernetes mounts Git repository volumes to provide persistent storage for application code and configurations.""\n  }\n]']","An emptyDir volume can be created on tmpfs filesystem for better performance, while a gitRepo volume clones and checks out a Git repository at pod startup. The files in a gitRepo volume are not kept in sync with the referenced repo, but are updated when a new pod is created. This type of volume is useful for storing static HTML files or serving the latest version of a website.","[{'highlight': ""You can tell Kubernetes to create the emptyDir on a tmpfs filesystem (in memory instead of on disk) by setting the emptyDir's medium to Memory.""}, {'highlight': 'A gitRepo volume is basically an emptyDir volume that gets populated by cloning a Git repository and checking out a specific revision when the pod is starting up.'}, {'highlight': ""The files in the gitRepo volume will not be updated when you push additional commits to the Git repository, but if your pod is managed by a ReplicationController, deleting the pod will result in a new pod being created and this new pod's volume will then contain the latest commits.""}, {'highlight': 'You can use a Git repository to store static HTML files of your website and create a pod containing a web server container and a gitRepo volume that pulls the latest version of your website every time the pod is created.'}, {'highlight': 'A gitRepo volume is an emptyDir volume initially populated with the contents of a Git repository, which can be used to store static HTML files or other data that needs to be updated periodically.'}]"
