,page,img_cnt,img_npy_lst,text,tables,entities,relationships,summary_rel,summary,highlights
130,219,0,[],"187
Dynamic provisioning of PersistentVolumes
As you can see, the first persistent disk’s name suggests it was provisioned dynamically
and its type shows it’s an SSD, as specified in the storage class you created earlier. 
UNDERSTANDING HOW TO USE STORAGE CLASSES
The cluster admin can create multiple storage classes with different performance or
other characteristics. The developer then decides which one is most appropriate for
each claim they create. 
 The nice thing about StorageClasses is the fact that claims refer to them by
name. The PVC definitions are therefore portable across different clusters, as long
as the StorageClass names are the same across all of them. To see this portability
yourself, you can try running the same example on Minikube, if you’ve been using
GKE up to this point. As a cluster admin, you’ll have to create a different storage
class (but with the same name). The storage class defined in the storageclass-fast-
hostpath.yaml file is tailor-made for use in Minikube. Then, once you deploy the stor-
age class, you as a cluster user can deploy the exact same PVC manifest and the exact
same pod manifest as before. This shows how the pods and PVCs are portable across
different clusters.
6.6.3
Dynamic provisioning without specifying a storage class
As we’ve progressed through this chapter, attaching persistent storage to pods has
become ever simpler. The sections in this chapter reflect how provisioning of storage
has evolved from early Kubernetes versions to now. In this final section, we’ll look at
the latest and simplest way of attaching a PersistentVolume to a pod. 
LISTING STORAGE CLASSES
When you created your custom storage class called fast, you didn’t check if any exist-
ing storage classes were already defined in your cluster. Why don’t you do that now?
Here are the storage classes available in GKE:
$ kubectl get sc
NAME                 TYPE
fast                 kubernetes.io/gce-pd
standard (default)   kubernetes.io/gce-pd
NOTE
We’re using sc as shorthand for storageclass.
Beside the fast storage class, which you created yourself, a standard storage class
exists and is marked as default. You’ll learn what that means in a moment. Let’s list the
storage classes available in Minikube, so we can compare:
$ kubectl get sc
NAME                 TYPE
fast                 k8s.io/minikube-hostpath
standard (default)   k8s.io/minikube-hostpath
Again, the fast storage class was created by you and a default standard storage class
exists here as well. Comparing the TYPE columns in the two listings, you see GKE is
 
",[],"[{'entity': 'PersistentVolumes', 'description': 'Dynamic provisioning of Persistent Volumes', 'category': 'application'}, {'entity': 'storage class', 'description': 'A storage class with different performance or other characteristics', 'category': 'database'}, {'entity': 'PVC', 'description': 'Persistent Volume Claim definitions are portable across different clusters', 'category': 'application'}, {'entity': 'Minikube', 'description': 'A local Kubernetes cluster for development and testing', 'category': 'hardware'}, {'entity': 'GKE', 'description': 'Google Kubernetes Engine, a managed container environment', 'category': 'cloud service'}, {'entity': 'kubectl', 'description': 'A command-line tool for managing Kubernetes clusters', 'category': 'command'}, {'entity': 'sc', 'description': 'Shorthand for storageclass, used to list existing storage classes', 'category': 'command'}, {'entity': 'Persistent disk', 'description': 'A persistent storage device attached to a pod', 'category': 'hardware'}, {'entity': 'SSD', 'description': 'Solid-State Drive, a type of fast storage device', 'category': 'hardware'}, {'entity': 'storageclass-fast-hostpath.yaml', 'description': 'A YAML file defining a custom storage class for Minikube', 'category': 'file'}, {'entity': 'fast storage class', 'description': 'A custom storage class created by the user', 'category': 'database'}, {'entity': 'standard storage class', 'description': 'The default storage class provided by GKE or Minikube', 'category': 'database'}]","[{'source_entity': '""kubectl""', 'description': 'is used to create', 'destination_entity': '""storageclass-fast-hostpath.yaml""'}, {'source_entity': '""kubectl""', 'description': 'applies to', 'destination_entity': '""Persistent disk""'}, {'source_entity': '""storageclass-fast-hostpath.yaml""', 'description': 'defines the characteristics of', 'destination_entity': '""standard storage class""'}, {'source_entity': '""storageclass-fast-hostpath.yaml""', 'description': 'specifies the type of', 'destination_entity': '""SSD""'}, {'source_entity': '""kubectl""', 'description': 'uses to create a', 'destination_entity': '""PVC""'}, {'source_entity': '""storageclass-fast-hostpath.yaml""', 'description': 'is based on', 'destination_entity': '""fast storage class""'}, {'source_entity': '""kubectl""', 'description': 'manages the creation of', 'destination_entity': '""PersistentVolumes""'}, {'source_entity': '""GKE""', 'description': 'uses to manage', 'destination_entity': '""PersistentVolumes""'}, {'source_entity': '""Minikube""', 'description': 'uses to create a', 'destination_entity': '""PVC""'}, {'source_entity': '""sc""', 'description': 'is used to specify the', 'destination_entity': '""storage class""'}]","['[\n  {\n    ""source"": ""kubectl"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""is used to create"",\n    ""summary_er"": ""Kubectl is used to create a pod, which is a container running on a host.""\n  }\n]', '[\n  {\n    ""source"": ""kubectl"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""applies to"",\n    ""summary_er"": ""Kubectl command applies configuration to a running Kubernetes pod.""\n  },\n  {\n    ""source"": ""Persistent disk"",\n    ""destination"": ""container"",\n    ""relation_description"": ""storage for"",\n    ""summary_er"": ""A persistent disk provides storage for a container in a Kubernetes cluster.""\n  }\n]', '[\n  {\n    ""source"": ""storageclass-fast-hostpath.yaml"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""defines the characteristics of"",\n    ""summary_er"": ""This YAML file defines a storage class for fast host path, which will be used to create a pod with optimized storage settings.""\n  }\n]', '[{\n  ""source"": ""storageclass-fast-hostpath.yaml"",\n  ""destination"": ""pod"",\n  ""relation_description"": ""specifies the type of storage"",\n  ""summary_er"": ""This YAML file defines a StorageClass that uses HostPath to specify SSD as the storage type for pods.""\n}]', '[\n  {\n    ""source"": ""kubectl"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""uses to create a"",\n    ""summary_er"": ""Kubectl is used to create and manage pods in Kubernetes.""\n  },\n  {\n    ""source"": ""PVC"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""provides storage for"",\n    ""summary_er"": ""A Persistent Volume Claim (PVC) provides storage for a pod in Kubernetes, ensuring data persistence.""\n  }\n]', '[\n  {\n    ""source"": ""storageclass-fast-hostpath.yaml"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""is based on"",\n    ""summary_er"": ""The \'storageclass-fast-hostpath.yaml\' file is used to define a fast storage class, which is utilized by the pod for efficient data storage.""\n  }\n]', '[\n  {\n    ""source"": ""kubectl"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""manages the creation of"",\n    ""summary_er"": ""Kubectl manages the creation, scaling, and management of pods in a Kubernetes cluster.""\n  },\n  {\n    ""source"": ""PersistentVolumes"",\n    ""destination"": ""storage"",\n    ""relation_description"": ""provides persistent storage"",\n    ""summary_er"": ""Persistent Volumes provides persistent storage for applications in a Kubernetes cluster, ensuring data durability and availability.""\n  }\n]', '[\n  {\n    ""source"": ""GKE"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""uses to manage"",\n    ""summary_er"": ""Google Kubernetes Engine (GKE) uses Persistent Volumes to manage persistent data for pods.""\n  }\n]', '[\n  {\n    ""source"": ""Minikube"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""uses to create a"",\n    ""summary_er"": ""Minikube uses Kubernetes to create and manage pods, which are the basic execution units in a containerized application.""\n  },\n  {\n    ""source"": ""PVC"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""provides storage for"",\n    ""summary_er"": ""A Persistent Volume Claim (PVC) provides persistent storage for a pod, allowing it to store and retrieve data even after the pod is deleted.""\n  }\n]', '[{\n    ""source"": ""sc"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""is used to specify"",\n    ""summary_er"": ""A storage class is used to specify the characteristics of a pod.""\n}]']","Dynamic provisioning of PersistentVolumes allows cluster admins to create multiple storage classes with different performance characteristics. Developers can then choose which one is most appropriate for each claim they create. This makes PVC definitions portable across different clusters as long as StorageClass names are the same, demonstrating flexibility and consistency in Kubernetes environments.","[{'highlight': 'Dynamic provisioning of PersistentVolumes allows for the creation of persistent disks with specific characteristics, such as SSD type, which can be specified in a storage class.'}]"
131,220,0,[],"188
CHAPTER 6
Volumes: attaching disk storage to containers
using the kubernetes.io/gce-pd provisioner, whereas Minikube is using k8s.io/
minikube-hostpath. 
EXAMINING THE DEFAULT STORAGE CLASS
You’re going to use kubectl get to see more info about the standard storage class in a
GKE cluster, as shown in the following listing.
$ kubectl get sc standard -o yaml
apiVersion: storage.k8s.io/v1
kind: StorageClass
metadata:
  annotations:
    storageclass.beta.kubernetes.io/is-default-class: ""true""   
  creationTimestamp: 2017-05-16T15:24:11Z
  labels:
    addonmanager.kubernetes.io/mode: EnsureExists
    kubernetes.io/cluster-service: ""true""
  name: standard
  resourceVersion: ""180""
  selfLink: /apis/storage.k8s.io/v1/storageclassesstandard
  uid: b6498511-3a4b-11e7-ba2c-42010a840014
parameters:                                    
  type: pd-standard                            
provisioner: kubernetes.io/gce-pd      
If you look closely toward the top of the listing, the storage class definition includes an
annotation, which makes this the default storage class. The default storage class is
what’s used to dynamically provision a PersistentVolume if the PersistentVolumeClaim
doesn’t explicitly say which storage class to use. 
CREATING A PERSISTENTVOLUMECLAIM WITHOUT SPECIFYING A STORAGE CLASS
You can create a PVC without specifying the storageClassName attribute and (on
Google Kubernetes Engine) a GCE Persistent Disk of type pd-standard will be provi-
sioned for you. Try this by creating a claim from the YAML in the following listing.
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: mongodb-pvc2
spec:                        
  resources:                 
    requests:                
      storage: 100Mi         
  accessModes:               
    - ReadWriteOnce          
Listing 6.16
The definition of the standard storage class on GKE
Listing 6.17
PVC with no storage class defined: mongodb-pvc-dp-nostorageclass.yaml
This annotation 
marks the storage 
class as default.
The type parameter is used by the provisioner 
to know what type of GCE PD to create.
The GCE Persistent Disk provisioner 
is used to provision PVs of this class.
You’re not specifying 
the storageClassName 
attribute (unlike earlier 
examples).
 
",[],"[{'entity': 'kubernetes.io/gce-pd', 'description': 'provisioner for GCE Persistent Disk', 'category': 'storage class'}, {'entity': 'Minikube', 'description': 'a tool for running Kubernetes locally', 'category': 'application'}, {'entity': 'kubectl', 'description': 'command-line interface for Kubernetes', 'category': 'command'}, {'entity': 'get', 'description': 'command to retrieve information about a resource', 'category': 'command'}, {'entity': 'sc', 'description': 'short form of StorageClass', 'category': 'storage class'}, {'entity': 'standard', 'description': 'default storage class in GKE cluster', 'category': 'storage class'}, {'entity': 'apiVersion', 'description': 'key in YAML file to specify the API version', 'category': 'yaml key'}, {'entity': 'kind', 'description': 'key in YAML file to specify the type of resource', 'category': 'yaml key'}, {'entity': 'metadata', 'description': 'section in YAML file to store metadata about a resource', 'category': 'yaml section'}, {'entity': 'annotations', 'description': 'key in YAML file to specify annotations for a resource', 'category': 'yaml key'}, {'entity': 'storageclass.beta.kubernetes.io/is-default-class', 'description': 'annotation to mark a storage class as default', 'category': 'annotation'}, {'entity': 'parameters', 'description': 'section in YAML file to specify parameters for a resource', 'category': 'yaml section'}, {'entity': 'type', 'description': 'parameter to specify the type of GCE PD', 'category': 'parameter'}, {'entity': 'pd-standard', 'description': 'type of GCE PD to create', 'category': 'storage class parameter'}, {'entity': 'provisioner', 'description': 'key in YAML file to specify the provisioner for a resource', 'category': 'yaml key'}, {'entity': 'kubernetes.io/gce-pd', 'description': 'provisioner for GCE Persistent Disk', 'category': 'storage class parameter'}, {'entity': 'PersistentVolumeClaim', 'description': 'resource in Kubernetes to request storage', 'category': 'resource'}, {'entity': 'spec', 'description': 'section in YAML file to specify the specification for a resource', 'category': 'yaml section'}, {'entity': 'resources', 'description': 'key in YAML file to specify resources requested by a PVC', 'category': 'yaml key'}, {'entity': 'requests', 'description': 'section in YAML file to specify the requests made by a resource', 'category': 'yaml section'}, {'entity': 'storage', 'description': 'key in YAML file to specify the storage requested by a PVC', 'category': 'yaml key'}, {'entity': '100Mi', 'description': 'amount of storage requested by the PVC', 'category': 'storage request'}, {'entity': 'ReadWriteOnce', 'description': 'access mode for a PVC', 'category': 'access mode'}]","[{'source_entity': '""kubectl""', 'description': 'used to manage Kubernetes clusters', 'destination_entity': '""Kubernetes""'}, {'source_entity': '""annotations""', 'description': 'added to provide additional information about a resource', 'destination_entity': '""PersistentVolumeClaim""'}, {'source_entity': '""ReadWriteOnce""', 'description': 'defined as the access mode for a Persistent Volume Claim', 'destination_entity': '""pd-standard""'}, {'source_entity': '""pd-standard""', 'description': 'specified as the storage class for a Persistent Volume', 'destination_entity': '""PersistentVolumeClaim""'}, {'source_entity': '""kind""', 'description': 'defined as the type of resource being created', 'destination_entity': '""PersistentVolumeClaim""'}, {'source_entity': '""type""', 'description': 'specified as the type of Persistent Volume Claim', 'destination_entity': '""PersistentVolumeClaim""'}, {'source_entity': '""get""', 'description': 'used to retrieve information about a resource', 'destination_entity': '""sc""'}, {'source_entity': '""sc""', 'description': 'referenced as the storage class for a Persistent Volume Claim', 'destination_entity': '""PersistentVolumeClaim""'}, {'source_entity': '""resources""', 'description': 'defined as the resources required by a Persistent Volume Claim', 'destination_entity': '""PersistentVolumeClaim""'}, {'source_entity': '""provisioner""', 'description': 'specified as the provisioner for a storage class', 'destination_entity': '""pd-standard""'}, {'source_entity': '""100Mi""', 'description': 'defined as the requested storage size for a Persistent Volume Claim', 'destination_entity': '""PersistentVolumeClaim""'}, {'source_entity': '""apiVersion""', 'description': 'specified as the API version for a Kubernetes resource', 'destination_entity': '""PersistentVolumeClaim""'}, {'source_entity': '""metadata""', 'description': 'defined as the metadata for a Persistent Volume Claim', 'destination_entity': '""PersistentVolumeClaim""'}, {'source_entity': '""PersistentVolumeClaim""', 'description': 'referenced as the type of resource being created', 'destination_entity': '""kubernetes.io/gce-pd""'}, {'source_entity': '""kubernetes.io/gce-pd""', 'description': 'specified as the storage class for a Persistent Volume Claim', 'destination_entity': '""PersistentVolumeClaim""'}, {'source_entity': '""requests""', 'description': 'defined as the requested resources for a Persistent Volume Claim', 'destination_entity': '""Minikube""'}, {'source_entity': '""Minikube""', 'description': 'referenced as the environment in which Kubernetes is running', 'destination_entity': '""PersistentVolumeClaim""'}, {'source_entity': '""storageclass.beta.kubernetes.io/is-default-class""', 'description': 'defined as a label for a storage class', 'destination_entity': '""pd-standard""'}, {'source_entity': '""spec""', 'description': 'defined as the specification for a Persistent Volume Claim', 'destination_entity': '""PersistentVolumeClaim""'}, {'source_entity': '""storage""', 'description': 'defined as the storage requirements for a Persistent Volume Claim', 'destination_entity': '""PersistentVolumeClaim""'}, {'source_entity': '""parameters""', 'description': 'defined as the parameters for a Persistent Volume Claim', 'destination_entity': '""PersistentVolumeClaim""'}]","['[\n  {\n    ""source"": ""kubectl"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""used to manage"",\n    ""summary_er"": ""kubectl is used to manage Kubernetes clusters and interact with pods.""\n  },\n  {\n    ""source"": ""kubectl"",\n    ""destination"": ""Kubernetes"",\n    ""relation_description"": ""manage clusters"",\n    ""summary_er"": ""kubectl is a tool used to manage Kubernetes clusters, providing a command-line interface for cluster management.""\n  }\n]', '[\n  {\n    ""source"": ""annotations"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""added to provide additional information about a resource"",\n    ""summary_er"": ""Annotations are key-value pairs added to a pod to provide additional metadata, such as labels or configuration details.""\n  },\n  {\n    ""source"": ""PersistentVolumeClaim"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""requests access to a Persistent Volume"",\n    ""summary_er"": ""A Persistent Volume Claim (PVC) is a request for storage resources that can be used by a pod, ensuring data persistence and availability.""\n  }\n]', '[\n  {\n    ""source"": ""Persistent Volume Claim"",\n    ""destination"": ""Pod"",\n    ""relation_description"": ""ReadWriteOnce"",\n    ""summary_er"": ""Persistent Volume Claim allows a Pod to read and write data from a shared storage resource, with ReadWriteOnce access mode.""\n  }\n]', '[\n  {\n    ""source"": ""pd-standard"",\n    ""destination"": ""PersistentVolumeClaim"",\n    ""relation_description"": ""specified as the storage class for a Persistent Volume"",\n    ""summary_er"": ""A pd-standard is used to specify the storage class for a Persistent Volume, which is then claimed by a PersistentVolumeClaim.""\n  }\n]', '[\n  {\n    ""source"": ""Pod"",\n    ""destination"": ""PersistentVolumeClaim"",\n    ""relation_description"": ""defined as the type of resource being created"",\n    ""summary_er"": ""A Pod can request a Persistent Volume Claim to store data persistently.""\n  }\n]', '[\n  {\n    ""source"": ""PersistentVolumeClaim"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""specified as the type of Persistent Volume Claim"",\n    ""summary_er"": ""A Persistent Volume Claim is used to request storage resources for a pod, ensuring data persistence and availability.""\n  }\n]', '[\n  {\n    ""source"": ""GET"",\n    ""destination"": ""Pod"",\n    ""relation_description"": ""used to retrieve information about a resource"",\n    ""summary_er"": ""The GET method retrieves information about a Pod, allowing for retrieval of its attributes and configuration.""\n  }\n]', '[\n  {\n    ""source"": ""Storage Class"",\n    ""destination"": ""Pod"",\n    ""relation_description"": ""referenced as the storage class for a Persistent Volume Claim"",\n    ""summary_er"": ""A Storage Class is referenced by a Pod to manage persistent data.""\n  }\n]', '[\n  {\n    ""source"": ""PersistentVolumeClaim"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""resources"",\n    ""summary_er"": ""A Persistent Volume Claim requires resources from a Pod, which provides storage and data access to the application.""\n  }\n]', '[\n  {\n    ""source"": ""provisioner"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""specified as the provisioner for a storage class"",\n    ""summary_er"": ""The provisioner is specified for a pod\'s storage class, ensuring proper data management.""\n  },\n  {\n    ""source"": ""pd-standard"",\n    ""destination"": ""provisioner"",\n    ""relation_description"": ""storage class"",\n    ""summary_er"": ""A standard persistent disk storage class is used as the provisioner, providing reliable storage solutions.""\n  }\n]', '[\n  {\n    ""source"": ""100Mi"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""defined as the requested storage size for a Persistent Volume Claim"",\n    ""summary_er"": ""The \'100Mi\' storage size is requested by a pod for a Persistent Volume Claim.""\n  }\n]', '[\n  {\n    ""source"": ""Kubernetes Resource"",\n    ""destination"": ""Pod"",\n    ""relation_description"": ""specified as the API version"",\n    ""summary_er"": ""The Kubernetes resource specifies its API version, which is used by the pod to understand the expected format of data.""\n  },\n  {\n    ""source"": ""Pod"",\n    ""destination"": ""PersistentVolumeClaim"",\n    ""relation_description"": ""defined"",\n    ""summary_er"": ""A persistent volume claim is defined for a pod to request storage resources from the cluster.""\n  }\n]', '[\n  {\n    ""source"": ""metadata"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""defined as the metadata for a Persistent Volume Claim"",\n    ""summary_er"": ""Metadata provides configuration details for a Pod, including PersistentVolumeClaim information.""\n  }\n]', '[\n  {\n    ""source"": ""PersistentVolumeClaim"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""referenced as the type of resource being created"",\n    ""summary_er"": ""A Persistent Volume Claim is referenced in a pod to create a persistent volume.""\n  },\n  {\n    ""source"": ""kubernetes.io/gce-pd"",\n    ""destination"": ""PersistentVolumeClaim"",\n    ""relation_description"": ""persistent disk type"",\n    ""summary_er"": ""The kubernetes.io/gce-pd label indicates the type of persistent disk used in a Persistent Volume Claim.""\n  }\n]', '[\n  {\n    ""source"": ""kubernetes.io/gce-pd"",\n    ""destination"": ""PersistentVolumeClaim"",\n    ""relation_description"": ""specified as the storage class for a Persistent Volume Claim"",\n    ""summary_er"": ""Kubernetes uses GCE PD as the storage class for persistent volume claims, enabling durable storage for pods.""\n  }\n]', '[\n  {\n    ""source"": ""Persistent Volume Claim"",\n    ""destination"": ""Pod"",\n    ""relation_description"": ""requests"",\n    ""summary_er"": ""A Persistent Volume Claim requests resources for a Pod to use, ensuring storage and data availability.""\n  }\n]', '[\n  {\n    ""source"": ""Minikube"",\n    ""destination"": ""Pod"",\n    ""relation_description"": ""Running Environment"",\n    ""summary_er"": ""\\""Minikube serves as the environment where Kubernetes pods run, providing a local development setup.\\""""\n  },\n  {\n    ""source"": ""PersistentVolumeClaim"",\n    ""destination"": ""Pod"",\n    ""relation_description"": ""Resource Allocation"",\n    ""summary_er"": ""\\""Persistent Volume Claims are used to allocate storage resources for Pods, ensuring data persistence and availability.\\""""\n  },\n  {\n    ""source"": ""Minikube"",\n    ""destination"": ""PersistentVolumeClaim"",\n    ""relation_description"": ""Storage Provisioning"",\n    ""summary_er"": ""\\""Minikube provides a way to provision Persistent Volumes, which are then claimed by Pods for storage needs.\\""""\n  },\n  {\n    ""source"": ""Pod"",\n    ""destination"": ""PersistentVolumeClaim"",\n    ""relation_description"": ""Resource Utilization"",\n    ""summary_er"": ""\\""Pods utilize Persistent Volume Claims to access and store data, ensuring efficient resource utilization.\\""""\n  },\n  {\n    ""source"": ""Minikube"",\n    ""destination"": ""Kubernetes"",\n    ""relation_description"": ""Hosting Environment"",\n    ""summary_er"": ""\\""Minikube serves as a hosting environment for Kubernetes, providing a local development setup for cluster management.\\""""\n  },\n  {\n    ""source"": ""PersistentVolumeClaim"",\n    ""destination"": ""Kubernetes"",\n    ""relation_description"": ""Resource Management"",\n    ""summary_er"": ""\\""Persistent Volume Claims are managed by Kubernetes to ensure efficient resource allocation and utilization.\\""""\n  },\n  {\n    ""source"": ""Pod"",\n    ""destination"": ""Kubernetes"",\n    ""relation_description"": ""Resource Utilization"",\n    ""summary_er"": ""\\""Pods utilize resources managed by Kubernetes, ensuring efficient resource utilization and allocation.\\""""\n  },\n  {\n    ""source"": ""Minikube"",\n    ""destination"": ""Pod"",\n    ""relation_description"": ""Deployment Environment"",\n    ""summary_er"": ""\\""Minikube provides a deployment environment for Pods, allowing for local development and testing of applications.\\""""\n  },\n  {\n    ""source"": ""PersistentVolumeClaim"",\n    ""destination"": ""Pod"",\n    ""relation_description"": ""Storage Access"",\n    ""summary_er"": ""\\""Persistent Volume Claims provide storage access for Pods, ensuring data persistence and availability.\\""""\n  },\n  {\n    ""source"": ""Kubernetes"",\n    ""destination"": ""Pod"",\n    ""relation_description"": ""Resource Management"",\n    ""summary_er"": ""\\""Kubernetes manages resources for Pods, ensuring efficient resource allocation and utilization.\\""""\n  }\n]', '[\n  {\n    ""source"": ""storageclass.beta.kubernetes.io/is-default-class"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""defined as a label for a storage class"",\n    ""summary_er"": ""The default storage class for pods is defined by this label.""\n  }\n]', '[\n  {\n    ""source"": ""PersistentVolumeClaim"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""defined as the specification for a Persistent Volume Claim"",\n    ""summary_er"": ""A PersistentVolumeClaim specifies the resources required by a pod, ensuring consistent storage allocation.""\n  }\n]', '[\n  {\n    ""source"": ""PersistentVolumeClaim"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""defined as the storage requirements for a Persistent Volume Claim"",\n    ""summary_er"": ""A Persistent Volume Claim defines the storage requirements for a pod, ensuring consistent and reliable data access.""\n  }\n]', '[\n  {\n    ""source"": ""PersistentVolumeClaim"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""parameters"",\n    ""summary_er"": ""A Persistent Volume Claim defines the parameters for a pod to access a persistent volume.""\n  }\n]']","The default storage class in a GKE cluster is defined by an annotation, which makes it the default storage class. A PersistentVolumeClaim can be created without specifying a storage class and a GCE Persistent Disk of type pd-standard will be provisioned for you.","[{'highlight': 'The default storage class is what’s used to dynamically provision a PersistentVolume if the PersistentVolumeClaim doesn’t explicitly say which storage class to use.'}, {'highlight': 'You can create a PVC without specifying the storageClassName attribute and (on Google Kubernetes Engine) a GCE Persistent Disk of type pd-standard will be provi-sioned for you.'}, {'highlight': 'The annotation marks the storage class as default, making it the default storage class used by the system.'}, {'highlight': 'The type parameter is used by the provisioner to know what type of GCE PD to create, in this case a pd-standard disk.'}, {'highlight': 'The GCE Persistent Disk provisioner is used to provision PVs of this class, making it suitable for dynamic provisioning of persistent storage.'}]"
132,221,0,[],"189
Dynamic provisioning of PersistentVolumes
This PVC definition includes only the storage size request and the desired access
modes, but no storage class. When you create the PVC, whatever storage class is
marked as default will be used. You can confirm that’s the case:
$ kubectl get pvc mongodb-pvc2
NAME          STATUS   VOLUME         CAPACITY   ACCESSMODES   STORAGECLASS
mongodb-pvc2  Bound    pvc-95a5ec12   1Gi        RWO           standard
$ kubectl get pv pvc-95a5ec12
NAME           CAPACITY  ACCESSMODES  RECLAIMPOLICY  STATUS    STORAGECLASS   
pvc-95a5ec12   1Gi       RWO          Delete         Bound     standard
$ gcloud compute disks list
NAME                          ZONE            SIZE_GB  TYPE         STATUS
gke-kubia-dyn-pvc-95a5ec12    europe-west1-d  1        pd-standard  READY
...
FORCING A PERSISTENTVOLUMECLAIM TO BE BOUND TO ONE OF THE PRE-PROVISIONED 
PERSISTENTVOLUMES
This finally brings us to why you set storageClassName to an empty string in listing 6.11
(when you wanted the PVC to bind to the PV you’d provisioned manually). Let me
repeat the relevant lines of that PVC definition here:
kind: PersistentVolumeClaim
spec:
  storageClassName: """"       
If you hadn’t set the storageClassName attribute to an empty string, the dynamic vol-
ume provisioner would have provisioned a new PersistentVolume, despite there being
an appropriate pre-provisioned PersistentVolume. At that point, I wanted to demon-
strate how a claim gets bound to a manually pre-provisioned PersistentVolume. I didn’t
want the dynamic provisioner to interfere. 
TIP
Explicitly set storageClassName to """" if you want the PVC to use a pre-
provisioned PersistentVolume.
UNDERSTANDING THE COMPLETE PICTURE OF DYNAMIC PERSISTENTVOLUME PROVISIONING
This brings us to the end of this chapter. To summarize, the best way to attach per-
sistent storage to a pod is to only create the PVC (with an explicitly specified storage-
ClassName if necessary) and the pod (which refers to the PVC by name). Everything
else is taken care of by the dynamic PersistentVolume provisioner.
 To get a complete picture of the steps involved in getting a dynamically provi-
sioned PersistentVolume, examine figure 6.10.
 
 
 
Specifying an empty string as the storage class 
name ensures the PVC binds to a pre-provisioned 
PV instead of dynamically provisioning a new one.
 
",[],"[{'entity': 'PersistentVolumeClaim', 'description': 'A request for storage resources', 'category': 'software'}, {'entity': 'storageClassName', 'description': 'The name of the storage class to use', 'category': 'software'}, {'entity': 'kubectl', 'description': 'A command-line tool for managing Kubernetes resources', 'category': 'software'}, {'entity': 'get', 'description': 'A command used with kubectl to retrieve information about resources', 'category': 'software'}, {'entity': 'pvc', 'description': 'Short for PersistentVolumeClaim, a request for storage resources', 'category': 'software'}, {'entity': 'pv', 'description': 'Short for PersistentVolume, a storage resource', 'category': 'software'}, {'entity': 'gcloud', 'description': 'A command-line tool for managing Google Cloud resources', 'category': 'software'}, {'entity': 'compute disks list', 'description': 'A command used with gcloud to retrieve information about compute disks', 'category': 'software'}, {'entity': 'PersistentVolume', 'description': 'A storage resource provided by a PersistentVolumeClaim', 'category': 'software'}, {'entity': 'storageClassName', 'description': 'The name of the storage class to use (empty string indicates pre-provisioned PV)', 'category': 'software'}, {'entity': 'PVC', 'description': 'Short for PersistentVolumeClaim, a request for storage resources', 'category': 'software'}, {'entity': 'PV', 'description': 'Short for PersistentVolume, a storage resource', 'category': 'software'}, {'entity': 'dynamic volume provisioner', 'description': 'A component that provisions PersistentVolumes dynamically', 'category': 'software'}]","[{'source_entity': '""storageClassName""', 'description': 'is associated with', 'destination_entity': '""pvc""'}, {'source_entity': '""kubectl""', 'description': 'is used to manage', 'destination_entity': '""PersistentVolumeClaim""'}, {'source_entity': '""gcloud""', 'description': 'is used to interact with', 'destination_entity': '""compute disks list""'}, {'source_entity': '""kubectl""', 'description': 'is used to get information about', 'destination_entity': '""PV""'}, {'source_entity': '""kubectl""', 'description': 'is used to get information about', 'destination_entity': '""PersistentVolume""'}, {'source_entity': '""pvc""', 'description': 'is a type of', 'destination_entity': '""PersistentVolumeClaim""'}, {'source_entity': '""pv""', 'description': 'is associated with', 'destination_entity': '""PVC""'}, {'source_entity': '""dynamic volume provisioner""', 'description': 'provides storage for', 'destination_entity': '""pvc""'}]","['[\n  {\n    ""source"": ""storageClassName"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""is associated with"",\n    ""summary_er"": ""Storage class name is a characteristic of a pod, indicating its storage requirements.""\n  },\n  {\n    ""source"": ""pvc"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""is associated with"",\n    ""summary_er"": ""Persistent volume claim (PVC) is a resource request for a pod, ensuring sufficient storage capacity.""\n  }\n]', '[\n  {\n    ""source"": ""kubectl"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""is used to manage"",\n    ""summary_er"": ""Kubectl is a command-line tool for managing Kubernetes resources, including pods.""\n  },\n  {\n    ""source"": ""kubectl"",\n    ""destination"": ""PersistentVolumeClaim"",\n    ""relation_description"": ""is used to manage"",\n    ""summary_er"": ""Kubectl can also be used to manage Persistent Volume Claims (PVCs), which provide storage for pods.""\n  }\n]', '[\n  {\n    ""source"": ""gcloud"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""is used to interact with"",\n    ""summary_er"": ""The gcloud command is used to interact with a pod, which is a containerized application running on a Kubernetes cluster.""\n  },\n  {\n    ""source"": ""gcloud"",\n    ""destination"": ""compute disks list"",\n    ""relation_description"": ""is used to"",\n    ""summary_er"": ""The compute disks list command is used by gcloud to manage and list available compute disks in the Google Cloud Platform.""\n  }\n]', '[\n  {\n    ""source"": ""kubectl"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""is used to get information about"",\n    ""summary_er"": ""Kubectl is used to retrieve information about a running pod, such as its status and configuration.""\n  },\n  {\n    ""source"": ""PV"",\n    ""destination"": ""storage"",\n    ""relation_description"": ""provides persistent storage"",\n    ""summary_er"": ""Persistent Volume (PV) provides a way to persistently store data across pods, ensuring data availability even after pod termination.""\n  }\n]', '[\n  {\n    ""source"": ""kubectl"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""is used to get information about"",\n    ""summary_er"": ""kubectl is a command-line tool that retrieves information about pods, including their status, configuration, and logs.""\n  },\n  {\n    ""source"": ""kubectl"",\n    ""destination"": ""PersistentVolume"",\n    ""relation_description"": ""is used to manage"",\n    ""summary_er"": ""kubectl can be used to create, update, delete, and describe Persistent Volumes, which provide persistent storage for pods.""\n  }\n]', '[\n  {\n    ""source"": ""PVC"",\n    ""destination"": ""Pod"",\n    ""relation_description"": ""is a type of"",\n    ""summary_er"": ""A Persistent Volume Claim is a request for storage resources that can be used by a Pod.""\n  }\n]', '[\n  {\n    ""source"": ""PV"",\n    ""destination"": ""Pod"",\n    ""relation_description"": ""is associated with"",\n    ""summary_er"": ""A Persistent Volume (PV) is a resource that provides storage for a Pod, allowing it to access and utilize data.""\n  }\n]', '[\n  {\n    ""source"": ""dynamic volume provisioner"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""provides storage for"",\n    ""summary_er"": ""The dynamic volume provisioner provides persistent storage to a pod, enabling it to store and retrieve data.""\n  }\n]']","Dynamic provisioning of PersistentVolumes uses the default storage class when creating a PVC. To bind a PVC to a manually pre-provisioned PV, explicitly set storageClassName to an empty string. This prevents the dynamic provisioner from provisioning a new PV and allows the PVC to use the existing one.","[{'highlight': 'Dynamic provisioning of PersistentVolumes can use the default storage class when no specific class is specified in the PVC definition.'}, {'highlight': 'Setting storageClassName to an empty string in a PVC definition forces it to bind to a pre-provisioned PersistentVolume instead of dynamically provisioning a new one.'}, {'highlight': 'The dynamic volume provisioner will provision a new PersistentVolume if storageClassName is not set to an empty string, even if a suitable pre-provisioned PV exists.'}, {'highlight': 'To use a pre-provisioned PersistentVolume, explicitly set storageClassName to an empty string in the PVC definition.'}, {'highlight': 'The best way to attach persistent storage to a pod is to create only the PVC and the pod, with the PVC referring to itself by name, allowing the dynamic PersistentVolume provisioner to handle everything else.'}]"
133,222,0,[],"190
CHAPTER 6
Volumes: attaching disk storage to containers
6.7
Summary
This chapter has shown you how volumes are used to provide either temporary or per-
sistent storage to a pod’s containers. You’ve learned how to
Create a multi-container pod and have the pod’s containers operate on the
same files by adding a volume to the pod and mounting it in each container
Use the emptyDir volume to store temporary, non-persistent data
Use the gitRepo volume to easily populate a directory with the contents of a Git
repository at pod startup
Use the hostPath volume to access files from the host node
Mount external storage in a volume to persist pod data across pod restarts
Decouple the pod from the storage infrastructure by using PersistentVolumes
and PersistentVolumeClaims
Have PersistentVolumes of the desired (or the default) storage class dynami-
cally provisioned for each PersistentVolumeClaim
Prevent the dynamic provisioner from interfering when you want the Persistent-
VolumeClaim to be bound to a pre-provisioned PersistentVolume
In the next chapter, you’ll see what mechanisms Kubernetes provides to deliver con-
figuration data, secret information, and metadata about the pod and container to the
processes running inside a pod. This is done with the special types of volumes we’ve
mentioned in this chapter, but not yet explored.
Pod
Admin
Volume
1. Cluster admin sets up a PersistentVolume
provisioner (if one’s not already deployed)
2. Admin creates one or
more StorageClasses
and marks one as the
default (it may already
exist)
Actual
storage
Persistent
Volume
User
Persistent
Volume
provisioner
Persistent
VolumeClaim
Storage
Class
3. User creates a PVC referencing one of the
StorageClasses (or none to use the default)
6. User creates a pod with
a volume referencing the
PVC by name
4. Kubernetes looks up the
StorageClass and the provisioner
referenced in it and asks the provisioner
to provision a new PV based on the
PVC’s requested access mode and
storage size and the parameters
in the StorageClass
5. Provisioner provisions the
actual storage, creates
a PersistentVolume, and
binds it to the PVC
Figure 6.10
The complete picture of dynamic provisioning of PersistentVolumes
 
",[],"[{'entity': 'Pod', 'description': 'A pod is a logical host for one or more containers.', 'category': 'application'}, {'entity': 'Volume', 'description': ""A volume provides storage to a pod's containers."", 'category': 'database'}, {'entity': 'emptyDir', 'description': 'A type of volume that stores temporary, non-persistent data.', 'category': 'process'}, {'entity': 'gitRepo', 'description': 'A type of volume that populates a directory with the contents of a Git repository at pod startup.', 'category': 'database'}, {'entity': 'hostPath', 'description': 'A type of volume that accesses files from the host node.', 'category': 'hardware'}, {'entity': 'PersistentVolume', 'description': 'A Persistent Volume is a storage resource provisioned by the cluster.', 'category': 'database'}, {'entity': 'PersistentVolumeClaim', 'description': 'A Persistent Volume Claim is a request for storage resources.', 'category': 'application'}, {'entity': 'StorageClass', 'description': 'A Storage Class defines the policies for allocating storage resources.', 'category': 'database'}, {'entity': 'PersistentVolumeClaim', 'description': 'A Persistent Volume Claim is a request for storage resources.', 'category': 'application'}, {'entity': 'Kubernetes', 'description': 'An open-source container orchestration system.', 'category': 'software'}, {'entity': 'Pod', 'description': 'A pod is a logical host for one or more containers.', 'category': 'application'}, {'entity': 'PersistentVolume', 'description': 'A Persistent Volume is a storage resource provisioned by the cluster.', 'category': 'database'}, {'entity': 'PersistentVolumeClaim', 'description': 'A Persistent Volume Claim is a request for storage resources.', 'category': 'application'}, {'entity': 'StorageClass', 'description': 'A Storage Class defines the policies for allocating storage resources.', 'category': 'database'}]","[{'source_entity': 'Pod', 'description': 'requests storage resources from Persistent Volume Claim', 'destination_entity': 'PersistentVolumeClaim'}, {'source_entity': 'Kubernetes', 'description': 'manages and schedules Pods to run on hosts with hostPath volumes', 'destination_entity': 'hostPath'}, {'source_entity': 'Pod', 'description': 'uses Persistent Volumes for storage needs', 'destination_entity': 'PersistentVolume'}, {'source_entity': 'Kubernetes', 'description': 'provides a way to store data in emptyDir volumes', 'destination_entity': 'emptyDir'}, {'source_entity': 'Pod', 'description': 'can use gitRepo as a volume for source code', 'destination_entity': 'gitRepo'}, {'source_entity': 'Kubernetes', 'description': 'manages Persistent Volumes and their Storage Classes', 'destination_entity': 'StorageClass'}, {'source_entity': 'Pod', 'description': 'can use Persistent Volume Claims to request storage resources', 'destination_entity': 'PersistentVolumeClaim'}, {'source_entity': 'Kubernetes', 'description': 'provides a way to store data in Volumes', 'destination_entity': 'Volume'}]","['[\n  {\n    ""source"": ""Pod"",\n    ""destination"": ""PersistentVolumeClaim"",\n    ""relation_description"": ""requests storage resources"",\n    ""summary_er"": ""A Pod requests storage resources from a Persistent Volume Claim, which provides access to persistent storage.""\n  }\n]', '[\n  {\n    ""source"": ""Kubernetes"",\n    ""destination"": ""Pod"",\n    ""relation_description"": ""manages and schedules Pods to run on hosts with hostPath volumes"",\n    ""summary_er"": ""Kubernetes manages and schedules pods to run on hosts using hostPath volumes, ensuring efficient resource utilization.""\n  }\n]', '[\n  {\n    ""source"": ""Pod"",\n    ""destination"": ""PersistentVolume"",\n    ""relation_description"": ""uses Persistent Volumes for storage needs"",\n    ""summary_er"": ""A Pod uses a Persistent Volume for storing data, ensuring persistence across restarts and scaling.""\n  }\n]', '[\n  {\n    ""source"": ""Kubernetes"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""provides a way to store data in emptyDir volumes"",\n    ""summary_er"": ""Kubernetes provides a way to store data in emptyDir volumes, allowing pods to access shared storage.""\n  }\n]', '[\n  {\n    ""source"": ""Pod"",\n    ""destination"": ""gitRepo"",\n    ""relation_description"": ""can use as a volume for source code"",\n    ""summary_er"": ""A Pod can utilize a Git repository as a volume to manage its source code, enabling efficient collaboration and version control.""\n  }\n]', '[\n  {\n    ""source"": ""Kubernetes"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""manages Persistent Volumes and their Storage Classes"",\n    ""summary_er"": ""Kubernetes manages persistent volumes and storage classes to ensure efficient data storage for pods.""\n  }\n]', '[\n  {\n    ""source"": ""Pod"",\n    ""destination"": ""PersistentVolumeClaim"",\n    ""relation_description"": ""can use Persistent Volume Claims to request storage resources"",\n    ""summary_er"": ""A Pod can utilize Persistent Volume Claims to acquire storage resources, enabling efficient data management within the Kubernetes environment.""\n  }\n]', '[\n  {\n    ""source"": ""Kubernetes"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""provides a way to store data in Volumes"",\n    ""summary_er"": ""Kubernetes provides persistent storage for pods through volumes, ensuring data availability and consistency.""\n  }\n]']","This chapter explains how volumes provide temporary or persistent storage to containers in a pod. Key concepts include creating multi-container pods with shared files using volumes, mounting external storage for persistence across restarts, and dynamically provisioning PersistentVolumes through PersistentVolumeClaims and StorageClasses.","[{'highlight': ""You can create a multi-container pod and have the pod's containers operate on the same files by adding a volume to the pod and mounting it in each container.""}, {'highlight': 'PersistentVolumes of the desired (or the default) storage class can be dynamically provisioned for each PersistentVolumeClaim, preventing the dynamic provisioner from interfering when you want the Persistent-VolumeClaim to be bound to a pre-provisioned PersistentVolume.'}, {'highlight': 'To use persistent storage, cluster admin sets up a PersistentVolume provisioner, creates one or more StorageClasses, and marks one as the default. User then creates a PVC referencing one of the StorageClasses (or none to use the default) and a pod with a volume referencing the PVC by name.'}, {'highlight': ""The dynamic provisioning process involves Kubernetes looking up the StorageClass and provisioner referenced in it, asking the provisioner to provision a new PV based on the PVC's requested access mode and storage size, and then binding it to the PVC.""}, {'highlight': ""You can use different types of volumes such as emptyDir, gitRepo, hostPath, and PersistentVolumes to provide temporary or persistent storage to a pod's containers, decoupling the pod from the storage infrastructure.""}]"
134,223,0,[],"191
ConfigMaps and Secrets:
configuring applications
Up to now you haven’t had to pass any kind of configuration data to the apps you’ve
run in the exercises in this book. Because almost all apps require configuration (set-
tings that differ between deployed instances, credentials for accessing external sys-
tems, and so on), which shouldn’t be baked into the built app itself, let’s see how to
pass configuration options to your app when running it in Kubernetes.
7.1
Configuring containerized applications
Before we go over how to pass configuration data to apps running in Kubernetes,
let’s look at how containerized applications are usually configured.
 If you skip the fact that you can bake the configuration into the application
itself, when starting development of a new app, you usually start off by having the
This chapter covers
Changing the main process of a container
Passing command-line options to the app
Setting environment variables exposed to the app
Configuring apps through ConfigMaps
Passing sensitive information through Secrets
 
",[],"[{'entity': 'ConfigMaps', 'description': 'a way to pass configuration data to applications running in Kubernetes', 'category': 'software'}, {'entity': 'Secrets', 'description': 'a way to pass sensitive information to applications running in Kubernetes', 'category': 'software'}, {'entity': 'applications', 'description': 'programs that run on a computer or mobile device', 'category': 'application'}, {'entity': 'Kubernetes', 'description': 'an open-source container orchestration system for automating the deployment, scaling, and management of containers', 'category': 'software'}, {'entity': 'containers', 'description': 'lightweight and standalone execution environments that package an application and its dependencies together in a single unit', 'category': 'container'}, {'entity': 'process', 'description': 'a program or set of programs running on a computer, including the operating system itself', 'category': 'process'}, {'entity': 'command-line options', 'description': 'arguments passed to an application when it is run from the command line', 'category': 'software'}, {'entity': 'environment variables', 'description': 'variables that can be set and accessed by applications running on a computer', 'category': 'process'}, {'entity': 'ConfigMaps', 'description': 'a way to pass configuration data to applications running in Kubernetes', 'category': 'software'}, {'entity': 'Secrets', 'description': 'a way to pass sensitive information to applications running in Kubernetes', 'category': 'software'}]","[{'source_entity': 'Kubernetes', 'description': 'manages and orchestrates', 'destination_entity': 'containers'}, {'source_entity': 'containers', 'description': 'run and execute', 'destination_entity': 'applications'}, {'source_entity': 'process', 'description': 'executes and runs', 'destination_entity': 'command-line options'}, {'source_entity': 'Kubernetes', 'description': 'manages and secures', 'destination_entity': 'Secrets'}, {'source_entity': 'Kubernetes', 'description': 'configures and manages', 'destination_entity': 'ConfigMaps'}, {'source_entity': 'containers', 'description': 'access and utilize', 'destination_entity': 'environment variables'}]","['[\n  {\n    ""source"": ""Kubernetes"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""manages and orchestrates"",\n    ""summary_er"": ""Kubernetes manages and orchestrates containerized applications, including pods, which are groups of one or more containers that share resources.""\n  }\n]', '[\n  {\n    ""source"": ""containers"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""run and execute"",\n    ""summary_er"": ""Containers are executed within a Pod, allowing for multiple containers to run together in a single unit.""\n  }\n]', '[\n  {\n    ""source"": ""process"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""executes and runs"",\n    ""summary_er"": ""A process executes and runs within a pod, utilizing command-line options to manage its lifecycle.""\n  }\n]', '[\n  {\n    ""source"": ""Kubernetes"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""manages and secures"",\n    ""summary_er"": ""Kubernetes securely manages and orchestrates pods, ensuring efficient resource utilization.""\n  },\n  {\n    ""source"": ""Docker"",\n    ""destination"": ""container"",\n    ""relation_description"": ""builds and runs"",\n    ""summary_er"": ""Docker builds and runs containers, providing a lightweight and portable way to deploy applications.""\n  },\n  {\n    ""source"": ""Machine Learning"",\n    ""destination"": ""model"",\n    ""relation_description"": ""trains and deploys"",\n    ""summary_er"": ""Machine Learning trains and deploys models, enabling intelligent decision-making and automation in various domains.""\n  },\n  {\n    ""source"": ""Generative AI"",\n    ""destination"": ""data"",\n    ""relation_description"": ""generates and manipulates"",\n    ""summary_er"": ""Generative AI generates and manipulates data, creating realistic synthetic samples for training and testing purposes.""\n  },\n  {\n    ""source"": ""Natural Language Understanding"",\n    ""destination"": ""text"",\n    ""relation_description"": ""analyzes and interprets"",\n    ""summary_er"": ""Natural Language Understanding analyzes and interprets text, extracting meaning and context from human language inputs.""\n  },\n  {\n    ""source"": ""Computer Vision"",\n    ""destination"": ""image"",\n    ""relation_description"": ""interprets and recognizes"",\n    ""summary_er"": ""Computer Vision interprets and recognizes images, enabling object detection, classification, and scene understanding in various applications.""\n  }\n]', '[\n  {\n    ""source"": ""Kubernetes"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""configures and manages"",\n    ""summary_er"": ""Kubernetes configures and manages pods, ensuring efficient resource allocation and scalability.""\n  },\n  {\n    ""source"": ""Kubernetes"",\n    ""destination"": ""ConfigMaps"",\n    ""relation_description"": ""manages"",\n    ""summary_er"": ""Kubernetes manages ConfigMaps to store and retrieve configuration data for applications.""\n  }\n]', '[\n  {\n    ""source"": ""containers"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""access and utilize"",\n    ""summary_er"": ""Containers in a pod can access and utilize each other\'s environment variables, enabling communication and resource sharing between them.""\n  }\n]']","ConfigMaps and Secrets allow passing configuration data to Kubernetes applications, configuring containerized applications by changing the main process, passing command-line options, setting environment variables, or using ConfigMaps for non-sensitive settings and Secrets for sensitive info like credentials.","[{'highlight': 'This chapter covers changing the main process of a container, passing command-line options to the app, setting environment variables exposed to the app, configuring apps through ConfigMaps, and passing sensitive information through Secrets.'}, {'highlight': 'When starting development of a new app, you usually start off by having the configuration baked into the application itself or passing it as command-line options or environment variables.'}, {'highlight': ""ConfigMaps are used to pass configuration data to apps running in Kubernetes, which shouldn't be baked into the built app itself.""}, {'highlight': 'Secrets are used to pass sensitive information through Kubernetes, such as credentials for accessing external systems.'}, {'highlight': 'Configuring applications in Kubernetes involves passing configuration options, setting environment variables, and using ConfigMaps and Secrets.'}]"
135,224,0,[],"192
CHAPTER 7
ConfigMaps and Secrets: configuring applications
app configured through command-line arguments. Then, as the list of configuration
options grows, you can move the configuration into a config file. 
 Another way of passing configuration options to an application that’s widely popu-
lar in containerized applications is through environment variables. Instead of having
the app read a config file or command-line arguments, the app looks up the value of a
certain environment variable. The official MySQL container image, for example, uses
an environment variable called MYSQL_ROOT_PASSWORD for setting the password for the
root super-user account. 
 But why are environment variables so popular in containers? Using configuration
files inside Docker containers is a bit tricky, because you’d have to bake the config file
into the container image itself or mount a volume containing the file into the con-
tainer. Obviously, baking files into the image is similar to hardcoding configuration
into the source code of the application, because it requires you to rebuild the image
every time you want to change the config. Plus, everyone with access to the image can
see the config, including any information that should be kept secret, such as creden-
tials or encryption keys. Using a volume is better, but still requires you to make sure
the file is written to the volume before the container is started. 
 If you’ve read the previous chapter, you might think of using a gitRepo volume as
a configuration source. That’s not a bad idea, because it allows you to keep the config
nicely versioned and enables you to easily rollback a config change if necessary. But a
simpler way allows you to put the configuration data into a top-level Kubernetes
resource and store it and all the other resource definitions in the same Git repository
or in any other file-based storage. The Kubernetes resource for storing configuration
data is called a ConfigMap. We’ll learn how to use it in this chapter.
 Regardless if you’re using a ConfigMap to store configuration data or not, you can
configure your apps by
Passing command-line arguments to containers
Setting custom environment variables for each container
Mounting configuration files into containers through a special type of volume
We’ll go over all these options in the next few sections, but before we start, let’s look
at config options from a security perspective. Though most configuration options
don’t contain any sensitive information, several can. These include credentials, pri-
vate encryption keys, and similar data that needs to be kept secure. This type of infor-
mation needs to be handled with special care, which is why Kubernetes offers
another type of first-class object called a Secret. We’ll learn about it in the last part of
this chapter.
7.2
Passing command-line arguments to containers
In all the examples so far, you’ve created containers that ran the default command
defined in the container image, but Kubernetes allows overriding the command as
part of the pod’s container definition when you want to run a different executable
 
",[],"[{'entity': 'ConfigMaps', 'description': 'Kubernetes resource for storing configuration data', 'category': 'database'}, {'entity': 'Secrets', 'description': 'Kubernetes object for handling sensitive information', 'category': 'database'}, {'entity': 'command-line arguments', 'description': 'way of passing configuration options to an application', 'category': 'application'}, {'entity': 'config file', 'description': 'file containing configuration options', 'category': 'application'}, {'entity': 'environment variables', 'description': 'way of passing configuration options to an application', 'category': 'application'}, {'entity': 'Docker containers', 'description': 'containerized applications', 'category': 'container'}, {'entity': 'Kubernetes resources', 'description': 'top-level Kubernetes resource for storing configuration data', 'category': 'database'}, {'entity': 'Git repository', 'description': 'file-based storage for Kubernetes resource definitions', 'category': 'storage'}, {'entity': 'ConfigMap', 'description': 'Kubernetes resource for storing configuration data', 'category': 'database'}, {'entity': 'Secret', 'description': 'Kubernetes object for handling sensitive information', 'category': 'database'}, {'entity': 'pod', 'description': 'container definition in Kubernetes', 'category': 'application'}, {'entity': 'container image', 'description': 'image containing the application and its dependencies', 'category': 'container'}, {'entity': 'volume', 'description': 'special type of volume for mounting configuration files into containers', 'category': 'storage'}]","[{'source_entity': '""Kubernetes resources""', 'description': 'are used to manage and orchestrate Docker containers', 'destination_entity': '""Docker containers""'}, {'source_entity': '""config file""', 'description': 'is used to store configuration settings for a Kubernetes pod', 'destination_entity': '""pod""'}, {'source_entity': '""Git repository""', 'description': 'is used as a source of Docker container images', 'destination_entity': '""container image""'}, {'source_entity': '""volume""', 'description': 'is used to persist data for a Kubernetes pod', 'destination_entity': '""pod""'}, {'source_entity': '""Secret""', 'description': 'is used to store sensitive information for a Kubernetes pod', 'destination_entity': '""pod""'}, {'source_entity': '""ConfigMaps""', 'description': 'are used to store configuration settings for a Kubernetes pod', 'destination_entity': '""pod""'}, {'source_entity': '""container image""', 'description': 'is used to create a new Docker container', 'destination_entity': '""Docker containers""'}, {'source_entity': '""environment variables""', 'description': 'are used to configure a Kubernetes pod', 'destination_entity': '""pod""'}, {'source_entity': '""command-line arguments""', 'description': 'are used to pass configuration settings to a Docker container', 'destination_entity': '""Docker containers""'}, {'source_entity': '""volume""', 'description': 'is used to persist data for a Kubernetes pod', 'destination_entity': '""pod""'}]","['[\n  {\n    ""source"": ""Kubernetes resources"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""are managed and orchestrated by"",\n    ""summary_er"": ""Kubernetes resources manage and orchestrate Docker containers to create a pod.""\n  },\n  {\n    ""source"": ""Docker containers"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""are created and run within"",\n    ""summary_er"": ""Docker containers are created and run within a Kubernetes-managed pod.""\n  }\n]', '[\n  {\n    ""source"": ""config file"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""is used to store configuration settings"",\n    ""summary_er"": ""A config file is used to store configuration settings for a Kubernetes pod, which can be applied to a running pod.""\n  }\n]', '[\n  {\n    ""source"": ""Git repository"",\n    ""destination"": ""Docker container image"",\n    ""relation_description"": ""is used as a source of"",\n    ""summary_er"": ""A Git repository serves as the origin for Docker container images, providing the necessary code and metadata for building and deploying containers.""\n  },\n  {\n    ""source"": ""Docker container image"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""is used to create"",\n    ""summary_er"": ""A Docker container image is utilized to generate a pod, which is a deployable unit of application code in Kubernetes.""\n  }\n]', '[\n  {\n    ""source"": ""volume"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""is used to persist data for a Kubernetes pod"",\n    ""summary_er"": ""A volume is attached to a pod to store and retrieve data, ensuring persistence across pod restarts or re-deployments.""\n  }\n]', '[\n  {\n    ""source"": ""Secret"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""is used to store sensitive information"",\n    ""summary_er"": ""A Secret is used to securely store and provide sensitive information, such as credentials or API keys, to a Kubernetes pod.""\n  }\n]', '[\n  {\n    ""source"": ""ConfigMaps"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""are used to store configuration settings"",\n    ""summary_er"": ""ConfigMaps are used to store config settings for a pod, providing dynamic configuration to the pod.""\n  }\n]', '[{""source"": ""container image"", ""destination"": ""pod"", ""relation_description"": ""is used to create a new Docker container"", ""summary_er"": ""A container image is used to create a new Docker container, which can then be run as a pod in Kubernetes.""}]', '[\n  {\n    ""source"": ""environment variables"",\n    ""destination"": ""Kubernetes pod"",\n    ""relation_description"": ""are used to configure"",\n    ""summary_er"": ""Environment variables are used to configure a Kubernetes pod, providing it with necessary settings and parameters.""\n  },\n  {\n    ""source"": ""Kubernetes pod"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""is configured by"",\n    ""summary_er"": ""A Kubernetes pod is configured by environment variables, which provide it with essential settings and configurations.""\n  }\n]', '[\n  {\n    ""source"": ""command-line arguments"",\n    ""destination"": ""Docker container"",\n    ""relation_description"": ""pass configuration settings"",\n    ""summary_er"": ""Command-line arguments are used to pass configuration settings to a Docker container, allowing for customization and flexibility.""\n  }\n]', '[\n  {\n    ""source"": ""volume"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""is used to persist data for a Kubernetes pod"",\n    ""summary_er"": ""A volume is attached to a pod to store and retrieve data, ensuring persistence across pod restarts or rescheduling.""\n  }\n]']","ConfigMaps and Secrets allow storing configuration data and sensitive information separately from container images. ConfigMaps store config data as a top-level Kubernetes resource, while Secrets handle sensitive info like credentials or encryption keys with special care. This allows for easier management of config changes and keeping sensitive data secure.","[{'highlight': 'ConfigMaps and Secrets: configuring applications can be done through command-line arguments, environment variables, or mounting configuration files into containers.'}, {'highlight': 'Environment variables are popular in containers because they allow for easy configuration without having to bake config files into the image or mount volumes.'}, {'highlight': 'ConfigMaps are a simpler way to store configuration data as a top-level Kubernetes resource, allowing for versioning and rollback of changes.'}, {'highlight': 'Secrets in Kubernetes offer special care for sensitive information like credentials, private encryption keys, and similar data that needs to be kept secure.'}, {'highlight': ""Kubernetes allows overriding the default command defined in a container image by passing command-line arguments as part of the pod's container definition.""}]"
136,225,0,[],"193
Passing command-line arguments to containers
instead of the one specified in the image, or want to run it with a different set of com-
mand-line arguments. We’ll look at how to do that now.
7.2.1
Defining the command and arguments in Docker
The first thing I need to explain is that the whole command that gets executed in the
container is composed of two parts: the command and the arguments. 
UNDERSTANDING ENTRYPOINT AND CMD
In a Dockerfile, two instructions define the two parts:

ENTRYPOINT defines the executable invoked when the container is started.

CMD specifies the arguments that get passed to the ENTRYPOINT.
Although you can use the CMD instruction to specify the command you want to execute
when the image is run, the correct way is to do it through the ENTRYPOINT instruction
and to only specify the CMD if you want to define the default arguments. The image can
then be run without specifying any arguments
$ docker run <image>
or with additional arguments, which override whatever’s set under CMD in the Dockerfile:
$ docker run <image> <arguments>
UNDERSTANDING THE DIFFERENCE BETWEEN THE SHELL AND EXEC FORMS
But there’s more. Both instructions support two different forms:

shell form—For example, ENTRYPOINT node app.js.

exec form—For example, ENTRYPOINT [""node"", ""app.js""].
The difference is whether the specified command is invoked inside a shell or not. 
 In the kubia image you created in chapter 2, you used the exec form of the ENTRY-
POINT instruction: 
ENTRYPOINT [""node"", ""app.js""]
This runs the node process directly (not inside a shell), as you can see by listing the
processes running inside the container:
$ docker exec 4675d ps x
  PID TTY      STAT   TIME COMMAND
    1 ?        Ssl    0:00 node app.js
   12 ?        Rs     0:00 ps x
If you’d used the shell form (ENTRYPOINT node app.js), these would have been the
container’s processes:
$ docker exec -it e4bad ps x
  PID TTY      STAT   TIME COMMAND
    1 ?        Ss     0:00 /bin/sh -c node app.js
 
",[],"[{'entity': 'command-line arguments', 'description': 'arguments passed to a container instead of the one specified in the image', 'category': 'application'}, {'entity': 'Docker', 'description': 'containerization platform', 'category': 'software'}, {'entity': 'ENTRYPOINT', 'description': 'instruction in a Dockerfile that defines the executable invoked when the container is started', 'category': 'application'}, {'entity': 'CMD', 'description': 'instruction in a Dockerfile that specifies the arguments passed to the ENTRYPOINT', 'category': 'application'}, {'entity': 'docker run', 'description': 'command used to execute a container with specified image and arguments', 'category': 'application'}, {'entity': 'image', 'description': 'pre-built Docker container that can be run as is or modified', 'category': 'software'}, {'entity': 'node', 'description': 'JavaScript runtime environment', 'category': 'software'}, {'entity': 'app.js', 'description': 'JavaScript application file', 'category': 'application'}, {'entity': 'docker exec', 'description': 'command used to execute a command inside a running container', 'category': 'application'}, {'entity': 'ps x', 'description': 'Unix command used to list processes running in the system', 'category': 'application'}, {'entity': 'docker exec -it', 'description': 'command used to execute a command inside a running container with interactive shell', 'category': 'application'}]","[{'source_entity': '""CMD""', 'description': 'executes', 'destination_entity': '""image""'}, {'source_entity': '""docker run""', 'description': 'runs', 'destination_entity': '""image""'}, {'source_entity': '""ps x""', 'description': 'displays', 'destination_entity': '""processes""'}, {'source_entity': '""ENTRYPOINT""', 'description': 'specifies', 'destination_entity': '""app.js""'}, {'source_entity': '""docker exec""', 'description': 'executes', 'destination_entity': '""image""'}, {'source_entity': '""node""', 'description': 'runs', 'destination_entity': '""app.js""'}, {'source_entity': '""docker exec -it""', 'description': 'interactively executes', 'destination_entity': '""image""'}]","['[\n  {\n    ""source"": ""CMD"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""executes"",\n    ""summary_er"": ""\\""The CMD command in a Dockerfile executes a command in a new container, which can be used to run a pod\'s image.\\""""\n  },\n  {\n    ""source"": ""image"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""runs"",\n    ""summary_er"": ""\\""An image is used to run a pod in Kubernetes, providing the necessary dependencies and binaries for the container to execute.\\""""\n  }\n]', '[\n  {\n    ""source"": ""docker"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""runs"",\n    ""summary_er"": ""Docker container runs as a process within a Kubernetes pod, utilizing the pod\'s resources and network connectivity.""\n  }\n]', '[\n  {\n    ""source"": ""ps x"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""displays"",\n    ""summary_er"": ""The \'ps x\' command displays information about running processes, which are executed within a pod in Kubernetes.""\n  }\n]', '[\n  {\n    ""source"": ""ENTRYPOINT"",\n    ""destination"": ""app.js"",\n    ""relation_description"": ""specifies"",\n    ""summary_er"": ""The ENTRYPOINT in Docker specifies the default command to run when a container starts, which in this case points to the app.js file.""\n  }\n]', '[\n  {\n    ""source"": ""docker exec"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""executes"",\n    ""summary_er"": ""The Docker exec command runs a process within a running container, executing commands or scripts inside the pod.""\n  }\n]', '[\n  {\n    ""source"": ""node"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""runs"",\n    ""summary_er"": ""A node in a Kubernetes cluster runs a pod, which is a containerized application.""\n  }\n]', '[\n  {\n    ""source"": ""docker"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""executes"",\n    ""summary_er"": ""Docker executes a command interactively within a running pod.""\n  }\n]']","You can pass command-line arguments to Docker containers by specifying them in the docker run command, overriding any default arguments set in the image's Dockerfile. This is achieved through the ENTRYPOINT instruction, which defines the executable, and CMD, which specifies the default arguments. The ENTRYPOINT instruction supports two forms: shell and exec, where shell form invokes the command inside a shell and exec form runs it directly.","[{'highlight': 'The correct way to specify a command when running a Docker image is through the ENTRYPOINT instruction, and only use CMD to define default arguments.'}]"
137,226,0,[],"194
CHAPTER 7
ConfigMaps and Secrets: configuring applications
    7 ?        Sl     0:00 node app.js
   13 ?        Rs+    0:00 ps x
As you can see, in that case, the main process (PID 1) would be the shell process
instead of the node process. The node process (PID 7) would be started from that
shell. The shell process is unnecessary, which is why you should always use the exec
form of the ENTRYPOINT instruction.
MAKING THE INTERVAL CONFIGURABLE IN YOUR FORTUNE IMAGE
Let’s modify your fortune script and image so the delay interval in the loop is configu-
rable. You’ll add an INTERVAL variable and initialize it with the value of the first com-
mand-line argument, as shown in the following listing.
#!/bin/bash
trap ""exit"" SIGINT
INTERVAL=$1
echo Configured to generate new fortune every $INTERVAL seconds
mkdir -p /var/htdocs
while :
do
  echo $(date) Writing fortune to /var/htdocs/index.html
  /usr/games/fortune > /var/htdocs/index.html
  sleep $INTERVAL
done
You’ve added or modified the lines in bold font. Now, you’ll modify the Dockerfile so
it uses the exec version of the ENTRYPOINT instruction and sets the default interval to
10 seconds using the CMD instruction, as shown in the following listing.
FROM ubuntu:latest
RUN apt-get update ; apt-get -y install fortune
ADD fortuneloop.sh /bin/fortuneloop.sh
ENTRYPOINT [""/bin/fortuneloop.sh""]        
CMD [""10""]                                
You can now build and push the image to Docker Hub. This time, you’ll tag the image
as args instead of latest:
$ docker build -t docker.io/luksa/fortune:args .
$ docker push docker.io/luksa/fortune:args
You can test the image by running it locally with Docker:
$ docker run -it docker.io/luksa/fortune:args
Configured to generate new fortune every 10 seconds
Fri May 19 10:39:44 UTC 2017 Writing fortune to /var/htdocs/index.html
Listing 7.1
Fortune script with interval configurable through argument: fortune-args/
fortuneloop.sh
Listing 7.2
Dockerfile for the updated fortune image: fortune-args/Dockerfile
The exec form of the 
ENTRYPOINT instruction
The default argument 
for the executable
 
",[],"[{'entity': 'ConfigMaps', 'description': 'a feature in Kubernetes that allows you to store and retrieve configuration data', 'category': 'software'}, {'entity': 'Secrets', 'description': 'a feature in Kubernetes that allows you to store sensitive information, such as passwords or API keys', 'category': 'software'}, {'entity': 'ENTRYPOINT instruction', 'description': 'a command in a Dockerfile that specifies the default command to run when the container is started', 'category': 'software'}, {'entity': 'CMD instruction', 'description': 'a command in a Dockerfile that specifies the default arguments for the ENTRYPOINT command', 'category': 'software'}, {'entity': 'Dockerfile', 'description': 'a text file that contains instructions for building a Docker image', 'category': 'software'}, {'entity': 'ubuntu:latest', 'description': 'a pre-built Docker image based on Ubuntu Linux', 'category': 'software'}, {'entity': 'apt-get update', 'description': 'a command used to update the package index in Ubuntu', 'category': 'software'}, {'entity': 'apt-get -y install fortune', 'description': 'a command used to install the fortune program in Ubuntu', 'category': 'software'}, {'entity': 'fortuneloop.sh', 'description': 'a Bash script that generates fortunes at regular intervals', 'category': 'software'}, {'entity': 'interval', 'description': 'a variable that specifies the delay interval between fortunes', 'category': 'software'}, {'entity': 'PID 1', 'description': 'the process ID of the shell process', 'category': 'process'}, {'entity': 'PID 7', 'description': 'the process ID of the node process', 'category': 'process'}, {'entity': 'shell', 'description': 'a command-line interface for interacting with the operating system', 'category': 'software'}, {'entity': 'exec form', 'description': 'a way to specify a default command in a Dockerfile using the ENTRYPOINT instruction', 'category': 'software'}, {'entity': 'docker build', 'description': 'a command used to build a Docker image from a Dockerfile', 'category': 'software'}, {'entity': 'docker push', 'description': 'a command used to push a Docker image to a registry, such as Docker Hub', 'category': 'software'}, {'entity': 'docker run', 'description': 'a command used to run a Docker container from an image', 'category': 'software'}]","[{'source_entity': '""ENTRYPOINT instruction""', 'description': 'executes', 'destination_entity': '""fortuneloop.sh""'}, {'source_entity': '""PID 1""', 'description': 'runs', 'destination_entity': '""fortuneloop.sh""'}, {'source_entity': '""apt-get update""', 'description': 'updates', 'destination_entity': '""ubuntu:latest""'}, {'source_entity': '""interval""', 'description': 'sets the interval for', 'destination_entity': '""apt-get update""'}, {'source_entity': '""shell""', 'description': 'executes in', 'destination_entity': '""fortuneloop.sh""'}, {'source_entity': '""exec form""', 'description': 'executes the command in', 'destination_entity': '""apt-get -y install fortune""'}, {'source_entity': '""apt-get -y install fortune""', 'description': 'installs', 'destination_entity': '""fortune""'}, {'source_entity': '""docker push""', 'description': 'pushes the image to', 'destination_entity': '""Dockerfile""'}, {'source_entity': '""docker run""', 'description': 'runs the container from', 'destination_entity': '""fortuneloop.sh""'}, {'source_entity': '""CMD instruction""', 'description': 'specifies the command to be executed in', 'destination_entity': '""Dockerfile""'}, {'source_entity': '""Secrets""', 'description': 'manages and stores', 'destination_entity': '""ConfigMaps""'}, {'source_entity': '""PID 7""', 'description': 'runs the process with ID', 'destination_entity': '""docker build""'}, {'source_entity': '""docker build""', 'description': 'builds the Docker image from', 'destination_entity': '""Dockerfile""'}]","['[\n  {\n    ""source"": ""ENTRYPOINT instruction"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""executes"",\n    ""summary_er"": ""The ENTRYPOINT instruction executes a command within a Docker container, which can be used to start a pod.""\n  }\n]', '[\n    {\n        ""source"": ""PID 1"",\n        ""destination"": ""fortuneloop.sh"",\n        ""relation_description"": ""runs"",\n        ""summary_er"": ""Process ID 1 runs the fortuneloop.sh pod, indicating that it executes a shell script.""\n    }\n]', '[\n  {\n    ""source"": ""apt-get update"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""updates"",\n    ""summary_er"": ""The \'apt-get update\' command updates the package list in a pod, ensuring it has the latest packages and dependencies.""\n  }\n]', '[\n  {\n    ""source"": ""Interval"",\n    ""destination"": ""Pod"",\n    ""relation_description"": ""sets the interval for"",\n    ""summary_er"": ""The interval entity configures the time duration for a pod\'s execution.""\n  },\n  {\n    ""source"": ""Apt-get update"",\n    ""destination"": ""Pod"",\n    ""relation_description"": """",\n    ""summary_er"": ""The apt-get update command ensures that a pod has access to the latest package repository.""\n  }\n]', '[\n  {\n    ""source"": ""shell"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""executes in"",\n    ""summary_er"": ""A shell script executes within a containerized environment, specifically a pod, allowing for isolated and efficient execution of commands.""\n  }\n]', '[\n  {\n    ""source"": ""exec form"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""executes the command in"",\n    ""summary_er"": ""Executes a command within a pod, installing software packages using apt-get.""\n  }\n]', '[\n  {\n    ""source"": ""apt-get"",\n    ""destination"": ""fortune"",\n    ""relation_description"": ""installs"",\n    ""summary_er"": ""The apt-get package manager installs the fortune package.""\n  }\n]', '[{""source"": ""docker push"", ""destination"": ""pod"", ""relation_description"": ""pushes the image to"", ""summary_er"": ""Pushing Docker images to a Kubernetes pod for deployment.""}, {""source"": ""Dockerfile"", ""destination"": ""image"", ""relation_description"": ""builds the"", ""summary_er"": ""Building a Docker image from a Dockerfile for containerization.""}]', '[\n  {\n    ""source"": ""docker"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""runs the container from"",\n    ""summary_er"": ""Docker runs a container from an image, which can be thought of as a pod in Kubernetes.""\n  },\n  {\n    ""source"": ""fortuneloop.sh"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""runs the container from"",\n    ""summary_er"": ""FortuneLoop.sh is a script that runs a container from an image, similar to how a pod is created in Kubernetes.""\n  }\n]', '[\n  {\n    ""source"": ""CMD instruction"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""specifies the command to be executed in"",\n    ""summary_er"": ""The CMD instruction defines the default command to run within a Docker container, which can override the default behavior of running /bin/sh -c \\""\\"".""\n  },\n  {\n    ""source"": ""Dockerfile"",\n    ""destination"": ""CMD instruction"",\n    ""relation_description"": ""defines the default command to run within a Docker container"",\n    ""summary_er"": ""The Dockerfile is used to define the instructions for building a Docker image, and the CMD instruction is one of these instructions that specifies the default command to execute.""\n  }\n]', '[\n  {\n    ""source"": ""Secrets"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""manages and stores"",\n    ""summary_er"": ""Secrets manage and store sensitive data for pods, ensuring secure configuration.""\n  },\n  {\n    ""source"": ""ConfigMaps"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""manages and stores"",\n    ""summary_er"": ""ConfigMaps manage and store configuration data for pods, enabling flexible deployment.""\n  }\n]', '[\n  {\n    ""source"": ""PID 7"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""runs the process with ID"",\n    ""summary_er"": ""A container process with ID 7 is running within a pod, utilizing Docker\'s build functionality.""\n  },\n  {\n    ""source"": ""docker build"",\n    ""destination"": ""image"",\n    ""relation_description"": ""builds an image using Dockerfile instructions"",\n    ""summary_er"": ""Docker builds an image from a Dockerfile, creating a containerized package for deployment.""\n  }\n]', '[\n  {\n    ""source"": ""docker build"",\n    ""destination"": ""Dockerfile"",\n    ""relation_description"": ""builds the Docker image from"",\n    ""summary_er"": ""The \'docker build\' command uses a Dockerfile to create a Docker image, which is a self-contained package of an application and its dependencies.""\n  }\n]']","This chapter discusses ConfigMaps and Secrets in Kubernetes, specifically how to make an interval configurable in a Docker image using the exec form of the ENTRYPOINT instruction and setting a default value with the CMD instruction. A script is modified to accept an INTERVAL variable from the command line, and the Dockerfile is updated to use this new script and set the default interval to 10 seconds.","[{'highlight': 'The shell process is unnecessary, which is why you should always use the exec form of the ENTRYPOINT instruction.'}, {'highlight': 'You can modify your fortune script and image so the delay interval in the loop is configurable by adding an INTERVAL variable and initializing it with the value of the first command-line argument.'}, {'highlight': 'The Dockerfile uses the exec version of the ENTRYPOINT instruction and sets the default interval to 10 seconds using the CMD instruction.'}, {'highlight': 'You can build and push the image to Docker Hub by running $ docker build -t docker.io/luksa/fortune:args . and $ docker push docker.io/luksa/fortune:args'}, {'highlight': 'The exec form of the ENTRYPOINT instruction is used to start a new process from the shell, eliminating the need for an unnecessary shell process.'}]"
138,227,0,[],"195
Passing command-line arguments to containers
NOTE
You can stop the script with Control+C.
And you can override the default sleep interval by passing it as an argument:
$ docker run -it docker.io/luksa/fortune:args 15
Configured to generate new fortune every 15 seconds
Now that you’re sure your image honors the argument passed to it, let’s see how to use
it in a pod.
7.2.2
Overriding the command and arguments in Kubernetes
In Kubernetes, when specifying a container, you can choose to override both ENTRY-
POINT and CMD. To do that, you set the properties command and args in the container
specification, as shown in the following listing.
kind: Pod
spec:
  containers:
  - image: some/image
    command: [""/bin/command""]
    args: [""arg1"", ""arg2"", ""arg3""]
In most cases, you’ll only set custom arguments and rarely override the command
(except in general-purpose images such as busybox, which doesn’t define an ENTRY-
POINT at all). 
NOTE
The command and args fields can’t be updated after the pod is created.
The two Dockerfile instructions and the equivalent pod spec fields are shown in table 7.1.
RUNNING THE FORTUNE POD WITH A CUSTOM INTERVAL
To run the fortune pod with a custom delay interval, you’ll copy your fortune-
pod.yaml into fortune-pod-args.yaml and modify it as shown in the following listing.
apiVersion: v1
kind: Pod
metadata:
  name: fortune2s        
Listing 7.3
A pod definition specifying a custom command and arguments
Table 7.1
Specifying the executable and its arguments in Docker vs Kubernetes
Docker
Kubernetes
Description
ENTRYPOINT
command
The executable that’s executed inside the container
CMD
args
The arguments passed to the executable
Listing 7.4
Passing an argument in the pod definition: fortune-pod-args.yaml
You changed the 
pod’s name.
 
","[            Docker     Kubernetes  \
0  ENTRYPOINT\nCMD  command\nargs   

                                         Description  
0  The executable that’s executed inside the cont...  ]","[{'entity': 'docker run', 'description': 'Command to run a Docker container', 'category': 'command'}, {'entity': 'Control+C', 'description': 'Keyboard shortcut to stop the script', 'category': 'process'}, {'entity': 'docker.io/luksa/fortune:args', 'description': 'Docker image with custom argument handling', 'category': 'image'}, {'entity': 'CMD', 'description': 'Docker instruction to set the default command', 'category': 'instruction'}, {'entity': 'ENTRYPOINT', 'description': 'Docker instruction to set the executable', 'category': 'instruction'}, {'entity': 'command', 'description': 'Kubernetes field to override the ENTRYPOINT', 'category': 'field'}, {'entity': 'args', 'description': 'Kubernetes field to pass custom arguments', 'category': 'field'}, {'entity': 'Pod', 'description': 'Kubernetes resource to run a container', 'category': 'resource'}, {'entity': '/bin/command', 'description': 'Custom command to override the ENTRYPOINT', 'category': 'command'}, {'entity': 'arg1, arg2, arg3', 'description': 'Custom arguments to pass to the container', 'category': 'arguments'}, {'entity': 'fortune-pod.yaml', 'description': 'Kubernetes pod definition file', 'category': 'file'}, {'entity': 'fortune-pod-args.yaml', 'description': 'Modified Kubernetes pod definition file with custom arguments', 'category': 'file'}, {'entity': 'apiVersion', 'description': 'Kubernetes field to specify the API version', 'category': 'field'}, {'entity': 'kind', 'description': 'Kubernetes field to specify the resource type', 'category': 'field'}, {'entity': 'metadata', 'description': 'Kubernetes field to specify metadata for the pod', 'category': 'field'}, {'entity': 'name', 'description': 'Field to specify the name of the pod', 'category': 'field'}]","[{'source_entity': '""docker.io/luksa/fortune:args""', 'description': 'is used as an image', 'destination_entity': '""Pod""'}, {'source_entity': '""/bin/command""', 'description': 'executes the command', 'destination_entity': '""Pod""'}, {'source_entity': '""fortune-pod.yaml""', 'description': 'defines the configuration for the Pod', 'destination_entity': '""Pod""'}, {'source_entity': '""metadata""', 'description': 'contains metadata information', 'destination_entity': '""Pod""'}, {'source_entity': '""name""', 'description': 'specifies the name of the Pod', 'destination_entity': '""Pod""'}, {'source_entity': '""CMD""', 'description': 'defines the command to be executed', 'destination_entity': '""Pod""'}, {'source_entity': '""command""', 'description': 'specifies the command to be executed', 'destination_entity': '""Pod""'}, {'source_entity': '""arg1, arg2, arg3""', 'description': 'are arguments passed to the command', 'destination_entity': '""Pod""'}, {'source_entity': '""ENTRYPOINT""', 'description': 'defines the entry point of the container', 'destination_entity': '""docker.io/luksa/fortune:args""'}, {'source_entity': '""Control+C""', 'description': 'terminates the execution of the command', 'destination_entity': '""Pod""'}, {'source_entity': '""fortune-pod-args.yaml""', 'description': 'defines additional arguments for the Pod', 'destination_entity': '""Pod""'}, {'source_entity': '""docker run""', 'description': 'runs a Docker container', 'destination_entity': '""docker.io/luksa/fortune:args""'}, {'source_entity': '""args""', 'description': 'are arguments passed to the Docker command', 'destination_entity': '""docker.io/luksa/fortune:args""'}, {'source_entity': '""kind""', 'description': 'specifies the type of resource being created', 'destination_entity': '""Pod""'}]","['[\n  {\n    ""source"": ""docker.io/luksa/fortune:args"",\n    ""destination"": ""Pod"",\n    ""relation_description"": ""is used as an image"",\n    ""summary_er"": ""The Docker image \'docker.io/luksa/fortune:args\' is utilized to create a Pod, which is a containerized entity in Kubernetes.""\n  }\n]', '[\n  {\n    ""source"": ""/bin/command"",\n    ""destination"": ""Pod"",\n    ""relation_description"": ""executes the command"",\n    ""summary_er"": ""/bin/command executes a command within the Pod, utilizing its resources to run the specified task.""\n  }\n]', '[{""source"":""fortune-pod.yaml"",""destination"":""Pod"",""relation_description"":""defines the configuration for the Pod"",""summary_er"":""The YAML file fortune-pod.yaml configures a Kubernetes Pod, specifying its settings and requirements.""}]', '[\n  {\n    ""source"": ""metadata"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""contains metadata information"",\n    ""summary_er"": ""The Pod resource in Kubernetes contains metadata information, such as labels and annotations.""\n  }\n]', '[\n  {\n    ""source"": ""Kubernetes"",\n    ""destination"": ""Pod"",\n    ""relation_description"": ""specifies the name of the Pod"",\n    ""summary_er"": ""In Kubernetes, a Pod\'s name is specified to uniquely identify it within a cluster.""\n  }\n]', '[\n  {\n    ""source"": ""CMD"",\n    ""destination"": ""Pod"",\n    ""relation_description"": ""defines the command to be executed"",\n    ""summary_er"": ""The CMD relation specifies a command to run within a Pod, defining its execution behavior.""\n  }\n]', '[\n  {\n    ""source"": ""Command"",\n    ""destination"": ""Pod"",\n    ""relation_description"": ""specifies the command to be executed"",\n    ""summary_er"": ""The command specifies the instructions for a Pod to execute, allowing it to perform specific tasks or run applications.""\n  }\n]', '[\n  {\n    ""source"": ""arg1"",\n    ""destination"": ""Pod"",\n    ""relation_description"": ""are arguments passed to the command"",\n    ""summary_er"": ""Arguments are input parameters for a Pod, influencing its execution.""\n  },\n  {\n    ""source"": ""arg2"",\n    ""destination"": ""Pod"",\n    ""relation_description"": ""are arguments passed to the command"",\n    ""summary_er"": ""Additional input parameters for a Pod, modifying its behavior.""\n  },\n  {\n    ""source"": ""arg3"",\n    ""destination"": ""Pod"",\n    ""relation_description"": ""are arguments passed to the command"",\n    ""summary_er"": ""Further input parameters for a Pod, affecting its operation.""\n  }\n]', '[\n  {\n    ""source"": ""ENTRYPOINT"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""defines the entry point of the container"",\n    ""summary_er"": ""The ENTRYPOINT command in Docker defines the default command to run when a container is started, which can be used to configure the pod\'s behavior.""\n  },\n  {\n    ""source"": ""docker.io/luksa/fortune:args"",\n    ""destination"": ""ENTRYPOINT"",\n    ""relation_description"": ""image name and tag"",\n    ""summary_er"": ""The docker.io/luksa/fortune:args image is a specific version of the fortune container, which can be used to configure the ENTRYPOINT command.""\n  }\n]', '[\n  {\n    ""source"": ""Control+C"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""terminates the execution of the command"",\n    ""summary_er"": ""When Control+C is pressed, it terminates the execution of a command running in a pod.""\n  }\n]', '[\n  {\n    ""source"": ""fortune-pod-args.yaml"",\n    ""destination"": ""Pod"",\n    ""relation_description"": ""defines additional arguments for the Pod"",\n    ""summary_er"": ""This YAML file provides extra configuration options for a Kubernetes Pod, allowing customization of its behavior and resources.""\n  }\n]', '[\n  {\n    ""source"": ""docker run"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""runs a Docker container"",\n    ""summary_er"": ""Running a Docker container using \'docker run\' command to create a pod.""\n  }\n]', '[\n  {\n    ""source"": ""Docker"",\n    ""destination"": ""Pod"",\n    ""relation_description"": ""are arguments passed to the Docker command"",\n    ""summary_er"": ""In Kubernetes, Docker arguments are used to pass commands to a pod.""\n  }\n]', '[\n  {\n    ""source"": ""Kind"",\n    ""destination"": ""Pod"",\n    ""relation_description"": ""specifies the type of resource being created"",\n    ""summary_er"": ""The Kind field specifies the type of Kubernetes resource, such as a Pod, Service, or Deployment.""\n  }\n]']","Kubernetes allows overriding command and arguments in a container by setting 'command' and 'args' fields in the container specification. This can be done when creating a pod, but not updated after it's created. The equivalent Dockerfile instructions are ENTRYPOINT and CMD.","[{'highlight': 'You can stop the script with Control+C.'}, {'highlight': ""To run the fortune pod with a custom delay interval, you'll copy your fortune-pod.yaml into fortune-pod-args.yaml and modify it as shown in the following listing.""}, {'highlight': ""The command and args fields can't be updated after the pod is created.""}, {'highlight': 'You can override the default sleep interval by passing it as an argument:'}, {'highlight': ""In most cases, you'll only set custom arguments and rarely override the command""}]"
139,228,0,[],"196
CHAPTER 7
ConfigMaps and Secrets: configuring applications
spec:
  containers:
  - image: luksa/fortune:args      
    args: [""2""]                  
    name: html-generator
    volumeMounts:
    - name: html
      mountPath: /var/htdocs
...
You added the args array to the container definition. Try creating this pod now. The
values of the array will be passed to the container as command-line arguments when it
is run. 
 The array notation used in this listing is great if you have one argument or a few. If
you have several, you can also use the following notation:
    args:
    - foo
    - bar
    - ""15""
TIP
You don’t need to enclose string values in quotations marks (but you
must enclose numbers). 
Specifying arguments is one way of passing config
options to your containers through command-
line arguments. Next, you’ll see how to do it
through environment variables.
7.3
Setting environment variables for 
a container
As I’ve already mentioned, containerized appli-
cations often use environment variables as a
source of configuration options. Kubernetes
allows you to specify a custom list of environ-
ment variables for each container of a pod, as
shown in figure 7.1. Although it would be use-
ful to also define environment variables at the
pod level and have them be inherited by its
containers, no such option currently exists.
NOTE
Like the container’s command and
arguments, the list of environment variables
also cannot be updated after the pod is created.
Using fortune:args 
instead of fortune:latest
This argument makes the 
script generate a new fortune 
every two seconds.
Pod
Container A
Environment variables
FOO=BAR
ABC=123
Container B
Environment variables
FOO=FOOBAR
BAR=567
Figure 7.1
Environment variables can 
be set per container.
 
",[],"[{'entity': 'args', 'description': 'an array of command-line arguments passed to the container', 'category': 'container'}, {'entity': 'image', 'description': 'the Docker image used by the container', 'category': 'container'}, {'entity': 'fortune:args', 'description': 'a specific Docker image that generates a new fortune every two seconds', 'category': 'container'}, {'entity': 'fortune:latest', 'description': 'a specific Docker image, but not specified what it does', 'category': 'container'}, {'entity': 'pod', 'description': 'the basic execution unit in Kubernetes', 'category': 'application'}, {'entity': 'container', 'description': 'a lightweight and standalone executable package of software', 'category': 'container'}, {'entity': 'environment variables', 'description': 'configuration options for a container, set as key-value pairs', 'category': 'container'}, {'entity': 'FOO=BAR', 'description': 'an environment variable with key FOO and value BAR', 'category': 'environment variable'}, {'entity': 'ABC=123', 'description': 'an environment variable with key ABC and value 123', 'category': 'environment variable'}, {'entity': 'Container A', 'description': 'the first container in the pod, with its own set of environment variables', 'category': 'container'}, {'entity': 'Container B', 'description': 'the second container in the pod, with its own set of environment variables', 'category': 'container'}]","[{'source_entity': '""container""', 'description': 'runs', 'destination_entity': '""image""'}, {'source_entity': '""container""', 'description': 'uses', 'destination_entity': '""environment variables""'}, {'source_entity': '""Container A""', 'description': 'pulls', 'destination_entity': '""fortune:latest""'}, {'source_entity': '""Container B""', 'description': 'pulls', 'destination_entity': '""fortune:args""'}, {'source_entity': '""container""', 'description': 'executes', 'destination_entity': '""args""'}, {'source_entity': '""pod""', 'description': 'manages', 'destination_entity': '""Container A""'}, {'source_entity': '""pod""', 'description': 'manages', 'destination_entity': '""Container B""'}, {'source_entity': '""container""', 'description': 'sets', 'destination_entity': '""FOO=BAR""'}, {'source_entity': '""container""', 'description': 'sets', 'destination_entity': '""ABC=123""'}]","['[\n  {\n    ""source"": ""container"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""runs"",\n    ""summary_er"": ""A container runs within a pod, providing isolation and resource sharing.""\n  },\n  {\n    ""source"": ""image"",\n    ""destination"": ""container"",\n    ""relation_description"": """",\n    ""summary_er"": ""An image is used to create a container, providing the base operating system and application code.""\n  }\n]', '[\n  {\n    ""source"": ""container"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""uses"",\n    ""summary_er"": ""A container runs within a pod, utilizing its resources and sharing its network space.""\n  },\n  {\n    ""source"": ""environment variables"",\n    ""destination"": ""container"",\n    ""relation_description"": """",\n    ""summary_er"": ""Environment variables are used to configure and customize containers by passing them as arguments or setting them within the container\'s configuration files.""\n  }\n]', '[\n  {\n    ""source"": ""Container A"",\n    ""destination"": ""pod fortune:latest"",\n    ""relation_description"": ""pulls"",\n    ""summary_er"": ""Container A pulls the latest image of fortune from a registry.""\n  }\n]', '[\n  {\n    ""source"": ""Container B"",\n    ""destination"": ""Pod fortune:args"",\n    ""relation_description"": ""pulls"",\n    ""summary_er"": ""Container B pulls dependencies from Pod fortune:args, ensuring consistent application state.""\n  }\n]', '[\n  {\n    ""source"": ""container"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""executes"",\n    ""summary_er"": ""A container executes within a pod, utilizing shared resources and networking.""\n  },\n  {\n    ""source"": ""args"",\n    ""destination"": ""container"",\n    ""relation_description"": ""for"",\n    ""summary_er"": ""Arguments are provided for a container to execute specific commands or functions.""\n  }\n]', '[\n  {\n    ""source"": ""pod"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""manages"",\n    ""summary_er"": ""A pod in Kubernetes manages one or more containers, providing a logical host for them to run on.""\n  },\n  {\n    ""source"": ""Container A"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""runs on"",\n    ""summary_er"": ""Container A is a container that runs within a pod in Kubernetes, utilizing the resources provided by the pod.""\n  }\n]', '[\n  {\n    ""source"": ""pod"",\n    ""destination"": ""Container B"",\n    ""relation_description"": ""manages"",\n    ""summary_er"": ""A Kubernetes pod manages a container, ensuring its execution and resource allocation.""\n  }\n]', '[\n  {\n    ""source"": ""container"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""sets"",\n    ""summary_er"": ""A container is set within a pod, providing isolation and resource management for the application.""\n  },\n  {\n    ""source"": ""FOO=BAR"",\n    ""destination"": ""environment variable"",\n    ""relation_description"": ""assignment"",\n    ""summary_er"": ""The FOO=BAR assignment sets an environment variable with key \'FOO\' and value \'BAR\'.""\n  }\n]', '[{\n  ""source"": ""Container"",\n  ""destination"": ""Pod"",\n  ""relation_description"": ""Sets"",\n  ""summary_er"": ""A container is used to set up a pod, which is a group of one or more containers running as a single application.""\n}]']","The chapter discusses ConfigMaps and Secrets for configuring applications in Kubernetes. It explains how to pass configuration options through command-line arguments using the args array, and also through environment variables. The example uses the fortune:args image to generate a new fortune every two seconds.","[{'highlight': 'You added the args array to the container definition. Try creating this pod now.'}, {'highlight': 'The values of the array will be passed to the container as command-line arguments when it is run.'}, {'highlight': 'Specifying arguments is one way of passing config options to your containers through command-line arguments.'}, {'highlight': 'Kubernetes allows you to specify a custom list of environment variables for each container of a pod.'}, {'highlight': 'Using fortune:args instead of fortune:latest This argument makes the script generate a new fortune every two seconds.'}]"
