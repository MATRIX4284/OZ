,page,img_cnt,img_npy_lst,text,tables,entities,relationships,summary_rel,summary,highlights
90,179,0,[],"147
Exposing services externally through an Ingress resource
MAPPING DIFFERENT SERVICES TO DIFFERENT HOSTS
Similarly, you can use an Ingress to map to different services based on the host in the
HTTP request instead of (only) the path, as shown in the next listing.
spec:
  rules:
  - host: foo.example.com          
    http:
      paths:
      - path: / 
        backend:
          serviceName: foo         
          servicePort: 80
  - host: bar.example.com          
    http:
      paths:
      - path: /
        backend:
          serviceName: bar         
          servicePort: 80
Requests received by the controller will be forwarded to either service foo or bar,
depending on the Host header in the request (the way virtual hosts are handled in
web servers). DNS needs to point both the foo.example.com and the bar.exam-
ple.com domain names to the Ingress controller’s IP address. 
5.4.4
Configuring Ingress to handle TLS traffic
You’ve seen how an Ingress forwards HTTP traffic. But what about HTTPS? Let’s take
a quick look at how to configure Ingress to support TLS. 
CREATING A TLS CERTIFICATE FOR THE INGRESS
When a client opens a TLS connection to an Ingress controller, the controller termi-
nates the TLS connection. The communication between the client and the controller
is encrypted, whereas the communication between the controller and the backend
pod isn’t. The application running in the pod doesn’t need to support TLS. For exam-
ple, if the pod runs a web server, it can accept only HTTP traffic and let the Ingress
controller take care of everything related to TLS. To enable the controller to do that,
you need to attach a certificate and a private key to the Ingress. The two need to be
stored in a Kubernetes resource called a Secret, which is then referenced in the
Ingress manifest. We’ll explain Secrets in detail in chapter 7. For now, you’ll create the
Secret without paying too much attention to it.
 First, you need to create the private key and certificate:
$ openssl genrsa -out tls.key 2048
$ openssl req -new -x509 -key tls.key -out tls.cert -days 360 -subj 
➥ /CN=kubia.example.com
Listing 5.15
Ingress exposing multiple services on different hosts
Requests for 
foo.example.com will be 
routed to service foo.
Requests for 
bar.example.com will be 
routed to service bar.
 
",[],"[{'entity': 'Ingress', 'description': 'A Kubernetes resource that allows you to expose services externally through a single IP address and host name.', 'category': 'software'}, {'entity': 'host', 'description': 'The domain name or IP address used to access the service.', 'category': 'network'}, {'entity': 'path', 'description': 'The URL path that determines which backend service to use.', 'category': 'application'}, {'entity': 'backend', 'description': 'The service that handles requests for a specific host and path.', 'category': 'software'}, {'entity': 'serviceName', 'description': 'The name of the service that handles requests for a specific host and path.', 'category': 'software'}, {'entity': 'servicePort', 'description': 'The port number used by the service to handle requests.', 'category': 'application'}, {'entity': 'TLS', 'description': 'A protocol for encrypting communication between clients and servers.', 'category': 'network'}, {'entity': 'certificate', 'description': 'A file that contains a public key used to verify the identity of a server.', 'category': 'software'}, {'entity': 'private key', 'description': 'A file that contains a secret key used to decrypt data encrypted with the corresponding public key.', 'category': 'software'}, {'entity': 'Secret', 'description': 'A Kubernetes resource that stores sensitive information, such as certificates and private keys.', 'category': 'software'}, {'entity': 'openssl', 'description': 'A command-line tool for generating and managing SSL/TLS certificates and private keys.', 'category': 'software'}, {'entity': 'genrsa', 'description': 'A command used to generate a new RSA key pair.', 'category': 'command'}, {'entity': 'req', 'description': 'A command used to create a certificate signing request (CSR).', 'category': 'command'}, {'entity': 'x509', 'description': 'A command used to create a self-signed X.509 certificate.', 'category': 'command'}]","[{'source_entity': '""openssl""', 'description': 'generates', 'destination_entity': '""req""'}, {'source_entity': '""openssl""', 'description': 'uses', 'destination_entity': '""genrsa""'}, {'source_entity': '""openssl""', 'description': 'creates', 'destination_entity': '""certificate""'}, {'source_entity': '""openssl""', 'description': 'signs', 'destination_entity': '""req""'}, {'source_entity': '""openssl""', 'description': 'generates', 'destination_entity': '""private key""'}, {'source_entity': '""kubectl""', 'description': 'creates', 'destination_entity': '""Secret""'}, {'source_entity': '""kubectl""', 'description': 'applies', 'destination_entity': '""Ingress""'}, {'source_entity': '""kubectl""', 'description': 'exposes', 'destination_entity': '""servicePort""'}, {'source_entity': '""TLS""', 'description': 'encrypts', 'destination_entity': '""backend""'}, {'source_entity': '""x509""', 'description': 'verifies', 'destination_entity': '""certificate""'}, {'source_entity': '""path""', 'description': 'specifies', 'destination_entity': '""Ingress""'}, {'source_entity': '""host""', 'description': 'defines', 'destination_entity': '""Ingress""'}]","['[\n  {\n    ""source"": ""openssl"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""generates"",\n    ""summary_er"": ""The OpenSSL library generates a cryptographic key for secure communication within a Kubernetes pod.""\n  }\n]', '[\n  {\n    ""source"": ""openssl"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""uses"",\n    ""summary_er"": ""The OpenSSL library is used by a containerized application running in a Kubernetes pod.""\n  },\n  {\n    ""source"": ""genrsa"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""uses"",\n    ""summary_er"": ""The genrsa command uses a containerized environment within a Kubernetes pod for cryptographic key generation.""\n  }\n]', '[\n  {\n    ""source"": ""openssl"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""creates"",\n    ""summary_er"": ""OpenSSL generates a certificate for a Kubernetes pod.""\n  }\n]', '[\n  {\n    ""source"": ""openssl"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""signs"",\n    ""summary_er"": ""The OpenSSL library generates digital signatures for secure communication between pods.""\n  },\n  {\n    ""source"": ""req"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""requests"",\n    ""summary_er"": ""The req module sends HTTP requests to interact with the pod\'s API.""\n  }\n]', '[\n  {\n    ""source"": ""openssl"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""generates"",\n    ""summary_er"": ""The OpenSSL command-line tool generates a private key for secure communication.""\n  }\n]', '[\n  {\n    ""source"": ""kubectl"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""creates"",\n    ""summary_er"": ""Kubernetes command-line tool (kubectl) creates a new pod, which is a container running an application.""\n  },\n  {\n    ""source"": ""kubectl"",\n    ""destination"": ""Secret"",\n    ""relation_description"": ""manages"",\n    ""summary_er"": ""Kubernetes command-line tool (kubectl) manages secrets, which are sensitive data stored in Kubernetes.""\n  }\n]', '[\n  {\n    ""source"": ""kubectl"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""applies"",\n    ""summary_er"": ""Kubectl command applies configuration to a running pod, ensuring it meets the specified requirements.""\n  },\n  {\n    ""source"": ""Ingress"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""routes traffic"",\n    ""summary_er"": ""Ingress resource routes incoming HTTP requests to a specific pod, enabling load balancing and traffic management.""\n  }\n]', '[\n  {\n    ""source"": ""kubectl"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""exposes"",\n    ""summary_er"": ""Kubectl command exposes a pod\'s port to be accessed from outside the cluster.""\n  },\n  {\n    ""source"": ""servicePort"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""exposes"",\n    ""summary_er"": ""ServicePort exposes a pod\'s port to be accessed from outside the cluster, allowing external traffic to reach the service.""\n  }\n]', '[\n  {\n    ""source"": ""TLS"",\n    ""destination"": ""backend"",\n    ""relation_description"": ""encrypts"",\n    ""summary_er"": ""TLS encrypts data transmitted to the backend pod for secure communication.""\n  }\n]', '[\n  {\n    ""source"": ""x509"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""verifies"",\n    ""summary_er"": ""The x509 certificate verifies the identity of a pod in Kubernetes, ensuring secure communication between containers.""\n  }\n]', '[\n  {\n    ""source"": ""path"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""specifies"",\n    ""summary_er"": ""The path specifies a destination pod in Kubernetes.""\n  },\n  {\n    ""source"": ""Ingress"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""related to"",\n    ""summary_er"": ""An Ingress is related to a pod, providing access to it in Kubernetes.""\n  }\n]', '[\n  {\n    ""source"": ""host"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""defines"",\n    ""summary_er"": ""A host machine defines a pod, which is a containerized application in Kubernetes.""\n  },\n  {\n    ""source"": ""pod"",\n    ""destination"": ""Ingress"",\n    ""relation_description"": """",\n    ""summary_er"": ""A pod can be exposed to external traffic through an Ingress resource, providing access to the application.""\n  }\n]']","An Ingress resource can map different services to different hosts based on the Host header in the request, and can also handle TLS traffic by attaching a certificate and private key to the Ingress as a Secret. This allows for secure communication between clients and the controller without requiring the application pod to support TLS.","[{'highlight': 'You can use an Ingress to map to different services based on the host in the HTTP request instead of (only) the path.'}, {'highlight': 'Requests received by the controller will be forwarded to either service foo or bar, depending on the Host header in the request.'}, {'highlight': 'DNS needs to point both the foo.example.com and the bar.example.com domain names to the Ingress controller’s IP address.'}, {'highlight': 'The communication between the client and the controller is encrypted, whereas the communication between the controller and the backend pod isn’t.'}, {'highlight': 'You need to attach a certificate and a private key to the Ingress to enable the controller to handle TLS traffic.'}]"
91,180,0,[],"148
CHAPTER 5
Services: enabling clients to discover and talk to pods
Then you create the Secret from the two files like this:
$ kubectl create secret tls tls-secret --cert=tls.cert --key=tls.key
secret ""tls-secret"" created
The private key and the certificate are now stored in the Secret called tls-secret.
Now, you can update your Ingress object so it will also accept HTTPS requests for
kubia.example.com. The Ingress manifest should now look like the following listing.
apiVersion: extensions/v1beta1
kind: Ingress
metadata:
  name: kubia
spec:
  tls:                           
  - hosts:                        
    - kubia.example.com           
    secretName: tls-secret       
  rules:
  - host: kubia.example.com
    http:
      paths:
      - path: /
        backend:
          serviceName: kubia-nodeport
          servicePort: 80
TIP
Instead of deleting the Ingress and re-creating it from the new file, you
can invoke kubectl apply -f kubia-ingress-tls.yaml, which updates the
Ingress resource with what’s specified in the file.
Signing certificates through the CertificateSigningRequest resource
Instead of signing the certificate ourselves, you can get the certificate signed by
creating a CertificateSigningRequest (CSR) resource. Users or their applications
can create a regular certificate request, put it into a CSR, and then either a human
operator or an automated process can approve the request like this:
$ kubectl certificate approve <name of the CSR> 
The signed certificate can then be retrieved from the CSR’s status.certificate
field. 
Note that a certificate signer component must be running in the cluster; otherwise
creating CertificateSigningRequest and approving or denying them won’t have
any effect.
Listing 5.16
Ingress handling TLS traffic: kubia-ingress-tls.yaml
The whole TLS configuration 
is under this attribute.
TLS connections will be accepted for 
the kubia.example.com hostname.
The private key and the certificate 
should be obtained from the tls-
secret you created previously.
 
",[],"[{'entity': 'kubectl', 'description': 'command to create a Secret', 'category': 'software'}, {'entity': 'Secret', 'description': 'resource to store sensitive information', 'category': 'database'}, {'entity': 'tls-secret', 'description': 'name of the Secret resource', 'category': 'database'}, {'entity': 'Ingress', 'description': 'resource to manage incoming HTTP requests', 'category': 'application'}, {'entity': 'kubia-nodeport', 'description': 'name of the Service resource', 'category': 'database'}, {'entity': 'servicePort', 'description': 'attribute of the Ingress resource', 'category': 'software'}, {'entity': 'CertificateSigningRequest', 'description': 'resource to request a signed certificate', 'category': 'application'}, {'entity': 'csr', 'description': 'short form for CertificateSigningRequest', 'category': 'software'}, {'entity': 'kubia-ingress-tls.yaml', 'description': 'file containing the Ingress configuration', 'category': 'hardware'}, {'entity': 'tls', 'description': 'attribute of the Ingress resource', 'category': 'software'}, {'entity': 'hosts', 'description': 'attribute of the tls attribute', 'category': 'software'}, {'entity': 'kubia.example.com', 'description': 'hostname for which TLS connections will be accepted', 'category': 'network'}]","[{'source_entity': 'kubectl', 'description': 'uses to create a CertificateSigningRequest', 'destination_entity': 'csr'}, {'source_entity': 'kubectl', 'description': 'applies tls-secret to csr', 'destination_entity': 'tls-secret'}, {'source_entity': 'kubectl', 'description': 'exposes servicePort of kubia-nodeport', 'destination_entity': 'servicePort'}, {'source_entity': 'kubectl', 'description': 'configures Ingress for kubia.example.com', 'destination_entity': 'kubia.example.com'}, {'source_entity': 'kubectl', 'description': 'applies tls configuration from kubia-ingress-tls.yaml', 'destination_entity': 'kubia-ingress-tls.yaml'}, {'source_entity': 'kubectl', 'description': 'creates Secret for tls configuration', 'destination_entity': 'Secret'}, {'source_entity': 'kubectl', 'description': 'configures Ingress for kubia.example.com with tls', 'destination_entity': 'Ingress'}, {'source_entity': 'kubectl', 'description': 'exposes nodePort of kubia-nodeport', 'destination_entity': 'kubia-nodeport'}]","['[\n  {\n    ""source"": ""kubectl"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""uses to create a CertificateSigningRequest"",\n    ""summary_er"": ""kubectl uses CertificateSigningRequest to authenticate pods, ensuring secure communication between cluster components.""\n  }\n]', '[\n  {\n    ""source"": ""kubectl"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""applies tls-secret to csr"",\n    ""summary_er"": ""Kubectl applies a TLS secret to a Certificate Signing Request (CSR) for a pod.""\n  }\n]', '[\n  {\n    ""source"": ""kubectl"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""exposes servicePort of kubia-nodeport"",\n    ""summary_er"": ""Kubectl exposes a service port for the Kubia NodePort pod, allowing external access to the application.""\n  }\n]', '[\n  {\n    ""source"": ""kubectl"",\n    ""destination"": ""kubia.example.com"",\n    ""relation_description"": ""configures Ingress for"",\n    ""summary_er"": ""Kubectl configures ingress settings for kubia.example.com, enabling external access to the pod.""\n  }\n]', '[\n  {\n    ""source"": ""kubectl"",\n    ""destination"": ""kubia-ingress-tls.yaml"",\n    ""relation_description"": ""applies tls configuration"",\n    ""summary_er"": ""Kubectl applies TLS configuration from kubia-ingress-tls.yaml to secure ingress traffic.""\n  }\n]', '[\n  {\n    ""source"": ""kubectl"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""creates Secret for tls configuration"",\n    ""summary_er"": ""Kubectl creates a secret for TLS configuration to secure communication between pods.""\n  }\n]', '[\n  {\n    ""source"": ""kubectl"",\n    ""destination"": ""Ingress"",\n    ""relation_description"": ""configures Ingress for kubia.example.com with tls"",\n    ""summary_er"": ""Kubectl configures an Ingress resource to handle HTTPS traffic for a specific domain, in this case kubia.example.com.""\n  }\n]', '[\n  {\n    ""source"": ""kubectl"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""exposes nodePort"",\n    ""summary_er"": ""Kubectl exposes a NodePort for the Kubia pod, making it accessible from outside the cluster.""\n  }\n]']","Services allow clients to discover and communicate with pods. A Secret was created using two files, and an Ingress object was updated to accept HTTPS requests for kubia.example.com. Alternatively, 'kubectl apply' can be used to update the Ingress resource. CertificateSigningRequest resources enable certificates to be signed by a human operator or automated process, retrieving a signed certificate from the CSR's status field.","[{'highlight': 'You can create a Secret in Kubernetes using the command `kubectl create secret tls tls-secret --cert=tls.cert --key=tls.key` to store private key and certificate.'}, {'highlight': 'To enable HTTPS requests for kubia.example.com, update the Ingress object with the Secret name `tls-secret` and path `/` pointing to service `kubia-nodeport` on port 80.'}, {'highlight': 'Instead of deleting and re-creating the Ingress resource, you can use `kubectl apply -f kubia-ingress-tls.yaml` to update it with the new TLS configuration.'}, {'highlight': ""To sign a certificate through CertificateSigningRequest (CSR), create a CSR resource using `kubectl certificate approve <name of the CSR>` and then retrieve the signed certificate from the CSR's status.certificate field.""}, {'highlight': 'A certificate signer component must be running in the cluster for creating, approving, or denying CertificateSigningRequests to have any effect.'}]"
92,181,0,[],"149
Signaling when a pod is ready to accept connections
You can now use HTTPS to access your service through the Ingress:
$ curl -k -v https://kubia.example.com/kubia
* About to connect() to kubia.example.com port 443 (#0)
...
* Server certificate:
*   subject: CN=kubia.example.com
...
> GET /kubia HTTP/1.1
> ...
You've hit kubia-xueq1
The command’s output shows the response from the app, as well as the server certifi-
cate you configured the Ingress with.
NOTE
Support for Ingress features varies between the different Ingress con-
troller implementations, so check the implementation-specific documenta-
tion to see what’s supported. 
Ingresses are a relatively new Kubernetes feature, so you can expect to see many
improvements and new features in the future. Although they currently support only
L7 (HTTP/HTTPS) load balancing, support for L4 load balancing is also planned.
5.5
Signaling when a pod is ready to accept connections
There’s one more thing we need to cover regarding both Services and Ingresses.
You’ve already learned that pods are included as endpoints of a service if their labels
match the service’s pod selector. As soon as a new pod with proper labels is created, it
becomes part of the service and requests start to be redirected to the pod. But what if
the pod isn’t ready to start serving requests immediately? 
 The pod may need time to load either configuration or data, or it may need to per-
form a warm-up procedure to prevent the first user request from taking too long and
affecting the user experience. In such cases you don’t want the pod to start receiving
requests immediately, especially when the already-running instances can process
requests properly and quickly. It makes sense to not forward requests to a pod that’s in
the process of starting up until it’s fully ready.
5.5.1
Introducing readiness probes
In the previous chapter you learned about liveness probes and how they help keep
your apps healthy by ensuring unhealthy containers are restarted automatically.
Similar to liveness probes, Kubernetes allows you to also define a readiness probe
for your pod.
 The readiness probe is invoked periodically and determines whether the specific
pod should receive client requests or not. When a container’s readiness probe returns
success, it’s signaling that the container is ready to accept requests. 
 This notion of being ready is obviously something that’s specific to each container.
Kubernetes can merely check if the app running in the container responds to a simple
 
",[],"[{'entity': 'pod', 'description': 'A pod is a logical host for one or more containers.', 'category': 'container'}, {'entity': 'service', 'description': 'A service provides a network identity and load balancing for accessing applications in a cluster.', 'category': 'application'}, {'entity': 'ingress', 'description': 'An ingress is an API object that manages external access to services running within a Kubernetes cluster.', 'category': 'network'}, {'entity': 'HTTPS', 'description': 'A secure version of the HTTP protocol.', 'category': 'protocol'}, {'entity': 'curl', 'description': 'A command-line tool for transferring data with URL syntax.', 'category': 'command'}, {'entity': 'liveness probes', 'description': 'A mechanism to periodically check if a container is running and responding correctly.', 'category': 'process'}, {'entity': 'readiness probes', 'description': 'A mechanism to periodically check if a pod is ready to accept client requests.', 'category': 'process'}, {'entity': 'container', 'description': 'A lightweight and standalone executable package of software, such as an application or service.', 'category': 'container'}, {'entity': 'labels', 'description': 'Key-value pairs that can be attached to pods, services, and other Kubernetes objects.', 'category': 'metadata'}, {'entity': 'selector', 'description': 'A label selector used to identify matching pods for a service or other object.', 'category': 'metadata'}, {'entity': 'requests', 'description': 'Client requests sent to a pod or service.', 'category': 'network'}, {'entity': 'load balancing', 'description': 'A technique to distribute incoming network traffic across multiple servers or containers.', 'category': 'network'}]","[{'source_entity': '""requests""', 'description': 'sent to', 'destination_entity': '""container""'}, {'source_entity': '""labels""', 'description': 'applied to', 'destination_entity': '""pod""'}, {'source_entity': '""selector""', 'description': 'used for', 'destination_entity': '""pod""'}, {'source_entity': '""readiness probes""', 'description': 'performed on', 'destination_entity': '""container""'}, {'source_entity': '""ingress""', 'description': 'configured for', 'destination_entity': '""load balancing""'}, {'source_entity': '""HTTPS""', 'description': 'used by', 'destination_entity': '""ingress""'}, {'source_entity': '""curl""', 'description': 'used to test', 'destination_entity': '""service""'}, {'source_entity': '""liveness probes""', 'description': 'performed on', 'destination_entity': '""container""'}, {'source_entity': '""requests""', 'description': 'routed through', 'destination_entity': '""ingress""'}]","['[\n  {\n    ""source"": ""requests"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""sent to"",\n    ""summary_er"": ""In Kubernetes, a request is sent from an application to a pod, which contains one or more containers.""\n  },\n  {\n    ""source"": ""container"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""contains"",\n    ""summary_er"": ""A container in Docker is contained within a pod in Kubernetes, providing isolation and resource management.""\n  }\n]', '[\n  {\n    ""source"": ""labels"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""applied to"",\n    ""summary_er"": ""Labels are key-value pairs that can be applied to a pod, providing metadata and configuration information.""\n  }\n]', '[\n  {\n    ""source"": ""selector"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""used for"",\n    ""summary_er"": ""A selector is used to select a pod based on its labels, allowing for efficient resource management and scaling.""\n  }\n]', '[\n  {\n    ""source"": ""Readiness Probes"",\n    ""destination"": ""Pod"",\n    ""relation_description"": ""performed on"",\n    ""summary_er"": ""Readiness probes are executed on a pod to determine its readiness for incoming traffic.""\n  },\n  {\n    ""source"": ""Container"",\n    ""destination"": ""Pod"",\n    ""relation_description"": ""within"",\n    ""summary_er"": ""A container is deployed within a pod, providing isolation and resource management.""\n  }\n]', '[\n  {\n    ""source"": ""Ingress"",\n    ""destination"": ""Pod"",\n    ""relation_description"": ""configured for"",\n    ""summary_er"": ""The Ingress resource configures load balancing for a Pod, enabling incoming traffic to be distributed among multiple replicas.""\n  },\n  {\n    ""source"": ""Load Balancing"",\n    ""destination"": ""Pod"",\n    ""relation_description"": ""enabled by"",\n    ""summary_er"": ""Load balancing is enabled by the Ingress resource, allowing multiple Pods to receive incoming traffic and improving application scalability.""\n  }\n]', '[\n  {\n    ""source"": ""HTTPS"",\n    ""destination"": ""Ingress"",\n    ""relation_description"": ""Used By"",\n    ""summary_er"": ""\\""HTTPS is used by Ingress to handle incoming HTTP requests.\\""""\n  },\n  {\n    ""source"": ""Ingress"",\n    ""destination"": ""Pod"",\n    ""relation_description"": ""ingress"",\n    ""summary_er"": ""\\""Ingress is a pod that handles incoming HTTP requests and directs them to the correct service.\\""""\n  },\n  {\n    ""source"": ""Pod"",\n    ""destination"": ""HTTPS"",\n    ""relation_description"": ""used by"",\n    ""summary_er"": ""\\""A pod uses HTTPS to communicate with other pods or services over a secure connection.\\""""\n  }\n]', '[\n  {\n    ""source"": ""curl"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""used to test"",\n    ""summary_er"": ""Curl command used to interact with a pod in Kubernetes, verifying its functionality and performance.""\n  },\n  {\n    ""source"": ""curl"",\n    ""destination"": ""service"",\n    ""relation_description"": ""used to test"",\n    ""summary_er"": ""Curl command used to interact with a service in Kubernetes, verifying its availability and responsiveness.""\n  }\n]', '[\n  {\n    ""source"": ""Liveness Probes"",\n    ""destination"": ""Pod"",\n    ""relation_description"": ""performed on"",\n    ""summary_er"": ""Liveness probes are executed within a pod to ensure its health and responsiveness.""\n  },\n  {\n    ""source"": ""Container"",\n    ""destination"": ""Pod"",\n    ""relation_description"": ""within"",\n    ""summary_er"": ""A container is housed within a pod, providing a runtime environment for the application.""\n  }\n]', '[\n  {\n    ""source"": ""requests"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""routed through"",\n    ""summary_er"": ""Incoming HTTP requests are routed through a pod for processing and handling.""\n  },\n  {\n    ""source"": ""ingress"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""ingress"",\n    ""summary_er"": ""Ingress traffic is directed to a specific pod for routing and load balancing purposes.""\n  }\n]']","Kubernetes allows you to define a readiness probe for your pod, which periodically determines whether the pod should receive client requests or not. When a container's readiness probe returns success, it signals that the container is ready to accept requests, allowing traffic to be directed to it only when it's fully ready to serve.","[{'highlight': 'You can now use HTTPS to access your service through the Ingress: $ curl -k -v https://kubia.example.com/kubia'}, {'highlight': 'The readiness probe is invoked periodically and determines whether the specific pod should receive client requests or not.'}, {'highlight': 'When a container’s readiness probe returns success, it’s signaling that the container is ready to accept requests.'}, {'highlight': 'Kubernetes allows you to also define a readiness probe for your pod, similar to liveness probes.'}, {'highlight': 'Support for Ingress features varies between the different Ingress controller implementations, so check the implementation-specific documentation to see what’s supported.'}]"
93,182,0,[],"150
CHAPTER 5
Services: enabling clients to discover and talk to pods
GET / request or it can hit a specific URL path, which causes the app to perform a
whole list of checks to determine if it’s ready. Such a detailed readiness probe, which
takes the app’s specifics into account, is the app developer’s responsibility. 
TYPES OF READINESS PROBES
Like liveness probes, three types of readiness probes exist:
An Exec probe, where a process is executed. The container’s status is deter-
mined by the process’ exit status code.
An HTTP GET probe, which sends an HTTP GET request to the container and
the HTTP status code of the response determines whether the container is
ready or not.
A TCP Socket probe, which opens a TCP connection to a specified port of the
container. If the connection is established, the container is considered ready.
UNDERSTANDING THE OPERATION OF READINESS PROBES
When a container is started, Kubernetes can be configured to wait for a configurable
amount of time to pass before performing the first readiness check. After that, it
invokes the probe periodically and acts based on the result of the readiness probe. If a
pod reports that it’s not ready, it’s removed from the service. If the pod then becomes
ready again, it’s re-added. 
 Unlike liveness probes, if a container fails the readiness check, it won’t be killed or
restarted. This is an important distinction between liveness and readiness probes.
Liveness probes keep pods healthy by killing off unhealthy containers and replacing
them with new, healthy ones, whereas readiness probes make sure that only pods that
are ready to serve requests receive them. This is mostly necessary during container
start up, but it’s also useful after the container has been running for a while. 
 As you can see in figure 5.11, if a pod’s readiness probe fails, the pod is removed
from the Endpoints object. Clients connecting to the service will not be redirected to
the pod. The effect is the same as when the pod doesn’t match the service’s label
selector at all.
Endpoints
Service
Selector: app=kubia
app: kubia
Pod: kubia-q3vkg
app: kubia
Pod: kubia-k0xz6
app: kubia
Pod: kubia-53thy
Not ready
This pod is no longer
an endpoint, because its
readiness probe has failed.
Figure 5.11
A pod whose readiness probe fails is removed as an endpoint of a service.
 
","[Empty DataFrame
Columns: [This pod is no longer
an endpoint, because its
Service readiness probe has failed.
Endpoints
Selector: app=kubia
app: kubia app: kubia app: kubia
Pod: kubia-q3vkg Pod: kubia-k0xz6 Pod: kubia-53thy
Not ready, Col1]
Index: []]","[{'entity': 'GET / request', 'description': 'HTTP request method', 'category': 'network,application'}, {'entity': 'Exec probe', 'description': 'Type of readiness probe that executes a process', 'category': 'process,container'}, {'entity': 'HTTP GET probe', 'description': 'Type of readiness probe that sends an HTTP GET request', 'category': 'process,container'}, {'entity': 'TCP Socket probe', 'description': 'Type of readiness probe that opens a TCP connection', 'category': 'process,container'}, {'entity': 'Kubernetes', 'description': 'Container orchestration system', 'category': 'software,application'}, {'entity': 'Pods', 'description': 'Independent execution environment for containers', 'category': 'container,application'}, {'entity': 'Services', 'description': 'Abstraction layer that enables clients to discover and talk to pods', 'category': 'application,container'}, {'entity': 'Readiness probes', 'description': 'Mechanism to determine if a pod is ready to serve requests', 'category': 'process,container,application'}, {'entity': 'Liveness probes', 'description': 'Mechanism to determine if a container is healthy and running', 'category': 'process,container,application'}, {'entity': 'Endpoints', 'description': 'Object that stores the IP addresses of pods that are ready to serve requests', 'category': 'database,application'}, {'entity': 'TCP connection', 'description': 'Network communication protocol', 'category': 'network,application'}]","[{'source_entity': '""Services""', 'description': 'provide', 'destination_entity': '""Endpoints""'}, {'source_entity': '""Exec probe""', 'description': 'check', 'destination_entity': '""Liveness probes""'}, {'source_entity': '""GET / request""', 'description': 'send', 'destination_entity': '""Pods""'}, {'source_entity': '""Kubernetes""', 'description': 'manage', 'destination_entity': '""Services""'}, {'source_entity': '""HTTP GET probe""', 'description': 'perform', 'destination_entity': '""TCP connection""'}, {'source_entity': '""Readiness probes""', 'description': 'verify', 'destination_entity': '""Pods""'}, {'source_entity': '""TCP Socket probe""', 'description': 'establish', 'destination_entity': '""TCP connection""'}]","['[\n  {\n    ""source"": ""Services"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""provide"",\n    ""summary_er"": ""Services provide a way to expose an application running in a pod, making it accessible from outside the cluster.""\n  }\n]', '[\n  {\n    ""source"": ""Exec probe"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""check"",\n    ""summary_er"": ""Kubernetes uses Exec probe to check the liveness of a pod by executing a command within the container.""\n  },\n  {\n    ""source"": ""Liveness probes"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""check"",\n    ""summary_er"": ""Liveness probes in Kubernetes are used to periodically check if a pod is alive and responding, ensuring it\'s running correctly.""\n  }\n]', '[\n  {\n    ""source"": ""GET / request"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""send"",\n    ""summary_er"": ""A GET request is sent to a pod, which is a containerized application in Kubernetes.""\n  }\n]', '[{\n  ""source"": ""Kubernetes"",\n  ""destination"": ""pod"",\n  ""relation_description"": ""manage"",\n  ""summary_er"": ""Kubernetes manages pods, ensuring efficient resource allocation and scalability.""\n}]', '[\n  {\n    ""source"": ""HTTP GET probe"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""perform"",\n    ""summary_er"": ""The HTTP GET probe performs a request to the destination pod, likely to check its health or functionality.""\n  },\n  {\n    ""source"": ""TCP connection"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""establish"",\n    ""summary_er"": ""A TCP connection is established between the client and the destination pod, enabling data transfer and communication.""\n  }\n]', '[\n  {\n    ""source"": ""Readiness Probes"",\n    ""destination"": ""Pods"",\n    ""relation_description"": ""verify"",\n    ""summary_er"": ""Readiness probes ensure a Pod is running correctly before it becomes available to the cluster, verifying its readiness for service.""\n  }\n]', '[\n  {\n    ""source"": ""TCP Socket probe"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""establish"",\n    ""summary_er"": ""The TCP Socket probe establishes a connection to a specific pod in the Kubernetes cluster.""\n  },\n  {\n    ""source"": ""TCP connection"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""establish"",\n    ""summary_er"": ""A TCP connection is established between the client and the pod, enabling communication between them.""\n  }\n]']","Services in Kubernetes enable clients to discover and talk to pods through GET requests or specific URL paths. Readiness probes check if a container is ready to serve requests, with three types: Exec, HTTP GET, and TCP Socket. If a pod fails the readiness check, it's removed from the service until it becomes ready again. This ensures only healthy containers receive requests, distinguishing from liveness probes which keep pods running.","[{'highlight': 'Kubernetes can be configured to wait for a configurable amount of time to pass before performing the first readiness check.'}, {'highlight': 'Readiness probes make sure that only pods that are ready to serve requests receive them, and failed pods are removed from the service.'}, {'highlight': 'There are three types of readiness probes: Exec probe, HTTP GET probe, and TCP Socket probe.'}, {'highlight': ""Unlike liveness probes, if a container fails the readiness check, it won't be killed or restarted.""}, {'highlight': ""A pod's readiness probe failure results in its removal from the Endpoints object, preventing clients from being redirected to the failed pod.""}]"
94,183,0,[],"151
Signaling when a pod is ready to accept connections
UNDERSTANDING WHY READINESS PROBES ARE IMPORTANT
Imagine that a group of pods (for example, pods running application servers)
depends on a service provided by another pod (a backend database, for example). If
at any point one of the frontend pods experiences connectivity problems and can’t
reach the database anymore, it may be wise for its readiness probe to signal to Kuber-
netes that the pod isn’t ready to serve any requests at that time. If other pod instances
aren’t experiencing the same type of connectivity issues, they can serve requests nor-
mally. A readiness probe makes sure clients only talk to those healthy pods and never
notice there’s anything wrong with the system.
5.5.2
Adding a readiness probe to a pod
Next you’ll add a readiness probe to your existing pods by modifying the Replication-
Controller’s pod template. 
ADDING A READINESS PROBE TO THE POD TEMPLATE
You’ll use the kubectl edit command to add the probe to the pod template in your
existing ReplicationController:
$ kubectl edit rc kubia
When the ReplicationController’s YAML opens in the text editor, find the container
specification in the pod template and add the following readiness probe definition to
the first container under spec.template.spec.containers. The YAML should look
like the following listing.
apiVersion: v1
kind: ReplicationController
...
spec:
  ...
  template:
    ...
    spec:
      containers:
      - name: kubia
        image: luksa/kubia
        readinessProbe:       
          exec:               
            command:          
            - ls              
            - /var/ready      
        ...
The readiness probe will periodically perform the command ls /var/ready inside the
container. The ls command returns exit code zero if the file exists, or a non-zero exit
code otherwise. If the file exists, the readiness probe will succeed; otherwise, it will fail. 
Listing 5.17
RC creating a pod with a readiness probe: kubia-rc-readinessprobe.yaml
A readinessProbe may 
be defined for each 
container in the pod.
 
",[],"[{'entity': 'readiness probes', 'description': 'Signaling when a pod is ready to accept connections', 'category': 'application'}, {'entity': 'Kubernetes', 'description': 'Container orchestration system', 'category': 'software'}, {'entity': 'pods', 'description': 'Group of containers running as a single entity', 'category': 'container'}, {'entity': 'service', 'description': 'Backend database or application server', 'category': 'application'}, {'entity': 'kubectl edit command', 'description': ""Command to modify the ReplicationController's pod template"", 'category': 'command'}, {'entity': 'ReplicationController', 'description': 'Pod template and configuration management system', 'category': 'software'}, {'entity': 'container specification', 'description': 'Definition of a container in the pod template', 'category': 'application'}, {'entity': 'readiness probe definition', 'description': 'Periodic command to check if a file exists inside the container', 'category': 'process'}, {'entity': 'ls command', 'description': 'Command to list files and directories inside the container', 'category': 'command'}, {'entity': 'exit code zero', 'description': 'Return value indicating success or failure of the readiness probe', 'category': 'error'}, {'entity': 'file /var/ready', 'description': 'File used by the readiness probe to determine pod readiness', 'category': 'process'}]","[{'source_entity': '""ReplicationController""', 'description': 'ensures', 'destination_entity': '""readiness probe definition""'}, {'source_entity': '""ReplicationController""', 'description': 'uses', 'destination_entity': '""ls command""'}, {'source_entity': '""ReplicationController""', 'description': 'monitors', 'destination_entity': '""pods""'}, {'source_entity': '""kubectl edit command""', 'description': 'modifies', 'destination_entity': '""readiness probe definition""'}, {'source_entity': '""Kubernetes""', 'description': 'manages', 'destination_entity': '""pods""'}, {'source_entity': '""container specification""', 'description': 'defines', 'destination_entity': '""file /var/ready""'}, {'source_entity': '""ReplicationController""', 'description': 'checks', 'destination_entity': '""exit code zero""'}, {'source_entity': '""service""', 'description': 'provides', 'destination_entity': '""readiness probes""'}]","['[\n  {\n    ""source"": ""ReplicationController"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""ensures"",\n    ""summary_er"": ""A ReplicationController ensures a specified number of replicas (pods) are running at any given time.""\n  },\n  {\n    ""source"": ""readiness probe definition"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""definition"",\n    ""summary_er"": ""A readiness probe definition specifies the conditions under which a pod is considered ready to serve traffic.""\n  }\n]', '[\n  {\n    ""source"": ""ReplicationController"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""uses"",\n    ""summary_er"": ""A ReplicationController ensures a specified number of replicas (identical copies) of a pod are running at any given time. It uses the pod to maintain the desired state.""\n  }\n]', '[\n  {\n    ""source"": ""ReplicationController"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""monitors"",\n    ""summary_er"": ""A ReplicationController ensures a specified number of replicas (identical copies) of a pod are running at any given time, continuously monitoring and adjusting the count as necessary.""\n  }\n]', '[\n  {\n    ""source"": ""kubectl"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""modifies"",\n    ""summary_er"": ""The kubectl edit command modifies a pod\'s configuration by updating its readiness probe definition.""\n  },\n  {\n    ""source"": ""readiness probe definition"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""definition"",\n    ""summary_er"": ""A readiness probe definition is used to determine the readiness of a pod, indicating whether it is ready to serve traffic or not.""\n  }\n]', '[\n  {\n    ""source"": ""Kubernetes"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""manages"",\n    ""summary_er"": ""Kubernetes manages pods, ensuring efficient resource allocation and scaling.""\n  }\n]', '[\n  {\n    ""source"": ""container specification"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""defines"",\n    ""summary_er"": ""A container specification defines a pod in Kubernetes, specifying the container\'s configuration and settings.""\n  },\n  {\n    ""source"": ""file /var/ready"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""indicates readiness"",\n    ""summary_er"": ""The file /var/ready indicates that a pod is ready to receive traffic or perform tasks in Kubernetes.""\n  }\n]', '[\n  {\n    ""source"": ""ReplicationController"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""checks"",\n    ""summary_er"": ""A ReplicationController ensures a specified number of replicas (in this case, pods) are running and healthy by periodically checking their status.""\n  },\n  {\n    ""source"": ""pod"",\n    ""destination"": ""ReplicationController"",\n    ""relation_description"": ""exit code zero"",\n    ""summary_er"": ""When a pod exits with a zero exit code, it indicates successful execution of the container(s) within it, which is monitored by the ReplicationController.""\n  }\n]', '[\n  {\n    ""source"": ""service"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""provides"",\n    ""summary_er"": ""A service in Kubernetes provides a way to access a pod, ensuring it\'s running and ready for use.""\n  },\n  {\n    ""source"": ""pod"",\n    ""destination"": ""service"",\n    ""relation_description"": ""readiness probes"",\n    ""summary_er"": ""Pods in Kubernetes can be configured with readiness probes to indicate when they\'re ready to receive traffic from a service.""\n  }\n]']","Readiness probes ensure clients only talk to healthy pods by signaling when a pod is ready to accept connections. A readiness probe can be added to a pod by modifying the ReplicationController's pod template using kubectl edit, adding the probe definition under spec.template.spec.containers. The probe periodically checks if a file exists, and if it does, the pod is considered ready.","[{'highlight': 'Readiness probes are important because they ensure clients only talk to healthy pods and never notice any issues with the system.'}, {'highlight': ""To add a readiness probe to a pod, modify the ReplicationController's pod template using kubectl edit command.""}, {'highlight': 'A readiness probe can be defined for each container in the pod and will periodically perform a command inside the container.'}, {'highlight': 'The readiness probe will succeed if the file exists, otherwise it will fail, allowing Kubernetes to signal when a pod is ready to accept connections.'}, {'highlight': 'A readiness probe can be used to signal when a pod experiences connectivity problems and cannot reach another service, ensuring only healthy pods serve requests.'}]"
95,184,0,[],"152
CHAPTER 5
Services: enabling clients to discover and talk to pods
 The reason you’re defining such a strange readiness probe is so you can toggle its
result by creating or removing the file in question. The file doesn’t exist yet, so all the
pods should now report not being ready, right? Well, not exactly. As you may remem-
ber from the previous chapter, changing a ReplicationController’s pod template has
no effect on existing pods. 
 In other words, all your existing pods still have no readiness probe defined. You
can see this by listing the pods with kubectl get pods and looking at the READY col-
umn. You need to delete the pods and have them re-created by the Replication-
Controller. The new pods will fail the readiness check and won’t be included as
endpoints of the service until you create the /var/ready file in each of them. 
OBSERVING AND MODIFYING THE PODS’ READINESS STATUS
List the pods again and inspect whether they’re ready or not:
$ kubectl get po
NAME          READY     STATUS    RESTARTS   AGE
kubia-2r1qb   0/1       Running   0          1m
kubia-3rax1   0/1       Running   0          1m
kubia-3yw4s   0/1       Running   0          1m
The READY column shows that none of the containers are ready. Now make the readi-
ness probe of one of them start returning success by creating the /var/ready file,
whose existence makes your mock readiness probe succeed:
$ kubectl exec kubia-2r1qb -- touch /var/ready
You’ve used the kubectl exec command to execute the touch command inside the
container of the kubia-2r1qb pod. The touch command creates the file if it doesn’t
yet exist. The pod’s readiness probe command should now exit with status code 0,
which means the probe is successful, and the pod should now be shown as ready. Let’s
see if it is:
$ kubectl get po kubia-2r1qb
NAME          READY     STATUS    RESTARTS   AGE
kubia-2r1qb   0/1       Running   0          2m
The pod still isn’t ready. Is there something wrong or is this the expected result? Take
a more detailed look at the pod with kubectl describe. The output should contain
the following line:
Readiness: exec [ls /var/ready] delay=0s timeout=1s period=10s #success=1
➥ #failure=3
The readiness probe is checked periodically—every 10 seconds by default. The pod
isn’t ready because the readiness probe hasn’t been invoked yet. But in 10 seconds at
the latest, the pod should become ready and its IP should be listed as the only end-
point of the service (run kubectl get endpoints kubia-loadbalancer to confirm). 
 
",[],"[{'entity': 'Services', 'description': 'enabling clients to discover and talk to pods', 'category': 'application'}, {'entity': 'ReplicationController', 'description': 'managing pod creation and deletion', 'category': 'application'}, {'entity': 'pods', 'description': 'containers running an application', 'category': 'container'}, {'entity': 'kubectl get pods', 'description': 'command to list all pods', 'category': 'command'}, {'entity': 'READY column', 'description': 'column in kubectl output showing pod readiness', 'category': 'output'}, {'entity': '/var/ready file', 'description': 'file used to toggle pod readiness', 'category': 'file'}, {'entity': 'kubectl exec', 'description': 'command to execute a command inside a container', 'category': 'command'}, {'entity': 'touch command', 'description': 'command to create a new file', 'category': 'command'}, {'entity': 'readiness probe', 'description': 'mechanism to check pod readiness', 'category': 'process'}, {'entity': 'kubectl describe', 'description': 'command to get detailed information about a pod', 'category': 'command'}, {'entity': 'endpoints', 'description': 'list of IP addresses and ports for a service', 'category': 'output'}, {'entity': 'kubia-loadbalancer', 'description': 'service name', 'category': 'application'}]","[{'source_entity': 'kubectl describe', 'description': 'provides detailed information about a Kubernetes resource', 'destination_entity': 'endpoints'}, {'source_entity': 'kubectl get pods', 'description': 'displays a list of running pods in the cluster', 'destination_entity': 'pods'}, {'source_entity': 'kubectl exec', 'description': 'executes a command inside a container', 'destination_entity': '/var/ready file'}, {'source_entity': 'touch command', 'description': 'creates or updates the timestamp of a file', 'destination_entity': '/var/ready file'}, {'source_entity': 'kubectl get pods', 'description': 'displays information about readiness probe in READY column', 'destination_entity': 'READY column'}, {'source_entity': 'readiness probe', 'description': 'checks the health of a pod and its containers', 'destination_entity': 'pods'}, {'source_entity': 'ReplicationController', 'description': 'manages the number of replicas of an application', 'destination_entity': 'kubia-loadbalancer'}, {'source_entity': 'kubectl exec', 'description': 'executes a command inside a container to update /var/ready file', 'destination_entity': '/var/ready file'}, {'source_entity': 'Services', 'description': 'provides load balancing and access to an application', 'destination_entity': 'kubia-loadbalancer'}]","['[\n  {\n    ""source"": ""kubectl"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""describe"",\n    ""summary_er"": ""Provides detailed information about a Kubernetes resource, specifically for pods.""\n  }\n]', '[\n  {\n    ""source"": ""kubectl"",\n    ""destination"": ""pods"",\n    ""relation_description"": ""displays a list of running pods in the cluster"",\n    ""summary_er"": ""Kubectl displays a list of running pods in the cluster, providing visibility into pod status and lifecycle.""\n  }\n]', '[\n  {\n    ""source"": ""kubectl"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""executes a command inside a container"",\n    ""summary_er"": ""Executes a command within a running pod\'s container, allowing for direct interaction with the container\'s file system and processes.""\n  },\n  {\n    ""source"": ""/var/ready"",\n    ""destination"": ""file"",\n    ""relation_description"": ""inside a container"",\n    ""summary_er"": ""A file located inside a container, typically used to indicate readiness or completion of a process within the container.""\n  }\n]', '[\n  {\n    ""source"": ""touch command"",\n    ""destination"": ""/var/ready file"",\n    ""relation_description"": ""creates or updates the timestamp of a file"",\n    ""summary_er"": ""The touch command updates the timestamp of /var/ready file, creating it if it doesn\'t exist.""\n  }\n]', '[\n  {\n    ""source"": ""kubectl"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""displays information about readiness probe"",\n    ""summary_er"": ""Kubectl displays pod readiness status, including readiness probe results in the READY column.""\n  },\n  {\n    ""source"": ""pod"",\n    ""destination"": ""READY column"",\n    ""relation_description"": ""readiness probe results"",\n    ""summary_er"": ""Pods display their readiness status in the READY column, showing the outcome of readiness probes.""\n  }\n]', '[\n  {\n    ""source"": ""readiness probe"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""checks the health of a pod and its containers"",\n    ""summary_er"": ""Readiness probe ensures pod\'s container is healthy by checking its status.""\n  }\n]', '[\n  {\n    ""source"": ""ReplicationController"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""manages the number of replicas of an application"",\n    ""summary_er"": ""A ReplicationController manages the number of pod replicas to ensure a desired application scale.""\n  }\n]', '[\n  {\n    ""source"": ""kubectl exec"",\n    ""destination"": ""/var/ready file"",\n    ""relation_description"": ""executes a command inside a container to update"",\n    ""summary_er"": ""Updates /var/ready file within a pod using kubectl exec.""\n  },\n  {\n    ""source"": ""/var/ready file"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""file updated by kubectl exec"",\n    ""summary_er"": ""A file named /var/ready is updated in a pod, indicating readiness.""\n  }\n]', '[\n  {\n    ""source"": ""Services"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""provides load balancing and access to an application"",\n    ""summary_er"": ""A Service provides a stable network identity and load-balancing for accessing applications in a Kubernetes cluster.""\n  }\n]']","Services: enabling clients to discover and talk to pods. ReplicationController's pod template changes have no effect on existing pods. Existing pods report not being ready until they're re-created by the Replication-Controller, which will fail the readiness check unless a /var/ready file is created in each of them.","[{'highlight': 'The readiness probe is checked periodically—every 10 seconds by default.'}, {'highlight': 'You need to delete the pods and have them re-created by the Replication-Controller for the new pods to fail the readiness check and not be included as endpoints of the service until you create the /var/ready file in each of them.'}, {'highlight': ""The pod's readiness probe command should now exit with status code 0, which means the probe is successful, and the pod should now be shown as ready.""}, {'highlight': ""The readiness probe is checked periodically—every 10 seconds by default. The pod isn't ready because the readiness probe hasn't been invoked yet.""}, {'highlight': 'But in 10 seconds at the latest, the pod should become ready and its IP should be listed as the only endpoint of the service (run kubectl get endpoints kubia-loadbalancer to confirm).'}]"
96,185,0,[],"153
Signaling when a pod is ready to accept connections
HITTING THE SERVICE WITH THE SINGLE READY POD
You can now hit the service URL a few times to see that each and every request is redi-
rected to this one pod:
$ curl http://130.211.53.173
You’ve hit kubia-2r1qb
$ curl http://130.211.53.173
You’ve hit kubia-2r1qb
...
$ curl http://130.211.53.173
You’ve hit kubia-2r1qb
Even though there are three pods running, only a single pod is reporting as being
ready and is therefore the only pod receiving requests. If you now delete the file, the
pod will be removed from the service again. 
5.5.3
Understanding what real-world readiness probes should do
This mock readiness probe is useful only for demonstrating what readiness probes do.
In the real world, the readiness probe should return success or failure depending on
whether the app can (and wants to) receive client requests or not. 
 Manually removing pods from services should be performed by either deleting the
pod or changing the pod’s labels instead of manually flipping a switch in the probe. 
TIP
If you want to add or remove a pod from a service manually, add
enabled=true as a label to your pod and to the label selector of your service.
Remove the label when you want to remove the pod from the service.
ALWAYS DEFINE A READINESS PROBE
Before we conclude this section, there are two final notes about readiness probes that
I need to emphasize. First, if you don’t add a readiness probe to your pods, they’ll
become service endpoints almost immediately. If your application takes too long to
start listening for incoming connections, client requests hitting the service will be for-
warded to the pod while it’s still starting up and not ready to accept incoming connec-
tions. Clients will therefore see “Connection refused” types of errors. 
TIP
You should always define a readiness probe, even if it’s as simple as send-
ing an HTTP request to the base URL. 
DON’T INCLUDE POD SHUTDOWN LOGIC INTO YOUR READINESS PROBES
The other thing I need to mention applies to the other end of the pod’s life (pod
shutdown) and is also related to clients experiencing connection errors. 
 When a pod is being shut down, the app running in it usually stops accepting con-
nections as soon as it receives the termination signal. Because of this, you might think
you need to make your readiness probe start failing as soon as the shutdown proce-
dure is initiated, ensuring the pod is removed from all services it’s part of. But that’s
not necessary, because Kubernetes removes the pod from all services as soon as you
delete the pod.
 
",[],"[{'entity': 'pod', 'description': 'A container running an application', 'category': 'container'}, {'entity': 'service', 'description': 'An abstraction which defines a set of pods and provides load balancing, self-healing, and scaling capabilities', 'category': 'application'}, {'entity': 'readiness probe', 'description': 'A mechanism to determine whether a pod is ready to accept connections or not', 'category': 'process'}, {'entity': 'curl', 'description': 'A command-line tool for transferring data with URL syntax', 'category': 'command'}, {'entity': 'HTTP request', 'description': 'A request sent over the HTTP protocol', 'category': 'protocol'}, {'entity': 'connection refused', 'description': 'An error that occurs when a client tries to connect to a service but receives no response', 'category': 'error'}, {'entity': 'Kubernetes', 'description': 'An open-source container orchestration system for automating the deployment, scaling, and management of containers', 'category': 'container orchestration system'}, {'entity': 'pod labels', 'description': 'Metadata associated with a pod that can be used to identify or filter pods', 'category': 'metadata'}, {'entity': 'label selector', 'description': 'A mechanism to select pods based on their labels', 'category': 'selector'}]","[{'source_entity': 'Kubernetes', 'description': 'manages', 'destination_entity': 'pod'}, {'source_entity': 'readiness probe', 'description': 'checks', 'destination_entity': 'pod'}, {'source_entity': 'label selector', 'description': 'selects', 'destination_entity': 'pod'}, {'source_entity': 'HTTP request', 'description': 'sent to', 'destination_entity': 'service'}, {'source_entity': 'curl', 'description': 'used to', 'destination_entity': 'HTTP request'}, {'source_entity': 'connection refused', 'description': 'error returned by', 'destination_entity': 'service'}, {'source_entity': 'pod labels', 'description': 'used to', 'destination_entity': 'label selector'}]","['[\n  {\n    ""source"": ""Kubernetes"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""manages"",\n    ""summary_er"": ""Kubernetes manages pods, ensuring efficient resource allocation and scaling.""\n  }\n]', '[\n  {\n    ""source"": ""readiness probe"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""checks"",\n    ""summary_er"": ""The readiness probe ensures a pod is running and ready to receive traffic by checking its status.""\n  }\n]', '[\n  {\n    ""source"": ""label selector"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""selects"",\n    ""summary_er"": ""A label selector used to filter pods based on their labels, selecting specific pods for further processing.""\n  }\n]', '[\n  {\n    ""source"": ""HTTP request"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""sent to"",\n    ""summary_er"": ""An HTTP request is sent from a client to a pod in a Kubernetes cluster, which then processes and responds to the request.""\n  },\n  {\n    ""source"": ""pod"",\n    ""destination"": ""service"",\n    ""relation_description"": ""exposed by"",\n    ""summary_er"": ""A pod exposes its services to other pods or external clients through a service, allowing for communication and resource sharing within the cluster.""\n  }\n]', '[\n  {\n    ""source"": ""curl"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""used to send HTTP request"",\n    ""summary_er"": ""curl is a command-line tool used to send HTTP requests to a pod, allowing for communication between the client and server.""\n  }\n]', '[\n  {\n    ""source"": ""Pod"",\n    ""destination"": ""Service"",\n    ""relation_description"": ""connection refused"",\n    ""summary_er"": ""A Pod\'s connection to a Service is refused due to an error returned by the Service, preventing communication between them.""\n  },\n  {\n    ""source"": ""Service"",\n    ""destination"": ""Pod"",\n    ""relation_description"": ""error returned by"",\n    ""summary_er"": ""A Service returns an error when attempting to communicate with a Pod, indicating a potential issue in their interaction.""\n  }\n]', '[\n  {\n    ""source"": ""pod labels"",\n    ""destination"": ""pod label selector"",\n    ""relation_description"": ""used to"",\n    ""summary_er"": ""Pod labels are used to select pods based on their labels, which allows for efficient filtering and retrieval of specific pods in a Kubernetes cluster.""\n  }\n]']","A readiness probe in Kubernetes determines if a pod is ready to accept connections. In real-world scenarios, it should return success or failure depending on whether the app can receive client requests. If no readiness probe is defined, pods become service endpoints immediately and clients may experience connection errors when the app takes too long to start listening for incoming connections.","[{'highlight': 'You can hit the service URL a few times to see that each and every request is redirected to this one pod, even though there are three pods running.'}, {'highlight': 'In the real world, the readiness probe should return success or failure depending on whether the app can (and wants to) receive client requests or not.'}, {'highlight': ""If you don't add a readiness probe to your pods, they'll become service endpoints almost immediately, and clients will see 'Connection refused' types of errors.""}, {'highlight': ""You should always define a readiness probe, even if it's as simple as sending an HTTP request to the base URL.""}, {'highlight': ""Kubernetes removes the pod from all services as soon as you delete the pod, so there's no need to include pod shutdown logic into your readiness probes.""}]"
97,186,0,[],"154
CHAPTER 5
Services: enabling clients to discover and talk to pods
5.6
Using a headless service for discovering individual pods
You’ve seen how services can be used to provide a stable IP address allowing clients to
connect to pods (or other endpoints) backing each service. Each connection to the
service is forwarded to one randomly selected backing pod. But what if the client
needs to connect to all of those pods? What if the backing pods themselves need to
each connect to all the other backing pods? Connecting through the service clearly
isn’t the way to do this. What is?
 For a client to connect to all pods, it needs to figure out the the IP of each individ-
ual pod. One option is to have the client call the Kubernetes API server and get the
list of pods and their IP addresses through an API call, but because you should always
strive to keep your apps Kubernetes-agnostic, using the API server isn’t ideal. 
 Luckily, Kubernetes allows clients to discover pod IPs through DNS lookups. Usually,
when you perform a DNS lookup for a service, the DNS server returns a single IP—the
service’s cluster IP. But if you tell Kubernetes you don’t need a cluster IP for your service
(you do this by setting the clusterIP field to None in the service specification), the DNS
server will return the pod IPs instead of the single service IP.
 Instead of returning a single DNS A record, the DNS server will return multiple A
records for the service, each pointing to the IP of an individual pod backing the ser-
vice at that moment. Clients can therefore do a simple DNS A record lookup and get
the IPs of all the pods that are part of the service. The client can then use that infor-
mation to connect to one, many, or all of them.
5.6.1
Creating a headless service
Setting the clusterIP field in a service spec to None makes the service headless, as
Kubernetes won’t assign it a cluster IP through which clients could connect to the
pods backing it. 
 You’ll create a headless service called kubia-headless now. The following listing
shows its definition.
apiVersion: v1
kind: Service
metadata:
  name: kubia-headless
spec:
  clusterIP: None       
  ports:
  - port: 80
    targetPort: 8080
  selector:
    app: kubia
After you create the service with kubectl create, you can inspect it with kubectl get
and kubectl describe. You’ll see it has no cluster IP and its endpoints include (part of)
Listing 5.18
A headless service: kubia-svc-headless.yaml
This makes the 
service headless.
 
",[],"[{'entity': 'Services', 'description': 'enabling clients to discover and talk to pods', 'category': 'application'}, {'entity': 'Pods', 'description': 'individual units of execution that can be scaled horizontally', 'category': 'container'}, {'entity': 'Kubernetes API server', 'description': 'the central authority for managing Kubernetes resources', 'category': 'software'}, {'entity': 'DNS lookups', 'description': 'a way to resolve service names to pod IPs', 'category': 'process'}, {'entity': 'Cluster IP', 'description': 'a virtual IP address assigned to a service by Kubernetes', 'category': 'network'}, {'entity': 'Service specification', 'description': 'the configuration file that defines a service', 'category': 'software'}, {'entity': 'clusterIP field', 'description': 'a field in the service specification that determines whether a cluster IP is assigned', 'category': 'process'}, {'entity': 'kubectl create', 'description': 'a command used to create a Kubernetes resource', 'category': 'command'}, {'entity': 'kubectl get', 'description': 'a command used to retrieve information about a Kubernetes resource', 'category': 'command'}, {'entity': 'kubectl describe', 'description': 'a command used to display detailed information about a Kubernetes resource', 'category': 'command'}, {'entity': 'headless service', 'description': 'a type of service that does not have a cluster IP assigned', 'category': 'application'}, {'entity': 'selector', 'description': 'a field in the service specification that determines which pods are associated with a service', 'category': 'process'}, {'entity': 'ports', 'description': 'a field in the service specification that defines the ports used by a service', 'category': 'network'}, {'entity': 'targetPort', 'description': 'a field in the service specification that determines which port on a pod is exposed to clients', 'category': 'process'}]","[{'source_entity': '""Services""', 'description': 'are created using', 'destination_entity': '""kubectl create""'}, {'source_entity': '""selector""', 'description': 'is used to specify', 'destination_entity': '""Services""'}, {'source_entity': '""kubectl create""', 'description': 'creates a new', 'destination_entity': '""Service specification""'}, {'source_entity': '""Cluster IP""', 'description': 'is assigned to', 'destination_entity': '""Services""'}, {'source_entity': '""kubectl describe""', 'description': 'provides detailed information about', 'destination_entity': '""Service specification""'}, {'source_entity': '""DNS lookups""', 'description': 'are performed to resolve', 'destination_entity': '""Pods""'}, {'source_entity': '""Pods""', 'description': 'are managed by the', 'destination_entity': '""Kubernetes API server""'}, {'source_entity': '""Service specification""', 'description': 'is used to define', 'destination_entity': '""headless service""'}, {'source_entity': '""clusterIP field""', 'description': 'specifies the IP address of', 'destination_entity': '""Services""'}, {'source_entity': '""ports""', 'description': 'are exposed by', 'destination_entity': '""Service specification""'}, {'source_entity': '""kubectl get""', 'description': 'is used to retrieve information about', 'destination_entity': '""Services""'}, {'source_entity': '""targetPort""', 'description': 'specifies the port on which', 'destination_entity': '""Service specification""'}]","['[\n  {\n    ""source"": ""Services"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""are created using"",\n    ""summary_er"": ""Services are dynamically provisioned and managed by Kubernetes, utilizing \'kubectl create\' command to create pods.""\n  }\n]', '[\n  {\n    ""source"": ""Selector"",\n    ""destination"": ""Pod"",\n    ""relation_description"": ""is used to specify"",\n    ""summary_er"": ""A selector is used to identify a specific Pod in a Kubernetes cluster, allowing for targeted configuration and management.""\n  },\n  {\n    ""source"": ""Services"",\n    ""destination"": ""Pod"",\n    ""relation_description"": ""and the destination pod"",\n    ""summary_er"": ""A Service in Kubernetes provides a stable network identity and load balancing for accessing one or more Pods, which are ephemeral and may change over time.""\n  }\n]', '[\n  {\n    ""source"": ""kubectl create"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""creates a new"",\n    ""summary_er"": ""The \'kubectl create\' command creates a new Kubernetes pod, which is a containerized application running in a cluster.""\n  },\n  {\n    ""source"": ""Service specification"",\n    ""destination"": ""service"",\n    ""relation_description"": ""specifies the service"",\n    ""summary_er"": ""A Service specification defines the characteristics of a Kubernetes service, including its name, selector, and port information.""\n  }\n]', '[\n  {\n    ""source"": ""Cluster IP"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""is assigned to"",\n    ""summary_er"": ""A Cluster IP is a virtual IP address assigned to a pod, allowing it to receive traffic from outside the cluster.""\n  },\n  {\n    ""source"": ""Services"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""exposes"",\n    ""summary_er"": ""A Service exposes a pod\'s IP address and port to other pods in the cluster, enabling communication between them.""\n  }\n]', '[{""source"": ""kubectl describe"", ""destination"": ""pod"", ""relation_description"": ""provides detailed information about"", ""summary_er"": ""Provides detailed info about a pod using kubectl describe command.""}, {""source"": ""Service specification"", ""destination"": ""pod"", ""relation_description"": ""defines the service for"", ""summary_er"": ""Defines service spec for a pod to provide network access.""}]', '[\n  {\n    ""source"": ""DNS lookups"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""are performed to resolve"",\n    ""summary_er"": ""DNS lookups are used by pods to resolve network addresses.""\n  }\n]', '[\n  {\n    ""source"": ""Kubernetes API server"",\n    ""destination"": ""Pods"",\n    ""relation_description"": ""are managed by the"",\n    ""summary_er"": ""The Kubernetes API server manages Pods, overseeing their lifecycle and ensuring they run smoothly.""\n  }\n]', '[\n  {\n    ""source"": ""Service specification"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""is used to define"",\n    ""summary_er"": ""A Service Specification is used to define a pod, providing metadata and configuration for the service.""\n  },\n  {\n    ""source"": ""headless service"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""is used to define"",\n    ""summary_er"": ""A headless service is used to define a pod without a DNS entry, typically used for stateless applications.""\n  }\n]', '[\n  {\n    ""source"": ""clusterIP field"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""specifies the IP address of"",\n    ""summary_er"": ""The clusterIP field specifies the IP address assigned to a pod for communication within the cluster.""\n  }\n]', '[\n  {\n    ""source"": ""ports"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""are exposed by"",\n    ""summary_er"": ""Ports are exposed by a pod, allowing external access to services running within it.""\n  },\n  {\n    ""source"": ""Service specification"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""is used to"",\n    ""summary_er"": ""A Service specification is used to define and expose a service running within a pod.""\n  }\n]', '[\n  {\n    ""source"": ""kubectl"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""is used to retrieve information about"",\n    ""summary_er"": ""The \'kubectl get\' command is used to fetch details about a pod, providing essential information such as its status and configuration.""\n  },\n  {\n    ""source"": ""Services"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""exposes"",\n    ""summary_er"": ""A Service exposes a pod\'s IP address and port to the outside world, enabling external access to the pod\'s resources.""\n  }\n]', '[{""source"": ""Pod"", ""destination"": ""Service"", ""relation_description"": ""Target Port"", ""summary_er"": ""The targetPort field in a Service specification specifies the port on which the service will be exposed to the outside world.""}, {""source"": ""Service"", ""destination"": ""Pod"", ""relation_description"": ""Exposed Port"", ""summary_er"": ""A Service exposes a specific port of a Pod to the outside world, allowing external access to the Pod\'s services.""}]']","Kubernetes allows clients to discover pod IPs through DNS lookups, enabling connection to all pods or individual pods using a headless service with clusterIP set to None. This method is ideal for Kubernetes-agnostic apps, providing a stable IP address for clients to connect to all backing pods.","[{'highlight': 'Services can be used to provide a stable IP address allowing clients to connect to pods or other endpoints backing each service.'}, {'highlight': 'Kubernetes allows clients to discover pod IPs through DNS lookups, which is ideal for keeping apps Kubernetes-agnostic.'}, {'highlight': 'A headless service can be created by setting the clusterIP field in a service spec to None, making it impossible for clients to connect to the pods backing it directly.'}, {'highlight': 'When performing a DNS lookup for a headless service, the DNS server returns multiple A records pointing to the IP of each individual pod backing the service at that moment.'}, {'highlight': 'Clients can use the information obtained from a DNS lookup to connect to one, many, or all of the pods that are part of the service.'}]"
98,187,0,[],"155
Using a headless service for discovering individual pods
the pods matching its pod selector. I say “part of” because your pods contain a readi-
ness probe, so only pods that are ready will be listed as endpoints of the service.
Before continuing, please make sure at least two pods report being ready, by creating
the /var/ready file, as in the previous example:
$ kubectl exec <pod name> -- touch /var/ready
5.6.2
Discovering pods through DNS
With your pods ready, you can now try performing a DNS lookup to see if you get the
actual pod IPs or not. You’ll need to perform the lookup from inside one of the pods.
Unfortunately, your kubia container image doesn’t include the nslookup (or the dig)
binary, so you can’t use it to perform the DNS lookup.
 All you’re trying to do is perform a DNS lookup from inside a pod running in the
cluster. Why not run a new pod based on an image that contains the binaries you
need? To perform DNS-related actions, you can use the tutum/dnsutils container
image, which is available on Docker Hub and contains both the nslookup and the dig
binaries. To run the pod, you can go through the whole process of creating a YAML
manifest for it and passing it to kubectl create, but that’s too much work, right?
Luckily, there’s a faster way.
RUNNING A POD WITHOUT WRITING A YAML MANIFEST
In chapter 1, you already created pods without writing a YAML manifest by using the
kubectl run command. But this time you want to create only a pod—you don’t need
to create a ReplicationController to manage the pod. You can do that like this:
$ kubectl run dnsutils --image=tutum/dnsutils --generator=run-pod/v1
➥ --command -- sleep infinity
pod ""dnsutils"" created
The trick is in the --generator=run-pod/v1 option, which tells kubectl to create the
pod directly, without any kind of ReplicationController or similar behind it. 
UNDERSTANDING DNS A RECORDS RETURNED FOR A HEADLESS SERVICE
Let’s use the newly created pod to perform a DNS lookup:
$ kubectl exec dnsutils nslookup kubia-headless
...
Name:    kubia-headless.default.svc.cluster.local
Address: 10.108.1.4 
Name:    kubia-headless.default.svc.cluster.local
Address: 10.108.2.5 
The DNS server returns two different IPs for the kubia-headless.default.svc
.cluster.local FQDN. Those are the IPs of the two pods that are reporting being
ready. You can confirm this by listing pods with kubectl get pods -o wide, which
shows the pods’ IPs. 
 
",[],"[{'entity': 'headless service', 'description': 'a service that does not have an IP address and instead uses DNS to discover individual pods', 'category': 'software'}, {'entity': 'pod selector', 'description': 'a label used to select specific pods', 'category': 'software'}, {'entity': 'readiness probe', 'description': 'a mechanism to check if a pod is ready to serve traffic', 'category': 'software'}, {'entity': 'kubectl exec', 'description': 'a command to execute a command inside a running container', 'category': 'command'}, {'entity': 'pod name', 'description': 'the name of a running pod', 'category': 'object'}, {'entity': '/var/ready file', 'description': 'a file used to indicate that a pod is ready', 'category': 'file'}, {'entity': 'DNS lookup', 'description': 'a process to resolve a domain name to an IP address', 'category': 'process'}, {'entity': 'nslookup', 'description': 'a command-line tool to perform DNS lookups', 'category': 'command'}, {'entity': 'dig binary', 'description': 'a binary used for DNS-related actions', 'category': 'binary'}, {'entity': 'tutum/dnsutils container image', 'description': 'an image containing the binaries needed for DNS-related actions', 'category': 'image'}, {'entity': 'kubectl run command', 'description': 'a command to create a pod without writing a YAML manifest', 'category': 'command'}, {'entity': '--generator=run-pod/v1 option', 'description': 'an option used to create a pod directly without any kind of ReplicationController or similar behind it', 'category': 'option'}, {'entity': 'ReplicationController', 'description': 'a component used to manage the creation and scaling of pods', 'category': 'software'}, {'entity': 'DNS A records', 'description': 'the IP addresses returned by a DNS server for a headless service', 'category': 'object'}, {'entity': 'kubia-headless.default.svc.cluster.local FQDN', 'description': 'a fully qualified domain name used to perform DNS lookups', 'category': 'domain name'}, {'entity': 'kubectl get pods command', 'description': 'a command to list running pods with their IPs', 'category': 'command'}]","[{'source_entity': '""nslookup""', 'description': 'performs DNS A records lookup', 'destination_entity': '""DNS A records""'}, {'source_entity': '""pod selector""', 'description': 'selects pods based on labels', 'destination_entity': '""pods""'}, {'source_entity': '""readiness probe""', 'description': 'checks the readiness of a pod', 'destination_entity': '""pod name""'}, {'source_entity': '""kubectl run command""', 'description': 'runs a container in a pod', 'destination_entity': '""tutum/dnsutils container image""'}, {'source_entity': '""kubia-headless.default.svc.cluster.local FQDN""', 'description': 'is the DNS name of a headless service', 'destination_entity': '""headless service""'}, {'source_entity': '""dig binary""', 'description': 'performs DNS lookup', 'destination_entity': '""DNS A records""'}, {'source_entity': '""kubectl get pods command""', 'description': 'gets information about a pod', 'destination_entity': '""pod name""'}, {'source_entity': '""kubectl exec""', 'description': 'executes a command in a container', 'destination_entity': '""/var/ready file""'}, {'source_entity': '""DNS lookup""', 'description': 'looks up DNS information for a domain name', 'destination_entity': '""kubia-headless.default.svc.cluster.local FQDN""'}, {'source_entity': '""headless service""', 'description': 'is a type of Kubernetes service that does not have an IP address', 'destination_entity': '""ReplicationController""'}]","['[\n  {\n    ""source"": ""nslookup"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""performs DNS A records lookup"",\n    ""summary_er"": ""The nslookup command performs a DNS A records lookup on a pod to resolve its IP address.""\n  }\n]', '[\n  {\n    ""source"": ""pod selector"",\n    ""destination"": ""pods"",\n    ""relation_description"": ""selects pods based on labels"",\n    ""summary_er"": ""A pod selector uses labels to identify and select specific pods in a Kubernetes cluster, allowing for targeted management and operations.""\n  }\n]', '[\n  {\n    ""source"": ""readiness probe"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""checks the readiness of a pod"",\n    ""summary_er"": ""The readiness probe checks if a pod is ready to receive traffic by executing a command or checking for a file. It ensures the pod\'s health and availability.""\n  },\n  {\n    ""source"": ""readiness probe"",\n    ""destination"": ""pod name"",\n    ""relation_description"": ""checks the readiness of a pod"",\n    ""summary_er"": ""The readiness probe uses the pod name to identify the specific pod being checked for readiness. It ensures accurate monitoring and reporting.""\n  }\n]', '[\n  {\n    ""source"": ""kubectl run command"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""runs a container in a pod"",\n    ""summary_er"": ""The kubectl run command deploys a container within a pod, utilizing the tutum/dnsutils image for DNS utility functionality.""\n  },\n  {\n    ""source"": ""tutum/dnsutils container image"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""runs a container in a pod"",\n    ""summary_er"": ""The tutum/dnsutils image provides DNS utilities, which are executed within a pod created by the kubectl run command.""\n  }\n]', '[\n  {\n    ""source"": ""kubia-headless.default.svc.cluster.local FQDN"",\n    ""destination"": ""headless service"",\n    ""relation_description"": ""is the DNS name of a headless service"",\n    ""summary_er"": ""A headless service is a Kubernetes service that does not have an associated pod, and its DNS name is used to resolve the IP address of the pods it manages.""\n  }\n]', '[\n  {\n    ""source"": ""dig binary"",\n    ""destination"": ""DNS A records"",\n    ""relation_description"": ""performs DNS lookup"",\n    ""summary_er"": ""The dig binary performs a DNS lookup on the \'DNS A records\' to resolve domain names into IP addresses.""\n  }\n]', '[\n  {\n    ""source"": ""kubectl get pods command"",\n    ""destination"": ""pod name"",\n    ""relation_description"": ""gets information about a pod"",\n    ""summary_er"": ""The \'kubectl get pods\' command retrieves details about a specific pod, including its status and other relevant information.""\n  }\n]', '[\n  {\n    ""source"": ""kubectl exec"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""executes a command in a container"",\n    ""summary_er"": ""Executes a command within a pod\'s container, allowing for direct interaction with the container\'s file system and processes.""\n  }\n]', '[\n  {\n    ""source"": ""DNS lookup"",\n    ""destination"": ""kubia-headless.default.svc.cluster.local FQDN"",\n    ""relation_description"": ""looks up DNS information for a domain name"",\n    ""summary_er"": ""DNS lookup service resolves \'kubia-headless\' FQDN to its IP address and port.""\n  }\n]', '[\n  {\n    ""source"": ""Kubernetes"",\n    ""destination"": ""Pod"",\n    ""relation_description"": ""is a container runtime environment"",\n    ""summary_er"": ""A Pod is the basic execution unit in Kubernetes, comprising one or more containers.""\n  },\n  {\n    ""source"": ""Docker"",\n    ""destination"": ""Container"",\n    ""relation_description"": ""is a lightweight and standalone executable package"",\n    ""summary_er"": ""A Container is a lightweight and portable software package that includes everything needed to run an application.""\n  },\n  {\n    ""source"": ""Machine Learning"",\n    ""destination"": ""Generative AI"",\n    ""relation_description"": ""uses algorithms to generate new data samples"",\n    ""summary_er"": ""Generative AI uses machine learning algorithms to create new, synthetic data samples that resemble real-world data.""\n  },\n  {\n    ""source"": ""Natural Language Understanding"",\n    ""destination"": ""Computer Vision"",\n    ""relation_description"": ""analyzes and interprets visual data from images and videos"",\n    ""summary_er"": ""Computer Vision is a field of AI that enables machines to interpret and understand visual data from images and videos.""\n  },\n  {\n    ""source"": ""Kubernetes"",\n    ""destination"": ""ReplicationController"",\n    ""relation_description"": ""is a type of pod controller"",\n    ""summary_er"": ""A ReplicationController ensures a specified number of replicas (identical copies) of a pod are running at any given time.""\n  },\n  {\n    ""source"": ""headless service"",\n    ""destination"": ""Kubernetes service"",\n    ""relation_description"": ""is a type of Kubernetes service that does not have an IP address"",\n    ""summary_er"": ""A headless service in Kubernetes is a service without an IP address, used to manage and expose pods without a network identity.""\n  }\n]']","A headless service is used to discover individual pods based on a pod selector. The service will list only ready pods as endpoints. To confirm readiness, create the /var/ready file in each pod. A DNS lookup can be performed from inside a pod using the tutum/dnsutils container image or by running a new pod without writing a YAML manifest using kubectl run with the --generator=run-pod/v1 option. This allows understanding of how DNS A records are returned for a headless service, which returns IPs of all ready pods.","[{'highlight': 'You can use a headless service to discover individual pods that match its pod selector, but only pods that are ready will be listed as endpoints of the service.'}, {'highlight': 'To perform DNS-related actions from inside a pod, you can run a new pod based on the tutum/dnsutils container image, which contains both nslookup and dig binaries.'}, {'highlight': 'You can create a pod without writing a YAML manifest using the kubectl run command with the --generator=run-pod/v1 option to tell kubectl to create the pod directly.'}, {'highlight': 'A DNS lookup for a headless service returns the IPs of all pods that are reporting being ready, which can be confirmed by listing pods with kubectl get pods -o wide.'}, {'highlight': 'The tutum/dnsutils container image contains both nslookup and dig binaries, making it useful for performing DNS-related actions from inside a pod.'}]"
99,188,0,[],"156
CHAPTER 5
Services: enabling clients to discover and talk to pods
 This is different from what DNS returns for regular (non-headless) services, such
as for your kubia service, where the returned IP is the service’s cluster IP:
$ kubectl exec dnsutils nslookup kubia
...
Name:    kubia.default.svc.cluster.local
Address: 10.111.249.153
Although headless services may seem different from regular services, they aren’t that
different from the clients’ perspective. Even with a headless service, clients can con-
nect to its pods by connecting to the service’s DNS name, as they can with regular ser-
vices. But with headless services, because DNS returns the pods’ IPs, clients connect
directly to the pods, instead of through the service proxy. 
NOTE
A headless services still provides load balancing across pods, but through
the DNS round-robin mechanism instead of through the service proxy.
5.6.3
Discovering all pods—even those that aren’t ready
You’ve seen that only pods that are ready become endpoints of services. But some-
times you want to use the service discovery mechanism to find all pods matching the
service’s label selector, even those that aren’t ready. 
 Luckily, you don’t have to resort to querying the Kubernetes API server. You can
use the DNS lookup mechanism to find even those unready pods. To tell Kubernetes
you want all pods added to a service, regardless of the pod’s readiness status, you must
add the following annotation to the service:
kind: Service
metadata:
  annotations:
    service.alpha.kubernetes.io/tolerate-unready-endpoints: ""true""
WARNING
As the annotation name suggests, as I’m writing this, this is an alpha
feature. The Kubernetes Service API already supports a new service spec field
called publishNotReadyAddresses, which will replace the tolerate-unready-
endpoints annotation. In Kubernetes version 1.9.0, the field is not honored yet
(the annotation is what determines whether unready endpoints are included in
the DNS or not). Check the documentation to see whether that’s changed.
5.7
Troubleshooting services
Services are a crucial Kubernetes concept and the source of frustration for many
developers. I’ve seen many developers lose heaps of time figuring out why they can’t
connect to their pods through the service IP or FQDN. For this reason, a short look at
how to troubleshoot services is in order.
 When you’re unable to access your pods through the service, you should start by
going through the following list:
 
",[],"[{'entity': 'Kubernetes', 'description': 'container orchestration system', 'category': 'software'}, {'entity': 'DNS', 'description': 'domain name system', 'category': 'network'}, {'entity': 'Pods', 'description': 'lightweight and ephemeral containers', 'category': 'application'}, {'entity': 'Services', 'description': 'abstraction layer for accessing pods', 'category': 'software'}, {'entity': 'kubectl', 'description': 'command-line tool for interacting with Kubernetes', 'category': 'software'}, {'entity': 'exec', 'description': 'command for executing a command in a container', 'category': 'command'}, {'entity': 'nslookup', 'description': 'command for looking up DNS records', 'category': 'command'}, {'entity': 'headless services', 'description': ""services that don't have an IP address"", 'category': 'software'}, {'entity': 'load balancing', 'description': 'distributing traffic across multiple pods', 'category': 'process'}, {'entity': 'DNS round-robin', 'description': 'mechanism for distributing traffic across multiple pods', 'category': 'process'}, {'entity': 'Kubernetes API server', 'description': 'centralized management interface for Kubernetes', 'category': 'software'}, {'entity': 'annotations', 'description': 'metadata associated with a resource', 'category': 'database'}, {'entity': 'service.alpha.kubernetes.io/tolerate-unready-endpoints', 'description': 'annotation for tolerating unready endpoints', 'category': 'database'}, {'entity': 'publishNotReadyAddresses', 'description': 'field for publishing not ready addresses', 'category': 'database'}, {'entity': 'Kubernetes version 1.9.0', 'description': 'version of Kubernetes', 'category': 'software'}]","[{'source_entity': '""exec""', 'description': 'Executes a command to check Kubernetes version', 'destination_entity': '""Kubernetes version 1.9.0""'}, {'source_entity': '""kubectl""', 'description': 'Uses to manage Kubernetes clusters', 'destination_entity': '""Kubernetes API server""'}, {'source_entity': '""publishNotReadyAddresses""', 'description': 'Publishes not ready addresses for services', 'destination_entity': '""Services""'}, {'source_entity': '""headless services""', 'description': 'Provides a way to expose services without creating a load balancer', 'destination_entity': '""load balancing""'}, {'source_entity': '""Kubernetes API server""', 'description': 'Manages and controls the cluster resources', 'destination_entity': '""Pods""'}, {'source_entity': '""DNS round-robin""', 'description': 'Provides a way to distribute traffic across multiple instances of a service', 'destination_entity': '""Services""'}, {'source_entity': '""Kubernetes""', 'description': 'Manages containerized applications and services', 'destination_entity': '""Pods""'}, {'source_entity': '""service.alpha.kubernetes.io/tolerate-unready-endpoints""', 'description': 'Tolerates unready endpoints for services', 'destination_entity': '""Services""'}, {'source_entity': '""nslookup""', 'description': 'Looks up the DNS records for a service', 'destination_entity': '""DNS""'}]","['[\n  {\n    ""source"": ""exec"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""Executes a command to check Kubernetes version"",\n    ""summary_er"": ""The exec relation executes a command on a pod to retrieve its Kubernetes version, which is currently 1.9.0.""\n  }\n]', '[\n  {\n    ""source"": ""kubectl"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""Uses to manage"",\n    ""summary_er"": ""kubectl uses Kubernetes API server to manage pods.""\n  },\n  {\n    ""source"": ""Kubernetes API server"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""manages"",\n    ""summary_er"": ""The Kubernetes API server manages and controls the lifecycle of pods.""\n  }\n]', '[\n  {\n    ""source"": ""publishNotReadyAddresses"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""Publishes not ready addresses for services"",\n    ""summary_er"": ""Publishes not ready addresses for services, indicating which pods are not yet ready to receive traffic.""\n  },\n  {\n    ""source"": ""publishNotReadyAddresses"",\n    ""destination"": ""Services"",\n    ""relation_description"": ""Publishes not ready addresses for services"",\n    ""summary_er"": ""Provides a list of services that are not yet ready to receive traffic, allowing the system to wait until they are available.""\n  }\n]', '[\n  {\n    ""source"": ""headless services"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""Provides a way to expose services without creating a load balancer"",\n    ""summary_er"": ""Headless services enable exposing pods directly, bypassing load balancing, allowing for efficient service exposure.""\n  }\n]', '[\n  {\n    ""source"": ""Kubernetes API server"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""Manages and controls the cluster resources"",\n    ""summary_er"": ""The Kubernetes API server manages and controls pod resources within a cluster.""\n  }\n]', '[\n  {\n    ""source"": ""DNS round-robin"",\n    ""destination"": ""Pods"",\n    ""relation_description"": ""Provides a way to distribute traffic across multiple instances of a service"",\n    ""summary_er"": ""DNS round-robin distributes traffic across multiple pod instances for load balancing.""\n  }\n]', '[\n  {\n    ""source"": ""Kubernetes"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""Manages containerized applications and services"",\n    ""summary_er"": ""Kubernetes manages and orchestrates pods, ensuring efficient resource utilization and scalability for containerized applications.""\n  }\n]', '[\n  {\n    ""source"": ""service.alpha.kubernetes.io/tolerate-unready-endpoints"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""Tolerates unready endpoints for services"",\n    ""summary_er"": ""This Kubernetes annotation allows a service to tolerate unready endpoints, enabling it to function even when pods are not yet ready.""\n  }\n]', '[\n  {\n    ""source"": ""nslookup"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""Looks up the DNS records for a service"",\n    ""summary_er"": ""The nslookup command retrieves DNS records from a pod, allowing it to resolve service names and access resources.""\n  }\n]']","Headless services allow clients to connect directly to pods by DNS name. Kubernetes provides load balancing across pods through DNS round-robin mechanism instead of service proxy. To discover all pods, including unready ones, add annotation 'service.alpha.kubernetes.io/tolerate-unready-endpoints: true' or use the publishNotReadyAddresses field in service spec.","[{'highlight': 'Headless services allow clients to connect directly to pods instead of through the service proxy.'}, {'highlight': ""To discover all pods, including unready ones, add the annotation 'service.alpha.kubernetes.io/tolerate-unready-endpoints: true' to the service.""}, {'highlight': ""The 'publishNotReadyAddresses' field will replace the 'tolerate-unready-endpoints' annotation in future Kubernetes versions.""}, {'highlight': 'To troubleshoot services, check if the service is running and if the pods are ready and accessible through the service IP or FQDN.'}, {'highlight': 'Headless services still provide load balancing across pods through DNS round-robin mechanism.'}]"
