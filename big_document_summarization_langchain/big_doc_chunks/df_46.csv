,page,img_cnt,img_npy_lst,text,tables,entities,relationships,summary_rel,summary,highlights
460,549,0,[],"517
Defining custom API objects
The logs show that the controller received the ADDED event and that it created a Service
and a Deployment for the kubia-website Website. The API server responded with a
201 Created response, which means the two resources should now exist. Let’s verify
that the Deployment, Service and the resulting Pod were created. The following list-
ing lists all Deployments, Services and Pods.
$ kubectl get deploy,svc,po
NAME                        DESIRED   CURRENT   UP-TO-DATE   AVAILABLE  AGE
deploy/kubia-website        1         1         1            1          4s
deploy/website-controller   1         1         1            1          5m
NAME                CLUSTER-IP     EXTERNAL-IP   PORT(S)        AGE
svc/kubernetes      10.96.0.1      <none>        443/TCP        38d
svc/kubia-website   10.101.48.23   <nodes>       80:32589/TCP   4s
NAME                                     READY     STATUS    RESTARTS   AGE
po/kubia-website-1029415133-rs715        2/2       Running   0          4s
po/website-controller-1571685839-qzmg6   2/2       Running   1          5m
There they are. The kubia-website Service, through which you can access your web-
site, is available on port 32589 on all cluster nodes. You can access it with your browser.
Awesome, right? 
 Users of your Kubernetes cluster can now deploy static websites in seconds, with-
out knowing anything about Pods, Services, or any other Kubernetes resources, except
your custom Website resource. 
 Obviously, you still have room for improvement. The controller could, for exam-
ple, watch for Service objects and as soon as the node port is assigned, write the URL
the website is accessible at into the status section of the Website resource instance
itself. Or it could also create an Ingress object for each website. I’ll leave the imple-
mentation of these additional features to you as an exercise.
18.1.3 Validating custom objects
You may have noticed that you didn’t specify any kind of validation schema in the Web-
site CustomResourceDefinition. Users can include any field they want in the YAML of
their Website object. The API server doesn’t validate the contents of the YAML (except
the usual fields like apiVersion, kind, and metadata), so users can create invalid
Website objects (without a gitRepo field, for example). 
 Is it possible to add validation to the controller and prevent invalid objects from
being accepted by the API server? It isn’t, because the API server first stores the object,
then returns a success response to the client (kubectl), and only then notifies all the
watchers (the controller is one of them). All the controller can really do is validate
the object when it receives it in a watch event, and if the object is invalid, write the
error message to the Website object (by updating the object through a new request to
the API server). The user wouldn’t be notified of the error automatically. They’d have
Listing 18.7
The Deployment, Service, and Pod created for the kubia-website
 
",[],"[{'entity': 'API server', 'description': 'The API server responded with a 201 Created response.', 'category': 'software'}, {'entity': 'Deployment', 'description': 'A Deployment was created for the kubia-website Website.', 'category': 'application'}, {'entity': 'Service', 'description': 'A Service was created for the kubia-website Website.', 'category': 'application'}, {'entity': 'Pod', 'description': 'A Pod was created for the kubia-website Website.', 'category': 'container'}, {'entity': 'kubectl', 'description': 'The command used to get Deployments, Services, and Pods.', 'category': 'command'}, {'entity': 'get deploy,svc,po', 'description': 'The command used to list all Deployments, Services, and Pods.', 'category': 'command'}, {'entity': 'cluster-IP', 'description': 'The Cluster IP address of the Service.', 'category': 'network'}, {'entity': 'EXTERNAL-IP', 'description': 'The External IP address of the Service.', 'category': 'network'}, {'entity': 'PORT(S)', 'description': 'The port(s) exposed by the Service.', 'category': 'process'}, {'entity': 'READY', 'description': 'The status of the Pod.', 'category': 'process'}, {'entity': 'STATUS', 'description': 'The status of the Pod.', 'category': 'process'}, {'entity': 'RESTARTS', 'description': 'The number of restarts for the Pod.', 'category': 'process'}, {'entity': 'AGE', 'description': 'The age of the Deployment, Service, or Pod.', 'category': 'hardware'}, {'entity': 'CustomResourceDefinition', 'description': 'A Custom Resource Definition for the Website resource.', 'category': 'software'}, {'entity': 'validation schema', 'description': 'A validation schema to validate the contents of the YAML.', 'category': 'software'}, {'entity': 'Website object', 'description': 'A custom object representing a website.', 'category': 'application'}, {'entity': 'gitRepo field', 'description': 'A required field in the Website object.', 'category': 'database'}]","[{'source_entity': 'Service', 'description': 'defines a logical set of pods and accessibility rules', 'destination_entity': 'Pod'}, {'source_entity': 'get deploy,svc,po', 'description': 'allows you to view the status of deployments, services, and pods', 'destination_entity': 'Deployment'}, {'source_entity': 'get deploy,svc,po', 'description': 'allows you to view the status of deployments, services, and pods', 'destination_entity': 'Service'}, {'source_entity': 'get deploy,svc,po', 'description': 'allows you to view the status of deployments, services, and pods', 'destination_entity': 'Pod'}, {'source_entity': 'READY', 'description': 'shows the number of ready replicas for each deployment', 'destination_entity': 'Deployment'}, {'source_entity': 'STATUS', 'description': 'displays the current status of each pod', 'destination_entity': 'Pod'}, {'source_entity': 'RESTARTS', 'description': 'indicates how many times a pod has been restarted', 'destination_entity': 'Pod'}, {'source_entity': 'kubectl', 'description': 'used to interact with a Kubernetes cluster', 'destination_entity': 'API server'}, {'source_entity': 'validation schema', 'description': 'defines the structure and content of a resource', 'destination_entity': 'Deployment'}, {'source_entity': 'Deployment', 'description': 'defines a template for creating multiple replicas of a pod', 'destination_entity': 'Pod'}, {'source_entity': 'EXTERNAL-IP', 'description': 'used to configure access to a service', 'destination_entity': 'Service'}, {'source_entity': 'PORT(S)', 'description': 'used to configure access to a service', 'destination_entity': 'Service'}, {'source_entity': 'cluster-IP', 'description': 'used to configure access to a service', 'destination_entity': 'Service'}, {'source_entity': 'CustomResourceDefinition', 'description': 'allows you to define custom resources', 'destination_entity': 'Deployment'}, {'source_entity': 'AGE', 'description': 'displays the age of each deployment', 'destination_entity': 'Deployment'}, {'source_entity': 'API server', 'description': 'entry point for interacting with a Kubernetes cluster', 'destination_entity': 'kubectl'}, {'source_entity': 'gitRepo field', 'description': 'used to specify the Git repository containing the source code for a deployment', 'destination_entity': 'Deployment'}]","['[\n  {\n    ""source"": ""Service"",\n    ""destination"": ""Pod"",\n    ""relation_description"": ""defines a logical set of pods and accessibility rules"",\n    ""summary_er"": ""A Service provides a network identity and load balancing for accessing a group of Pods with similar characteristics.""\n  }\n]', '[\n  {\n    ""source"": ""get"",\n    ""destination"": ""deploy"",\n    ""relation_description"": ""command to retrieve deployment information"",\n    ""summary_er"": ""The \'get\' command allows you to view deployment details, including status.""\n  },\n  {\n    ""source"": ""get"",\n    ""destination"": ""svc"",\n    ""relation_description"": ""command to retrieve service information"",\n    ""summary_er"": ""The \'get\' command enables viewing of service details, such as status and endpoints.""\n  },\n  {\n    ""source"": ""get"",\n    ""destination"": ""po"",\n    ""relation_description"": ""command to retrieve pod information"",\n    ""summary_er"": ""The \'get\' command allows you to view pod details, including status and logs.""\n  },\n  {\n    ""source"": ""deploy"",\n    ""destination"": ""svc"",\n    ""relation_description"": ""relationship between deployment and service"",\n    ""summary_er"": ""A deployment is associated with one or more services, which provide access to the deployed application.""\n  },\n  {\n    ""source"": ""deploy"",\n    ""destination"": ""po"",\n    ""relation_description"": ""relationship between deployment and pod"",\n    ""summary_er"": ""A deployment consists of one or more pods, which are the basic execution units in Kubernetes.""\n  },\n  {\n    ""source"": ""svc"",\n    ""destination"": ""po"",\n    ""relation_description"": ""relationship between service and pod"",\n    ""summary_er"": ""A service provides access to a set of pods, which can be scaled and managed independently.""\n  }\n]', '[\n  {\n    ""source"": ""get deploy"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""allows you to view the status of deployments, services, and pods"",\n    ""summary_er"": ""Get deployment status via pod""\n  },\n  {\n    ""source"": ""get svc"",\n    ""destination"": ""service"",\n    ""relation_description"": ""allows you to view the status of deployments, services, and pods"",\n    ""summary_er"": ""Get service status via service""\n  },\n  {\n    ""source"": ""get po"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""allows you to view the status of deployments, services, and pods"",\n    ""summary_er"": ""Get pod status via pod""\n  }\n]', '[\n  {\n    ""source"": ""get"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""allows you to view the status of deployments, services, and pods"",\n    ""summary_er"": ""The get command allows users to retrieve information about a pod, including its status and details.""\n  }\n]', '[\n  {\n    ""source"": ""READY"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""shows the number of ready replicas for each deployment"",\n    ""summary_er"": ""The READY metric displays the count of active replicas for each deployment, indicating their operational status.""\n  }\n]', '[\n  {\n    ""source"": ""STATUS"",\n    ""destination"": ""Pod"",\n    ""relation_description"": ""displays the current status of each pod"",\n    ""summary_er"": ""The STATUS entity displays real-time information about the state of each Pod, providing insights into their operational status.""\n  }\n]', '[\n  {\n    ""source"": ""RESTARTS"",\n    ""destination"": ""Pod"",\n    ""relation_description"": ""indicates how many times a pod has been restarted"",\n    ""summary_er"": ""The RESTARTS metric tracks the number of restarts for a Pod, indicating its reliability and stability.""\n  }\n]', '[\n  {\n    ""source"": ""kubectl"",\n    ""destination"": ""API server"",\n    ""relation_description"": ""used to interact with a Kubernetes cluster"",\n    ""summary_er"": ""kubectl interacts with the API server to manage and control Kubernetes clusters.""\n  }\n]', '[\n  {\n    ""source"": ""validation schema"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""defines the structure and content of a resource"",\n    ""summary_er"": ""A validation schema defines the structure and content of a pod, ensuring it conforms to specific requirements.""\n  },\n  {\n    ""source"": ""pod"",\n    ""destination"": ""deployment"",\n    ""relation_description"": ""related entity"",\n    ""summary_er"": ""A pod is related to a deployment, which manages its lifecycle and ensures it runs as expected.""\n  }\n]', '[\n  {\n    ""source"": ""Deployment"",\n    ""destination"": ""Pod"",\n    ""relation_description"": ""defines a template for creating multiple replicas of a pod"",\n    ""summary_er"": ""A Deployment creates a template for multiple identical Pods, ensuring scalability and high availability.""\n  }\n]', '[\n  {\n    ""source"": ""EXTERNAL-IP"",\n    ""destination"": ""Service"",\n    ""relation_description"": ""used to configure access to a service"",\n    ""summary_er"": ""The EXTERNAL-IP is used to expose a Service, allowing external access to it.""\n  }\n]', '[\n  {\n    ""source"": ""PORT(S)"",\n    ""destination"": ""Service"",\n    ""relation_description"": ""used to configure access to a service"",\n    ""summary_er"": ""A port in PORT(S) allows access to a Service, enabling communication between them.""\n  }\n]', '[\n  {\n    ""source"": ""cluster-IP"",\n    ""destination"": ""Service"",\n    ""relation_description"": ""used to configure access to a service"",\n    ""summary_er"": ""Cluster IP is used to expose a Service to the network, allowing external access.""\n  }\n]', '[\n  {\n    ""source"": ""CustomResourceDefinition"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""allows you to define custom resources"",\n    ""summary_er"": ""CustomResourceDefinition enables defining custom resources, which can be used to manage pods and other Kubernetes objects.""\n  }\n]', '[\n  {\n    ""source"": ""AGE"",\n    ""destination"": ""Deployment"",\n    ""relation_description"": ""displays the age of each deployment"",\n    ""summary_er"": ""The AGE relation displays the age or uptime of each deployment, providing a metric for monitoring and optimizing deployment performance.""\n  }\n]', '[\n  {\n    ""source"": ""API server"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""entry point for interacting with a Kubernetes cluster"",\n    ""summary_er"": ""The API server serves as the primary entry point for interacting with a Kubernetes cluster, allowing users to manage and control pods through kubectl.""\n  }\n]', '[\n  {\n    ""source"": ""Git Repo"",\n    ""destination"": ""Pod"",\n    ""relation_description"": ""used to specify the Git repository containing the source code for a deployment"",\n    ""summary_er"": ""A Git repository contains the source code for a deployment, which is then deployed as a Pod in Kubernetes.""\n  }\n]']","A custom API object was successfully created by the controller, which received an ADDED event and created a Service and a Deployment for the kubia-website Website. The API server responded with a 201 Created response, and the resulting Pod was also created. However, users can create invalid Website objects without validation schema in the CustomResourceDefinition. The controller can only validate the object when it receives it in a watch event, and if invalid, write an error message to the Website object.","[{'highlight': 'A custom API object was successfully created by the controller, including a Service and a Deployment for the kubia-website Website.'}, {'highlight': 'The API server responded with a 201 Created response, indicating that the two resources should now exist.'}, {'highlight': 'Users of your Kubernetes cluster can now deploy static websites in seconds without knowing anything about Pods, Services, or other Kubernetes resources.'}, {'highlight': 'Validation schema was not specified in the Website CustomResourceDefinition, allowing users to create invalid Website objects.'}, {'highlight': ""The controller can validate the object when it receives it in a watch event and update the object with an error message if it's invalid.""}]"
461,550,0,[],"518
CHAPTER 18
Extending Kubernetes
to notice the error message by querying the API server for the Website object. Unless
the user does this, they have no way of knowing whether the object is valid or not.
 This obviously isn’t ideal. You’d want the API server to validate the object and
reject invalid objects immediately. Validation of custom objects was introduced in
Kubernetes version 1.8 as an alpha feature. To have the API server validate your cus-
tom objects, you need to enable the CustomResourceValidation feature gate in the
API server and specify a JSON schema in the CRD.
18.1.4 Providing a custom API server for your custom objects
A better way of adding support for custom objects in Kubernetes is to implement your
own API server and have the clients talk directly to it. 
INTRODUCING API SERVER AGGREGATION
In Kubernetes version 1.7, you can integrate your custom API server with the main
Kubernetes API server, through API server aggregation. Initially, the Kubernetes API
server was a single monolithic component. From Kubernetes version 1.7, multiple
aggregated API servers will be exposed at a single location. Clients can connect to the
aggregated API and have their requests transparently forwarded to the appropriate
API server. This way, the client wouldn’t even be aware that multiple API servers han-
dle different objects behind the scenes. Even the core Kubernetes API server may
eventually end up being split into multiple smaller API servers and exposed as a single
server through the aggregator, as shown in figure 18.5.
In your case, you could create an API server responsible for handling your Website
objects. It could validate those objects the way the core Kubernetes API server validates
them. You’d no longer need to create a CRD to represent those objects, because you’d
implement the Website object type into the custom API server directly. 
 Generally, each API server is responsible for storing their own resources. As shown
in figure 18.5, it can either run its own instance of etcd (or a whole etcd cluster), or it
Main
API server
Custom
API server Y
Custom
API server X
kubectl
Uses its own etcd instance
for storing its resources
Uses CustomResourceDeﬁnitions
in main API server as storage
mechanism
etcd
etcd
Figure 18.5
API server aggregation
 
",[],"[{'entity': 'Kubernetes', 'description': 'Container orchestration system', 'category': 'software'}, {'entity': 'API server', 'description': 'Server responsible for handling API requests', 'category': 'software'}, {'entity': 'CustomResourceValidation', 'description': 'Feature gate for validating custom objects', 'category': 'software'}, {'entity': 'JSON schema', 'description': 'Schema for validating custom object definitions', 'category': 'software'}, {'entity': 'CRD', 'description': 'Custom Resource Definition for defining custom objects', 'category': 'software'}, {'entity': 'etcd', 'description': 'Key-value store used by Kubernetes for storing data', 'category': 'database'}, {'entity': 'kubectl', 'description': 'Command-line tool for interacting with Kubernetes', 'category': 'command'}, {'entity': 'API server aggregation', 'description': 'Feature for integrating multiple API servers into a single location', 'category': 'software'}, {'entity': 'Website object', 'description': 'Custom object type for representing website resources', 'category': 'software'}, {'entity': 'Custom API server', 'description': 'API server responsible for handling custom objects', 'category': 'software'}, {'entity': 'Main API server', 'description': 'Primary API server for Kubernetes', 'category': 'software'}]","[{'source_entity': '""Website object""', 'description': 'uses', 'destination_entity': '""JSON schema""'}, {'source_entity': '""CustomResourceValidation""', 'description': 'validates', 'destination_entity': '""API server aggregation""'}, {'source_entity': '""kubectl""', 'description': 'interacts with', 'destination_entity': '""etcd""'}, {'source_entity': '""Custom API server""', 'description': 'extends', 'destination_entity': '""Kubernetes""'}, {'source_entity': '""CRD""', 'description': 'defines', 'destination_entity': '""API server""'}, {'source_entity': '""Main API server""', 'description': 'aggregates', 'destination_entity': '""Custom API server""'}]","['[\n  {\n    ""source"": ""Website object"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""uses"",\n    ""summary_er"": ""A website object utilizes a pod to deploy and manage its application components, leveraging containerization for efficient resource allocation.""\n  }\n]', '[\n  {\n    ""source"": ""CustomResourceValidation"",\n    ""destination"": ""Pod"",\n    ""relation_description"": ""validates"",\n    ""summary_er"": ""The CustomResourceValidation mechanism ensures that custom resources conform to predefined validation rules, guaranteeing their integrity and consistency within the Kubernetes environment.""\n  },\n  {\n    ""source"": ""API server aggregation"",\n    ""destination"": ""Pod"",\n    ""relation_description"": ""aggregates"",\n    ""summary_er"": ""The API server aggregation feature in Kubernetes enables the consolidation of multiple APIs into a single endpoint, streamlining interactions with pods and enhancing overall system efficiency.""\n  }\n]', '[\n  {\n    ""source"": ""kubectl"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""interacts with"",\n    ""summary_er"": ""Kubectl, a command-line tool, interacts with pods to manage and deploy containerized applications.""\n  },\n  {\n    ""source"": ""etcd"",\n    ""destination"": """",\n    ""relation_description"": """",\n    ""summary_er"": """"\n  }\n]', '[\n  {\n    ""source"": ""Custom API server"",\n    ""destination"": ""Kubernetes"",\n    ""relation_description"": ""extends"",\n    ""summary_er"": ""A custom API server built on top of Kubernetes, leveraging its scalability and reliability features.""\n  }\n]', '[\n  {\n    ""source"": ""CRD"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""defines"",\n    ""summary_er"": ""A Custom Resource Definition (CRD) defines a new API object type in Kubernetes, which can be used to create and manage pods.""\n  }\n]', '[\n  {\n    ""source"": ""Main API server"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""aggregates"",\n    ""summary_er"": ""The Main API server aggregates data from multiple sources, including pods, to provide a unified view.""\n  },\n  {\n    ""source"": ""Custom API server"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""serves"",\n    ""summary_er"": ""The Custom API server serves as an entry point for incoming requests, interacting with the pod to fulfill them.""\n  }\n]']","To extend Kubernetes, validation of custom objects was introduced in version 1.8, enabling the API server to validate custom objects immediately. Alternatively, implementing a custom API server and integrating it with the main Kubernetes API server through API server aggregation allows for more control over custom object handling. This approach eliminates the need for a CRD and enables direct implementation of custom object types within the custom API server.","[{'highlight': 'Kubernetes version 1.8 introduced validation of custom objects as an alpha feature.'}, {'highlight': 'To validate custom objects, you need to enable the CustomResourceValidation feature gate and specify a JSON schema in the CRD.'}, {'highlight': 'API server aggregation was introduced in Kubernetes version 1.7, allowing multiple API servers to be exposed at a single location.'}, {'highlight': 'You can create a custom API server responsible for handling your Website objects and validate them directly, eliminating the need for a CRD.'}, {'highlight': 'Each API server is responsible for storing its own resources, which can either run their own etcd instance or use CustomResourceDefinitions in the main API server as storage.'}]"
462,551,0,[],"519
Extending Kubernetes with the Kubernetes Service Catalog
can store its resources in the core API server’s etcd store by creating CRD instances in
the core API server. In that case, it needs to create a CRD object first, before creating
instances of the CRD, the way you did in the example.
REGISTERING A CUSTOM API SERVER
To add a custom API server to your cluster, you’d deploy it as a pod and expose it
through a Service. Then, to integrate it into the main API server, you’d deploy a YAML
manifest describing an APIService resource like the one in the following listing.
apiVersion: apiregistration.k8s.io/v1beta1   
kind: APIService                             
metadata:
  name: v1alpha1.extensions.example.com
spec:
  group: extensions.example.com           
  version: v1alpha1                      
  priority: 150
  service:                    
    name: website-api         
    namespace: default        
After creating the APIService resource from the previous listing, client requests sent
to the main API server that contain any resource from the extensions.example.com
API group and version v1alpha1 would be forwarded to the custom API server pod(s)
exposed through the website-api Service. 
CREATING CUSTOM CLIENTS
While you can create custom resources from YAML files using the regular kubectl cli-
ent, to make deployment of custom objects even easier, in addition to providing a cus-
tom API server, you can also build a custom CLI tool. This will allow you to add
dedicated commands for manipulating those objects, similar to how kubectl allows
creating Secrets, Deployments, and other resources through resource-specific com-
mands like kubectl create secret or kubectl create deployment.
 As I’ve already mentioned, custom API servers, API server aggregation, and other
features related to extending Kubernetes are currently being worked on intensively, so
they may change after the book is published. To get up-to-date information on the
subject, refer to the Kubernetes GitHub repos at http:/
/github.com/kubernetes.
18.2
Extending Kubernetes with the Kubernetes Service 
Catalog
One of the first additional API servers that will be added to Kubernetes through API
server aggregation is the Service Catalog API server. The Service Catalog is a hot topic
in the Kubernetes community, so you may want to know about it. 
 Currently, for a pod to consume a service (here I use the term generally, not in
relation to Service resources; for example, a database service includes everything
Listing 18.8
An APIService YAML definition 
This is an APIService 
resource.
The API group this API 
server is responsible for
The supported API version
The Service the custom API 
server is exposed through
 
",[],"[{'entity': 'Kubernetes', 'description': 'Container orchestration system', 'category': 'software'}, {'entity': 'Service Catalog', 'description': 'API server for managing services', 'category': 'software'}, {'entity': 'CRD (Custom Resource Definition)', 'description': 'Definition of a custom resource', 'category': 'software'}, {'entity': 'etcd store', 'description': 'Key-value store for storing Kubernetes resources', 'category': 'database'}, {'entity': 'APIService', 'description': 'Resource for registering a custom API server', 'category': 'software'}, {'entity': 'API group', 'description': 'Namespace for APIs (e.g. extensions.example.com)', 'category': 'network'}, {'entity': 'Service', 'description': ""Resource for exposing a pod's port to the network"", 'category': 'software'}, {'entity': 'pod', 'description': 'Lightweight and portable container runtime', 'category': 'container'}, {'entity': 'kubectl', 'description': 'Command-line tool for interacting with Kubernetes', 'category': 'software'}, {'entity': 'custom API server', 'description': 'API server built on top of Kubernetes', 'category': 'software'}, {'entity': 'YAML manifest', 'description': 'File format for defining resources in Kubernetes', 'category': 'file format'}, {'entity': 'GitHub repos', 'description': 'Kubernetes source code repository on GitHub', 'category': 'software development'}]","[{'source_entity': '""Service""', 'description': 'is managed by', 'destination_entity': '""CRD (Custom Resource Definition)""'}, {'source_entity': '""CRD (Custom Resource Definition)""', 'description': 'defines the structure for', 'destination_entity': '""Service Catalog""'}, {'source_entity': '""APIService""', 'description': 'provides an interface to', 'destination_entity': '""custom API server""'}, {'source_entity': '""kubectl""', 'description': 'interacts with', 'destination_entity': '""Service Catalog""'}, {'source_entity': '""GitHub repos""', 'description': 'store the YAML manifests for', 'destination_entity': '""Kubernetes""'}, {'source_entity': '""YAML manifest""', 'description': 'defines the configuration for', 'destination_entity': '""Service Catalog""'}, {'source_entity': '""etcd store""', 'description': 'stores the state of', 'destination_entity': '""Kubernetes""'}, {'source_entity': '""Service Catalog""', 'description': 'provides a catalog of', 'destination_entity': '""Services""'}, {'source_entity': '""Kubernetes""', 'description': 'manages the lifecycle of', 'destination_entity': '""pod""'}]","['[\n  {\n    ""source"": ""Service"",\n    ""destination"": ""Pod"",\n    ""relation_description"": ""is managed by"",\n    ""summary_er"": ""A Service is a logical abstraction that manages access to one or more Pods, providing a stable network identity and load balancing.""\n  },\n  {\n    ""source"": ""CRD (Custom Resource Definition)"",\n    ""destination"": ""API Server"",\n    ""relation_description"": ""defines"",\n    ""summary_er"": ""A CRD defines a custom resource that can be used by the API Server to manage and store data in a Kubernetes cluster.""\n  }\n]', '[\n  {\n    ""source"": ""CRD"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""defines the structure for"",\n    ""summary_er"": ""A CRD defines the structure of a custom resource, which can be used to manage pods in Kubernetes.""\n  },\n  {\n    ""source"": ""Service Catalog"",\n    ""destination"": ""CRD"",\n    ""relation_description"": ""uses"",\n    ""summary_er"": ""Service Catalog uses Custom Resource Definitions (CRDs) to define and manage services in Kubernetes.""\n  }\n]', '[\n  {\n    ""source"": ""APIService"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""provides an interface to"",\n    ""summary_er"": ""The APIService provides a custom API server interface for pods, enabling them to interact with the Kubernetes cluster.""\n  }\n]', '[\n  {\n    ""source"": ""kubectl"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""interacts with"",\n    ""summary_er"": ""Kubectl, a command-line tool, interacts with pods to manage and deploy containerized applications.""\n  },\n  {\n    ""source"": ""Service Catalog"",\n    ""destination"": null,\n    ""relation_description"": null,\n    ""summary_er"": ""Service Catalog is a Kubernetes feature that provides a way to expose services as APIs, but it does not have a direct relation with another entity.""\n  }\n]', '[\n  {\n    ""source"": ""GitHub repos"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""store the YAML manifests for"",\n    ""summary_er"": ""GitHub repos store YAML manifests for Kubernetes pods, enabling deployment and management of containerized applications.""\n  }\n]', '[\n  {\n    ""source"": ""YAML manifest"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""defines the configuration for"",\n    ""summary_er"": ""A YAML file that defines the configuration for a pod, specifying its properties and behavior.""\n  },\n  {\n    ""source"": ""Service Catalog"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""provides a catalog of services"",\n    ""summary_er"": ""A Service Catalog is a collection of pre-defined services that can be used to deploy applications, providing a standardized way to access and utilize these services within a pod.""\n  }\n]', '[\n  {\n    ""source"": ""etcd store"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""stores the state of"",\n    ""summary_er"": ""Etcd store maintains the state of a Kubernetes pod, ensuring data consistency and integrity.""\n  },\n  {\n    ""source"": ""Kubernetes"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""container orchestration"",\n    ""summary_er"": ""Kubernetes orchestrates and manages containers within pods, providing efficient resource utilization and scalability.""\n  }\n]', '[\n  {\n    ""source"": ""Service Catalog"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""provides a catalog of"",\n    ""summary_er"": ""The Service Catalog provides a centralized repository of services, enabling efficient discovery and utilization by pods.""\n  }\n]', '[\n  {\n    ""source"": ""Kubernetes"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""manages the lifecycle of"",\n    ""summary_er"": ""Kubernetes manages the lifecycle of pods, ensuring they are created, updated, and deleted as needed.""\n  }\n]']","Kubernetes can be extended by creating Custom Resource Definitions (CRDs) in the core API server's etcd store. A custom API server can be added to a cluster by deploying it as a pod and exposing it through a Service, then integrating it into the main API server using an APIService resource. This allows client requests to be forwarded to the custom API server for specific resources. Additionally, custom clients can be built to create custom objects, making deployment easier. The Kubernetes Service Catalog API server will also be added through API server aggregation, enabling pods to consume services.","[{'highlight': 'To add a custom API server to your cluster, you’d deploy it as a pod and expose it through a Service. Then, to integrate it into the main API server, you’d deploy a YAML manifest describing an APIService resource.'}, {'highlight': 'Client requests sent to the main API server that contain any resource from the extensions.example.com API group and version v1alpha1 would be forwarded to the custom API server pod(s) exposed through the website-api Service.'}, {'highlight': 'You can create custom resources from YAML files using the regular kubectl client, or build a custom CLI tool to add dedicated commands for manipulating those objects.'}, {'highlight': 'The Service Catalog is a hot topic in the Kubernetes community, and one of the first additional API servers that will be added to Kubernetes through API server aggregation is the Service Catalog API server.'}, {'highlight': 'To create a custom API server, you need to create a CRD object first, before creating instances of the CRD, by creating a CRD instance in the core API server’s etcd store.'}]"
463,552,0,[],"520
CHAPTER 18
Extending Kubernetes
required to allow users to use a database in their app), someone needs to deploy the
pods providing the service, a Service resource, and possibly a Secret so the client pod
can use it to authenticate with the service. That someone is usually the same user
deploying the client pod or, if a team is dedicated to deploying these types of general
services, the user needs to file a ticket and wait for the team to provision the service.
This means the user needs to either create the manifests for all the components of the
service, know where to find an existing set of manifests, know how to configure it
properly, and deploy it manually, or wait for the other team to do it. 
 But Kubernetes is supposed to be an easy-to-use, self-service system. Ideally, users
whose apps require a certain service (for example, a web application requiring a back-
end database), should be able to say to Kubernetes. “Hey, I need a PostgreSQL data-
base. Please provision one and tell me where and how I can connect to it.” This will
soon be possible through the Kubernetes Service Catalog. 
18.2.1 Introducing the Service Catalog
As the name suggests, the Service Catalog is a catalog of services. Users can browse
through the catalog and provision instances of the services listed in the catalog by
themselves without having to deal with Pods, Services, ConfigMaps, and other resources
required for the service to run. You’ll recognize that this is similar to what you did
with the Website custom resource.
 Instead of adding custom resources to the API server for each type of service, the
Service Catalog introduces the following four generic API resources:
A ClusterServiceBroker, which describes an (external) system that can provision
services
A ClusterServiceClass, which describes a type of service that can be provisioned
A ServiceInstance, which is one instance of a service that has been provisioned
A ServiceBinding, which represents a binding between a set of clients (pods)
and a ServiceInstance
The relationships between those four resources are shown in the figure 18.6 and
explained in the following paragraphs.
In a nutshell, a cluster admin creates a ClusterServiceBroker resource for each service
broker whose services they’d like to make available in the cluster. Kubernetes then asks
the broker for a list of services that it can provide and creates a ClusterServiceClass
resource for each of them. When a user requires a service to be provisioned, they create
an ServiceInstance resource and then a ServiceBinding to bind that ServiceInstance to
Client pods
ServiceBinding
ServiceInstance
ClusterServiceClass(es)
ClusterServiceBroker
Figure 18.6
The relationships between Service Catalog API resources. 
 
","[Empty DataFrame
Columns: [ClusterServiceBroker, Col1, ClusterServiceClass(es), Col3, Col4, ServiceInstance, Col6, Col7, ServiceBinding, Client pods]
Index: []]","[{'entity': 'Kubernetes', 'description': 'Container orchestration system', 'category': 'software'}, {'entity': 'Pods', 'description': 'Lightweight and portable containers', 'category': 'container'}, {'entity': 'Service resource', 'description': 'Resource that defines a service in Kubernetes', 'category': 'resource'}, {'entity': 'Secret', 'description': 'Resource that stores sensitive information', 'category': 'resource'}, {'entity': 'Client pod', 'description': 'Pod that uses a service to authenticate', 'category': 'container'}, {'entity': 'Service Catalog', 'description': 'Catalog of services in Kubernetes', 'category': 'software'}, {'entity': 'ClusterServiceBroker', 'description': 'API resource that describes an external system for provisioning services', 'category': 'resource'}, {'entity': 'ClusterServiceClass', 'description': 'API resource that describes a type of service that can be provisioned', 'category': 'resource'}, {'entity': 'ServiceInstance', 'description': 'API resource that represents one instance of a service', 'category': 'resource'}, {'entity': 'ServiceBinding', 'description': 'API resource that represents a binding between clients and a ServiceInstance', 'category': 'resource'}, {'entity': 'Cluster admin', 'description': 'User who creates ClusterServiceBroker resources for each service broker', 'category': 'user'}, {'entity': 'User', 'description': 'Person who deploys client pods and requires services to be provisioned', 'category': 'user'}, {'entity': 'Team', 'description': 'Group of users who are responsible for deploying general services', 'category': 'group'}, {'entity': 'Ticket', 'description': 'Request for a service to be provisioned by the team', 'category': 'request'}, {'entity': 'Manifests', 'description': 'Files that define the configuration and deployment of a service', 'category': 'file'}, {'entity': 'API server', 'description': 'Component of Kubernetes that manages API requests', 'category': 'component'}]","[{'source_entity': '""API server""', 'description': 'provides', 'destination_entity': '""Manifests""'}, {'source_entity': '""API server""', 'description': 'manages', 'destination_entity': '""Service resource""'}, {'source_entity': '""API server""', 'description': 'deploys', 'destination_entity': '""Pods""'}, {'source_entity': '""ClusterServiceBroker""', 'description': 'registers', 'destination_entity': '""Service Catalog""'}, {'source_entity': '""ClusterServiceBroker""', 'description': 'provides', 'destination_entity': '""ServiceInstance""'}, {'source_entity': '""Client pod""', 'description': 'requests', 'destination_entity': '""ServiceBinding""'}, {'source_entity': '""User""', 'description': 'interacts with', 'destination_entity': '""API server""'}, {'source_entity': '""User""', 'description': 'creates', 'destination_entity': '""Ticket""'}, {'source_entity': '""Cluster admin""', 'description': 'manages', 'destination_entity': '""Service Catalog""'}, {'source_entity': '""Team""', 'description': 'uses', 'destination_entity': '""Kubernetes""'}, {'source_entity': '""Cluster admin""', 'description': 'configures', 'destination_entity': '""ClusterServiceClass""'}, {'source_entity': '""API server""', 'description': 'exposes', 'destination_entity': '""Secret""'}]","['[\n  {\n    ""source"": ""API server"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""provides"",\n    ""summary_er"": ""The API server provides a pod, which is a containerized application instance.""\n  }\n]', '[\n  {\n    ""source"": ""API server"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""manages"",\n    ""summary_er"": ""The API server manages a pod, which is a containerized application that can be scaled and managed by Kubernetes.""\n  },\n  {\n    ""source"": ""Service resource"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""managed by"",\n    ""summary_er"": ""A Service resource provides a stable network identity and load balancing for accessing a pod, which is a containerized application.""\n  }\n]', '[\n  {\n    ""source"": ""API server"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""deploys"",\n    ""summary_er"": ""The API server is responsible for deploying pods, which are the basic execution units in a Kubernetes cluster.""\n  }\n]', '[\n  {\n    ""source"": ""ClusterServiceBroker"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""registers"",\n    ""summary_er"": ""The Cluster Service Broker registers a pod with the Service Catalog, enabling it to provide services to clients.""\n  }\n]', '[\n  {\n    ""source"": ""ClusterServiceBroker"",\n    ""destination"": ""ServiceInstance"",\n    ""relation_description"": ""provides"",\n    ""summary_er"": ""A Cluster Service Broker provides a service instance to a cluster, enabling the deployment and management of external services within the cluster.""\n  }\n]', '[\n  {\n    ""source"": ""Client pod"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""requests"",\n    ""summary_er"": ""A client pod sends requests to a service binding, which forwards them to the actual service.""\n  }\n]', '[\n  {\n    ""source"": ""User"",\n    ""destination"": ""API server"",\n    ""relation_description"": ""interacts with"",\n    ""summary_er"": ""A user communicates with the API server to access and manage Kubernetes resources.""\n  }\n]', '[{\n  ""source"": ""User"",\n  ""destination"": ""Pod"",\n  ""relation_description"": ""creates"",\n  ""summary_er"": ""A user initiates a new pod creation, which is a containerized application instance.""\n}]', '[\n  {\n    ""source"": ""Cluster admin"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""manages"",\n    ""summary_er"": ""Cluster admin manages pods, ensuring they are running and scaling correctly.""\n  },\n  {\n    ""source"": ""Service Catalog"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""catalogs"",\n    ""summary_er"": ""Service Catalog catalogs available services for pods to use, streamlining deployment and management.""\n  }\n]', '[\n  {\n    ""source"": ""Team"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""uses"",\n    ""summary_er"": ""A team utilizes Kubernetes to manage and orchestrate their containerized applications, ensuring efficient resource allocation and scalability.""\n  }\n]', '[\n  {\n    ""source"": ""Cluster admin"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""configures"",\n    ""summary_er"": ""A cluster administrator sets up and manages pods within a Kubernetes cluster.""\n  }\n]', '[\n  {\n    ""source"": ""API server"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""exposes"",\n    ""summary_er"": ""The API server exposes its functionality to a pod, allowing it to interact with the server.""\n  },\n  {\n    ""source"": ""Secret"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""exposes"",\n    ""summary_er"": ""A Secret exposes sensitive information to a pod, making it accessible for use within the container.""\n  }\n]']","Kubernetes' Service Catalog is a feature that allows users to provision services without dealing with underlying components like Pods and Services. It uses four generic API resources: ClusterServiceBroker, ClusterServiceClass, ServiceInstance, and ServiceBinding. A cluster admin creates a ClusterServiceBroker resource for each service broker, which lists available services. Users create a ServiceInstance resource for the required service, and a ServiceBinding to bind it to client pods.","[{'highlight': 'Kubernetes is supposed to be an easy-to-use, self-service system where users can provision services like PostgreSQL databases without manual configuration and deployment.'}, {'highlight': 'The Kubernetes Service Catalog introduces four generic API resources: ClusterServiceBroker, ClusterServiceClass, ServiceInstance, and ServiceBinding to enable users to browse and provision services without dealing with underlying resources.'}, {'highlight': ""A cluster admin creates a ClusterServiceBroker resource for each service broker whose services they'd like to make available in the cluster.""}, {'highlight': 'Users can create a ServiceInstance resource to request a specific service, such as PostgreSQL, and then bind it to client pods using a ServiceBinding resource.'}, {'highlight': 'The relationships between Service Catalog API resources are defined by ClusterServiceBroker, ClusterServiceClass, ServiceInstance, and ServiceBinding, which enable users to provision services without manual configuration and deployment.'}]"
464,553,0,[],"521
Extending Kubernetes with the Kubernetes Service Catalog
their pods. Those pods are then injected with a Secret that holds all the necessary cre-
dentials and other data required to connect to the provisioned ServiceInstance.
 The Service Catalog system architecture is shown in figure 18.7.
The components shown in the figure are explained in the following sections.
18.2.2 Introducing the Service Catalog API server and Controller 
Manager
Similar to core Kubernetes, the Service Catalog is a distributed system composed of
three components:
Service Catalog API Server
etcd as the storage
Controller Manager, where all the controllers run
The four Service Catalog–related resources we introduced earlier are created by post-
ing YAML/JSON manifests to the API server. It then stores them into its own etcd
instance or uses CustomResourceDefinitions in the main API server as an alternative
storage mechanism (in that case, no additional etcd instance is required). 
 The controllers running in the Controller Manager are the ones doing some-
thing with those resources. They obviously talk to the Service Catalog API server, the
way other core Kubernetes controllers talk to the core API server. Those controllers
don’t provision the requested services themselves. They leave that up to external
service brokers, which are registered by creating ServiceBroker resources in the Ser-
vice Catalog API.
Kubernetes cluster
External system(s)
Kubernetes Service Catalog
Client pods
Provisioned
services
Broker A
Broker B
etcd
Service
Catalog
API server
Controller
Manager
kubectl
Provisioned
services
Client pods use the
provisioned services
Figure 18.7
The architecture of the Service Catalog
 
",[],"[{'entity': 'Kubernetes', 'description': 'Container orchestration system', 'category': 'software'}, {'entity': 'Service Catalog', 'description': 'System for discovering and using external services', 'category': 'software'}, {'entity': 'pods', 'description': 'Lightweight and portable containers', 'category': 'container'}, {'entity': 'Secret', 'description': 'Object that holds sensitive information', 'category': 'database'}, {'entity': 'ServiceInstance', 'description': 'Resource representing a provisioned service', 'category': 'resource'}, {'entity': 'API server', 'description': 'Component of the Service Catalog system', 'category': 'software'}, {'entity': 'etcd', 'description': 'Distributed key-value store', 'category': 'database'}, {'entity': 'Controller Manager', 'description': 'Component of the Service Catalog system', 'category': 'software'}, {'entity': 'ServiceBroker', 'description': 'Resource representing a service broker', 'category': 'resource'}, {'entity': 'kubectl', 'description': 'Command-line tool for interacting with Kubernetes', 'category': 'command'}, {'entity': 'Client pods', 'description': 'Pods that use provisioned services', 'category': 'container'}, {'entity': 'Provisioned services', 'description': 'Services provided by external systems', 'category': 'resource'}, {'entity': 'Broker A and Broker B', 'description': 'External service brokers', 'category': 'software'}]","[{'source_entity': '""Broker A and Broker B""', 'description': 'provides', 'destination_entity': '""ServiceBroker""'}, {'source_entity': '""Broker A and Broker B""', 'description': 'registers', 'destination_entity': '""Service Catalog""'}, {'source_entity': '""Broker A and Broker B""', 'description': 'manages', 'destination_entity': '""Client pods""'}, {'source_entity': '""Broker A and Broker B""', 'description': 'provisions', 'destination_entity': '""Provisioned services""'}, {'source_entity': '""ServiceBroker""', 'description': 'exposes', 'destination_entity': '""ServiceInstance""'}, {'source_entity': '""kubectl""', 'description': 'interacts with', 'destination_entity': '""API server""'}, {'source_entity': '""etcd""', 'description': 'stores', 'destination_entity': '""Controller Manager""'}, {'source_entity': '""Controller Manager""', 'description': 'manages', 'destination_entity': '""Client pods""'}, {'source_entity': '""Controller Manager""', 'description': 'uses', 'destination_entity': '""Secret""'}, {'source_entity': '""Service Catalog""', 'description': 'provides', 'destination_entity': '""Provisioned services""'}]","['[\n  {\n    ""source"": ""Broker A and Broker B"",\n    ""destination"": ""ServiceBroker"",\n    ""relation_description"": ""provides"",\n    ""summary_er"": ""Broker A and Broker B provide ServiceBroker, enabling efficient service discovery and management.""\n  }\n]', '[\n  {\n    ""source"": ""Broker A and Broker B"",\n    ""destination"": ""Service Catalog"",\n    ""relation_description"": ""registers"",\n    ""summary_er"": ""Broker A and Broker B register Service Catalog, enabling dynamic service discovery and management.""\n  }\n]', '[\n  {\n    ""source"": ""Broker A and Broker B"",\n    ""destination"": ""Client pods"",\n    ""relation_description"": ""manages"",\n    ""summary_er"": ""Broker A and Broker B manage client pods, ensuring efficient resource allocation and scalability.""\n  }\n]', '[\n  {\n    ""source"": ""Broker A and Broker B"",\n    ""destination"": ""Pod"",\n    ""relation_description"": ""provisions"",\n    ""summary_er"": ""Broker A and Broker B provide provisions to Pod, ensuring it has necessary resources for operation.""\n  },\n  {\n    ""source"": ""Pod"",\n    ""destination"": ""Provisioned services"",\n    ""relation_description"": ""has"",\n    ""summary_er"": ""The Pod has been provisioned with necessary services, enabling it to function correctly and efficiently.""\n  }\n]', '[\n  {\n    ""source"": ""ServiceBroker"",\n    ""destination"": ""ServiceInstance"",\n    ""relation_description"": ""exposes"",\n    ""summary_er"": ""A ServiceBroker exposes a ServiceInstance, making it available for consumption by applications.""\n  }\n]', '[\n  {\n    ""source"": ""kubectl"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""interacts with"",\n    ""summary_er"": ""Kubectl, a command-line tool, interacts with pods to manage containerized applications.""\n  },\n  {\n    ""source"": ""API server"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""manages"",\n    ""summary_er"": ""The API server manages the lifecycle of pods in a Kubernetes cluster, including creation and deletion.""\n  }\n]', '[\n  {\n    ""source"": ""etcd"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""stores"",\n    ""summary_er"": ""Etcd stores data for Kubernetes pods, ensuring consistency and availability across the cluster.""\n  }\n]', '[\n  {\n    ""source"": ""Controller Manager"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""manages"",\n    ""summary_er"": ""The Controller Manager component in Kubernetes manages a collection of Pods, ensuring their lifecycle and resource allocation.""\n  }\n]', '[\n  {\n    ""source"": ""Controller Manager"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""uses"",\n    ""summary_er"": ""The Controller Manager component in Kubernetes utilizes a pod to execute its functionality, relying on it for resource management and orchestration.""\n  }\n]', '[\n  {\n    ""source"": ""Service Catalog"",\n    ""destination"": ""Pod"",\n    ""relation_description"": ""provides"",\n    ""summary_er"": ""The Service Catalog provides a catalog of provisioned services to pods, enabling them to access and utilize these services.""\n  }\n]']","The Kubernetes Service Catalog is a distributed system composed of three components: API Server, etcd, and Controller Manager. The Service Catalog API server stores resources created by posting YAML/JSON manifests to itself or uses CustomResourceDefinitions in the main API server. Controllers running in the Controller Manager talk to the Service Catalog API server and provision services using external service brokers registered with ServiceBroker resources.","[{'highlight': 'The Kubernetes Service Catalog is a distributed system composed of three components: Service Catalog API Server, etcd as the storage, and Controller Manager.'}, {'highlight': 'Four Service Catalog-related resources (ServiceInstance, ClusterServiceClass, ServiceBroker, and Plans) are created by posting YAML/JSON manifests to the API server.'}, {'highlight': 'The controllers running in the Controller Manager provision services by talking to external service brokers registered through ServiceBroker resources.'}, {'highlight': 'Client pods use the provisioned services provided by external systems, which are managed by the Kubernetes Service Catalog.'}, {'highlight': 'The Service Catalog API server stores resources in its own etcd instance or uses CustomResourceDefinitions in the main API server as an alternative storage mechanism.'}]"
465,554,0,[],"522
CHAPTER 18
Extending Kubernetes
18.2.3 Introducing Service Brokers and the OpenServiceBroker API
A cluster administrator can register one or more external ServiceBrokers in the Ser-
vice Catalog. Every broker must implement the OpenServiceBroker API.
INTRODUCING THE OPENSERVICEBROKER API
The Service Catalog talks to the broker through that API. The API is relatively simple.
It’s a REST API providing the following operations:
Retrieving the list of services with GET /v2/catalog
Provisioning a service instance (PUT /v2/service_instances/:id)
Updating a service instance (PATCH /v2/service_instances/:id)
Binding a service instance (PUT /v2/service_instances/:id/service_bind-
ings/:binding_id)
Unbinding an instance (DELETE /v2/service_instances/:id/service_bind-
ings/:binding_id)
Deprovisioning a service instance (DELETE /v2/service_instances/:id)
You’ll find the OpenServiceBroker API spec at https:/
/github.com/openservicebro-
kerapi/servicebroker.
REGISTERING BROKERS IN THE SERVICE CATALOG
The cluster administrator registers a broker by posting a ServiceBroker resource man-
ifest to the Service Catalog API, like the one shown in the following listing.
apiVersion: servicecatalog.k8s.io/v1alpha1    
kind: ClusterServiceBroker                                  
metadata:
  name: database-broker                          
spec:
  url: http://database-osbapi.myorganization.org  
The listing describes an imaginary broker that can provision databases of different
types. After the administrator creates the ClusterServiceBroker resource, a controller
in the Service Catalog Controller Manager connects to the URL specified in the
resource to retrieve the list of services this broker can provision.
 After the Service Catalog retrieves the list of services, it creates a ClusterService-
Class resource for each of them. Each ClusterServiceClass resource describes a sin-
gle type of service that can be provisioned (an example of a ClusterServiceClass is
“PostgreSQL database”). Each ClusterServiceClass has one or more service plans asso-
ciated with it. These allow the user to choose the level of service they need (for exam-
ple, a database ClusterServiceClass could provide a “Free” plan, where the size of the
Listing 18.9
A ClusterServiceBroker manifest: database-broker.yaml
The resource kind and 
the API group and version
The name of this broker
Where the Service Catalog
can contact the broker
(its OpenServiceBroker [OSB] API URL)
 
",[],"[{'entity': 'Kubernetes', 'description': 'Container orchestration system', 'category': 'software'}, {'entity': 'Service Brokers', 'description': 'External service providers that implement the OpenServiceBroker API', 'category': 'application'}, {'entity': 'OpenServiceBroker API', 'description': 'REST API for interacting with Service Brokers', 'category': 'software'}, {'entity': 'GET /v2/catalog', 'description': 'Operation to retrieve the list of services from a Service Broker', 'category': 'operation'}, {'entity': 'PUT /v2/service_instances/:id', 'description': 'Operation to provision a service instance from a Service Broker', 'category': 'operation'}, {'entity': 'PATCH /v2/service_instances/:id', 'description': 'Operation to update a service instance from a Service Broker', 'category': 'operation'}, {'entity': 'PUT /v2/service_instances/:id/service_bindings/:binding_id', 'description': 'Operation to bind a service instance from a Service Broker', 'category': 'operation'}, {'entity': 'DELETE /v2/service_instances/:id/service_bindings/:binding_id', 'description': 'Operation to unbind a service instance from a Service Broker', 'category': 'operation'}, {'entity': 'DELETE /v2/service_instances/:id', 'description': 'Operation to deprovision a service instance from a Service Broker', 'category': 'operation'}, {'entity': 'ClusterServiceBroker', 'description': 'Resource manifest for registering a Service Broker in the Service Catalog', 'category': 'resource'}, {'entity': 'apiVersion', 'description': 'Field in the ClusterServiceBroker resource manifest specifying the API version', 'category': 'field'}, {'entity': 'kind', 'description': 'Field in the ClusterServiceBroker resource manifest specifying the kind of resource', 'category': 'field'}, {'entity': 'metadata', 'description': 'Field in the ClusterServiceBroker resource manifest containing metadata about the resource', 'category': 'field'}, {'entity': 'name', 'description': 'Field in the ClusterServiceBroker resource manifest specifying the name of the Service Broker', 'category': 'field'}, {'entity': 'spec', 'description': 'Field in the ClusterServiceBroker resource manifest containing specifications for the Service Broker', 'category': 'field'}, {'entity': 'url', 'description': ""Field in the ClusterServiceBroker resource manifest specifying the URL of the Service Broker's OpenServiceBroker API"", 'category': 'field'}, {'entity': 'ClusterServiceClass', 'description': 'Resource created by the Service Catalog to describe a type of service that can be provisioned', 'category': 'resource'}, {'entity': 'service plans', 'description': 'Options for choosing the level of service needed for a particular type of service', 'category': 'option'}]","[{'source_entity': '""OpenServiceBroker API""', 'description': 'provides', 'destination_entity': '""PUT /v2/service_instances/:id""'}, {'source_entity': '""OpenServiceBroker API""', 'description': 'allows', 'destination_entity': '""PATCH /v2/service_instances/:id""'}, {'source_entity': '""OpenServiceBroker API""', 'description': 'provides', 'destination_entity': '""GET /v2/catalog""'}, {'source_entity': '""ClusterServiceBroker""', 'description': 'manages', 'destination_entity': '""service plans""'}, {'source_entity': '""ClusterServiceBroker""', 'description': 'provides', 'destination_entity': '""PUT /v2/service_instances/:id""'}, {'source_entity': '""spec""', 'description': 'defines', 'destination_entity': '""service plans""'}, {'source_entity': '""apiVersion""', 'description': 'specifies', 'destination_entity': '""Kubernetes""'}, {'source_entity': '""DELETE /v2/service_instances/:id""', 'description': 'removes', 'destination_entity': '""service bindings""'}, {'source_entity': '""Service Brokers""', 'description': 'list', 'destination_entity': '""GET /v2/catalog""'}, {'source_entity': '""DELETE /v2/service_instances/:id""', 'description': 'deletes', 'destination_entity': '""service instances""'}, {'source_entity': '""kind""', 'description': 'specifies', 'destination_entity': '""Kubernetes""'}, {'source_entity': '""ClusterServiceClass""', 'description': 'defines', 'destination_entity': '""service plans""'}]","['[\n  {\n    ""source"": ""OpenServiceBroker API"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""provides"",\n    ""summary_er"": ""The OpenServiceBroker API provides a pod, which is a containerized application that can be scaled and managed.""\n  }\n]', '[\n  {\n    ""source"": ""OpenServiceBroker API"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""allows"",\n    ""summary_er"": ""The OpenServiceBroker API enables access to a pod, allowing for PATCH requests to service instances with ID :id.""\n  }\n]', '[\n  {\n    ""source"": ""OpenServiceBroker API"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""provides"",\n    ""summary_er"": ""The OpenServiceBroker API provides a catalog of available services, which can be retrieved using the GET /v2/catalog endpoint.""\n  }\n]', '[\n  {\n    ""source"": ""ClusterServiceBroker"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""manages"",\n    ""summary_er"": ""The Cluster Service Broker manages service plans for pods, providing a way to deploy and manage services within a Kubernetes cluster.""\n  }\n]', '[\n  {\n    ""source"": ""ClusterServiceBroker"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""provides"",\n    ""summary_er"": ""The Cluster Service Broker provides a pod with services, enabling it to run and manage containerized applications.""\n  }\n]', '[\n  {\n    ""source"": ""spec"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""defines"",\n    ""summary_er"": ""The spec entity defines a pod, which is a containerized application in Kubernetes.""\n  },\n  {\n    ""source"": ""service plans"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""related to"",\n    ""summary_er"": ""Service plans are related to pods, which provide scalable and reliable deployment of applications.""\n  }\n]', '[\n  {\n    ""source"": ""apiVersion"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""specifies"",\n    ""summary_er"": ""The Kubernetes API version is specified for a pod, defining its configuration and behavior.""\n  }\n]', '[\n  {\n    ""source"": ""DELETE /v2/service_instances/:id"",\n    ""destination"": ""pod service bindings"",\n    ""relation_description"": ""removes"",\n    ""summary_er"": ""Deleting a service instance removes its associated pod and service bindings.""\n  }\n]', '[\n  {\n    ""source"": ""Service Brokers"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""list"",\n    ""summary_er"": ""Service brokers list available pods for deployment and management.""\n  }\n]', '[\n  {\n    ""source"": ""Service Instances"",\n    ""destination"": ""Pod"",\n    ""relation_description"": ""deletes"",\n    ""summary_er"": ""Deleting a service instance terminates its associated pod, releasing resources and stopping any running containers.""\n  }\n]', '[\n  {\n    ""source"": ""kind"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""specifies"",\n    ""summary_er"": ""In Kubernetes, a kind is used to specify a pod\'s configuration and characteristics.""\n  }\n]', '[\n  {\n    ""source"": ""ClusterServiceClass"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""defines"",\n    ""summary_er"": ""A Cluster Service Class defines a set of characteristics for a pod, including service plans and other configurations.""\n  }\n]']","A cluster administrator can register external ServiceBrokers in the Service Catalog through the OpenServiceBroker API, which provides operations for provisioning, updating, and deprovisioning services. A ClusterServiceBroker resource manifest is posted to the Service Catalog API to register a broker, and a controller connects to the specified URL to retrieve the list of services this broker can provision, creating ClusterServiceClass resources for each service type.","[{'highlight': 'The Service Catalog talks to the broker through the OpenServiceBroker API, which is a REST API providing operations for retrieving services, provisioning service instances, updating instances, binding and unbinding instances, and deprovisioning instances.'}, {'highlight': 'A cluster administrator can register one or more external ServiceBrokers in the Service Catalog by posting a ServiceBroker resource manifest to the Service Catalog API.'}, {'highlight': 'Each ClusterServiceClass resource describes a single type of service that can be provisioned, with associated service plans allowing users to choose the level of service they need.'}, {'highlight': 'The OpenServiceBroker API spec is available at https://github.com/openservicebrokerapi/servicebroker.'}, {'highlight': ""The Service Catalog creates a ClusterServiceClass resource for each service this broker can provision after retrieving the list of services from the broker's URL.""}]"
466,555,0,[],"523
Extending Kubernetes with the Kubernetes Service Catalog
database is limited and the underlying storage is a spinning disk, and a “Premium”
plan, with unlimited size and SSD storage). 
LISTING THE AVAILABLE SERVICES IN A CLUSTER
Users of the Kubernetes cluster can retrieve a list of all services that can be provi-
sioned in the cluster with kubectl get serviceclasses, as shown in the following
listing.
$ kubectl get clusterserviceclasses
NAME                KIND
postgres-database   ClusterServiceClass.v1alpha1.servicecatalog.k8s.io
mysql-database      ServiceClass.v1alpha1.servicecatalog.k8s.io
mongodb-database    ServiceClass.v1alpha1.servicecatalog.k8s.io
The listing shows ClusterServiceClasses for services that your imaginary database bro-
ker could provide. You can compare ClusterServiceClasses to StorageClasses, which we
discussed in chapter 6. StorageClasses allow you to select the type of storage you’d like
to use in your pods, while ClusterServiceClasses allow you to select the type of service.
 You can see details of one of the ClusterServiceClasses by retrieving its YAML. An
example is shown in the following listing.
$ kubectl get serviceclass postgres-database -o yaml
apiVersion: servicecatalog.k8s.io/v1alpha1
bindable: true
brokerName: database-broker                     
description: A PostgreSQL database
kind: ClusterServiceClass
metadata:
  name: postgres-database
  ...
planUpdatable: false
plans:
- description: A free (but slow) PostgreSQL instance        
  name: free                                                
  osbFree: true                                             
  ...
- description: A paid (very fast) PostgreSQL instance      
  name: premium                                            
  osbFree: false                                           
  ...
The ClusterServiceClass in the listing contains two plans—a free plan, and a premium
plan. You can see that this ClusterServiceClass is provided by the database-broker
broker.
Listing 18.10
List of ClusterServiceClasses in a cluster
Listing 18.11
A ClusterServiceClass definition
This ClusterServiceClass 
is provided by the 
database-broker.
A free plan for 
this service
A paid plan
 
",[],"[{'entity': 'Kubernetes', 'description': 'Container orchestration system', 'category': 'software'}, {'entity': 'kubectl', 'description': 'Command-line tool for interacting with Kubernetes clusters', 'category': 'command'}, {'entity': 'Service Catalog', 'description': 'API for discovering and using services in a cluster', 'category': 'application'}, {'entity': 'ClusterServiceClass', 'description': 'Definition of a service that can be provisioned in a cluster', 'category': 'database'}, {'entity': 'StorageClasses', 'description': 'Definitions of available storage options for pods', 'category': 'database'}, {'entity': 'pods', 'description': 'Lightweight and portable containers', 'category': 'container'}, {'entity': 'apiVersion', 'description': 'Version of the API used to define a ClusterServiceClass', 'category': 'key-value pair'}, {'entity': 'bindable', 'description': 'Flag indicating whether a service can be bound to a cluster', 'category': 'flag'}, {'entity': 'brokerName', 'description': 'Name of the broker providing a service', 'category': 'identifier'}, {'entity': 'plans', 'description': 'List of available plans for a ClusterServiceClass', 'category': 'list'}, {'entity': 'planUpdatable', 'description': 'Flag indicating whether a plan can be updated', 'category': 'flag'}, {'entity': 'osbFree', 'description': 'Flag indicating whether a plan is free or paid', 'category': 'flag'}]","[{'source_entity': 'osbFree', 'description': 'provides', 'destination_entity': 'plans'}, {'source_entity': 'plans', 'description': 'includes', 'destination_entity': 'bindable'}, {'source_entity': 'plans', 'description': 'allows', 'destination_entity': 'planUpdatable'}, {'source_entity': 'kubectl', 'description': 'manages', 'destination_entity': 'pods'}, {'source_entity': 'Service Catalog', 'description': 'integrates', 'destination_entity': 'Kubernetes'}, {'source_entity': 'Service Catalog', 'description': 'provides', 'destination_entity': 'ClusterServiceClass'}]","['[\n  {\n    ""source"": ""osbFree"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""provides"",\n    ""summary_er"": ""Osbfree provides a platform for creating and managing containers, which are used to deploy and run applications in a pod.""\n  },\n  {\n    ""source"": ""plans"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""has"",\n    ""summary_er"": ""Plans have been made to create and manage a pod, which is a group of one or more containers that can be used to deploy an application.""\n  }\n]', '[\n  {\n    ""source"": ""plans"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""includes"",\n    ""summary_er"": ""Plans include binding to a specific pod, allowing for deployment and management of applications.""\n  }\n]', '[\n  {\n    ""source"": ""plans"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""allows"",\n    ""summary_er"": ""Plans allow pods to be updated dynamically.""\n  }\n]', '[\n  {\n    ""source"": ""kubectl"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""manages"",\n    ""summary_er"": ""Kubernetes command-line tool (kubectl) manages and controls containerized applications and services, including pods.""\n  }\n]', '[\n  {\n    ""source"": ""Service Catalog"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""integrates"",\n    ""summary_er"": ""Service Catalog integrates with pods to provide a unified interface for deploying and managing applications in Kubernetes.""\n  }\n]', '[\n  {\n    ""source"": ""Service Catalog"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""provides"",\n    ""summary_er"": ""The Service Catalog provides a catalog of services to pods, enabling them to discover and use available services.""\n  }\n]']","The Kubernetes Service Catalog allows users to retrieve a list of available services in a cluster using kubectl get serviceclasses. ClusterServiceClasses are similar to StorageClasses, but allow users to select the type of service they want to use. An example is shown for a PostgreSQL database, with two plans: free and premium. The ClusterServiceClass is provided by the database-broker broker.","[{'highlight': 'Kubernetes Service Catalog allows users to retrieve a list of all services that can be provisioned in a cluster with kubectl get serviceclasses.'}, {'highlight': 'ClusterServiceClasses are similar to StorageClasses, but allow users to select the type of service rather than storage.'}, {'highlight': 'Each ClusterServiceClass has multiple plans, such as free and premium plans, which can be selected by users.'}, {'highlight': 'Users can retrieve details of a ClusterServiceClass by running kubectl get serviceclass <serviceclass_name> -o yaml.'}, {'highlight': 'The Kubernetes Service Catalog is provided by the database-broker broker in this example.'}]"
467,556,0,[],"524
CHAPTER 18
Extending Kubernetes
18.2.4 Provisioning and using a service
Let’s imagine the pods you’re deploying need to use a database. You’ve inspected the
list of available ClusterServiceClasses and have chosen to use the free plan of the
postgres-database ClusterServiceClass. 
PROVISIONING A SERVICEINSTANCE
To have the database provisioned for you, all you need to do is create a Service-
Instance resource, as shown in the following listing.
apiVersion: servicecatalog.k8s.io/v1alpha1
kind: ServiceInstance
metadata:
  name: my-postgres-db                     
spec:
  clusterServiceClassName: postgres-database        
  clusterServicePlanName: free                             
  parameters:
    init-db-args: --data-checksums         
You created a ServiceInstance called my-postgres-db (that will be the name of the
resource you’re deploying) and specified the ClusterServiceClass and the chosen
plan. You’re also specifying a parameter, which is specific for each broker and Cluster-
ServiceClass. Let’s imagine you looked up the possible parameters in the broker’s doc-
umentation.
 As soon as you create this resource, the Service Catalog will contact the broker the
ClusterServiceClass belongs to and ask it to provision the service. It will pass on the
chosen ClusterServiceClass and plan names, as well as all the parameters you specified.
 It’s then completely up to the broker to know what to do with this information. In
your case, your database broker will probably spin up a new instance of a PostgreSQL
database somewhere—not necessarily in the same Kubernetes cluster or even in
Kubernetes at all. It could run a Virtual Machine and run the database in there. The
Service Catalog doesn’t care, and neither does the user requesting the service. 
 You can check if the service has been provisioned successfully by inspecting the
status section of the my-postgres-db ServiceInstance you created, as shown in the
following listing.
$ kubectl get instance my-postgres-db -o yaml
apiVersion: servicecatalog.k8s.io/v1alpha1
kind: ServiceInstance
...
status:
  asyncOpInProgress: false
  conditions:
Listing 18.12
A ServiceInstance manifest: database-instance.yaml
Listing 18.13
Inspecting the status of a ServiceInstance
You’re giving this 
Instance a name.
The ServiceClass 
and Plan you want
Additional parameters 
passed to the broker
 
",[],"[{'entity': 'Kubernetes', 'description': 'Container orchestration system', 'category': 'software'}, {'entity': 'Service Catalog', 'description': 'API for provisioning and using services', 'category': 'software'}, {'entity': 'ClusterServiceClass', 'description': 'Resource representing a service class', 'category': 'software'}, {'entity': 'postgres-database', 'description': 'ClusterServiceClass for PostgreSQL database', 'category': 'software'}, {'entity': 'ServiceInstance', 'description': 'Resource representing a provisioned service instance', 'category': 'software'}, {'entity': 'parameters', 'description': 'Additional parameters passed to the broker', 'category': 'process'}, {'entity': '--data-checksums', 'description': 'Parameter for initializing database', 'category': 'command'}, {'entity': 'kubectl', 'description': 'Command-line tool for interacting with Kubernetes', 'category': 'software'}, {'entity': 'get instance', 'description': 'Command for retrieving service instance status', 'category': 'command'}, {'entity': 'yaml', 'description': 'Format for outputting resource information', 'category': 'file format'}, {'entity': 'apiVersion', 'description': 'Field in ServiceInstance manifest', 'category': 'field'}, {'entity': 'kind', 'description': 'Field in ServiceInstance manifest', 'category': 'field'}, {'entity': 'metadata', 'description': 'Section of ServiceInstance manifest', 'category': 'section'}, {'entity': 'spec', 'description': 'Section of ServiceInstance manifest', 'category': 'section'}, {'entity': 'clusterServiceClassName', 'description': 'Field in ServiceInstance manifest', 'category': 'field'}, {'entity': 'clusterServicePlanName', 'description': 'Field in ServiceInstance manifest', 'category': 'field'}]","[{'source_entity': '""metadata""', 'description': 'contains', 'destination_entity': '""yaml""'}, {'source_entity': '""parameters""', 'description': 'are used to', 'destination_entity': '""get instance""'}, {'source_entity': '""kubectl""', 'description': 'is used to', 'destination_entity': '""clusterServicePlanName""'}, {'source_entity': '""spec""', 'description': 'defines the', 'destination_entity': '""apiVersion""'}, {'source_entity': '""postgres-database""', 'description': 'is a type of', 'destination_entity': '""ServiceInstance""'}, {'source_entity': '""--data-checksums""', 'description': 'are used to', 'destination_entity': '""spec""'}, {'source_entity': '""kind""', 'description': 'is a field of', 'destination_entity': '""ServiceInstance""'}, {'source_entity': '""Service Catalog""', 'description': 'provides the', 'destination_entity': '""Kubernetes""'}, {'source_entity': '""ClusterServiceClass""', 'description': 'is a type of', 'destination_entity': '""clusterServiceClassName""'}]","['[\n  {\n    ""source"": ""metadata"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""contains"",\n    ""summary_er"": ""The metadata of a Kubernetes pod contains essential information about the pod, such as its name, namespace, and labels.""\n  },\n  {\n    ""source"": ""yaml"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""describes"",\n    ""summary_er"": ""A YAML file describes the configuration of a Kubernetes pod, including its containers, volumes, and other settings.""\n  }\n]', '[\n  {\n    ""source"": ""parameters"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""are used to"",\n    ""summary_er"": ""Parameters are used to configure a Kubernetes pod, which is an isolated environment for running containerized applications.""\n  },\n  {\n    ""source"": ""get instance"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""and the destination pod"",\n    ""summary_er"": ""The \'get instance\' command retrieves information about a specific pod in a Kubernetes cluster, providing details about its configuration and status.""\n  }\n]', '[\n  {\n    ""source"": ""kubectl"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""is used to"",\n    ""summary_er"": ""\\""kubectl\\"" is a command-line tool that interacts with Kubernetes clusters, and it\'s used to manage pods within those clusters.""\n  },\n  {\n    ""source"": ""clusterServicePlanName"",\n    ""destination"": ""service plan"",\n    ""relation_description"": ""is associated with"",\n    ""summary_er"": ""A cluster service plan name is a unique identifier for a service plan in a Kubernetes cluster, which defines the configuration and resources allocated to it.""\n  }\n]', '[\n  {\n    ""source"": ""spec"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""defines the configuration for a Kubernetes Pod"",\n    ""summary_er"": ""The spec field in a Kubernetes deployment defines the configuration for a pod, including its container(s), volume(s), and other settings.""\n  },\n  {\n    ""source"": ""apiVersion"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""specifies the API version of the Kubernetes object"",\n    ""summary_er"": ""The apiVersion field in a Kubernetes deployment specifies the API version of the pod, which determines the format and structure of the object.""\n  }\n]', '[\n  {\n    ""source"": ""postgres-database"",\n    ""destination"": ""ServiceInstance"",\n    ""relation_description"": ""is a type of"",\n    ""summary_er"": ""Postgres database is an instance of Service, providing data storage and management capabilities.""\n  }\n]', '[\n  {\n    ""source"": ""Data Checksums"",\n    ""destination"": ""Pod Spec"",\n    ""relation_description"": ""are used to"",\n    ""summary_er"": ""Data checksums are used to verify the integrity of pod spec, ensuring that it has not been tampered with or corrupted during transmission.""\n  }\n]', '[\n  {\n    ""source"": ""Kind"",\n    ""destination"": ""Pod"",\n    ""relation_description"": ""is a field of"",\n    ""summary_er"": ""A Kind is a metadata attribute that categorizes a Pod, providing context for its purpose and behavior.""\n  },\n  {\n    ""source"": ""Pod"",\n    ""destination"": ""ServiceInstance"",\n    ""relation_description"": ""is related to"",\n    ""summary_er"": ""A Pod is a logical host for one or more containers, which can be part of a ServiceInstance, enabling scalable and reliable service delivery.""\n  }\n]', '[\n  {\n    ""source"": ""Service Catalog"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""provides"",\n    ""summary_er"": ""The Service Catalog in Kubernetes offers a catalog of services that provides to pods, enabling them to access and utilize various resources.""\n  }\n]', '[\n  {\n    ""source"": ""ClusterServiceClass"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""is a type of"",\n    ""summary_er"": ""A ClusterServiceClass is a type of pod, which is a containerized application in Kubernetes.""\n  }\n]']","To provision a service instance, create a Service-Instance resource with ClusterServiceClass and plan specified. The Service Catalog will contact the broker, passing on chosen class, plan, and parameters. The broker then provisions the service according to its configuration, potentially spinning up a new instance of a database or running it in a VM. Successful provisioning can be checked by inspecting the status section of the created ServiceInstance.","[{'highlight': 'To have the database provisioned for you, all you need to do is create a Service-Instance resource, as shown in the following listing.'}, {'highlight': 'You created a ServiceInstance called my-postgres-db and specified the ClusterServiceClass and the chosen plan.'}, {'highlight': 'The Service Catalog will contact the broker the ClusterServiceClass belongs to and ask it to provision the service.'}, {'highlight': 'You can check if the service has been provisioned successfully by inspecting the status section of the my-postgres-db ServiceInstance you created.'}, {'highlight': 'A ServiceInstance manifest: database-instance.yaml'}]"
468,557,0,[],"525
Extending Kubernetes with the Kubernetes Service Catalog
  - lastTransitionTime: 2017-05-17T13:57:22Z
    message: The instance was provisioned successfully    
    reason: ProvisionedSuccessfully                       
    status: ""True""
    type: Ready                   
A database instance is now running somewhere, but how do you use it in your pods?
To do that, you need to bind it.
BINDING A SERVICEINSTANCE
To use a provisioned ServiceInstance in your pods, you create a ServiceBinding
resource, as shown in the following listing.
apiVersion: servicecatalog.k8s.io/v1alpha1
kind: ServiceBinding
metadata:
  name: my-postgres-db-binding
spec:
  instanceRef:                          
    name: my-postgres-db                
  secretName: postgres-secret           
The listing shows that you’re defining a ServiceBinding resource called my-postgres-
db-binding, in which you’re referencing the my-postgres-db service instance you
created earlier. You’re also specifying a name of a Secret. You want the Service Catalog
to put all the necessary credentials for accessing the service instance into a Secret
called postgres-secret. But where are you binding the ServiceInstance to your pods?
Nowhere, actually.
 Currently, the Service Catalog doesn’t yet make it possible to inject pods with the
ServiceInstance’s credentials. This will be possible when a new Kubernetes feature
called PodPresets is available. Until then, you can choose a name for the Secret
where you want the credentials to be stored in and mount that Secret into your pods
manually.
 When you submit the ServiceBinding resource from the previous listing to the Ser-
vice Catalog API server, the controller will contact the Database broker once again
and create a binding for the ServiceInstance you provisioned earlier. The broker
responds with a list of credentials and other data necessary for connecting to the data-
base. The Service Catalog creates a new Secret with the name you specified in the
ServiceBinding resource and stores all that data in the Secret. 
USING THE NEWLY CREATED SECRET IN CLIENT PODS
The Secret created by the Service Catalog system can be mounted into pods, so they
can read its contents and use them to connect to the provisioned service instance (a
PostgreSQL database in the example). The Secret could look like the one in the fol-
lowing listing.
Listing 18.14
A ServiceBinding: my-postgres-db-binding.yaml
The database was 
provisioned successfully.
It’s ready to be used.
You’re referencing the 
instance you created 
earlier.
You’d like the credentials 
for accessing the service 
stored in this Secret.
 
",[],"[{'entity': 'Kubernetes Service Catalog', 'description': 'A Kubernetes feature that allows users to provision and use external services', 'category': 'software'}, {'entity': 'ServiceInstance', 'description': 'A resource that represents a provisioned service', 'category': 'software'}, {'entity': 'ServiceBinding', 'description': 'A resource that binds a ServiceInstance to a pod', 'category': 'software'}, {'entity': 'apiVersion', 'description': 'The version of the Kubernetes API being used', 'category': 'software'}, {'entity': 'kind', 'description': 'The type of resource being defined (e.g. ServiceBinding)', 'category': 'software'}, {'entity': 'metadata', 'description': 'A field that contains metadata about the resource', 'category': 'software'}, {'entity': 'name', 'description': 'The name of the ServiceBinding resource', 'category': 'software'}, {'entity': 'instanceRef', 'description': 'A reference to the ServiceInstance being bound', 'category': 'software'}, {'entity': 'secretName', 'description': 'The name of the Secret that will store the credentials for accessing the service', 'category': 'software'}, {'entity': 'Service Catalog', 'description': 'A system that manages the provision and use of external services', 'category': 'software'}, {'entity': 'Database broker', 'description': 'A component that interacts with the Database service to provision and bind ServiceInstances', 'category': 'software'}, {'entity': 'PodPresets', 'description': 'A new Kubernetes feature that will allow pods to be pre-configured with credentials for accessing services', 'category': 'software'}, {'entity': 'Secret', 'description': 'A resource that stores sensitive information (e.g. credentials) for accessing a service', 'category': 'software'}, {'entity': 'PostgreSQL database', 'description': 'An external service being provisioned and used by the Service Catalog', 'category': 'database'}]","[{'source_entity': 'Kubernetes Service Catalog', 'description': 'provides a catalog of services to users', 'destination_entity': 'Service Catalog'}, {'source_entity': 'Database broker', 'description': 'acts as an intermediary between services and databases', 'destination_entity': 'Database broker'}, {'source_entity': 'name', 'description': 'is a unique identifier for a service instance', 'destination_entity': 'ServiceInstance'}, {'source_entity': 'ServiceBinding', 'description': 'binds a service to an application', 'destination_entity': 'Service Catalog'}, {'source_entity': 'Service Catalog', 'description': 'catalogs and manages services for users', 'destination_entity': 'ServiceInstance'}, {'source_entity': 'ServiceInstance', 'description': 'represents a specific instance of a service', 'destination_entity': 'instanceRef'}, {'source_entity': 'apiVersion', 'description': 'specifies the API version used by a resource', 'destination_entity': 'metadata'}, {'source_entity': 'metadata', 'description': 'contains metadata about a resource', 'destination_entity': 'secretName'}, {'source_entity': 'secretName', 'description': 'references the name of a secret', 'destination_entity': 'Secret'}, {'source_entity': 'kind', 'description': 'specifies the type of resource being referenced', 'destination_entity': 'PodPresets'}, {'source_entity': 'PodPresets', 'description': 'defines a set of pre-configured pods', 'destination_entity': 'Secret'}, {'source_entity': 'PostgreSQL database', 'description': 'is a type of relational database', 'destination_entity': 'Database broker'}]","['[\n  {\n    ""source"": ""Kubernetes Service Catalog"",\n    ""destination"": ""Pod"",\n    ""relation_description"": ""provides a catalog of services to users"",\n    ""summary_er"": ""The Kubernetes Service Catalog provides a centralized repository of services that can be consumed by users, making it easier to discover and utilize available resources.""\n  }\n]', '[\n  {\n    ""source"": ""Database broker"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""acts as an intermediary between services and databases"",\n    ""summary_er"": ""The database broker acts as a mediator between services and databases, facilitating communication and data exchange.""\n  }\n]', '[\n  {\n    ""source"": ""ServiceInstance"",\n    ""destination"": ""Pod"",\n    ""relation_description"": ""is a unique identifier for a service instance"",\n    ""summary_er"": ""A ServiceInstance is identified by a unique identifier, which is associated with a Pod in Kubernetes.""\n  }\n]', '[\n  {\n    ""source"": ""ServiceBinding"",\n    ""destination"": ""Pod"",\n    ""relation_description"": ""binds a service to an application"",\n    ""summary_er"": ""ServiceBinding binds a service to a pod, enabling communication between them.""\n  },\n  {\n    ""source"": ""Service Catalog"",\n    ""destination"": ""Pod"",\n    ""relation_description"": ""provides a catalog of services"",\n    ""summary_er"": ""Service Catalog provides a list of available services that can be bound to a pod for use.""\n  }\n]', '[\n  {\n    ""source"": ""Service Catalog"",\n    ""destination"": ""Pod"",\n    ""relation_description"": ""catalogs and manages services for users"",\n    ""summary_er"": ""The Service Catalog provides a centralized interface to manage and catalog services, making it easier for users to discover and utilize available resources.""\n  }\n]', '[\n  {\n    ""source"": ""ServiceInstance"",\n    ""destination"": ""Pod"",\n    ""relation_description"": ""instanceRef"",\n    ""summary_er"": ""A ServiceInstance represents a specific instance of a service, referencing a Pod.""\n  }\n]', '[\n  {\n    ""source"": ""apiVersion"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""specifies the API version used by a resource"",\n    ""summary_er"": ""API version specifies the version of Kubernetes API used by a pod.""\n  }\n]', '[\n  {\n    ""source"": ""metadata"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""contains metadata about a resource"",\n    ""summary_er"": ""The pod contains metadata that provides information about itself, such as its name and labels.""\n  },\n  {\n    ""source"": ""secretName"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""specifies the name of a secret"",\n    ""summary_er"": ""A secret is referenced by its name in the pod\'s configuration, providing access to sensitive data.""\n  }\n]', '[\n  {\n    ""source"": ""Secret"",\n    ""destination"": ""Pod"",\n    ""relation_description"": ""references"",\n    ""summary_er"": ""A Secret in Kubernetes references the name of a Pod, allowing the Pod to access sensitive information stored in the Secret.""\n  }\n]', '[\n  {\n    ""source"": ""kind"",\n    ""destination"": ""PodPresets"",\n    ""relation_description"": ""specifies the type of resource being referenced"",\n    ""summary_er"": ""The kind field specifies the type of resource, which in this case is PodPresets, indicating a set of predefined pod configurations.""\n  }\n]', '[\n  {\n    ""source"": ""PodPresets"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""defines a set of pre-configured pods"",\n    ""summary_er"": ""PodPresets defines a collection of pre-configured pod templates, providing a standardized way to deploy applications in Kubernetes.""\n  },\n  {\n    ""source"": ""Secret"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""accesses"",\n    ""summary_er"": ""A Secret provides sensitive information, such as credentials or API keys, that can be accessed by a pod for authentication and authorization purposes.""\n  }\n]', '[\n  {\n    ""source"": ""PostgreSQL database"",\n    ""destination"": ""Database broker"",\n    ""relation_description"": ""is a type of relational database"",\n    ""summary_er"": ""The PostgreSQL database is a type of relational database that serves as a data storage and management system, which the Database broker utilizes to manage and interact with.""\n  }\n]']","A Kubernetes Service Catalog is extended by binding a provisioned ServiceInstance to pods using a ServiceBinding resource. A Secret is created with necessary credentials, which can be manually mounted into pods for access to the ServiceInstance.","[{'highlight': 'A ServiceBinding resource is created to use a provisioned ServiceInstance in pods, referencing the instance and specifying a name for a Secret where credentials will be stored.'}, {'highlight': 'The Service Catalog creates a new Secret with the specified name and stores all data necessary for connecting to the database in it.'}, {'highlight': 'The newly created Secret can be mounted into pods, allowing them to read its contents and connect to the provisioned service instance.'}, {'highlight': ""Currently, the Service Catalog does not make it possible to inject pods with the ServiceInstance's credentials, but this will be possible when PodPresets is available.""}, {'highlight': 'A Secret created by the Service Catalog system can store all data necessary for connecting to a provisioned service instance, such as database credentials.'}]"
469,558,0,[],"526
CHAPTER 18
Extending Kubernetes
$ kubectl get secret postgres-secret -o yaml
apiVersion: v1
data:
  host: <base64-encoded hostname of the database>     
  username: <base64-encoded username>                 
  password: <base64-encoded password>                 
kind: Secret
metadata:
  name: postgres-secret
  namespace: default
  ...
type: Opaque
Because you can choose the name of the Secret yourself, you can deploy pods before
provisioning or binding the service. As you learned in chapter 7, the pods won’t be
started until such a Secret exists. 
 If necessary, multiple bindings can be created for different pods. The service bro-
ker can choose to use the same set of credentials in every binding, but it’s better to
create a new set of credentials for every binding instance. This way, pods can be pre-
vented from using the service by deleting the ServiceBinding resource.
18.2.5 Unbinding and deprovisioning
Once you no longer need a ServiceBinding, you can delete it the way you delete other
resources:
$ kubectl delete servicebinding my-postgres-db-binding
servicebinding ""my-postgres-db-binding"" deleted
When you do this, the Service Catalog controller will delete the Secret and call the bro-
ker to perform an unbinding operation. The service instance (in your case a PostgreSQL
database) is still running. You can therefore create a new ServiceBinding if you want.
 But if you don’t need the database instance anymore, you should delete the Service-
Instance resource also:
$ kubectl delete serviceinstance my-postgres-db
serviceinstance ""my-postgres-db "" deleted
Deleting the ServiceInstance resource causes the Service Catalog to perform a depro-
visioning operation on the service broker. Again, exactly what that means is up to the
service broker, but in your case, the broker should shut down the PostgreSQL data-
base instance that it created when we provisioned the service instance.
18.2.6 Understanding what the Service Catalog brings
As you’ve learned, the Service Catalog enables service providers make it possible to
expose those services in any Kubernetes cluster by registering the broker in that cluster.
Listing 18.15
A Secret holding the credentials for connecting to the service instance
This is what the pod 
should use to connect to 
the database service.
 
",[],"[{'entity': 'kubectl', 'description': 'command-line tool for managing Kubernetes clusters', 'category': 'software'}, {'entity': 'get secret', 'description': 'command to retrieve a Secret resource from a Kubernetes cluster', 'category': 'software'}, {'entity': 'postgres-secret', 'description': 'Secret resource holding database credentials', 'category': 'database'}, {'entity': 'apiVersion', 'description': 'API version of the Secret resource', 'category': 'software'}, {'entity': 'v1', 'description': 'API version of the Secret resource', 'category': 'software'}, {'entity': 'data', 'description': 'field containing base64-encoded database credentials', 'category': 'database'}, {'entity': 'host', 'description': 'field containing hostname of the database service', 'category': 'database'}, {'entity': 'username', 'description': 'field containing username for database connection', 'category': 'database'}, {'entity': 'password', 'description': 'field containing password for database connection', 'category': 'database'}, {'entity': 'kind', 'description': 'type of resource (Secret)', 'category': 'software'}, {'entity': 'metadata', 'description': 'field containing metadata about the Secret resource', 'category': 'software'}, {'entity': 'name', 'description': 'field containing name of the Secret resource', 'category': 'database'}, {'entity': 'namespace', 'description': 'field containing namespace of the Secret resource', 'category': 'database'}, {'entity': 'type', 'description': 'type of Secret resource (Opaque)', 'category': 'software'}, {'entity': 'ServiceBinding', 'description': 'resource representing a binding between a service and a pod', 'category': 'application'}, {'entity': 'servicebroker', 'description': 'component responsible for managing service instances', 'category': 'software'}, {'entity': 'ServiceInstance', 'description': 'resource representing a service instance (e.g. PostgreSQL database)', 'category': 'database'}, {'entity': 'kubectl delete', 'description': 'command to delete a resource from a Kubernetes cluster', 'category': 'software'}, {'entity': 'servicebinding', 'description': 'resource representing a binding between a service and a pod', 'category': 'application'}, {'entity': 'Secret', 'description': 'resource holding sensitive data (e.g. database credentials)', 'category': 'database'}]","[{'source_entity': '""ServiceInstance""', 'description': 'binds to', 'destination_entity': '""ServiceBinding""'}, {'source_entity': '""kubectl""', 'description': 'uses to get secret', 'destination_entity': '""get secret""'}, {'source_entity': '""kubectl delete""', 'description': 'deletes a service binding', 'destination_entity': '""ServiceBinding""'}, {'source_entity': '""servicebroker""', 'description': 'provides a service instance', 'destination_entity': '""ServiceInstance""'}, {'source_entity': '""kubectl delete""', 'description': 'deletes a secret', 'destination_entity': '""postgres-secret""'}, {'source_entity': '""kubectl""', 'description': 'uses to get metadata', 'destination_entity': '""metadata""'}, {'source_entity': '""ServiceInstance""', 'description': 'has a namespace', 'destination_entity': '""namespace""'}, {'source_entity': '""ServiceBinding""', 'description': 'has a type', 'destination_entity': '""type""'}, {'source_entity': '""postgres-secret""', 'description': 'is a secret', 'destination_entity': '""Secret""'}, {'source_entity': '""kubectl""', 'description': 'uses to get api version', 'destination_entity': '""apiVersion""'}, {'source_entity': '""ServiceBinding""', 'description': 'has a username', 'destination_entity': '""username""'}, {'source_entity': '""postgres-secret""', 'description': 'is bound to a service instance', 'destination_entity': '""ServiceInstance""'}]","['[\n  {\n    ""source"": ""ServiceInstance"",\n    ""destination"": ""Pod"",\n    ""relation_description"": ""binds to"",\n    ""summary_er"": ""A ServiceInstance binds a service to a Pod, allowing them to communicate with each other.""\n  },\n  {\n    ""source"": ""ServiceBinding"",\n    ""destination"": ""ServiceInstance"",\n    ""relation_description"": ""relates to"",\n    ""summary_er"": ""A ServiceBinding relates a ServiceInstance to a specific instance of a service, enabling configuration and management.""\n  }\n]', '[\n  {\n    ""source"": ""kubectl"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""uses to get secret"",\n    ""summary_er"": ""Kubectl uses \'get secret\' command to retrieve secrets from a pod, allowing for secure access and management of sensitive data.""\n  }\n]', '[\n  {\n    ""source"": ""kubectl"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""deletes a service binding"",\n    ""summary_er"": ""Kubernetes command \'kubectl delete\' removes a service binding associated with a pod, effectively deleting the connection between the two.""\n  }\n]', '[\n  {\n    ""source"": ""servicebroker"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""provides a service instance"",\n    ""summary_er"": ""The Service Broker provides a service instance to a Pod, enabling it to access and utilize external services within the Kubernetes cluster.""\n  }\n]', '[\n  {\n    ""source"": ""kubectl"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""deletes a secret"",\n    ""summary_er"": ""The Kubernetes command-line tool (kubectl) deletes a secret, specifically \'postgres-secret\', which is associated with a pod.""\n  }\n]', '[\n  {\n    ""source"": ""kubectl"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""uses to get metadata"",\n    ""summary_er"": ""Kubectl uses metadata to retrieve information about a pod, such as its name, namespace, and status.""\n  }\n]', '[\n  {\n    ""source"": ""ServiceInstance"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""has a namespace"",\n    ""summary_er"": ""A ServiceInstance in Kubernetes has a namespace associated with it, which defines the scope and isolation of the service.""\n  }\n]', '[\n  {\n    ""source"": ""ServiceBinding"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""has a type"",\n    ""summary_er"": ""A ServiceBinding in Kubernetes is associated with a specific type of pod, which defines its characteristics and functionality.""\n  }\n]', '[\n  {\n    ""source"": ""postgres-secret"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""is a secret"",\n    ""summary_er"": ""Postgres secret is a sensitive data stored as a Kubernetes Secret, accessible by pods for database authentication.""\n  }\n]', '[\n  {\n    ""source"": ""kubectl"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""uses to get api version"",\n    ""summary_er"": ""kubectl uses API version to interact with pods, retrieving their metadata and configuration.""\n  }\n]', '[\n  {\n    ""source"": ""ServiceBinding"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""has a username"",\n    ""summary_er"": ""A ServiceBinding in Kubernetes has a username associated with it, which is used to authenticate and authorize access to a pod.""\n  }\n]', '[\n  {\n    ""source"": ""postgres-secret"",\n    ""destination"": ""ServiceInstance"",\n    ""relation_description"": ""is bound to"",\n    ""summary_er"": ""A PostgreSQL secret is bound to a service instance, ensuring secure access and configuration.""\n  }\n]']","The Service Catalog allows service providers to expose services in any Kubernetes cluster by registering a broker. A Secret can be created with credentials for connecting to a service instance, and can be used by multiple pods. Once no longer needed, the ServiceBinding can be deleted, which will delete the Secret and perform an unbinding operation on the service broker. Additionally, if not needed, the ServiceInstance resource should also be deleted to deprovision the service.","[{'highlight': 'You can deploy pods before provisioning or binding the service, as long as a Secret exists.'}]"
