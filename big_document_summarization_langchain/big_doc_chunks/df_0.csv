,page,img_cnt,img_npy_lst,text,tables,entities,relationships,summary_rel,summary,highlights
0,89,0,[],"57
Introducing pods
 Therefore, you need to run each process in its own container. That’s how Docker
and Kubernetes are meant to be used. 
3.1.2
Understanding pods
Because you’re not supposed to group multiple processes into a single container, it’s
obvious you need another higher-level construct that will allow you to bind containers
together and manage them as a single unit. This is the reasoning behind pods. 
 A pod of containers allows you to run closely related processes together and pro-
vide them with (almost) the same environment as if they were all running in a single
container, while keeping them somewhat isolated. This way, you get the best of both
worlds. You can take advantage of all the features containers provide, while at the
same time giving the processes the illusion of running together. 
UNDERSTANDING THE PARTIAL ISOLATION BETWEEN CONTAINERS OF THE SAME POD
In the previous chapter, you learned that containers are completely isolated from
each other, but now you see that you want to isolate groups of containers instead of
individual ones. You want containers inside each group to share certain resources,
although not all, so that they’re not fully isolated. Kubernetes achieves this by config-
uring Docker to have all containers of a pod share the same set of Linux namespaces
instead of each container having its own set. 
 Because all containers of a pod run under the same Network and UTS namespaces
(we’re talking about Linux namespaces here), they all share the same hostname and
network interfaces. Similarly, all containers of a pod run under the same IPC namespace
and can communicate through IPC. In the latest Kubernetes and Docker versions, they
can also share the same PID namespace, but that feature isn’t enabled by default. 
NOTE
When containers of the same pod use separate PID namespaces, you
only see the container’s own processes when running ps aux in the container.
But when it comes to the filesystem, things are a little different. Because most of the
container’s filesystem comes from the container image, by default, the filesystem of
each container is fully isolated from other containers. However, it’s possible to have
them share file directories using a Kubernetes concept called a Volume, which we’ll
talk about in chapter 6.
UNDERSTANDING HOW CONTAINERS SHARE THE SAME IP AND PORT SPACE
One thing to stress here is that because containers in a pod run in the same Network
namespace, they share the same IP address and port space. This means processes run-
ning in containers of the same pod need to take care not to bind to the same port
numbers or they’ll run into port conflicts. But this only concerns containers in the
same pod. Containers of different pods can never run into port conflicts, because
each pod has a separate port space. All the containers in a pod also have the same
loopback network interface, so a container can communicate with other containers in
the same pod through localhost.
 
",[],"[{'entity': 'Docker', 'description': 'Containerization platform', 'category': 'software'}, {'entity': 'Kubernetes', 'description': 'Container orchestration system', 'category': 'software'}, {'entity': 'Pods', 'description': 'Group of containers that share resources and run as a single unit', 'category': 'application'}, {'entity': 'Containers', 'description': 'Isolated execution environment for processes', 'category': 'container'}, {'entity': 'Linux namespaces', 'description': 'Resource isolation mechanism in Linux', 'category': 'process'}, {'entity': 'Network namespace', 'description': 'Shared network resources among containers in a pod', 'category': 'network'}, {'entity': 'UTS namespace', 'description': 'Shared hostname and network interfaces among containers in a pod', 'category': 'network'}, {'entity': 'IPC namespace', 'description': 'Shared inter-process communication resources among containers in a pod', 'category': 'process'}, {'entity': 'PID namespace', 'description': 'Shared process ID space among containers in a pod', 'category': 'process'}, {'entity': 'Volume', 'description': 'Kubernetes concept for sharing file directories among containers', 'category': 'database'}, {'entity': 'IP address', 'description': 'Shared IP address among containers in a pod', 'category': 'network'}, {'entity': 'Port space', 'description': 'Shared port numbers among containers in a pod', 'category': 'network'}]","[{'source_entity': '""Network namespace""', 'description': 'manages', 'destination_entity': '""Linux namespaces""'}, {'source_entity': '""Network namespace""', 'description': 'allocates', 'destination_entity': '""Port space""'}, {'source_entity': '""UTS namespace""', 'description': 'manages', 'destination_entity': '""Linux namespaces""'}, {'source_entity': '""Kubernetes""', 'description': 'orchestrates', 'destination_entity': '""Pods""'}, {'source_entity': '""Docker""', 'description': 'runs', 'destination_entity': '""Containers""'}, {'source_entity': '""Kubernetes""', 'description': 'manages', 'destination_entity': '""Volume""'}, {'source_entity': '""PID namespace""', 'description': 'manages', 'destination_entity': '""Linux namespaces""'}, {'source_entity': '""IPC namespace""', 'description': 'manages', 'destination_entity': '""Linux namespaces""'}]","['[\n  {\n    ""source"": ""Network namespace"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""manages"",\n    ""summary_er"": ""A network namespace manages a pod by providing isolation and resource management for its network stack.""\n  }\n]', '[\n  {\n    ""source"": ""Network namespace"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""allocates"",\n    ""summary_er"": ""The network namespace allocates resources to a pod, enabling communication and resource sharing between them.""\n  },\n  {\n    ""source"": ""Port space"",\n    ""destination"": ""pod"",\n    ""relation_description"": """",\n    ""summary_er"": """"\n  }\n]', '[\n  {\n    ""source"": ""UTS namespace"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""manages"",\n    ""summary_er"": ""The UTS namespace manages a Linux pod, providing isolation and resource control.""\n  }\n]', '[\n  {\n    ""source"": ""Kubernetes"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""orchestrates"",\n    ""summary_er"": ""Kubernetes manages and coordinates the execution of pods, ensuring efficient resource utilization and scalability.""\n  }\n]', '[\n  {\n    ""source"": ""Docker"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""runs"",\n    ""summary_er"": ""Docker runs containers, which are lightweight and portable packages of software that include everything needed to run an application.""\n  }\n]', '[\n  {\n    ""source"": ""Kubernetes"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""manages"",\n    ""summary_er"": ""Kubernetes manages pods, ensuring efficient resource allocation and scaling.""\n  },\n  {\n    ""source"": ""Kubernetes"",\n    ""destination"": ""Volume"",\n    ""relation_description"": ""uses"",\n    ""summary_er"": ""Kubernetes utilizes volumes to persist data across pod restarts or deletion.""\n  }\n]', '[\n  {\n    ""source"": ""PID namespace"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""manages"",\n    ""summary_er"": ""The PID namespace in Linux manages a pod, controlling its process ID space and ensuring isolation between processes.""\n  }\n]', '[\n  {\n    ""source"": ""IPC namespace"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""manages"",\n    ""summary_er"": ""The IPC namespace manages a pod, controlling how processes within it interact with each other.""\n  },\n  {\n    ""source"": ""Linux namespaces"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""manages"",\n    ""summary_er"": ""A Linux namespace manages a pod, providing isolation and resource control for its contained processes.""\n  }\n]']","A pod of containers allows you to run closely related processes together, providing them with almost the same environment as a single container, while keeping them somewhat isolated. Containers within a pod share certain resources like network interfaces and IPC namespaces, but have fully isolated filesystems unless shared using a Kubernetes Volume concept.","[{'highlight': 'A pod of containers allows you to run closely related processes together and provide them with (almost) the same environment as if they were all running in a single container, while keeping them somewhat isolated.'}, {'highlight': 'Kubernetes achieves partial isolation between containers of the same pod by configuring Docker to have all containers share the same set of Linux namespaces instead of each container having its own set.'}, {'highlight': ""Containers in a pod run in the same Network namespace, sharing the same IP address and port space, which means processes running in containers of the same pod need to take care not to bind to the same port numbers or they'll run into port conflicts.""}, {'highlight': 'Each pod has a separate port space from other pods, so containers of different pods can never run into port conflicts.'}, {'highlight': 'Containers in a pod share the same hostname and network interfaces, as well as the ability to communicate through IPC, but have fully isolated filesystems by default.'}]"
1,90,0,[],"58
CHAPTER 3
Pods: running containers in Kubernetes
INTRODUCING THE FLAT INTER-POD NETWORK
All pods in a Kubernetes cluster reside in a single flat, shared, network-address space
(shown in figure 3.2), which means every pod can access every other pod at the other
pod’s IP address. No NAT (Network Address Translation) gateways exist between them.
When two pods send network packets between each other, they’ll each see the actual
IP address of the other as the source IP in the packet.
Consequently, communication between pods is always simple. It doesn’t matter if two
pods are scheduled onto a single or onto different worker nodes; in both cases the
containers inside those pods can communicate with each other across the flat NAT-
less network, much like computers on a local area network (LAN), regardless of the
actual inter-node network topology. Like a computer on a LAN, each pod gets its own
IP address and is accessible from all other pods through this network established spe-
cifically for pods. This is usually achieved through an additional software-defined net-
work layered on top of the actual network.
 To sum up what’s been covered in this section: pods are logical hosts and behave
much like physical hosts or VMs in the non-container world. Processes running in the
same pod are like processes running on the same physical or virtual machine, except
that each process is encapsulated in a container. 
3.1.3
Organizing containers across pods properly
You should think of pods as separate machines, but where each one hosts only a cer-
tain app. Unlike the old days, when we used to cram all sorts of apps onto the same
host, we don’t do that with pods. Because pods are relatively lightweight, you can have
as many as you need without incurring almost any overhead. Instead of stuffing every-
thing into a single pod, you should organize apps into multiple pods, where each one
contains only tightly related components or processes.
Node 1
Pod A
IP: 10.1.1.6
Container 1
Container 2
Pod B
IP: 10.1.1.7
Container 1
Container 2
Node 2
Flat network
Pod C
IP: 10.1.2.5
Container 1
Container 2
Pod D
IP: 10.1.2.7
Container 1
Container 2
Figure 3.2
Each pod gets a routable IP address and all other pods see the pod under 
that IP address.
 
","[  Container 1 Container 1\nContainer 2 Container 2\nPod A Pod B\nIP: 10.1.1.6 IP: 10.1.1.7  \
0                                                                                            
1                                       Flat network                                         

     Col1  \
0  Node 1   
1    None   

  Container 1 Container 1\nContainer 2 Container 2\nPod C Pod D\nIP: 10.1.2.5 IP: 10.1.2.7  \
0                                               None                                         
1                                               None                                         

     Col3  Col4  
0  Node 2        
1    None  None  ]","[{'entity': 'Pods', 'description': 'logical hosts that behave much like physical hosts or VMs', 'category': 'container'}, {'entity': 'Kubernetes', 'description': 'cluster management system', 'category': 'software'}, {'entity': 'Flat inter-pod network', 'description': 'single flat, shared network-address space for all pods', 'category': 'network'}, {'entity': 'Pod', 'description': 'logical host that hosts a certain app', 'category': 'container'}, {'entity': 'Container', 'description': 'lightweight process that runs an application', 'category': 'process'}, {'entity': 'IP address', 'description': 'unique identifier for each pod', 'category': 'network'}, {'entity': 'NAT (Network Address Translation)', 'description': 'gateway between pods that translates IP addresses', 'category': 'software'}, {'entity': 'Worker nodes', 'description': 'physical or virtual machines that run pods', 'category': 'hardware'}, {'entity': 'LAN (Local Area Network)', 'description': 'network for computers on the same physical location', 'category': 'network'}, {'entity': 'Software-defined network', 'description': 'additional network layered on top of actual network', 'category': 'software'}, {'entity': 'VM (Virtual Machine)', 'description': 'virtualized environment for running operating systems', 'category': 'hardware'}, {'entity': 'Process', 'description': 'instance of a program that is being executed', 'category': 'process'}, {'entity': 'App', 'description': 'application or service that runs in a pod', 'category': 'software'}, {'entity': 'Node', 'description': 'physical or virtual machine that runs pods', 'category': 'hardware'}, {'entity': 'Container 1', 'description': 'instance of a container running an application', 'category': 'process'}, {'entity': 'Container 2', 'description': 'instance of a container running an application', 'category': 'process'}]","[{'source_entity': '""Kubernetes""', 'description': 'manages', 'destination_entity': '""Pods""'}, {'source_entity': '""Kubernetes""', 'description': 'orchestrates', 'destination_entity': '""Worker nodes""'}, {'source_entity': '""Container 1""', 'description': 'runs on top of', 'destination_entity': '""VM (Virtual Machine)""'}, {'source_entity': '""Container 2""', 'description': 'uses', 'destination_entity': '""Flat inter-pod network""'}, {'source_entity': '""Worker nodes""', 'description': 'hosts', 'destination_entity': '""Pods""'}, {'source_entity': '""Node""', 'description': 'provides', 'destination_entity': '""IP address""'}, {'source_entity': '""Container 1""', 'description': 'communicates with', 'destination_entity': '""Container 2""'}, {'source_entity': '""Pods""', 'description': 'consists of', 'destination_entity': '""Containers""'}, {'source_entity': '""Kubernetes""', 'description': 'uses', 'destination_entity': '""Software-defined network""'}, {'source_entity': '""Process""', 'description': 'runs within', 'destination_entity': '""Container 1""'}, {'source_entity': '""NAT (Network Address Translation)""', 'description': 'provides', 'destination_entity': '""LAN (Local Area Network)""'}]","['[\n  {\n    ""source"": ""Kubernetes"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""manages"",\n    ""summary_er"": ""Kubernetes manages pods, ensuring efficient resource allocation and scaling for containerized applications.""\n  }\n]', '[\n  {\n    ""source"": ""Kubernetes"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""orchestrates"",\n    ""summary_er"": ""Kubernetes manages and orchestrates containerized applications, including pods, which are the basic execution unit in a Kubernetes cluster.""\n  }\n]', '[\n    {\n        ""source"": ""Container 1"",\n        ""destination"": ""Pod"",\n        ""relation_description"": ""runs on top of"",\n        ""summary_er"": ""A container executes on top of a pod, utilizing its resources and sharing its network identity.""\n    }\n]', '[\n    {\n        ""source"": ""Container 2"",\n        ""destination"": ""Pod"",\n        ""relation_description"": ""uses"",\n        ""summary_er"": ""A container within a pod utilizes shared resources and networking.""\n    },\n    {\n        ""source"": ""Pod"",\n        ""destination"": ""Flat inter-pod network"",\n        ""relation_description"": ""networking"",\n        ""summary_er"": ""A pod shares a flat network with other pods, enabling communication between containers.""\n    }\n]', '[\n  {\n    ""source"": ""Worker nodes"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""hosts"",\n    ""summary_er"": ""Worker nodes host pods, providing a physical environment for containers to run.""\n  }\n]', '[\n  {\n    ""source"": ""Node"",\n    ""destination"": ""Pod"",\n    ""relation_description"": ""provides"",\n    ""summary_er"": ""A Node in Kubernetes provides a Pod with resources such as CPU and memory.""\n  },\n  {\n    ""source"": ""Pod"",\n    ""destination"": ""IP address"",\n    ""relation_description"": ""has"",\n    ""summary_er"": ""A Pod in Kubernetes has an IP address assigned to it for communication purposes.""\n  }\n]', '[\n    {\n        ""source"": ""Container 1"",\n        ""destination"": ""Container 2"",\n        ""relation_description"": ""communicates with"",\n        ""summary_er"": ""Container 1 communicates with Container 2, indicating a data exchange or interaction between the two containers.""\n    }\n]', '[\n  {\n    ""source"": ""Kubernetes"",\n    ""destination"": ""Pods"",\n    ""relation_description"": ""consists of"",\n    ""summary_er"": ""In Kubernetes, a Pod represents a logical host and consists of one or more Containers that share resources.""\n  },\n  {\n    ""source"": ""Containers"",\n    ""destination"": ""Pods"",\n    ""relation_description"": ""and the destination pod"",\n    ""summary_er"": ""A Container is a lightweight and standalone process within a Pod, sharing its resources and namespace.""\n  }\n]', '[\n  {\n    ""source"": ""Kubernetes"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""uses"",\n    ""summary_er"": ""Kubernetes manages and orchestrates containerized applications, utilizing pods as the basic execution unit.""\n  }\n]', '[\n    {\n        ""source"": ""Process"",\n        ""destination"": ""Container 1"",\n        ""relation_description"": ""runs within"",\n        ""summary_er"": ""A process executes within a container, utilizing its resources and environment.""\n    }\n]', '[\n  {\n    ""source"": ""NAT"",\n    ""destination"": ""LAN"",\n    ""relation_description"": ""provides"",\n    ""summary_er"": ""NAT translates private IP addresses to public ones, enabling communication between LAN and external networks.""\n  }\n]']","Kubernetes pods are logical hosts that behave like physical hosts or VMs, with processes running in the same pod behaving like processes on the same machine. Each pod has its own IP address and can communicate directly with other pods through a flat network, without NAT gateways. Pods should be organized by app, with each containing tightly related components or processes, allowing for as many pods as needed without significant overhead.","[{'highlight': 'All pods in a Kubernetes cluster reside in a single flat, shared, network-address space'}, {'highlight': 'Communication between pods is always simple, regardless of the actual inter-node network topology'}, {'highlight': 'Each pod gets its own IP address and is accessible from all other pods through this network established specifically for pods'}, {'highlight': 'Pods are logical hosts and behave much like physical hosts or VMs in the non-container world'}, {'highlight': 'You should organize apps into multiple pods, where each one contains only tightly related components or processes'}]"
2,91,0,[],"59
Introducing pods
 Having said that, do you think a multi-tier application consisting of a frontend
application server and a backend database should be configured as a single pod or as
two pods?
SPLITTING MULTI-TIER APPS INTO MULTIPLE PODS
Although nothing is stopping you from running both the frontend server and the
database in a single pod with two containers, it isn’t the most appropriate way. We’ve
said that all containers of the same pod always run co-located, but do the web server
and the database really need to run on the same machine? The answer is obviously no,
so you don’t want to put them into a single pod. But is it wrong to do so regardless? In
a way, it is.
 If both the frontend and backend are in the same pod, then both will always be
run on the same machine. If you have a two-node Kubernetes cluster and only this sin-
gle pod, you’ll only be using a single worker node and not taking advantage of the
computational resources (CPU and memory) you have at your disposal on the second
node. Splitting the pod into two would allow Kubernetes to schedule the frontend to
one node and the backend to the other node, thereby improving the utilization of
your infrastructure.
SPLITTING INTO MULTIPLE PODS TO ENABLE INDIVIDUAL SCALING
Another reason why you shouldn’t put them both into a single pod is scaling. A pod is
also the basic unit of scaling. Kubernetes can’t horizontally scale individual contain-
ers; instead, it scales whole pods. If your pod consists of a frontend and a backend con-
tainer, when you scale up the number of instances of the pod to, let’s say, two, you end
up with two frontend containers and two backend containers. 
 Usually, frontend components have completely different scaling requirements
than the backends, so we tend to scale them individually. Not to mention the fact that
backends such as databases are usually much harder to scale compared to (stateless)
frontend web servers. If you need to scale a container individually, this is a clear indi-
cation that it needs to be deployed in a separate pod. 
UNDERSTANDING WHEN TO USE MULTIPLE CONTAINERS IN A POD
The main reason to put multiple containers into a single pod is when the application
consists of one main process and one or more complementary processes, as shown in
figure 3.3.
Pod
Main container
Supporting
container 1
Supporting
container 2
Volume
Figure 3.3
Pods should contain tightly coupled 
containers, usually a main container and containers 
that support the main one.
 
",[],[],,[],"A multi-tier application consisting of frontend and backend components should not be configured as a single pod but rather split into multiple pods to enable individual scaling and utilize computational resources on multiple nodes. This approach allows for separate scaling requirements for frontend and backend components, making it more efficient and suitable for applications with diverse resource needs.","[{'highlight': 'Splitting multi-tier applications into multiple pods is recommended to improve infrastructure utilization and enable individual scaling of frontend and backend components.'}, {'highlight': ""Kubernetes can't horizontally scale individual containers, but it scales whole pods, making it necessary to deploy separate pods for frontend and backend containers when different scaling requirements exist.""}, {'highlight': 'The main reason to put multiple containers into a single pod is when the application consists of one main process and one or more complementary processes that are tightly coupled.'}, {'highlight': 'Running both frontend server and database in a single pod can lead to underutilization of computational resources on a two-node Kubernetes cluster, as both will always run on the same machine.'}, {'highlight': 'Pods should contain tightly coupled containers, usually a main container and one or more supporting containers that are closely related to the main process.'}]"
3,92,0,[],"60
CHAPTER 3
Pods: running containers in Kubernetes
For example, the main container in a pod could be a web server that serves files from
a certain file directory, while an additional container (a sidecar container) periodi-
cally downloads content from an external source and stores it in the web server’s
directory. In chapter 6 you’ll see that you need to use a Kubernetes Volume that you
mount into both containers. 
 Other examples of sidecar containers include log rotators and collectors, data pro-
cessors, communication adapters, and others.
DECIDING WHEN TO USE MULTIPLE CONTAINERS IN A POD
To recap how containers should be grouped into pods—when deciding whether to
put two containers into a single pod or into two separate pods, you always need to ask
yourself the following questions:
Do they need to be run together or can they run on different hosts?
Do they represent a single whole or are they independent components?
Must they be scaled together or individually? 
Basically, you should always gravitate toward running containers in separate pods,
unless a specific reason requires them to be part of the same pod. Figure 3.4 will help
you memorize this.
Although pods can contain multiple containers, to keep things simple for now, you’ll
only be dealing with single-container pods in this chapter. You’ll see how multiple
containers are used in the same pod later, in chapter 6. 
Pod
Frontend
process
Backend
process
Container
Pod
Frontend
process
Frontend
container
Frontend pod
Frontend
process
Frontend
container
Backend pod
Backend
process
Backend
container
Backend
process
Backend
container
Figure 3.4
A container shouldn’t run multiple processes. A pod shouldn’t contain multiple 
containers if they don’t need to run on the same machine.
 
",[],"[{'entity': 'Pod', 'description': 'a group of one or more containers that share resources and are scheduled together', 'category': 'container'}, {'entity': 'Container', 'description': 'a lightweight and standalone executable package of software', 'category': 'container'}, {'entity': 'Kubernetes', 'description': 'an open-source container orchestration system for automating the deployment, scaling, and management of containers', 'category': 'software'}, {'entity': 'Volume', 'description': 'a way to persist data across container restarts and provide shared storage between containers', 'category': 'database'}, {'entity': 'Sidecar container', 'description': 'an additional container that runs alongside the main container in a pod, often used for tasks such as log rotation or communication', 'category': 'container'}, {'entity': 'Log rotator', 'description': 'a type of sidecar container that rotates and manages logs for a container', 'category': 'process'}, {'entity': 'Collector', 'description': 'a type of sidecar container that collects data from a container or other sources', 'category': 'process'}, {'entity': 'Data processor', 'description': 'a type of sidecar container that processes and transforms data for a container', 'category': 'process'}, {'entity': 'Communication adapter', 'description': 'a type of sidecar container that enables communication between containers or other systems', 'category': 'process'}, {'entity': 'Frontend process', 'description': 'the main process running in the frontend pod, responsible for serving files and handling user requests', 'category': 'process'}, {'entity': 'Backend process', 'description': 'the main process running in the backend pod, responsible for processing data and handling requests', 'category': 'process'}, {'entity': 'Frontend container', 'description': 'the container running the frontend process in a pod', 'category': 'container'}, {'entity': 'Backend container', 'description': 'the container running the backend process in a pod', 'category': 'container'}, {'entity': 'Pod', 'description': 'a group of one or more containers that share resources and are scheduled together', 'category': 'container'}, {'entity': 'Frontend pod', 'description': 'a pod containing the frontend container and process', 'category': 'pod'}, {'entity': 'Backend pod', 'description': 'a pod containing the backend container and process', 'category': 'pod'}]","[{'source_entity': '""Frontend container""', 'description': 'runs', 'destination_entity': '""Frontend process""'}, {'source_entity': '""Communication adapter""', 'description': 'facilitates communication between', 'destination_entity': '""Frontend container"" and ""Backend container""'}, {'source_entity': '""Container""', 'description': 'hosts', 'destination_entity': '""Frontend process""'}, {'source_entity': '""Kubernetes""', 'description': 'manages', 'destination_entity': '""Frontend pod"" and ""Backend pod""'}, {'source_entity': '""Frontend pod""', 'description': 'contains', 'destination_entity': '""Frontend container""'}, {'source_entity': '""Pod""', 'description': 'hosts', 'destination_entity': '""Frontend process"" and ""Backend process""'}, {'source_entity': '""Sidecar container""', 'description': 'assists', 'destination_entity': '""Frontend container""'}, {'source_entity': '""Volume""', 'description': 'stores', 'destination_entity': '""Log rotator"" and ""Collector""'}, {'source_entity': '""Backend pod""', 'description': 'contains', 'destination_entity': '""Backend container""'}, {'source_entity': '""Log rotator""', 'description': 'removes', 'destination_entity': '""Logs""'}, {'source_entity': '""Collector""', 'description': 'collects', 'destination_entity': '""Data processor"" and ""Backend process""'}, {'source_entity': '""Backend container""', 'description': 'hosts', 'destination_entity': '""Backend process""'}, {'source_entity': '""Data processor""', 'description': 'processes', 'destination_entity': '""Collected data""'}]","['[\n  {\n    ""source"": ""Frontend container"",\n    ""destination"": ""Frontend process"",\n    ""relation_description"": ""runs"",\n    ""summary_er"": ""The Frontend container executes the Frontend process, utilizing its functionality to provide a user interface.""\n  }\n]', '[\n  {\n    ""source"": ""Communication adapter"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""facilitates communication between"",\n    ""summary_er"": ""The Communication adapter enables seamless interaction between applications, facilitating data exchange and synchronization with the pod.""\n  },\n  {\n    ""source"": ""Frontend container"",\n    ""destination"": ""Backend container"",\n    ""relation_description"": """",\n    ""summary_er"": ""The Frontend container interacts with the Backend container to provide a unified user experience, enabling data retrieval and processing between the two containers.""\n  }\n]', '[\n  {\n    ""source"": ""Container"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""hosts"",\n    ""summary_er"": ""A container runs on a host, which is an instance of a pod.""\n  },\n  {\n    ""source"": ""Frontend process"",\n    ""destination"": ""Container"",\n    ""relation_description"": ""runs in"",\n    ""summary_er"": ""The frontend process executes within a container, providing a user interface.""\n  }\n]', '[\n  {\n    ""source"": ""Kubernetes"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""manages"",\n    ""summary_er"": ""Kubernetes manages a pod, which is a containerized application that can run one or more containers.""\n  },\n  {\n    ""source"": ""Frontend pod"",\n    ""destination"": ""Backend pod"",\n    ""relation_description"": ""communicates with"",\n    ""summary_er"": ""The Frontend pod communicates with the Backend pod to exchange data and requests, enabling a seamless user experience.""\n  }\n]', '[\n  {\n    ""source"": ""Frontend pod"",\n    ""destination"": ""Frontend container"",\n    ""relation_description"": ""contains"",\n    ""summary_er"": ""The Frontend pod contains a single Frontend container, which handles user interactions and rendering.""\n  }\n]', '[\n  {\n    ""source"": ""Pod"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""hosts"",\n    ""summary_er"": ""A Pod hosts one or more containers, providing a shared environment for their execution.""\n  },\n  {\n    ""source"": ""Frontend process"",\n    ""destination"": ""Backend process"",\n    ""relation_description"": """",\n    ""summary_er"": ""The Frontend process communicates with the Backend process to handle user requests and retrieve data.""\n  }\n]', '[\n  {\n    ""source"": ""Sidecar container"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""assists"",\n    ""summary_er"": ""A sidecar container provides assistance to a pod by running additional processes or services that complement the main application.""\n  }\n]', '[\n  {\n    ""source"": ""Volume"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""stores"",\n    ""summary_er"": ""A volume stores data for a pod, providing persistent storage.""\n  },\n  {\n    ""source"": ""Log rotator"",\n    ""destination"": ""Collector"",\n    ""relation_description"": """",\n    ""summary_er"": ""The log rotator is responsible for collecting logs from various sources and sending them to the collector for processing.""\n  }\n]', '[\n  {\n    ""source"": ""Backend pod"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""contains"",\n    ""summary_er"": ""The Backend pod encapsulates a pod, which is a deployable unit of an application.""\n  },\n  {\n    ""source"": ""Backend pod"",\n    ""destination"": ""Backend container"",\n    ""relation_description"": ""contains"",\n    ""summary_er"": ""The Backend pod contains the Backend container, which is a runtime environment for the application.""\n  }\n]', '[\n  {\n    ""source"": ""Log Rotator"",\n    ""destination"": ""Pods"",\n    ""relation_description"": ""removes"",\n    ""summary_er"": ""The Log Rotator component periodically removes logs from a Pod, ensuring disk space and performance.""\n  }\n]', '[\n  {\n    ""source"": ""Collector"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""collects"",\n    ""summary_er"": ""The Collector entity collects data from a pod, which is a containerized application in Kubernetes.""\n  },\n  {\n    ""source"": ""Data processor"",\n    ""destination"": ""Backend process"",\n    ""relation_description"": """",\n    ""summary_er"": ""The Data processor entity processes data for the Backend process, which handles server-side logic and API calls.""\n  }\n]', '[\n  {\n    ""source"": ""Backend container"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""hosts"",\n    ""summary_er"": ""The Backend container resides on a pod, utilizing its resources and environment.""\n  },\n  {\n    ""source"": ""Backend process"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""runs on"",\n    ""summary_er"": ""The Backend process executes within a pod, leveraging its computing power and memory.""\n  }\n]', '[\n  {\n    ""source"": ""Data processor"",\n    ""destination"": ""Pod"",\n    ""relation_description"": ""processes"",\n    ""summary_er"": ""The Data processor entity takes in Collected data and performs processing operations on it.""\n  }\n]']","Pods in Kubernetes are groups of containers that can be run together, like a web server and a sidecar container for downloading content. To decide when to use multiple containers in a pod, ask yourself: do they need to run together, represent a single whole, or must they be scaled together? Typically, containers should be run in separate pods unless a specific reason requires them to be part of the same pod.","[{'highlight': ""Pods can contain multiple containers, but it's recommended to run them separately unless a specific reason requires them to be part of the same pod.""}, {'highlight': 'When deciding whether to put two containers into a single pod or separate pods, ask yourself: Do they need to be run together? Do they represent a single whole? Must they be scaled together?'}, {'highlight': ""A container should not run multiple processes, and a pod should not contain multiple containers if they don't need to run on the same machine.""}, {'highlight': 'Sidecar containers are used for tasks such as log rotation, data processing, communication adapters, and others that can be decoupled from the main container.'}, {'highlight': 'Kubernetes Volumes can be used to mount shared storage between multiple containers in a pod, allowing them to share files and communicate with each other.'}]"
4,93,0,[],"61
Creating pods from YAML or JSON descriptors
3.2
Creating pods from YAML or JSON descriptors
Pods and other Kubernetes resources are usually created by posting a JSON or YAML
manifest to the Kubernetes REST API endpoint. Also, you can use other, simpler ways
of creating resources, such as the kubectl run command you used in the previous
chapter, but they usually only allow you to configure a limited set of properties, not
all. Additionally, defining all your Kubernetes objects from YAML files makes it possi-
ble to store them in a version control system, with all the benefits it brings.
 To configure all aspects of each type of resource, you’ll need to know and under-
stand the Kubernetes API object definitions. You’ll get to know most of them as you
learn about each resource type throughout this book. We won’t explain every single
property, so you should also refer to the Kubernetes API reference documentation at
http:/
/kubernetes.io/docs/reference/ when creating objects.
3.2.1
Examining a YAML descriptor of an existing pod
You already have some existing pods you created in the previous chapter, so let’s look
at what a YAML definition for one of those pods looks like. You’ll use the kubectl get
command with the -o yaml option to get the whole YAML definition of the pod, as
shown in the following listing.
$ kubectl get po kubia-zxzij -o yaml
apiVersion: v1                         
kind: Pod                                       
metadata:                                                 
  annotations:                                            
    kubernetes.io/created-by: ...                         
  creationTimestamp: 2016-03-18T12:37:50Z                 
  generateName: kubia-                                    
  labels:                                                 
    run: kubia                                            
  name: kubia-zxzij                                       
  namespace: default                                      
  resourceVersion: ""294""                                  
  selfLink: /api/v1/namespaces/default/pods/kubia-zxzij   
  uid: 3a564dc0-ed06-11e5-ba3b-42010af00004               
spec:                                                   
  containers:                                           
  - image: luksa/kubia                                  
    imagePullPolicy: IfNotPresent                       
    name: kubia                                         
    ports:                                              
    - containerPort: 8080                               
      protocol: TCP                                     
    resources:                                          
      requests:                                         
        cpu: 100m                                       
Listing 3.1
Full YAML of a deployed pod
Kubernetes API version used 
in this YAML descriptor
Type of Kubernetes 
object/resource
Pod metadata (name, 
labels, annotations, 
and so on)
Pod specification/
contents (list of 
pod’s containers, 
volumes, and so on)
 
",[],"[{'entity': 'Kubernetes', 'description': 'Container orchestration system', 'category': 'software'}, {'entity': 'REST API', 'description': 'Web service for interacting with Kubernetes resources', 'category': 'software'}, {'entity': 'kubectl', 'description': 'Command-line tool for managing Kubernetes resources', 'category': 'software'}, {'entity': 'YAML', 'description': 'Human-readable data serialization format', 'category': 'software'}, {'entity': 'JSON', 'description': 'Lightweight data interchange format', 'category': 'software'}, {'entity': 'Pods', 'description': 'Lightweight and ephemeral worker containers in Kubernetes', 'category': 'container'}, {'entity': 'API object definitions', 'description': 'Definitions of Kubernetes API objects, such as Pods, Services, etc.', 'category': 'software'}, {'entity': 'Kubernetes API reference documentation', 'description': 'Official documentation for the Kubernetes API', 'category': 'documentation'}, {'entity': 'kubectl get command', 'description': 'Command to retrieve information about a Kubernetes resource', 'category': 'software'}, {'entity': 'kubectl run command', 'description': 'Command to create a new Kubernetes resource, such as a Pod or Service', 'category': 'software'}, {'entity': 'Pod metadata', 'description': 'Information about a Pod, including its name, labels, annotations, etc.', 'category': 'container'}, {'entity': 'Pod specification', 'description': 'Contents of a Pod, including its containers, volumes, and so on', 'category': 'container'}, {'entity': 'containers', 'description': 'Lightweight and ephemeral worker processes in Kubernetes', 'category': 'container'}, {'entity': 'volumes', 'description': 'Persistent storage for a Pod or container', 'category': 'storage'}]","[{'source_entity': '""volumes""', 'description': 'are used to mount directories or files into a container', 'destination_entity': '""containers""'}, {'source_entity': '""JSON""', 'description': 'is used to define API object definitions', 'destination_entity': '""API object definitions""'}, {'source_entity': '""REST API""', 'description': 'provides an interface for interacting with Kubernetes resources', 'destination_entity': '""Kubernetes API reference documentation""'}, {'source_entity': '""Pod metadata""', 'description': 'is used to identify and manage Pods in a cluster', 'destination_entity': '""Pods""'}, {'source_entity': '""Pod specification""', 'description': 'defines the configuration for creating a Pod', 'destination_entity': '""Pods""'}, {'source_entity': '""kubectl get command""', 'description': 'is used to retrieve information about Pods and other resources', 'destination_entity': '""Pod metadata""'}, {'source_entity': '""kubectl run command""', 'description': 'is used to create a new Pod with the specified configuration', 'destination_entity': '""Pods""'}, {'source_entity': '""YAML""', 'description': 'is used to define API object definitions and Pod specifications', 'destination_entity': '""API object definitions""'}, {'source_entity': '""kubectl""', 'description': 'is a command-line tool for interacting with Kubernetes resources', 'destination_entity': '""Kubernetes API reference documentation""'}]","['[\n  {\n    ""source"": ""volumes"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""are used to mount directories or files into a container"",\n    ""summary_er"": ""Volumes are mounted into pods to provide persistent storage for containers.""\n  }\n]', '[\n  {\n    ""source"": ""JSON"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""is used to define"",\n    ""summary_er"": ""JSON is used to define API object definitions for a pod.""\n  },\n  {\n    ""source"": ""API object definitions"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""are used in"",\n    ""summary_er"": ""API object definitions are used in Kubernetes to configure a pod\'s behavior.""\n  }\n]', '[\n  {\n    ""source"": ""REST API"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""provides an interface for interacting with Kubernetes resources"",\n    ""summary_er"": ""The REST API provides a standardized interface to interact with Kubernetes resources, including pods.""\n  },\n  {\n    ""source"": ""Kubernetes API reference documentation"",\n    ""destination"": ""REST API"",\n    ""relation_description"": ""reference documentation for the REST API"",\n    ""summary_er"": ""The Kubernetes API reference documentation serves as a comprehensive guide to the REST API\'s functionality and usage.""\n  }\n]', '[\n  {\n    ""source"": ""Pod metadata"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""is used to identify and manage Pods in a cluster"",\n    ""summary_er"": ""Pod metadata is used to uniquely identify and manage pods within a Kubernetes cluster.""\n  }\n]', '[\n  {\n    ""source"": ""Pod specification"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""defines the configuration for creating a Pod"",\n    ""summary_er"": ""The Pod specification defines the configuration required to create a pod, which is a basic execution unit in Kubernetes.""\n  }\n]', '[\n  {\n    ""source"": ""kubectl get command"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""is used to retrieve information about Pods and other resources"",\n    ""summary_er"": ""The \'kubectl get\' command retrieves pod metadata, providing information about pods and their resources.""\n  }\n]', '[\n  {\n    ""source"": ""kubectl run command"",\n    ""destination"": ""Pods"",\n    ""relation_description"": ""is used to create a new Pod with the specified configuration"",\n    ""summary_er"": ""The \'kubectl run\' command creates a new pod with custom configuration, allowing for flexible deployment of applications.""\n  }\n]', '[\n  {\n    ""source"": ""YAML"",\n    ""destination"": ""Pod"",\n    ""relation_description"": ""is used to define API object definitions and Pod specifications"",\n    ""summary_er"": ""YAML is used to define Pod specifications, including API object definitions.""\n  }\n]', '[\n  {\n    ""source"": ""kubectl"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""interacting with Kubernetes resources"",\n    ""summary_er"": ""kubectl is used to interact with Kubernetes resources, including pods.""\n  },\n  {\n    ""source"": ""Kubernetes API reference documentation"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""resource management"",\n    ""summary_er"": ""The Kubernetes API reference documentation provides information on managing pods and other Kubernetes resources.""\n  }\n]']","You can create pods by posting a JSON or YAML manifest to the Kubernetes REST API endpoint. This method allows configuration of all properties, but requires knowledge of the Kubernetes API object definitions. Alternatively, you can use commands like kubectl run, but they limit the configurable properties. The YAML descriptor for an existing pod can be obtained using kubectl get with the -o yaml option, showing metadata and specification details.","[{'highlight': 'You can create pods from YAML or JSON descriptors by posting a JSON or YAML manifest to the Kubernetes REST API endpoint.'}, {'highlight': 'Defining all your Kubernetes objects from YAML files makes it possible to store them in a version control system, with all the benefits it brings.'}, {'highlight': 'To configure all aspects of each type of resource, you’ll need to know and understand the Kubernetes API object definitions.'}, {'highlight': 'You can use the kubectl get command with the -o yaml option to get the whole YAML definition of a pod.'}, {'highlight': 'The YAML descriptor for a pod includes metadata (name, labels, annotations, and so on) and specification/contents (list of containers, volumes, and so on).'}]"
5,94,0,[],"62
CHAPTER 3
Pods: running containers in Kubernetes
    terminationMessagePath: /dev/termination-log      
    volumeMounts:                                     
    - mountPath: /var/run/secrets/k8s.io/servacc      
      name: default-token-kvcqa                       
      readOnly: true                                  
  dnsPolicy: ClusterFirst                             
  nodeName: gke-kubia-e8fe08b8-node-txje              
  restartPolicy: Always                               
  serviceAccount: default                             
  serviceAccountName: default                         
  terminationGracePeriodSeconds: 30                   
  volumes:                                            
  - name: default-token-kvcqa                         
    secret:                                           
      secretName: default-token-kvcqa                 
status:                                                   
  conditions:                                             
  - lastProbeTime: null                                   
    lastTransitionTime: null                              
    status: ""True""                                        
    type: Ready                                           
  containerStatuses:                                      
  - containerID: docker://f0276994322d247ba...            
    image: luksa/kubia                                    
    imageID: docker://4c325bcc6b40c110226b89fe...         
    lastState: {}                                         
    name: kubia                                           
    ready: true                                           
    restartCount: 0                                       
    state:                                                
      running:                                            
        startedAt: 2016-03-18T12:46:05Z                   
  hostIP: 10.132.0.4                                      
  phase: Running                                          
  podIP: 10.0.2.3                                         
  startTime: 2016-03-18T12:44:32Z                         
I know this looks complicated, but it becomes simple once you understand the basics
and know how to distinguish between the important parts and the minor details. Also,
you can take comfort in the fact that when creating a new pod, the YAML you need to
write is much shorter, as you’ll see later.
INTRODUCING THE MAIN PARTS OF A POD DEFINITION
The pod definition consists of a few parts. First, there’s the Kubernetes API version
used in the YAML and the type of resource the YAML is describing. Then, three
important sections are found in almost all Kubernetes resources:
Metadata includes the name, namespace, labels, and other information about
the pod.
Spec contains the actual description of the pod’s contents, such as the pod’s con-
tainers, volumes, and other data.
Pod specification/
contents (list of 
pod’s containers, 
volumes, and so on)
Detailed status 
of the pod and 
its containers
 
",[],"[{'entity': 'terminationMessagePath', 'description': '/dev/termination-log', 'category': 'process'}, {'entity': 'dnsPolicy', 'description': 'ClusterFirst', 'category': 'network'}, {'entity': 'nodeName', 'description': 'gke-kubia-e8fe08b8-node-txje', 'category': 'hardware'}, {'entity': 'restartPolicy', 'description': 'Always', 'category': 'process'}, {'entity': 'serviceAccount', 'description': 'default', 'category': 'application'}, {'entity': 'terminationGracePeriodSeconds', 'description': '30', 'category': 'process'}, {'entity': 'volumes', 'description': 'list of pod’s containers, volumes, and so on', 'category': 'database'}, {'entity': 'containerID', 'description': 'docker://f0276994322d247ba...', 'category': 'process'}, {'entity': 'image', 'description': 'luksa/kubia', 'category': 'software'}, {'entity': 'lastState', 'description': '{}', 'category': 'process'}, {'entity': 'name', 'description': 'kubia', 'category': 'application'}, {'entity': 'ready', 'description': 'true', 'category': 'process'}, {'entity': 'restartCount', 'description': '0', 'category': 'process'}, {'entity': 'state', 'description': 'running: startedAt: 2016-03-18T12:46:05Z', 'category': 'process'}, {'entity': 'hostIP', 'description': '10.132.0.4', 'category': 'hardware'}, {'entity': 'phase', 'description': 'Running', 'category': 'process'}, {'entity': 'podIP', 'description': '10.0.2.3', 'category': 'hardware'}, {'entity': 'startTime', 'description': '2016-03-18T12:44:32Z', 'category': 'process'}, {'entity': 'Kubernetes API version', 'description': 'used in the YAML and the type of resource the YAML is describing', 'category': 'software'}, {'entity': 'Metadata', 'description': 'includes the name, namespace, labels, and other information about the pod', 'category': 'database'}, {'entity': 'Spec', 'description': 'contains the actual description of the pod’s contents', 'category': 'database'}, {'entity': 'Pod specification/contents', 'description': 'list of pod’s containers, volumes, and so on', 'category': 'database'}, {'entity': 'Detailed status of the pod and its containers', 'description': 'status: conditions: lastProbeTime: null lastTransitionTime: null status: True type: Ready', 'category': 'process'}]","[{'source_entity': '""volumes""', 'description': 'are used to store data for a pod', 'destination_entity': '""Pod specification/contents""'}, {'source_entity': '""phase""', 'description': 'indicates the current state of a pod', 'destination_entity': '""Detailed status of the pod and its containers""'}, {'source_entity': '""startTime""', 'description': 'represents the time when a pod was started', 'destination_entity': '""Pod specification/contents""'}, {'source_entity': '""podIP""', 'description': 'is the IP address of a pod', 'destination_entity': '""Pod specification/contents""'}, {'source_entity': '""ready""', 'description': 'indicates whether a pod is ready to receive traffic', 'destination_entity': '""Detailed status of the pod and its containers""'}, {'source_entity': '""image""', 'description': 'represents the Docker image used by a container', 'destination_entity': '""containerID""'}, {'source_entity': '""restartCount""', 'description': 'indicates how many times a pod has been restarted', 'destination_entity': '""Pod specification/contents""'}, {'source_entity': '""dnsPolicy""', 'description': 'specifies the DNS policy for a pod', 'destination_entity': '""Pod specification/contents""'}, {'source_entity': '""state""', 'description': 'represents the current state of a container', 'destination_entity': '""Detailed status of the pod and its containers""'}, {'source_entity': '""hostIP""', 'description': 'is the IP address of the host machine', 'destination_entity': '""Pod specification/contents""'}, {'source_entity': '""containerID""', 'description': 'represents the ID of a container', 'destination_entity': '""image""'}, {'source_entity': '""restartPolicy""', 'description': 'specifies the restart policy for a pod', 'destination_entity': '""Pod specification/contents""'}, {'source_entity': '""lastState""', 'description': 'represents the last known state of a container', 'destination_entity': '""Detailed status of the pod and its containers""'}, {'source_entity': '""terminationGracePeriodSeconds""', 'description': 'specifies the grace period for terminating a pod', 'destination_entity': '""Pod specification/contents""'}, {'source_entity': '""serviceAccount""', 'description': 'represents the service account used by a pod', 'destination_entity': '""Pod specification/contents""'}, {'source_entity': '""Spec""', 'description': 'specifies the configuration of a pod', 'destination_entity': '""Pod specification/contents""'}, {'source_entity': '""name""', 'description': 'represents the name of a pod or container', 'destination_entity': '""Pod specification/contents""'}, {'source_entity': '""Kubernetes API version""', 'description': 'specifies the version of the Kubernetes API used', 'destination_entity': '""Metadata""'}, {'source_entity': '""Metadata""', 'description': 'represents metadata about a pod or container', 'destination_entity': '""Pod specification/contents""'}, {'source_entity': '""nodeName""', 'description': 'specifies the name of the node on which a pod is running', 'destination_entity': '""Pod specification/contents""'}, {'source_entity': '""terminationMessagePath""', 'description': 'specifies the path to a file containing termination messages', 'destination_entity': '""Detailed status of the pod and its containers""'}]","['[\n  {\n    ""source"": ""volumes"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""are used to store data for a pod"",\n    ""summary_er"": ""Volumes are storage units that hold data for a pod, providing persistent storage and access to files.""\n  },\n  {\n    ""source"": ""pod specification/contents"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""Pod specification/contents"",\n    ""summary_er"": ""A pod\'s specification defines its contents, including containers, volumes, and other resources that make up the pod.""\n  }\n]', '[\n  {\n    ""source"": ""Pod"",\n    ""destination"": ""Phase"",\n    ""relation_description"": ""indicates the current state of a pod"",\n    ""summary_er"": ""The Pod\'s phase indicates its current status, such as running or terminated.""\n  },\n  {\n    ""source"": ""Pod"",\n    ""destination"": ""Detailed Status"",\n    ""relation_description"": ""of the pod and its containers"",\n    ""summary_er"": ""The detailed status provides a comprehensive view of the pod\'s and container\'s state.""\n  }\n]', '[\n  {\n    ""source"": ""Kubernetes"",\n    ""destination"": ""Pod"",\n    ""relation_description"": ""startTime"",\n    ""summary_er"": ""In Kubernetes, startTime represents the time when a pod was started.""\n  },\n  {\n    ""source"": ""Pod specification/contents"",\n    ""destination"": ""Pod"",\n    ""relation_description"": ""Pod specification/contents"",\n    ""summary_er"": ""A Pod\'s specification and contents are stored in its configuration files.""\n  }\n]', '[\n  {\n    ""source"": ""Kubernetes"",\n    ""destination"": ""Pod"",\n    ""relation_description"": ""is the IP address of a pod"",\n    ""summary_er"": ""In Kubernetes, a Pod\'s IP address is used to communicate with it.""\n  },\n  {\n    ""source"": ""Docker"",\n    ""destination"": ""Container"",\n    ""relation_description"": ""contains the application code and dependencies"",\n    ""summary_er"": ""A Docker Container holds the application code and its dependencies for execution.""\n  },\n  {\n    ""source"": ""Machine Learning"",\n    ""destination"": ""Model"",\n    ""relation_description"": ""is a trained algorithm to make predictions"",\n    ""summary_er"": ""In Machine Learning, a Model is a trained algorithm that makes predictions based on input data.""\n  },\n  {\n    ""source"": ""Generative AI"",\n    ""destination"": ""Generator"",\n    ""relation_description"": ""creates new, synthetic data samples"",\n    ""summary_er"": ""A Generative AI Generator creates new, synthetic data samples that resemble real-world data.""\n  },\n  {\n    ""source"": ""Natural Language Understanding"",\n    ""destination"": ""NLU Model"",\n    ""relation_description"": ""analyzes and interprets human language"",\n    ""summary_er"": ""In NLU, a Model analyzes and interprets human language to understand its meaning and intent.""\n  },\n  {\n    ""source"": ""Computer Vision"",\n    ""destination"": ""CV Model"",\n    ""relation_description"": ""interprets and understands visual data from images and videos"",\n    ""summary_er"": ""A CV Model interprets and understands visual data from images and videos to make predictions or take actions.""\n  }\n]', '[\n  {\n    ""source"": ""Pod"",\n    ""destination"": ""Pod"",\n    ""relation_description"": ""Ready Status"",\n    ""summary_er"": ""The Pod is ready to receive traffic, indicating a stable and operational state.""\n  },\n  {\n    ""source"": ""Pod"",\n    ""destination"": ""Container"",\n    ""relation_description"": ""Detailed Status"",\n    ""summary_er"": ""The Pod\'s status includes detailed information about its containers, such as their execution and resource utilization.""\n  }\n]', '[\n  {\n    ""source"": ""Docker Image"",\n    ""destination"": ""Pod"",\n    ""relation_description"": ""represents the Docker image used by a container"",\n    ""summary_er"": ""A Docker image is used to create a pod in Kubernetes.""\n  },\n  {\n    ""source"": ""Container ID"",\n    ""destination"": ""Pod"",\n    ""relation_description"": ""used by a container"",\n    ""summary_er"": ""A container ID identifies the running container within a pod.""\n  }\n]', '[{""source"": ""restartCount"", ""destination"": ""pod"", ""relation_description"": ""indicates how many times a pod has been restarted"", ""summary_er"": ""The restart count indicates the number of times a pod has been restarted due to failures or other issues.""}]', '[\n  {\n    ""source"": ""dnsPolicy"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""specifies the DNS policy for a pod"",\n    ""summary_er"": ""DNS policy specifies how a pod accesses and resolves domain names.""\n  },\n  {\n    ""source"": ""Pod specification/contents"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""defines the configuration and data of a pod"",\n    ""summary_er"": ""A pod\'s contents define its configuration, including containers, volumes, and settings.""\n  }\n]', '[\n  {\n    ""source"": ""container"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""represents the current state of a container"",\n    ""summary_er"": ""The container\'s status reflects its current operational condition, indicating whether it\'s running or not.""\n  },\n  {\n    ""source"": ""pod"",\n    ""destination"": ""container"",\n    ""relation_description"": ""Detailed status of the pod and its containers"",\n    ""summary_er"": ""A comprehensive overview of the pod\'s performance, including the status of all its constituent containers.""\n  }\n]', '[{\n  ""source"": ""hostIP"",\n  ""destination"": ""is the IP address of the host machine"",\n  ""relation_description"": ""is"",\n  ""summary_er"": ""The host\'s IP address is a unique identifier assigned to it.""\n}]', '[\n  {\n    ""source"": ""container"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""represents the ID of a container"",\n    ""summary_er"": ""A container ID uniquely identifies a running container, linking it to its parent pod.""\n  },\n  {\n    ""source"": ""image"",\n    ""destination"": ""container"",\n    ""relation_description"": ""the image used to create the container"",\n    ""summary_er"": ""An image serves as a blueprint for creating containers, providing the necessary dependencies and configuration.""\n  }\n]', '[{""source"": ""restartPolicy"", ""destination"": ""pod"", ""relation_description"": ""specifies the restart policy for a pod"", ""summary_er"": ""The restart policy specifies how often a pod should be restarted, ensuring reliability and availability.""}]', '[\n  {\n    ""source"": ""container"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""lastState"",\n    ""summary_er"": ""The last known state of a container is represented by the \'lastState\' relation, which provides detailed information about the pod and its containers.""\n  }\n]', '[\n  {\n    ""source"": ""terminationGracePeriodSeconds"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""specifies the grace period for terminating a pod"",\n    ""summary_er"": ""The terminationGracePeriodSeconds field specifies the time to wait before forcefully terminating a pod, allowing for cleanup and resource release.""\n  },\n  {\n    ""source"": ""Pod specification/contents"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""defines the configuration and data of a pod"",\n    ""summary_er"": ""The Pod specification contains metadata, labels, and container definitions that define the characteristics and behavior of a pod in Kubernetes.""\n  }\n]', '[\n  {\n    ""source"": ""Service Account"",\n    ""destination"": ""Pod"",\n    ""relation_description"": ""represents the service account used by a pod"",\n    ""summary_er"": ""A Service Account provides an identity for a Pod to authenticate with, allowing it to access cluster resources.""\n  },\n  {\n    ""source"": ""Pod specification/contents"",\n    ""destination"": ""Container"",\n    ""relation_description"": ""defines the container(s) that make up a pod"",\n    ""summary_er"": ""The Pod specification contains metadata and configuration for one or more Containers running within it, including resource requests and environment variables.""\n  }\n]', '[\n  {\n    ""source"": ""Spec"",\n    ""destination"": ""Pod"",\n    ""relation_description"": ""specifies the configuration of a pod"",\n    ""summary_er"": ""The spec entity defines the configuration and contents of a Pod, including its settings and parameters.""\n  }\n]', '[\n  {\n    ""source"": ""Kubernetes"",\n    ""destination"": ""Docker"",\n    ""relation_description"": ""containerization technology used in Kubernetes"",\n    ""summary_er"": ""Kubernetes utilizes Docker as a containerization technology to manage and orchestrate containers.""\n  },\n  {\n    ""source"": ""Machine Learning"",\n    ""destination"": ""Generative AI"",\n    ""relation_description"": ""subset of machine learning focused on generating new data"",\n    ""summary_er"": ""Generative AI is a subset of Machine Learning that focuses on generating new, synthetic data that resembles real-world data.""\n  },\n  {\n    ""source"": ""Natural Language Understanding"",\n    ""destination"": ""Computer Vision"",\n    ""relation_description"": ""two distinct areas of artificial intelligence"",\n    ""summary_er"": ""Natural Language Understanding and Computer Vision are two separate areas of AI research, focusing on text and image understanding respectively.""\n  }\n]', '[\n  {\n    ""source"": ""Kubernetes API"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""specifies the version of the Kubernetes API used"",\n    ""summary_er"": ""The Kubernetes API version specifies the version of the Kubernetes API used by a pod, ensuring compatibility and functionality.""\n  },\n  {\n    ""source"": ""Metadata"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""general information about the pod"",\n    ""summary_er"": ""Metadata provides general information about a pod, including its name, labels, and annotations, which are used for identification and management purposes.""\n  }\n]', '[\n  {\n    ""source"": ""Metadata"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""represents metadata about a pod or container"",\n    ""summary_er"": ""The metadata entity provides information about a pod\'s specifications and contents, serving as a detailed description of its characteristics.""\n  },\n  {\n    ""source"": ""Pod specification/contents"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""contains the actual data of a pod or container"",\n    ""summary_er"": ""The pod specification contains the actual data of a pod, including its contents and specifications, which are essential for its proper functioning.""\n  }\n]', '[\n  {\n    ""source"": ""nodeName"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""specifies the name of the node on which a pod is running"",\n    ""summary_er"": ""The nodeName specifies the node where a pod will be deployed, ensuring proper resource allocation and isolation.""\n  },\n  {\n    ""source"": ""Pod specification/contents"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""defines the configuration and settings of a pod"",\n    ""summary_er"": ""A Pod specification outlines the details required to create or update a pod, including its configuration, resources, and dependencies.""\n  }\n]', '[\n  {\n    ""source"": ""Pod"",\n    ""destination"": ""File"",\n    ""relation_description"": ""terminationMessagePath"",\n    ""summary_er"": ""The Pod specifies a path to a File containing termination messages.""\n  },\n  {\n    ""source"": ""Pod"",\n    ""destination"": ""Container"",\n    ""relation_description"": ""Detailed status of the pod and its containers"",\n    ""summary_er"": ""The Pod has a Detailed status of its Containers, including their execution state.""\n  }\n]']","A Kubernetes Pod is a logical host for one or more application containers. It consists of metadata (name, namespace, labels) and spec (containers, volumes), with optional detailed status information. Key elements include terminationMessagePath, dnsPolicy, restartPolicy, serviceAccount, and volumeMounts.","[{'highlight': 'A pod definition consists of a few parts, including the Kubernetes API version, resource type, metadata, spec, and status.'}, {'highlight': 'The metadata section includes the name, namespace, labels, and other information about the pod.'}, {'highlight': ""The spec section contains the actual description of the pod's contents, such as containers, volumes, and other data.""}, {'highlight': 'A pod can have multiple containers, volumes, and other resources, which are specified in the spec section.'}, {'highlight': ""The status section provides detailed information about the pod's current state, including its phase, IP address, and container statuses.""}]"
6,95,0,[],"63
Creating pods from YAML or JSON descriptors
Status contains the current information about the running pod, such as what
condition the pod is in, the description and status of each container, and the
pod’s internal IP and other basic info.
Listing 3.1 showed a full description of a running pod, including its status. The status
part contains read-only runtime data that shows the state of the resource at a given
moment. When creating a new pod, you never need to provide the status part. 
 The three parts described previously show the typical structure of a Kubernetes
API object. As you’ll see throughout the book, all other objects have the same anat-
omy. This makes understanding new objects relatively easy.
 Going through all the individual properties in the previous YAML doesn’t make
much sense, so, instead, let’s see what the most basic YAML for creating a pod looks
like. 
3.2.2
Creating a simple YAML descriptor for a pod
You’re going to create a file called kubia-manual.yaml (you can create it in any
directory you want), or download the book’s code archive, where you’ll find the
file inside the Chapter03 directory. The following listing shows the entire contents
of the file.
apiVersion: v1         
kind: Pod                             
metadata:     
  name: kubia-manual         
spec: 
  containers: 
  - image: luksa/kubia          
    name: kubia         
    ports: 
    - containerPort: 8080     
      protocol: TCP
I’m sure you’ll agree this is much simpler than the definition in listing 3.1. Let’s exam-
ine this descriptor in detail. It conforms to the v1 version of the Kubernetes API. The
type of resource you’re describing is a pod, with the name kubia-manual. The pod
consists of a single container based on the luksa/kubia image. You’ve also given a
name to the container and indicated that it’s listening on port 8080. 
SPECIFYING CONTAINER PORTS
Specifying ports in the pod definition is purely informational. Omitting them has no
effect on whether clients can connect to the pod through the port or not. If the con-
Listing 3.2
A basic pod manifest: kubia-manual.yaml
Descriptor conforms
to version v1 of
Kubernetes API
You’re 
describing a pod.
The name 
of the pod
Container image to create 
the container from
Name of the container
The port the app 
is listening on
 
",[],"[{'entity': 'Status', 'description': 'Current information about the running pod, such as what condition the pod is in, the description and status of each container, and the pod’s internal IP and other basic info.', 'category': 'software'}, {'entity': 'Pod', 'description': 'A Kubernetes API object that represents a running application or service.', 'category': 'application'}, {'entity': 'YAML', 'description': 'A human-readable serialization format for data, used to describe pods and other Kubernetes objects.', 'category': 'software'}, {'entity': 'JSON', 'description': 'A lightweight data interchange format, used to describe pods and other Kubernetes objects.', 'category': 'software'}, {'entity': 'apiVersion', 'description': 'The version of the Kubernetes API being used to create a pod or other object.', 'category': 'software'}, {'entity': 'kind', 'description': 'The type of resource being described, such as a pod or service.', 'category': 'software'}, {'entity': 'metadata', 'description': 'Information about the pod or other object, such as its name and labels.', 'category': 'software'}, {'entity': 'spec', 'description': 'The specification for the pod or other object, including its containers and ports.', 'category': 'software'}, {'entity': 'containers', 'description': 'A list of containers that make up the pod or other object.', 'category': 'application'}, {'entity': 'image', 'description': 'The Docker image being used to create a container for the pod or other object.', 'category': 'software'}, {'entity': 'ports', 'description': 'A list of ports that are exposed by the containers in the pod or other object.', 'category': 'application'}, {'entity': 'containerPort', 'description': 'The port number being exposed by a container in the pod or other object.', 'category': 'software'}, {'entity': 'protocol', 'description': 'The protocol being used for communication over a port, such as TCP or UDP.', 'category': 'network'}]","[{'source_entity': 'Docker', 'description': 'uses', 'destination_entity': 'image'}, {'source_entity': 'Kubernetes', 'description': 'manages', 'destination_entity': 'Pod'}, {'source_entity': 'JSON', 'description': 'is used for', 'destination_entity': 'metadata'}, {'source_entity': 'protocol', 'description': 'defines the communication', 'destination_entity': 'ports'}, {'source_entity': 'apiVersion', 'description': 'specifies the version of Kubernetes API', 'destination_entity': 'Kubernetes'}, {'source_entity': 'spec', 'description': 'contains the configuration details', 'destination_entity': 'containers'}, {'source_entity': 'containerPort', 'description': 'maps to a specific port in the container', 'destination_entity': 'ports'}, {'source_entity': 'YAML', 'description': 'is used for defining', 'destination_entity': 'metadata'}, {'source_entity': 'Status', 'description': 'represents the current state of the Pod', 'destination_entity': 'Pod'}]","['[\n  {\n    ""source"": ""Docker"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""uses"",\n    ""summary_er"": ""Docker uses a pod to run an application, providing a lightweight and portable way to deploy containers.""\n  },\n  {\n    ""source"": ""Docker"",\n    ""destination"": ""image"",\n    ""relation_description"": ""uses"",\n    ""summary_er"": ""Docker uses an image as the basis for creating a container, which can be customized and run independently.""\n  }\n]', '[\n  {\n    ""source"": ""Kubernetes"",\n    ""destination"": ""Pod"",\n    ""relation_description"": ""manages"",\n    ""summary_er"": ""Kubernetes manages a collection of containers called a pod, providing resource allocation and lifecycle management.""\n  }\n]', '[\n  {\n    ""source"": ""JSON"",\n    ""destination"": ""Pod Metadata"",\n    ""relation_description"": ""is used for"",\n    ""summary_er"": ""JSON data is utilized to store and manage Pod metadata, providing essential information about containerized applications.""\n  }\n]', '[\n  {\n    ""source"": ""protocol"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""defines the communication"",\n    ""summary_er"": ""The protocol defines how a pod communicates with other pods or services, specifying the port numbers and data formats used for interaction.""\n  },\n  {\n    ""source"": ""port"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""ports"",\n    ""summary_er"": ""A port is an endpoint that allows communication between a pod and other pods or services, enabling data exchange through specific protocols and addresses.""\n  }\n]', '[\n  {\n    ""source"": ""apiVersion"",\n    ""destination"": ""Kubernetes"",\n    ""relation_description"": ""specifies the version of Kubernetes API"",\n    ""summary_er"": ""The apiVersion field specifies the version of the Kubernetes API used by a pod, ensuring compatibility and functionality.""\n  }\n]', '[\n  {\n    ""source"": ""spec"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""contains the configuration details"",\n    ""summary_er"": ""The spec section of a Kubernetes deployment contains configuration details for the associated pod.""\n  },\n  {\n    ""source"": ""spec"",\n    ""destination"": ""containers"",\n    ""relation_description"": ""defines"",\n    ""summary_er"": ""In a Kubernetes deployment, the spec section defines the containers that make up the pod.""\n  }\n]', '[\n  {\n    ""source"": ""containerPort"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""maps to a specific port in the container"",\n    ""summary_er"": ""A container port is exposed by a pod, allowing external access to a service running within the container.""\n  }\n]', '[\n  {\n    ""source"": ""YAML"",\n    ""destination"": ""pod metadata"",\n    ""relation_description"": ""is used for defining"",\n    ""summary_er"": ""YAML defines pod metadata, specifying configuration details such as labels and annotations.""\n  }\n]', '[\n  {\n    ""source"": ""Status"",\n    ""destination"": ""Pod"",\n    ""relation_description"": ""represents the current state of the Pod"",\n    ""summary_er"": ""The Status entity represents the current operational status of a Pod, providing information about its execution state.""\n  },\n  {\n    ""source"": ""Pod"",\n    ""destination"": ""Status"",\n    ""relation_description"": ""represents the current state of the Pod"",\n    ""summary_er"": ""A Pod is a basic execution unit in Kubernetes, and Status provides details about its operational status.""\n  }\n]']","A Kubernetes pod can be created using a YAML or JSON descriptor, which typically consists of three parts: metadata, spec, and status. The spec section defines the container's image, name, and ports, with specifying ports being informational only. A simple example is shown in kubia-manual.yaml, where a single container based on luksa/kubia image listens on port 8080.","[{'highlight': 'When creating a new pod, you never need to provide the status part.'}, {'highlight': 'The most basic YAML for creating a pod looks like this: apiVersion: v1         kind: Pod                             metadata:     name: kubia-manual         spec:  containers:  - image: luksa/kubia          name: kubia         ports:  - containerPort: 8080      protocol: TCP'}, {'highlight': 'Specifying ports in the pod definition is purely informational. Omitting them has no effect on whether clients can connect to the pod through the port or not.'}, {'highlight': 'The three parts described previously show the typical structure of a Kubernetes API object: metadata, spec, and status.'}, {'highlight': ""You're describing a pod with the name kubia-manual, consisting of a single container based on the luksa/kubia image, listening on port 8080.""}]"
7,96,0,[],"64
CHAPTER 3
Pods: running containers in Kubernetes
tainer is accepting connections through a port bound to the 0.0.0.0 address, other
pods can always connect to it, even if the port isn’t listed in the pod spec explicitly. But
it makes sense to define the ports explicitly so that everyone using your cluster can
quickly see what ports each pod exposes. Explicitly defining ports also allows you to
assign a name to each port, which can come in handy, as you’ll see later in the book.
Using kubectl explain to discover possible API object fields
When preparing a manifest, you can either turn to the Kubernetes reference
documentation at http:/
/kubernetes.io/docs/api to see which attributes are
supported by each API object, or you can use the kubectl explain command.
For example, when creating a pod manifest from scratch, you can start by asking
kubectl to explain pods:
$ kubectl explain pods
DESCRIPTION:
Pod is a collection of containers that can run on a host. This resource 
is created by clients and scheduled onto hosts.
FIELDS:
   kind      <string>
     Kind is a string value representing the REST resource this object
     represents...
   metadata  <Object>
     Standard object's metadata...
   spec      <Object>
     Specification of the desired behavior of the pod...
   status    <Object>
     Most recently observed status of the pod. This data may not be up to
     date...
Kubectl prints out the explanation of the object and lists the attributes the object
can contain. You can then drill deeper to find out more about each attribute. For
example, you can examine the spec attribute like this:
$ kubectl explain pod.spec
RESOURCE: spec <Object>
DESCRIPTION:
    Specification of the desired behavior of the pod...
    podSpec is a description of a pod.
FIELDS:
   hostPID   <boolean>
     Use the host's pid namespace. Optional: Default to false.
   ...
   volumes   <[]Object>
     List of volumes that can be mounted by containers belonging to the
     pod.
 
",[],"[{'entity': 'Pod', 'description': 'A collection of containers that can run on a host.', 'category': 'application'}, {'entity': 'container', 'description': 'A process running within a pod.', 'category': 'process'}, {'entity': 'port', 'description': 'An endpoint for communication between pods or with the outside world.', 'category': 'network'}, {'entity': 'kubectl', 'description': 'A command-line tool for managing Kubernetes clusters.', 'category': 'software'}, {'entity': 'manifest', 'description': 'A file that defines a desired state of a Kubernetes object, such as a pod or service.', 'category': 'application'}, {'entity': 'API object', 'description': 'A resource in the Kubernetes API that can be created, updated, or deleted.', 'category': 'software'}, {'entity': 'spec', 'description': 'The desired behavior of a pod, including its containers and volumes.', 'category': 'application'}, {'entity': 'status', 'description': 'The current state of a pod, including its running containers and any errors.', 'category': 'application'}, {'entity': 'volumes', 'description': 'A list of volumes that can be mounted by containers within a pod.', 'category': 'storage'}, {'entity': 'hostPID', 'description': ""A boolean flag indicating whether to use the host's pid namespace."", 'category': 'process'}]","[{'source_entity': '""volumes""', 'description': 'are used to persist data', 'destination_entity': '""container""'}, {'source_entity': '""status""', 'description': 'provides information about the current state of the pod', 'destination_entity': '""Pod""'}, {'source_entity': '""spec""', 'description': 'defines the configuration of the pod', 'destination_entity': '""Pod""'}, {'source_entity': '""container""', 'description': 'is a runtime environment for an application', 'destination_entity': '""API object""'}, {'source_entity': '""hostPID""', 'description': ""allows the container to access the host's process ID"", 'destination_entity': '""container""'}, {'source_entity': '""port""', 'description': 'is used to expose a service outside the cluster', 'destination_entity': '""API object""'}, {'source_entity': '""kubectl""', 'description': 'is used to manage and deploy applications in a Kubernetes cluster', 'destination_entity': '""manifest""'}, {'source_entity': '""manifest""', 'description': 'is a YAML or JSON file that defines the configuration of an application', 'destination_entity': '""API object""'}]","['[\n  {\n    ""source"": ""volumes"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""are used to persist data"",\n    ""summary_er"": ""Persistent storage for pods, allowing them to retain data across restarts and scaling.""\n  },\n  {\n    ""source"": ""container"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""is a process running within the pod"",\n    ""summary_er"": ""A container is a lightweight process that runs within a pod, providing isolation and resource management.""\n  }\n]', '[\n  {\n    ""source"": ""status"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""provides information about the current state of the pod"",\n    ""summary_er"": ""The status field provides real-time updates on a pod\'s operational state, including its readiness and availability.""\n  }\n]', '[\n  {\n    ""source"": ""spec"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""defines the configuration of the pod"",\n    ""summary_er"": ""The spec entity defines the configuration parameters for a pod, which is a containerized application in Kubernetes.""\n  }\n]', '[\n  {\n    ""source"": ""container"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""is a runtime environment for an application"",\n    ""summary_er"": ""A container is a lightweight runtime environment that runs an application, providing isolation and resource management.""\n  },\n  {\n    ""source"": ""API object"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""is a runtime environment for an application"",\n    ""summary_er"": ""An API object represents a pod as a runtime environment for an application, encapsulating configuration and resources.""\n  }\n]', '[\n  {\n    ""source"": ""hostPID"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""allows the container to access the host\'s process ID"",\n    ""summary_er"": ""The hostPID relation allows a container to access the host\'s process ID, enabling communication between the container and the host.""\n  }\n]', '[\n  {\n    ""source"": ""Port"",\n    ""destination"": ""Pod"",\n    ""relation_description"": ""is used to expose a service outside the cluster"",\n    ""summary_er"": ""A port is used by a pod to expose its service to the outside world, allowing external access and communication.""\n  },\n  {\n    ""source"": ""API Object"",\n    ""destination"": ""Pod"",\n    ""relation_description"": ""represents a running instance of an application"",\n    ""summary_er"": ""An API object represents a running instance of an application, encapsulating its configuration and execution environment within the pod.""\n  }\n]', '[\n  {\n    ""source"": ""kubectl"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""is used to manage and deploy applications in a Kubernetes cluster"",\n    ""summary_er"": ""Kubectl is used to manage and deploy applications within a Kubernetes cluster, interacting with pods.""\n  },\n  {\n    ""source"": ""manifest"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""defines the configuration for a pod"",\n    ""summary_er"": ""A manifest defines the configuration for a pod, specifying its characteristics and requirements.""\n  }\n]', '[\n  {\n    ""source"": ""manifest"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""is a YAML or JSON file that defines the configuration of an application"",\n    ""summary_er"": ""A manifest is used to define the configuration of a pod, which is a container running an application.""\n  },\n  {\n    ""source"": ""pod"",\n    ""destination"": ""API object"",\n    ""relation_description"": ""is a Kubernetes resource that represents a running process"",\n    ""summary_er"": ""An API object represents a running process in a pod, providing a way to interact with it programmatically.""\n  }\n]']","A Kubernetes pod is a collection of containers that run on a host, and can be described using a manifest. The pod spec contains attributes such as hostname, IP addresses, ports, and volumes that can be mounted by containers. Using kubectl explain, one can discover possible API object fields and drill deeper to learn more about each attribute.","[{'highlight': 'In Kubernetes, a pod is a collection of containers that can run on a host.'}, {'highlight': 'You can use kubectl explain to discover possible API object fields when preparing a manifest.'}, {'highlight': 'Explicitly defining ports in a pod allows you to assign a name to each port and makes it easier for others to see what ports are exposed.'}, {'highlight': 'The kubectl explain command prints out the explanation of an object and lists its attributes, which can be drilled down further for more information.'}, {'highlight': 'The spec attribute in a pod manifest contains fields such as hostPID, volumes, and containers that describe the desired behavior of the pod.'}]"
8,97,0,[],"65
Creating pods from YAML or JSON descriptors
3.2.3
Using kubectl create to create the pod
To create the pod from your YAML file, use the kubectl create command:
$ kubectl create -f kubia-manual.yaml
pod ""kubia-manual"" created
The kubectl create -f command is used for creating any resource (not only pods)
from a YAML or JSON file. 
RETRIEVING THE WHOLE DEFINITION OF A RUNNING POD
After creating the pod, you can ask Kubernetes for the full YAML of the pod. You’ll
see it’s similar to the YAML you saw earlier. You’ll learn about the additional fields
appearing in the returned definition in the next sections. Go ahead and use the fol-
lowing command to see the full descriptor of the pod:
$ kubectl get po kubia-manual -o yaml
If you’re more into JSON, you can also tell kubectl to return JSON instead of YAML
like this (this works even if you used YAML to create the pod):
$ kubectl get po kubia-manual -o json
SEEING YOUR NEWLY CREATED POD IN THE LIST OF PODS
Your pod has been created, but how do you know if it’s running? Let’s list pods to see
their statuses:
$ kubectl get pods
NAME            READY   STATUS    RESTARTS   AGE
kubia-manual    1/1     Running   0          32s
kubia-zxzij     1/1     Running   0          1d    
There’s your kubia-manual pod. Its status shows that it’s running. If you’re like me,
you’ll probably want to confirm that’s true by talking to the pod. You’ll do that in a
minute. First, you’ll look at the app’s log to check for any errors.
3.2.4
Viewing application logs
Your little Node.js application logs to the process’s standard output. Containerized
applications usually log to the standard output and standard error stream instead of
   Containers  <[]Object> -required-
     List of containers belonging to the pod. Containers cannot currently
     Be added or removed. There must be at least one container in a pod.
     Cannot be updated. More info:
     http://releases.k8s.io/release-1.4/docs/user-guide/containers.md
 
",[],"[{'entity': 'kubectl create', 'description': 'Command to create a pod from YAML or JSON descriptor', 'category': 'command'}, {'entity': 'kubia-manual.yaml', 'description': 'YAML file used to create the pod', 'category': 'file'}, {'entity': 'kubectl get', 'description': 'Command to retrieve information about a pod', 'category': 'command'}, {'entity': 'po kubia-manual', 'description': 'Pod object used to retrieve its YAML definition', 'category': 'object'}, {'entity': '-o yaml', 'description': 'Option to specify output format as YAML', 'category': 'option'}, {'entity': '-o json', 'description': 'Option to specify output format as JSON', 'category': 'option'}, {'entity': 'kubectl get pods', 'description': 'Command to list all running pods', 'category': 'command'}, {'entity': 'kubia-manual', 'description': 'Pod name used to retrieve its YAML definition', 'category': 'pod'}, {'entity': 'kubia-zxzij', 'description': 'Pod name used to list all running pods', 'category': 'pod'}, {'entity': 'Node.js', 'description': 'Programming language used to develop the application', 'category': 'programming language'}, {'entity': ""process's standard output"", 'description': 'Output stream where the application logs are written', 'category': 'output stream'}, {'entity': 'standard error stream', 'description': 'Error output stream where the application logs are written', 'category': 'output stream'}, {'entity': 'Containers', 'description': 'List of containers belonging to a pod', 'category': 'object'}]","[{'source_entity': '""kubectl""', 'description': 'runs', 'destination_entity': '""kubia-manual""'}, {'source_entity': '""kubectl""', 'description': 'gets', 'destination_entity': '""pods""'}, {'source_entity': '""po kubia-manual""', 'description': 'is retrieved by', 'destination_entity': '""kubectl get pods""'}, {'source_entity': '""kubia-manual""', 'description': 'has a YAML file associated with it', 'destination_entity': '""kubia-manual.yaml""'}, {'source_entity': '""kubectl create""', 'description': 'creates', 'destination_entity': '""kubia-manual""'}, {'source_entity': '""-o yaml""', 'description': 'outputs the result in YAML format to', 'destination_entity': '""process\'s standard output""'}, {'source_entity': '""kubectl get""', 'description': 'gets information about', 'destination_entity': '""Containers""'}, {'source_entity': '""kubia-zxzij""', 'description': 'is a container that belongs to', 'destination_entity': '""kubia-manual""'}, {'source_entity': '""kubectl get""', 'description': 'gets information about', 'destination_entity': '""Node.js""'}, {'source_entity': '""standard error stream""', 'description': 'is used to output errors from', 'destination_entity': '""kubectl create""'}]","['[\n  {\n    ""source"": ""kubectl"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""runs"",\n    ""summary_er"": ""Kubectl command runs a pod, which is a containerized application in Kubernetes.""\n  }\n]', '[\n  {\n    ""source"": ""kubectl"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""gets"",\n    ""summary_er"": ""Kubernetes command-line tool retrieves information about a running containerized application.""\n  }\n]', '[\n  {\n    ""source"": ""kubia-manual"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""is retrieved by"",\n    ""summary_er"": ""The \'kubia-manual\' command is used to retrieve information about a pod using the \'kubectl get pods\' command.""\n  }\n]', '[\n  {\n    ""source"": ""kubia-manual"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""has a YAML file associated with it"",\n    ""summary_er"": ""The \'kubia-manual\' entity has a YAML file associated with its pod, which is a containerized application.""\n  }\n]', '[{\n  ""source"": ""kubectl create"",\n  ""destination"": ""pod"",\n  ""relation_description"": ""creates"",\n  ""summary_er"": ""The \'kubectl create\' command creates a new pod in Kubernetes, which is a containerized application.""\n}]', '[\n  {\n    ""source"": ""Kubernetes"",\n    ""destination"": ""Docker"",\n    ""relation_description"": ""containerization technology"",\n    ""summary_er"": ""Kubernetes manages containerized applications, leveraging Docker as a container runtime environment.""\n  },\n  {\n    ""source"": ""Machine Learning"",\n    ""destination"": ""Generative AI"",\n    ""relation_description"": ""subfield of AI"",\n    ""summary_er"": ""Machine Learning enables Generative AI models to learn patterns and generate new data, such as images or text.""\n  },\n  {\n    ""source"": ""Natural Language Understanding"",\n    ""destination"": ""Computer Vision"",\n    ""relation_description"": ""complementary AI fields"",\n    ""summary_er"": ""NLU analyzes human language, while Computer Vision interprets visual data from images and videos, both crucial for AI applications.""\n  },\n  {\n    ""source"": ""Kubernetes"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""deployment unit"",\n    ""summary_er"": ""In Kubernetes, a pod is the basic execution unit, representing a set of one or more application containers.""\n  },\n  {\n    ""source"": ""Docker"",\n    ""destination"": ""process\'s standard output"",\n    ""relation_description"": ""output stream"",\n    ""summary_er"": ""Docker container processes write their output to the process\'s standard output, which can be redirected and piped as needed.""\n  }\n]', '[\n  {\n    ""source"": ""kubectl get"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""gets information about"",\n    ""summary_er"": ""Kubectl command retrieves pod details, providing a snapshot of its current state.""\n  },\n  {\n    ""source"": ""kubectl get"",\n    ""destination"": ""Containers"",\n    ""relation_description"": ""gets information about"",\n    ""summary_er"": ""Kubectl command fetches container data, offering insights into their status and configuration.""\n  }\n]', '[\n  {\n    ""source"": ""kubia-zxzij"",\n    ""destination"": ""pod kubia-manual"",\n    ""relation_description"": ""is a container that belongs to"",\n    ""summary_er"": ""Kubia-zxzij is a container running within the pod Kubia-manual.""\n  }\n]', '[\n  {\n    ""source"": ""kubectl get"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""gets information about"",\n    ""summary_er"": ""Kubectl command retrieves pod details, providing a snapshot of its current state.""\n  },\n  {\n    ""source"": ""Node.js"",\n    ""destination"": ""server"",\n    ""relation_description"": ""runs on"",\n    ""summary_er"": ""Node.js is a JavaScript runtime environment that executes server-side logic and provides a scalable solution for web applications.""\n  }\n]', '[{\n  ""source"": ""Standard Error Stream"",\n  ""destination"": ""Pod"",\n  ""relation_description"": ""Output Errors From"",\n  ""summary_er"": ""The standard error stream outputs errors from a pod, allowing for real-time monitoring and troubleshooting.""\n}]']","To create a pod from a YAML file, use kubectl create -f command. After creating the pod, you can retrieve its full YAML or JSON definition using kubectl get po <pod_name> -o yaml/json commands. You can also view application logs by tailing the container's standard output and error streams.","[{'highlight': 'To create the pod from your YAML file, use the kubectl create command: $ kubectl create -f kubia-manual.yaml'}, {'highlight': 'You can ask Kubernetes for the full YAML of the pod using the command: $ kubectl get po kubia-manual -o yaml'}, {'highlight': ""Your pod has been created, but how do you know if it's running? Let's list pods to see their statuses: $ kubectl get pods""}, {'highlight': 'To view the application logs, use the command: $ kubectl logs <pod_name>'}, {'highlight': 'The kubectl create -f command is used for creating any resource (not only pods) from a YAML or JSON file.'}]"
9,98,0,[],"66
CHAPTER 3
Pods: running containers in Kubernetes
writing their logs to files. This is to allow users to view logs of different applications in
a simple, standard way. 
 The container runtime (Docker in your case) redirects those streams to files and
allows you to get the container’s log by running
$ docker logs <container id>
You could use ssh to log into the node where your pod is running and retrieve its logs
with docker logs, but Kubernetes provides an easier way. 
RETRIEVING A POD’S LOG WITH KUBECTL LOGS
To see your pod’s log (more precisely, the container’s log) you run the following com-
mand on your local machine (no need to ssh anywhere):
$ kubectl logs kubia-manual
Kubia server starting...
You haven’t sent any web requests to your Node.js app, so the log only shows a single
log statement about the server starting up. As you can see, retrieving logs of an appli-
cation running in Kubernetes is incredibly simple if the pod only contains a single
container. 
NOTE
Container logs are automatically rotated daily and every time the log file
reaches 10MB in size. The kubectl logs command only shows the log entries
from the last rotation.
SPECIFYING THE CONTAINER NAME WHEN GETTING LOGS OF A MULTI-CONTAINER POD
If your pod includes multiple containers, you have to explicitly specify the container
name by including the -c <container name> option when running kubectl logs. In
your kubia-manual pod, you set the container’s name to kubia, so if additional con-
tainers exist in the pod, you’d have to get its logs like this:
$ kubectl logs kubia-manual -c kubia
Kubia server starting...
Note that you can only retrieve container logs of pods that are still in existence. When
a pod is deleted, its logs are also deleted. To make a pod’s logs available even after the
pod is deleted, you need to set up centralized, cluster-wide logging, which stores all
the logs into a central store. Chapter 17 explains how centralized logging works.
3.2.5
Sending requests to the pod
The pod is now running—at least that’s what kubectl get and your app’s log say. But
how do you see it in action? In the previous chapter, you used the kubectl expose
command to create a service to gain access to the pod externally. You’re not going to
do that now, because a whole chapter is dedicated to services, and you have other ways
of connecting to a pod for testing and debugging purposes. One of them is through
port forwarding.
 
",[],"[{'entity': 'Pods', 'description': 'running containers in Kubernetes', 'category': 'application'}, {'entity': 'container runtime', 'description': ""redirects streams to files and allows getting container's log by running $ docker logs <container id>"", 'category': 'software'}, {'entity': 'Docker', 'description': 'container runtime', 'category': 'software'}, {'entity': '$ docker logs <container id>', 'description': ""command to get container's log"", 'category': 'command'}, {'entity': 'ssh', 'description': 'to log into the node where your pod is running and retrieve its logs with docker logs', 'category': 'process'}, {'entity': 'kubectl logs kubia-manual', 'description': ""command to see pod's log (more precisely, container's log)"", 'category': 'command'}, {'entity': 'Kubia server starting...', 'description': 'log statement about the server starting up', 'category': 'log message'}, {'entity': '-c <container name>', 'description': 'option to specify container name when getting logs of a multi-container pod', 'category': 'flag'}, {'entity': '$ kubectl logs kubia-manual -c kubia', 'description': 'command to get logs of a specific container in a multi-container pod', 'category': 'command'}, {'entity': 'container name', 'description': 'name of the container for which logs are being retrieved', 'category': 'parameter'}, {'entity': 'kubectl expose', 'description': 'command to create a service to gain access to the pod externally', 'category': 'command'}, {'entity': 'port forwarding', 'description': 'method to connect to a pod for testing and debugging purposes', 'category': 'process'}]","[{'source_entity': '""kubectl expose""', 'description': 'exposes a service', 'destination_entity': '""Kubia server starting...""'}, {'source_entity': '""kubectl logs kubia-manual -c kubia""', 'description': 'gets logs from container', 'destination_entity': '""container name""'}, {'source_entity': '""ssh""', 'description': 'connects to a remote server', 'destination_entity': '""Kubia server starting...""'}, {'source_entity': '""kubectl logs kubia-manual""', 'description': 'gets logs from pod', 'destination_entity': '""Pods""'}, {'source_entity': '""$ docker logs <container id>""', 'description': 'gets logs from container', 'destination_entity': '""Docker""'}, {'source_entity': '""port forwarding""', 'description': 'forwards traffic to a port', 'destination_entity': '""Kubia server starting...""'}]","['[\n  {\n    ""source"": ""kubectl"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""exposes a service"",\n    ""summary_er"": ""Exposing Kubia server as a service to be accessed by clients.""\n  },\n  {\n    ""source"": ""Kubia server"",\n    ""destination"": ""server"",\n    ""relation_description"": ""starting..."",\n    ""summary_er"": ""Starting the Kubia server application on a pod.""\n  }\n]', '[\n  {\n    ""source"": ""kubectl"",\n    ""destination"": ""kubia-manual"",\n    ""relation_description"": ""gets logs from container"",\n    ""summary_er"": ""Kubectl command retrieves logs from a specific container within a pod named kubia-manual.""\n  },\n  {\n    ""source"": ""container name"",\n    ""destination"": ""kubia-manual"",\n    ""relation_description"": ""is the name of"",\n    ""summary_er"": ""Container name is an identifier for a running process within the pod kubia-manual.""\n  }\n]', '[\n  {\n    ""source"": ""ssh"",\n    ""destination"": ""remote server"",\n    ""relation_description"": ""connects to"",\n    ""summary_er"": ""SSH connects to a remote server, allowing secure access and management.""\n  },\n  {\n    ""source"": ""Kubia server starting..."",\n    ""destination"": ""pod"",\n    ""relation_description"": ""starting"",\n    ""summary_er"": ""The Kubia server starts within a pod, providing a containerized environment for execution.""\n  }\n]', '[\n  {\n    ""source"": ""kubectl"",\n    ""destination"": ""kubia-manual"",\n    ""relation_description"": ""gets logs from pod"",\n    ""summary_er"": ""Kubectl command retrieves logs from a specific Kubernetes pod named kubia-manual.""\n  }\n]', '[\n  {\n    ""source"": ""docker"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""gets logs from container"",\n    ""summary_er"": ""The Docker command gets logs from a container within a pod, allowing for monitoring and troubleshooting of application execution.""\n  }\n]', '[\n  {\n    ""source"": ""port forwarding"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""forwards traffic to a port"",\n    ""summary_er"": ""Port forwarding establishes a connection between a local machine and a pod, allowing traffic to be forwarded to a specific port within the pod.""\n  },\n  {\n    ""source"": ""Kubia server starting..."",\n    ""destination"": ""pod"",\n    ""relation_description"": ""server startup"",\n    ""summary_er"": ""The Kubia server startup process initializes the server within a pod, making it available for incoming requests and traffic.""\n  }\n]']","This chapter discusses pods in Kubernetes, focusing on retrieving logs from containers running within a pod. The container runtime redirects streams to files, allowing users to view logs by running `docker logs <container id>`. However, Kubernetes provides an easier way using `kubectl logs`, which can be used to retrieve logs from a pod without the need for SSH access. Additionally, if a pod contains multiple containers, the user must specify the container name when retrieving logs. The chapter also touches on centralized logging and port forwarding as methods to connect to a pod for testing and debugging purposes.","[{'highlight': ""You can retrieve a pod's log by running the command $ kubectl logs <pod name> on your local machine, without needing to ssh into the node where the pod is running.""}, {'highlight': 'If a pod includes multiple containers, you must specify the container name using the -c <container name> option when running kubectl logs, e.g., $ kubectl logs kubia-manual -c kubia'}, {'highlight': ""Pod logs are automatically rotated daily and every time the log file reaches 10MB in size, with the kubectl logs command only showing the last rotation's log entries.""}, {'highlight': 'You can only retrieve container logs of pods that are still in existence, as when a pod is deleted, its logs are also deleted.'}, {'highlight': ""To make a pod's logs available even after the pod is deleted, you need to set up centralized, cluster-wide logging, which stores all the logs into a central store (Chapter 17 explains how this works).""}]"
