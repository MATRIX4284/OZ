,page,img_cnt,img_npy_lst,text,tables,entities,relationships,summary_rel,summary,highlights
160,249,0,[],"217
Using Secrets to pass sensitive data to containers
NOTE
You’re creating a generic Secret, but you could also have created a tls
Secret with the kubectl create secret tls command, as you did in chapter 5.
This would create the Secret with different entry names, though.
7.5.4
Comparing ConfigMaps and Secrets
Secrets and ConfigMaps have a pretty big difference. This is what drove Kubernetes
developers to create ConfigMaps after Kubernetes had already supported Secrets for a
while. The following listing shows the YAML of the Secret you created.
$ kubectl get secret fortune-https -o yaml
apiVersion: v1
data:
  foo: YmFyCg==
  https.cert: LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk1JSURCekNDQ...
  https.key: LS0tLS1CRUdJTiBSU0EgUFJJVkFURSBLRVktLS0tLQpNSUlFcE...
kind: Secret
...
Now compare this to the YAML of the ConfigMap you created earlier, which is shown
in the following listing.
$ kubectl get configmap fortune-config -o yaml
apiVersion: v1
data:
  my-nginx-config.conf: |
    server {
      ...
    }
  sleep-interval: |
    25
kind: ConfigMap
...
Notice the difference? The contents of a Secret’s entries are shown as Base64-encoded
strings, whereas those of a ConfigMap are shown in clear text. This initially made
working with Secrets in YAML and JSON manifests a bit more painful, because you
had to encode and decode them when setting and reading their entries. 
USING SECRETS FOR BINARY DATA
The reason for using Base64 encoding is simple. A Secret’s entries can contain binary
values, not only plain-text. Base64 encoding allows you to include the binary data in
YAML or JSON, which are both plain-text formats. 
TIP
You can use Secrets even for non-sensitive binary data, but be aware that
the maximum size of a Secret is limited to 1MB.
Listing 7.21
A Secret’s YAML definition
Listing 7.22
A ConfigMap’s YAML definition
 
",[],"[{'entity': 'Secret', 'description': 'a generic Secret used to pass sensitive data to containers', 'category': 'software'}, {'entity': 'kubectl', 'description': 'a command-line tool for interacting with Kubernetes', 'category': 'application'}, {'entity': 'create secret tls', 'description': 'a command for creating a TLS Secret', 'category': 'command'}, {'entity': 'ConfigMaps', 'description': 'a type of object used to store sensitive data', 'category': 'software'}, {'entity': 'YAML', 'description': 'a human-readable serialization format', 'category': 'format'}, {'entity': 'JSON', 'description': 'a lightweight, text-based data interchange format', 'category': 'format'}, {'entity': 'Base64 encoding', 'description': 'a method for encoding binary data as plain-text', 'category': 'process'}, {'entity': 'binary values', 'description': 'data that is not in plain-text format', 'category': 'software'}, {'entity': '1MB', 'description': 'the maximum size limit of a Secret', 'category': 'hardware'}, {'entity': 'apiVersion', 'description': 'a field in the YAML definition of a Secret or ConfigMap', 'category': 'field'}, {'entity': 'data', 'description': 'a field in the YAML definition of a Secret or ConfigMap', 'category': 'field'}, {'entity': 'foo', 'description': 'an entry name in the Secret', 'category': 'field'}, {'entity': 'https.cert', 'description': 'an entry name in the Secret', 'category': 'field'}, {'entity': 'https.key', 'description': 'an entry name in the Secret', 'category': 'field'}, {'entity': 'my-nginx-config.conf', 'description': 'an entry name in the ConfigMap', 'category': 'field'}, {'entity': 'sleep-interval', 'description': 'an entry name in the ConfigMap', 'category': 'field'}]","[{'source_entity': 'kubectl', 'description': 'uses to create a secret tls', 'destination_entity': 'create secret tls'}, {'source_entity': 'kubectl', 'description': 'utilizes Base64 encoding for https.key', 'destination_entity': 'Base64 encoding'}, {'source_entity': 'kubectl', 'description': 'manipulates my-nginx-config.conf', 'destination_entity': 'my-nginx-config.conf'}, {'source_entity': 'kubectl', 'description': 'configures sleep-interval', 'destination_entity': 'sleep-interval'}, {'source_entity': 'kubectl', 'description': 'handles binary values for Secret', 'destination_entity': 'Secret'}, {'source_entity': 'kubectl', 'description': 'utilizes YAML format for data', 'destination_entity': 'YAML'}, {'source_entity': 'kubectl', 'description': 'utilizes JSON format for ConfigMaps', 'destination_entity': 'JSON'}, {'source_entity': 'kubectl', 'description': 'manipulates 1MB of data in Secret', 'destination_entity': 'Secret'}, {'source_entity': 'kubectl', 'description': 'handles https.cert with Base64 encoding', 'destination_entity': 'Base64 encoding'}]","['[\n  {\n    ""source"": ""kubectl"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""uses to create a secret tls"",\n    ""summary_er"": ""Kubectl uses to create a TLS secret for pods, ensuring secure communication between components.""\n  }\n]', '[\n  {\n    ""source"": ""kubectl"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""utilizes Base64 encoding for https.key"",\n    ""summary_er"": ""Kubectl uses base64 encoding to securely transmit sensitive data, such as API keys, over HTTPS.""\n  },\n  {\n    ""source"": ""Base64 encoding"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""encoding"",\n    ""summary_er"": ""Base64 encoding is used by pods to encode and decode binary data, ensuring secure transmission and storage.""\n  }\n]', '[\n  {\n    ""source"": ""kubectl"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""manipulates"",\n    ""summary_er"": ""Kubectl configures and manages pods by manipulating their configurations.""\n  }\n]', '[\n  {\n    ""source"": ""kubectl"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""configures sleep-interval"",\n    ""summary_er"": ""Kubectl configures a sleep interval for a pod, allowing it to pause execution for a specified duration.""\n  }\n]', '[\n  {\n    ""source"": ""kubectl"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""handles binary values for Secret"",\n    ""summary_er"": ""Kubectl manages binary data for Secrets, ensuring secure storage and retrieval within pod environments.""\n  }\n]', '[\n  {\n    ""source"": ""kubectl"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""utilizes YAML format for data"",\n    ""summary_er"": ""Kubectl uses YAML to manage pod configurations, enabling efficient deployment and management of containerized applications.""\n  }\n]', '[\n  {\n    ""source"": ""kubectl"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""utilizes JSON format for ConfigMaps"",\n    ""summary_er"": ""Kubectl uses JSON format to manage ConfigMaps in pods, enabling efficient configuration management.""\n  }\n]', '[\n  {\n    ""source"": ""kubectl"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""manipulates 1MB of data in Secret"",\n    ""summary_er"": ""Kubectl interacts with a Pod by manipulating 1MB of data stored in a Secret, enabling secure communication and configuration management.""\n  }\n]', '[\n  {\n    ""source"": ""kubectl"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""handles https.cert with Base64 encoding"",\n    ""summary_er"": ""Kubectl uses Base64 encoding to handle HTTPS certificates for pods.""\n  }\n]']","Secrets in Kubernetes can hold sensitive or non-sensitive binary data, which are encoded as Base64 strings. This contrasts with ConfigMaps that store plain-text data. Secrets have a maximum size limit of 1MB and can be used even for non-sensitive binary data.","[{'highlight': 'Secrets and ConfigMaps have different entry formats, with Secrets using Base64-encoded strings and ConfigMaps displaying clear text.'}, {'highlight': 'Base64 encoding allows binary data to be included in YAML or JSON manifests, making it suitable for storing sensitive binary values in Secrets.'}, {'highlight': 'The maximum size of a Secret is limited to 1MB, which may impact its use for non-sensitive binary data.'}, {'highlight': 'Secrets can contain binary values, not just plain-text, and are suitable for storing sensitive or confidential information.'}, {'highlight': 'ConfigMaps display clear text entries, whereas Secrets show Base64-encoded strings in YAML and JSON manifests.'}]"
161,250,0,[],"218
CHAPTER 7
ConfigMaps and Secrets: configuring applications
INTRODUCING THE STRINGDATA FIELD
Because not all sensitive data is in binary form, Kubernetes also allows setting a Secret’s
values through the stringData field. The following listing shows how it’s used.
kind: Secret
apiVersion: v1
stringData:           
  foo: plain text      
data:
  https.cert: LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk1JSURCekNDQ...
  https.key: LS0tLS1CRUdJTiBSU0EgUFJJVkFURSBLRVktLS0tLQpNSUlFcE...
The stringData field is write-only (note: write-only, not read-only). It can only be
used to set values. When you retrieve the Secret’s YAML with kubectl get -o yaml, the
stringData field will not be shown. Instead, all entries you specified in the string-
Data field (such as the foo entry in the previous example) will be shown under data
and will be Base64-encoded like all the other entries. 
READING A SECRET’S ENTRY IN A POD
When you expose the Secret to a container through a secret volume, the value of the
Secret entry is decoded and written to the file in its actual form (regardless if it’s plain
text or binary). The same is also true when exposing the Secret entry through an envi-
ronment variable. In both cases, the app doesn’t need to decode it, but can read the
file’s contents or look up the environment variable value and use it directly.
7.5.5
Using the Secret in a pod
With your fortune-https Secret containing both the cert and key files, all you need to
do now is configure Nginx to use them. 
MODIFYING THE FORTUNE-CONFIG CONFIGMAP TO ENABLE HTTPS
For this, you need to modify the config file again by editing the ConfigMap:
$ kubectl edit configmap fortune-config
After the text editor opens, modify the part that defines the contents of the my-nginx-
config.conf entry so it looks like the following listing.
...
data:
  my-nginx-config.conf: |
    server {
      listen              80;
      listen              443 ssl;
      server_name         www.kubia-example.com;
Listing 7.23
Adding plain text entries to a Secret using the stringData field
Listing 7.24
Modifying the fortune-config ConfigMap’s data
The stringData can be used 
for non-binary Secret data.
See, “plain text” is not Base64-encoded.
 
",[],"[{'entity': 'ConfigMaps', 'description': 'a way to store and manage application configuration data', 'category': 'software'}, {'entity': 'Secrets', 'description': 'a way to store sensitive information, such as passwords or certificates', 'category': 'software'}, {'entity': 'stringData field', 'description': 'a write-only field in a Secret that allows setting values through plain text', 'category': 'software'}, {'entity': 'kubectl', 'description': 'a command-line tool for managing Kubernetes resources', 'category': 'application'}, {'entity': 'apiVersion', 'description': 'a field in a Kubernetes resource that specifies the API version', 'category': 'software'}, {'entity': 'kind', 'description': 'a field in a Kubernetes resource that specifies the type of resource', 'category': 'software'}, {'entity': 'data', 'description': 'a field in a Secret that stores sensitive information', 'category': 'software'}, {'entity': 'foo', 'description': 'an example entry in the stringData field', 'category': 'software'}, {'entity': 'https.cert', 'description': 'a certificate stored in a Secret', 'category': 'software'}, {'entity': 'https.key', 'description': 'a key stored in a Secret', 'category': 'software'}, {'entity': 'Base64-encoded', 'description': 'a way to encode binary data for storage', 'category': 'software'}, {'entity': 'pod', 'description': 'a lightweight and portable container that can run a single application', 'category': 'container'}, {'entity': 'secret volume', 'description': 'a way to expose a Secret to a container through a file', 'category': 'software'}, {'entity': 'environment variable', 'description': 'a way to expose a Secret to a container through a variable', 'category': 'software'}, {'entity': 'Nginx', 'description': 'a web server software', 'category': 'application'}, {'entity': 'fortune-https Secret', 'description': 'a Secret containing certificates and keys for HTTPS', 'category': 'software'}, {'entity': 'ConfigMap', 'description': 'a way to store and manage application configuration data', 'category': 'software'}, {'entity': 'fortune-config ConfigMap', 'description': 'a specific ConfigMap used in the example', 'category': 'software'}, {'entity': 'my-nginx-config.conf', 'description': 'a configuration file for Nginx', 'category': 'file'}]","[{'source_entity': 'kubectl', 'description': 'used to create a ConfigMap', 'destination_entity': 'ConfigMaps'}, {'source_entity': 'kubectl', 'description': 'used to reference environment variables', 'destination_entity': 'environment variable'}, {'source_entity': 'ConfigMaps', 'description': 'can be used as a secret volume', 'destination_entity': 'secret volume'}, {'source_entity': 'Nginx', 'description': 'configured using a ConfigMap', 'destination_entity': 'ConfigMaps'}, {'source_entity': 'fortune-https Secret', 'description': 'used as a secret volume for Nginx', 'destination_entity': 'Nginx'}, {'source_entity': 'my-nginx-config.conf', 'description': 'configured using a ConfigMap', 'destination_entity': 'ConfigMaps'}, {'source_entity': 'fortune-config ConfigMap', 'description': 'used to configure Nginx', 'destination_entity': 'Nginx'}, {'source_entity': 'https.cert', 'description': 'used as a secret volume for Nginx', 'destination_entity': 'Nginx'}, {'source_entity': 'pod', 'description': 'can reference environment variables', 'destination_entity': 'environment variable'}]","['[\n  {\n    ""source"": ""kubectl"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""used to create a ConfigMap"",\n    ""summary_er"": ""kubectl is used to create a ConfigMap which can be referenced by a pod for configuration purposes.""\n  }\n]', '[\n  {\n    ""source"": ""kubectl"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""used to reference environment variables"",\n    ""summary_er"": ""Kubectl uses environment variables to reference pod settings, allowing for dynamic configuration and flexibility in deployment.""\n  }\n]', '[\n  {\n    ""source"": ""ConfigMaps"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""can be used as a secret volume"",\n    ""summary_er"": ""ConfigMaps can be mounted as a secret volume to pods, providing secure storage for sensitive data.""\n  }\n]', '[\n  {\n    ""source"": ""Nginx"",\n    ""destination"": ""ConfigMaps"",\n    ""relation_description"": ""configured using a ConfigMap"",\n    ""summary_er"": ""Nginx is configured using a ConfigMap to manage its configuration, providing a flexible and scalable way to deploy the web server.""\n  }\n]', '[\n  {\n    ""source"": ""fortune-https Secret"",\n    ""destination"": ""Nginx"",\n    ""relation_description"": ""used as a secret volume"",\n    ""summary_er"": ""The fortune-https Secret is used to provide sensitive information to the Nginx pod, ensuring secure configuration.""\n  }\n]', '[\n  {\n    ""source"": ""my-nginx-config.conf"",\n    ""destination"": ""ConfigMaps"",\n    ""relation_description"": ""configured using a ConfigMap"",\n    ""summary_er"": ""The my-nginx-config.conf file is configured using a ConfigMap, which provides a way to manage and store configuration data for the pod.""\n  }\n]', '[\n  {\n    ""source"": ""fortune-config"",\n    ""destination"": ""ConfigMap"",\n    ""relation_description"": ""used to configure Nginx"",\n    ""summary_er"": ""The fortune-config ConfigMap provides configuration settings for the Nginx pod, enabling it to function correctly.""\n  },\n  {\n    ""source"": ""fortune-config"",\n    ""destination"": ""Nginx"",\n    ""relation_description"": ""configured by"",\n    ""summary_er"": ""The fortune-config ConfigMap is used to configure the Nginx pod with necessary settings for operation.""\n  }\n]', '[\n  {\n    ""source"": ""https://cert"",\n    ""destination"": ""Nginx"",\n    ""relation_description"": ""used as a secret volume"",\n    ""summary_er"": ""The https cert is used as a secret volume for Nginx pod to securely serve HTTPS traffic.""\n  }\n]', '[\n  {\n    ""source"": ""pod"",\n    ""destination"": ""environment variable"",\n    ""relation_description"": ""can reference"",\n    ""summary_er"": ""A pod can reference an environment variable to access its value.""\n  }\n]']","Kubernetes allows setting Secret values through the stringData field, which is write-only and will be shown under data when retrieved. Secrets are decoded and written to files or environment variables in their actual form, allowing apps to read them directly without decoding.","[{'highlight': 'Kubernetes allows setting a Secret’s values through the stringData field for non-binary sensitive data.'}, {'highlight': 'The stringData field is write-only and can only be used to set values, which will be Base64-encoded when retrieved with kubectl get -o yaml.'}, {'highlight': 'When exposing a Secret entry through a secret volume or environment variable in a pod, the value is decoded and written in its actual form.'}, {'highlight': ""To use a Secret containing cert and key files in a pod, configure Nginx to use them by modifying the ConfigMap's data.""}, {'highlight': 'The stringData field can be used for plain text entries in a Secret, which will not be Base64-encoded when retrieved.'}]"
162,251,0,[],"219
Using Secrets to pass sensitive data to containers
      ssl_certificate     certs/https.cert;           
      ssl_certificate_key certs/https.key;            
      ssl_protocols       TLSv1 TLSv1.1 TLSv1.2;
      ssl_ciphers         HIGH:!aNULL:!MD5;
      location / {
        root   /usr/share/nginx/html;
        index  index.html index.htm;
      }
    }
  sleep-interval: |
...
This configures the server to read the certificate and key files from /etc/nginx/certs,
so you’ll need to mount the secret volume there. 
MOUNTING THE FORTUNE-HTTPS SECRET IN A POD
Next, you’ll create a new fortune-https pod and mount the secret volume holding
the certificate and key into the proper location in the web-server container, as shown
in the following listing.
apiVersion: v1
kind: Pod
metadata:
  name: fortune-https
spec:
  containers:
  - image: luksa/fortune:env
    name: html-generator
    env:
    - name: INTERVAL
      valueFrom: 
        configMapKeyRef:
          name: fortune-config
          key: sleep-interval
    volumeMounts:
    - name: html
      mountPath: /var/htdocs
  - image: nginx:alpine
    name: web-server
    volumeMounts:
    - name: html
      mountPath: /usr/share/nginx/html
      readOnly: true
    - name: config
      mountPath: /etc/nginx/conf.d
      readOnly: true
    - name: certs                         
      mountPath: /etc/nginx/certs/        
      readOnly: true                      
    ports:
    - containerPort: 80
Listing 7.25
YAML definition of the fortune-https pod: fortune-pod-https.yaml
The paths are 
relative to /etc/nginx.
You configured Nginx to read the cert and 
key file from /etc/nginx/certs, so you need 
to mount the Secret volume there.
 
",[],"[{'entity': 'ssl_certificate', 'description': 'SSL certificate file', 'category': 'software'}, {'entity': 'certs/https.cert', 'description': 'Path to SSL certificate file', 'category': 'hardware'}, {'entity': 'ssl_certificate_key', 'description': 'SSL key file', 'category': 'software'}, {'entity': 'certs/https.key', 'description': 'Path to SSL key file', 'category': 'hardware'}, {'entity': 'ssl_protocols', 'description': 'Supported SSL protocols', 'category': 'software'}, {'entity': 'TLSv1 TLSv1.1 TLSv1.2', 'description': 'List of supported SSL protocols', 'category': 'hardware'}, {'entity': 'ssl_ciphers', 'description': 'Supported SSL ciphers', 'category': 'software'}, {'entity': 'HIGH:!aNULL:!MD5', 'description': 'List of supported SSL ciphers', 'category': 'hardware'}, {'entity': 'location /', 'description': 'Nginx configuration directive', 'category': 'software'}, {'entity': '/usr/share/nginx/html', 'description': 'Path to document root directory', 'category': 'hardware'}, {'entity': 'root', 'description': 'Nginx configuration directive', 'category': 'software'}, {'entity': 'index.html index.htm', 'description': 'List of index files', 'category': 'hardware'}, {'entity': 'sleep-interval', 'description': 'Environment variable for sleep interval', 'category': 'software'}, {'entity': '/etc/nginx/certs', 'description': 'Path to secret volume holding certificate and key files', 'category': 'hardware'}, {'entity': 'fortune-https', 'description': 'Name of the pod', 'category': 'software'}, {'entity': 'apiVersion: v1', 'description': 'Kubernetes API version', 'category': 'software'}, {'entity': 'kind: Pod', 'description': 'Type of Kubernetes resource', 'category': 'hardware'}, {'entity': 'metadata', 'description': 'Metadata for the pod', 'category': 'software'}, {'entity': 'name: fortune-https', 'description': 'Name of the pod', 'category': 'hardware'}, {'entity': 'spec', 'description': 'Specification for the pod', 'category': 'software'}, {'entity': 'containers', 'description': 'List of containers in the pod', 'category': 'hardware'}, {'entity': 'image: luksa/fortune:env', 'description': 'Image for the html-generator container', 'category': 'software'}, {'entity': 'html-generator', 'description': 'Name of the html-generator container', 'category': 'hardware'}, {'entity': 'env', 'description': 'Environment variables for the html-generator container', 'category': 'software'}, {'entity': 'INTERVAL', 'description': 'Environment variable for sleep interval', 'category': 'hardware'}, {'entity': 'valueFrom', 'description': 'Source of the environment variable value', 'category': 'software'}, {'entity': 'configMapKeyRef', 'description': 'Reference to a config map key', 'category': 'hardware'}, {'entity': 'fortune-config', 'description': 'Name of the config map', 'category': 'software'}, {'entity': 'sleep-interval', 'description': 'Key for the sleep interval value in the config map', 'category': 'hardware'}, {'entity': 'volumeMounts', 'description': 'List of volume mounts for the html-generator container', 'category': 'software'}, {'entity': 'html', 'description': 'Name of the volume mount', 'category': 'hardware'}, {'entity': '/var/htdocs', 'description': 'Path to the mounted volume', 'category': 'software'}, {'entity': 'mountPath', 'description': 'Path where the volume is mounted', 'category': 'hardware'}, {'entity': 'readOnly: true', 'description': 'Flag indicating whether the volume is read-only', 'category': 'software'}, {'entity': 'ports', 'description': 'List of ports exposed by the web-server container', 'category': 'hardware'}, {'entity': 'containerPort: 80', 'description': 'Exposed port for the web-server container', 'category': 'software'}]","[{'source_entity': 'apiVersion: v1', 'description': 'defines the API version for the Kubernetes resource', 'destination_entity': 'kind: Pod'}, {'source_entity': 'kind: Pod', 'description': 'specifies the type of Kubernetes resource', 'destination_entity': 'metadata'}, {'source_entity': 'metadata', 'description': 'provides metadata for the Kubernetes resource', 'destination_entity': 'containers'}, {'source_entity': 'containers', 'description': 'defines a container within the Pod', 'destination_entity': 'image: luksa/fortune:env'}, {'source_entity': 'image: luksa/fortune:env', 'description': 'specifies the Docker image to use for the container', 'destination_entity': 'containerPort: 80'}, {'source_entity': 'containerPort: 80', 'description': 'exposes a port from the container', 'destination_entity': '/usr/share/nginx/html'}, {'source_entity': '/usr/share/nginx/html', 'description': 'defines the directory to serve as the web root', 'destination_entity': 'ssl_ciphers'}, {'source_entity': 'ssl_ciphers', 'description': 'specifies the SSL/TLS ciphers to use', 'destination_entity': 'certs/https.key'}, {'source_entity': 'certs/https.key', 'description': 'defines the path to the SSL/TLS key file', 'destination_entity': 'ssl_protocols'}, {'source_entity': 'ssl_protocols', 'description': 'specifies the supported SSL/TLS protocols', 'destination_entity': 'TLSv1 TLSv1.1 TLSv1.2'}, {'source_entity': 'TLSv1 TLSv1.1 TLSv1.2', 'description': 'defines the supported SSL/TLS protocols', 'destination_entity': '/etc/nginx/certs'}, {'source_entity': '/etc/nginx/certs', 'description': 'defines the directory to store SSL/TLS certificates', 'destination_entity': 'configMapKeyRef'}, {'source_entity': 'configMapKeyRef', 'description': 'references a ConfigMap key', 'destination_entity': 'ssl_certificate_key'}, {'source_entity': 'ssl_certificate_key', 'description': 'defines the path to the SSL/TLS certificate key file', 'destination_entity': 'fortune-config'}, {'source_entity': 'fortune-config', 'description': 'defines configuration for the fortune service', 'destination_entity': 'html-generator'}, {'source_entity': 'html-generator', 'description': 'generates HTML content for the service', 'destination_entity': '/var/htdocs'}, {'source_entity': '/var/htdocs', 'description': 'defines the directory to store generated HTML content', 'destination_entity': 'location /'}, {'source_entity': 'location /', 'description': 'defines the location for the Nginx configuration', 'destination_entity': 'ssl_certificate'}, {'source_entity': 'ssl_certificate', 'description': 'defines the path to the SSL/TLS certificate file', 'destination_entity': 'HIGH:!aNULL:!MD5'}, {'source_entity': 'HIGH:!aNULL:!MD5', 'description': 'specifies the SSL/TLS cipher suite to use', 'destination_entity': 'ssl_certificate_key'}, {'source_entity': 'ssl_certificate_key', 'description': 'defines the path to the SSL/TLS certificate key file', 'destination_entity': 'fortune-https'}, {'source_entity': 'fortune-https', 'description': 'defines configuration for the fortune HTTPS service', 'destination_entity': 'spec'}, {'source_entity': 'spec', 'description': 'defines the specification for the Pod', 'destination_entity': 'containers'}, {'source_entity': 'containers', 'description': 'defines a container within the Pod', 'destination_entity': 'volumeMounts'}, {'source_entity': 'volumeMounts', 'description': 'defines volume mounts for the container', 'destination_entity': '/usr/share/nginx/html'}, {'source_entity': '/usr/share/nginx/html', 'description': 'defines the directory to serve as the web root', 'destination_entity': 'sleep-interval'}, {'source_entity': 'sleep-interval', 'description': 'defines the sleep interval for the service', 'destination_entity': 'INTERVAL'}, {'source_entity': 'INTERVAL', 'description': 'specifies the interval between updates', 'destination_entity': 'index.html index.htm'}, {'source_entity': 'index.html index.htm', 'description': 'defines the files to serve as the web root', 'destination_entity': 'fortune-https'}]","['[\n  {\n    ""source"": ""apiVersion"",\n    ""destination"": ""Pod"",\n    ""relation_description"": ""defines the API version for the Kubernetes resource"",\n    ""summary_er"": ""API version defines the format of the Kubernetes resource, ensuring compatibility and consistency.""\n  }\n]', '[\n  {\n    ""source"": ""Pod"",\n    ""destination"": ""metadata"",\n    ""relation_description"": ""specifies the type of Kubernetes resource"",\n    ""summary_er"": ""The Pod kind specifies the type of Kubernetes resource, which is used to identify and manage pods in a cluster.""\n  }\n]', '[\n  {\n    ""source"": ""metadata"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""provides metadata for the Kubernetes resource"",\n    ""summary_er"": ""Metadata provides essential information about a Kubernetes pod, including labels, annotations, and other details.""\n  },\n  {\n    ""source"": ""containers"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""contains one or more containers"",\n    ""summary_er"": ""A pod can contain multiple containers, each running an application or service within the shared resources of the pod.""\n  }\n]', '[\n  {\n    ""source"": ""containers"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""defines a container within the Pod"",\n    ""summary_er"": ""A container is defined within a pod, allowing for multiple containers to run in a single unit.""\n  },\n  {\n    ""source"": ""image"",\n    ""destination"": ""luksa/fortune:env"",\n    ""relation_description"": ""the relation description was not provided, assuming it\'s the image name"",\n    ""summary_er"": ""The image \'luksa/fortune:env\' is used to create a container.""\n  }\n]', '[\n    {\n        ""source"": ""image"",\n        ""destination"": ""pod"",\n        ""relation_description"": ""specifies the Docker image to use for the container"",\n        ""summary_er"": ""The Docker image \'luksa/fortune:env\' is used to create a pod.""\n    },\n    {\n        ""source"": ""containerPort"",\n        ""destination"": ""pod"",\n        ""relation_description"": ""exposes port 80 from the container"",\n        ""summary_er"": ""Port 80 is exposed from the container in the pod.""\n    }\n]', '[\n    {\n        ""source"": ""/usr/share/nginx/html"",\n        ""destination"": ""pod"",\n        ""relation_description"": ""exposes a port from the container"",\n        ""summary_er"": ""The source entity, /usr/share/nginx/html, exposes a port from the container to the destination pod.""\n    },\n    {\n        ""source"": ""containerPort: 80"",\n        ""destination"": ""/usr/share/nginx/html"",\n        ""relation_description"": ""the relation description: exposes a port from the container"",\n        ""summary_er"": ""The source entity, containerPort: 80, is related to the destination entity, /usr/share/nginx/html, through exposing a port from the container.""\n    }\n]', '[\n  {\n    ""source"": ""/usr/share/nginx/html"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""defines the directory to serve as the web root"",\n    ""summary_er"": ""/usr/share/nginx/html defines the web root for a pod, serving HTML content.""\n  },\n  {\n    ""source"": ""ssl_ciphers"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""configures SSL/TLS ciphers for secure communication"",\n    ""summary_er"": ""ssl_ciphers configures secure communication protocols for a pod, ensuring encrypted data transfer.""\n  }\n]', '[\n  {\n    ""source"": ""ssl_ciphers"",\n    ""destination"": ""certs/https.key"",\n    ""relation_description"": ""specifies the SSL/TLS ciphers to use"",\n    ""summary_er"": ""Configures SSL/TLS cipher suite for HTTPS key, ensuring secure communication between client and server.""\n  }\n]', '[{""source"": ""certs/https.key"", ""destination"": ""pod"", ""relation_description"": ""defines the path to the SSL/TLS key file"", ""summary_er"": ""The SSL/TLS key file path is defined for a pod.""}, {""source"": ""ssl_protocols"", ""destination"": ""pod"", ""relation_description"": ""defines the allowed SSL/TLS protocols"", ""summary_er"": ""Allowed SSL/TLS protocols are defined for a pod.""}]', '[\n  {\n    ""source"": ""ssl_protocols"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""specifies the supported SSL/TLS protocols"",\n    ""summary_er"": ""This configuration specifies the supported Transport Layer Security (TLS) versions for a pod, ensuring secure communication with clients.""\n  }\n]', '[\n  {\n    ""source"": ""/etc/nginx/certs"",\n    ""destination"": ""TLSv1 TLSv1.1 TLSv1.2"",\n    ""relation_description"": ""defines the supported SSL/TLS protocols"",\n    ""summary_er"": ""/etc/nginx/certs defines the supported SSL/TLS protocols for TLSv1, TLSv1.1, and TLSv1.2.""\n  }\n]', '[\n  {\n    ""source"": ""/etc/nginx/certs"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""configMapKeyRef"",\n    ""summary_er"": ""/etc/nginx/certs defines a directory to store SSL/TLS certificates, referenced by a pod using configMapKeyRef.""\n  }\n]', '[\n  {\n    ""source"": ""ConfigMap"",\n    ""destination"": ""Pod"",\n    ""relation_description"": ""ssl_certificate_key"",\n    ""summary_er"": ""A ConfigMap references a key in an SSL certificate for use by a Pod.""\n  }\n]', '[\n  {\n    ""source"": ""ssl_certificate_key"",\n    ""destination"": ""fortune-config"",\n    ""relation_description"": ""defines the path to the SSL/TLS certificate key file"",\n    ""summary_er"": ""The ssl_certificate_key configures the path to the SSL/TLS certificate key file for the fortune-config pod.""\n  }\n]', '[\n  {\n    ""source"": ""fortune-config"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""defines configuration"",\n    ""summary_er"": ""Defines configuration for the Fortune Service, used by a Pod.""\n  },\n  {\n    ""source"": ""fortune-config"",\n    ""destination"": ""html-generator"",\n    ""relation_description"": ""configures html generation"",\n    ""summary_er"": ""Configures HTML generation for the Fortune Service, utilizing the Html Generator component.""\n  }\n]', '[\n  {\n    ""source"": ""html-generator"",\n    ""destination"": ""/var/htdocs"",\n    ""relation_description"": ""generates HTML content for the service"",\n    ""summary_er"": ""HTML generator service stores generated content in /var/htdocs directory.""\n  }\n]', '[\n  {\n    ""source"": ""/var/htdocs"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""defines the directory to store generated HTML content"",\n    ""summary_er"": ""/var/htdocs defines a directory for pod-generated HTML content.""\n  }\n]', '[\n  {\n    ""source"": ""/"",\n    ""destination"": ""Nginx configuration"",\n    ""relation_description"": ""defines the location"",\n    ""summary_er"": ""The root directory \'/\' defines the location for Nginx configuration.""\n  },\n  {\n    ""source"": ""pod"",\n    ""destination"": ""ssl_certificate"",\n    ""relation_description"": ""related to"",\n    ""summary_er"": ""A pod is related to an ssl_certificate, which provides secure connections.""\n  }\n]', '[\n  {\n    ""source"": ""ssl_certificate"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""defines the path to the SSL/TLS certificate file"",\n    ""summary_er"": ""SSL/TLS certificate file path defined for pod security""\n  },\n  {\n    ""source"": ""HIGH:!aNULL:!MD5"",\n    ""destination"": ""ssl_certificate"",\n    ""relation_description"": ""cipher suite and hash algorithm restrictions"",\n    ""summary_er"": ""Cipher suite and hash algorithm restrictions applied to ssl_certificate""\n  }\n]', '[\n  {\n    ""source"": ""HIGH"",\n    ""destination"": ""!aNULL:!MD5"",\n    ""relation_description"": ""specifies the SSL/TLS cipher suite to use"",\n    ""summary_er"": ""This configuration option specifies the SSL/TLS cipher suite to be used, excluding MD5 and aNULL ciphers.""\n  },\n  {\n    ""source"": ""!aNULL:!MD5"",\n    ""destination"": ""ssl_certificate_key"",\n    ""relation_description"": ""specifies the SSL/TLS cipher suite to use"",\n    ""summary_er"": ""The ssl_certificate_key is related to the exclusion of MD5 and aNULL ciphers in the SSL/TLS cipher suite.""\n  }\n]', '[\n  {\n    ""source"": ""ssl_certificate_key"",\n    ""destination"": ""fortune-https"",\n    ""relation_description"": ""defines the path to the SSL/TLS certificate key file"",\n    ""summary_er"": ""Configures the SSL/TLS certificate key for the fortune-https pod, specifying the file path.""\n  }\n]', '[\n  {\n    ""source"": ""fortune-https"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""defines configuration"",\n    ""summary_er"": ""Defines configuration for the Fortune HTTPS service within a Pod\'s specification.""\n  }\n]', '[\n  {\n    ""source"": ""spec"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""defines the specification for the Pod"",\n    ""summary_er"": ""The spec entity defines the configuration details of a Pod, including its containers and settings.""\n  },\n  {\n    ""source"": ""spec"",\n    ""destination"": ""containers"",\n    ""relation_description"": ""defines the specification for the Pod"",\n    ""summary_er"": ""The spec entity outlines the container(s) that make up a Pod, including their images and configurations.""\n  }\n]', '[\n  {\n    ""source"": ""containers"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""defines a container within the Pod"",\n    ""summary_er"": ""A container is defined within a pod, allowing for multiple containers to run together in a single unit.""\n  },\n  {\n    ""source"": ""volumeMounts"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""mounts a volume within the Pod"",\n    ""summary_er"": ""A volume is mounted within a pod, providing shared storage and access to files across multiple containers.""\n  }\n]', '[\n  {\n    ""source"": ""/usr/share/nginx/html"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""volumeMounts"",\n    ""summary_er"": ""The source entity /usr/share/nginx/html defines a volume mount for the container within the pod.""\n  }\n]', '[\n  {\n    ""source"": ""/usr/share/nginx/html"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""defines the directory to serve as the web root"",\n    ""summary_er"": ""/usr/share/nginx/html defines the web root for a pod, serving static content from this directory.""\n  },\n  {\n    ""source"": ""sleep-interval"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""sleep interval"",\n    ""summary_er"": ""sleep-interval is a parameter that controls how often a pod sleeps or idles, affecting its resource utilization and responsiveness.""\n  }\n]', '[\n  {\n    ""source"": ""sleep-interval"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""defines the sleep interval for the service"",\n    ""summary_er"": ""The sleep-interval defines the duration a pod sleeps before being restarted.""\n  }\n]', '[\n  {\n    ""source"": ""INTERVAL"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""specifies the interval between updates"",\n    ""summary_er"": ""The INTERVAL relation specifies how often a pod should be updated, ensuring timely and efficient deployment of resources.""\n  },\n  {\n    ""source"": ""index.html"",\n    ""destination"": ""index.htm"",\n    ""relation_description"": ""file extension"",\n    ""summary_er"": ""Index.html and index.htm are file extensions used to identify HTML files, with the primary difference being the specific version or syntax used.""\n  }\n]', '[\n  {\n    ""source"": ""index.html"",\n    ""destination"": ""fortune-https"",\n    ""relation_description"": ""defines the files to serve as the web root"",\n    ""summary_er"": ""The index.html file serves as the web root for the fortune-https pod, defining the files to be served.""\n  }\n]']","This document explains how to pass sensitive data (SSL certificates) to a container using Kubernetes secrets. It shows an example of mounting a secret volume in a pod, specifically for a fortune-https pod that uses Nginx and mounts the certificate and key files from a secret volume at /etc/nginx/certs.",[{'highlight': 'Using Secrets to pass sensitive data to containers'}]
163,252,0,[],"220
CHAPTER 7
ConfigMaps and Secrets: configuring applications
    - containerPort: 443
  volumes:
  - name: html
    emptyDir: {}
  - name: config
    configMap:
      name: fortune-config
      items:
      - key: my-nginx-config.conf
        path: https.conf
  - name: certs                            
    secret:                                
      secretName: fortune-https            
Much is going on in this pod descriptor, so let me help you visualize it. Figure 7.12
shows the components defined in the YAML. The default-token Secret, volume, and
volume mount, which aren’t part of the YAML, but are added to your pod automati-
cally, aren’t shown in the figure.
NOTE
Like configMap volumes, secret volumes also support specifying file
permissions for the files exposed in the volume through the defaultMode
property.
You define the secret 
volume here, referring to 
the fortune-https Secret.
Container: web-server
Container: html-generator
Secret: fortune-https
Default token Secret and volume not shown
secret
volume:
certs
emptyDir
volume:
html
conﬁgMap
volume:
conﬁg
https.cert
...
...
...
https.key
foo
/etc/nginx/conf.d/
/etc/nginx/certs/
/usr/share/nginx/html/
/var/htdocs
ConﬁgMap: fortune-conﬁg
my-nginx-conﬁg.conf
server {
…
}
Pod
Environment variables:
INTERVAL=25
sleep-interval
25
Figure 7.12
Combining a ConfigMap and a Secret to run your fortune-https pod
 
","[  my-nginx-config.conf server {\n…\n}
0       sleep-interval             25,   https.cert  ...
0  https.key  ...
1        foo  ...]","[{'entity': 'containerPort', 'description': 'a port number for a container', 'category': 'software'}, {'entity': 'volumes', 'description': 'a list of volumes attached to a pod', 'category': 'software'}, {'entity': 'emptyDir', 'description': 'a type of volume that stores data in memory', 'category': 'software'}, {'entity': 'configMap', 'description': 'a way to store and reference configuration files', 'category': 'software'}, {'entity': 'items', 'description': 'a list of key-value pairs for a configMap', 'category': 'software'}, {'entity': 'key', 'description': 'a unique identifier for a configMap item', 'category': 'software'}, {'entity': 'path', 'description': 'the file path for a configMap item', 'category': 'software'}, {'entity': 'secret', 'description': 'a way to store and reference sensitive data', 'category': 'software'}, {'entity': 'defaultMode', 'description': 'a property that sets the default permissions for secret files', 'category': 'software'}, {'entity': 'volume', 'description': 'a storage unit attached to a pod', 'category': 'hardware'}, {'entity': 'mount', 'description': 'the process of attaching a volume to a container', 'category': 'software'}, {'entity': 'web-server', 'description': 'a container that serves web content', 'category': 'application'}, {'entity': 'html-generator', 'description': 'a container that generates HTML content', 'category': 'application'}, {'entity': 'fortune-https', 'description': 'a Secret that stores HTTPS certificates and keys', 'category': 'software'}, {'entity': 'default-token', 'description': 'a Secret that provides a default token for authentication', 'category': 'software'}, {'entity': 'pod', 'description': 'a logical unit of execution in Kubernetes', 'category': 'application'}, {'entity': 'environment variables', 'description': 'variables set by the operating system or container runtime', 'category': 'software'}, {'entity': 'INTERVAL', 'description': 'an environment variable that sets a sleep interval', 'category': 'software'}, {'entity': 'sleep-interval', 'description': 'a value for the INTERVAL environment variable', 'category': 'software'}]","[{'source_entity': 'path', 'description': 'specifies the path to a configuration file', 'destination_entity': 'configMap'}]","['[\n  {\n    ""source"": ""path"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""specifies the path to a configuration file"",\n    ""summary_er"": ""The path relation specifies the location of a configuration file for a pod, allowing it to access and utilize the file\'s contents.""\n  },\n  {\n    ""source"": ""configMap"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""configuration data stored in a configMap can be used by a pod"",\n    ""summary_er"": ""A configMap stores configuration data that can be accessed and utilized by a pod, enabling it to function correctly.""\n  }\n]']","A Kubernetes pod is configured using a ConfigMap and a Secret, with the ConfigMap providing application configuration and the Secret providing sensitive data such as SSL certificates. The ConfigMap and Secret are referenced in the pod descriptor through their respective names, with file permissions specified for the Secret files.","[{'highlight': 'ConfigMaps and Secrets are used to configure applications in Kubernetes.'}, {'highlight': 'A ConfigMap volume can be specified with file permissions using the defaultMode property.'}, {'highlight': 'Secret volumes support specifying file permissions for files exposed in the volume.'}, {'highlight': 'The fortune-https Secret is referenced as a secret volume in the pod descriptor.'}, {'highlight': 'ConfigMaps and Secrets are used together to run the fortune-https pod.'}]"
164,253,0,[],"221
Using Secrets to pass sensitive data to containers
TESTING WHETHER NGINX IS USING THE CERT AND KEY FROM THE SECRET
Once the pod is running, you can see if it’s serving HTTPS traffic by opening a port-
forward tunnel to the pod’s port 443 and using it to send a request to the server
with curl: 
$ kubectl port-forward fortune-https 8443:443 &
Forwarding from 127.0.0.1:8443 -> 443
Forwarding from [::1]:8443 -> 443
$ curl https://localhost:8443 -k
If you configured the server properly, you should get a response. You can check the
server’s certificate to see if it matches the one you generated earlier. This can also be
done with curl by turning on verbose logging using the -v option, as shown in the fol-
lowing listing.
$ curl https://localhost:8443 -k -v
* About to connect() to localhost port 8443 (#0)
*   Trying ::1...
* Connected to localhost (::1) port 8443 (#0)
* Initializing NSS with certpath: sql:/etc/pki/nssdb
* skipping SSL peer certificate verification
* SSL connection using TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384
* Server certificate:
*   subject: CN=www.kubia-example.com          
*   start date: aug 16 18:43:13 2016 GMT       
*   expire date: aug 14 18:43:13 2026 GMT      
*   common name: www.kubia-example.com         
*   issuer: CN=www.kubia-example.com           
UNDERSTANDING SECRET VOLUMES ARE STORED IN MEMORY
You successfully delivered your certificate and private key to your container by mount-
ing a secret volume in its directory tree at /etc/nginx/certs. The secret volume uses
an in-memory filesystem (tmpfs) for the Secret files. You can see this if you list mounts
in the container:
$ kubectl exec fortune-https -c web-server -- mount | grep certs
tmpfs on /etc/nginx/certs type tmpfs (ro,relatime) 
Because tmpfs is used, the sensitive data stored in the Secret is never written to disk,
where it could be compromised. 
EXPOSING A SECRET’S ENTRIES THROUGH ENVIRONMENT VARIABLES
Instead of using a volume, you could also have exposed individual entries from the
secret as environment variables, the way you did with the sleep-interval entry from
the ConfigMap. For example, if you wanted to expose the foo key from your Secret as
environment variable FOO_SECRET, you’d add the snippet from the following listing to
the container definition.
Listing 7.26
Displaying the server certificate sent by Nginx
The certificate 
matches the one you 
created and stored 
in the Secret.
 
",[],"[{'entity': 'Secrets', 'description': 'pass sensitive data to containers', 'category': 'software'}, {'entity': 'Nginx', 'description': 'web server', 'category': 'application'}, {'entity': 'kubectl', 'description': 'command-line tool for managing Kubernetes clusters', 'category': 'software'}, {'entity': 'port-forward', 'description': ""tunneling traffic from a local port to a pod's port"", 'category': 'process'}, {'entity': 'curl', 'description': 'command-line tool for transferring data with URLs', 'category': 'software'}, {'entity': 'HTTPS', 'description': 'secure communication protocol', 'category': 'protocol'}, {'entity': 'TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384', 'description': 'encryption algorithm', 'category': 'algorithm'}, {'entity': 'tmpfs', 'description': 'in-memory filesystem', 'category': 'filesystem'}, {'entity': 'Secret volume', 'description': ""mounting a Secret in a container's directory tree"", 'category': 'process'}, {'entity': 'ConfigMap', 'description': 'configuration data stored as key-value pairs', 'category': 'software'}, {'entity': 'environment variables', 'description': 'exposing individual entries from a Secret as environment variables', 'category': 'process'}, {'entity': 'FOO_SECRET', 'description': 'environment variable exposing the foo key from a Secret', 'category': 'variable'}]","[{'source_entity': '""kubectl""', 'description': 'used to manage and deploy applications', 'destination_entity': '""Nginx""'}, {'source_entity': '""environment variables""', 'description': 'configured for Nginx deployment', 'destination_entity': '""Nginx""'}, {'source_entity': '""HTTPS""', 'description': 'enabled for secure communication', 'destination_entity': '""Nginx""'}, {'source_entity': '""tmpfs""', 'description': 'mounted as a temporary file system', 'destination_entity': '""Secret volume""'}, {'source_entity': '""FOO_SECRET""', 'description': 'stored in a secret volume', 'destination_entity': '""Secret volume""'}, {'source_entity': '""port-forward""', 'description': 'enabled for external access', 'destination_entity': '""Nginx""'}, {'source_entity': '""TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384""', 'description': 'configured as a TLS protocol', 'destination_entity': '""HTTPS""'}, {'source_entity': '""Secrets""', 'description': 'managed and stored securely', 'destination_entity': '""FOO_SECRET""'}, {'source_entity': '""curl""', 'description': 'used to test and verify', 'destination_entity': '""Nginx""'}, {'source_entity': '""ConfigMap""', 'description': 'configured for Nginx deployment', 'destination_entity': '""Nginx""'}]","['[\n  {\n    ""source"": ""kubectl"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""used to manage and deploy applications"",\n    ""summary_er"": ""Kubernetes CLI tool used to manage and deploy pod instances.""\n  }\n]', '[\n  {\n    ""source"": ""Environment Variables"",\n    ""destination"": ""Pod"",\n    ""relation_description"": ""Configured for Nginx Deployment"",\n    ""summary_er"": ""Environment variables are used to configure the Nginx pod for deployment, providing necessary settings and parameters.""\n  }\n]', '[\n  {\n    ""source"": ""HTTPS"",\n    ""destination"": ""Pod"",\n    ""relation_description"": ""enabled for secure communication"",\n    ""summary_er"": ""HTTPS enables secure communication between clients and Nginx pods, protecting data transmission.""\n  }\n]', '[\n  {\n    ""source"": ""tmpfs"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""mounted as a temporary file system"",\n    ""summary_er"": ""A tmpfs is mounted on a pod to provide a temporary file system for ephemeral data.""\n  },\n  {\n    ""source"": ""Secret volume"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""provides secure storage for sensitive data"",\n    ""summary_er"": ""A Secret volume provides secure storage for sensitive data within a pod, ensuring confidentiality and integrity.""\n  }\n]', '[\n  {\n    ""source"": ""FOO_SECRET"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""stored in a secret volume"",\n    ""summary_er"": ""A secret key (FOO_SECRET) is stored in a secret volume and used by a pod.""\n  }\n]', '[\n  {\n    ""source"": ""port-forward"",\n    ""destination"": ""Nginx"",\n    ""relation_description"": ""enabled for external access"",\n    ""summary_er"": ""Port forwarding enables external access to the Nginx pod, allowing users to interact with it from outside the Kubernetes cluster.""\n  }\n]', '[\n  {\n    ""source"": ""TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""configured as a TLS protocol"",\n    ""summary_er"": ""This TLS cipher suite is configured on a pod for secure communication using HTTPS.""\n  }\n]', '[\n  {\n    ""source"": ""Secrets"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""managed and stored securely"",\n    ""summary_er"": ""Secrets are managed and stored securely within a pod, ensuring secure access to sensitive data.""\n  }\n]', '[\n  {\n    ""source"": ""curl"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""used to test and verify"",\n    ""summary_er"": ""\\""curl\\"" is used to test and verify the functionality of a pod, such as \\""Nginx\\"", by sending HTTP requests and checking responses.""\n  }\n]', '[\n  {\n    ""source"": ""ConfigMap"",\n    ""destination"": ""Nginx"",\n    ""relation_description"": ""configured for Nginx deployment"",\n    ""summary_er"": ""A ConfigMap is used to configure the Nginx pod with necessary settings and parameters.""\n  }\n]']","Using Kubernetes secrets to pass sensitive data to containers, a pod's HTTPS traffic can be tested by opening a port-forward tunnel and using curl. The server's certificate can also be checked with curl. Secrets are stored in memory (tmpfs) and do not write to disk, making them secure. Alternatively, secret entries can be exposed as environment variables.","[{'highlight': 'You can see if it’s serving HTTPS traffic by opening a port-forward tunnel to the pod’s port 443 and using it to send a request to the server with curl.'}, {'highlight': 'The secret volume uses an in-memory filesystem (tmpfs) for the Secret files, which means sensitive data stored in the Secret is never written to disk.'}, {'highlight': 'You can expose individual entries from the secret as environment variables instead of using a volume.'}, {'highlight': 'To expose a secret’s entry through environment variables, you’d add the snippet to the container definition and use it as an environment variable.'}, {'highlight': 'The certificate matches the one you created and stored in the Secret, which can be verified by checking the server’s certificate using curl with verbose logging.'}]"
165,254,0,[],"222
CHAPTER 7
ConfigMaps and Secrets: configuring applications
    env:
    - name: FOO_SECRET
      valueFrom:                  
        secretKeyRef:             
          name: fortune-https    
          key: foo           
This is almost exactly like when you set the INTERVAL environment variable, except
that this time you’re referring to a Secret by using secretKeyRef instead of config-
MapKeyRef, which is used to refer to a ConfigMap.
 Even though Kubernetes enables you to expose Secrets through environment vari-
ables, it may not be the best idea to use this feature. Applications usually dump envi-
ronment variables in error reports or even write them to the application log at startup,
which may unintentionally expose them. Additionally, child processes inherit all the
environment variables of the parent process, so if your app runs a third-party binary,
you have no way of knowing what happens with your secret data. 
TIP
Think twice before using environment variables to pass your Secrets to
your container, because they may get exposed inadvertently. To be safe, always
use secret volumes for exposing Secrets.
7.5.6
Understanding image pull Secrets
You’ve learned how to pass Secrets to your applications and use the data they contain.
But sometimes Kubernetes itself requires you to pass credentials to it—for example,
when you’d like to use images from a private container image registry. This is also
done through Secrets.
 Up to now all your container images have been stored on public image registries,
which don’t require any special credentials to pull images from them. But most orga-
nizations don’t want their images to be available to everyone and thus use a private
image registry. When deploying a pod, whose container images reside in a private reg-
istry, Kubernetes needs to know the credentials required to pull the image. Let’s see
how to do that.
USING A PRIVATE IMAGE REPOSITORY ON DOCKER HUB
Docker Hub, in addition to public image repositories, also allows you to create private
repositories. You can mark a repository as private by logging in at http:/
/hub.docker
.com with your web browser, finding the repository and checking a checkbox. 
 To run a pod, which uses an image from the private repository, you need to do
two things:
Create a Secret holding the credentials for the Docker registry.
Reference that Secret in the imagePullSecrets field of the pod manifest.
Listing 7.27
Exposing a Secret’s entry as an environment variable
The variable should be set 
from the entry of a Secret.
The name of the Secret 
holding the key
The key of the Secret 
to expose
 
",[],"[{'entity': 'ConfigMaps', 'description': 'a feature in Kubernetes that allows you to store and retrieve configuration data', 'category': 'software'}, {'entity': 'Secrets', 'description': 'a feature in Kubernetes that allows you to store sensitive information such as passwords or API keys', 'category': 'software'}, {'entity': 'environment variables', 'description': 'a way to pass values from the outside into a container', 'category': 'process'}, {'entity': 'configMapKeyRef', 'description': 'a way to refer to a ConfigMap in Kubernetes', 'category': 'command'}, {'entity': 'secretKeyRef', 'description': 'a way to refer to a Secret in Kubernetes', 'category': 'command'}, {'entity': 'Kubernetes', 'description': 'an open-source container orchestration system', 'category': 'software'}, {'entity': 'Docker', 'description': 'a containerization platform', 'category': 'software'}, {'entity': 'image registries', 'description': 'repositories that store Docker images', 'category': 'database'}, {'entity': 'private image registry', 'description': 'an image registry that requires credentials to access', 'category': 'database'}, {'entity': 'Docker Hub', 'description': 'a public image registry and private repository service', 'category': 'software'}, {'entity': 'pod manifest', 'description': 'a file that defines a pod in Kubernetes', 'category': 'application'}, {'entity': 'imagePullSecrets', 'description': 'a field in the pod manifest that references a Secret for pulling images', 'category': 'command'}, {'entity': 'Secret', 'description': 'an object in Kubernetes that stores sensitive information', 'category': 'software'}, {'entity': 'entry', 'description': 'a single piece of data stored in a Secret', 'category': 'database'}]","[{'source_entity': 'image registries', 'description': 'are used to store and manage Docker images', 'destination_entity': 'Docker'}, {'source_entity': 'entry', 'description': 'is a key-value pair in a ConfigMap or Secret', 'destination_entity': 'ConfigMaps'}, {'source_entity': 'configMapKeyRef', 'description': 'allows a pod to reference the contents of a ConfigMap', 'destination_entity': 'ConfigMaps'}, {'source_entity': 'environment variables', 'description': 'are used to set configuration values for a pod', 'destination_entity': 'pod manifest'}, {'source_entity': 'imagePullSecrets', 'description': 'are used to authenticate with a private image registry', 'destination_entity': 'private image registry'}, {'source_entity': 'Docker Hub', 'description': 'is a public image registry where users can push and pull images', 'destination_entity': 'image registries'}, {'source_entity': 'Kubernetes', 'description': 'uses image registries to store and manage Docker images', 'destination_entity': 'image registries'}, {'source_entity': 'Secret', 'description': 'is an object that stores sensitive information, such as passwords or OAuth tokens', 'destination_entity': 'pod manifest'}, {'source_entity': 'Docker', 'description': 'uses image registries to store and manage Docker images', 'destination_entity': 'image registries'}, {'source_entity': 'secretKeyRef', 'description': 'allows a pod to reference the contents of a Secret', 'destination_entity': 'Secrets'}, {'source_entity': 'ConfigMaps', 'description': 'are used to store configuration data for a pod', 'destination_entity': 'pod manifest'}, {'source_entity': 'Secrets', 'description': 'are used to store sensitive information, such as passwords or OAuth tokens', 'destination_entity': 'pod manifest'}, {'source_entity': 'pod manifest', 'description': 'is a YAML file that defines the configuration of a pod', 'destination_entity': 'Kubernetes'}]","['[\n  {\n    ""source"": ""image registries"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""are used to store and manage Docker images"",\n    ""summary_er"": ""Image registries are used to store and manage Docker images, which can then be deployed as pods in a Kubernetes cluster.""\n  }\n]', '[\n  {\n    ""source"": ""ConfigMap"",\n    ""destination"": ""Pod"",\n    ""relation_description"": ""is a key-value pair"",\n    ""summary_er"": ""A ConfigMap is used to store key-value pairs that can be consumed by pods, providing configuration data.""\n  }\n]', '[\n  {\n    ""source"": ""ConfigMap"",\n    ""destination"": ""Pod"",\n    ""relation_description"": ""allows a pod to reference the contents of a ConfigMap"",\n    ""summary_er"": ""A Pod can access and use data from a ConfigMap, enabling configuration management and flexibility.""\n  }\n]', '[\n  {\n    ""source"": ""environment variables"",\n    ""destination"": ""pod manifest"",\n    ""relation_description"": ""are used to set configuration values"",\n    ""summary_er"": ""Environment variables are used to configure a pod\'s settings, which are then reflected in its manifest.""\n  }\n]', '[\n  {\n    ""source"": ""imagePullSecrets"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""are used to authenticate with a private image registry"",\n    ""summary_er"": ""Image pull secrets enable pods to access private Docker registries, authenticating with credentials stored in the secret.""\n  }\n]', '[\n  {\n    ""source"": ""Docker Hub"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""is a public image registry where users can push and pull images"",\n    ""summary_er"": ""Docker Hub serves as a central repository for container images, enabling users to upload, share, and download images.""\n  }\n]', '[\n  {\n    ""source"": ""Kubernetes"",\n    ""destination"": ""Docker images"",\n    ""relation_description"": ""uses image registries to store and manage"",\n    ""summary_er"": ""Kubernetes utilizes Docker image registries for efficient storage and management of containerized applications.""\n  }\n]', '[\n  {\n    ""source"": ""Secret"",\n    ""destination"": ""Pod"",\n    ""relation_description"": ""stores sensitive information"",\n    ""summary_er"": ""A Secret object stores sensitive data like passwords or OAuth tokens, which is then used by a Pod to authenticate and authorize access.""\n  }\n]', '[\n  {\n    ""source"": ""Docker"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""uses image registries to store and manage Docker images"",\n    ""summary_er"": ""Docker uses image registries to store and manage its images, which are then used by pods.""\n  }\n]', '[\n  {\n    ""source"": ""SecretKeyRef"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""allows a pod to reference the contents of a Secret"",\n    ""summary_er"": ""A pod can access sensitive data from a Secret using SecretKeyRef, ensuring secure configuration.""\n  }\n]', '[\n  {\n    ""source"": ""ConfigMaps"",\n    ""destination"": ""pod manifest"",\n    ""relation_description"": ""are used to store configuration data for a pod"",\n    ""summary_er"": ""ConfigMaps provide configuration data for pods, stored within the pod manifest.""\n  }\n]', '[\n  {\n    ""source"": ""Secrets"",\n    ""destination"": ""Pod"",\n    ""relation_description"": ""are used to store sensitive information"",\n    ""summary_er"": ""Secrets are used to securely store sensitive data, such as passwords or OAuth tokens, which can be referenced by pods for authentication purposes.""\n  }\n]', '[\n  {\n    ""source"": ""pod manifest"",\n    ""destination"": ""Kubernetes"",\n    ""relation_description"": ""is a YAML file that defines the configuration of a pod"",\n    ""summary_er"": ""A pod manifest in Kubernetes is a YAML file that specifies the configuration and resources for a pod, including containers, volumes, and settings.""\n  }\n]']","ConfigMaps and Secrets in Kubernetes allow applications to access configuration data and secrets. However, exposing secrets through environment variables is not recommended due to security risks. Instead, use secret volumes or pass credentials to Kubernetes itself using image pull secrets for private container registries.","[{'highlight': 'You can pass Secrets to your applications and use the data they contain by using secretKeyRef instead of configMapKeyRef.'}, {'highlight': ""It's not recommended to use environment variables to pass Secrets to containers, as they may get exposed inadvertently.""}, {'highlight': ""To expose a Secret's entry as an environment variable, you need to reference the Secret in the imagePullSecrets field of the pod manifest.""}, {'highlight': 'You can create a private repository on Docker Hub by marking it as private and logging in with your web browser.'}, {'highlight': 'To run a pod that uses an image from a private repository, you need to create a Secret holding the credentials for the Docker registry and reference it in the imagePullSecrets field of the pod manifest.'}]"
166,255,0,[],"223
Using Secrets to pass sensitive data to containers
CREATING A SECRET FOR AUTHENTICATING WITH A DOCKER REGISTRY
Creating a Secret holding the credentials for authenticating with a Docker registry
isn’t that different from creating the generic Secret you created in section 7.5.3. You
use the same kubectl create secret command, but with a different type and
options:
$ kubectl create secret docker-registry mydockerhubsecret \
  --docker-username=myusername --docker-password=mypassword \ 
  --docker-email=my.email@provider.com
Rather than create a generic secret, you’re creating a docker-registry Secret called
mydockerhubsecret. You’re specifying your Docker Hub username, password, and
email. If you inspect the contents of the newly created Secret with kubectl describe,
you’ll see that it includes a single entry called .dockercfg. This is equivalent to the
.dockercfg file in your home directory, which is created by Docker when you run the
docker login command.
USING THE DOCKER-REGISTRY SECRET IN A POD DEFINITION
To have Kubernetes use the Secret when pulling images from your private Docker
Hub repository, all you need to do is specify the Secret’s name in the pod spec, as
shown in the following listing.
apiVersion: v1
kind: Pod
metadata:
  name: private-pod
spec:
  imagePullSecrets:                 
  - name: mydockerhubsecret         
  containers:
  - image: username/private:tag
    name: main
In the pod definition in the previous listing, you’re specifying the mydockerhubsecret
Secret as one of the imagePullSecrets. I suggest you try this out yourself, because it’s
likely you’ll deal with private container images soon.
NOT HAVING TO SPECIFY IMAGE PULL SECRETS ON EVERY POD
Given that people usually run many different pods in their systems, it makes you won-
der if you need to add the same image pull Secrets to every pod. Luckily, that’s not the
case. In chapter 12 you’ll learn how image pull Secrets can be added to all your pods
automatically if you add the Secrets to a ServiceAccount.
Listing 7.28
A pod definition using an image pull Secret: pod-with-private-image.yaml
This enables pulling images 
from a private image registry.
 
",[],"[{'entity': 'Secret', 'description': 'a way to pass sensitive data to containers', 'category': 'software'}, {'entity': 'kubectl', 'description': 'command-line tool for interacting with Kubernetes', 'category': 'software'}, {'entity': 'docker-registry', 'description': 'type of Secret for authenticating with a Docker registry', 'category': 'software'}, {'entity': 'mydockerhubsecret', 'description': 'name of the Secret holding Docker Hub credentials', 'category': 'software'}, {'entity': '.dockercfg', 'description': 'file containing Docker Hub credentials', 'category': 'software'}, {'entity': 'Pod', 'description': 'a container running in a Kubernetes cluster', 'category': 'software'}, {'entity': 'imagePullSecrets', 'description': 'field in Pod spec for specifying image pull Secrets', 'category': 'software'}, {'entity': 'mydockerhubsecret', 'description': 'name of the Secret specified in the Pod definition', 'category': 'software'}, {'entity': 'username/private:tag', 'description': 'image name and tag for a private Docker Hub repository', 'category': 'software'}, {'entity': 'ServiceAccount', 'description': 'a way to add image pull Secrets to all pods automatically', 'category': 'software'}]","[{'source_entity': '""ServiceAccount""', 'description': 'authenticates', 'destination_entity': '"".dockercfg""'}, {'source_entity': '""kubectl""', 'description': 'pulls', 'destination_entity': '""username/private:tag""'}, {'source_entity': '""imagePullSecrets""', 'description': 'uses', 'destination_entity': '""docker-registry""'}, {'source_entity': '""kubectl""', 'description': 'deploys', 'destination_entity': '""Pod""'}, {'source_entity': '""Secret""', 'description': 'stores', 'destination_entity': '""mydockerhubsecret""'}]","['[\n  {\n    ""source"": ""ServiceAccount"",\n    ""destination"": "".dockercfg"",\n    ""relation_description"": ""authenticates"",\n    ""summary_er"": ""A ServiceAccount authenticates with a .dockercfg file to provide credentials for Docker container authentication.""\n  }\n]', '[\n  {\n    ""source"": ""kubectl"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""pulls"",\n    ""summary_er"": ""Kubernetes command kubectl pulls a container image from a registry, such as Docker Hub or Google Container Registry.""\n  },\n  {\n    ""source"": ""username/private:tag"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""image"",\n    ""summary_er"": ""A private container image with username and tag is used to create a pod in Kubernetes.""\n  }\n]', '[\n  {\n    ""source"": ""imagePullSecrets"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""uses"",\n    ""summary_er"": ""The imagePullSecrets object uses a secret to authenticate with a container registry, allowing a pod to pull images from it.""\n  }\n]', '[\n  {\n    ""source"": ""kubectl"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""deploys"",\n    ""summary_er"": ""Kubernetes command-line tool (kubectl) deploys a containerized application or service as a pod, which is the basic execution unit in Kubernetes.""\n  }\n]', '[\n  {\n    ""source"": ""Secret"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""stores"",\n    ""summary_er"": ""A Secret in Kubernetes stores sensitive information, such as API keys or credentials, and makes it available to a pod named \'mydockerhubsecret\' for use.""\n  }\n]']","To pass sensitive data to containers, create a Secret holding Docker registry credentials using kubectl create secret docker-registry command. Specify the Secret's name in the pod spec as an imagePullSecrets. This enables pulling images from a private image registry. Alternatively, add Secrets to a ServiceAccount to automatically include them in all pods.","[{'highlight': 'To create a Secret for authenticating with a Docker registry, use the kubectl create secret command with the --docker-username, --docker-password, and --docker-email options.'}]"
167,256,0,[],"224
CHAPTER 7
ConfigMaps and Secrets: configuring applications
7.6
Summary
This wraps up this chapter on how to pass configuration data to containers. You’ve
learned how to
Override the default command defined in a container image in the pod definition
Pass command-line arguments to the main container process
Set environment variables for a container
Decouple configuration from a pod specification and put it into a ConfigMap
Store sensitive data in a Secret and deliver it securely to containers
Create a docker-registry Secret and use it to pull images from a private image
registry
In the next chapter, you’ll learn how to pass pod and container metadata to applica-
tions running inside them. You’ll also see how the default token Secret, which we
learned about in this chapter, is used to talk to the API server from within a pod. 
 
",[],"[{'entity': 'ConfigMaps', 'description': 'a way to decouple configuration from a pod specification', 'category': 'software'}, {'entity': 'Secrets', 'description': 'used to store sensitive data and deliver it securely to containers', 'category': 'software'}, {'entity': 'containers', 'description': 'lightweight and standalone execution environment', 'category': 'container'}, {'entity': 'pod definition', 'description': ""a way to define a pod's configuration"", 'category': 'application'}, {'entity': 'command-line arguments', 'description': 'arguments passed to the main container process', 'category': 'process'}, {'entity': 'environment variables', 'description': 'variables set for a container', 'category': 'process'}, {'entity': 'docker-registry Secret', 'description': 'a way to store sensitive data and use it to pull images from a private image registry', 'category': 'software'}, {'entity': 'API server', 'description': 'the server that manages the Kubernetes cluster', 'category': 'application'}, {'entity': 'token Secret', 'description': 'used to talk to the API server from within a pod', 'category': 'software'}]","[{'source_entity': '""environment variables""', 'description': 'are used to configure containers', 'destination_entity': '""containers""'}, {'source_entity': '""command-line arguments""', 'description': 'can be passed to containers at runtime', 'destination_entity': '""containers""'}, {'source_entity': '""docker-registry Secret""', 'description': 'is used to authenticate with a private container registry', 'destination_entity': '""API server""'}, {'source_entity': '""token Secret""', 'description': 'is used to authenticate with the API server', 'destination_entity': '""API server""'}, {'source_entity': '""Secrets""', 'description': 'can be mounted into containers as files', 'destination_entity': '""containers""'}, {'source_entity': '""ConfigMaps""', 'description': 'can be used to configure containers at runtime', 'destination_entity': '""containers""'}, {'source_entity': '""pod definition""', 'description': 'specifies the resources and configuration for a pod', 'destination_entity': '""API server""'}]","['[{""source"": ""environment variables"", ""destination"": ""pod"", ""relation_description"": ""are used to configure containers"", ""summary_er"": ""Environment variables are used to pass configuration settings to a container, allowing for customization without modifying the container itself.""}]', '[\n  {\n    ""source"": ""command-line arguments"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""can be passed to containers at runtime"",\n    ""summary_er"": ""Command-line arguments can be directly passed to containers running within a pod, allowing for dynamic configuration and input.""\n  }\n]', '[\n  {\n    ""source"": ""Docker Registry Secret"",\n    ""destination"": ""API Server"",\n    ""relation_description"": ""Authentication with Private Container Registry"",\n    ""summary_er"": ""The Docker Registry Secret is used to authenticate with a private container registry, allowing the API server to access and manage containers securely.""\n  }\n]', '[\n  {\n    ""source"": ""Token Secret"",\n    ""destination"": ""API Server"",\n    ""relation_description"": ""is used to authenticate with the API server"",\n    ""summary_er"": ""The Token Secret is used for authentication with the API Server, enabling secure access and management of resources.""\n  }\n]', '[\n  {\n    ""source"": ""Secrets"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""can be mounted into containers as files"",\n    ""summary_er"": ""Secrets can be used to store sensitive data and mounted into containers for use by applications.""\n  },\n  {\n    ""source"": ""containers"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""can run multiple instances of an application"",\n    ""summary_er"": ""Containers can be run within a pod, allowing for multiple instances of the same application to coexist and share resources.""\n  }\n]', '[\n  {\n    ""source"": ""ConfigMaps"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""can be used to configure containers at runtime"",\n    ""summary_er"": ""ConfigMaps can be used to provide configuration data to pods, allowing for dynamic container configuration.""\n  }\n]', '[\n  {\n    ""source"": ""Pod Definition"",\n    ""destination"": ""Pod"",\n    ""relation_description"": ""specifies the resources and configuration for a pod"",\n    ""summary_er"": ""The Pod Definition specifies the resources and configuration for a pod, which is a logical host in Kubernetes.""\n  },\n  {\n    ""source"": ""API Server"",\n    ""destination"": ""Pod"",\n    ""relation_description"": ""API server interacts with pods to manage containerized applications"",\n    ""summary_er"": ""The API Server interacts with Pods to manage containerized applications, enabling deployment and management of containers within the cluster.""\n  }\n]']","This chapter summarizes how to pass configuration data to containers using ConfigMaps and Secrets, including overriding commands, passing arguments, setting environment variables, decoupling config from pods, storing sensitive data in Secrets, and creating a docker-registry Secret.","[{'highlight': 'Override the default command defined in a container image in the pod definition'}, {'highlight': 'Decouple configuration from a pod specification and put it into a ConfigMap'}, {'highlight': 'Store sensitive data in a Secret and deliver it securely to containers'}, {'highlight': 'Create a docker-registry Secret and use it to pull images from a private image registry'}, {'highlight': 'Pass pod and container metadata to applications running inside them'}]"
168,257,0,[],"225
Accessing pod metadata
and other resources
from applications
Applications often need information about the environment they’re running in,
including details about themselves and that of other components in the cluster.
You’ve already seen how Kubernetes enables service discovery through environ-
ment variables or DNS, but what about other information? In this chapter, you’ll
see how certain pod and container metadata can be passed to the container and
how easy it is for an app running inside a container to talk to the Kubernetes API
server to get information about the resources deployed in the cluster and even how
to create or modify those resources.
This chapter covers
Using the Downward API to pass information into 
containers
Exploring the Kubernetes REST API
Leaving authentication and server verification to 
kubectl proxy
Accessing the API server from within a container
Understanding the ambassador container pattern
Using Kubernetes client libraries
 
",[],"[{'entity': 'pod metadata', 'description': 'information about the environment and other components in the cluster', 'category': 'software'}, {'entity': 'applications', 'description': 'programs that need information about their environment', 'category': 'application'}, {'entity': 'Kubernetes API server', 'description': 'server that provides information about resources deployed in the cluster', 'category': 'database'}, {'entity': 'Downward API', 'description': 'mechanism to pass information into containers', 'category': 'framework'}, {'entity': 'environment variables', 'description': 'variables that provide information about the environment', 'category': 'process'}, {'entity': 'DNS', 'description': 'domain name system for service discovery', 'category': 'network'}, {'entity': 'containers', 'description': 'isolated environments for applications', 'category': 'container'}, {'entity': 'kubectl proxy', 'description': 'tool to leave authentication and server verification to', 'category': 'command'}, {'entity': 'Kubernetes client libraries', 'description': 'libraries that provide access to the Kubernetes API server', 'category': 'library'}]","[{'source_entity': '""Kubernetes API server""', 'description': 'provides', 'destination_entity': '""Downward API""'}, {'source_entity': '""Kubernetes client libraries""', 'description': 'use', 'destination_entity': '""Kubernetes API server""'}, {'source_entity': '""containers""', 'description': 'are managed by', 'destination_entity': '""Kubernetes API server""'}, {'source_entity': '""applications""', 'description': 'run within', 'destination_entity': '""containers""'}, {'source_entity': '""kubectl proxy""', 'description': 'provides a proxy to', 'destination_entity': '""Kubernetes API server""'}, {'source_entity': '""pod metadata""', 'description': 'is accessed through', 'destination_entity': '""Downward API""'}, {'source_entity': '""DNS""', 'description': 'is used for', 'destination_entity': '""container communication""'}, {'source_entity': '""environment variables""', 'description': 'are passed to', 'destination_entity': '""containers""'}]","['[\n  {\n    ""source"": ""Kubernetes API server"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""provides"",\n    ""summary_er"": ""The Kubernetes API server provides a pod with necessary resources and configuration.""\n  }\n]', '[\n  {\n    ""source"": ""Kubernetes client libraries"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""use"",\n    ""summary_er"": ""Kubernetes client libraries utilize pods to interact with the Kubernetes API server.""\n  },\n  {\n    ""source"": ""pod"",\n    ""destination"": ""Kubernetes API server"",\n    ""relation_description"": ""interact with"",\n    ""summary_er"": ""Pods interact with the Kubernetes API server to manage containerized applications.""\n  }\n]', '[\n  {\n    ""source"": ""containers"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""are managed by"",\n    ""summary_er"": ""Containers in Kubernetes are managed by a pod, which provides shared resources and environment for container execution.""\n  },\n  {\n    ""source"": ""Kubernetes API server"",\n    ""destination"": ""container"",\n    ""relation_description"": ""manages"",\n    ""summary_er"": ""The Kubernetes API server manages containers, ensuring their lifecycle, networking, and storage requirements are met.""\n  }\n]', '[\n  {\n    ""source"": ""applications"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""run within"",\n    ""summary_er"": ""Applications are executed within a containerized environment, leveraging Docker containers to ensure isolation and efficient resource utilization.""\n  },\n  {\n    ""source"": ""containers"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""run within"",\n    ""summary_er"": ""Containers are deployed within a pod, allowing for co-location of multiple applications and efficient resource sharing.""\n  }\n]', '[\n  {\n    ""source"": ""kubectl"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""provides a proxy to"",\n    ""summary_er"": ""The Kubernetes command-line tool (kubectl) provides a proxy to access the API server, allowing users to interact with the cluster.""\n  },\n  {\n    ""source"": ""Kubernetes API server"",\n    ""destination"": ""cluster"",\n    ""relation_description"": ""access and management"",\n    ""summary_er"": ""The Kubernetes API server is responsible for accessing and managing the cluster, handling requests from clients like kubectl.""\n  }\n]', '[\n  {\n    ""source"": ""Pod Metadata"",\n    ""destination"": ""Pod"",\n    ""relation_description"": ""is accessed through"",\n    ""summary_er"": ""The Pod Metadata is a collection of key-value pairs that provide information about a pod, such as its name, namespace, and labels.""\n  },\n  {\n    ""source"": ""Downward API"",\n    ""destination"": ""Pod"",\n    ""relation_description"": ""provides"",\n    ""summary_er"": ""The Downward API allows pods to access their own metadata, such as environment variables and config maps, through a downward API volume.""\n  }\n]', '[\n  {\n    ""source"": ""DNS"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""is used for container communication"",\n    ""summary_er"": ""DNS is used to facilitate communication between containers within a pod, enabling them to resolve each other\'s names and communicate effectively.""\n  }\n]', '[\n  {\n    ""source"": ""Environment Variables"",\n    ""destination"": ""Pod"",\n    ""relation_description"": ""are passed to"",\n    ""summary_er"": ""Environment variables are configuration settings that are passed from a container\'s environment to its pod, allowing for dynamic configuration and flexibility.""\n  }\n]']","This chapter explores how applications can access pod metadata, resources, and interact with the Kubernetes API server. It covers using the Downward API to pass information into containers, exploring the Kubernetes REST API, accessing the API server from within a container, and understanding the ambassador container pattern.","[{'highlight': 'Applications often need information about the environment they’re running in, including details about themselves and that of other components in the cluster.'}, {'highlight': 'The Downward API can be used to pass information into containers.'}, {'highlight': 'Kubernetes REST API can be explored from within a container.'}, {'highlight': 'Authentication and server verification can be left to kubectl proxy.'}, {'highlight': 'Kubernetes client libraries can be used to access the API server from within a container.'}]"
169,258,0,[],"226
CHAPTER 8
Accessing pod metadata and other resources from applications
8.1
Passing metadata through the Downward API
In the previous chapter you saw how you can pass configuration data to your appli-
cations through environment variables or through configMap and secret volumes.
This works well for data that you set yourself and that is known before the pod is
scheduled to a node and run there. But what about data that isn’t known up until
that point—such as the pod’s IP, the host node’s name, or even the pod’s own name
(when the name is generated; for example, when the pod is created by a ReplicaSet
or similar controller)? And what about data that’s already specified elsewhere, such
as a pod’s labels and annotations? You don’t want to repeat the same information in
multiple places.
 Both these problems are solved by the Kubernetes Downward API. It allows you to
pass metadata about the pod and its environment through environment variables or
files (in a downwardAPI volume). Don’t be confused by the name. The Downward API
isn’t like a REST endpoint that your app needs to hit so it can get the data. It’s a way of
having environment variables or files populated with values from the pod’s specifica-
tion or status, as shown in figure 8.1.
8.1.1
Understanding the available metadata
The Downward API enables you to expose the pod’s own metadata to the processes
running inside that pod. Currently, it allows you to pass the following information to
your containers:
The pod’s name
The pod’s IP address
Container: main
Environment
variables
API server
Used to initialize environment
variables and ﬁles in the
downwardAPI volume
Pod manifest
- Metadata
- Status
Pod
downwardAPI
volume
App process
Figure 8.1
The Downward API exposes pod metadata through environment variables or files.
 
",[],"[{'entity': 'Downward API', 'description': 'A way to pass metadata about the pod and its environment through environment variables or files.', 'category': 'software'}, {'entity': 'Kubernetes', 'description': 'An open-source container orchestration system for automating the deployment, scaling, and management of containers.', 'category': 'software'}, {'entity': 'Pod', 'description': 'A logical host in a Kubernetes cluster where one or more containers can run.', 'category': 'container'}, {'entity': 'Environment variables', 'description': 'Variables that are set outside the container and made available to the processes running inside it.', 'category': 'process'}, {'entity': 'ConfigMap', 'description': 'A Kubernetes resource that stores configuration data as key-value pairs.', 'category': 'database'}, {'entity': 'Secret', 'description': 'A Kubernetes resource that stores sensitive information such as passwords or OAuth tokens.', 'category': 'database'}, {'entity': 'ReplicaSet', 'description': 'A Kubernetes controller that ensures a specified number of replicas (identical copies) of a pod are running at any given time.', 'category': 'controller'}, {'entity': 'API server', 'description': 'The central component of the Kubernetes control plane that exposes the Kubernetes API.', 'category': 'software'}, {'entity': 'Pod manifest', 'description': ""A YAML or JSON file that defines a pod's configuration, including its metadata and status."", 'category': 'file'}, {'entity': 'Metadata', 'description': 'Data about the pod itself, such as its name, IP address, and labels.', 'category': 'database'}, {'entity': 'Status', 'description': ""Information about the pod's current state, such as whether it is running or not."", 'category': 'database'}, {'entity': 'DownwardAPI volume', 'description': 'A Kubernetes resource that exposes metadata from the pod to the processes running inside it.', 'category': 'volume'}]","[{'source_entity': '""Pod manifest""', 'description': 'defines', 'destination_entity': '""Status""'}, {'source_entity': '""Pod manifest""', 'description': 'specifies', 'destination_entity': '""Downward API""'}, {'source_entity': '""Pod manifest""', 'description': 'contains', 'destination_entity': '""Pod""'}, {'source_entity': '""Kubernetes""', 'description': 'manages', 'destination_entity': '""ReplicaSet""'}, {'source_entity': '""ReplicaSet""', 'description': 'uses', 'destination_entity': '""Secret""'}, {'source_entity': '""Pod manifest""', 'description': 'provides', 'destination_entity': '""Metadata""'}, {'source_entity': '""Pod manifest""', 'description': 'defines', 'destination_entity': '""Environment variables""'}, {'source_entity': '""DownwardAPI volume""', 'description': 'is based on', 'destination_entity': '""ConfigMap""'}, {'source_entity': '""API server""', 'description': 'interacts with', 'destination_entity': '""Kubernetes""'}]","['[\n  {\n    ""source"": ""Pod manifest"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""defines"",\n    ""summary_er"": ""A Pod manifest defines a pod, which is the basic execution unit in Kubernetes.""\n  },\n  {\n    ""source"": ""pod"",\n    ""destination"": ""Status"",\n    ""relation_description"": ""has"",\n    ""summary_er"": ""A pod has a status that indicates its current state, such as running or terminated.""\n  }\n]', '[\n  {\n    ""source"": ""Pod manifest"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""specifies"",\n    ""summary_er"": ""The Pod manifest file contains specifications for a Kubernetes pod, including its configuration and settings.""\n  },\n  {\n    ""source"": ""Downward API"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""provides"",\n    ""summary_er"": ""The Downward API provides information about the pod\'s environment to the container running inside it.""\n  }\n]', '[\n  {\n    ""source"": ""Pod manifest"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""contains"",\n    ""summary_er"": ""A Pod manifest file describes a containerized application, including its configuration and dependencies.""\n  }\n]', '[\n  {\n    ""source"": ""Kubernetes"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""manages"",\n    ""summary_er"": ""Kubernetes manages and orchestrates pod deployments, ensuring scalability and high availability.""\n  }\n]', '[\n  {\n    ""source"": ""ReplicaSet"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""uses"",\n    ""summary_er"": ""A ReplicaSet ensures a specified number of replicas (identical Pods) are running at any given time. It uses a Pod template to create the desired number of identical Pods.""\n  },\n  {\n    ""source"": ""Secret"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""uses"",\n    ""summary_er"": ""A Secret provides sensitive information, such as passwords or API keys, that can be used by a Pod. The Pod uses the Secret to access the sensitive data.""\n  }\n]', '[\n  {\n    ""source"": ""Pod manifest"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""provides"",\n    ""summary_er"": ""A Pod manifest provides metadata to a pod, enabling it to run and operate within a Kubernetes cluster.""\n  }\n]', '[\n  {\n    ""source"": ""Pod manifest"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""defines"",\n    ""summary_er"": ""A Pod manifest defines a pod, which is the basic execution unit in Kubernetes.""\n  },\n  {\n    ""source"": ""Environment variables"",\n    ""destination"": ""container"",\n    ""relation_description"": ""sets"",\n    ""summary_er"": ""Environment variables set configuration values for a container to use during execution.""\n  }\n]', '[\n  {\n    ""source"": ""Downward API Volume"",\n    ""destination"": ""Pod"",\n    ""relation_description"": ""is based on"",\n    ""summary_er"": ""A Downward API Volume is a Kubernetes resource that provides configuration data to a Pod, allowing it to access and use external data.""\n  },\n  {\n    ""source"": ""ConfigMap"",\n    ""destination"": ""Pod"",\n    ""relation_description"": ""provides configuration data to"",\n    ""summary_er"": ""A ConfigMap is a Kubernetes resource that stores configuration data as key-value pairs, which can be used by a Pod to access and use external data.""\n  }\n]', '[\n  {\n    ""source"": ""API server"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""interacts with"",\n    ""summary_er"": ""The API server communicates with pods to manage and orchestrate containerized applications.""\n  },\n  {\n    ""source"": ""Kubernetes"",\n    ""destination"": ""API server"",\n    ""relation_description"": ""uses"",\n    ""summary_er"": ""Kubernetes utilizes the API server as a central management interface for its cluster operations.""\n  }\n]']","The Kubernetes Downward API allows passing metadata about a pod and its environment through environment variables or files, solving problems of repeating information in multiple places, and exposing pod metadata to processes running inside the pod, with currently available metadata being the pod's name, IP address, and labels/annotations.","[{'highlight': 'The Kubernetes Downward API allows you to pass metadata about the pod and its environment through environment variables or files, solving problems of passing unknown data at runtime and avoiding repetition of information in multiple places.'}, {'highlight': ""The Downward API enables you to expose the pod's own metadata to the processes running inside that pod, currently allowing you to pass the following information: the pod's name, the pod's IP address, and other metadata.""}, {'highlight': ""The Downward API is not a REST endpoint that your app needs to hit to get data, but rather a way of having environment variables or files populated with values from the pod's specification or status.""}, {'highlight': 'You can use the Downward API to pass metadata through environment variables or files in a downwardAPI volume, making it easy to access pod metadata and other resources from applications.'}, {'highlight': 'The Downward API allows you to avoid repeating information in multiple places by exposing pod metadata through environment variables or files, making it easier to manage complex Kubernetes environments.'}]"
