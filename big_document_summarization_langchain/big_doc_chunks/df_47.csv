,page,img_cnt,img_npy_lst,text,tables,entities,relationships,summary_rel,summary,highlights
470,559,0,[],"527
Platforms built on top of Kubernetes
For example, I’ve been involved with the Service Catalog since early on and have
implemented a broker, which makes it trivial to provision messaging systems and
expose them to pods in a Kubernetes cluster. Another team has implemented a broker
that makes it easy to provision Amazon Web Services. 
 In general, service brokers allow easy provisioning and exposing of services in
Kubernetes and will make Kubernetes an even more awesome platform for deploying
your applications. 
18.3
Platforms built on top of Kubernetes
I’m sure you’ll agree that Kubernetes is a great system by itself. Given that it’s easily
extensible across all its components, it’s no wonder companies that had previously
developed their own custom platforms are now re-implementing them on top of
Kubernetes. Kubernetes is, in fact, becoming a widely accepted foundation for the
new generation of Platform-as-a-Service offerings.
 Among the best-known PaaS systems built on Kubernetes are Deis Workflow and
Red Hat’s OpenShift. We’ll do a quick overview of both systems to give you a sense of
what they offer on top of all the awesome stuff Kubernetes already offers.
18.3.1 Red Hat OpenShift Container Platform
Red Hat OpenShift is a Platform-as-a-Service and as such, it has a strong focus on
developer experience. Among its goals are enabling rapid development of applica-
tions, as well as easy deployment, scaling, and long-term maintenance of those apps.
OpenShift has been around much longer than Kubernetes. Versions 1 and 2 were
built from the ground up and had nothing to do with Kubernetes, but when Kuberne-
tes was announced, Red Hat decided to rebuild OpenShift version 3 from scratch—
this time on top of Kubernetes. When a company such as Red Hat decides to throw
away an old version of their software and build a new one on top of an existing tech-
nology like Kubernetes, it should be clear to everyone how great Kubernetes is.
 Kubernetes automates rollouts and application scaling, whereas OpenShift also auto-
mates the actual building of application images and their automatic deployment with-
out requiring you to integrate a Continuous Integration solution into your cluster. 
 OpenShift also provides user and group management, which allows you to run a
properly secured multi-tenant Kubernetes cluster, where individual users are only
allowed to access their own Kubernetes namespaces and the apps running in those
namespaces are also fully network-isolated from each other by default. 
INTRODUCING ADDITIONAL RESOURCES AVAILABLE IN OPENSHIFT
OpenShift provides some additional API objects in addition to all those available in
Kubernetes. We’ll explain them in the next few paragraphs to give you a good over-
view of what OpenShift does and what it provides.
 The additional resources include
Users & Groups
Projects
 
",[],"[{'entity': 'Kubernetes', 'description': 'Container orchestration system', 'category': 'software'}, {'entity': 'Service Catalog', 'description': 'Broker for provisioning messaging systems', 'category': 'application'}, {'entity': 'broker', 'description': 'Software component for provisioning services', 'category': 'software'}, {'entity': 'Amazon Web Services', 'description': 'Cloud computing platform', 'category': 'cloud service'}, {'entity': 'pods', 'description': 'Lightweight and portable containers in Kubernetes', 'category': 'container'}, {'entity': 'Kubernetes cluster', 'description': 'Group of machines running Kubernetes', 'category': 'cluster'}, {'entity': 'Deis Workflow', 'description': 'Platform-as-a-Service built on top of Kubernetes', 'category': 'application'}, {'entity': 'Red Hat OpenShift', 'description': 'Platform-as-a-Service and container application platform', 'category': 'application'}, {'entity': 'developer experience', 'description': 'Focus area for Red Hat OpenShift', 'category': 'software feature'}, {'entity': 'applications', 'description': 'Software programs running on Kubernetes', 'category': 'software'}, {'entity': 'scaling', 'description': 'Process of adjusting application resources', 'category': 'process'}, {'entity': 'maintenance', 'description': 'Process of keeping applications up-to-date and secure', 'category': 'process'}, {'entity': 'user management', 'description': 'Feature for managing user access to Kubernetes resources', 'category': 'software feature'}, {'entity': 'group management', 'description': 'Feature for managing group access to Kubernetes resources', 'category': 'software feature'}, {'entity': 'namespaces', 'description': 'Logical isolation of Kubernetes resources', 'category': 'resource'}, {'entity': 'projects', 'description': 'Additional resource in OpenShift', 'category': 'resource'}, {'entity': 'users', 'description': 'Entities with access to Kubernetes resources', 'category': 'user'}, {'entity': 'groups', 'description': 'Entities with shared access to Kubernetes resources', 'category': 'group'}]","[{'source_entity': '""Red Hat OpenShift""', 'description': 'provides', 'destination_entity': '""Kubernetes cluster""'}, {'source_entity': '""Amazon Web Services""', 'description': 'offers', 'destination_entity': '""Service Catalog""'}, {'source_entity': '""namespaces""', 'description': 'contain', 'destination_entity': '""pods""'}, {'source_entity': '""user management""', 'description': 'manages', 'destination_entity': '""users""'}, {'source_entity': '""maintenance""', 'description': 'performs', 'destination_entity': '""Kubernetes cluster""'}, {'source_entity': '""Service Catalog""', 'description': 'provides', 'destination_entity': '""applications""'}, {'source_entity': '""users""', 'description': 'use', 'destination_entity': '""projects""'}, {'source_entity': '""developer experience""', 'description': 'enhances', 'destination_entity': '""user management""'}, {'source_entity': '""pods""', 'description': 'run', 'destination_entity': '""applications""'}, {'source_entity': '""Kubernetes""', 'description': 'manages', 'destination_entity': '""namespaces""'}, {'source_entity': '""group management""', 'description': 'handles', 'destination_entity': '""groups""'}, {'source_entity': '""projects""', 'description': 'contain', 'destination_entity': '""applications""'}, {'source_entity': '""Deis Workflow""', 'description': 'uses', 'destination_entity': '""broker""'}, {'source_entity': '""groups""', 'description': 'scale', 'destination_entity': '""projects""'}, {'source_entity': '""broker""', 'description': 'handles', 'destination_entity': '""scaling""'}]","['[\n  {\n    ""source"": ""Red Hat OpenShift"",\n    ""destination"": ""Kubernetes cluster"",\n    ""relation_description"": ""provides"",\n    ""summary_er"": ""Red Hat OpenShift provides a managed Kubernetes experience, enabling users to deploy and manage containerized applications in a scalable and secure manner.""\n  }\n]', '[\n  {\n    ""source"": ""Amazon Web Services"",\n    ""destination"": ""Service Catalog"",\n    ""relation_description"": ""offers"",\n    ""summary_er"": ""Amazon Web Services provides a service catalog that enables users to discover and subscribe to cloud services.""\n  }\n]', '[\n  {\n    ""source"": ""namespaces"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""contain"",\n    ""summary_er"": ""A namespace contains one or more pods, which are the basic execution units in a Kubernetes cluster.""\n  }\n]', '[\n  {\n    ""source"": ""User Management"",\n    ""destination"": ""Pods"",\n    ""relation_description"": ""manages"",\n    ""summary_er"": ""User Management system oversees and controls the lifecycle of Pods, ensuring they are created, updated, and deleted as needed.""\n  }\n]', '[\n  {\n    ""source"": ""maintenance"",\n    ""destination"": ""Kubernetes cluster"",\n    ""relation_description"": ""performs"",\n    ""summary_er"": ""The Kubernetes cluster performs maintenance tasks to ensure smooth operation and prevent downtime.""\n  }\n]', '[\n  {\n    ""source"": ""Service Catalog"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""provides"",\n    ""summary_er"": ""The Service Catalog provides a catalog of services to pods, enabling them to discover and utilize available services.""\n  }\n]', '[{\n  ""source"": ""users"",\n  ""destination"": ""projects"",\n  ""relation_description"": ""use"",\n  ""summary_er"": ""\\""Users interact with and utilize various projects, leveraging their features and functionalities to achieve specific goals or complete tasks.\\""""\n}]', '[\n  {\n    ""source"": ""developer experience"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""enhances"",\n    ""summary_er"": ""Developer experience is enhanced by a containerized user management system, providing a seamless and efficient way for developers to manage users.""\n  }\n]', '[\n  {\n    ""source"": ""pods"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""run"",\n    ""summary_er"": ""A Kubernetes pod is a logical host for one or more containers, which are run using the \'run\' command.""\n  }\n]', '[\n  {\n    ""source"": ""Kubernetes"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""manages"",\n    ""summary_er"": ""Kubernetes manages pods, ensuring efficient resource allocation and scaling.""\n  },\n  {\n    ""source"": ""Kubernetes"",\n    ""destination"": ""namespaces"",\n    ""relation_description"": ""manages"",\n    ""summary_er"": ""Kubernetes manages namespaces, providing isolation and organization for multiple applications.""\n  }\n]', '[\n  {\n    ""source"": ""group management"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""handles"",\n    ""summary_er"": ""Group management system manages and handles multiple pods, ensuring efficient resource allocation and scalability.""\n  }\n]', '[\n  {\n    ""source"": ""projects"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""contain"",\n    ""summary_er"": ""Projects are contained within pods, which are isolated environments for applications to run in.""\n  }\n]', '[\n  {\n    ""source"": ""Deis Workflow"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""uses"",\n    ""summary_er"": ""Deis Workflow utilizes a pod to execute its workflow, leveraging containerization for efficient resource management and scalability.""\n  }\n]', '[{\n    ""source"": ""groups"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""scale"",\n    ""summary_er"": ""The group\'s resources are scaled to match the demand by adjusting the number of pods.""\n}]', '[\n  {\n    ""source"": ""broker"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""handles"",\n    ""summary_er"": ""Broker entity manages or controls a Pod, which is a containerized application in Kubernetes.""\n  },\n  {\n    ""source"": ""broker"",\n    ""destination"": ""scaling"",\n    ""relation_description"": ""scaling"",\n    ""summary_er"": ""Broker entity enables scaling of resources, such as increasing the number of Pods to meet demand.""\n  }\n]']","Kubernetes is becoming a widely accepted foundation for Platform-as-a-Service (PaaS) offerings. Platforms built on top of Kubernetes, such as Deis Workflow and Red Hat's OpenShift, provide features like easy provisioning, automated rollouts and scaling, user and group management, and additional API objects. Red Hat OpenShift automates application image building and deployment without requiring a Continuous Integration solution.",[{'highlight': 'Kubernetes is becoming a widely accepted foundation for the new generation of Platform-as-a-Service offerings.'}]
471,560,0,[],"528
CHAPTER 18
Extending Kubernetes
Templates
BuildConfigs
DeploymentConfigs
ImageStreams
Routes
And others
UNDERSTANDING USERS, GROUPS, AND PROJECTS
We’ve said that OpenShift provides a proper multi-tenant environment to its users.
Unlike Kubernetes, which doesn’t have an API object for representing an individual
user of the cluster (but does have ServiceAccounts that represent services running in
it), OpenShift provides powerful user management features, which make it possible to
specify what each user can do and what they cannot. These features pre-date the Role-
Based Access Control, which is now the standard in vanilla Kubernetes.
 Each user has access to certain Projects, which are nothing more than Kubernetes
Namespaces with additional annotations. Users can only act on resources that reside
in the projects the user has access to. Access to the project is granted by a cluster
administrator. 
INTRODUCING APPLICATION TEMPLATES
Kubernetes makes it possible to deploy a set of resources through a single JSON or
YAML manifest. OpenShift takes this a step further by allowing that manifest to be
parameterizable. A parameterizable list in OpenShift is called a Template; it’s a list of
objects whose definitions can include placeholders that get replaced with parameter
values when you process and then instantiate a template (see figure 18.8).
The template itself is a JSON or YAML file containing a list of parameters that are ref-
erenced in resources defined in that same JSON/YAML. The template can be stored
in the API server like any other object. Before a template can be instantiated, it needs
Template
Parameters
APP_NAME=""kubia""
VOL_CAPACITY=""5 Gi""
...
Pod
name: $(APP_NAME)
Service
name: $(APP_NAME)
Template
Pod
name: kubia
Service
name: kubia
Pod
name: kubia
Service
name: kubia
Process
Create
Figure 18.8
OpenShift templates
 
",[],"[{'entity': 'Templates', 'description': 'A parameterizable list in OpenShift that allows a manifest to be instantiated with parameter values.', 'category': 'software'}, {'entity': 'BuildConfigs', 'description': 'A configuration for building images in OpenShift.', 'category': 'software'}, {'entity': 'DeploymentConfigs', 'description': 'A configuration for deploying applications in OpenShift.', 'category': 'software'}, {'entity': 'ImageStreams', 'description': 'A stream of images in OpenShift that can be used to deploy applications.', 'category': 'software'}, {'entity': 'Routes', 'description': 'A way to expose an application running in OpenShift to the outside world.', 'category': 'software'}, {'entity': 'ServiceAccounts', 'description': 'An object in Kubernetes that represents a service running in a cluster.', 'category': 'software'}, {'entity': 'Projects', 'description': 'A concept in OpenShift that represents a set of resources, similar to a namespace in Kubernetes.', 'category': 'software'}, {'entity': 'Users', 'description': 'An entity in OpenShift that has access to certain projects and can perform actions on resources within those projects.', 'category': 'hardware'}, {'entity': 'Groups', 'description': 'A collection of users in OpenShift that have shared permissions.', 'category': 'hardware'}, {'entity': 'Roles-Based Access Control (RBAC)', 'description': 'A standard access control mechanism in Kubernetes that defines permissions for users and groups.', 'category': 'software'}, {'entity': 'JSON', 'description': 'A lightweight data interchange format used to define resources in OpenShift.', 'category': 'software'}, {'entity': 'YAML', 'description': 'A human-readable serialization format for data that is commonly used with JSON in OpenShift.', 'category': 'software'}, {'entity': 'Pods', 'description': 'A basic execution unit in Kubernetes and OpenShift that can run one or more containers.', 'category': 'hardware'}, {'entity': 'Services', 'description': 'An abstraction layer in Kubernetes and OpenShift that provides a network identity and load balancing for accessing applications.', 'category': 'software'}, {'entity': 'Templates (parameterizable)', 'description': 'A way to define resources in OpenShift using placeholders that get replaced with parameter values when instantiated.', 'category': 'software'}]","[{'source_entity': '""ImageStreams""', 'description': 'are used to manage container images', 'destination_entity': '""Pods""'}, {'source_entity': '""ServiceAccounts""', 'description': 'provide an identity for processes running inside pods', 'destination_entity': '""Pods""'}, {'source_entity': '""YAML""', 'description': 'is used to define configuration files for various objects', 'destination_entity': '""Templates (parameterizable)""'}, {'source_entity': '""Groups""', 'description': 'are used to manage access control for users and projects', 'destination_entity': '""Users""'}, {'source_entity': '""Groups""', 'description': 'are used to manage access control for users and projects', 'destination_entity': '""Projects""'}, {'source_entity': '""Templates (parameterizable)""', 'description': 'can be used to create multiple objects with the same configuration', 'destination_entity': '""Pods""'}, {'source_entity': '""Services""', 'description': 'provide a network identity and load balancing for accessing applications', 'destination_entity': '""Users""'}, {'source_entity': '""Services""', 'description': 'provide a network identity and load balancing for accessing applications', 'destination_entity': '""Projects""'}, {'source_entity': '""Users""', 'description': 'can create and manage various objects within the cluster', 'destination_entity': '""Pods""'}, {'source_entity': '""Users""', 'description': 'can create and manage various objects within the cluster', 'destination_entity': '""Services""'}, {'source_entity': '""Projects""', 'description': 'can be used to organize and manage access control for users', 'destination_entity': '""Groups""'}, {'source_entity': '""DeploymentConfigs""', 'description': 'are used to manage the deployment of applications within the cluster', 'destination_entity': '""Pods""'}, {'source_entity': '""Templates""', 'description': 'can be used to create multiple objects with the same configuration', 'destination_entity': '""Pods""'}, {'source_entity': '""Roles-Based Access Control (RBAC)""', 'description': 'is used to manage access control for users and projects within the cluster', 'destination_entity': '""Users""'}, {'source_entity': '""Routes""', 'description': 'provide a network identity and load balancing for accessing applications', 'destination_entity': '""Services""'}, {'source_entity': '""BuildConfigs""', 'description': 'are used to manage the build process for container images', 'destination_entity': '""ImageStreams""'}, {'source_entity': '""JSON""', 'description': 'is used to define configuration files for various objects', 'destination_entity': '""Templates (parameterizable)""'}]","['[\n  {\n    ""source"": ""ImageStreams"",\n    ""destination"": ""Pods"",\n    ""relation_description"": ""are used to manage container images"",\n    ""summary_er"": ""ImageStreams are used to manage container images for Pods, ensuring efficient image management and deployment.""\n  }\n]', '[\n  {\n    ""source"": ""ServiceAccounts"",\n    ""destination"": ""Pods"",\n    ""relation_description"": ""provide an identity for processes running inside pods"",\n    ""summary_er"": ""Service Accounts provide a unique identity to processes within Pods, enabling secure communication and access control.""\n  }\n]', '[\n  {\n    ""source"": ""YAML"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""is used to define configuration files for various objects"",\n    ""summary_er"": ""YAML is used to configure pod settings, defining various object configurations.""\n  },\n  {\n    ""source"": ""Templates (parameterizable)"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""Templates (parameterizable)"",\n    ""summary_er"": ""Parameterizable templates are used to create and manage pods, allowing for dynamic configuration.""\n  }\n]', '[\n  {\n    ""source"": ""Groups"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""are used to manage access control for users and projects"",\n    ""summary_er"": ""Access control for users and projects is managed through groups, which are used to authenticate and authorize pod access.""\n  }\n]', '[\n  {\n    ""source"": ""Groups"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""are used to manage access control for users and projects"",\n    ""summary_er"": ""Access control for users and projects is managed through groups, which are used to grant or deny permissions.""\n  }\n]', '[\n  {\n    ""source"": ""Templates (parameterizable)"",\n    ""destination"": ""Pods"",\n    ""relation_description"": ""can be used to create multiple objects with the same configuration"",\n    ""summary_er"": ""Templates enable mass production of identical pods with shared configurations.""\n  }\n]', '[\n  {\n    ""source"": ""Services"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""provide a network identity and load balancing for accessing applications"",\n    ""summary_er"": ""Services provide a network identity and load balancing to enable access to applications running in pods.""\n  },\n  {\n    ""source"": ""Users"",\n    ""destination"": ""Services"",\n    ""relation_description"": """",\n    ""summary_er"": """"\n  }\n]', '[\n  {\n    ""source"": ""Services"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""provide a network identity and load balancing for accessing applications"",\n    ""summary_er"": ""Services provide a network identity and load balancing for pods, enabling access to applications.""\n  },\n  {\n    ""source"": ""Projects"",\n    ""destination"": """",\n    ""relation_description"": """",\n    ""summary_er"": """"\n  }\n]', '[\n  {\n    ""source"": ""Users"",\n    ""destination"": ""Pods"",\n    ""relation_description"": ""can create and manage various objects within the cluster"",\n    ""summary_er"": ""Users can utilize Pods to deploy, manage, and scale applications within a Kubernetes cluster.""\n  }\n]', '[\n  {\n    ""source"": ""Users"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""can create and manage various objects within the cluster"",\n    ""summary_er"": ""Users can create, configure, and manage pods in a Kubernetes cluster.""\n  },\n  {\n    ""source"": ""Services"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""can create and manage various objects within the cluster"",\n    ""summary_er"": ""Services provide load balancing and access to pods in a Kubernetes cluster.""\n  }\n]', '[\n  {\n    ""source"": ""Projects"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""can be used to organize and manage access control for users"",\n    ""summary_er"": ""Projects can be used to manage pod access control, ensuring user permissions are properly configured.""\n  }\n]', '[\n  {\n    ""source"": ""DeploymentConfigs"",\n    ""destination"": ""Pods"",\n    ""relation_description"": ""are used to manage the deployment of applications within the cluster"",\n    ""summary_er"": ""DeploymentConfigs are used to deploy applications within a Kubernetes cluster, which are then executed as Pods.""\n  }\n]', '[\n  {\n    ""source"": ""Templates"",\n    ""destination"": ""Pods"",\n    ""relation_description"": ""can be used to create multiple objects with the same configuration"",\n    ""summary_er"": ""Templates enable mass production of identical Pods, streamlining deployment and management.""\n  }\n]', '[\n  {\n    ""source"": ""Roles-Based Access Control (RBAC)"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""is used to manage access control for users and projects within the cluster"",\n    ""summary_er"": ""RBAC manages access control for users and projects in a Kubernetes cluster, ensuring secure interactions with pods.""\n  }\n]', '[\n  {\n    ""source"": ""Routes"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""provide a network identity and load balancing for accessing applications"",\n    ""summary_er"": ""A Route provides a network identity and load balancing for accessing applications, allowing users to access pods through a stable IP address.""\n  },\n  {\n    ""source"": ""Services"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""expose an application running within a pod"",\n    ""summary_er"": ""A Service exposes an application running within a pod, providing a stable network identity and load balancing for accessing the application.""\n  }\n]', '[\n  {\n    ""source"": ""BuildConfigs"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""are used to manage the build process for container images"",\n    ""summary_er"": ""BuildConfigs are used to automate the build process for container images, which are then deployed as pods.""\n  },\n  {\n    ""source"": ""ImageStreams"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""are used to manage the build process for container images"",\n    ""summary_er"": ""ImageStreams are used to manage and deploy container images, which are then run as pods in a Kubernetes cluster.""\n  }\n]', '[\n  {\n    ""source"": ""JSON"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""is used to define configuration files for various objects"",\n    ""summary_er"": ""JSON is used to configure pod settings, defining various object configurations.""\n  },\n  {\n    ""source"": ""Templates (parameterizable)"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""Templates (parameterizable)"",\n    ""summary_er"": ""Parameterizable templates are used to create pods with customizable settings.""\n  }\n]']","OpenShift provides powerful user management features, allowing users to access certain Projects (Kubernetes Namespaces with additional annotations) and granting access by a cluster administrator. Application Templates in OpenShift are parameterizable JSON or YAML manifests that can be instantiated with placeholder values replaced with parameter values.","[{'highlight': ""Kubernetes doesn't have an API object for representing an individual user of the cluster, but OpenShift provides powerful user management features.""}, {'highlight': 'Each user has access to certain Projects, which are nothing more than Kubernetes Namespaces with additional annotations.'}, {'highlight': 'Users can only act on resources that reside in the projects the user has access to.'}, {'highlight': ""OpenShift allows a parameterizable list in JSON or YAML manifest called Template; it's a list of objects whose definitions can include placeholders.""}, {'highlight': 'A template itself is a JSON or YAML file containing a list of parameters referenced in resources defined in that same JSON/YAML.'}]"
472,561,0,[],"529
Platforms built on top of Kubernetes
to be processed. To process a template, you supply the values for the template’s
parameters and then OpenShift replaces the references to the parameters with those
values. The result is a processed template, which is exactly like a Kubernetes resource
list that can then be created with a single POST request.
 OpenShift provides a long list of pre-fabricated templates that allow users to
quickly run complex applications by specifying a few arguments (or none at all, if the
template provides good defaults for those arguments). For example, a template can
enable the creation of all the Kubernetes resources necessary to run a Java EE appli-
cation inside an Application Server, which connects to a back-end database, also
deployed as part of that same template. All those components can be deployed with a
single command.
BUILDING IMAGES FROM SOURCE USING BUILDCONFIGS
One of the best features of OpenShift is the ability to have OpenShift build and imme-
diately deploy an application in the OpenShift cluster by pointing it to a Git repository
holding the application’s source code. You don’t need to build the container image at
all—OpenShift does that for you. This is done by creating a resource called Build-
Config, which can be configured to trigger builds of container images immediately
after a change is committed to the source Git repository. 
 Although OpenShift doesn’t monitor the Git repository itself, a hook in the repos-
itory can notify OpenShift of the new commit. OpenShift will then pull the changes
from the Git repository and start the build process. A build mechanism called Source
To Image can detect what type of application is in the Git repository and run the
proper build procedure for it. For example, if it detects a pom.xml file, which is used
in Java Maven-formatted projects, it runs a Maven build. The resulting artifacts are
packaged into an appropriate container image, and are then pushed to an internal
container registry (provided by OpenShift). From there, they can be pulled and run
in the cluster immediately. 
 By creating a BuildConfig object, developers can thus point to a Git repo and not
worry about building container images. Developers have almost no need to know
anything about containers. Once the ops team deploys an OpenShift cluster and
gives developers access to it, those developers can develop their code, commit, and
push it to a Git repo, the same way they used to before we started packaging apps into
containers. Then OpenShift takes care of building, deploying, and managing apps
from that code.
AUTOMATICALLY DEPLOYING NEWLY BUILT IMAGES WITH DEPLOYMENTCONFIGS
Once a new container image is built, it can also automatically be deployed in the clus-
ter. This is enabled by creating a DeploymentConfig object and pointing it to an
ImageStream. As the name suggests, an ImageStream is a stream of images. When an
image is built, it’s added to the ImageStream. This enables the DeploymentConfig to
notice the newly built image and allows it to take action and initiate a rollout of the
new image (see figure 18.9).
 
",[],"[{'entity': 'Kubernetes', 'description': 'Container orchestration platform', 'category': 'software'}, {'entity': 'OpenShift', 'description': 'Cloud platform built on top of Kubernetes', 'category': 'software'}, {'entity': 'template', 'description': 'Pre-fabricated configuration for running complex applications', 'category': 'application'}, {'entity': 'parameters', 'description': 'Values used to process a template', 'category': 'process'}, {'entity': 'POST request', 'description': 'HTTP request method for creating resources', 'category': 'protocol'}, {'entity': 'Java EE application', 'description': 'Type of application that can be run using OpenShift templates', 'category': 'application'}, {'entity': 'Application Server', 'description': 'Component used to connect to a back-end database', 'category': 'component'}, {'entity': 'BuildConfig', 'description': 'Resource used to trigger builds of container images', 'category': 'resource'}, {'entity': 'Git repository', 'description': 'Source code storage for applications', 'category': 'database'}, {'entity': 'Source To Image', 'description': 'Build mechanism that detects application type and runs proper build procedure', 'category': 'process'}, {'entity': 'Maven', 'description': 'Build tool used for Java projects', 'category': 'tool'}, {'entity': 'container image', 'description': 'Image created from source code', 'category': 'image'}, {'entity': 'DeploymentConfig', 'description': 'Resource used to automatically deploy newly built images', 'category': 'resource'}, {'entity': 'ImageStream', 'description': 'Stream of images that can be used for deployment', 'category': 'stream'}, {'entity': 'rollout', 'description': 'Process of initiating a rollout of new image', 'category': 'process'}]","[{'source_entity': 'Maven', 'description': 'builds', 'destination_entity': 'BuildConfig'}, {'source_entity': 'DeploymentConfig', 'description': 'deploys', 'destination_entity': 'Java EE application'}, {'source_entity': 'Git repository', 'description': 'hosts', 'destination_entity': 'Source To Image'}, {'source_entity': 'ImageStream', 'description': 'manages', 'destination_entity': 'container image'}, {'source_entity': 'OpenShift', 'description': 'provides', 'destination_entity': 'Kubernetes'}, {'source_entity': 'Application Server', 'description': 'serves', 'destination_entity': 'Java EE application'}, {'source_entity': 'Maven', 'description': 'generates', 'destination_entity': 'BuildConfig'}, {'source_entity': 'DeploymentConfig', 'description': 'configures', 'destination_entity': 'Kubernetes'}, {'source_entity': 'Git repository', 'description': 'stores', 'destination_entity': 'Source To Image'}, {'source_entity': 'ImageStream', 'description': 'pushes', 'destination_entity': 'container image'}, {'source_entity': 'OpenShift', 'description': 'orchestrates', 'destination_entity': 'rollout'}, {'source_entity': 'Application Server', 'description': 'hosts', 'destination_entity': 'Java EE application'}]","['[\n  {\n    ""source"": ""Maven"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""builds"",\n    ""summary_er"": ""Maven builds a pod, which is a containerized application that can be deployed in a Kubernetes cluster.""\n  }\n]', '[\n  {\n    ""source"": ""DeploymentConfig"",\n    ""destination"": ""Pod"",\n    ""relation_description"": ""deploys"",\n    ""summary_er"": ""A DeploymentConfig in Kubernetes deploys a Pod, which is an instance of a containerized application, such as a Java EE application.""\n  }\n]', '[\n  {\n    ""source"": ""Git repository"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""hosts"",\n    ""summary_er"": ""A Git repository serves as a host for a pod, providing a centralized location for storing and managing containerized applications.""\n  },\n  {\n    ""source"": ""Image"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""Source To Image"",\n    ""summary_er"": ""An image is the source used to create a new pod, allowing for efficient deployment and scaling of containerized applications.""\n  }\n]', '[\n  {\n    ""source"": ""ImageStream"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""manages"",\n    ""summary_er"": ""ImageStream manages the container image for a pod, ensuring consistent and up-to-date versions are used.""\n  }\n]', '[\n  {\n    ""source"": ""OpenShift"",\n    ""destination"": ""Kubernetes"",\n    ""relation_description"": ""provides"",\n    ""summary_er"": ""OpenShift provides a managed platform for running Kubernetes applications, offering scalability and high availability.""\n  }\n]', '[\n  {\n    ""source"": ""Application Server"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""serves"",\n    ""summary_er"": ""The Application Server deploys and manages Java EE applications within a Kubernetes pod, utilizing Docker containers for efficient resource utilization.""\n  }\n]', '[\n  {\n    ""source"": ""Maven"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""generates"",\n    ""summary_er"": ""Maven generates a pod, which is a containerized application in Kubernetes.""\n  }\n]', '[\n  {\n    ""source"": ""DeploymentConfig"",\n    ""destination"": ""Pod"",\n    ""relation_description"": ""configures"",\n    ""summary_er"": ""A DeploymentConfig in Kubernetes configures a Pod, defining its desired state and settings.""\n  }\n]', '[\n  {\n    ""source"": ""Git repository"",\n    ""destination"": ""Pod"",\n    ""relation_description"": ""stores"",\n    ""summary_er"": ""A Git repository stores a Pod\'s configuration, including Docker images and Kubernetes manifests.""\n  },\n  {\n    ""source"": ""Source To Image"",\n    ""destination"": ""Image"",\n    ""relation_description"": ""converts"",\n    ""summary_er"": ""The Source To Image process converts source code into an executable image, which can be run on a container platform like Kubernetes.""\n  }\n]', '[\n  {\n    ""source"": ""ImageStream"",\n    ""destination"": ""Pod"",\n    ""relation_description"": ""pushes"",\n    ""summary_er"": ""An ImageStream in Kubernetes pushes a container image to a Pod, allowing for efficient deployment and management of containerized applications.""\n  }\n]', '[\n  {\n    ""source"": ""OpenShift"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""orchestrates"",\n    ""summary_er"": ""OpenShift manages and coordinates the deployment of pods, ensuring efficient resource utilization and scalability.""\n  },\n  {\n    ""source"": ""OpenShift"",\n    ""destination"": ""rollout"",\n    ""relation_description"": ""orchestrates"",\n    ""summary_er"": ""OpenShift orchestrates rollouts, automating the process of deploying new versions of applications while minimizing downtime and disruption.""\n  }\n]', '[\n  {\n    ""source"": ""Application Server"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""hosts"",\n    ""summary_er"": ""The Application Server hosts a pod, which is a containerized instance of a Java EE application.""\n  }\n]']","OpenShift provides pre-fabricated templates for complex applications, allowing users to quickly run them with minimal arguments. It also enables automatic deployment of newly built images by creating a DeploymentConfig object and pointing it to an ImageStream. BuildConfigs can trigger builds immediately after changes are committed to the source Git repository, building container images without manual intervention.","[{'highlight': 'OpenShift provides a long list of pre-fabricated templates that allow users to quickly run complex applications by specifying a few arguments (or none at all, if the template provides good defaults for those arguments).'}, {'highlight': 'You don’t need to build the container image at all—OpenShift does that for you. This is done by creating a resource called Build-Config, which can be configured to trigger builds of container images immediately after a change is committed to the source Git repository.'}, {'highlight': 'Once a new container image is built, it can also automatically be deployed in the cluster. This is enabled by creating a DeploymentConfig object and pointing it to an ImageStream.'}, {'highlight': 'OpenShift takes care of building, deploying, and managing apps from that code, allowing developers to develop their code, commit, and push it to a Git repo without worrying about containers.'}, {'highlight': 'An ImageStream is a stream of images. When an image is built, it’s added to the ImageStream, enabling the DeploymentConfig to notice the newly built image and initiate a rollout of the new image.'}]"
473,562,0,[],"530
CHAPTER 18
Extending Kubernetes
A DeploymentConfig is almost identical to the Deployment object in Kubernetes, but
it pre-dates it. Like a Deployment object, it has a configurable strategy for transition-
ing between Deployments. It contains a pod template used to create the actual pods,
but it also allows you to configure pre- and post-deployment hooks. In contrast to a
Kubernetes Deployment, it creates ReplicationControllers instead of ReplicaSets and
provides a few additional features.
EXPOSING SERVICES EXTERNALLY USING ROUTES
Early on, Kubernetes didn’t provide Ingress objects. To expose Services to the outside
world, you needed to use NodePort or LoadBalancer-type Services. But at that time,
OpenShift already provided a better option through a Route resource. A Route is sim-
ilar to an Ingress, but it provides additional configuration related to TLS termination
and traffic splitting. 
 Similar to an Ingress controller, a Route needs a Router, which is a controller that
provides the load balancer or proxy. In contrast to Kubernetes, the Router is available
out of the box in OpenShift. 
TRYING OUT OPENSHIFT
If you’re interested in trying out OpenShift, you can start by using Minishift, which is
the OpenShift equivalent of Minikube, or you can try OpenShift Online Starter at
https:/
/manage.openshift.com, which is a free multi-tenant, hosted solution provided
to get you started with OpenShift. 
18.3.2 Deis Workflow and Helm
A company called Deis, which has recently been acquired by Microsoft, also provides a
PaaS called Workflow, which is also built on top of Kubernetes. Besides Workflow,
Pods
Builder pod
Replication
Controller
BuildConﬁg
Git repo
DeploymentConﬁg
ImageStream
Build trigger
Clones Git repo, builds new
image from source, and adds
it to the ImageStream
Watches for new images in ImageStream
and rolls out new version (similarly to a
Deployment)
Figure 18.9
BuildConfigs and DeploymentConfigs in OpenShift
 
",[],"[{'entity': 'Kubernetes', 'description': 'Container orchestration system', 'category': 'software'}, {'entity': 'DeploymentConfig', 'description': 'OpenShift resource for deploying applications', 'category': 'software'}, {'entity': 'ReplicationController', 'description': 'OpenShift resource for managing replicas of a pod', 'category': 'software'}, {'entity': 'Pod', 'description': 'Lightweight and portable container runtime', 'category': 'container'}, {'entity': 'Builder pod', 'description': 'OpenShift component for building images', 'category': 'component'}, {'entity': 'BuildConfig', 'description': 'OpenShift resource for configuring builds', 'category': 'software'}, {'entity': 'DeploymentConfig', 'description': 'OpenShift resource for deploying applications', 'category': 'software'}, {'entity': 'ImageStream', 'description': 'OpenShift resource for managing images', 'category': 'software'}, {'entity': 'Build trigger', 'description': 'OpenShift component for triggering builds', 'category': 'component'}, {'entity': 'Git repo', 'description': 'Version control system', 'category': 'software'}, {'entity': 'Minishift', 'description': 'Tool for running OpenShift locally', 'category': 'software'}, {'entity': 'OpenShift Online Starter', 'description': 'Free, hosted version of OpenShift', 'category': 'service'}, {'entity': 'Deis Workflow', 'description': 'PaaS built on top of Kubernetes', 'category': 'software'}, {'entity': 'Helm', 'description': 'Package manager for Kubernetes', 'category': 'software'}]","[{'source_entity': '""OpenShift Online Starter""', 'description': 'provides', 'destination_entity': '""DeploymentConfig""'}, {'source_entity': '""OpenShift Online Starter""', 'description': 'supports', 'destination_entity': '""BuildConfig""'}, {'source_entity': '""OpenShift Online Starter""', 'description': 'integrates with', 'destination_entity': '""Helm""'}, {'source_entity': '""DeploymentConfig""', 'description': 'defines', 'destination_entity': '""ReplicationController""'}, {'source_entity': '""BuildConfig""', 'description': 'specifies', 'destination_entity': '""ImageStream""'}, {'source_entity': '""OpenShift Online Starter""', 'description': 'uses', 'destination_entity': '""Git repo""'}, {'source_entity': '""Build trigger""', 'description': 'triggers', 'destination_entity': '""Builder pod""'}, {'source_entity': '""Kubernetes""', 'description': 'runs on', 'destination_entity': '""Minishift""'}, {'source_entity': '""Deis Workflow""', 'description': 'uses', 'destination_entity': '""Pod""'}, {'source_entity': '""OpenShift Online Starter""', 'description': 'deploys', 'destination_entity': '""DeploymentConfig""'}]","['[\n  {\n    ""source"": ""OpenShift Online Starter"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""provides"",\n    ""summary_er"": ""OpenShift Online Starter provides a managed Kubernetes environment for deploying and managing pods.""\n  }\n]', '[\n  {\n    ""source"": ""OpenShift Online Starter"",\n    ""destination"": ""pod BuildConfig"",\n    ""relation_description"": ""supports"",\n    ""summary_er"": ""OpenShift Online Starter supports a pod named BuildConfig, providing a scalable and secure environment for its execution.""\n  }\n]', '[\n  {\n    ""source"": ""OpenShift Online Starter"",\n    ""destination"": ""Helm"",\n    ""relation_description"": ""integrates with"",\n    ""summary_er"": ""OpenShift Online Starter integrates with Helm to provide a seamless deployment experience for applications.""\n  }\n]', '[\n  {\n    ""source"": ""DeploymentConfig"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""defines"",\n    ""summary_er"": ""A DeploymentConfig defines a template for creating one or more pods, which are the basic execution units in Kubernetes.""\n  }\n]', '[\n  {\n    ""source"": ""BuildConfig"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""specifies"",\n    ""summary_er"": ""A BuildConfig defines a container image build process, which results in a pod being created with the built image.""\n  },\n  {\n    ""source"": ""ImageStream"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""used by"",\n    ""summary_er"": ""An ImageStream is used to create or update a pod with an existing container image from the stream.""\n  }\n]', '[\n  {\n    ""source"": ""OpenShift Online Starter"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""uses"",\n    ""summary_er"": ""OpenShift Online Starter utilizes a pod to manage and deploy applications.""\n  }\n]', '[\n  {\n    ""source"": ""Build trigger"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""triggers"",\n    ""summary_er"": ""A build trigger initiates the creation of a pod in response to specific events or conditions.""\n  }\n]', '[\n  {\n    ""source"": ""Kubernetes"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""runs on"",\n    ""summary_er"": ""Kubernetes manages and orchestrates containerized applications, including pods, which are the basic execution unit in Kubernetes.""\n  }\n]', '[\n  {\n    ""source"": ""Deis Workflow"",\n    ""destination"": ""Pod"",\n    ""relation_description"": ""uses"",\n    ""summary_er"": ""Deis Workflow utilizes a Pod to execute its workflow, leveraging the pod\'s resources and capabilities.""\n  }\n]', '[\n  {\n    ""source"": ""OpenShift Online Starter"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""deploys"",\n    ""summary_er"": ""OpenShift Online Starter deploys a containerized application to a pod, utilizing Kubernetes for orchestration and management.""\n  }\n]']","Kubernetes can be extended with features from OpenShift, such as DeploymentConfig, which provides pre- and post-deployment hooks and creates ReplicationControllers instead of ReplicaSets. Routes are used to expose Services externally, providing additional configuration for TLS termination and traffic splitting. Minishift is available for trying out OpenShift, along with OpenShift Online Starter. Deis Workflow, also built on Kubernetes, provides a PaaS with features like BuildConfigs and DeploymentConfigs.","[{'highlight': 'A DeploymentConfig is almost identical to the Deployment object in Kubernetes, but it pre-dates it.'}, {'highlight': 'To expose Services to the outside world, you needed to use NodePort or LoadBalancer-type Services, but OpenShift provided a better option through a Route resource.'}, {'highlight': 'A Route needs a Router, which is a controller that provides the load balancer or proxy, and this Router is available out of the box in OpenShift.'}, {'highlight': 'Deis Workflow and Helm provide a PaaS built on top of Kubernetes, with features like BuildConfigs and DeploymentConfigs.'}, {'highlight': 'Minishift and OpenShift Online Starter are free multi-tenant, hosted solutions provided to get you started with OpenShift.'}]"
474,563,0,[],"531
Platforms built on top of Kubernetes
they’ve also developed a tool called Helm, which is gaining traction in the Kubernetes
community as a standard way of deploying existing apps in Kubernetes. We’ll take a
brief look at both.
INTRODUCING DEIS WORKFLOW
You can deploy Deis Workflow to any existing Kubernetes cluster (unlike OpenShift,
which is a complete cluster with a modified API server and other Kubernetes compo-
nents). When you run Workflow, it creates a set of Services and ReplicationControllers,
which then provide developers with a simple, developer-friendly environment. 
 Deploying new versions of your app is triggered by pushing your changes with git
push deis master and letting Workflow take care of the rest. Similar to OpenShift,
Workflow also provides a source to image mechanism, application rollouts and roll-
backs, edge routing, and also log aggregation, metrics, and alerting, which aren’t
available in core Kubernetes. 
 To run Workflow in your Kubernetes cluster, you first need to install the Deis Work-
flow and Helm CLI tools and then install Workflow into your cluster. We won’t go into
how to do that here, but if you’d like to learn more, visit the website at https:/
/deis
.com/workflow. What we’ll explore here is the Helm tool, which can be used without
Workflow and has gained popularity in the community.
DEPLOYING RESOURCES THROUGH HELM
Helm is a package manager for Kubernetes (similar to OS package managers like yum
or apt in Linux or homebrew in MacOS). 
 Helm is comprised of two things:
A helm CLI tool (the client).
Tiller, a server component running as a Pod inside the Kubernetes cluster.
Those two components are used to deploy and manage application packages in a
Kubernetes cluster. Helm application packages are called Charts. They’re combined
with a Config, which contains configuration information and is merged into a Chart
to create a Release, which is a running instance of an application (a combined Chart
and Config). You deploy and manage Releases using the helm CLI tool, which talks to
the Tiller server, which is the component that creates all the necessary Kubernetes
resources defined in the Chart, as shown in figure 18.10.
 You can create charts yourself and keep them on your local disk, or you can use
any existing chart, which is available in the growing list of helm charts maintained by
the community at https:/
/github.com/kubernetes/charts. The list includes charts for
applications such as PostgreSQL, MySQL, MariaDB, Magento, Memcached, MongoDB,
OpenVPN, PHPBB, RabbitMQ, Redis, WordPress, and others.
 Similar to how you don’t build and install apps developed by other people to your
Linux system manually, you probably don’t want to build and manage your own
Kubernetes manifests for such applications, right? That’s why you’ll want to use Helm
and the charts available in the GitHub repository I mentioned. 
 
",[],"[{'entity': 'Kubernetes', 'description': 'Container orchestration platform', 'category': 'software'}, {'entity': 'Helm', 'description': 'Package manager for Kubernetes', 'category': 'software'}, {'entity': 'Deis Workflow', 'description': 'Developer-friendly environment on top of Kubernetes', 'category': 'software'}, {'entity': 'Services', 'description': 'Kubernetes resource for exposing applications to the network', 'category': 'software'}, {'entity': 'ReplicationControllers', 'description': 'Kubernetes resource for managing application replicas', 'category': 'software'}, {'entity': 'git', 'description': 'Version control system', 'category': 'software'}, {'entity': 'Tiller', 'description': 'Server component of Helm running as a Pod inside the Kubernetes cluster', 'category': 'software'}, {'entity': 'Pod', 'description': 'Kubernetes resource for running an application container', 'category': 'software'}, {'entity': 'Charts', 'description': 'Helm packages containing application configuration and resources', 'category': 'software'}, {'entity': 'Config', 'description': 'Configuration information merged into a Chart to create a Release', 'category': 'software'}, {'entity': 'Release', 'description': 'Running instance of an application created from a Chart and Config', 'category': 'software'}, {'entity': 'Kubernetes cluster', 'description': 'Group of machines running Kubernetes', 'category': 'hardware/network'}, {'entity': 'API server', 'description': 'Component of a Kubernetes cluster responsible for managing API requests', 'category': 'software'}, {'entity': 'Linux system', 'description': 'Operating system', 'category': 'hardware/software'}]","[{'source_entity': '""Helm""', 'description': 'manages', 'destination_entity': '""ReplicationControllers""'}, {'source_entity': '""Helm""', 'description': 'deploys', 'destination_entity': '""Services""'}, {'source_entity': '""git""', 'description': 'hosts', 'destination_entity': '""Charts""'}, {'source_entity': '""Kubernetes cluster""', 'description': 'uses', 'destination_entity': '""API server""'}, {'source_entity': '""API server""', 'description': 'communicates with', 'destination_entity': '""Linux system""'}, {'source_entity': '""Helm""', 'description': 'integrates with', 'destination_entity': '""Kubernetes""'}, {'source_entity': '""Release""', 'description': 'manages', 'destination_entity': '""Config""'}, {'source_entity': '""Tiller""', 'description': 'uses', 'destination_entity': '""Helm""'}, {'source_entity': '""Deis Workflow""', 'description': 'integrates with', 'destination_entity': '""Kubernetes cluster""'}, {'source_entity': '""Pod""', 'description': 'runs on', 'destination_entity': '""Linux system""'}]","['[\n  {\n    ""source"": ""Helm"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""manages"",\n    ""summary_er"": ""Helm manages pods, providing a flexible way to deploy and manage containerized applications.""\n  }\n]', '[\n  {\n    ""source"": ""Helm"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""deploys"",\n    ""summary_er"": ""Helm is a package manager for Kubernetes that deploys applications as pods.""\n  }\n]', '[\n  {\n    ""source"": ""git"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""hosts"",\n    ""summary_er"": ""Git repository hosted on a Kubernetes pod, allowing for version control and deployment of applications.""\n  },\n  {\n    ""source"": ""Charts"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""hosts"",\n    ""summary_er"": ""Helm charts used to deploy and manage applications on a Kubernetes pod, providing a standardized way of packaging and deploying software.""\n  }\n]', '[\n  {\n    ""source"": ""Kubernetes cluster"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""uses"",\n    ""summary_er"": ""A Kubernetes cluster utilizes one or more pods to execute containerized applications, with the API server being a key component that manages and controls these pods.""\n  }\n]', '[\n  {\n    ""source"": ""API server"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""communicates with"",\n    ""summary_er"": ""The API server interacts with a Linux-based pod to facilitate communication and data exchange.""\n  }\n]', '[\n  {\n    ""source"": ""Helm"",\n    ""destination"": ""Kubernetes"",\n    ""relation_description"": ""integrates with"",\n    ""summary_er"": ""Helm integrates Kubernetes to manage deployments and configurations.""\n  }\n]', '[\n  {\n    ""source"": ""Release"",\n    ""destination"": ""Pod"",\n    ""relation_description"": ""manages"",\n    ""summary_er"": ""A Release entity manages a Pod entity, overseeing its lifecycle and configuration.""\n  },\n  {\n    ""source"": ""Config"",\n    ""destination"": ""Pod"",\n    ""relation_description"": ""manages"",\n    ""summary_er"": ""A Config entity manages a Pod entity, configuring its settings and parameters.""\n  }\n]', '[\n  {\n    ""source"": ""Tiller"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""uses"",\n    ""summary_er"": ""Tiller, a component of Helm, uses a pod to execute its functionality.""\n  }\n]', '[\n  {\n    ""source"": ""Deis Workflow"",\n    ""destination"": ""Kubernetes cluster"",\n    ""relation_description"": ""integrates with"",\n    ""summary_er"": ""Deis Workflow integrates with a Kubernetes cluster to leverage its container orchestration capabilities.""\n  }\n]', '[\n  {\n    ""source"": ""Pod"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""runs on"",\n    ""summary_er"": ""A Pod is a logical host that runs one or more containers, providing a runtime environment for applications.""\n  },\n  {\n    ""source"": ""Pod"",\n    ""destination"": ""Linux system"",\n    ""relation_description"": ""runs on"",\n    ""summary_er"": ""A Pod runs on top of a Linux system, utilizing its kernel and core services to execute containerized applications.""\n  }\n]']","Deis Workflow is a tool built on top of Kubernetes that creates services and replication controllers, providing developers with a simple environment. Deploying new versions of an app can be triggered by pushing changes with 'git push deis master'. The Helm tool is a package manager for Kubernetes, allowing the deployment and management of application packages called Charts.","[{'highlight': 'Deis Workflow is a tool that can be deployed on any existing Kubernetes cluster and provides developers with a simple, developer-friendly environment.'}, {'highlight': 'Helm is a package manager for Kubernetes that allows users to deploy and manage application packages in a Kubernetes cluster through the use of Charts, Configs, and Releases.'}, {'highlight': 'Charts are pre-built application packages in Helm that can be used to deploy applications in a Kubernetes cluster, with many charts available in the community at https://github.com/kubernetes/charts.'}, {'highlight': 'Tiller is a server component running as a Pod inside the Kubernetes cluster that creates all the necessary Kubernetes resources defined in a Chart when deploying an application through Helm.'}, {'highlight': 'The helm CLI tool can be used to deploy and manage Releases, which are running instances of applications created by combining Charts with Configs, without requiring users to build and install their own Kubernetes manifests for such applications.'}]"
475,564,0,[],"532
CHAPTER 18
Extending Kubernetes
When you want to run a PostgreSQL or a MySQL database in your Kubernetes cluster,
don’t start writing manifests for them. Instead, check if someone else has already gone
through the trouble and prepared a Helm chart for it. 
 Once someone prepares a Helm chart for a specific application and adds it to the
Helm chart GitHub repo, installing the whole application takes a single one-line com-
mand. For example, to run MySQL in your Kubernetes cluster, all you need to do is
clone the charts Git repo to your local machine and run the following command (pro-
vided you have Helm’s CLI tool and Tiller running in your cluster):
$ helm install --name my-database stable/mysql
This will create all the necessary Deployments, Services, Secrets, and PersistentVolu-
meClaims needed to run MySQL in your cluster. You don’t need to concern yourself
with what components you need and how to configure them to run MySQL properly.
I’m sure you’ll agree this is awesome.
TIP
One of the most interesting charts available in the repo is an OpenVPN
chart, which runs an OpenVPN server inside your Kubernetes cluster and
allows you to enter the pod network through VPN and access Services as if
your local machine was a pod in the cluster. This is useful when you’re devel-
oping apps and running them locally.
These were several examples of how Kubernetes can be extended and how companies
like Red Hat and Deis (now Microsoft) have extended it. Now go and start riding the
Kubernetes wave yourself!
Kubernetes cluster
Chart
and
Conﬁg
Helm
Charts
(ﬁles on
local disk)
Tiller
(pod)
Deployments,
Services, and
other objects
helm
CLI tool
Manages
charts
Combines Chart and
Conﬁg into a Release
Creates Kubernetes objects
deﬁned in the Release
Figure 18.10
Overview of Helm
 
",[],"[{'entity': 'Kubernetes', 'description': 'Container orchestration system', 'category': 'software'}, {'entity': 'PostgreSQL', 'description': 'Database management system', 'category': 'database'}, {'entity': 'MySQL', 'description': 'Database management system', 'category': 'database'}, {'entity': 'Helm chart', 'description': 'Package for deploying applications to Kubernetes', 'category': 'software'}, {'entity': 'Deployments', 'description': 'Kubernetes object for managing replicas of a pod', 'category': 'application'}, {'entity': 'Services', 'description': 'Kubernetes object for exposing applications to the network', 'category': 'application'}, {'entity': 'Secrets', 'description': 'Kubernetes object for storing sensitive information', 'category': 'database'}, {'entity': 'PersistentVolumeClaims', 'description': 'Kubernetes object for requesting storage resources', 'category': 'storage'}, {'entity': 'OpenVPN', 'description': 'Virtual private network software', 'category': 'software'}, {'entity': 'Tiller', 'description': 'Helm component for managing releases in a Kubernetes cluster', 'category': 'software'}, {'entity': 'helm CLI tool', 'description': 'Command-line interface for interacting with Helm', 'category': 'software'}, {'entity': 'Release', 'description': 'Helm object for managing a deployment in a Kubernetes cluster', 'category': 'application'}]","[{'source_entity': '""Helm chart""', 'description': 'provides a template for deploying applications', 'destination_entity': '""Services""'}, {'source_entity': '""helm CLI tool""', 'description': 'manages Helm charts and releases', 'destination_entity': '""Release""'}, {'source_entity': '""Kubernetes""', 'description': 'orchestrates containerized applications', 'destination_entity': '""Deployments""'}, {'source_entity': '""Helm chart""', 'description': 'deploys and manages applications', 'destination_entity': '""MySQL""'}, {'source_entity': '""Tiller""', 'description': 'acts as a server for Helm charts', 'destination_entity': '""helm CLI tool""'}, {'source_entity': '""Helm chart""', 'description': 'manages Persistent Volumes and Claims', 'destination_entity': '""PersistentVolumeClaims""'}, {'source_entity': '""Kubernetes""', 'description': 'provides a platform for running containerized applications', 'destination_entity': '""OpenVPN""'}, {'source_entity': '""PostgreSQL""', 'description': 'manages databases and data storage', 'destination_entity': '""Secrets""'}, {'source_entity': '""Helm chart""', 'description': 'deploys and manages applications', 'destination_entity': '""Deployments""'}]","['[\n  {\n    ""source"": ""Helm chart"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""provides a template for deploying applications"",\n    ""summary_er"": ""A Helm chart provides a template for deploying applications, allowing users to easily deploy and manage containers using Kubernetes.""\n  },\n  {\n    ""source"": ""Services"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""exposes an application running in a pod"",\n    ""summary_er"": ""Services expose an application running in a pod, providing a network identity and load balancing for the application.""\n  }\n]', '[\n  {\n    ""source"": ""Helm CLI tool"",\n    ""destination"": ""Pod"",\n    ""relation_description"": ""manages Helm charts and releases"",\n    ""summary_er"": ""The Helm CLI tool manages and deploys Helm charts to pods, ensuring smooth release management.""\n  }\n]', '[\n  {\n    ""source"": ""Kubernetes"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""orchestrates containerized applications"",\n    ""summary_er"": ""Kubernetes manages and schedules pods, ensuring efficient resource utilization and application scalability.""\n  }\n]', '[\n  {\n    ""source"": ""Helm chart"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""deploys and manages applications"",\n    ""summary_er"": ""A Helm chart deploys and manages applications as a pod, utilizing Kubernetes resources.""\n  }\n]', '[\n  {\n    ""source"": ""Tiller"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""acts as a server for Helm charts"",\n    ""summary_er"": ""Tiller serves as a server for Helm charts, managing deployments and upgrades.""\n  },\n  {\n    ""source"": ""helm CLI tool"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""deploys and manages applications"",\n    ""summary_er"": ""The helm CLI tool deploys and manages applications by interacting with the pod.""\n  }\n]', '[\n  {\n    ""source"": ""Helm chart"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""manages Persistent Volumes and Claims"",\n    ""summary_er"": ""The Helm chart manages persistent volumes and claims for a pod, ensuring data persistence and storage management.""\n  }\n]', '[\n  {\n    ""source"": ""Kubernetes"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""provides a platform for running containerized applications"",\n    ""summary_er"": ""Kubernetes provides a platform to run containerized apps, including pods.""\n  }\n]', '[\n  {\n    ""source"": ""PostgreSQL"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""manages databases and data storage"",\n    ""summary_er"": ""PostgreSQL manages database and data storage for a pod, ensuring secure and efficient data management.""\n  },\n  {\n    ""source"": ""PostgreSQL"",\n    ""destination"": ""Secrets"",\n    ""relation_description"": ""manages databases and data storage"",\n    ""summary_er"": ""PostgreSQL utilizes Secrets to securely store and manage sensitive data, such as database credentials and access keys.""\n  }\n]', '[\n  {\n    ""source"": ""Helm chart"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""deploys and manages applications"",\n    ""summary_er"": ""A Helm chart deploys and manages applications by creating a pod, which is a container running an application.""\n  }\n]']","When extending Kubernetes, instead of writing manifests for apps like PostgreSQL or MySQL, check if someone has prepared a Helm chart for it. Once installed, running the app takes a single command and creates necessary Deployments, Services, Secrets, and PersistentVolumeClaims.","[{'highlight': 'You can run a PostgreSQL or MySQL database in your Kubernetes cluster by using a pre-made Helm chart, which can be installed with a single one-line command.'}, {'highlight': 'Helm charts provide a convenient way to install and manage applications in a Kubernetes cluster, without requiring manual configuration of components.'}, {'highlight': 'The OpenVPN chart is an example of a Helm chart that allows you to run an OpenVPN server inside your Kubernetes cluster and access Services as if your local machine was a pod in the cluster.'}, {'highlight': 'Companies like Red Hat and Deis (now Microsoft) have extended Kubernetes by providing pre-made Helm charts for various applications, making it easier to use and extend the platform.'}, {'highlight': 'Helm is a package manager for Kubernetes that allows you to manage charts, which are files on local disk that contain configuration and other metadata for deploying applications in a cluster.'}]"
476,565,0,[],"533
Summary
18.4
Summary
This final chapter has shown you how you can go beyond the existing functionalities
Kubernetes provides and how companies like Dies and Red Hat have done it. You’ve
learned how
Custom resources can be registered in the API server by creating a Custom-
ResourceDefinition object.
Instances of custom objects can be stored, retrieved, updated, and deleted with-
out having to change the API server code.
A custom controller can be implemented to bring those objects to life.
Kubernetes can be extended with custom API servers through API aggregation.
Kubernetes Service Catalog makes it possible to self-provision external services
and expose them to pods running in the Kubernetes cluster.
Platforms-as-a-Service built on top of Kubernetes make it easy to build contain-
erized applications inside the same Kubernetes cluster that then runs them. 
A package manager called Helm makes deploying existing apps without requir-
ing you to build resource manifests for them.
Thank you for taking the time to read through this long book. I hope you’ve learned
as much from reading it as I have from writing it.
 
",[],"[{'entity': 'Kubernetes', 'description': 'Container orchestration system', 'category': 'software'}, {'entity': 'Custom-ResourceDefinition', 'description': 'API server object for registering custom resources', 'category': 'software'}, {'entity': 'API server', 'description': 'Component of Kubernetes that manages API requests', 'category': 'software'}, {'entity': 'Controller', 'description': 'Kubernetes component that watches and responds to changes in the cluster', 'category': 'software'}, {'entity': 'Pods', 'description': 'Lightweight and portable container runtime environment', 'category': 'container'}, {'entity': 'Cluster', 'description': 'Group of machines that run Kubernetes', 'category': 'hardware/network'}, {'entity': 'Helm', 'description': 'Package manager for deploying applications to Kubernetes', 'category': 'software'}, {'entity': 'Resource manifests', 'description': 'Files that define the resources needed by an application', 'category': 'software'}, {'entity': 'API aggregation', 'description': 'Kubernetes feature that allows custom API servers to be added', 'category': 'software'}, {'entity': 'Service Catalog', 'description': 'Kubernetes feature that enables self-provisioning of external services', 'category': 'software'}]","[{'source_entity': '""Helm""', 'description': 'provides', 'destination_entity': '""API aggregation""'}, {'source_entity': '""API server""', 'description': 'hosts', 'destination_entity': '""Pods""'}, {'source_entity': '""Kubernetes""', 'description': 'manages', 'destination_entity': '""Cluster""'}, {'source_entity': '""Resource manifests""', 'description': 'are used by', 'destination_entity': '""API server""'}, {'source_entity': '""Service Catalog""', 'description': 'is a part of', 'destination_entity': '""Kubernetes""'}, {'source_entity': '""Custom-ResourceDefinition""', 'description': 'is used to define', 'destination_entity': '""Controller""'}, {'source_entity': '""API aggregation""', 'description': 'provides a way to', 'destination_entity': '""expose multiple APIs as a single API""'}, {'source_entity': '""Helm""', 'description': 'is used to manage', 'destination_entity': '""Resource manifests""'}]","['[\n  {\n    ""source"": ""Helm"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""provides"",\n    ""summary_er"": ""Helm provides a way to manage and deploy applications in Kubernetes, specifically pods.""\n  }\n]', '[\n  {\n    ""source"": ""API server"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""hosts"",\n    ""summary_er"": ""The API server hosts a pod, which is a containerized application that provides a specific service.""\n  }\n]', '[\n  {\n    ""source"": ""Kubernetes"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""manages"",\n    ""summary_er"": ""Kubernetes manages a collection of containers called pods, providing a runtime environment for applications.""\n  },\n  {\n    ""source"": ""Kubernetes"",\n    ""destination"": ""Cluster"",\n    ""relation_description"": ""manages"",\n    ""summary_er"": ""Kubernetes manages a cluster of machines, automating the deployment and scaling of containerized applications.""\n  }\n]', '[\n  {\n    ""source"": ""Resource manifests"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""are used by"",\n    ""summary_er"": ""Resource manifests are utilized by pods to define their configuration and settings.""\n  },\n  {\n    ""source"": ""API server"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""is a part of"",\n    ""summary_er"": ""The API server is an integral component of the pod, responsible for managing its lifecycle and interactions.""\n  }\n]', '[\n  {\n    ""source"": ""Service Catalog"",\n    ""destination"": ""Kubernetes"",\n    ""relation_description"": ""is a part of"",\n    ""summary_er"": ""The Service Catalog is an integral component of Kubernetes, providing a centralized interface for deploying and managing applications.""\n  }\n]', '[\n  {\n    ""source"": ""Custom-ResourceDefinition"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""is used to define"",\n    ""summary_er"": ""A Custom Resource Definition (CRD) is used to define a custom resource, which can be a pod in this context.""\n  },\n  {\n    ""source"": ""Controller"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""manages"",\n    ""summary_er"": ""A controller manages the lifecycle of a pod, ensuring it\'s running and healthy.""\n  }\n]', '[\n  {\n    ""source"": ""API aggregation"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""provides a way to expose multiple APIs as a single API"",\n    ""summary_er"": ""API aggregation enables combining multiple APIs into a unified interface, simplifying interactions and improving user experience.""\n  }\n]', '[\n  {\n    ""source"": ""Helm"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""is used to manage"",\n    ""summary_er"": ""Helm is a package manager for Kubernetes that helps manage resources and deployments.""\n  }\n]']","This final chapter shows how to extend Kubernetes' functionalities by registering custom resources, implementing custom controllers, and using API aggregation, Service Catalog, and platforms-as-a-service built on top of Kubernetes. A package manager called Helm is also introduced for deploying existing apps without requiring resource manifests.","[{'highlight': 'Custom resources can be registered in the API server by creating a Custom-ResourceDefinition object.'}, {'highlight': 'Instances of custom objects can be stored, retrieved, updated, and deleted without having to change the API server code.'}, {'highlight': 'A custom controller can be implemented to bring those objects to life.'}, {'highlight': 'Kubernetes Service Catalog makes it possible to self-provision external services and expose them to pods running in the Kubernetes cluster.'}, {'highlight': 'A package manager called Helm makes deploying existing apps without requiring you to build resource manifests for them.'}]"
477,566,0,[],"534
appendix A
Using kubectl
with multiple clusters
A.1
Switching between Minikube and Google Kubernetes 
Engine
The examples in this book can either be run in a cluster created with Minikube, or
one created with Google Kubernetes Engine (GKE). If you plan on using both, you
need to know how to switch between them. A detailed explanation of how to use
kubectl with multiple clusters is described in the next section. Here we look at how
to switch between Minikube and GKE.
SWITCHING TO MINIKUBE
Luckily, every time you start up a Minikube cluster with minikube start, it also
reconfigures kubectl to use it:
$ minikube start
Starting local Kubernetes cluster...
...
Setting up kubeconfig...                            
Kubectl is now configured to use the cluster.       
After switching from Minikube to GKE, you can switch back by stopping Minikube
and starting it up again. kubectl will then be re-configured to use the Minikube clus-
ter again.
SWITCHING TO GKE
To switch to using the GKE cluster, you can use the following command:
$ gcloud container clusters get-credentials my-gke-cluster
This will configure kubectl to use the GKE cluster called my-gke-cluster.
Minikube sets up kubectl every 
time you start the cluster.
 
",[],"[{'entity': 'kubectl', 'description': 'Command-line tool for interacting with Kubernetes clusters', 'category': 'software'}, {'entity': 'Minikube', 'description': 'Local Kubernetes cluster creation tool', 'category': 'software'}, {'entity': 'Google Kubernetes Engine (GKE)', 'description': 'Cloud-based managed Kubernetes service', 'category': 'cloud service'}, {'entity': 'kubeconfig', 'description': 'Configuration file for kubectl to interact with clusters', 'category': 'configuration'}, {'entity': 'minikube start', 'description': 'Command to start a Minikube cluster and reconfigure kubectl', 'category': 'command'}, {'entity': 'gcloud container clusters get-credentials', 'description': 'Command to configure kubectl to use a GKE cluster', 'category': 'command'}]","[{'source_entity': 'kubeconfig', 'description': 'is used to configure', 'destination_entity': 'Minikube'}, {'source_entity': 'kubectl', 'description': 'is used to interact with', 'destination_entity': 'Minikube'}, {'source_entity': 'kubectl', 'description': 'is used to manage', 'destination_entity': 'Google Kubernetes Engine (GKE)'}, {'source_entity': 'gcloud container clusters get-credentials', 'description': 'is used to retrieve credentials for', 'destination_entity': 'Google Kubernetes Engine (GKE)'}, {'source_entity': 'minikube start', 'description': 'starts the Minikube cluster', 'destination_entity': 'Minikube'}, {'source_entity': 'kubectl', 'description': 'is used to deploy applications to', 'destination_entity': 'Google Kubernetes Engine (GKE)'}]","['[\n  {\n    ""source"": ""kubeconfig"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""is used to configure"",\n    ""summary_er"": ""Kubeconfig is a file that configures pod settings, such as authentication and authorization.""\n  }\n]', '[\n  {\n    ""source"": ""kubectl"",\n    ""destination"": ""Minikube"",\n    ""relation_description"": ""is used to interact with"",\n    ""summary_er"": ""Kubectl is a command-line tool used to interact with Minikube, allowing users to manage and deploy applications on the Kubernetes cluster.""\n  }\n]', '[\n  {\n    ""source"": ""kubectl"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""is used to manage"",\n    ""summary_er"": ""kubectl is a command-line tool used to manage and deploy applications in Kubernetes, specifically pods.""\n  },\n  {\n    ""source"": ""GKE"",\n    ""destination"": ""Kubernetes Engine"",\n    ""relation_description"": ""Google"",\n    ""summary_er"": ""GKE stands for Google Kubernetes Engine, which is a managed environment for deploying containerized applications using Kubernetes.""\n  }\n]', '[\n  {\n    ""source"": ""gcloud container clusters get-credentials"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""is used to retrieve credentials for"",\n    ""summary_er"": ""This command retrieves credentials for a Google Kubernetes Engine (GKE) cluster, allowing access to the cluster\'s resources.""\n  }\n]', '[\n  {\n    ""source"": ""minikube"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""starts"",\n    ""summary_er"": ""Minikube starts a new pod for containerized applications.""\n  }\n]', '[\n  {\n    ""source"": ""kubectl"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""is used to deploy applications to"",\n    ""summary_er"": ""kubectl is used to deploy applications to pods in a Kubernetes cluster.""\n  },\n  {\n    ""source"": ""pod"",\n    ""destination"": ""Google Kubernetes Engine (GKE)"",\n    ""relation_description"": ""deployment target"",\n    ""summary_er"": ""Pods are deployed to Google Kubernetes Engine (GKE) for scalable and secure application hosting.""\n  }\n]']","To switch between Minikube and Google Kubernetes Engine (GKE) clusters using kubectl, simply run 'minikube start' to configure kubectl for Minikube or use 'gcloud container clusters get-credentials my-gke-cluster' to set up GKE. Minikube reconfigures kubectl every time you start the cluster, making it easy to switch between the two.","[{'highlight': 'You can run examples in this book either in a Minikube cluster or a Google Kubernetes Engine (GKE) cluster.'}, {'highlight': ""To switch between Minikube and GKE, you need to reconfigure kubectl using the 'minikube start' command for Minikube and the 'gcloud container clusters get-credentials' command for GKE.""}, {'highlight': 'Minikube automatically sets up kubectl every time you start a new cluster.'}, {'highlight': 'To switch from GKE to Minikube, stop Minikube and restart it; this will reconfigure kubectl to use the Minikube cluster again.'}, {'highlight': ""The 'gcloud container clusters get-credentials' command is used to configure kubectl to use a specific GKE cluster.""}]"
478,567,0,[],"535
Using kubectl with multiple clusters or namespaces
GOING FURTHER
These two methods should be enough to get you started quickly, but to understand
the complete picture of using kubectl with multiple clusters, study the next section. 
A.2
Using kubectl with multiple clusters or namespaces
If you need to switch between different Kubernetes clusters, or if you want to work in a
different namespace than the default and don’t want to specify the --namespace
option every time you run kubectl, here’s how to do it.
A.2.1
Configuring the location of the kubeconfig file
The config used by kubectl is usually stored in the ~/.kube/config file. If it’s stored
somewhere else, the KUBECONFIG environment variable needs to point to its location. 
NOTE
You can use multiple config files and have kubectl use them all at
once by specifying all of them in the KUBECONFIG environment variable (sepa-
rate them with a colon).
A.2.2
Understanding the contents of the kubeconfig file
An example config file is shown in the following listing.
apiVersion: v1
clusters:
- cluster:                                                 
    certificate-authority: /home/luksa/.minikube/ca.crt    
    server: https://192.168.99.100:8443                    
  name: minikube                                           
contexts:
- context:                          
    cluster: minikube               
    user: minikube                  
    namespace: default              
  name: minikube                    
current-context: minikube             
kind: Config
preferences: {}
users:
- name: minikube                                             
  user:                                                      
    client-certificate: /home/luksa/.minikube/apiserver.crt  
    client-key: /home/luksa/.minikube/apiserver.key          
The kubeconfig file consists of four sections:
■
A list of clusters
■
A list of users
■
A list of contexts
■
The name of the current context
Listing A.1
Example kubeconfig file
Contains 
information about a 
Kubernetes cluster
Defines a 
kubectl 
context
The current context 
kubectl uses
Contains 
a user’s 
credentials
 
",[],"[{'entity': 'kubectl', 'description': 'command-line tool for interacting with Kubernetes clusters', 'category': 'software'}, {'entity': 'multiple clusters', 'description': 'ability to manage multiple Kubernetes clusters simultaneously', 'category': 'application'}, {'entity': 'namespaces', 'description': 'logical isolation of resources within a cluster', 'category': 'application'}, {'entity': 'kubeconfig file', 'description': 'configuration file for kubectl that stores cluster information', 'category': 'software'}, {'entity': 'KUBECONFIG environment variable', 'description': 'environment variable used to specify the location of kubeconfig files', 'category': 'process'}, {'entity': 'clusters', 'description': 'list of Kubernetes clusters defined in the kubeconfig file', 'category': 'database'}, {'entity': 'users', 'description': 'list of user credentials stored in the kubeconfig file', 'category': 'database'}, {'entity': 'contexts', 'description': 'list of kubectl contexts that define a cluster, user, and namespace', 'category': 'database'}, {'entity': 'current-context', 'description': 'name of the current kubectl context being used', 'category': 'process'}, {'entity': 'apiVersion', 'description': 'field in the kubeconfig file that specifies the API version', 'category': 'software'}, {'entity': 'v1', 'description': 'API version specified in the kubeconfig file', 'category': 'software'}, {'entity': 'certificate-authority', 'description': 'field in the cluster definition that specifies the certificate authority', 'category': 'database'}, {'entity': '/home/luksa/.minikube/ca.crt', 'description': 'path to the certificate authority file', 'category': 'hardware'}, {'entity': 'server', 'description': 'field in the cluster definition that specifies the server address', 'category': 'network'}, {'entity': 'https://192.168.99.100:8443', 'description': 'address of the Kubernetes server', 'category': 'network'}, {'entity': 'name', 'description': 'field in the context definition that specifies the name of the context', 'category': 'database'}, {'entity': 'minikube', 'description': 'name of the kubectl context being used', 'category': 'application'}, {'entity': 'cluster', 'description': 'field in the context definition that specifies the cluster being used', 'category': 'database'}, {'entity': 'user', 'description': 'field in the context definition that specifies the user being used', 'category': 'database'}, {'entity': 'namespace', 'description': 'field in the context definition that specifies the namespace being used', 'category': 'application'}]","[{'source_entity': 'kubectl', 'description': 'uses to connect to a cluster', 'destination_entity': 'cluster'}, {'source_entity': 'KUBECONFIG environment variable', 'description': 'stores the path to the kubeconfig file', 'destination_entity': 'kubeconfig file'}, {'source_entity': 'kubectl', 'description': 'displays information about multiple clusters', 'destination_entity': 'multiple clusters'}, {'source_entity': 'current-context', 'description': 'sets the current context for kubectl', 'destination_entity': 'kubectl'}, {'source_entity': 'namespace', 'description': 'manages resources within a namespace', 'destination_entity': 'resources'}, {'source_entity': 'certificate-authority', 'description': 'verifies the identity of the server', 'destination_entity': 'server'}, {'source_entity': 'minikube', 'description': 'runs a single-node cluster', 'destination_entity': 'cluster'}, {'source_entity': 'kubeconfig file', 'description': 'stores configuration for kubectl', 'destination_entity': 'kubectl'}, {'source_entity': 'v1', 'description': 'defines the API version for Kubernetes', 'destination_entity': 'Kubernetes'}, {'source_entity': 'https://192.168.99.100:8443', 'description': 'specifies the URL of the server', 'destination_entity': 'server'}, {'source_entity': 'clusters', 'description': 'lists all available clusters', 'destination_entity': 'kubectl'}, {'source_entity': 'users', 'description': 'manages user authentication for Kubernetes', 'destination_entity': 'Kubernetes'}, {'source_entity': '/home/luksa/.minikube/ca.crt', 'description': 'specifies the path to the certificate authority file', 'destination_entity': 'certificate-authority'}]","['[\n  {\n    ""source"": ""kubectl"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""uses to connect to a cluster"",\n    ""summary_er"": ""kubectl connects to a Kubernetes cluster, allowing users to interact with pods within that cluster.""\n  }\n]', '[\n  {\n    ""source"": ""KUBECONFIG environment variable"",\n    ""destination"": ""kubeconfig file"",\n    ""relation_description"": ""stores the path to the kubeconfig file"",\n    ""summary_er"": ""The KUBECONFIG environment variable stores the path to the kubeconfig file, which is used by Kubernetes to authenticate and authorize access to clusters.""\n  },\n  {\n    ""source"": ""kubeconfig file"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""stores configuration for a pod"",\n    ""summary_er"": ""The kubeconfig file stores configuration settings for a pod, including authentication and authorization details, which are used by the Kubernetes cluster to manage the pod.""\n  }\n]', '[\n  {\n    ""source"": ""kubectl"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""displays information about"",\n    ""summary_er"": ""Displays info about a single pod, its containers, and their logs.""\n  },\n  {\n    ""source"": ""kubectl"",\n    ""destination"": ""multiple clusters"",\n    ""relation_description"": ""displays information about"",\n    ""summary_er"": ""Displays info about multiple Kubernetes clusters, including nodes, pods, and services.""\n  }\n]', '[\n  {\n    ""source"": ""current-context"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""sets the current context for kubectl"",\n    ""summary_er"": ""The current context sets the default namespace and authentication settings for kubectl commands, allowing users to interact with a specific Kubernetes cluster.""\n  }\n]', '[\n  {\n    ""source"": ""namespace"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""manages resources within a namespace"",\n    ""summary_er"": ""A namespace manages resources for a pod, ensuring efficient allocation and utilization of system resources.""\n  }\n]', '[\n  {\n    ""source"": ""certificate-authority"",\n    ""destination"": ""server"",\n    ""relation_description"": ""verifies the identity of the server"",\n    ""summary_er"": ""The certificate authority verifies the identity of the server, ensuring secure communication between the client and server.""\n  }\n]', '[\n  {\n    ""source"": ""minikube"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""runs a single-node cluster"",\n    ""summary_er"": ""Minikube runs a single-node Kubernetes cluster, allowing for local development and testing of containerized applications.""\n  }\n]', '[\n  {\n    ""source"": ""kubeconfig file"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""stores configuration for"",\n    ""summary_er"": ""The kubeconfig file stores configuration for a pod, allowing kubectl to interact with it.""\n  }\n]', '[\n  {\n    ""source"": ""v1"",\n    ""destination"": ""Kubernetes"",\n    ""relation_description"": ""defines the API version for Kubernetes"",\n    ""summary_er"": ""The v1 entity defines the API version for Kubernetes, which is a key component of the system.""\n  }\n]', '[\n    {\n        ""source"": ""https://192.168.99.100:8443"",\n        ""destination"": ""server"",\n        ""relation_description"": ""specifies the URL of the server"",\n        ""summary_er"": ""The provided URL (https://192.168.99.100:8443) points to a server, which is identified by its unique address.""\n    }\n]', '[\n  {\n    ""source"": ""clusters"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""lists all available clusters"",\n    ""summary_er"": ""Kubernetes lists all available clusters using kubectl command.""\n  }\n]', '[\n  {\n    ""source"": ""users"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""manages user authentication for Kubernetes"",\n    ""summary_er"": ""Users manage authentication for pods in a Kubernetes cluster, ensuring secure access to resources.""\n  },\n  {\n    ""source"": ""users"",\n    ""destination"": ""Kubernetes"",\n    ""relation_description"": ""manages user authentication for Kubernetes"",\n    ""summary_er"": ""Users are authenticated and managed by Kubernetes, enabling secure access to the platform\'s resources.""\n  }\n]', '[\n  {\n    ""source"": ""/home/luksa/.minikube/ca.crt"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""specifies the path to the certificate authority file"",\n    ""summary_er"": ""/home/luksa/.minikube/ca.crt is a certificate authority file used by the pod for secure communication.""\n  }\n]']","To switch between different Kubernetes clusters or namespaces without specifying the --namespace option every time, configure the kubeconfig file's location using the KUBECONFIG environment variable. This file contains four sections: clusters (list of available clusters), users (list of user credentials), contexts (defined by a cluster and a user), and current-context (the currently used context). By listing multiple config files in KUBECONFIG, kubectl can use them all at once.","[{'highlight': 'You can use multiple config files and have kubectl use them all at once by specifying all of them in the KUBECONFIG environment variable (separate them with a colon).'}, {'highlight': 'The kubeconfig file consists of four sections: A list of clusters, A list of users, A list of contexts, and The name of the current context.'}, {'highlight': ""An example config file is shown in the following listing, which includes information about a Kubernetes cluster, defines a kubectl context, contains a user's credentials, and specifies the current context used by kubectl.""}, {'highlight': ""The KUBECONFIG environment variable needs to point to the location of the kubeconfig file if it's stored somewhere else than the default ~/.kube/config file.""}, {'highlight': 'You can switch between different Kubernetes clusters or work in a different namespace without specifying the --namespace option every time you run kubectl by configuring the kubeconfig file and using the KUBECONFIG environment variable.'}]"
