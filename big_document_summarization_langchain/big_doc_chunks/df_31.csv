,page,img_cnt,img_npy_lst,text,tables,entities,relationships,summary_rel,summary,highlights
310,399,0,[],"367
Securing the cluster with role-based access control
and from your local machine, without specifying any authentication tokens (making
you an unauthenticated user):
$ curl https://$(minikube ip):8443/api -k
{
  ""kind"": ""APIVersions"",
  ""versions"": [
  ...
You’ve now used ClusterRoles and ClusterRoleBindings to grant access to cluster-level
resources and non-resource URLs. Now let’s look at how ClusterRoles can be used
with namespaced RoleBindings to grant access to namespaced resources in the Role-
Binding’s namespace.
USING CLUSTERROLES TO GRANT ACCESS TO RESOURCES IN SPECIFIC NAMESPACES
ClusterRoles don’t always need to be bound with cluster-level ClusterRoleBindings.
They can also be bound with regular, namespaced RoleBindings. You’ve already
started looking at predefined ClusterRoles, so let’s look at another one called view,
which is shown in the following listing.
$ kubectl get clusterrole view -o yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: view
  ...
rules:
- apiGroups:
  - """"
  resources:                           
  - configmaps                         
  - endpoints                          
  - persistentvolumeclaims             
  - pods                               
  - replicationcontrollers             
  - replicationcontrollers/scale       
  - serviceaccounts                    
  - services                           
  verbs:                
  - get                 
  - list                
  - watch               
...
This ClusterRole has many rules. Only the first one is shown in the listing. The rule
allows getting, listing, and watching resources like ConfigMaps, Endpoints, Persistent-
VolumeClaims, and so on. These are namespaced resources, even though you’re
looking at a ClusterRole (not a regular, namespaced Role). What exactly does this
ClusterRole do?
Listing 12.16
The default view ClusterRole
This rule applies to 
these resources (note: 
they’re all namespaced 
resources).
As the ClusterRole’s name 
suggests, it only allows 
reading, not writing the 
resources listed. 
 
",[],"[{'entity': 'ClusterRoles', 'description': 'a Kubernetes concept for granting access to cluster-level resources and non-resource URLs', 'category': 'software'}, {'entity': 'ClusterRoleBindings', 'description': 'a way to bind ClusterRoles with cluster-level permissions', 'category': 'software'}, {'entity': 'RoleBindings', 'description': 'a way to grant access to namespaced resources in a specific namespace', 'category': 'software'}, {'entity': 'minikube', 'description': 'a tool for running Kubernetes locally on a machine', 'category': 'software'}, {'entity': 'curl', 'description': 'a command-line tool for transferring data over HTTP', 'category': 'software'}, {'entity': 'APIVersions', 'description': 'a Kubernetes concept for managing API versions', 'category': 'software'}, {'entity': 'ClusterRole', 'description': 'a Kubernetes concept for granting access to cluster-level resources and non-resource URLs', 'category': 'software'}, {'entity': 'view', 'description': 'a predefined ClusterRole that allows reading namespaced resources', 'category': 'software'}, {'entity': 'configmaps', 'description': 'a type of Kubernetes resource for storing configuration data', 'category': 'software'}, {'entity': 'endpoints', 'description': 'a type of Kubernetes resource for exposing services to the outside world', 'category': 'software'}, {'entity': 'persistentvolumeclaims', 'description': 'a type of Kubernetes resource for managing persistent storage', 'category': 'software'}, {'entity': 'pods', 'description': 'a type of Kubernetes resource for running containers', 'category': 'software'}, {'entity': 'replicationcontrollers', 'description': 'a type of Kubernetes resource for managing replication and scaling', 'category': 'software'}, {'entity': 'serviceaccounts', 'description': 'a type of Kubernetes resource for managing service accounts', 'category': 'software'}, {'entity': 'services', 'description': 'a type of Kubernetes resource for exposing services to the outside world', 'category': 'software'}]","[{'source_entity': '""pods""', 'description': 'are managed by', 'destination_entity': '""minikube""'}, {'source_entity': '""persistentvolumeclaims""', 'description': 'can be created and managed within', 'destination_entity': '""minikube""'}, {'source_entity': '""view""', 'description': 'provides a visual representation of', 'destination_entity': '""pods"", ""services"", ""endpoints"", ""replicationcontrollers""'}, {'source_entity': '""ClusterRole""', 'description': 'defines permissions for', 'destination_entity': '""serviceaccounts"", ""configmaps""'}, {'source_entity': '""APIVersions""', 'description': 'specifies the supported API versions for', 'destination_entity': '""minikube"", ""pods"", ""services"", ""endpoints""'}, {'source_entity': '""endpoints""', 'description': 'can be created and managed within', 'destination_entity': '""minikube""'}, {'source_entity': '""services""', 'description': 'are exposed to the outside world through', 'destination_entity': '""minikube"", ""pods"", ""endpoints""'}, {'source_entity': '""curl""', 'description': 'is used to interact with and retrieve data from', 'destination_entity': '""services"", ""endpoints"", ""replicationcontrollers""'}, {'source_entity': '""replicationcontrollers""', 'description': 'are used to manage the scaling of', 'destination_entity': '""pods"", ""minikube""'}, {'source_entity': '""ClusterRoles""', 'description': 'define permissions for', 'destination_entity': '""serviceaccounts"", ""configmaps""'}, {'source_entity': '""ClusterRoleBindings""', 'description': 'assign ClusterRoles to service accounts and users', 'destination_entity': '""serviceaccounts"", ""users""'}, {'source_entity': '""RoleBindings""', 'description': 'assign roles to service accounts and users', 'destination_entity': '""serviceaccounts"", ""users""'}, {'source_entity': '""serviceaccounts""', 'description': 'are used to authenticate and authorize access to', 'destination_entity': '""pods"", ""services"", ""endpoints""'}, {'source_entity': '""configmaps""', 'description': 'store configuration data for', 'destination_entity': '""pods"", ""services"", ""endpoints""'}]","['[\n  {\n    ""source"": ""Kubernetes"",\n    ""destination"": ""Pods"",\n    ""relation_description"": ""are managed by"",\n    ""summary_er"": ""In Kubernetes, pods are containerized applications that are managed and orchestrated by the platform.""\n  },\n  {\n    ""source"": ""Docker"",\n    ""destination"": ""Containers"",\n    ""relation_description"": ""are used to create"",\n    ""summary_er"": ""Docker containers are lightweight and portable packages of software that can be run on any system with Docker installed.""\n  },\n  {\n    ""source"": ""Machine Learning"",\n    ""destination"": ""Generative AI"",\n    ""relation_description"": ""is a type of"",\n    ""summary_er"": ""Generative AI is a subfield of machine learning that focuses on generating new data, such as images or text, that resembles existing data.""\n  },\n  {\n    ""source"": ""Natural Language Understanding"",\n    ""destination"": ""Computer Vision"",\n    ""relation_description"": ""are both applications of"",\n    ""summary_er"": ""Both natural language understanding and computer vision are areas of artificial intelligence that involve processing and analyzing human input or visual data.""\n  }\n]', '[\n  {\n    ""source"": ""persistentvolumeclaims"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""can be created and managed within"",\n    ""summary_er"": ""Persistent volume claims can be dynamically provisioned and managed within a pod in Minikube, enabling efficient storage management.""\n  }\n]', '[\n  {\n    ""source"": ""view"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""provides a visual representation of"",\n    ""summary_er"": ""A view provides a graphical interface to visualize pod details, offering insights into its state and behavior.""\n  },\n  {\n    ""source"": ""pods"",\n    ""destination"": ""services"",\n    ""relation_description"": ""exposes"",\n    ""summary_er"": ""Pods expose services, making them accessible from outside the cluster, enabling communication between pods and external systems.""\n  },\n  {\n    ""source"": ""pods"",\n    ""destination"": ""endpoints"",\n    ""relation_description"": ""maps to"",\n    ""summary_er"": ""Pods are mapped to endpoints, which serve as a stable identifier for accessing pod resources, ensuring consistent communication with the pod.""\n  },\n  {\n    ""source"": ""pods"",\n    ""destination"": ""replicationcontrollers"",\n    ""relation_description"": ""managed by"",\n    ""summary_er"": ""Pods are managed by replication controllers, which ensure that the desired number of replicas is maintained, providing scalability and reliability.""\n  }\n]', '[\n  {\n    ""source"": ""ClusterRole"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""defines permissions for"",\n    ""summary_er"": ""A ClusterRole defines a set of permissions that can be used by pods to access resources in a Kubernetes cluster.""\n  },\n  {\n    ""source"": ""serviceaccounts"",\n    ""destination"": ""configmaps"",\n    ""relation_description"": """",\n    ""summary_er"": ""ServiceAccounts are used to authenticate and authorize interactions with ConfigMaps, allowing pods to access sensitive information.""\n  }\n]', '[\n  {\n    ""source"": ""APIVersions"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""specifies the supported API versions for"",\n    ""summary_er"": ""The APIVersions relation specifies the supported API versions for a pod, enabling it to communicate with the Kubernetes cluster.""\n  },\n  {\n    ""source"": ""minikube"",\n    ""destination"": ""pods"",\n    ""relation_description"": ""manages"",\n    ""summary_er"": ""Minikube manages pods, providing a local environment for running and testing containerized applications.""\n  },\n  {\n    ""source"": ""minikube"",\n    ""destination"": ""services"",\n    ""relation_description"": ""exposes"",\n    ""summary_er"": ""Minikube exposes services to the outside world, making them accessible from within the cluster or externally via a load balancer.""\n  },\n  {\n    ""source"": ""minikube"",\n    ""destination"": ""endpoints"",\n    ""relation_description"": ""provides"",\n    ""summary_er"": ""Minikube provides endpoints for accessing and interacting with services running within the cluster, enabling communication between pods and external clients.""\n  }\n]', '[\n  {\n    ""source"": ""endpoints"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""can be created and managed within"",\n    ""summary_er"": ""Endpoints can be created and managed within a pod, allowing for dynamic configuration of network settings.""\n  }\n]', '[\n  {\n    ""source"": ""services"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""are exposed to the outside world through"",\n    ""summary_er"": ""Services expose pods to the outside world by providing a network interface for incoming requests.""\n  },\n  {\n    ""source"": ""minikube"",\n    ""destination"": ""pods"",\n    ""relation_description"": ""container runtime"",\n    ""summary_er"": ""Minikube is a container runtime that manages and runs pods on a local machine.""\n  },\n  {\n    ""source"": ""minikube"",\n    ""destination"": ""endpoints"",\n    ""relation_description"": ""exposes services to the outside world"",\n    ""summary_er"": ""Minikube exposes endpoints, which represent services, to the outside world for external access.""\n  }\n]', '[\n  {\n    ""source"": ""curl"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""is used to interact with and retrieve data from"",\n    ""summary_er"": ""Curl is a command-line tool that interacts with pods to retrieve data.""\n  },\n  {\n    ""source"": ""services"",\n    ""destination"": ""endpoints"",\n    ""relation_description"": ""are related to"",\n    ""summary_er"": ""Services are related to endpoints, which provide network access to applications.""\n  },\n  {\n    ""source"": ""services"",\n    ""destination"": ""replicationcontrollers"",\n    ""relation_description"": ""are managed by"",\n    ""summary_er"": ""Services are managed by replication controllers, which ensure application scalability and reliability.""\n  }\n]', '[\n  {\n    ""source"": ""replicationcontrollers"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""are used to manage the scaling of"",\n    ""summary_er"": ""Replication controllers scale pod instances based on resource needs.""\n  },\n  {\n    ""source"": ""pods"",\n    ""destination"": ""minikube"",\n    ""relation_description"": """",\n    ""summary_er"": ""Pods run within minikube, a lightweight Kubernetes cluster.""\n  }\n]', '[\n  {\n    ""source"": ""ClusterRoles"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""define permissions for"",\n    ""summary_er"": ""ClusterRoles define permissions for pods, controlling access to resources such as serviceaccounts and configmaps.""\n  },\n  {\n    ""source"": ""serviceaccounts"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""access control"",\n    ""summary_er"": ""Serviceaccounts provide access control for pods, allowing them to authenticate with other services.""\n  },\n  {\n    ""source"": ""configmaps"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""configuration data"",\n    ""summary_er"": ""Configmaps store configuration data that can be accessed by pods, enabling dynamic configuration and customization.""\n  }\n]', '[\n  {\n    ""source"": ""ClusterRoleBindings"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""assign ClusterRoles to service accounts and users"",\n    ""summary_er"": ""ClusterRoleBindings assign roles to pods, allowing them to access cluster resources.""\n  },\n  {\n    ""source"": ""serviceaccounts"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""assign ClusterRoles to service accounts and users"",\n    ""summary_er"": ""Service accounts provide credentials for pods to access cluster resources.""\n  },\n  {\n    ""source"": ""users"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""assign ClusterRoles to service accounts and users"",\n    ""summary_er"": ""Users can authenticate with the cluster, allowing their pods to access resources.""\n  }\n]', '[\n  {\n    ""source"": ""RoleBindings"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""assign roles to service accounts and users"",\n    ""summary_er"": ""RoleBindings assign roles to service accounts and users, which are then applied to pods for authentication and authorization purposes.""\n  },\n  {\n    ""source"": ""serviceaccounts"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""authenticate and authorize access"",\n    ""summary_er"": ""Service accounts authenticate and authorize access to pods by providing credentials and permissions for service-to-service communication.""\n  },\n  {\n    ""source"": ""users"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""authenticate and authorize access"",\n    ""summary_er"": ""Users authenticate and authorize access to pods by providing credentials and permissions for human-to-pod interaction.""\n  }\n]', '[\n  {\n    ""source"": ""serviceaccounts"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""authentication and authorization"",\n    ""summary_er"": ""Service accounts are used to authenticate and authorize access to pods, enabling secure communication between them.""\n  },\n  {\n    ""source"": ""pods"",\n    ""destination"": ""services"",\n    ""relation_description"": ""communication and discovery"",\n    ""summary_er"": ""Pods communicate with services to discover and interact with them, facilitating data exchange and coordination.""\n  },\n  {\n    ""source"": ""pods"",\n    ""destination"": ""endpoints"",\n    ""relation_description"": ""load balancing and routing"",\n    ""summary_er"": ""Pods use endpoints for load balancing and routing, ensuring efficient distribution of traffic to available instances.""\n  }\n]', '[\n  {\n    ""source"": ""configmaps"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""store configuration data for"",\n    ""summary_er"": ""ConfigMaps store configuration data for Pods, providing a way to decouple application configuration from Pod creation.""\n  },\n  {\n    ""source"": ""pods"",\n    ""destination"": ""services"",\n    ""relation_description"": ""expose"",\n    ""summary_er"": ""Pods expose Services, making them accessible to external traffic and enabling communication between Pods and Services.""\n  },\n  {\n    ""source"": ""pods"",\n    ""destination"": ""endpoints"",\n    ""relation_description"": ""resolve"",\n    ""summary_er"": ""Pods resolve Endpoints, which provide a stable network identity and enable load balancing for Services.""\n  }\n]']","ClusterRoles can be used with namespaced RoleBindings to grant access to specific namespaces and their resources. The 'view' ClusterRole allows reading (get, list, watch) but not writing resources in a namespace, demonstrating how ClusterRoles can control access to resources within a specific scope.","[{'highlight': 'You can use ClusterRoles with namespaced RoleBindings to grant access to namespaced resources in a specific namespace.'}, {'highlight': 'The view ClusterRole allows getting, listing, and watching namespaced resources like ConfigMaps, Endpoints, Persistent-VolumeClaims, and so on.'}, {'highlight': 'This ClusterRole has many rules that allow reading but not writing the listed resources.'}, {'highlight': 'You can use curl to access the cluster API without authentication tokens, making you an unauthenticated user.'}, {'highlight': 'ClusterRoles can be bound with regular, namespaced RoleBindings in addition to cluster-level ClusterRoleBindings.'}]"
311,400,0,[],"368
CHAPTER 12
Securing the Kubernetes API server
 It depends whether it’s bound with a ClusterRoleBinding or a RoleBinding (it can
be bound with either). If you create a ClusterRoleBinding and reference the Cluster-
Role in it, the subjects listed in the binding can view the specified resources across all
namespaces. If, on the other hand, you create a RoleBinding, the subjects listed in the
binding can only view resources in the namespace of the RoleBinding. You’ll try both
options now.
 You’ll see how the two options affect your test pod’s ability to list pods. First, let’s
see what happens before any bindings are in place:
/ # curl localhost:8001/api/v1/pods
User ""system:serviceaccount:foo:default"" cannot list pods at the cluster 
scope./ #
/ # curl localhost:8001/api/v1/namespaces/foo/pods
User ""system:serviceaccount:foo:default"" cannot list pods in the namespace 
""foo"".
With the first command, you’re trying to list pods across all namespaces. With the sec-
ond, you’re trying to list pods in the foo namespace. The server doesn’t allow you to
do either.
 Now, let’s see what happens when you create a ClusterRoleBinding and bind it to
the pod’s ServiceAccount:
$ kubectl create clusterrolebinding view-test --clusterrole=view 
➥ --serviceaccount=foo:default
clusterrolebinding ""view-test"" created
Can the pod now list pods in the foo namespace?
/ # curl localhost:8001/api/v1/namespaces/foo/pods
{
  ""kind"": ""PodList"",
  ""apiVersion"": ""v1"",
  ...
It can! Because you created a ClusterRoleBinding, it applies across all namespaces.
The pod in namespace foo can list pods in the bar namespace as well:
/ # curl localhost:8001/api/v1/namespaces/bar/pods
{
  ""kind"": ""PodList"",
  ""apiVersion"": ""v1"",
  ...
Okay, the pod is allowed to list pods in a different namespace. It can also retrieve pods
across all namespaces by hitting the /api/v1/pods URL path:
/ # curl localhost:8001/api/v1/pods
{
  ""kind"": ""PodList"",
  ""apiVersion"": ""v1"",
  ...
 
",[],"[{'entity': 'ClusterRoleBinding', 'description': 'A binding that grants access to resources across all namespaces.', 'category': 'Kubernetes'}, {'entity': 'RoleBinding', 'description': 'A binding that grants access to resources within a specific namespace.', 'category': 'Kubernetes'}, {'entity': 'ClusterRole', 'description': 'A role that grants access to resources across all namespaces.', 'category': 'Kubernetes'}, {'entity': 'Role', 'description': 'A role that grants access to resources within a specific namespace.', 'category': 'Kubernetes'}, {'entity': 'ServiceAccount', 'description': 'An account used by pods to authenticate with the API server.', 'category': 'Kubernetes'}, {'entity': 'PodList', 'description': 'A list of pods in a specific namespace or across all namespaces.', 'category': 'Kubernetes'}, {'entity': 'curl', 'description': 'A command-line tool used to make HTTP requests to the API server.', 'category': 'Command'}, {'entity': '/api/v1/pods', 'description': 'An API endpoint that lists pods across all namespaces.', 'category': 'API Endpoint'}, {'entity': '/api/v1/namespaces/foo/pods', 'description': 'An API endpoint that lists pods in a specific namespace (foo).', 'category': 'API Endpoint'}, {'entity': 'localhost:8001', 'description': 'The address of the API server.', 'category': 'Address'}]","[{'source_entity': '""/api/v1/namespaces/foo/pods""', 'description': 'lists pods in namespace foo', 'destination_entity': '""PodList""'}, {'source_entity': '""/api/v1/namespaces/foo/pods""', 'description': 'provides information about pods in namespace foo', 'destination_entity': '""ClusterRole""'}, {'source_entity': '""/api/v1/namespaces/foo/pods""', 'description': 'manages access to pods in namespace foo', 'destination_entity': '""RoleBinding""'}, {'source_entity': '""/api/v1/namespaces/foo/pods""', 'description': 'binds a role to a service account for pods in namespace foo', 'destination_entity': '""ServiceAccount""'}, {'source_entity': '""/api/v1/pods""', 'description': 'lists all pods in the cluster', 'destination_entity': '""PodList""'}, {'source_entity': '""ClusterRole""', 'description': 'defines a cluster-wide role', 'destination_entity': '""RoleBinding""'}, {'source_entity': '""ClusterRoleBinding""', 'description': 'binds a cluster role to a service account', 'destination_entity': '""ServiceAccount""'}, {'source_entity': '""Role""', 'description': 'defines a role within a namespace', 'destination_entity': '""RoleBinding""'}]","['[\n  {\n    ""source"": ""/api/v1/namespaces/foo/pods"",\n    ""destination"": ""PodList"",\n    ""relation_description"": ""lists pods in namespace foo"",\n    ""summary_er"": ""This API endpoint lists all pods within a specific namespace (foo), providing details about each pod\'s status and configuration.""\n  }\n]', '[\n  {\n    ""source"": ""/api/v1/namespaces/foo/pods"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""provides information about pods in namespace foo"",\n    ""summary_er"": ""This API endpoint provides details about pods within a specific namespace, allowing for management and monitoring of these containerized applications.""\n  },\n  {\n    ""source"": ""/api/v1/namespaces/foo/pods"",\n    ""destination"": ""ClusterRole"",\n    ""relation_description"": ""provides information about pods in namespace foo"",\n    ""summary_er"": ""The ClusterRole is associated with the API endpoint providing pod information, indicating its role and permissions within the cluster.""\n  }\n]', '[\n  {\n    ""source"": ""/api/v1/namespaces/foo/pods"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""manages access to pods in namespace foo"",\n    ""summary_er"": ""The API endpoint manages access to pods within a specific namespace, ensuring secure interactions between users and pods.""\n  },\n  {\n    ""source"": ""/api/v1/namespaces/foo/pods"",\n    ""destination"": ""RoleBinding"",\n    ""relation_description"": ""manages access to pods in namespace foo"",\n    ""summary_er"": ""A RoleBinding is used to manage access to pods within a specific namespace, enforcing permissions and security protocols.""\n  }\n]', '[\n  {\n    ""source"": ""Namespace"",\n    ""destination"": ""Pod"",\n    ""relation_description"": ""binds a role to a service account for pods in namespace"",\n    ""summary_er"": ""A namespace binds a role to a service account for its pods.""\n  }\n]', '[\n  {\n    ""source"": ""/api/v1/pods"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""lists all pods in the cluster"",\n    ""summary_er"": ""The /api/v1/pods endpoint retrieves a list of all pods currently running in the Kubernetes cluster, providing detailed information about each pod.""\n  },\n  {\n    ""source"": ""/api/v1/pods"",\n    ""destination"": ""PodList"",\n    ""relation_description"": ""lists all pods in the cluster"",\n    ""summary_er"": ""The PodList object represents a collection of all pods within the Kubernetes cluster, offering insights into their status and configuration.""\n  }\n]', '[\n  {\n    ""source"": ""ClusterRole"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""defines a cluster-wide role"",\n    ""summary_er"": ""A ClusterRole defines a set of permissions that can be bound to a RoleBinding, which in turn grants access to pods within the cluster.""\n  },\n  {\n    ""source"": ""RoleBinding"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""grants access"",\n    ""summary_er"": ""A RoleBinding binds a ClusterRole to a set of users or service accounts, granting them access to pods and other resources within the cluster.""\n  }\n]', '[\n  {\n    ""source"": ""ClusterRoleBinding"",\n    ""destination"": ""ServiceAccount"",\n    ""relation_description"": ""binds a cluster role to a service account"",\n    ""summary_er"": ""A ClusterRoleBinding binds a cluster role to a ServiceAccount, granting permissions to pods created from that account.""\n  },\n  {\n    ""source"": ""ClusterRoleBinding"",\n    ""destination"": ""Pod"",\n    ""relation_description"": ""grants permissions to pods created from the service account"",\n    ""summary_er"": ""A ClusterRoleBinding grants permissions to Pods created from a ServiceAccount, allowing them to access cluster resources.""\n  }\n]', '[\n  {\n    ""source"": ""Namespace"",\n    ""destination"": ""Pod"",\n    ""relation_description"": ""defines a role within a namespace"",\n    ""summary_er"": ""A Role defines a set of permissions within a Namespace, which are then applied to a Pod.""\n  },\n  {\n    ""source"": ""Role"",\n    ""destination"": ""Pod"",\n    ""relation_description"": ""applies the role to the pod"",\n    ""summary_er"": ""A RoleBinding applies the defined Role to a specific Pod, granting it access to resources within the Namespace.""\n  }\n]']","The Kubernetes API server's permissions are determined by a ClusterRoleBinding or RoleBinding. A ClusterRoleBinding allows subjects to view resources across all namespaces, while a RoleBinding only allows viewing resources in the namespace of the binding. The example demonstrates listing pods using curl commands before and after creating a ClusterRoleBinding, showing that it applies across all namespaces.","[{'highlight': 'A ClusterRoleBinding allows subjects to view resources across all namespaces, while a RoleBinding only allows viewing resources in the namespace of the binding.'}, {'highlight': ""Creating a ClusterRoleBinding with the 'view' cluster role and referencing it in the binding allows a pod's ServiceAccount to list pods across all namespaces.""}, {'highlight': 'A pod can list pods in a different namespace if a ClusterRoleBinding is created, even if the pod is not in that namespace.'}, {'highlight': 'The Kubernetes API server does not allow listing pods across all namespaces or in a specific namespace without a binding in place.'}, {'highlight': 'A RoleBinding only allows viewing resources in the namespace of the binding, whereas a ClusterRoleBinding applies across all namespaces.'}]"
312,401,0,[],"369
Securing the cluster with role-based access control
As expected, the pod can get a list of all the pods in the cluster. To summarize, com-
bining a ClusterRoleBinding with a ClusterRole referring to namespaced resources
allows the pod to access namespaced resources in any namespace, as shown in fig-
ure 12.9.
Now, let’s see what happens if you replace the ClusterRoleBinding with a RoleBinding.
First, delete the ClusterRoleBinding:
$ kubectl delete clusterrolebinding view-test
clusterrolebinding ""view-test"" deleted
Next create a RoleBinding instead. Because a RoleBinding is namespaced, you need
to specify the namespace you want to create it in. Create it in the foo namespace:
$ kubectl create rolebinding view-test --clusterrole=view 
➥ --serviceaccount=foo:default -n foo
rolebinding ""view-test"" created
You now have a RoleBinding in the foo namespace, binding the default Service-
Account in that same namespace with the view ClusterRole. What can your pod
access now?
/ # curl localhost:8001/api/v1/namespaces/foo/pods
{
  ""kind"": ""PodList"",
  ""apiVersion"": ""v1"",
  ...
Namespace: foo
Cluster-level
resources
Namespace: bar
Pods
Pods
Default
ServiceAccount
in foo namespace
is allowed to
view pods in
any namespace
ClusterRole:
view
Allows getting,
listing, watching
ClusterRoleBinding:
view-test
Pods,
Services,
Endpoints,
ConﬁgMaps,
…
Service-
Account:
default
Figure 12.9
A ClusterRoleBinding and ClusterRole grants permission to resources across all 
namespaces.
 
",[],"[{'entity': 'ClusterRoleBinding', 'description': 'a binding that grants permissions to a cluster role across all namespaces', 'category': 'software'}, {'entity': 'ClusterRole', 'description': 'a role that defines permissions for accessing resources in the cluster', 'category': 'software'}, {'entity': 'RoleBinding', 'description': 'a binding that grants permissions to a role within a specific namespace', 'category': 'software'}, {'entity': 'ServiceAccount', 'description': 'an object that represents an identity for a pod or container', 'category': 'software'}, {'entity': 'PodList', 'description': 'a list of pods in the cluster', 'category': 'software'}, {'entity': 'Namespace', 'description': 'a logical grouping of resources within a cluster', 'category': 'software'}, {'entity': 'Role', 'description': 'a set of permissions that can be granted to a user or service account', 'category': 'software'}, {'entity': 'ClusterRoleBinding', 'description': 'view-test', 'category': 'software'}, {'entity': 'RoleBinding', 'description': 'view-test', 'category': 'software'}, {'entity': 'ServiceAccount', 'description': 'default', 'category': 'software'}, {'entity': 'kubectl', 'description': 'a command-line tool for interacting with a Kubernetes cluster', 'category': 'software'}, {'entity': 'API', 'description': 'the interface through which the pod interacts with the cluster', 'category': 'software'}, {'entity': 'Pods', 'description': 'a collection of running containers within a cluster', 'category': 'software'}, {'entity': 'Services', 'description': 'a set of resources that provide a network interface for accessing applications', 'category': 'software'}, {'entity': 'Endpoints', 'description': 'a resource that represents the IP addresses and ports of a service', 'category': 'software'}, {'entity': 'ConfigMaps', 'description': 'a resource that stores configuration data for an application', 'category': 'software'}]","[{'source_entity': 'Namespace', 'description': 'is used to organize and isolate resources within a cluster.', 'destination_entity': 'Pods'}, {'source_entity': 'Endpoints', 'description': 'provides information about the IP addresses of pods that are backing a service.', 'destination_entity': 'Services'}, {'source_entity': 'Pods', 'description': 'can be scaled horizontally by creating multiple replicas of the same pod.', 'destination_entity': 'ClusterRoleBinding'}, {'source_entity': 'ClusterRoleBinding', 'description': 'binds a cluster role to a user or service account, granting access to cluster resources.', 'destination_entity': 'ClusterRole'}, {'source_entity': 'API', 'description': 'provides an interface for interacting with the Kubernetes API server.', 'destination_entity': 'kubectl'}, {'source_entity': 'ConfigMaps', 'description': 'can be used to store and manage configuration data for pods and other resources.', 'destination_entity': 'Pods'}, {'source_entity': 'Services', 'description': 'exposes a network service to the outside world, allowing access from within the cluster.', 'destination_entity': 'Endpoints'}, {'source_entity': 'kubectl', 'description': 'is used to interact with the Kubernetes API server and manage cluster resources.', 'destination_entity': 'API'}, {'source_entity': 'RoleBinding', 'description': 'binds a role to a user or service account, granting access to specific cluster resources.', 'destination_entity': 'Role'}, {'source_entity': 'PodList', 'description': 'provides information about the pods running in a cluster.', 'destination_entity': 'Pods'}, {'source_entity': 'ServiceAccount', 'description': 'is used to authenticate and authorize access to cluster resources for services and pods.', 'destination_entity': 'RoleBinding'}]","['[\n  {\n    ""source"": ""Namespace"",\n    ""destination"": ""Pods"",\n    ""relation_description"": ""is used to organize and isolate resources within a cluster."",\n    ""summary_er"": ""Namespaces provide isolation for pods, allowing multiple instances of an application to run on the same cluster without conflicts.""\n  }\n]', '[\n  {\n    ""source"": ""Endpoints"",\n    ""destination"": ""Services"",\n    ""relation_description"": ""provides information about the IP addresses of pods that are backing a service."",\n    ""summary_er"": ""Endpoints provide IP addresses for services, enabling communication between pods and services.""\n  }\n]', '[\n  {\n    ""source"": ""Pods"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""can be scaled horizontally by creating multiple replicas of the same pod."",\n    ""summary_er"": ""Horizontal scaling in Kubernetes involves creating multiple replicas of a Pod to increase capacity.""\n  },\n  {\n    ""source"": ""ClusterRoleBinding"",\n    ""destination"": ""Pods"",\n    ""relation_description"": ""binding cluster roles to pods for access control"",\n    ""summary_er"": ""A ClusterRoleBinding grants permissions from a cluster role to a pod, enabling it to perform specific actions within the cluster.""\n  }\n]', '[\n  {\n    ""source"": ""ClusterRoleBinding"",\n    ""destination"": ""Pod"",\n    ""relation_description"": ""binds a cluster role to a user or service account, granting access to cluster resources."",\n    ""summary_er"": ""A ClusterRoleBinding grants access to cluster resources by binding a ClusterRole to a user or service account.""\n  }\n]', '[\n  {\n    ""source"": ""API"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""provides an interface for interacting with the Kubernetes API server."",\n    ""summary_er"": ""The Kubernetes API provides a standardized interface for interacting with pods, enabling management and automation of containerized applications.""\n  }\n]', '[\n  {\n    ""source"": ""ConfigMaps"",\n    ""destination"": ""Pods"",\n    ""relation_description"": ""can be used to store and manage configuration data for pods and other resources."",\n    ""summary_er"": ""ConfigMaps provide a way to decouple configuration from pod definitions, making it easier to manage and update configurations.""\n  }\n]', '[\n  {\n    ""source"": ""Services"",\n    ""destination"": ""Pods"",\n    ""relation_description"": ""exposes a network service to the outside world, allowing access from within the cluster."",\n    ""summary_er"": ""A Service exposes a network service to the outside world, enabling access from within the cluster.""\n  }\n]', '[\n  {\n    ""source"": ""kubectl"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""is used to interact with the Kubernetes API server and manage cluster resources."",\n    ""summary_er"": ""kubectl interacts with Kubernetes API server to manage pod resources.""\n  }\n]', '[\n  {\n    ""source"": ""RoleBinding"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""binds a role to a user or service account, granting access to specific cluster resources."",\n    ""summary_er"": ""A RoleBinding grants access to cluster resources by binding a role to a user or service account.""\n  }\n]', '[\n  {\n    ""source"": ""PodList"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""provides information about the pods running in a cluster."",\n    ""summary_er"": ""The PodList provides details on active pods within a Kubernetes cluster, including pod metadata and status.""\n  }\n]', '[\n  {\n    ""source"": ""ServiceAccount"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""is used to authenticate and authorize access to cluster resources"",\n    ""summary_er"": ""ServiceAccount authenticates and authorizes pod access to cluster resources.""\n  }\n]']","A pod can access namespaced resources in any namespace by combining a ClusterRoleBinding with a ClusterRole referring to namespaced resources. Replacing the ClusterRoleBinding with a RoleBinding limits the pod's access to only the specified namespace, as demonstrated with the creation of a RoleBinding in the foo namespace.","[{'highlight': 'Combining a ClusterRoleBinding with a ClusterRole referring to namespaced resources allows the pod to access namespaced resources in any namespace.'}, {'highlight': 'Replacing the ClusterRoleBinding with a RoleBinding restricts access to only the specified namespace.'}, {'highlight': 'A RoleBinding is namespaced, requiring specification of the target namespace when created.'}, {'highlight': 'The default ServiceAccount in a namespace has access to view pods in any namespace through a ClusterRole.'}, {'highlight': 'A ClusterRole grants permission to resources such as Pods, Services, Endpoints, ConfigMaps, and more across all namespaces.'}]"
313,402,0,[],"370
CHAPTER 12
Securing the Kubernetes API server
/ # curl localhost:8001/api/v1/namespaces/bar/pods
User ""system:serviceaccount:foo:default"" cannot list pods in the namespace 
""bar"".
/ # curl localhost:8001/api/v1/pods
User ""system:serviceaccount:foo:default"" cannot list pods at the cluster 
scope.
As you can see, your pod can list pods in the foo namespace, but not in any other spe-
cific namespace or across all namespaces. This is visualized in figure 12.10.
SUMMARIZING ROLE, CLUSTERROLE, ROLEBINDING, AND CLUSTERROLEBINDING COMBINATIONS
We’ve covered many different combinations and it may be hard for you to remember
when to use each one. Let’s see if we can make sense of all these combinations by cat-
egorizing them per specific use case. Refer to table 12.2.
Table 12.2
When to use specific combinations of role and binding types
For accessing
Role type to use
Binding type to use
Cluster-level resources (Nodes, PersistentVolumes, ...)
ClusterRole
ClusterRoleBinding
Non-resource URLs (/api, /healthz, ...)
ClusterRole
ClusterRoleBinding
Namespaced resources in any namespace (and 
across all namespaces)
ClusterRole
ClusterRoleBinding
Namespaced resources in a specific namespace (reus-
ing the same ClusterRole in multiple namespaces)
ClusterRole
RoleBinding
Namespaced resources in a specific namespace 
(Role must be defined in each namespace)
Role
RoleBinding
Namespace: foo
Cluster-level resources
Namespace: bar
Pods
Pods
ClusterRole:
view
Allows getting,
listing, watching
RoleBinding:
view-test
Pods,
Services,
Endpoints,
ConﬁgMaps,
…
Default ServiceAccount in
foo namespace is only allowed
to view pods in namespace foo,
despite using a ClusterRole
Service-
Account:
default
Figure 12.10
A RoleBinding referring to a ClusterRole only grants access to resources inside the 
RoleBinding’s namespace.
 
","[  Table 12.2 When to use specific combinations of role  \
0                                      For accessing     
1  Cluster-level resources (Nodes, PersistentVolu...     

                                   and binding types  \
0                                   Role type to use   
1  ClusterRole\nClusterRole\nClusterRole\nCluster...   

                                                Col2  
0                                Binding type to use  
1  ClusterRoleBinding\nClusterRoleBinding\nCluste...  ]","[{'entity': 'Kubernetes API server', 'description': 'The main entry point for interacting with Kubernetes resources.', 'category': 'software'}, {'entity': 'curl', 'description': 'A command-line tool for transferring data to and from a web server.', 'category': 'command'}, {'entity': 'localhost:8001/api/v1/namespaces/bar/pods', 'description': ""A URL endpoint for listing pods in the 'bar' namespace."", 'category': 'url'}, {'entity': 'system:serviceaccount:foo:default', 'description': ""A service account user with permissions to list pods in the 'foo' namespace."", 'category': 'user'}, {'entity': 'Role', 'description': 'An object that defines a set of permissions for accessing Kubernetes resources.', 'category': 'software'}, {'entity': 'ClusterRole', 'description': 'A role that can be used across multiple namespaces to access cluster-level resources.', 'category': 'software'}, {'entity': 'RoleBinding', 'description': 'An object that binds a user or service account to a specific role, granting them permissions to access Kubernetes resources.', 'category': 'software'}, {'entity': 'ClusterRoleBinding', 'description': 'A binding that grants a user or service account access to cluster-level resources using a ClusterRole.', 'category': 'software'}, {'entity': 'Namespace', 'description': 'A logical partitioning of Kubernetes resources, used for isolation and organization.', 'category': 'software'}, {'entity': 'Pods', 'description': 'A lightweight container that can run one or more processes.', 'category': 'container'}]","[{'source_entity': 'Namespace', 'description': 'is associated with', 'destination_entity': 'Pods'}, {'source_entity': 'system:serviceaccount:foo:default', 'description': 'has access to', 'destination_entity': 'ClusterRole'}, {'source_entity': 'ClusterRole', 'description': 'grants permissions to', 'destination_entity': 'RoleBinding'}, {'source_entity': 'curl', 'description': 'uses to interact with', 'destination_entity': 'Kubernetes API server'}, {'source_entity': 'localhost:8001/api/v1/namespaces/bar/pods', 'description': 'is accessed by', 'destination_entity': 'Kubernetes API server'}]","['[\n  {\n    ""source"": ""Namespace"",\n    ""destination"": ""Pods"",\n    ""relation_description"": ""is associated with"",\n    ""summary_er"": ""A namespace is a logical grouping of resources in Kubernetes, and pods are the basic execution units within a namespace.""\n  }\n]', '[\n  {\n    ""source"": ""system:serviceaccount:foo:default"",\n    ""destination"": ""ClusterRole"",\n    ""relation_description"": ""has access to"",\n    ""summary_er"": ""The default service account for namespace foo has access to ClusterRole, granting it permissions and privileges within the cluster.""\n  }\n]', '[\n  {\n    ""source"": ""ClusterRole"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""grants permissions to"",\n    ""summary_er"": ""A ClusterRole grants permissions to a pod, defining access rights for Kubernetes resources.""\n  }\n]', '[\n  {\n    ""source"": ""curl"",\n    ""destination"": ""Kubernetes API server"",\n    ""relation_description"": ""uses to interact with"",\n    ""summary_er"": ""Curl uses HTTP requests to interact with the Kubernetes API server, allowing users to manage and monitor cluster resources.""\n  }\n]', '[\n  {\n    ""source"": ""localhost:8001/api/v1/namespaces/bar/pods"",\n    ""destination"": ""Kubernetes API server"",\n    ""relation_description"": ""is accessed by"",\n    ""summary_er"": ""The Kubernetes API server is accessed through the localhost URL, allowing for management and control of pods in the bar namespace.""\n  }\n]']","Securing the Kubernetes API server involves understanding the difference between ClusterRoles, ClusterRoleBindings, RoleBindings, and Roles. The document explains various combinations of these concepts for specific use cases, such as accessing cluster-level resources, non-resource URLs, namespaced resources in any or specific namespaces. It also highlights how a ServiceAccount can only view pods within its own namespace, despite using a ClusterRole.","[{'highlight': 'User ""system:serviceaccount:foo:default"" cannot list pods in the namespace ""bar"".'}, {'highlight': 'User ""system:serviceaccount:foo:default"" cannot list pods at the cluster scope.'}, {'highlight': 'Default ServiceAccount in foo namespace is only allowed to view pods in namespace foo, despite using a ClusterRole.'}, {'highlight': 'A RoleBinding referring to a ClusterRole only grants access to resources inside the RoleBinding’s namespace.'}, {'highlight': 'ClusterRole: view Allows getting, listing, watching'}]"
314,403,0,[],"371
Securing the cluster with role-based access control
Hopefully, the relationships between the four RBAC resources are much clearer
now. Don’t worry if you still feel like you don’t yet grasp everything. Things may
clear up as we explore the pre-configured ClusterRoles and ClusterRoleBindings in
the next section.
12.2.5 Understanding default ClusterRoles and ClusterRoleBindings
Kubernetes comes with a default set of ClusterRoles and ClusterRoleBindings, which
are updated every time the API server starts. This ensures all the default roles and
bindings are recreated if you mistakenly delete them or if a newer version of Kuberne-
tes uses a different configuration of cluster roles and bindings.
 You can see the default cluster roles and bindings in the following listing.
$ kubectl get clusterrolebindings
NAME                                           AGE
cluster-admin                                  1d
system:basic-user                              1d
system:controller:attachdetach-controller      1d
...
system:controller:ttl-controller               1d
system:discovery                               1d
system:kube-controller-manager                 1d
system:kube-dns                                1d
system:kube-scheduler                          1d
system:node                                    1d
system:node-proxier                            1d
$ kubectl get clusterroles
NAME                                           AGE
admin                                          1d
cluster-admin                                  1d
edit                                           1d
system:auth-delegator                          1d
system:basic-user                              1d
system:controller:attachdetach-controller      1d
...
system:controller:ttl-controller               1d
system:discovery                               1d
system:heapster                                1d
system:kube-aggregator                         1d
system:kube-controller-manager                 1d
system:kube-dns                                1d
system:kube-scheduler                          1d
system:node                                    1d
system:node-bootstrapper                       1d
system:node-problem-detector                   1d
system:node-proxier                            1d
system:persistent-volume-provisioner           1d
view                                           1d
Listing 12.17
Listing all ClusterRoleBindings and ClusterRoles
 
",[],"[{'entity': 'role-based access control', 'description': 'a security feature that allows you to manage access to a Kubernetes cluster based on roles', 'category': 'software'}, {'entity': 'ClusterRoleBindings', 'description': 'an object that binds a ClusterRole to a user or group', 'category': 'software'}, {'entity': 'ClusterRoles', 'description': 'a set of permissions that define what actions can be performed in a Kubernetes cluster', 'category': 'software'}, {'entity': 'kubectl', 'description': 'the command-line tool for interacting with a Kubernetes cluster', 'category': 'command'}, {'entity': 'get', 'description': 'a command used to retrieve information about an object in the cluster', 'category': 'command'}, {'entity': 'clusterrolebindings', 'description': 'an API resource that lists all ClusterRoleBindings in the cluster', 'category': 'software'}, {'entity': 'clusterroles', 'description': 'an API resource that lists all ClusterRoles in the cluster', 'category': 'software'}, {'entity': 'admin', 'description': 'a ClusterRole that grants full access to a Kubernetes cluster', 'category': 'software'}, {'entity': 'cluster-admin', 'description': 'a ClusterRole that grants full access to a Kubernetes cluster', 'category': 'software'}, {'entity': 'edit', 'description': 'a ClusterRole that grants edit permissions in a Kubernetes cluster', 'category': 'software'}, {'entity': 'system:auth-delegator', 'description': 'a ClusterRole that grants authentication delegation permissions in a Kubernetes cluster', 'category': 'software'}, {'entity': 'system:basic-user', 'description': 'a ClusterRole that grants basic user permissions in a Kubernetes cluster', 'category': 'software'}, {'entity': 'system:controller:attachdetach-controller', 'description': 'a ClusterRole that grants attach/detach controller permissions in a Kubernetes cluster', 'category': 'software'}]","[{'source_entity': 'kubectl', 'description': 'uses to get cluster roles', 'destination_entity': 'ClusterRoles'}, {'source_entity': 'kubectl', 'description': 'uses to edit cluster role bindings', 'destination_entity': 'clusterrolebindings'}, {'source_entity': 'admin', 'description': 'has access to get cluster roles', 'destination_entity': 'ClusterRoles'}, {'source_entity': 'admin', 'description': 'has access to edit cluster role bindings', 'destination_entity': 'clusterrolebindings'}, {'source_entity': 'system:basic-user', 'description': 'has basic user privileges', 'destination_entity': None}, {'source_entity': 'system:controller:attachdetach-controller', 'description': 'is a controller for attaching and detaching volumes', 'destination_entity': None}, {'source_entity': 'kubectl', 'description': 'uses to get cluster role bindings', 'destination_entity': 'ClusterRoleBindings'}, {'source_entity': 'admin', 'description': 'has access to get cluster role bindings', 'destination_entity': 'ClusterRoleBindings'}]","['[\n  {\n    ""source"": ""kubectl"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""uses to get cluster roles"",\n    ""summary_er"": ""kubectl retrieves cluster roles for a pod, enabling access control and role-based management.""\n  }\n]', '[\n  {\n    ""source"": ""kubectl"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""uses to edit cluster role bindings"",\n    ""summary_er"": ""Kubectl edits cluster role bindings for pods, ensuring proper access control and security.""\n  }\n]', '[\n  {\n    ""source"": ""admin"",\n    ""destination"": ""ClusterRoles"",\n    ""relation_description"": ""has access to get cluster roles"",\n    ""summary_er"": ""Admin has read-only access to cluster roles for role-based access control.""\n  }\n]', '[\n  {\n    ""source"": ""admin"",\n    ""destination"": ""clusterrolebindings"",\n    ""relation_description"": ""has access to edit cluster role bindings"",\n    ""summary_er"": ""Admin has edit permissions for ClusterRoleBindings, allowing them to manage role assignments within the Kubernetes cluster.""\n  }\n]', '[\n  {\n    ""source"": ""system"",\n    ""destination"": ""basic-user"",\n    ""relation_description"": ""has basic user privileges"",\n    ""summary_er"": ""The system grants basic user privileges to a user, allowing them to access fundamental features and functionality.""\n  },\n  {\n    ""source"": ""basic-user"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""None"",\n    ""summary_er"": ""A basic user has no direct relationship with a pod, as pods are typically managed by the system or other users with higher privileges.""\n  }\n]', '[\n  {\n    ""source"": ""system"",\n    ""destination"": ""controller"",\n    ""relation_description"": ""is a controller"",\n    ""summary_er"": ""The system is controlled by the controller.""\n  },\n  {\n    ""source"": ""controller"",\n    ""destination"": ""attachdetach-controller"",\n    ""relation_description"": ""is a controller for attaching and detaching volumes"",\n    ""summary_er"": ""The attachdetach-controller is used to manage volume attachments and detachments.""\n  },\n  {\n    ""source"": ""controller"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""None"",\n    ""summary_er"": ""There is no specific relation between the controller and pod, but they are related in a broader context of Kubernetes components.""\n  }\n]', '[\n  {\n    ""source"": ""kubectl"",\n    ""destination"": ""Pod"",\n    ""relation_description"": ""uses to get cluster role bindings"",\n    ""summary_er"": ""kubectl retrieves Pod information by getting cluster role bindings, enabling administrators to manage and monitor Pods within a Kubernetes cluster.""\n  }\n]', '[\n  {\n    ""source"": ""admin"",\n    ""destination"": ""ClusterRoleBindings"",\n    ""relation_description"": ""has access to get cluster role bindings"",\n    ""summary_er"": ""Admin has read-only access to ClusterRoleBindings for cluster role management.""\n  }\n]']","Kubernetes has a default set of ClusterRoles and ClusterRoleBindings that are updated every time the API server starts, allowing for automatic recreation if deleted or changed in newer versions. The default roles include cluster-admin, system:basic-user, and various controller roles.","[{'highlight': 'Kubernetes comes with a default set of ClusterRoles and ClusterRoleBindings, which are updated every time the API server starts.'}, {'highlight': 'You can see the default cluster roles and bindings in the following listing.'}, {'highlight': 'The default cluster roles and bindings include cluster-admin, system:basic-user, system:kube-controller-manager, system:kube-dns, system:kube-scheduler, system:node, and system:node-proxier.'}, {'highlight': 'These default ClusterRoles and ClusterRoleBindings are recreated if you mistakenly delete them or if a newer version of Kubernetes uses a different configuration of cluster roles and bindings.'}, {'highlight': '$ kubectl get clusterrolebindings and $ kubectl get clusterroles commands can be used to view the default ClusterRoleBindings and ClusterRoles, respectively.'}]"
315,404,0,[],"372
CHAPTER 12
Securing the Kubernetes API server
The most important roles are the view, edit, admin, and cluster-admin ClusterRoles.
They’re meant to be bound to ServiceAccounts used by user-defined pods.
ALLOWING READ-ONLY ACCESS TO RESOURCES WITH THE VIEW CLUSTERROLE
You already used the default view ClusterRole in the previous example. It allows read-
ing most resources in a namespace, except for Roles, RoleBindings, and Secrets. You’re
probably wondering, why not Secrets? Because one of those Secrets might include an
authentication token with greater privileges than those defined in the view Cluster-
Role and could allow the user to masquerade as a different user to gain additional
privileges (privilege escalation). 
ALLOWING MODIFYING RESOURCES WITH THE EDIT CLUSTERROLE
Next is the edit ClusterRole, which allows you to modify resources in a namespace,
but also allows both reading and modifying Secrets. It doesn’t, however, allow viewing
or modifying Roles or RoleBindings—again, this is to prevent privilege escalation.
GRANTING FULL CONTROL OF A NAMESPACE WITH THE ADMIN CLUSTERROLE
Complete control of the resources in a namespace is granted in the admin Cluster-
Role. Subjects with this ClusterRole can read and modify any resource in the name-
space, except ResourceQuotas (we’ll learn what those are in chapter 14) and the
Namespace resource itself. The main difference between the edit and the admin Cluster-
Roles is in the ability to view and modify Roles and RoleBindings in the namespace.
NOTE
To prevent privilege escalation, the API server only allows users to cre-
ate and update Roles if they already have all the permissions listed in that
Role (and for the same scope). 
ALLOWING COMPLETE CONTROL WITH THE CLUSTER-ADMIN CLUSTERROLE 
Complete control of the Kubernetes cluster can be given by assigning the cluster-
admin ClusterRole to a subject. As you’ve seen before, the admin ClusterRole doesn’t
allow users to modify the namespace’s ResourceQuota objects or the Namespace
resource itself. If you want to allow a user to do that, you need to create a RoleBinding
that references the cluster-admin ClusterRole. This gives the user included in the
RoleBinding complete control over all aspects of the namespace in which the Role-
Binding is created.
 If you’ve paid attention, you probably already know how to give users complete
control of all the namespaces in the cluster. Yes, by referencing the cluster-admin
ClusterRole in a ClusterRoleBinding instead of a RoleBinding.
UNDERSTANDING THE OTHER DEFAULT CLUSTERROLES
The list of default ClusterRoles includes a large number of other ClusterRoles, which
start with the system: prefix. These are meant to be used by the various Kubernetes
components. Among them, you’ll find roles such as system:kube-scheduler, which
is obviously used by the Scheduler, system:node, which is used by the Kubelets, and
so on. 
 
",[],"[{'entity': 'Kubernetes API server', 'description': 'The most important roles are the view, edit, admin, and cluster-admin ClusterRoles.', 'category': 'software'}, {'entity': 'ClusterRoles', 'description': 'They’re meant to be bound to ServiceAccounts used by user-defined pods.', 'category': 'software'}, {'entity': 'view ClusterRole', 'description': 'It allows read-ing most resources in a namespace, except for Roles, RoleBindings, and Secrets.', 'category': 'software'}, {'entity': 'Roles', 'description': 'They might include an authentication token with greater privileges than those defined in the view Cluster-Role.', 'category': 'software'}, {'entity': 'RoleBindings', 'description': 'They might include an authentication token with greater privileges than those defined in the view Cluster-Role.', 'category': 'software'}, {'entity': 'Secrets', 'description': 'One of those Secrets might include an authentication token with greater privileges than those defined in the view Cluster-Role and could allow the user to masquerade as a different user to gain additional privileges (privilege escalation).', 'category': 'software'}, {'entity': 'edit ClusterRole', 'description': 'It allows you to modify resources in a namespace, but also allows both reading and modifying Secrets.', 'category': 'software'}, {'entity': 'admin ClusterRole', 'description': 'Complete control of the resources in a namespace is granted in the admin Cluster-Role.', 'category': 'software'}, {'entity': 'cluster-admin ClusterRole', 'description': 'Subjects with this ClusterRole can read and modify any resource in the namespace, except ResourceQuotas (we’ll learn what those are in chapter 14) and the Namespace resource itself.', 'category': 'software'}, {'entity': 'ResourceQuotas', 'description': 'They’re used to limit the resources that a namespace can use.', 'category': 'software'}, {'entity': 'Namespace', 'description': 'It’s used to group related resources together.', 'category': 'software'}, {'entity': 'ServiceAccounts', 'description': 'They’re used by user-defined pods to authenticate with the Kubernetes API server.', 'category': 'software'}, {'entity': 'Roles', 'description': 'They define a set of permissions that can be granted to users or groups.', 'category': 'software'}, {'entity': 'RoleBindings', 'description': 'They bind a Role to a user or group, granting them the permissions defined in the Role.', 'category': 'software'}, {'entity': 'ClusterRoleBinding', 'description': 'It’s used to grant permissions to users or groups across multiple namespaces.', 'category': 'software'}]","[{'source_entity': 'Kubernetes API server', 'description': 'authenticates', 'destination_entity': 'cluster-admin ClusterRole'}, {'source_entity': 'Kubernetes API server', 'description': 'enforces', 'destination_entity': 'ResourceQuotas'}, {'source_entity': 'Kubernetes API server', 'description': 'manages', 'destination_entity': 'Roles'}, {'source_entity': 'Kubernetes API server', 'description': 'assigns', 'destination_entity': 'admin ClusterRole'}, {'source_entity': 'Kubernetes API server', 'description': 'grants', 'destination_entity': 'Namespace'}, {'source_entity': 'Kubernetes API server', 'description': 'provides', 'destination_entity': 'edit ClusterRole'}, {'source_entity': 'Kubernetes API server', 'description': 'defines', 'destination_entity': 'ClusterRoles'}, {'source_entity': 'Kubernetes API server', 'description': 'manages', 'destination_entity': 'ServiceAccounts'}, {'source_entity': 'Kubernetes API server', 'description': 'binds', 'destination_entity': 'RoleBindings'}, {'source_entity': 'Kubernetes API server', 'description': 'enforces', 'destination_entity': 'view ClusterRole'}, {'source_entity': 'Kubernetes API server', 'description': 'binds', 'destination_entity': 'ClusterRoleBinding'}]","['[\n  {\n    ""source"": ""Kubernetes API server"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""authenticates"",\n    ""summary_er"": ""The Kubernetes API server verifies the identity of pods to ensure secure access and authentication.""\n  }\n]', '[\n  {\n    ""source"": ""Kubernetes API server"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""enforces"",\n    ""summary_er"": ""The Kubernetes API server enforces resource quotas on pods, ensuring they adhere to predefined limits and constraints.""\n  }\n]', '[\n  {\n    ""source"": ""Kubernetes API server"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""manages"",\n    ""summary_er"": ""The Kubernetes API server manages a pod, which is a logical host for running containers.""\n  }\n]', '[\n  {\n    ""source"": ""Kubernetes API server"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""assigns"",\n    ""summary_er"": ""The Kubernetes API server assigns a pod to manage resources and execute tasks.""\n  },\n  {\n    ""source"": ""admin ClusterRole"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""assigns"",\n    ""summary_er"": ""The admin ClusterRole assigns a pod to perform administrative tasks and manage cluster resources.""\n  }\n]', '[\n  {\n    ""source"": ""Kubernetes API server"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""grants"",\n    ""summary_er"": ""The Kubernetes API server authorizes and authenticates pods, granting them access to cluster resources.""\n  }\n]', '[\n  {\n    ""source"": ""Kubernetes API server"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""provides"",\n    ""summary_er"": ""The Kubernetes API server provides a pod with access to edit ClusterRole.""\n  }\n]', '[\n  {\n    ""source"": ""Kubernetes API server"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""defines"",\n    ""summary_er"": ""The Kubernetes API server defines a pod, which is a logical host for running containers.""\n  }\n]', '[{\n  ""source"": ""Kubernetes API server"",\n  ""destination"": ""pod"",\n  ""relation_description"": ""manages"",\n  ""summary_er"": ""The Kubernetes API server manages pods, ensuring they are created, updated, and deleted as needed.""\n}]', '[\n  {\n    ""source"": ""Kubernetes API server"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""binds"",\n    ""summary_er"": ""The Kubernetes API server binds a pod to a cluster, establishing its presence and configuration within the containerized environment.""\n  }\n]', '[\n  {\n    ""source"": ""Kubernetes API server"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""enforces"",\n    ""summary_er"": ""The Kubernetes API server enforces policies on pods, ensuring they adhere to defined rules and configurations.""\n  }\n]', '[{\n  ""source"": ""Kubernetes API server"",\n  ""destination"": ""pod"",\n  ""relation_description"": ""binds"",\n  ""summary_er"": ""The Kubernetes API server binds a pod to its intended role, ensuring proper resource allocation and access control.""\n}]']","The most important ClusterRoles in Kubernetes are view, edit, admin, and cluster-admin, designed to prevent privilege escalation. The view role allows read-only access, while the edit role grants modifying resources within a namespace. The admin role provides complete control of a namespace's resources, but not ResourceQuotas or Namespace itself. The cluster-admin role offers complete control over the entire Kubernetes cluster.","[{'highlight': 'The most important roles are the view, edit, admin, and cluster-admin ClusterRoles.'}, {'highlight': 'ALLOWING READ-ONLY ACCESS TO RESOURCES WITH THE VIEW CLUSTERROLE'}, {'highlight': 'GRANTING FULL CONTROL OF A NAMESPACE WITH THE ADMIN CLUSTERROLE'}, {'highlight': 'ALLOWING COMPLETE CONTROL WITH THE CLUSTER-ADMIN CLUSTERROLE'}, {'highlight': 'The list of default ClusterRoles includes a large number of other ClusterRoles, which start with the system: prefix.'}]"
316,405,0,[],"373
Summary
 Although the Controller Manager runs as a single pod, each controller running
inside it can use a separate ClusterRole and ClusterRoleBinding (they’re prefixed
with system: controller:). 
 Each of these system ClusterRoles has a matching ClusterRoleBinding, which binds
it to the user the system component authenticates as. The system:kube-scheduler
ClusterRoleBinding, for example, assigns the identically named ClusterRole to the
system:kube-scheduler user, which is the username the scheduler Authenticates as. 
12.2.6 Granting authorization permissions wisely
By default, the default ServiceAccount in a namespace has no permissions other than
those of an unauthenticated user (as you may remember from one of the previous
examples, the system:discovery ClusterRole and associated binding allow anyone to
make GET requests on a few non-resource URLs). Therefore, pods, by default, can’t
even view cluster state. It’s up to you to grant them appropriate permissions to do that. 
 Obviously, giving all your ServiceAccounts the cluster-admin ClusterRole is a
bad idea. As is always the case with security, it’s best to give everyone only the permis-
sions they need to do their job and not a single permission more (principle of least
privilege).
CREATING SPECIFIC SERVICEACCOUNTS FOR EACH POD
It’s a good idea to create a specific ServiceAccount for each pod (or a set of pod rep-
licas) and then associate it with a tailor-made Role (or a ClusterRole) through a
RoleBinding (not a ClusterRoleBinding, because that would give the pod access to
resources in other namespaces, which is probably not what you want). 
 If one of your pods (the application running within it) only needs to read pods,
while the other also needs to modify them, then create two different ServiceAccounts
and make those pods use them by specifying the serviceAccountName property in the
pod spec, as you learned in the first part of this chapter. Don’t add all the necessary
permissions required by both pods to the default ServiceAccount in the namespace. 
EXPECTING YOUR APPS TO BE COMPROMISED
Your aim is to reduce the possibility of an intruder getting hold of your cluster. Today’s
complex apps contain many vulnerabilities. You should expect unwanted persons to
eventually get their hands on the ServiceAccount’s authentication token, so you should
always constrain the ServiceAccount to prevent them from doing any real damage.
12.3
Summary
This chapter has given you a foundation on how to secure the Kubernetes API server.
You learned the following:
Clients of the API server include both human users and applications running
in pods.
Applications in pods are associated with a ServiceAccount. 
Both users and ServiceAccounts are associated with groups.
 
",[],"[{'entity': 'Controller Manager', 'description': 'A single pod that runs each controller inside it', 'category': 'application'}, {'entity': 'ClusterRole', 'description': 'A role that defines permissions for a user or service account', 'category': 'database'}, {'entity': 'ClusterRoleBinding', 'description': 'A binding that associates a ClusterRole with a user or service account', 'category': 'database'}, {'entity': 'ServiceAccount', 'description': 'An identity for pods to authenticate with the API server', 'category': 'application'}, {'entity': 'Role', 'description': 'A role that defines permissions for a user or service account within a namespace', 'category': 'database'}, {'entity': 'RoleBinding', 'description': 'A binding that associates a Role with a user or service account within a namespace', 'category': 'database'}, {'entity': 'ClusterAdmin', 'description': 'The highest level of permissions in the cluster', 'category': 'application'}, {'entity': 'ServiceAccountName', 'description': 'A property that specifies the service account to use for a pod', 'category': 'application'}, {'entity': 'API Server', 'description': 'The server that provides access to the Kubernetes cluster', 'category': 'application'}, {'entity': 'ServiceAccountToken', 'description': 'An authentication token used by a ServiceAccount to authenticate with the API server', 'category': 'database'}]","[{'source_entity': 'API Server', 'description': 'authenticates and authorizes requests from users', 'destination_entity': 'ServiceAccountToken'}, {'source_entity': 'API Server', 'description': 'verifies the validity of ServiceAccountTokens', 'destination_entity': 'ServiceAccountName'}, {'source_entity': 'Controller Manager', 'description': 'manages and coordinates the actions of Controllers', 'destination_entity': 'ClusterRoleBinding'}, {'source_entity': 'API Server', 'description': 'enforces access control policies based on ClusterRoleBindings', 'destination_entity': 'ClusterAdmin'}, {'source_entity': 'Controller Manager', 'description': 'manages and coordinates the actions of Controllers', 'destination_entity': 'ServiceAccount'}, {'source_entity': 'API Server', 'description': 'authenticates and authorizes requests from users based on ServiceAccounts', 'destination_entity': 'ServiceAccount'}, {'source_entity': 'RoleBinding', 'description': 'binds a Role to a user or group', 'destination_entity': 'ClusterAdmin'}, {'source_entity': 'API Server', 'description': 'enforces access control policies based on RoleBindings', 'destination_entity': 'Role'}, {'source_entity': 'Controller Manager', 'description': 'manages and coordinates the actions of Controllers', 'destination_entity': 'ClusterRoleBinding'}]","['[\n  {\n    ""source"": ""API Server"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""authenticates and authorizes requests from users"",\n    ""summary_er"": ""The API Server authenticates and authorizes user requests, ensuring secure access to resources.""\n  },\n  {\n    ""source"": ""ServiceAccountToken"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""provides authentication credentials"",\n    ""summary_er"": ""A ServiceAccountToken provides authentication credentials for pods to access cluster resources securely.""\n  }\n]', '[\n  {\n    ""source"": ""API Server"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""verifies the validity of ServiceAccountTokens"",\n    ""summary_er"": ""The API Server verifies the validity of ServiceAccountTokens for a pod, ensuring secure access to cluster resources.""\n  },\n  {\n    ""source"": ""ServiceAccountName"",\n    ""destination"": ""pod"",\n    ""relation_description"": """",\n    ""summary_er"": """"\n  }\n]', '[\n  {\n    ""source"": ""Controller Manager"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""manages and coordinates the actions of Controllers"",\n    ""summary_er"": ""The Controller Manager oversees and synchronizes the activities of Controllers, ensuring they function correctly within the pod environment.""\n  },\n  {\n    ""source"": ""ClusterRoleBinding"",\n    ""destination"": ""Controller Manager"",\n    ""relation_description"": ""relates to"",\n    ""summary_er"": ""A ClusterRoleBinding establishes a connection between itself and the Controller Manager, defining their roles and responsibilities within the cluster.""\n  }\n]', '[\n  {\n    ""source"": ""API Server"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""enforces access control policies based on ClusterRoleBindings"",\n    ""summary_er"": ""The API Server enforces access control for pods using ClusterRoleBindings, ensuring only authorized entities can interact with them.""\n  }\n]', '[\n  {\n    ""source"": ""Controller Manager"",\n    ""destination"": ""Pod"",\n    ""relation_description"": ""manages and coordinates the actions of Controllers"",\n    ""summary_er"": ""The Controller Manager oversees and synchronizes the activities of Controllers to ensure efficient operation within a Pod environment.""\n  },\n  {\n    ""source"": ""ServiceAccount"",\n    ""destination"": ""Pod"",\n    ""relation_description"": ""manages and coordinates the actions of Controllers"",\n    ""summary_er"": ""A ServiceAccount is responsible for managing and coordinating the actions of Controllers within a specific Pod, ensuring secure and efficient operation.""\n  }\n]', '[\n  {\n    ""source"": ""API Server"",\n    ""destination"": ""ServiceAccount"",\n    ""relation_description"": ""authenticates and authorizes requests from users based on ServiceAccounts"",\n    ""summary_er"": ""The API Server authenticates and authorizes user requests using ServiceAccounts, ensuring secure access to resources.""\n  },\n  {\n    ""source"": ""ServiceAccount"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""based on ServiceAccounts"",\n    ""summary_er"": ""A ServiceAccount is used by a pod to authenticate and authorize requests, providing secure access to cluster resources.""\n  }\n]', '[\n  {\n    ""source"": ""RoleBinding"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""binds a Role to a user or group"",\n    ""summary_er"": ""A RoleBinding binds a Role to a specific user or group, granting them access to resources within the cluster.""\n  },\n  {\n    ""source"": ""ClusterAdmin"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""cluster administrator role"",\n    ""summary_er"": ""The ClusterAdmin role grants full administrative privileges to users, allowing them to manage and configure the entire Kubernetes cluster.""\n  }\n]', '[\n  {\n    ""source"": ""API Server"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""enforces access control policies based on RoleBindings"",\n    ""summary_er"": ""The API Server enforces access control to pods using RoleBindings.""\n  }\n]', '[\n  {\n    ""source"": ""Controller Manager"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""manages and coordinates the actions of Controllers"",\n    ""summary_er"": ""The Controller Manager oversees and synchronizes the activities of Controllers, ensuring they operate in harmony with pods.""\n  },\n  {\n    ""source"": ""ClusterRoleBinding"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""assigns permissions to a user or service account for accessing cluster resources"",\n    ""summary_er"": ""A ClusterRoleBinding grants access rights to users or services, enabling them to interact with pods and other cluster components.""\n  }\n]']","The Controller Manager runs as a single pod, but each controller can use a separate ClusterRole and ClusterRoleBinding. By default, ServiceAccounts have no permissions, so pods can't view cluster state. It's best to grant only the necessary permissions (principle of least privilege). Create specific ServiceAccounts for each pod and associate them with tailor-made Roles through RoleBindings. Constrain ServiceAccounts to prevent damage if compromised.","[{'highlight': 'Each controller running inside the Controller Manager can use a separate ClusterRole and ClusterRoleBinding, which binds it to the user the system component authenticates as.'}, {'highlight': 'By default, the default ServiceAccount in a namespace has no permissions other than those of an unauthenticated user, so pods can’t even view cluster state without explicit permission.'}, {'highlight': 'It’s best to give everyone only the permissions they need to do their job and not a single permission more (principle of least privilege), rather than giving all ServiceAccounts the cluster-admin ClusterRole.'}, {'highlight': 'Creating specific ServiceAccounts for each pod and associating them with tailor-made Roles or ClusterRoles through RoleBindings is a good idea, especially when different pods have different permissions needs.'}, {'highlight': ""You should expect unwanted persons to eventually get hold of your cluster's ServiceAccount authentication token, so you should always constrain the ServiceAccount to prevent them from doing any real damage.""}]"
317,406,0,[],"374
CHAPTER 12
Securing the Kubernetes API server
By default, pods run under the default ServiceAccount, which is created for
each namespace automatically.
Additional ServiceAccounts can be created manually and associated with a pod.
ServiceAccounts can be configured to allow mounting only a constrained list of
Secrets in a given pod.
A ServiceAccount can also be used to attach image pull Secrets to pods, so you
don’t need to specify the Secrets in every pod.
Roles and ClusterRoles define what actions can be performed on which resources.
RoleBindings and ClusterRoleBindings bind Roles and ClusterRoles to users,
groups, and ServiceAccounts.
Each cluster comes with default ClusterRoles and ClusterRoleBindings.
In the next chapter, you’ll learn how to protect the cluster nodes from pods and how
to isolate pods from each other by securing the network.
 
",[],"[{'entity': 'Kubernetes API server', 'description': 'The component responsible for managing and securing access to Kubernetes resources.', 'category': 'application'}, {'entity': 'ServiceAccount', 'description': 'A ServiceAccount is an identity used by pods to authenticate with the Kubernetes API server.', 'category': 'software'}, {'entity': 'pods', 'description': 'The basic execution unit in a containerized environment, running as a process within a container.', 'category': 'container'}, {'entity': 'Secrets', 'description': 'A Secret is an object that stores sensitive information such as passwords or OAuth tokens.', 'category': 'database'}, {'entity': 'Roles', 'description': 'A Role defines what actions can be performed on which resources in the Kubernetes cluster.', 'category': 'software'}, {'entity': 'ClusterRoles', 'description': 'A ClusterRole is a role that applies to all namespaces within a Kubernetes cluster.', 'category': 'software'}, {'entity': 'RoleBindings', 'description': 'A RoleBinding binds a Role or ClusterRole to a user, group, or ServiceAccount.', 'category': 'software'}, {'entity': 'ClusterRoleBindings', 'description': 'A ClusterRoleBinding binds a ClusterRole to a user, group, or ServiceAccount across all namespaces in the cluster.', 'category': 'software'}]","[{'source_entity': 'Kubernetes API server', 'description': 'manages and controls', 'destination_entity': 'pods'}, {'source_entity': 'Kubernetes API server', 'description': 'enforces', 'destination_entity': 'Roles'}, {'source_entity': 'Kubernetes API server', 'description': 'binds', 'destination_entity': 'RoleBindings'}, {'source_entity': 'Kubernetes API server', 'description': 'manages', 'destination_entity': 'ClusterRoles'}, {'source_entity': 'Kubernetes API server', 'description': 'binds', 'destination_entity': 'ClusterRoleBindings'}, {'source_entity': 'ServiceAccount', 'description': 'uses', 'destination_entity': 'Secrets'}, {'source_entity': 'Roles', 'description': 'defines', 'destination_entity': 'permissions'}, {'source_entity': 'RoleBindings', 'description': 'assigns', 'destination_entity': 'roles'}, {'source_entity': 'ClusterRoles', 'description': 'defines', 'destination_entity': 'cluster-wide permissions'}, {'source_entity': 'ClusterRoleBindings', 'description': 'assigns', 'destination_entity': 'cluster roles'}]","['[\n  {\n    ""source"": ""Kubernetes API server"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""manages and controls"",\n    ""summary_er"": ""The Kubernetes API server manages and controls all aspects of cluster operations, including pods.""\n  }\n]', '[\n  {\n    ""source"": ""Kubernetes API server"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""enforces"",\n    ""summary_er"": ""The Kubernetes API server enforces policies on pods, ensuring they comply with defined rules and configurations.""\n  }\n]', '[\n  {\n    ""source"": ""Kubernetes API server"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""binds"",\n    ""summary_er"": ""The Kubernetes API server binds a pod to a specific role, granting it access to resources and permissions.""\n  }\n]', '[\n  {\n    ""source"": ""Kubernetes API server"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""manages"",\n    ""summary_er"": ""The Kubernetes API server manages and controls the lifecycle of a pod, ensuring it runs as expected.""\n  }\n]', '[\n  {\n    ""source"": ""Kubernetes API server"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""binds"",\n    ""summary_er"": ""The Kubernetes API server binds a pod to a ClusterRoleBinding, granting access to the pod\'s resources.""\n  }\n]', '[\n  {\n    ""source"": ""ServiceAccount"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""uses"",\n    ""summary_er"": ""A ServiceAccount provides an identity for a pod to authenticate with the API server, allowing it to access secrets and other resources.""\n  }\n]', '[\n  {\n    ""source"": ""Roles"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""defines"",\n    ""summary_er"": ""Roles define the permissions for a pod, specifying what actions can be performed on it.""\n  }\n]', '[\n  {\n    ""source"": ""RoleBindings"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""assigns"",\n    ""summary_er"": ""RoleBindings assign specific roles to pods, defining their responsibilities within a Kubernetes cluster.""\n  }\n]', '[\n  {\n    ""source"": ""ClusterRoles"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""defines"",\n    ""summary_er"": ""ClusterRoles define cluster-wide permissions for pods, allowing them to access resources and perform actions across the entire Kubernetes cluster.""\n  }\n]', '[{\n  ""source"": ""ClusterRoleBindings"",\n  ""destination"": ""pod"",\n  ""relation_description"": ""assigns"",\n  ""summary_er"": ""ClusterRoleBindings assign permissions to pods, allowing them to access cluster resources.""\n}]']","Kubernetes API server security is discussed. ServiceAccounts are used to run pods, with default accounts created for each namespace. Additional accounts can be created manually and configured to allow mounting specific Secrets. Roles and ClusterRoles define allowed actions on resources, and RoleBindings bind these to users, groups, and ServiceAccounts. This sets the stage for securing cluster nodes and isolating pods in the next chapter.","[{'highlight': 'By default, pods run under the default ServiceAccount, which is created for each namespace automatically.'}, {'highlight': 'ServiceAccounts can be configured to allow mounting only a constrained list of Secrets in a given pod.'}, {'highlight': 'Roles and ClusterRoles define what actions can be performed on which resources.'}, {'highlight': 'RoleBindings and ClusterRoleBindings bind Roles and ClusterRoles to users, groups, and ServiceAccounts.'}, {'highlight': 'Each cluster comes with default ClusterRoles and ClusterRoleBindings.'}]"
318,407,0,[],"375
Securing cluster nodes
and the network
In the previous chapter, we talked about securing the API server. If an attacker
gets access to the API server, they can run whatever they like by packaging their
code into a container image and running it in a pod. But can they do any real
damage? Aren’t containers isolated from other containers and from the node
they’re running on? 
 Not necessarily. In this chapter, you’ll learn how to allow pods to access the
resources of the node they’re running on. You’ll also learn how to configure the
cluster so users aren’t able to do whatever they want with their pods. Then, in
This chapter covers
Using the node’s default Linux namespaces 
in pods
Running containers as different users
Running privileged containers
Adding or dropping a container’s kernel 
capabilities
Defining security policies to limit what pods can do
Securing the pod network
 
",[],"[{'entity': 'cluster nodes', 'description': 'a group of machines that run Kubernetes', 'category': 'hardware'}, {'entity': 'API server', 'description': 'the central component of a Kubernetes cluster', 'category': 'software'}, {'entity': 'container image', 'description': 'a packaged version of an application and its dependencies', 'category': 'software'}, {'entity': 'pod', 'description': 'the basic execution unit in Kubernetes', 'category': 'software'}, {'entity': 'node', 'description': 'a machine that runs a pod', 'category': 'hardware'}, {'entity': 'Linux namespaces', 'description': 'a way to isolate processes from each other', 'category': 'software'}, {'entity': 'users', 'description': 'individuals who interact with the cluster', 'category': 'application'}, {'entity': 'policies', 'description': 'rules that govern what pods can do', 'category': 'software'}, {'entity': 'pod network', 'description': 'a virtual network for pods to communicate on', 'category': 'network'}]","[{'source_entity': 'pod network', 'description': 'is managed by', 'destination_entity': 'node'}, {'source_entity': 'node', 'description': 'hosts', 'destination_entity': 'pod'}, {'source_entity': 'policies', 'description': 'are enforced on', 'destination_entity': 'pod network'}, {'source_entity': 'Linux namespaces', 'description': 'are used by', 'destination_entity': 'container image'}, {'source_entity': 'users', 'description': 'interact with', 'destination_entity': 'API server'}, {'source_entity': 'pod', 'description': 'is scheduled on', 'destination_entity': 'cluster nodes'}, {'source_entity': 'container image', 'description': 'is stored in', 'destination_entity': 'node'}]","['[\n  {\n    ""source"": ""pod"",\n    ""destination"": ""network"",\n    ""relation_description"": ""is managed by"",\n    ""summary_er"": ""A pod uses a network to manage its communication and data exchange.""\n  },\n  {\n    ""source"": ""pod"",\n    ""destination"": ""node"",\n    ""relation_description"": ""runs on"",\n    ""summary_er"": ""A pod runs on a node, utilizing its resources for execution.""\n  }\n]', '[\n  {\n    ""source"": ""node"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""hosts"",\n    ""summary_er"": ""A Kubernetes node can host one or more pods, providing them with resources such as CPU and memory.""\n  }\n]', '[\n  {\n    ""source"": ""policies"",\n    ""destination"": ""pod network"",\n    ""relation_description"": ""are enforced on"",\n    ""summary_er"": ""Policies govern access to pod network, ensuring secure communication between containers.""\n  }\n]', '[\n  {\n    ""source"": ""Linux namespaces"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""are used by"",\n    ""summary_er"": ""Linux namespaces provide isolation for a pod, allowing multiple processes to run concurrently without interference.""\n  },\n  {\n    ""source"": ""container image"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""is stored in"",\n    ""summary_er"": ""A container image is stored in a pod, which serves as the runtime environment for the containerized application.""\n  }\n]', '[\n  {\n    ""source"": ""users"",\n    ""destination"": ""API server"",\n    ""relation_description"": ""interact with"",\n    ""summary_er"": ""Users interact with the API server to access Kubernetes resources and manage their cluster.""\n  }\n]', '[\n  {\n    ""source"": ""pod"",\n    ""destination"": ""cluster nodes"",\n    ""relation_description"": ""is scheduled on"",\n    ""summary_er"": ""A pod is scheduled to run on a specific node within the Kubernetes cluster, utilizing available resources and ensuring efficient resource allocation.""\n  }\n]', '[\n  {\n    ""source"": ""container image"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""is stored in"",\n    ""summary_er"": ""A container image is stored within a pod, providing a runtime environment for the application.""\n  }\n]']","This chapter focuses on securing cluster nodes and the network, allowing pods to access node resources while limiting user actions. Key topics include using default Linux namespaces in pods, running containers as different users, privileged containers, modifying kernel capabilities, defining security policies, and securing the pod network.","[{'highlight': ""Allowing pods to access node resources can be done by using the node's default Linux namespaces in pods.""}, {'highlight': ""Running containers as different users can help configure the cluster so users aren't able to do whatever they want with their pods.""}, {'highlight': 'Privileged containers can be run, but this requires careful consideration of security policies to limit what pods can do.'}, {'highlight': ""Adding or dropping a container's kernel capabilities is another way to secure the pod network and prevent unauthorized access.""}, {'highlight': 'Defining security policies is crucial to limit what pods can do and prevent attackers from running malicious code in containers.'}]"
319,408,0,[],"376
CHAPTER 13
Securing cluster nodes and the network
the last part of the chapter, you’ll also learn how to secure the network the pods use
to communicate.
13.1
Using the host node’s namespaces in a pod
Containers in a pod usually run under separate Linux namespaces, which isolate
their processes from processes running in other containers or in the node’s default
namespaces. 
 For example, we learned that each pod gets its own IP and port space, because it
uses its own network namespace. Likewise, each pod has its own process tree, because
it has its own PID namespace, and it also uses its own IPC namespace, allowing only
processes in the same pod to communicate with each other through the Inter-Process
Communication mechanism (IPC).
13.1.1 Using the node’s network namespace in a pod
Certain pods (usually system pods) need to operate in the host’s default namespaces,
allowing them to see and manipulate node-level resources and devices. For example, a
pod may need to use the node’s network adapters instead of its own virtual network
adapters. This can be achieved by setting the hostNetwork property in the pod spec
to true.
 In that case, the pod gets to use the node’s network interfaces instead of having its
own set, as shown in figure 13.1. This means the pod doesn’t get its own IP address and
if it runs a process that binds to a port, the process will be bound to the node’s port.
You can try running such a pod. The next listing shows an example pod manifest.
apiVersion: v1
kind: Pod
metadata:
  name: pod-with-host-network
Listing 13.1
A pod using the node’s network namespace: pod-with-host-network.yaml
Node
Pod A
Pod’s own network
namespace
eth0
lo
eth0
docker0
lo
eth1
Node’s default network
namespace
Pod B
hostNetwork: true
Figure 13.1
A pod 
with hostNetwork: 
true uses the node’s 
network interfaces 
instead of its own.
 
","[Empty DataFrame
Columns: [eth0, lo]
Index: [],    eth0  Col1 Col2  Col3     Col4 Col5
0  None  eth0       eth1  docker0   lo]","[{'entity': 'Linux namespaces', 'description': ""Isolate processes from other containers or node's default namespaces"", 'category': 'process'}, {'entity': 'IP and port space', 'description': 'Each pod gets its own IP and port space', 'category': 'network'}, {'entity': 'PID namespace', 'description': 'Each pod has its own process tree', 'category': 'process'}, {'entity': 'IPC namespace', 'description': 'Allow processes in the same pod to communicate with each other', 'category': 'network'}, {'entity': 'Inter-Process Communication (IPC)', 'description': 'Mechanism for processes in the same pod to communicate', 'category': 'process'}, {'entity': 'hostNetwork property', 'description': ""Allow pods to use node's network interfaces instead of their own"", 'category': 'network'}, {'entity': ""node's network adapters"", 'description': ""Pods can use node's network adapters instead of virtual network adapters"", 'category': 'hardware'}, {'entity': 'virtual network adapters', 'description': 'Pods have their own virtual network adapters', 'category': 'hardware'}, {'entity': 'eth0', 'description': ""Node's default network interface"", 'category': 'network'}, {'entity': 'lo', 'description': 'Loopback interface', 'category': 'network'}, {'entity': 'docker0', 'description': 'Docker bridge interface', 'category': 'network'}, {'entity': 'eth1', 'description': ""Node's network interface"", 'category': 'network'}, {'entity': 'Pod A', 'description': 'Pod using its own network namespace', 'category': 'application'}, {'entity': 'Pod B', 'description': ""Pod using node's network namespace"", 'category': 'application'}]","[{'source_entity': '""node\'s network adapters""', 'description': 'provides', 'destination_entity': '""virtual network adapters""'}, {'source_entity': '""IPC namespace""', 'description': 'allows for', 'destination_entity': '""Inter-Process Communication (IPC)""'}, {'source_entity': '""docker0""', 'description': 'serves as', 'destination_entity': '""virtual network adapters""'}, {'source_entity': '""hostNetwork property""', 'description': 'enables', 'destination_entity': '""IP and port space""'}, {'source_entity': '""Pod A""', 'description': 'uses', 'destination_entity': '""Linux namespaces""'}, {'source_entity': '""Pod B""', 'description': 'utilizes', 'destination_entity': '""Linux namespaces""'}, {'source_entity': '""eth0""', 'description': 'provides', 'destination_entity': '""IP and port space""'}, {'source_entity': '""lo""', 'description': 'serves as', 'destination_entity': '""loopback interface""'}, {'source_entity': '""PID namespace""', 'description': 'allows for', 'destination_entity': '""process isolation""'}, {'source_entity': '""eth1""', 'description': 'provides', 'destination_entity': '""additional network interface""'}]","['[\n  {\n    ""source"": ""node\'s network adapters"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""provides"",\n    ""summary_er"": ""A node\'s network adapters provide virtual network adapters to a pod, enabling communication and data transfer between them.""\n  }\n]', '[\n  {\n    ""source"": ""IPC namespace"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""allows for"",\n    ""summary_er"": ""The IPC namespace enables communication between processes within a pod, allowing them to share resources and exchange data.""\n  }\n]', '[\n  {\n    ""source"": ""docker0"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""serves as virtual network adapters"",\n    ""summary_er"": ""Docker0 serves as a virtual network adapter for pods, enabling communication between containers and the host machine.""\n  }\n]', '[\n  {\n    ""source"": ""hostNetwork property"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""enables"",\n    ""summary_er"": ""The hostNetwork property allows a pod to use the host\'s IP and port space, enabling communication between the pod and other processes running on the host.""\n  }\n]', '[\n  {\n    ""source"": ""Pod A"",\n    ""destination"": ""Linux namespaces"",\n    ""relation_description"": ""uses"",\n    ""summary_er"": ""Pod A utilizes Linux namespaces for isolation and resource management.""\n  }\n]', '[\n  {\n    ""source"": ""Pod B"",\n    ""destination"": ""Linux namespaces"",\n    ""relation_description"": ""utilizes"",\n    ""summary_er"": ""Pod B utilizes Linux namespaces to isolate processes and provide a layer of security.""\n  }\n]', '[\n  {\n    ""source"": ""eth0"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""provides"",\n    ""summary_er"": ""The eth0 interface provides IP and port space to a pod, enabling network connectivity.""\n  }\n]', '[\n  {\n    ""source"": ""lo"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""serves as loopback interface"",\n    ""summary_er"": ""The \'lo\' entity serves as a loopback interface for the pod, providing a local IP address for communication within the cluster.""\n  }\n]', '[\n  {\n    ""source"": ""PID namespace"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""allows for process isolation"",\n    ""summary_er"": ""The PID namespace allows a pod to run processes in isolation from other pods, ensuring secure and independent execution.""\n  }\n]', '[\n  {\n    ""source"": ""eth1"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""provides"",\n    ""summary_er"": ""The eth1 provides a network interface for the pod to communicate with other nodes.""\n  },\n  {\n    ""source"": ""additional network interface"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""provides"",\n    ""summary_er"": ""The additional network interface is provided by the pod for enhanced networking capabilities.""\n  }\n]']","In Kubernetes, containers in a pod run under separate namespaces, isolating their processes from other containers or the node's default namespace. Certain system pods can use the node's network namespace by setting hostNetwork to true in the pod spec, allowing them to see and manipulate node-level resources and devices.","[{'highlight': ""Containers in a pod usually run under separate Linux namespaces, which isolate their processes from processes running in other containers or in the node's default namespaces.""}, {'highlight': ""Certain pods (usually system pods) need to operate in the host's default namespaces, allowing them to see and manipulate node-level resources and devices.""}, {'highlight': ""By setting the hostNetwork property in the pod spec to true, a pod gets to use the node's network interfaces instead of having its own set, without getting its own IP address.""}, {'highlight': ""A pod using the node's network namespace does not get its own IP address and if it runs a process that binds to a port, the process will be bound to the node's port.""}, {'highlight': ""The hostNetwork property in the pod spec can be set to true to allow a pod to use the node's network interfaces instead of its own virtual network adapters.""}]"
