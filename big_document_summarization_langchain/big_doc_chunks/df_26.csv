,page,img_cnt,img_npy_lst,text,tables,entities,relationships,summary_rel,summary,highlights
260,349,0,[],"317
Understanding the architecture
AUTHENTICATING THE CLIENT WITH AUTHENTICATION PLUGINS
First, the API server needs to authenticate the client sending the request. This is per-
formed by one or more authentication plugins configured in the API server. The API
server calls these plugins in turn, until one of them determines who is sending the
request. It does this by inspecting the HTTP request. 
 Depending on the authentication method, the user can be extracted from the cli-
ent’s certificate or an HTTP header, such as Authorization, which you used in chap-
ter 8. The plugin extracts the client’s username, user ID, and groups the user belongs
to. This data is then used in the next stage, which is authorization.
AUTHORIZING THE CLIENT WITH AUTHORIZATION PLUGINS
Besides authentication plugins, the API server is also configured to use one or more
authorization plugins. Their job is to determine whether the authenticated user can
perform the requested action on the requested resource. For example, when creating
pods, the API server consults all authorization plugins in turn, to determine whether
the user can create pods in the requested namespace. As soon as a plugin says the user
can perform the action, the API server progresses to the next stage.
VALIDATING AND/OR MODIFYING THE RESOURCE IN THE REQUEST WITH ADMISSION CONTROL PLUGINS
If the request is trying to create, modify, or delete a resource, the request is sent
through Admission Control. Again, the server is configured with multiple Admission
Control plugins. These plugins can modify the resource for different reasons. They
may initialize fields missing from the resource specification to the configured default
values or even override them. They may even modify other related resources, which
aren’t in the request, and can also reject a request for whatever reason. The resource
passes through all Admission Control plugins.
NOTE
When the request is only trying to read data, the request doesn’t go
through the Admission Control.
Examples of Admission Control plugins include

AlwaysPullImages—Overrides the pod’s imagePullPolicy to Always, forcing
the image to be pulled every time the pod is deployed.

ServiceAccount—Applies the default service account to pods that don’t specify
it explicitly.

NamespaceLifecycle—Prevents creation of pods in namespaces that are in the
process of being deleted, as well as in non-existing namespaces.

ResourceQuota—Ensures pods in a certain namespace only use as much CPU
and memory as has been allotted to the namespace. We’ll learn more about this
in chapter 14.
You’ll find a list of additional Admission Control plugins in the Kubernetes documen-
tation at https:/
/kubernetes.io/docs/admin/admission-controllers/.
 
",[],"[{'entity': 'Authentication Plugins', 'description': 'Plugins configured in the API server to authenticate clients sending requests.', 'category': 'Software'}, {'entity': 'API Server', 'description': 'The server that handles incoming requests and authenticates clients.', 'category': 'Software'}, {'entity': 'HTTP Request', 'description': 'The request sent by the client to the API server.', 'category': 'Network'}, {'entity': 'Client Certificate', 'description': 'A certificate used by clients to authenticate themselves.', 'category': 'Software'}, {'entity': 'HTTP Header', 'description': 'A header in the HTTP request that contains authentication information.', 'category': 'Network'}, {'entity': 'Authorization Plugins', 'description': 'Plugins configured in the API server to determine whether authenticated users can perform actions on requested resources.', 'category': 'Software'}, {'entity': 'User', 'description': 'The person or entity that is sending the request.', 'category': 'Application'}, {'entity': 'Pods', 'description': 'Resources in Kubernetes that can be created, modified, or deleted.', 'category': 'Software'}, {'entity': 'Namespace', 'description': 'A scope for resources in Kubernetes.', 'category': 'Software'}, {'entity': 'Admission Control Plugins', 'description': 'Plugins that validate and/or modify resources in requests.', 'category': 'Software'}, {'entity': 'AlwaysPullImages', 'description': ""An Admission Control plugin that overrides the pod's imagePullPolicy to Always."", 'category': 'Software'}, {'entity': 'ServiceAccount', 'description': 'An Admission Control plugin that applies the default service account to pods.', 'category': 'Software'}, {'entity': 'NamespaceLifecycle', 'description': 'An Admission Control plugin that prevents creation of pods in namespaces being deleted or not existing.', 'category': 'Software'}, {'entity': 'ResourceQuota', 'description': 'An Admission Control plugin that ensures pods in a namespace only use allotted CPU and memory.', 'category': 'Software'}]","[{'source_entity': 'ServiceAccount', 'description': 'authenticates users to access API Server', 'destination_entity': 'API Server'}, {'source_entity': 'Client Certificate', 'description': 'verifies the identity of clients making requests', 'destination_entity': 'API Server'}, {'source_entity': 'Admission Control Plugins', 'description': 'enforces policies on API Server', 'destination_entity': 'API Server'}, {'source_entity': 'ResourceQuota', 'description': 'limits the resources used by Pods', 'destination_entity': 'Pods'}, {'source_entity': 'Namespace', 'description': 'organizes and isolates resources for users', 'destination_entity': 'API Server'}, {'source_entity': 'AlwaysPullImages', 'description': 'pulls images from registries before deploying Pods', 'destination_entity': 'Pods'}, {'source_entity': 'Authentication Plugins', 'description': 'authenticates users to access API Server', 'destination_entity': 'API Server'}, {'source_entity': 'Authorization Plugins', 'description': 'authorizes access to resources for users', 'destination_entity': 'API Server'}, {'source_entity': 'NamespaceLifecycle', 'description': 'manages the lifecycle of Namespaces', 'destination_entity': 'Namespaces'}, {'source_entity': 'Pods', 'description': 'runs containers and manages resources', 'destination_entity': 'API Server'}, {'source_entity': 'HTTP Request', 'description': 'makes requests to API Server', 'destination_entity': 'API Server'}, {'source_entity': 'HTTP Header', 'description': 'provides metadata for HTTP Requests', 'destination_entity': 'API Server'}, {'source_entity': 'User', 'description': 'interacts with API Server to access resources', 'destination_entity': 'API Server'}]","['[\n  {\n    ""source"": ""ServiceAccount"",\n    ""destination"": ""API Server"",\n    ""relation_description"": ""authenticates users to access"",\n    ""summary_er"": ""ServiceAccount authenticates users to access API Server, ensuring secure access control.""\n  }\n]', '[\n  {\n    ""source"": ""Client Certificate"",\n    ""destination"": ""API Server"",\n    ""relation_description"": ""verifies the identity of clients making requests"",\n    ""summary_er"": ""The Client Certificate verifies the identity of clients making requests to the API Server, ensuring secure access.""\n  }\n]', '[\n  {\n    ""source"": ""Admission Control Plugins"",\n    ""destination"": ""API Server"",\n    ""relation_description"": ""enforces policies on API Server"",\n    ""summary_er"": ""Admission Control Plugins enforces policy rules on API Server, ensuring secure and controlled access to cluster resources.""\n  },\n  {\n    ""source"": ""API Server"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""destinations for incoming requests"",\n    ""summary_er"": ""The API Server receives and processes incoming requests, directing them to the appropriate pod for execution or management.""\n  }\n]', '[\n  {\n    ""source"": ""ResourceQuota"",\n    ""destination"": ""Pods"",\n    ""relation_description"": ""limits the resources used by"",\n    ""summary_er"": ""ResourceQuota limits the resources used by Pods, ensuring they don\'t exceed allocated capacity.""\n  }\n]', '[\n  {\n    ""source"": ""Namespace"",\n    ""destination"": ""Pod"",\n    ""relation_description"": ""organizes and isolates resources for users"",\n    ""summary_er"": ""A Namespace provides a logical isolation of resources, allowing multiple users to share the same cluster without conflicts.""\n  }\n]', '[\n  {\n    ""source"": ""AlwaysPullImages"",\n    ""destination"": ""Pods"",\n    ""relation_description"": ""pulls images from registries before deploying Pods"",\n    ""summary_er"": ""AlwaysPullImages ensures that Pods are deployed with the latest image versions by pulling them from registries, preventing outdated or malicious images.""\n  }\n]', '[\n  {\n    ""source"": ""Authentication Plugins"",\n    ""destination"": ""API Server"",\n    ""relation_description"": ""authenticates users to access"",\n    ""summary_er"": ""Authenticates users to access API Server, ensuring secure access control.""\n  }\n]', '[\n  {\n    ""source"": ""Authorization Plugins"",\n    ""destination"": ""API Server"",\n    ""relation_description"": ""authorizes access to resources for users"",\n    ""summary_er"": ""Authorization plugins ensure secure access to API server resources by authenticating and authorizing user requests.""\n  }\n]', '[\n  {\n    ""source"": ""NamespaceLifecycle"",\n    ""destination"": ""Namespaces"",\n    ""relation_description"": ""manages the lifecycle of Namespaces"",\n    ""summary_er"": ""Namespace Lifecycle manages the creation, deletion, and scaling of Namespaces.""\n  },\n  {\n    ""source"": ""pod"",\n    ""destination"": ""Namespaces"",\n    ""relation_description"": ""contains"",\n    ""summary_er"": ""A pod contains one or more containers that share resources and namespaces.""\n  }\n]', '[\n  {\n    ""source"": ""Pods"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""runs containers and manages resources"",\n    ""summary_er"": ""Pods manage container execution, resource allocation, and lifecycle for a pod.""\n  },\n  {\n    ""source"": ""API Server"",\n    ""destination"": ""Pods"",\n    ""relation_description"": ""manages API requests and interactions"",\n    ""summary_er"": ""The API server handles incoming requests, interacts with pods, and manages cluster resources.""\n  }\n]', '[\n  {\n    ""source"": ""HTTP Request"",\n    ""destination"": ""API Server"",\n    ""relation_description"": ""makes requests to"",\n    ""summary_er"": ""HTTP Request sends requests to API Server for processing.""\n  },\n  {\n    ""source"": ""API Server"",\n    ""destination"": ""Pod"",\n    ""relation_description"": ""serves as"",\n    ""summary_er"": ""API Server serves as a server for the Pod, handling incoming requests.""\n  }\n]', '[\n  {\n    ""source"": ""HTTP Header"",\n    ""destination"": ""API Server"",\n    ""relation_description"": ""provides metadata for HTTP Requests"",\n    ""summary_er"": ""The HTTP header provides essential information to the API server, enabling it to process requests correctly and efficiently.""\n  }\n]', '[\n  {\n    ""source"": ""User"",\n    ""destination"": ""API Server"",\n    ""relation_description"": ""interacts with"",\n    ""summary_er"": ""The user interacts with the API server to access resources, enabling them to retrieve or modify data.""\n  },\n  {\n    ""source"": ""API Server"",\n    ""destination"": ""Pod"",\n    ""relation_description"": ""accesses"",\n    ""summary_er"": ""The API server accesses a pod to manage and interact with its resources, such as containers and volumes.""\n  }\n]']","The API server authenticates clients using authentication plugins, which extract client data from HTTP requests or certificates. Authorization plugins then determine if the authenticated user can perform requested actions on resources. Admission Control plugins validate and/or modify resource requests, modifying fields, overriding values, or rejecting requests. Examples of Admission Control plugins include AlwaysPullImages, ServiceAccount, NamespaceLifecycle, and ResourceQuota.","[{'highlight': 'The API server authenticates the client using one or more authentication plugins configured in the API server.'}, {'highlight': 'The API server uses authorization plugins to determine whether the authenticated user can perform the requested action on the requested resource.'}, {'highlight': 'Admission Control plugins validate and/or modify resources in the request, such as initializing missing fields or overriding default values.'}, {'highlight': 'Examples of Admission Control plugins include AlwaysPullImages, ServiceAccount, NamespaceLifecycle, and ResourceQuota.'}, {'highlight': 'Requests that only try to read data do not go through Admission Control.'}]"
261,350,0,[],"318
CHAPTER 11
Understanding Kubernetes internals
VALIDATING THE RESOURCE AND STORING IT PERSISTENTLY
After letting the request pass through all the Admission Control plugins, the API server
then validates the object, stores it in etcd, and returns a response to the client.
11.1.4 Understanding how the API server notifies clients of resource 
changes
The API server doesn’t do anything else except what we’ve discussed. For example, it
doesn’t create pods when you create a ReplicaSet resource and it doesn’t manage the
endpoints of a service. That’s what controllers in the Controller Manager do. 
 But the API server doesn’t even tell these controllers what to do. All it does is
enable those controllers and other components to observe changes to deployed
resources. A Control Plane component can request to be notified when a resource is
created, modified, or deleted. This enables the component to perform whatever task
it needs in response to a change of the cluster metadata.
 Clients watch for changes by opening an HTTP connection to the API server.
Through this connection, the client will then receive a stream of modifications to the
watched objects. Every time an object is updated, the server sends the new version of
the object to all connected clients watching the object. Figure 11.4 shows how clients
can watch for changes to pods and how a change to one of the pods is stored into etcd
and then relayed to all clients watching pods at that moment.
One of the API server’s clients is the kubectl tool, which also supports watching
resources. For example, when deploying a pod, you don’t need to constantly poll the list
of pods by repeatedly executing kubectl get pods. Instead, you can use the --watch
flag and be notified of each creation, modification, or deletion of a pod, as shown in
the following listing.
$ kubectl get pods --watch
NAME                    READY     STATUS              RESTARTS   AGE
Listing 11.6
Watching a pod being created and then deleted
Various
clients
kubectl
API server
1. GET /.../pods?watch=true
2. POST /.../pods/pod-xyz
5. Send updated object
to all watchers
3. Update object
in etcd
4. Modiﬁcation
notiﬁcation
etcd
Figure 11.4
When an object is updated, the API server sends the updated object to all interested 
watchers.
 
","[  Various\nclients              Col1              Col2 Col3
0             None  Various\nclients              None     
1             None              None  Various\nclients     ]","[{'entity': 'Admission Control plugins', 'description': 'Plugins that validate incoming requests before they are processed by the API server.', 'category': 'software'}, {'entity': 'API server', 'description': 'The component responsible for validating and storing resources persistently.', 'category': 'software'}, {'entity': 'etcd', 'description': 'A distributed key-value store used by the API server to store resources persistently.', 'category': 'database'}, {'entity': 'Controller Manager', 'description': 'A component responsible for managing controllers that observe changes to deployed resources.', 'category': 'software'}, {'entity': 'controllers', 'description': 'Components that perform tasks in response to changes of the cluster metadata.', 'category': 'software'}, {'entity': 'kubectl tool', 'description': 'A client used to interact with the API server and watch resources for changes.', 'category': 'software'}, {'entity': 'HTTP connection', 'description': 'The protocol used by clients to connect to the API server and receive notifications of resource changes.', 'category': 'network'}, {'entity': 'stream of modifications', 'description': 'A continuous flow of updates sent by the API server to connected clients watching resources.', 'category': 'process'}, {'entity': 'watched objects', 'description': 'Resources being observed by clients for changes, such as pods or services.', 'category': 'application'}, {'entity': '--watch flag', 'description': 'A command-line option used with kubectl to enable watching resources for changes.', 'category': 'software'}, {'entity': 'GET /.../pods?watch=true', 'description': 'An HTTP request used by clients to watch pods for changes.', 'category': 'command'}, {'entity': 'POST /.../pods/pod-xyz', 'description': 'An HTTP request used by clients to create a new pod resource.', 'category': 'command'}, {'entity': 'Send updated object to all watchers', 'description': 'The process by which the API server notifies connected clients of changes to watched resources.', 'category': 'process'}]","[{'source_entity': '""Controller Manager""', 'description': 'watches', 'destination_entity': '""watched objects""'}, {'source_entity': '""Controller Manager""', 'description': 'uses', 'destination_entity': '""--watch flag""'}, {'source_entity': '""Controller Manager""', 'description': 'communicates with', 'destination_entity': '""etcd""'}, {'source_entity': '""Controller Manager""', 'description': 'manages', 'destination_entity': '""Admission Control plugins""'}, {'source_entity': '""API server""', 'description': 'establishes', 'destination_entity': '""HTTP connection""'}, {'source_entity': '""kubectl tool""', 'description': 'uses to', 'destination_entity': '""API server""'}, {'source_entity': '""Controller Manager""', 'description': 'sends', 'destination_entity': '""Send updated object to all watchers""'}, {'source_entity': '""Controller Manager""', 'description': 'receives', 'destination_entity': '""stream of modifications""'}, {'source_entity': '""API server""', 'description': 'handles', 'destination_entity': '""GET /.../pods?watch=true""'}, {'source_entity': '""API server""', 'description': 'handles', 'destination_entity': '""POST /.../pods/pod-xyz""'}]","['[\n  {\n    ""source"": ""Controller Manager"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""watches"",\n    ""summary_er"": ""The Controller Manager continuously monitors and watches over pods, ensuring their proper functioning and management within the Kubernetes cluster.""\n  }\n]', '[\n  {\n    ""source"": ""Controller Manager"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""uses"",\n    ""summary_er"": ""The Controller Manager in Kubernetes utilizes pods to manage containerized applications, leveraging the \'--watch flag\' for real-time monitoring.""\n  }\n]', '[\n  {\n    ""source"": ""Controller Manager"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""communicates with"",\n    ""summary_er"": ""The Controller Manager communicates with pods to manage and orchestrate containerized applications.""\n  }\n]', '[\n  {\n    ""source"": ""Controller Manager"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""manages"",\n    ""summary_er"": ""The Controller Manager component manages and controls the lifecycle of pods in a Kubernetes cluster.""\n  },\n  {\n    ""source"": ""Admission Control plugins"",\n    ""destination"": """",\n    ""relation_description"": """",\n    ""summary_er"": """"\n  }\n]', '[\n  {\n    ""source"": ""API server"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""establishes"",\n    ""summary_er"": ""The API server establishes a connection to a pod, enabling communication and data exchange between them.""\n  },\n  {\n    ""source"": ""HTTP connection"",\n    ""destination"": ""pod"",\n    ""relation_description"": """",\n    ""summary_er"": """"\n  }\n]', '[\n  {\n    ""source"": ""kubectl tool"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""uses to"",\n    ""summary_er"": ""The kubectl tool utilizes pods for container orchestration and management.""\n  },\n  {\n    ""source"": ""API server"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""manages"",\n    ""summary_er"": ""The API server manages the lifecycle of pods, including creation, deletion, and scaling.""\n  }\n]', '[\n  {\n    ""source"": ""Controller Manager"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""sends"",\n    ""summary_er"": ""The Controller Manager sends updates to all pods, notifying them of changes.""\n  }\n]', '[\n  {\n    ""source"": ""Controller Manager"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""receives"",\n    ""summary_er"": ""The Controller Manager receives a stream of modifications from pods, enabling it to manage and coordinate their behavior.""\n  }\n]', '[\n  {\n    ""source"": ""API server"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""handles"",\n    ""summary_er"": ""The API server manages and handles interactions with pods, enabling communication between them.""\n  }\n]', '[\n  {\n    ""source"": ""API server"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""handles"",\n    ""summary_er"": ""The API server manages and handles interactions with a specific pod, ensuring its proper functioning within the Kubernetes cluster.""\n  }\n]']","The Kubernetes API server validates and stores objects in etcd, then notifies clients of resource changes by sending updates to watchers. Clients can watch for changes using an HTTP connection, receiving a stream of modifications to watched objects. The kubectl tool also supports watching resources, allowing users to be notified of creation, modification, or deletion events without needing to constantly poll lists of resources.","[{'highlight': 'The API server validates the object, stores it in etcd, and returns a response to the client after passing through Admission Control plugins.'}, {'highlight': 'The API server notifies clients of resource changes by sending a stream of modifications to watched objects.'}, {'highlight': 'Clients can watch for changes by opening an HTTP connection to the API server and receiving updates on creation, modification, or deletion of resources.'}, {'highlight': 'The kubectl tool supports watching resources using the --watch flag, notifying users of each creation, modification, or deletion of a pod.'}, {'highlight': 'When an object is updated, the API server sends the updated object to all connected clients watching the object.'}]"
262,351,0,[],"319
Understanding the architecture
kubia-159041347-14j3i   0/1       Pending             0          0s
kubia-159041347-14j3i   0/1       Pending             0          0s
kubia-159041347-14j3i   0/1       ContainerCreating   0          1s
kubia-159041347-14j3i   0/1       Running             0          3s
kubia-159041347-14j3i   1/1       Running             0          5s
kubia-159041347-14j3i   1/1       Terminating         0          9s
kubia-159041347-14j3i   0/1       Terminating         0          17s
kubia-159041347-14j3i   0/1       Terminating         0          17s
kubia-159041347-14j3i   0/1       Terminating         0          17s
You can even have kubectl print out the whole YAML on each watch event like this:
$ kubectl get pods -o yaml --watch
The watch mechanism is also used by the Scheduler, which is the next Control Plane
component you’re going to learn more about.
11.1.5 Understanding the Scheduler
You’ve already learned that you don’t usually specify which cluster node a pod should
run on. This is left to the Scheduler. From afar, the operation of the Scheduler looks
simple. All it does is wait for newly created pods through the API server’s watch mech-
anism and assign a node to each new pod that doesn’t already have the node set. 
 The Scheduler doesn’t instruct the selected node (or the Kubelet running on that
node) to run the pod. All the Scheduler does is update the pod definition through the
API server. The API server then notifies the Kubelet (again, through the watch mech-
anism described previously) that the pod has been scheduled. As soon as the Kubelet
on the target node sees the pod has been scheduled to its node, it creates and runs the
pod’s containers.
 Although a coarse-grained view of the scheduling process seems trivial, the actual
task of selecting the best node for the pod isn’t that simple. Sure, the simplest
Scheduler could pick a random node and not care about the pods already running on
that node. On the other side of the spectrum, the Scheduler could use advanced tech-
niques such as machine learning to anticipate what kind of pods are about to be
scheduled in the next minutes or hours and schedule pods to maximize future hard-
ware utilization without requiring any rescheduling of existing pods. Kubernetes’
default Scheduler falls somewhere in between. 
UNDERSTANDING THE DEFAULT SCHEDULING ALGORITHM
The selection of a node can be broken down into two parts, as shown in figure 11.5:
Filtering the list of all nodes to obtain a list of acceptable nodes the pod can be
scheduled to.
Prioritizing the acceptable nodes and choosing the best one. If multiple nodes
have the highest score, round-robin is used to ensure pods are deployed across
all of them evenly.
 
",[],"[{'entity': 'kubia-159041347-14j3i', 'description': 'pod name', 'category': 'container'}, {'entity': 'kubectl', 'description': 'command-line tool', 'category': 'software'}, {'entity': 'API server', 'description': 'component of the Control Plane', 'category': 'application'}, {'entity': 'Kubelet', 'description': 'component running on each node', 'category': 'process'}, {'entity': 'Scheduler', 'description': 'Control Plane component responsible for scheduling pods', 'category': 'application'}, {'entity': 'watch mechanism', 'description': 'API server feature used by the Scheduler and Kubelet', 'category': 'network'}, {'entity': 'pods', 'description': 'units of execution in Kubernetes', 'category': 'container'}, {'entity': 'nodes', 'description': 'physical or virtual machines running containers', 'category': 'hardware'}, {'entity': 'yaml', 'description': 'format for printing pod definitions', 'category': 'software'}, {'entity': 'kubectl get pods -o yaml --watch', 'description': 'command used to print pod definitions with watch mechanism', 'category': 'software'}, {'entity': 'round-robin', 'description': 'algorithm used to prioritize nodes when multiple have the highest score', 'category': 'process'}]","[{'source_entity': '""Kubelet""', 'description': 'monitors', 'destination_entity': '""pods""'}, {'source_entity': '""Scheduler""', 'description': 'allocates', 'destination_entity': '""nodes""'}, {'source_entity': '""kubectl""', 'description': 'gets', 'destination_entity': '""pods""'}, {'source_entity': '""kubectl""', 'description': 'watches', 'destination_entity': '""pods""'}, {'source_entity': '""Kubelet""', 'description': 'communicates', 'destination_entity': '""API server""'}, {'source_entity': '""Scheduler""', 'description': 'uses', 'destination_entity': '""round-robin""'}, {'source_entity': '""kubectl""', 'description': 'displays', 'destination_entity': '""pods""'}, {'source_entity': '""Kubelet""', 'description': 'manages', 'destination_entity': '""kubia-159041347-14j3i""'}]","['[\n  {\n    ""source"": ""Kubelet"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""monitors"",\n    ""summary_er"": ""The Kubelet continuously monitors the status of pods, ensuring they are running as expected and taking corrective action if necessary.""\n  }\n]', '[\n  {\n    ""source"": ""Scheduler"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""allocates"",\n    ""summary_er"": ""The Scheduler component in Kubernetes allocates resources to pods, ensuring efficient resource utilization and pod placement.""\n  }\n]', '[\n  {\n    ""source"": ""kubectl"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""gets"",\n    ""summary_er"": ""Kubernetes command-line tool retrieves information about a running pod.""\n  }\n]', '[\n  {\n    ""source"": ""kubectl"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""watches"",\n    ""summary_er"": ""Kubectl monitors and manages pods in a Kubernetes cluster.""\n  }\n]', '[\n  {\n    ""source"": ""Kubelet"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""communicates"",\n    ""summary_er"": ""The Kubelet communicates with pods to manage and monitor their lifecycle.""\n  }\n]', '[\n  {\n    ""source"": ""Scheduler"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""uses"",\n    ""summary_er"": ""The Scheduler component assigns incoming requests to a pod using a round-robin scheduling strategy.""\n  }\n]', '[\n  {\n    ""source"": ""kubectl"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""displays"",\n    ""summary_er"": ""Kubectl command displays information about a specific pod in a Kubernetes cluster.""\n  }\n]', '[\n  {\n    ""source"": ""Kubelet"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""manages"",\n    ""summary_er"": ""The Kubelet manages a pod, ensuring its lifecycle and resource allocation.""\n  }\n]']","The document discusses Kubernetes' scheduling process, where the Scheduler waits for newly created pods through the API server's watch mechanism and assigns a node to each new pod. The Scheduler updates the pod definition, and the API server notifies the Kubelet to create and run the pod's containers. The default Scheduler uses an algorithm that filters nodes to obtain acceptable ones and prioritizes them to choose the best one, with round-robin used if multiple nodes have the highest score.","[{'highlight': ""The Scheduler doesn't instruct the selected node (or the Kubelet running on that node) to run the pod. All it does is update the pod definition through the API server.""}, {'highlight': ""The actual task of selecting the best node for the pod isn't that simple. The Scheduler could use advanced techniques such as machine learning to anticipate what kind of pods are about to be scheduled in the next minutes or hours and schedule pods to maximize future hardware utilization without requiring any rescheduling of existing pods.""}, {'highlight': 'The selection of a node can be broken down into two parts: Filtering the list of all nodes to obtain a list of acceptable nodes the pod can be scheduled to, and Prioritizing the acceptable nodes and choosing the best one.'}, {'highlight': ""Kubernetes' default Scheduler falls somewhere in between the simplest Scheduler that picks a random node and an advanced Scheduler that uses machine learning techniques.""}, {'highlight': 'If multiple nodes have the highest score, round-robin is used to ensure pods are deployed across all of them evenly.'}]"
263,352,1,[],"320
CHAPTER 11
Understanding Kubernetes internals
FINDING ACCEPTABLE NODES
To determine which nodes are acceptable for the pod, the Scheduler passes each
node through a list of configured predicate functions. These check various things
such as
Can the node fulfill the pod’s requests for hardware resources? You’ll learn how
to specify them in chapter 14.
Is the node running out of resources (is it reporting a memory or a disk pres-
sure condition)? 
If the pod requests to be scheduled to a specific node (by name), is this the node?
Does the node have a label that matches the node selector in the pod specifica-
tion (if one is defined)?
If the pod requests to be bound to a specific host port (discussed in chapter 13),
is that port already taken on this node or not? 
If the pod requests a certain type of volume, can this volume be mounted for
this pod on this node, or is another pod on the node already using the same
volume?
Does the pod tolerate the taints of the node? Taints and tolerations are explained
in chapter 16.
Does the pod specify node and/or pod affinity or anti-affinity rules? If yes,
would scheduling the pod to this node break those rules? This is also explained
in chapter 16.
All these checks must pass for the node to be eligible to host the pod. After perform-
ing these checks on every node, the Scheduler ends up with a subset of the nodes. Any
of these nodes could run the pod, because they have enough available resources for
the pod and conform to all requirements you’ve specified in the pod definition.
SELECTING THE BEST NODE FOR THE POD
Even though all these nodes are acceptable and can run the pod, several may be a
better choice than others. Suppose you have a two-node cluster. Both nodes are eli-
gible, but one is already running 10 pods, while the other, for whatever reason, isn’t
running any pods right now. It’s obvious the Scheduler should favor the second
node in this case. 
Node 1
Node 2
Node 3
Node 4
Node 5
...
Find acceptable
nodes
Node 1
Node 2
Node 3
Node 4
Node 5
...
Prioritize nodes
and select the
top one
Node 3
Node 1
Node 4
Figure 11.5
The Scheduler finds acceptable nodes for a pod and then selects the best node 
for the pod.
 
",[],"[{'entity': 'Kubernetes', 'description': 'Container orchestration system', 'category': 'software'}, {'entity': 'Scheduler', 'description': 'Component responsible for scheduling pods to nodes', 'category': 'software'}, {'entity': 'Pod', 'description': 'Lightweight and portable container', 'category': 'software'}, {'entity': 'Node', 'description': 'Physical or virtual machine running the Kubernetes cluster', 'category': 'hardware'}, {'entity': 'Predicate functions', 'description': 'Functions used to check node eligibility for pod scheduling', 'category': 'software'}, {'entity': 'Hardware resources', 'description': 'Resources such as CPU, memory, and disk space required by a pod', 'category': 'hardware'}, {'entity': 'Memory pressure condition', 'description': 'Condition where a node is running low on memory', 'category': 'hardware'}, {'entity': 'Disk pressure condition', 'description': 'Condition where a node is running low on disk space', 'category': 'hardware'}, {'entity': 'Node selector', 'description': 'Label used to select specific nodes for pod scheduling', 'category': 'software'}, {'entity': 'Host port', 'description': 'Port used by a pod to communicate with the host machine', 'category': 'network'}, {'entity': 'Volume', 'description': 'Persistent storage used by a pod', 'category': 'storage'}, {'entity': 'Taints and tolerations', 'description': 'Mechanism for node affinity and anti-affinity rules', 'category': 'software'}, {'entity': 'Affinity or anti-affinity rules', 'description': 'Rules used to select specific nodes for pod scheduling', 'category': 'software'}]","[{'source_entity': 'Scheduler', 'description': 'allocates resources to', 'destination_entity': 'Pod'}, {'source_entity': 'Node selector', 'description': 'selects nodes based on', 'destination_entity': 'Hardware resources'}, {'source_entity': 'Predicate functions', 'description': 'evaluates conditions for', 'destination_entity': 'Disk pressure condition'}, {'source_entity': 'Node selector', 'description': 'applies to', 'destination_entity': 'Pod'}, {'source_entity': 'Taints and tolerations', 'description': 'manages', 'destination_entity': 'Node'}, {'source_entity': 'Affinity or anti-affinity rules', 'description': 'defines relationships between', 'destination_entity': 'Pod'}, {'source_entity': 'Host port', 'description': 'exposes to', 'destination_entity': 'Pod'}, {'source_entity': 'Volume', 'description': 'provides to', 'destination_entity': 'Pod'}, {'source_entity': 'Memory pressure condition', 'description': 'detects and responds to', 'destination_entity': 'Node'}]","['[\n  {\n    ""source"": ""Scheduler"",\n    ""destination"": ""Pod"",\n    ""relation_description"": ""allocates resources to"",\n    ""summary_er"": ""The Scheduler allocates resources to a Pod, ensuring efficient resource utilization and optimal performance.""\n  }\n]', '[\n  {\n    ""source"": ""Node selector"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""selects nodes based on hardware resources"",\n    ""summary_er"": ""The Node Selector feature in Kubernetes allows users to specify which nodes a pod can be scheduled on, based on hardware resource requirements such as CPU and memory.""\n  }\n]', '[\n  {\n    ""source"": ""Predicate functions"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""evaluates conditions for"",\n    ""summary_er"": ""Predicate functions evaluate conditions to determine disk pressure on a pod.""\n  },\n  {\n    ""source"": ""conditions"",\n    ""destination"": ""Disk pressure condition"",\n    ""relation_description"": ""evaluated by"",\n    ""summary_er"": ""Conditions are evaluated to determine the Disk pressure condition.""\n  }\n]', '[\n  {\n    ""source"": ""Node selector"",\n    ""destination"": ""Pod"",\n    ""relation_description"": ""applies to"",\n    ""summary_er"": ""The Node selector is used to filter pods based on node attributes, ensuring that pods are scheduled on specific nodes.""\n  }\n]', '[\n  {\n    ""source"": ""Taints and tolerations"",\n    ""destination"": ""Pod"",\n    ""relation_description"": ""manages"",\n    ""summary_er"": ""Taints and tolerations manage pods by assigning labels to nodes, allowing pods to be scheduled on specific nodes.""\n  }\n]', '[\n  {\n    ""source"": ""Affinity or anti-affinity rules"",\n    ""destination"": ""Pod"",\n    ""relation_description"": ""defines relationships between"",\n    ""summary_er"": ""Establishes affinity or anti-affinity rules between pods, defining their relationships and interactions.""\n  },\n  {\n    ""source"": ""and"",\n    ""destination"": ""the destination pod"",\n    ""relation_description"": """",\n    ""summary_er"": ""Refers to the target pod that is being related to through an affinity or anti-affinity rule.""\n  }\n]', '[\n  {\n    ""source"": ""Host Port"",\n    ""destination"": ""Pod"",\n    ""relation_description"": ""exposes to"",\n    ""summary_er"": ""A host port allows a container within a pod to expose its service to the outside world, making it accessible from the host machine.""\n  }\n]', '[\n  {\n    ""source"": ""Volume"",\n    ""destination"": ""Pod"",\n    ""relation_description"": ""provides to"",\n    ""summary_er"": ""A Volume provides storage to a Pod, allowing it to access and write data.""\n  }\n]', '[\n  {\n    ""source"": ""Memory pressure condition"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""detects and responds to"",\n    ""summary_er"": ""The Memory pressure condition detects and responds to changes in a pod\'s memory usage, ensuring optimal performance.""\n  },\n  {\n    ""source"": ""pod"",\n    ""destination"": ""Node"",\n    ""relation_description"": ""resides on"",\n    ""summary_er"": ""A pod resides on a Node, utilizing its resources for execution and management.""\n  }\n]']","To determine which nodes are acceptable for a pod, Kubernetes Scheduler passes each node through a list of configured predicate functions that check things such as hardware resource availability, memory or disk pressure conditions, and volume usage. After passing all checks, the Scheduler ends up with a subset of eligible nodes from which it selects the best one based on factors like available resources, pod requirements, and affinity rules.","[{'highlight': 'To determine which nodes are acceptable for the pod, the Scheduler passes each node through a list of configured predicate functions.'}, {'highlight': 'All these checks must pass for the node to be eligible to host the pod.'}, {'highlight': 'Even though all these nodes are acceptable and can run the pod, several may be a better choice than others.'}, {'highlight': 'The Scheduler should favor the node that is not running any pods over the one that is already running 10 pods.'}, {'highlight': 'The Scheduler finds acceptable nodes for a pod and then selects the best node for the pod.'}]"
264,353,0,[],"321
Understanding the architecture
 Or is it? If these two nodes are provided by the cloud infrastructure, it may be bet-
ter to schedule the pod to the first node and relinquish the second node back to the
cloud provider to save money. 
ADVANCED SCHEDULING OF PODS
Consider another example. Imagine having multiple replicas of a pod. Ideally, you’d
want them spread across as many nodes as possible instead of having them all sched-
uled to a single one. Failure of that node would cause the service backed by those
pods to become unavailable. But if the pods were spread across different nodes, a sin-
gle node failure would barely leave a dent in the service’s capacity. 
 Pods belonging to the same Service or ReplicaSet are spread across multiple nodes
by default. It’s not guaranteed that this is always the case. But you can force pods to be
spread around the cluster or kept close together by defining pod affinity and anti-
affinity rules, which are explained in chapter 16. 
 Even these two simple cases show how complex scheduling can be, because it
depends on a multitude of factors. Because of this, the Scheduler can either be config-
ured to suit your specific needs or infrastructure specifics, or it can even be replaced
with a custom implementation altogether. You could also run a Kubernetes cluster
without a Scheduler, but then you’d have to perform the scheduling manually.
USING MULTIPLE SCHEDULERS
Instead of running a single Scheduler in the cluster, you can run multiple Schedulers.
Then, for each pod, you specify the Scheduler that should schedule this particular
pod by setting the schedulerName property in the pod spec.
 Pods without this property set are scheduled using the default Scheduler, and so
are pods with schedulerName set to default-scheduler. All other pods are ignored by
the default Scheduler, so they need to be scheduled either manually or by another
Scheduler watching for such pods. 
 You can implement your own Schedulers and deploy them in the cluster, or you
can deploy an additional instance of Kubernetes’ Scheduler with different configura-
tion options.
11.1.6 Introducing the controllers running in the Controller Manager
As previously mentioned, the API server doesn’t do anything except store resources in
etcd and notify clients about the change. The Scheduler only assigns a node to the
pod, so you need other active components to make sure the actual state of the system
converges toward the desired state, as specified in the resources deployed through the
API server. This work is done by controllers running inside the Controller Manager. 
 The single Controller Manager process currently combines a multitude of control-
lers performing various reconciliation tasks. Eventually those controllers will be split
up into separate processes, enabling you to replace each one with a custom imple-
mentation if necessary. The list of these controllers includes the
Replication Manager (a controller for ReplicationController resources)
ReplicaSet, DaemonSet, and Job controllers
 
",[],"[{'entity': 'Kubernetes', 'description': 'Container orchestration system', 'category': 'software'}, {'entity': 'Pod', 'description': 'Lightweight and portable container', 'category': 'container'}, {'entity': 'Node', 'description': 'Physical or virtual machine running Kubernetes', 'category': 'hardware'}, {'entity': 'Cloud provider', 'description': 'Company providing cloud infrastructure services', 'category': 'software'}, {'entity': 'ReplicaSet', 'description': 'Controller for managing multiple replicas of a pod', 'category': 'controller'}, {'entity': 'DaemonSet', 'description': 'Controller for deploying one or more copies of a pod on each node in the cluster', 'category': 'controller'}, {'entity': 'Job', 'description': 'Controller for running a batch job', 'category': 'controller'}, {'entity': 'Service', 'description': 'Abstract interface to access a group of pods', 'category': 'application'}, {'entity': 'Scheduler', 'description': 'Component responsible for scheduling pods on nodes', 'category': 'component'}, {'entity': 'Controller Manager', 'description': 'Process running multiple controllers', 'category': 'process'}, {'entity': 'ReplicationManager', 'description': 'Controller for ReplicationController resources', 'category': 'controller'}, {'entity': 'API server', 'description': 'Component responsible for storing resources in etcd and notifying clients about changes', 'category': 'component'}, {'entity': 'etcd', 'description': 'Distributed key-value store used by Kubernetes', 'category': 'database'}]","[{'source_entity': '""Job""', 'description': 'is managed by', 'destination_entity': '""Controller Manager""'}, {'source_entity': '""Node""', 'description': 'hosts', 'destination_entity': '""Pod""'}, {'source_entity': '""DaemonSet""', 'description': 'deploys', 'destination_entity': '""Pod""'}, {'source_entity': '""Service""', 'description': 'exposes', 'destination_entity': '""Pod""'}, {'source_entity': '""Scheduler""', 'description': 'allocates', 'destination_entity': '""Node""'}, {'source_entity': '""Controller Manager""', 'description': 'manages', 'destination_entity': '""ReplicaSet""'}, {'source_entity': '""etcd""', 'description': 'stores', 'destination_entity': '""cluster state""'}, {'source_entity': '""Cloud provider""', 'description': 'provides', 'destination_entity': '""infrastructure resources""'}, {'source_entity': '""Kubernetes""', 'description': 'uses', 'destination_entity': '""etcd""'}, {'source_entity': '""ReplicaSet""', 'description': 'is managed by', 'destination_entity': '""Controller Manager""'}, {'source_entity': '""ReplicationManager""', 'description': 'manages', 'destination_entity': '""Pod""'}, {'source_entity': '""API server""', 'description': 'exposes', 'destination_entity': '""Kubernetes API""'}]","['[\n  {\n    ""source"": ""Job"",\n    ""destination"": ""Controller Manager"",\n    ""relation_description"": ""is managed by"",\n    ""summary_er"": ""A Job in Kubernetes is managed by a Controller Manager, which is responsible for scheduling and executing pods based on job specifications.""\n  }\n]', '[\n  {\n    ""source"": ""Node"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""hosts"",\n    ""summary_er"": ""A node in a Kubernetes cluster hosts one or more pods, providing them with resources and infrastructure.""\n  }\n]', '[{\n  ""source"": ""DaemonSet"",\n  ""destination"": ""Pod"",\n  ""relation_description"": ""deploys"",\n  ""summary_er"": ""A DaemonSet ensures a specified Pod template is deployed to every node in a cluster, providing a consistent and reliable service.""\n}]', '[\n  {\n    ""source"": ""Service"",\n    ""destination"": ""Pod"",\n    ""relation_description"": ""exposes"",\n    ""summary_er"": ""A Service in Kubernetes exposes a Pod\'s port to the outside world, allowing external traffic to reach the Pod.""\n  }\n]', '[\n  {\n    ""source"": ""Scheduler"",\n    ""destination"": ""Pod"",\n    ""relation_description"": ""allocates"",\n    ""summary_er"": ""The Scheduler component in Kubernetes allocates resources to Pods, ensuring efficient resource utilization and optimal performance.""\n  }\n]', '[\n  {\n    ""source"": ""Controller Manager"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""manages"",\n    ""summary_er"": ""The Controller Manager is responsible for managing and scheduling pods within a Kubernetes cluster.""\n  },\n  {\n    ""source"": ""ReplicaSet"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""manages"",\n    ""summary_er"": ""A ReplicaSet ensures that a specified number of pod replicas are running at any given time, providing high availability for applications.""\n  }\n]', '[\n  {\n    ""source"": ""etcd"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""stores"",\n    ""summary_er"": ""Etcd stores cluster state in a pod, ensuring data consistency and availability across the Kubernetes cluster.""\n  }\n]', '[\n  {\n    ""source"": ""Cloud provider"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""provides"",\n    ""summary_er"": ""A cloud provider offers infrastructure resources to run a pod, enabling scalable and on-demand computing.""\n  }\n]', '[\n  {\n    ""source"": ""Kubernetes"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""uses"",\n    ""summary_er"": ""Kubernetes manages and orchestrates containerized applications, utilizing pods as the basic execution unit.""\n  }\n]', '[\n  {\n    ""source"": ""ReplicaSet"",\n    ""destination"": ""Pod"",\n    ""relation_description"": ""is managed by"",\n    ""summary_er"": ""A ReplicaSet is responsible for managing and scaling a set of identical Pods in a Kubernetes cluster.""\n  },\n  {\n    ""source"": ""Controller Manager"",\n    ""destination"": ""ReplicaSet"",\n    ""relation_description"": ""manages"",\n    ""summary_er"": ""The Controller Manager component in Kubernetes is responsible for creating, updating, and deleting ReplicaSets based on user-defined configurations.""\n  }\n]', '[\n  {\n    ""source"": ""ReplicationManager"",\n    ""destination"": ""Pod"",\n    ""relation_description"": ""manages"",\n    ""summary_er"": ""The ReplicationManager is responsible for managing Pods, ensuring they are running and scaled as needed.""\n  }\n]', '[\n  {\n    ""source"": ""API server"",\n    ""destination"": ""Kubernetes API"",\n    ""relation_description"": ""exposes"",\n    ""summary_er"": ""The Kubernetes API server exposes its functionality to clients, providing a interface for managing cluster resources.""\n  }\n]']","The Kubernetes Scheduler can be configured to suit specific needs or infrastructure specifics, or even replaced with a custom implementation. Multiple Schedulers can be run in the cluster, and pods can be scheduled using a specified Scheduler by setting the schedulerName property. The Controller Manager also runs controllers that make sure the actual state of the system converges toward the desired state, as specified in resources deployed through the API server, such as ReplicationController, ReplicaSet, DaemonSet, and Job controllers.",[{'highlight': 'Pods belonging to the same Service or ReplicaSet are spread across multiple nodes by default.'}]
265,354,0,[],"322
CHAPTER 11
Understanding Kubernetes internals
Deployment controller
StatefulSet controller
Node controller
Service controller
Endpoints controller
Namespace controller
PersistentVolume controller
Others
What each of these controllers does should be evident from its name. From the list,
you can tell there’s a controller for almost every resource you can create. Resources
are descriptions of what should be running in the cluster, whereas the controllers are
the active Kubernetes components that perform actual work as a result of the deployed
resources.
UNDERSTANDING WHAT CONTROLLERS DO AND HOW THEY DO IT
Controllers do many different things, but they all watch the API server for changes to
resources (Deployments, Services, and so on) and perform operations for each change,
whether it’s a creation of a new object or an update or deletion of an existing object.
Most of the time, these operations include creating other resources or updating the
watched resources themselves (to update the object’s status, for example).
 In general, controllers run a reconciliation loop, which reconciles the actual state
with the desired state (specified in the resource’s spec section) and writes the new
actual state to the resource’s status section. Controllers use the watch mechanism to
be notified of changes, but because using watches doesn’t guarantee the controller
won’t miss an event, they also perform a re-list operation periodically to make sure
they haven’t missed anything.
 Controllers never talk to each other directly. They don’t even know any other con-
trollers exist. Each controller connects to the API server and, through the watch
mechanism described in section 11.1.3, asks to be notified when a change occurs in
the list of resources of any type the controller is responsible for. 
 We’ll briefly look at what each of the controllers does, but if you’d like an in-depth
view of what they do, I suggest you look at their source code directly. The sidebar
explains how to get started.
A few pointers on exploring the controllers’ source code
If you’re interested in seeing exactly how these controllers operate, I strongly encour-
age you to browse through their source code. To make it easier, here are a few tips:
The source code for the controllers is available at https:/
/github.com/kubernetes/
kubernetes/blob/master/pkg/controller.
Each controller usually has a constructor in which it creates an Informer, which is
basically a listener that gets called every time an API object gets updated. Usually,
 
",[],"[{'entity': 'Deployment controller', 'description': 'Kubernetes component responsible for managing Deployments', 'category': 'software'}, {'entity': 'StatefulSet controller', 'description': 'Kubernetes component responsible for managing StatefulSets', 'category': 'software'}, {'entity': 'Node controller', 'description': 'Kubernetes component responsible for managing Nodes', 'category': 'software'}, {'entity': 'Service controller', 'description': 'Kubernetes component responsible for managing Services', 'category': 'software'}, {'entity': 'Endpoints controller', 'description': 'Kubernetes component responsible for managing Endpoints', 'category': 'software'}, {'entity': 'Namespace controller', 'description': 'Kubernetes component responsible for managing Namespaces', 'category': 'software'}, {'entity': 'PersistentVolume controller', 'description': 'Kubernetes component responsible for managing Persistent Volumes', 'category': 'software'}, {'entity': 'API server', 'description': 'Kubernetes component responsible for serving the Kubernetes API', 'category': 'software'}, {'entity': 'Watch mechanism', 'description': 'Mechanism used by controllers to be notified of changes to resources', 'category': 'process'}, {'entity': 'Re-list operation', 'description': ""Periodic operation performed by controllers to ensure they haven't missed any events"", 'category': 'process'}, {'entity': 'Informer', 'description': 'Listener that gets called every time an API object gets updated', 'category': 'software'}, {'entity': 'Constructor', 'description': 'Method used by controllers to create an Informer and initialize themselves', 'category': 'software'}]","[{'source_entity': 'StatefulSet controller', 'description': 'manages', 'destination_entity': 'PersistentVolume'}, {'source_entity': 'PersistentVolume controller', 'description': 'monitors', 'destination_entity': 'Endpoints'}, {'source_entity': 'Endpoints controller', 'description': 'coordinates', 'destination_entity': 'Service'}, {'source_entity': 'Service controller', 'description': 'regulates', 'destination_entity': 'Re-list operation'}, {'source_entity': 'Constructor', 'description': 'constructs', 'destination_entity': 'Deployment controller'}, {'source_entity': 'Deployment controller', 'description': 'manages', 'destination_entity': 'Informer'}, {'source_entity': 'Informer', 'description': 'informs', 'destination_entity': 'Namespace controller'}, {'source_entity': 'Namespace controller', 'description': 'controls', 'destination_entity': 'Watch mechanism'}, {'source_entity': 'Watch mechanism', 'description': 'monitors', 'destination_entity': 'Node controller'}, {'source_entity': 'Node controller', 'description': 'manages', 'destination_entity': 'API server'}]","['[\n  {\n    ""source"": ""StatefulSet controller"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""manages"",\n    ""summary_er"": ""The StatefulSet controller is responsible for managing the lifecycle of a pod, ensuring it\'s created and updated as needed.""\n  },\n  {\n    ""source"": ""PersistentVolume"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""provides storage"",\n    ""summary_er"": ""A PersistentVolume provides persistent storage to a pod, allowing data to be stored and retrieved across restarts.""\n  }\n]', '[\n  {\n    ""source"": ""PersistentVolume controller"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""monitors"",\n    ""summary_er"": ""The PersistentVolume controller continuously monitors pods to ensure their storage needs are met.""\n  }\n]', '[\n  {\n    ""source"": ""Endpoints controller"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""coordinates"",\n    ""summary_er"": ""The Endpoints controller is responsible for managing the IP addresses of pods, providing a way to access them through DNS names or IP addresses.""\n  }\n]', '[\n  {\n    ""source"": ""Service controller"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""regulates"",\n    ""summary_er"": ""The service controller manages and regulates the lifecycle of pods, ensuring they are created, updated, or deleted as needed.""\n  }\n]', '[\n  {\n    ""source"": ""Constructor"",\n    ""destination"": ""Deployment controller"",\n    ""relation_description"": ""constructs"",\n    ""summary_er"": ""The constructor creates a deployment controller, which manages the lifecycle of a pod.""\n  }\n]', '[\n  {\n    ""source"": ""Deployment controller"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""manages"",\n    ""summary_er"": ""The Deployment controller is responsible for managing the lifecycle of a pod, ensuring it meets the desired state and configuration.""\n  }\n]', '[\n  {\n    ""source"": ""Informer"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""informs"",\n    ""summary_er"": ""The Informer component in Kubernetes notifies pods about changes to their namespace.""\n  }\n]', '[\n  {\n    ""source"": ""Namespace controller"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""controls"",\n    ""summary_er"": ""The namespace controller manages and regulates access to pods within a Kubernetes cluster, ensuring that resources are properly allocated and utilized.""\n  }\n]', '[\n  {\n    ""source"": ""Watch mechanism"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""monitors"",\n    ""summary_er"": ""The Watch mechanism continuously monitors the pod\'s status, ensuring it remains operational and responsive.""\n  }\n]', '[\n  {\n    ""source"": ""Node controller"",\n    ""destination"": ""Pod"",\n    ""relation_description"": ""manages"",\n    ""summary_er"": ""The Node controller manages a Pod, overseeing its lifecycle and ensuring it runs smoothly within the Kubernetes cluster.""\n  }\n]']","Kubernetes controllers are active components that perform work as a result of deployed resources. They watch the API server for changes and perform operations such as creation, update or deletion of resources. Controllers run a reconciliation loop to reconcile actual state with desired state and use the watch mechanism to be notified of changes, also performing periodic re-list operations to ensure they haven't missed anything. Each controller connects to the API server and asks to be notified when a change occurs in its responsible resource list.","[{'highlight': ""Kubernetes controllers run a reconciliation loop to reconcile the actual state with the desired state specified in the resource's spec section.""}]"
266,355,0,[],"323
Understanding the architecture
THE REPLICATION MANAGER
The controller that makes ReplicationController resources come to life is called the
Replication Manager. We talked about how ReplicationControllers work in chapter 4.
It’s not the ReplicationControllers that do the actual work, but the Replication Man-
ager. Let’s quickly review what the controller does, because this will help you under-
stand the rest of the controllers.
 In chapter 4, we said that the operation of a ReplicationController could be
thought of as an infinite loop, where in each iteration, the controller finds the num-
ber of pods matching its pod selector and compares the number to the desired replica
count. 
 Now that you know how the API server can notify clients through the watch
mechanism, it’s clear that the controller doesn’t poll the pods in every iteration, but
is instead notified by the watch mechanism of each change that may affect the
desired replica count or the number of matched pods (see figure 11.6). Any such
changes trigger the controller to recheck the desired vs. actual replica count and act
accordingly.
 You already know that when too few pod instances are running, the Replication-
Controller runs additional instances. But it doesn’t actually run them itself. It creates
an Informer listens for changes to a specific type of resource. Looking at the con-
structor will show you which resources the controller is watching.
Next, go look for the worker() method. In it, you’ll find the method that gets invoked
each time the controller needs to do something. The actual function is often stored
in a field called syncHandler or something similar. This field is also initialized in the
constructor, so that’s where you’ll find the name of the function that gets called. That
function is the place where all the magic happens.
Controller Manager
Watches
Creates and
deletes
Replication
Manager
API server
ReplicationController
resources
Pod resources
Other resources
Figure 11.6
The Replication Manager watches for changes to API 
objects.
 
","[  Controller Manager\nReplication\nManager               Watches  \
0                                     None  Creates and\ndeletes   

  API server\nReplicationController\nresources\nPod resources\nOther resources  
0                                               None                            ]","[{'entity': 'Replication Manager', 'description': 'controller that makes ReplicationController resources come to life', 'category': 'software'}, {'entity': 'ReplicationController', 'description': 'resource that manages the number of replicas of a pod', 'category': 'software'}, {'entity': 'API server', 'description': 'server that provides an interface for clients to interact with the cluster', 'category': 'software'}, {'entity': 'Pod resources', 'description': 'resources that represent running containers in the cluster', 'category': 'software'}, {'entity': 'Informer', 'description': 'component that listens for changes to a specific type of resource', 'category': 'software'}, {'entity': 'syncHandler', 'description': 'function that gets invoked each time the controller needs to do something', 'category': 'software'}, {'entity': 'ReplicationController resources', 'description': 'resources that represent the desired replica count and actual replica count', 'category': 'software'}, {'entity': 'Worker() method', 'description': 'method that gets invoked each time the controller needs to do something', 'category': 'software'}, {'entity': 'API objects', 'description': 'objects that are watched by the Replication Manager', 'category': 'software'}]","[{'source_entity': 'Informer', 'description': 'watches for changes to ReplicationController resources', 'destination_entity': 'ReplicationController resources'}, {'source_entity': 'Worker() method', 'description': 'syncs with API server to update Pod resources', 'destination_entity': 'API server'}, {'source_entity': 'API objects', 'description': 'are managed by Replication Manager', 'destination_entity': 'Replication Manager'}, {'source_entity': 'syncHandler', 'description': 'handles synchronization of Pod resources with API server', 'destination_entity': 'API server'}, {'source_entity': 'ReplicationController', 'description': 'is a type of API object managed by Replication Manager', 'destination_entity': 'Replication Manager'}, {'source_entity': 'ReplicationController resources', 'description': 'are watched by Informer for changes', 'destination_entity': 'Informer'}, {'source_entity': 'Pod resources', 'description': 'are synced with API server using Worker() method', 'destination_entity': 'API server'}]","['[\n  {\n    ""source"": ""Informer"",\n    ""destination"": ""ReplicationController resources"",\n    ""relation_description"": ""watches for changes"",\n    ""summary_er"": ""Informer monitors ReplicationController resources for updates.""\n  },\n  {\n    ""source"": ""Informer"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""watches for changes to ReplicationController resources"",\n    ""summary_er"": ""Informer watches pod for changes triggered by ReplicationController updates.""\n  }\n]', '[\n  {\n    ""source"": ""Worker() method"",\n    ""destination"": ""API server"",\n    ""relation_description"": ""syncs with API server to update Pod resources"",\n    ""summary_er"": ""The Worker() method synchronizes with the API server to update pod resources, ensuring accurate and up-to-date information.""\n  }\n]', '[\n  {\n    ""source"": ""API objects"",\n    ""destination"": ""Replication Manager"",\n    ""relation_description"": ""are managed by"",\n    ""summary_er"": ""API objects are managed by Replication Manager to ensure efficient scaling and deployment of applications.""\n  },\n  {\n    ""source"": ""Replication Manager"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""Replication Manager"",\n    ""summary_er"": ""Replication Manager is responsible for managing pods, ensuring they are running efficiently and effectively.""\n  }\n]', '[\n  {\n    ""source"": ""syncHandler"",\n    ""destination"": ""Pod"",\n    ""relation_description"": ""handles synchronization of resources"",\n    ""summary_er"": ""Syncs Pod resources with API server to ensure consistency.""\n  },\n  {\n    ""source"": ""API server"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""managed by"",\n    ""summary_er"": ""Manages pod resources, ensuring data integrity and availability.""\n  }\n]', '[\n  {\n    ""source"": ""ReplicationController"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""is a type of API object managed by"",\n    ""summary_er"": ""A ReplicationController is a configuration object that manages the replication of pods, ensuring a specified number of replicas are running at any given time.""\n  },\n  {\n    ""source"": ""ReplicationController"",\n    ""destination"": ""Replication Manager"",\n    ""relation_description"": ""is managed by"",\n    ""summary_er"": ""A ReplicationController is configured and managed by the Replication Manager, which ensures the desired number of replicas are running.""\n  }\n]', '[\n  {\n    ""source"": ""ReplicationController"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""are watched by Informer for changes"",\n    ""summary_er"": ""ReplicationController resources are monitored by Informer for any changes, triggering updates to corresponding pod instances.""\n  }\n]', '[\n  {\n    ""source"": ""Pod resources"",\n    ""destination"": ""API server"",\n    ""relation_description"": ""synced with"",\n    ""summary_er"": ""Pod resources are synced with API server using Worker() method to ensure efficient resource utilization.""\n  }\n]']","The Replication Manager is a controller that makes ReplicationController resources come to life, and it's not the actual work but the manager that does it. It uses the watch mechanism to be notified of changes affecting the desired replica count or number of matched pods, triggering rechecks and actions accordingly. The worker() method contains the magic where all the actual function calls are made.","[{'highlight': 'The controller that makes ReplicationController resources come to life is called the Replication Manager.'}, {'highlight': ""The Replication Manager doesn't poll the pods in every iteration, but is instead notified by the watch mechanism of each change that may affect the desired replica count or the number of matched pods.""}, {'highlight': 'The Replication-Controller runs additional instances when too few pod instances are running, and it creates an Informer to listen for changes to a specific type of resource.'}, {'highlight': 'The actual function invoked by the controller is stored in a field called syncHandler or something similar, which gets initialized in the constructor.'}, {'highlight': 'The Replication Manager watches for changes to API objects, including ReplicationController and Pod resources.'}]"
267,356,0,[],"324
CHAPTER 11
Understanding Kubernetes internals
new Pod manifests, posts them to the API server, and lets the Scheduler and the
Kubelet do their job of scheduling and running the pod.
 The Replication Manager performs its work by manipulating Pod API objects
through the API server. This is how all controllers operate.
THE REPLICASET, THE DAEMONSET, AND THE JOB CONTROLLERS
The ReplicaSet controller does almost the same thing as the Replication Manager
described previously, so we don’t have much to add here. The DaemonSet and Job
controllers are similar. They create Pod resources from the pod template defined in
their respective resources. Like the Replication Manager, these controllers don’t run
the pods, but post Pod definitions to the API server, letting the Kubelet create their
containers and run them.
THE DEPLOYMENT CONTROLLER
The Deployment controller takes care of keeping the actual state of a deployment in
sync with the desired state specified in the corresponding Deployment API object. 
 The Deployment controller performs a rollout of a new version each time a
Deployment object is modified (if the modification should affect the deployed pods).
It does this by creating a ReplicaSet and then appropriately scaling both the old and
the new ReplicaSet based on the strategy specified in the Deployment, until all the old
pods have been replaced with new ones. It doesn’t create any pods directly.
THE STATEFULSET CONTROLLER
The StatefulSet controller, similarly to the ReplicaSet controller and other related
controllers, creates, manages, and deletes Pods according to the spec of a StatefulSet
resource. But while those other controllers only manage Pods, the StatefulSet control-
ler also instantiates and manages PersistentVolumeClaims for each Pod instance.
THE NODE CONTROLLER
The Node controller manages the Node resources, which describe the cluster’s worker
nodes. Among other things, a Node controller keeps the list of Node objects in sync
with the actual list of machines running in the cluster. It also monitors each node’s
health and evicts pods from unreachable nodes.
 The Node controller isn’t the only component making changes to Node objects.
They’re also changed by the Kubelet, and can obviously also be modified by users
through REST API calls. 
THE SERVICE CONTROLLER
In chapter 5, when we talked about Services, you learned that a few different types
exist. One of them was the LoadBalancer service, which requests a load balancer from
the infrastructure to make the service available externally. The Service controller is
the one requesting and releasing a load balancer from the infrastructure, when a
LoadBalancer-type Service is created or deleted.
 
",[],"[{'entity': 'Kubernetes', 'description': 'container orchestration system', 'category': 'software'}, {'entity': 'Pod', 'description': 'lightweight and ephemeral container', 'category': 'software'}, {'entity': 'API server', 'description': 'component that exposes REST API for Kubernetes resources', 'category': 'software'}, {'entity': 'Scheduler', 'description': 'component responsible for scheduling pods on nodes', 'category': 'software'}, {'entity': 'Kubelet', 'description': 'component responsible for running and managing containers on nodes', 'category': 'software'}, {'entity': 'Replication Manager', 'description': 'controller that manages replication of pods', 'category': 'software'}, {'entity': 'ReplicaSet', 'description': 'resource that defines a set of identical replicas', 'category': 'software'}, {'entity': 'DaemonSet', 'description': 'controller that runs a pod on each node in the cluster', 'category': 'software'}, {'entity': 'Job', 'description': 'controller that manages running pods until they complete', 'category': 'software'}, {'entity': 'Deployment', 'description': 'resource that defines a set of identical replicas', 'category': 'software'}, {'entity': 'Replication Manager', 'description': 'controller that manages replication of pods', 'category': 'software'}, {'entity': 'StatefulSet', 'description': 'controller that manages stateful applications', 'category': 'software'}, {'entity': 'PersistentVolumeClaim', 'description': 'resource that requests storage from the cluster', 'category': 'software'}, {'entity': 'Node controller', 'description': 'component that manages Node resources', 'category': 'software'}, {'entity': 'Node', 'description': 'resource that describes a worker node in the cluster', 'category': 'hardware'}, {'entity': 'Service controller', 'description': 'component that requests and releases load balancers from the infrastructure', 'category': 'software'}]","[{'source_entity': '""Job""', 'description': 'creates', 'destination_entity': '""Pod""'}, {'source_entity': '""Node""', 'description': 'hosts', 'destination_entity': '""Pod""'}, {'source_entity': '""DaemonSet""', 'description': 'deploys', 'destination_entity': '""Pod""'}, {'source_entity': '""Service controller""', 'description': 'manages', 'destination_entity': '""Service""'}, {'source_entity': '""StatefulSet""', 'description': 'orchestrates', 'destination_entity': '""Pod""'}, {'source_entity': '""PersistentVolumeClaim""', 'description': 'requests', 'destination_entity': '""Persistent Volume""'}, {'source_entity': '""Scheduler""', 'description': 'allocates', 'destination_entity': '""Node""'}, {'source_entity': '""Node controller""', 'description': 'manages', 'destination_entity': '""Node""'}, {'source_entity': '""Kubernetes""', 'description': 'orchestrates', 'destination_entity': '""Pod""'}, {'source_entity': '""Deployment""', 'description': 'updates', 'destination_entity': '""ReplicaSet""'}, {'source_entity': '""Kubelet""', 'description': 'communicates', 'destination_entity': '""API server""'}, {'source_entity': '""ReplicaSet""', 'description': 'ensures', 'destination_entity': '""Pod""'}, {'source_entity': '""Replication Manager""', 'description': 'monitors', 'destination_entity': '""Deployment""'}, {'source_entity': '""API server""', 'description': 'exposes', 'destination_entity': '""Service""'}]","['[\n  {\n    ""source"": ""Job"",\n    ""destination"": ""Pod"",\n    ""relation_description"": ""creates"",\n    ""summary_er"": ""A Job in Kubernetes creates a Pod, which is a container running an application.""\n  }\n]', '[\n  {\n    ""source"": ""Node"",\n    ""destination"": ""Pod"",\n    ""relation_description"": ""hosts"",\n    ""summary_er"": ""A Node in Kubernetes hosts one or more Pods, providing them with resources and a runtime environment.""\n  }\n]', '[\n  {\n    ""source"": ""DaemonSet"",\n    ""destination"": ""Pod"",\n    ""relation_description"": ""deploys"",\n    ""summary_er"": ""A DaemonSet ensures a specified Pod template is deployed to every node in the cluster, providing a basic unit of deployment.""\n  }\n]', '[\n  {\n    ""source"": ""Service controller"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""manages"",\n    ""summary_er"": ""The Service controller manages a pod, ensuring its lifecycle and configuration.""\n  }\n]', '[\n  {\n    ""source"": ""StatefulSet"",\n    ""destination"": ""Pod"",\n    ""relation_description"": ""orchestrates"",\n    ""summary_er"": ""A StatefulSet manages a set of replicas (identical Pods) that can scale and maintain their own state, ensuring consistent application behavior.""\n  }\n]', '[\n  {\n    ""source"": ""PersistentVolumeClaim"",\n    ""destination"": ""Pod"",\n    ""relation_description"": ""requests"",\n    ""summary_er"": ""A PersistentVolumeClaim is requested by a Pod to access storage resources.""\n  }\n]', '[\n  {\n    ""source"": ""Scheduler"",\n    ""destination"": ""Pod"",\n    ""relation_description"": ""allocates"",\n    ""summary_er"": ""The Scheduler component in Kubernetes allocates resources to Pods, ensuring efficient utilization of cluster resources.""\n  }\n]', '[\n  {\n    ""source"": ""Node controller"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""manages"",\n    ""summary_er"": ""The Node controller manages a pod, overseeing its lifecycle and ensuring it runs smoothly within the Kubernetes cluster.""\n  }\n]', '[\n  {\n    ""source"": ""Kubernetes"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""orchestrates"",\n    ""summary_er"": ""Kubernetes manages and coordinates the execution of pods, ensuring efficient resource utilization and scalability.""\n  }\n]', '[\n  {\n    ""source"": ""Deployment"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""updates"",\n    ""summary_er"": ""A Deployment ensures a specified number of replicas (identical Pod instances) are running and updates them as needed.""\n  },\n  {\n    ""source"": ""ReplicaSet"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""template"",\n    ""summary_er"": ""A ReplicaSet defines the desired state of a set of identical Pods, which are created from a template.""\n  }\n]', '[\n  {\n    ""source"": ""Kubelet"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""communicates"",\n    ""summary_er"": ""The Kubelet communicates with pods to manage and monitor their lifecycle.""\n  }\n]', '[\n  {\n    ""source"": ""ReplicaSet"",\n    ""destination"": ""Pod"",\n    ""relation_description"": ""ensures"",\n    ""summary_er"": ""A ReplicaSet ensures a specified number of replicas (identical Pods) are running at any given time.""\n  }\n]', '[\n  {\n    ""source"": ""Replication Manager"",\n    ""destination"": ""Pod"",\n    ""relation_description"": ""monitors"",\n    ""summary_er"": ""The Replication Manager continuously monitors the Pod\'s status, ensuring it remains operational and up-to-date.""\n  }\n]', '[\n  {\n    ""source"": ""API server"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""exposes"",\n    ""summary_er"": ""The API server exposes its functionality to a pod, allowing it to access and utilize the server\'s services.""\n  }\n]']","Kubernetes controllers manage Pod resources through the API server, with different controllers like ReplicaSet, DaemonSet, Job, Deployment, StatefulSet, Node, and Service controlling various aspects of cluster management, such as pod creation, scaling, and load balancing.","[{'highlight': 'The Replication Manager performs its work by manipulating Pod API objects through the API server.'}, {'highlight': 'The Deployment controller takes care of keeping the actual state of a deployment in sync with the desired state specified in the corresponding Deployment API object.'}, {'highlight': 'The StatefulSet controller creates, manages, and deletes Pods according to the spec of a StatefulSet resource.'}, {'highlight': 'The Node controller keeps the list of Node objects in sync with the actual list of machines running in the cluster.'}, {'highlight': 'The Service controller is the one requesting and releasing a load balancer from the infrastructure, when a LoadBalancer-type Service is created or deleted.'}]"
268,357,0,[],"325
Understanding the architecture
THE ENDPOINTS CONTROLLER
You’ll remember that Services aren’t linked directly to pods, but instead contain a list
of endpoints (IPs and ports), which is created and updated either manually or auto-
matically according to the pod selector defined on the Service. The Endpoints con-
troller is the active component that keeps the endpoint list constantly updated with
the IPs and ports of pods matching the label selector.
 As figure 11.7 shows, the controller watches both Services and Pods. When
Services are added or updated or Pods are added, updated, or deleted, it selects Pods
matching the Service’s pod selector and adds their IPs and ports to the Endpoints
resource. Remember, the Endpoints object is a standalone object, so the controller
creates it if necessary. Likewise, it also deletes the Endpoints object when the Service is
deleted.
THE NAMESPACE CONTROLLER
Remember namespaces (we talked about them in chapter 3)? Most resources belong
to a specific namespace. When a Namespace resource is deleted, all the resources in
that namespace must also be deleted. This is what the Namespace controller does.
When it’s notified of the deletion of a Namespace object, it deletes all the resources
belonging to the namespace through the API server. 
THE PERSISTENTVOLUME CONTROLLER
In chapter 6 you learned about PersistentVolumes and PersistentVolumeClaims.
Once a user creates a PersistentVolumeClaim, Kubernetes must find an appropriate
PersistentVolume and bind it to the claim. This is performed by the PersistentVolume
controller. 
 When a PersistentVolumeClaim pops up, the controller finds the best match for
the claim by selecting the smallest PersistentVolume with the access mode matching
the one requested in the claim and the declared capacity above the capacity requested
Controller Manager
Watches
Creates, modiﬁes,
and deletes
Endpoints
controller
API server
Service resources
Pod resources
Endpoints resources
Figure 11.7
The Endpoints controller watches Service and Pod resources, 
and manages Endpoints.
 
","[  Controller Manager\nEndpoints\ncontroller                          Watches  \
0                                      None  Creates, modifies,\nand deletes   

  API server\nService resources\nPod resources\nEndpoints resources  
0                                               None                 ]","[{'entity': 'Services', 'description': 'A resource in Kubernetes that defines a network service.', 'category': 'software'}, {'entity': 'Pods', 'description': 'The basic execution unit in Kubernetes, a pod is a logical host for one or more containers.', 'category': 'container'}, {'entity': 'Endpoints', 'description': 'A resource that contains a list of IP addresses and ports for pods matching a label selector.', 'category': 'software'}, {'entity': 'EndPoints controller', 'description': 'The active component that keeps the endpoint list constantly updated with the IPs and ports of pods matching the label selector.', 'category': 'process'}, {'entity': 'Namespace', 'description': 'A resource in Kubernetes that defines a logical grouping of resources, such as services and pods.', 'category': 'software'}, {'entity': 'Namespace controller', 'description': 'The component responsible for deleting all resources belonging to a namespace when the namespace is deleted.', 'category': 'process'}, {'entity': 'PersistentVolume', 'description': 'A resource in Kubernetes that represents a storage device, such as a disk or network file system.', 'category': 'software'}, {'entity': 'PersistentVolumeClaim', 'description': 'A resource in Kubernetes that requests access to a PersistentVolume.', 'category': 'software'}, {'entity': 'PersistentVolume controller', 'description': 'The component responsible for binding a PersistentVolume to a PersistentVolumeClaim.', 'category': 'process'}, {'entity': 'Controller Manager', 'description': 'A component in Kubernetes that watches and manages various resources, such as Endpoints and Namespaces.', 'category': 'software'}]","[{'source_entity': '""PersistentVolume controller""', 'description': 'manages', 'destination_entity': '""PersistentVolume""'}, {'source_entity': '""PersistentVolume controller""', 'description': 'binds', 'destination_entity': '""PersistentVolumeClaim""'}, {'source_entity': '""Namespace controller""', 'description': 'manages', 'destination_entity': '""Namespace""'}, {'source_entity': '""Controller Manager""', 'description': 'coordinates', 'destination_entity': '""Endpoints""'}, {'source_entity': '""Controller Manager""', 'description': 'manages', 'destination_entity': '""Services""'}, {'source_entity': '""Endpoints controller""', 'description': 'manages', 'destination_entity': '""Endpoints""'}, {'source_entity': '""Pods""', 'description': 'uses', 'destination_entity': '""PersistentVolumeClaim""'}, {'source_entity': '""Services""', 'description': 'exposes', 'destination_entity': '""Endpoints""'}]","['[\n  {\n    ""source"": ""PersistentVolume controller"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""manages"",\n    ""summary_er"": ""The Persistent Volume controller manages a pod, ensuring its storage needs are met.""\n  }\n]', '[\n  {\n    ""source"": ""PersistentVolume controller"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""binds"",\n    ""summary_er"": ""The Persistent Volume controller binds a persistent volume to a pod, providing storage for the pod\'s data.""\n  }\n]', '[\n  {\n    ""source"": ""Namespace controller"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""manages"",\n    ""summary_er"": ""The Namespace controller manages a collection of pods, ensuring they are running and scaled correctly within the namespace.""\n  }\n]', '[\n  {\n    ""source"": ""Controller Manager"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""coordinates"",\n    ""summary_er"": ""The Controller Manager in Kubernetes coordinates with pods to manage their lifecycle, including creation, deletion, and scaling.""\n  },\n  {\n    ""source"": ""Endpoints"",\n    ""destination"": ""pod"",\n    ""relation_description"": """",\n    ""summary_er"": ""Endpoints in Kubernetes provide a stable network identity and IP address for pods, allowing them to be addressed consistently across restarts and rescheduling.""\n  }\n]', '[\n  {\n    ""source"": ""Controller Manager"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""manages"",\n    ""summary_er"": ""The Controller Manager component in Kubernetes is responsible for managing and scheduling pods, ensuring they are running and meeting resource requirements.""\n  },\n  {\n    ""source"": ""Services"",\n    ""destination"": ""Controller Manager"",\n    ""relation_description"": ""uses"",\n    ""summary_er"": ""Services in Kubernetes utilize the Controller Manager to provide a stable network identity and load balancing for applications, abstracting underlying infrastructure complexities.""\n  }\n]', '[\n  {\n    ""source"": ""Endpoints controller"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""manages"",\n    ""summary_er"": ""The Endpoints controller is responsible for managing pods, ensuring they are running and available.""\n  }\n]', '[\n  {\n    ""source"": ""Pods"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""uses"",\n    ""summary_er"": ""A Pod in Kubernetes uses a specific pod to execute its container(s).""\n  },\n  {\n    ""source"": ""PersistentVolumeClaim"",\n    ""destination"": ""Persistent Volume"",\n    ""relation_description"": ""requests"",\n    ""summary_er"": ""A PersistentVolumeClaim in Kubernetes requests access to a Persistent Volume for storage needs.""\n  }\n]', '[\n  {\n    ""source"": ""Services"",\n    ""destination"": ""Pod"",\n    ""relation_description"": ""exposes"",\n    ""summary_er"": ""A Service provides a stable network identity and load balancing for accessing a group of pods running the same application.""\n  },\n  {\n    ""source"": ""Endpoints"",\n    ""destination"": ""Service"",\n    ""relation_description"": ""points to"",\n    ""summary_er"": ""An Endpoints object points to a set of IP addresses that can be used to access a service, providing load balancing and network identity.""\n  }\n]']","Services aren't linked directly to pods but contain a list of endpoints which is updated by the Endpoints controller based on pod selector and pod IPs/ports. The Namespace controller deletes all resources in a namespace when it's deleted, while the PersistentVolume controller binds PVs to PVCs matching access mode and capacity requirements.","[{'highlight': 'The Endpoints controller is the active component that keeps the endpoint list constantly updated with the IPs and ports of pods matching the label selector.'}, {'highlight': 'When a Namespace resource is deleted, all the resources in that namespace must also be deleted. This is what the Namespace controller does.'}, {'highlight': 'The PersistentVolume controller finds an appropriate PersistentVolume and binds it to the claim by selecting the smallest PersistentVolume with the access mode matching the one requested in the claim and the declared capacity above the capacity requested'}, {'highlight': 'The Endpoints controller watches Service and Pod resources, and manages Endpoints.'}, {'highlight': 'The Namespace controller deletes all the resources belonging to the namespace through the API server when notified of the deletion of a Namespace object.'}]"
269,358,0,[],"326
CHAPTER 11
Understanding Kubernetes internals
in the claim. It does this by keeping an ordered list of PersistentVolumes for each
access mode by ascending capacity and returning the first volume from the list.
 Then, when the user deletes the PersistentVolumeClaim, the volume is unbound
and reclaimed according to the volume’s reclaim policy (left as is, deleted, or emptied).
CONTROLLER WRAP-UP
You should now have a good feel for what each controller does and how controllers
work in general. Again, all these controllers operate on the API objects through the
API server. They don’t communicate with the Kubelets directly or issue any kind of
instructions to them. In fact, they don’t even know Kubelets exist. After a controller
updates a resource in the API server, the Kubelets and Kubernetes Service Proxies,
also oblivious of the controllers’ existence, perform their work, such as spinning up a
pod’s containers and attaching network storage to them, or in the case of services, set-
ting up the actual load balancing across pods. 
 The Control Plane handles one part of the operation of the whole system, so to
fully understand how things unfold in a Kubernetes cluster, you also need to under-
stand what the Kubelet and the Kubernetes Service Proxy do. We’ll learn that next.
11.1.7 What the Kubelet does
In contrast to all the controllers, which are part of the Kubernetes Control Plane and
run on the master node(s), the Kubelet and the Service Proxy both run on the worker
nodes, where the actual pods containers run. What does the Kubelet do exactly?
UNDERSTANDING THE KUBELET’S JOB
In a nutshell, the Kubelet is the component responsible for everything running on a
worker node. Its initial job is to register the node it’s running on by creating a Node
resource in the API server. Then it needs to continuously monitor the API server for
Pods that have been scheduled to the node, and start the pod’s containers. It does this
by telling the configured container runtime (which is Docker, CoreOS’ rkt, or some-
thing else) to run a container from a specific container image. The Kubelet then con-
stantly monitors running containers and reports their status, events, and resource
consumption to the API server. 
 The Kubelet is also the component that runs the container liveness probes, restart-
ing containers when the probes fail. Lastly, it terminates containers when their Pod is
deleted from the API server and notifies the server that the pod has terminated.
RUNNING STATIC PODS WITHOUT THE API SERVER
Although the Kubelet talks to the Kubernetes API server and gets the pod manifests
from there, it can also run pods based on pod manifest files in a specific local direc-
tory as shown in figure 11.8. This feature is used to run the containerized versions of
the Control Plane components as pods, as you saw in the beginning of the chapter.
 Instead of running Kubernetes system components natively, you can put their pod
manifests into the Kubelet’s manifest directory and have the Kubelet run and manage
 
",[],"[{'entity': 'PersistentVolumes', 'description': 'ordered list of Persistent Volumes for each access mode by ascending capacity', 'category': 'database'}, {'entity': 'PersistentVolumeClaim', 'description': 'claim for a Persistent Volume', 'category': 'database'}, {'entity': 'Kubelets', 'description': 'component responsible for running pods on worker nodes', 'category': 'application'}, {'entity': 'API server', 'description': 'server that manages Kubernetes API objects', 'category': 'network'}, {'entity': 'Kubernetes Service Proxies', 'description': 'components that perform load balancing across pods', 'category': 'application'}, {'entity': 'Control Plane', 'description': 'part of the Kubernetes system responsible for handling operations', 'category': 'application'}, {'entity': 'Pods', 'description': 'units of execution in Kubernetes, containing one or more containers', 'category': 'container'}, {'entity': 'containers', 'description': 'lightweight and standalone processes that run in a pod', 'category': 'container'}, {'entity': 'Docker', 'description': 'container runtime used by the Kubelet', 'category': 'software'}, {'entity': 'rkt', 'description': 'container runtime used by CoreOS', 'category': 'software'}, {'entity': 'Node resource', 'description': 'resource in the API server that represents a worker node', 'category': 'database'}, {'entity': 'API objects', 'description': 'objects managed by the Kubernetes API server', 'category': 'database'}, {'entity': 'Kubelet manifest directory', 'description': 'local directory where pod manifests are stored', 'category': 'file system'}, {'entity': 'pod manifests', 'description': 'files that contain pod configuration information', 'category': 'file system'}]","[{'source_entity': '""Pods""', 'description': 'are created by', 'destination_entity': '""Kubelet manifest directory""'}, {'source_entity': '""Pods""', 'description': 'are managed by', 'destination_entity': '""Kubernetes Service Proxies""'}, {'source_entity': '""PersistentVolumeClaim""', 'description': 'requests storage from', 'destination_entity': '""PersistentVolumes""'}, {'source_entity': '""containers""', 'description': 'are run within', 'destination_entity': '""Pods""'}, {'source_entity': '""Kubelet manifest directory""', 'description': 'contains configuration for', 'destination_entity': '""Kubelets""'}, {'source_entity': '""API objects""', 'description': 'are managed by', 'destination_entity': '""Control Plane""'}, {'source_entity': '""API server""', 'description': 'is responsible for', 'destination_entity': '""API objects""'}, {'source_entity': '""Docker""', 'description': 'provides container runtime for', 'destination_entity': '""containers""'}, {'source_entity': '""Kubelets""', 'description': 'are responsible for', 'destination_entity': '""Pods""'}, {'source_entity': '""PersistentVolumes""', 'description': 'provide storage for', 'destination_entity': '""PersistentVolumeClaim""'}]","['[\n  {\n    ""source"": ""Kubernetes"",\n    ""destination"": ""Pods"",\n    ""relation_description"": ""are created by"",\n    ""summary_er"": ""Kubernetes creates Pods through a process that involves generating manifests and scheduling them for execution.""\n  },\n  {\n    ""source"": ""Kubelet manifest directory"",\n    ""destination"": ""Pods"",\n    ""relation_description"": """",\n    ""summary_er"": ""The Kubelet manifest directory contains configuration files that define the Pods to be created, managed, and deleted on a node.""\n  }\n]', '[\n  {\n    ""source"": ""Pods"",\n    ""destination"": ""Controller"",\n    ""relation_description"": ""are managed by"",\n    ""summary_er"": ""Pods are managed by a Controller, which oversees their lifecycle and ensures they run as expected.""\n  },\n  {\n    ""source"": ""Kubernetes Service Proxies"",\n    ""destination"": ""Pods"",\n    ""relation_description"": """",\n    ""summary_er"": ""Kubernetes Service Proxies provide a way to access Pods, allowing users to interact with them through a proxy layer.""\n  }\n]', '[\n  {\n    ""source"": ""PersistentVolumeClaim"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""requests storage from"",\n    ""summary_er"": ""A Persistent Volume Claim requests storage resources from a Pod, which can be fulfilled by a Persistent Volume.""\n  }\n]', '[\n  {\n    ""source"": ""containers"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""are run within"",\n    ""summary_er"": ""Containers are executed within a Pod, which provides shared resources and networking.""\n  }\n]', '[\n  {\n    ""source"": ""Kubelet manifest directory"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""contains configuration for"",\n    ""summary_er"": ""The Kubelet manifest directory holds configuration files that define pod settings and behavior.""\n  }\n]', '[\n  {\n    ""source"": ""API objects"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""are managed by"",\n    ""summary_er"": ""API objects are managed by pods, which provide a runtime environment for them.""\n  },\n  {\n    ""source"": ""Control Plane"",\n    ""destination"": ""pod"",\n    ""relation_description"": """",\n    ""summary_er"": ""The Control Plane is responsible for managing and orchestrating the lifecycle of pods in a Kubernetes cluster.""\n  }\n]', '[{""source"": ""API server"", ""destination"": ""pod"", ""relation_description"": ""is responsible for"", ""summary_er"": ""The API server manages and controls the pods, ensuring they run smoothly and efficiently.""}, {""source"": ""API server"", ""destination"": ""API objects"", ""relation_description"": ""manages"", ""summary_er"": ""The API server oversees and governs the creation, modification, and deletion of API objects.""}]', '[\n  {\n    ""source"": ""Docker"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""provides container runtime for"",\n    ""summary_er"": ""Docker provides a container runtime environment that allows applications to run in isolated containers within a pod.""\n  }\n]', '[\n  {\n    ""source"": ""Kubelets"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""are responsible for"",\n    ""summary_er"": ""Kubelets manage and monitor pods, ensuring they run correctly and efficiently.""\n  }\n]', '[\n  {\n    ""source"": ""PersistentVolumes"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""provide storage for"",\n    ""summary_er"": ""Persistent Volumes provide persistent storage for pods, allowing them to store and retrieve data across restarts.""\n  }\n]']","Kubernetes controllers operate on API objects through the API server without communicating with Kubelets. The Control Plane handles part of the system's operation, while the Kubelet and Service Proxy run on worker nodes, responsible for starting and monitoring containers, reporting status and events to the API server, and terminating containers when their Pod is deleted.","[{'highlight': 'Kubernetes controllers operate on API objects through the API server, without communicating with Kubelets directly or issuing instructions to them.'}, {'highlight': 'The Kubelet is responsible for everything running on a worker node, including registering the node, monitoring the API server for Pods, and starting containers from specific container images.'}, {'highlight': 'The Kubelet monitors running containers, reports their status and resource consumption to the API server, and runs container liveness probes, restarting or terminating containers as needed.'}, {'highlight': 'Kubernetes controllers update resources in the API server, which are then performed by Kubelets and Kubernetes Service Proxies without direct communication between them.'}, {'highlight': 'The Kubelet can run pods based on pod manifest files in a local directory, allowing for running containerized versions of Control Plane components as pods.'}]"
