,page,img_cnt,img_npy_lst,text,tables,entities,relationships,summary_rel,summary,highlights
250,339,0,[],"307
Summary
UNDERSTANDING WHY THE POD ISN’T DELETED
The pod was marked for deletion even before you deleted it. That’s because the con-
trol plane itself already deleted it (in order to evict it from the node). 
 If you look at listing 10.14 again, you’ll see that the pod’s status is Terminating.
The pod was already marked for deletion earlier and will be removed as soon as the
Kubelet on its node notifies the API server that the pod’s containers have terminated.
Because the node’s network is down, this will never happen. 
FORCIBLY DELETING THE POD
The only thing you can do is tell the API server to delete the pod without waiting for
the Kubelet to confirm that the pod is no longer running. You do that like this:
$ kubectl delete po kubia-0 --force --grace-period 0
warning: Immediate deletion does not wait for confirmation that the running 
resource has been terminated. The resource may continue to run on the 
cluster indefinitely.
pod ""kubia-0"" deleted
You need to use both the --force and --grace-period 0 options. The warning dis-
played by kubectl notifies you of what you did. If you list the pods again, you’ll finally
see a new kubia-0 pod created:
$ kubectl get po
NAME          READY     STATUS              RESTARTS   AGE
kubia-0       0/1       ContainerCreating   0          8s
kubia-1       1/1       Running             0          20m
kubia-2       1/1       Running             0          19m
WARNING
Don’t delete stateful pods forcibly unless you know the node is no
longer running or is unreachable (and will remain so forever). 
Before continuing, you may want to bring the node you disconnected back online.
You can do that by restarting the node through the GCE web console or in a terminal
by issuing the following command:
$ gcloud compute instances reset <node name>
10.6
Summary
This concludes the chapter on using StatefulSets to deploy stateful apps. This chapter
has shown you how to
Give replicated pods individual storage
Provide a stable identity to a pod
Create a StatefulSet and a corresponding headless governing Service
Scale and update a StatefulSet
Discover other members of the StatefulSet through DNS
 
",[],"[{'entity': 'Pod', 'description': 'A pod is a logical host for one or more application containers.', 'category': 'container'}, {'entity': 'Kubelet', 'description': 'The Kubelet is an agent that runs on each node in the cluster and is responsible for running pods.', 'category': 'process'}, {'entity': 'API server', 'description': 'The API server is a component of the Kubernetes control plane that provides a RESTful interface to the cluster.', 'category': 'application'}, {'entity': 'kubectl', 'description': 'kubectl is a command-line tool for interacting with the Kubernetes API server.', 'category': 'command'}, {'entity': '--force', 'description': 'The --force option tells kubectl to delete the pod immediately, without waiting for confirmation from the Kubelet.', 'category': 'option'}, {'entity': '--grace-period', 'description': 'The --grace-period option specifies how long to wait before deleting a pod.', 'category': 'option'}, {'entity': 'StatefulSet', 'description': 'A StatefulSet is a Kubernetes resource that manages stateful applications.', 'category': 'application'}, {'entity': 'Service', 'description': 'A Service is a Kubernetes resource that provides a network identity and load balancing for accessing an application.', 'category': 'application'}, {'entity': 'DNS', 'description': 'DNS (Domain Name System) is a system for translating domain names to IP addresses.', 'category': 'network'}, {'entity': 'node', 'description': 'A node is a physical or virtual machine that runs the Kubernetes control plane and/or worker nodes.', 'category': 'hardware'}, {'entity': 'GCE web console', 'description': 'The GCE (Google Compute Engine) web console is a graphical interface for managing Google Cloud resources.', 'category': 'application'}, {'entity': 'gcloud', 'description': 'gcloud is a command-line tool for interacting with the Google Cloud API.', 'category': 'command'}]","[{'source_entity': '""Service""', 'description': 'manages', 'destination_entity': '""Pod""'}, {'source_entity': '""gcloud""', 'description': 'deploys', 'destination_entity': '""StatefulSet""'}, {'source_entity': '""kubectl""', 'description': 'executes', 'destination_entity': '""API server""'}, {'source_entity': '""Kubelet""', 'description': 'communicates with', 'destination_entity': '""DNS""'}, {'source_entity': '""--grace-period""', 'description': 'specifies', 'destination_entity': '""node""'}, {'source_entity': '""--force""', 'description': 'enforces', 'destination_entity': '""API server""'}, {'source_entity': '""GCE web console""', 'description': 'monitors', 'destination_entity': '""Pod""'}, {'source_entity': '""kubectl""', 'description': 'manages', 'destination_entity': '""StatefulSet""'}]","['[\n  {\n    ""source"": ""Service"",\n    ""destination"": ""Pod"",\n    ""relation_description"": ""manages"",\n    ""summary_er"": ""A Service manages a Pod, ensuring it has network access and can be accessed by other components in the cluster.""\n  }\n]', '[\n  {\n    ""source"": ""gcloud"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""deploys"",\n    ""summary_er"": ""Google Cloud CLI deploys a pod to manage stateful applications.""\n  }\n]', '[\n  {\n    ""source"": ""kubectl"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""executes"",\n    ""summary_er"": ""The Kubernetes command-line tool (kubectl) executes commands on a running pod, allowing users to interact with and manage containerized applications.""\n  }\n]', '[\n  {\n    ""source"": ""Kubelet"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""communicates with"",\n    ""summary_er"": ""The Kubelet communicates with pods to manage container runtime and provide node status.""\n  }\n]', '[\n  {\n    ""source"": ""pod"",\n    ""destination"": ""node"",\n    ""relation_description"": ""specifies"",\n    ""summary_er"": ""The pod\'s lifecycle is managed by a node in Kubernetes, specifying its deployment and execution details.""\n  }\n]', '[\n  {\n    ""source"": ""command line"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""enforces"",\n    ""summary_er"": ""The --force flag in a command line forces the creation of a pod, overriding any existing configuration.""\n  }\n]', '[\n  {\n    ""source"": ""GCE web console"",\n    ""destination"": ""Pod"",\n    ""relation_description"": ""monitors"",\n    ""summary_er"": ""The GCE web console continuously monitors the Pod\'s performance, ensuring optimal resource utilization and efficient operation within the Kubernetes cluster.""\n  }\n]', '[\n  {\n    ""source"": ""kubectl"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""manages"",\n    ""summary_er"": ""Kubectl manages the lifecycle of a pod, including creation, scaling, and deletion.""\n  },\n  {\n    ""source"": ""StatefulSet"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""manages"",\n    ""summary_er"": ""A StatefulSet manages the deployment and scaling of pods with persistent identities.""\n  }\n]']","A pod marked for deletion can't be deleted immediately due to node's network being down. Use --force and --grace-period 0 options with kubectl delete command to forcefully delete the pod. This approach is risky, especially for stateful pods. It's recommended to bring back a disconnected node before continuing.","[{'highlight': 'The pod was marked for deletion even before you deleted it. That’s because the control plane itself already deleted it (in order to evict it from the node).'}, {'highlight': 'You need to use both the --force and --grace-period 0 options to forcibly delete a pod without waiting for confirmation that the running resource has been terminated.'}, {'highlight': 'Don’t delete stateful pods forcibly unless you know the node is no longer running or is unreachable (and will remain so forever).'}, {'highlight': 'This chapter has shown you how to Give replicated pods individual storage, Provide a stable identity to a pod, Create a StatefulSet and a corresponding headless governing Service, Scale and update a StatefulSet, Discover other members of the StatefulSet through DNS.'}, {'highlight': 'The only thing you can do is tell the API server to delete the pod without waiting for the Kubelet to confirm that the pod is no longer running.'}]"
251,340,0,[],"308
CHAPTER 10
StatefulSets: deploying replicated stateful applications
Connect to other members through their host names
Forcibly delete stateful pods
Now that you know the major building blocks you can use to have Kubernetes run and
manage your apps, we can look more closely at how it does that. In the next chapter,
you’ll learn about the individual components that control the Kubernetes cluster and
keep your apps running.
 
",[],"[{'entity': 'StatefulSets', 'description': 'deploying replicated stateful applications', 'category': 'software'}, {'entity': 'Kubernetes', 'description': 'run and manage apps', 'category': 'software'}, {'entity': 'pods', 'description': 'stateful pods', 'category': 'container'}, {'entity': 'host names', 'description': 'connect to other members through their host names', 'category': 'network'}, {'entity': 'delete', 'description': 'forcibly delete stateful pods', 'category': 'process'}]","[{'source_entity': 'Kubernetes', 'description': 'manages', 'destination_entity': 'pods'}, {'source_entity': 'StatefulSets', 'description': 'orchestrates', 'destination_entity': 'pods'}, {'source_entity': 'Kubernetes', 'description': 'keeps track of', 'destination_entity': 'host names'}, {'source_entity': 'delete', 'description': 'removes', 'destination_entity': 'StatefulSets'}, {'source_entity': 'delete', 'description': 'deletes', 'destination_entity': 'pods'}]","['[\n  {\n    ""source"": ""Kubernetes"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""manages"",\n    ""summary_er"": ""Kubernetes manages a collection of containers called pods, providing resource allocation and lifecycle management.""\n  }\n]', '[\n  {\n    ""source"": ""StatefulSets"",\n    ""destination"": ""pods"",\n    ""relation_description"": ""orchestrates"",\n    ""summary_er"": ""StatefulSets manages the deployment, scaling, and management of stateful applications by orchestrating multiple pods.""\n  }\n]', '[\n  {\n    ""source"": ""Kubernetes"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""keeps track of"",\n    ""summary_er"": ""Kubernetes manages and keeps track of pod hostnames, ensuring efficient resource allocation and scaling.""\n  }\n]', '[\n  {\n    ""source"": ""delete"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""removes"",\n    ""summary_er"": ""Deleting a pod removes its associated resources, such as volumes and network policies.""\n  },\n  {\n    ""source"": ""delete"",\n    ""destination"": ""StatefulSets"",\n    ""relation_description"": ""removes"",\n    ""summary_er"": ""Deleting a StatefulSet removes the entire set of replicas, including their associated resources.""\n  }\n]', '[\n  {\n    ""source"": ""delete"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""deletes"",\n    ""summary_er"": ""The \'delete\' command removes a pod from the Kubernetes cluster, effectively deleting it.""\n  }\n]']","StatefulSets allow replicated stateful applications to connect with each other through host names and enable forcible deletion of stateful pods, a crucial feature for managing Kubernetes-managed apps.","[{'highlight': 'Connect to other members through their host names'}, {'highlight': 'Forcibly delete stateful pods'}, {'highlight': 'Now that you know the major building blocks you can use to have Kubernetes run and manage your apps'}, {'highlight': ""you'll learn about the individual components that control the Kubernetes cluster and keep your apps running""}, {'highlight': 'StatefulSets: deploying replicated stateful applications'}]"
252,341,0,[],"309
Understanding
Kubernetes internals
By reading this book up to this point, you’ve become familiar with what Kubernetes
has to offer and what it does. But so far, I’ve intentionally not spent much time
explaining exactly how it does all this because, in my opinion, it makes no sense to
go into details of how a system works until you have a good understanding of what
the system does. That’s why we haven’t talked about exactly how a pod is scheduled
or how the various controllers running inside the Controller Manager make deployed
resources come to life. Because you now know most resources that can be deployed in
Kubernetes, it’s time to dive into how they’re implemented.
This chapter covers
What components make up a Kubernetes cluster
What each component does and how it does it
How creating a Deployment object results in a 
running pod
What a running pod is
How the network between pods works
How Kubernetes Services work
How high-availability is achieved
 
",[],"[{'entity': 'Kubernetes', 'description': 'Container orchestration system', 'category': 'software'}, {'entity': 'Pod', 'description': 'Lightweight and portable container', 'category': 'container'}, {'entity': 'Controller Manager', 'description': 'Component responsible for running controllers', 'category': 'process'}, {'entity': 'Deployment object', 'description': 'Resource that represents a set of replicas', 'category': 'resource'}, {'entity': 'Running pod', 'description': 'Pod that is currently executing', 'category': 'container'}, {'entity': 'Network between pods', 'description': 'Communication mechanism between pods', 'category': 'network'}, {'entity': 'Kubernetes Services', 'description': 'Resource that provides a network identity and load balancing for accessing applications', 'category': 'resource'}, {'entity': 'High-availability', 'description': 'Capability to ensure continuous operation of an application or system', 'category': 'application'}]","[{'source_entity': 'Controller Manager', 'description': 'manages and schedules', 'destination_entity': 'Pod'}, {'source_entity': 'Kubernetes Services', 'description': 'provides high-availability', 'destination_entity': 'Deployment object'}, {'source_entity': 'Network between pods', 'description': 'establishes communication', 'destination_entity': 'Pods'}, {'source_entity': 'Running pod', 'description': 'executes and manages', 'destination_entity': 'Pod'}, {'source_entity': 'Kubernetes Services', 'description': 'orchestrates and schedules', 'destination_entity': 'Pod'}, {'source_entity': 'Controller Manager', 'description': 'monitors and controls', 'destination_entity': 'Deployment object'}, {'source_entity': 'High-availability', 'description': 'ensures continuous operation', 'destination_entity': 'Kubernetes Services'}]","['[{\n  ""source"": ""Controller Manager"",\n  ""destination"": ""Pod"",\n  ""relation_description"": ""manages and schedules"",\n  ""summary_er"": ""The Controller Manager is responsible for managing and scheduling Pods, ensuring efficient resource allocation and smooth operation of containerized applications.""\n}]', '[\n  {\n    ""source"": ""Kubernetes Service"",\n    ""destination"": ""Pod"",\n    ""relation_description"": ""provides high-availability"",\n    ""summary_er"": ""A Kubernetes Service provides high-availability to a Pod, ensuring it remains accessible even in case of node failures.""\n  }\n]', '[\n  {\n    ""source"": ""Network"",\n    ""destination"": ""Pods"",\n    ""relation_description"": ""establishes communication"",\n    ""summary_er"": ""A network establishes communication between pods, enabling them to exchange data and interact with each other.""\n  }\n]', '[\n  {\n    ""source"": ""Running pod"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""executes and manages"",\n    ""summary_er"": ""The running pod is responsible for executing and managing other pods in a Kubernetes cluster.""\n  }\n]', '[\n  {\n    ""source"": ""Kubernetes Services"",\n    ""destination"": ""Pod"",\n    ""relation_description"": ""orchestrates and schedules"",\n    ""summary_er"": ""Kubernetes Services manage and schedule Pods, ensuring efficient resource allocation and deployment.""\n  }\n]', '[\n  {\n    ""source"": ""Controller Manager"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""monitors and controls"",\n    ""summary_er"": ""The Controller Manager is responsible for monitoring and controlling pods in a Kubernetes cluster, ensuring they are running as expected.""\n  },\n  {\n    ""source"": ""Deployment object"",\n    ""destination"": ""Controller Manager"",\n    ""relation_description"": ""managed by"",\n    ""summary_er"": ""A Deployment object is managed by the Controller Manager, which ensures its configuration and state are up-to-date in the cluster.""\n  }\n]', '[\n  {\n    ""source"": ""High-availability"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""ensures continuous operation"",\n    ""summary_er"": ""High-availability ensures that a pod remains operational, even in case of hardware or software failures.""\n  },\n  {\n    ""source"": ""Kubernetes Services"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""provides load balancing and access control"",\n    ""summary_er"": ""Kubernetes Services provides load balancing and access control to pods, ensuring efficient resource utilization and security.""\n  }\n]']","This chapter delves into Kubernetes internals, explaining how resources are implemented. It covers what makes up a cluster, each component's role and functionality, pod scheduling, controllers in the Controller Manager, and resource deployment. Specific topics include Deployments, pods, networking between pods, Services, and achieving high-availability.","[{'highlight': 'Understanding Kubernetes internals requires a good understanding of what the system does before diving into how it works.'}, {'highlight': 'A Kubernetes cluster is composed of various components that work together to manage deployed resources.'}, {'highlight': 'Creating a Deployment object results in a running pod, which is a containerized application instance.'}, {'highlight': 'Kubernetes Services enable communication between pods and provide high-availability through load balancing and replication.'}, {'highlight': 'Achieving high-availability in Kubernetes involves deploying resources with redundancy and using services to distribute traffic across multiple instances.'}]"
253,342,0,[],"310
CHAPTER 11
Understanding Kubernetes internals
11.1
Understanding the architecture
Before you look at how Kubernetes does what it does, let’s take a closer look at the
components that make up a Kubernetes cluster. In chapter 1, you saw that a Kuberne-
tes cluster is split into two parts:
The Kubernetes Control Plane
The (worker) nodes
Let’s look more closely at what these two parts do and what’s running inside them.
COMPONENTS OF THE CONTROL PLANE
The Control Plane is what controls and makes the whole cluster function. To refresh
your memory, the components that make up the Control Plane are
The etcd distributed persistent storage
The API server
The Scheduler
The Controller Manager
These components store and manage the state of the cluster, but they aren’t what runs
the application containers. 
COMPONENTS RUNNING ON THE WORKER NODES
The task of running your containers is up to the components running on each
worker node:
The Kubelet
The Kubernetes Service Proxy (kube-proxy)
The Container Runtime (Docker, rkt, or others)
ADD-ON COMPONENTS
Beside the Control Plane components and the components running on the nodes, a
few add-on components are required for the cluster to provide everything discussed
so far. This includes
The Kubernetes DNS server
The Dashboard
An Ingress controller
Heapster, which we’ll talk about in chapter 14
The Container Network Interface network plugin (we’ll explain it later in this
chapter)
11.1.1 The distributed nature of Kubernetes components
The previously mentioned components all run as individual processes. The compo-
nents and their inter-dependencies are shown in figure 11.1.
 
",[],"[{'entity': 'Kubernetes Control Plane', 'description': 'The part of a Kubernetes cluster that controls and makes the whole cluster function.', 'category': 'application'}, {'entity': 'worker nodes', 'description': 'The parts of a Kubernetes cluster where application containers run.', 'category': 'hardware'}, {'entity': 'etcd distributed persistent storage', 'description': 'A component that stores and manages the state of the cluster.', 'category': 'database'}, {'entity': 'API server', 'description': 'A component that handles incoming requests to the Kubernetes API.', 'category': 'application'}, {'entity': 'Scheduler', 'description': 'A component that schedules containers to run on worker nodes.', 'category': 'process'}, {'entity': 'Controller Manager', 'description': 'A component that manages the state of the cluster and ensures it is in a desired state.', 'category': 'application'}, {'entity': 'Kubelet', 'description': 'A component that runs on each worker node and is responsible for running containers.', 'category': 'process'}, {'entity': 'Kubernetes Service Proxy (kube-proxy)', 'description': 'A component that provides network connectivity to services running in the cluster.', 'category': 'application'}, {'entity': 'Container Runtime', 'description': 'A component that runs containers on worker nodes, such as Docker or rkt.', 'category': 'container'}, {'entity': 'Kubernetes DNS server', 'description': 'A component that provides DNS resolution for services running in the cluster.', 'category': 'application'}, {'entity': 'Dashboard', 'description': 'A web-based interface for managing and monitoring a Kubernetes cluster.', 'category': 'application'}, {'entity': 'Ingress controller', 'description': 'A component that provides ingress routing for services running in the cluster.', 'category': 'application'}, {'entity': 'Heapster', 'description': 'A component that provides monitoring and logging capabilities for a Kubernetes cluster.', 'category': 'application'}, {'entity': 'Container Network Interface network plugin', 'description': 'A component that provides networking capabilities for containers running in the cluster.', 'category': 'network'}]","[{'source_entity': '""etcd distributed persistent storage""', 'description': 'stores cluster-wide configuration data', 'destination_entity': '""Kubernetes Control Plane""'}, {'source_entity': '""Heapster""', 'description': 'monitors and reports on cluster resource usage', 'destination_entity': '""worker nodes""'}, {'source_entity': '""Container Runtime""', 'description': 'manages the execution of containers', 'destination_entity': '""worker nodes""'}, {'source_entity': '""Controller Manager""', 'description': 'coordinates the actions of multiple controllers', 'destination_entity': '""Kubernetes Control Plane""'}, {'source_entity': '""Scheduler""', 'description': 'decides which node to place a new container on', 'destination_entity': '""worker nodes""'}, {'source_entity': '""Dashboard""', 'description': 'provides a user interface for monitoring and managing the cluster', 'destination_entity': '""Kubernetes Control Plane""'}, {'source_entity': '""Ingress controller""', 'description': 'manages incoming HTTP requests', 'destination_entity': '""API server""'}, {'source_entity': '""Kubernetes Service Proxy (kube-proxy)""', 'description': 'routes traffic to services within the cluster', 'destination_entity': '""worker nodes""'}, {'source_entity': '""Kubelet""', 'description': 'communicates with the API server and manages container execution on worker nodes', 'destination_entity': '""worker nodes""'}, {'source_entity': '""Kubernetes DNS server""', 'description': 'resolves service names to IP addresses within the cluster', 'destination_entity': '""API server""'}, {'source_entity': '""Container Network Interface network plugin""', 'description': 'manages networking for containers within the cluster', 'destination_entity': '""worker nodes""'}]","['[\n  {\n    ""source"": ""etcd distributed persistent storage"",\n    ""destination"": ""Kubernetes Control Plane"",\n    ""relation_description"": ""stores cluster-wide configuration data"",\n    ""summary_er"": ""Etcd stores configuration data for Kubernetes control plane, enabling centralized management and persistence.""\n  }\n]', '[\n  {\n    ""source"": ""Heapster"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""monitors and reports on cluster resource usage"",\n    ""summary_er"": ""Heapster monitors and reports on pod resource usage, providing insights into cluster performance.""\n  },\n  {\n    ""source"": ""Heapster"",\n    ""destination"": ""worker nodes"",\n    ""relation_description"": ""monitors and reports on cluster resource usage"",\n    ""summary_er"": ""Heapster monitors and reports on worker node resource usage, ensuring optimal cluster performance.""\n  }\n]', '[\n  {\n    ""source"": ""Container Runtime"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""manages the execution of containers"",\n    ""summary_er"": ""The Container Runtime manages container execution within a pod, ensuring efficient resource utilization and streamlined application deployment.""\n  },\n  {\n    ""source"": ""Container Runtime"",\n    ""destination"": ""worker nodes"",\n    ""relation_description"": ""runs on top of"",\n    ""summary_er"": ""Worker nodes serve as the foundation for Container Runtime, providing the necessary infrastructure to execute containers efficiently and securely.""\n  }\n]', '[\n  {\n    ""source"": ""Controller Manager"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""coordinates the actions of multiple controllers"",\n    ""summary_er"": ""The Controller Manager in Kubernetes coordinates the actions of multiple controllers to manage and schedule pods.""\n  },\n  {\n    ""source"": ""Kubernetes Control Plane"",\n    ""destination"": ""Controller Manager"",\n    ""relation_description"": ""part of"",\n    ""summary_er"": ""The Kubernetes Control Plane includes the Controller Manager, which is responsible for managing and scheduling pods.""\n  }\n]', '[\n  {\n    ""source"": ""Scheduler"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""decides which node to place a new container on"",\n    ""summary_er"": ""The Scheduler determines the optimal worker node for a new pod by considering resource availability and other factors.""\n  },\n  {\n    ""source"": ""worker nodes"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""placement"",\n    ""summary_er"": ""Worker nodes provide the compute resources for running pods, with the Scheduler allocating them as needed.""\n  }\n]', '[\n  {\n    ""source"": ""Dashboard"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""provides a user interface for monitoring and managing the cluster"",\n    ""summary_er"": ""The Dashboard provides a graphical interface to monitor and manage pods in the Kubernetes cluster.""\n  }\n]', '[\n  {\n    ""source"": ""Ingress controller"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""manages incoming HTTP requests"",\n    ""summary_er"": ""The Ingress controller manages incoming HTTP requests to a pod, routing traffic to the API server.""\n  },\n  {\n    ""source"": ""API server"",\n    ""destination"": ""Ingress controller"",\n    ""relation_description"": ""receives and processes HTTP requests"",\n    ""summary_er"": ""The API server receives and processes HTTP requests from the Ingress controller, handling incoming traffic.""\n  }\n]', '[\n  {\n    ""source"": ""Kubernetes Service Proxy (kube-proxy)"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""routes traffic to services within the cluster"",\n    ""summary_er"": ""Kube-proxy directs traffic from services to worker nodes in a Kubernetes cluster, ensuring service availability and load balancing.""\n  }\n]', '[\n  {\n    ""source"": ""Kubelet"",\n    ""destination"": ""API Server"",\n    ""relation_description"": ""communicates with"",\n    ""summary_er"": ""The Kubelet communicates with the API server to manage container execution on worker nodes.""\n  },\n  {\n    ""source"": ""Kubelet"",\n    ""destination"": ""Worker Nodes"",\n    ""relation_description"": ""manages container execution on"",\n    ""summary_er"": ""The Kubelet manages container execution on worker nodes, ensuring efficient resource utilization.""\n  },\n  {\n    ""source"": ""API Server"",\n    ""destination"": ""Pod"",\n    ""relation_description"": ""communicates with"",\n    ""summary_er"": ""The API server communicates with the pod to manage container execution and resource allocation.""\n  }\n]', '[\n  {\n    ""source"": ""Kubernetes DNS server"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""resolves service names to IP addresses within the cluster"",\n    ""summary_er"": ""The Kubernetes DNS server resolves service names to IP addresses within the cluster, enabling communication between pods.""\n  },\n  {\n    ""source"": ""API server"",\n    ""destination"": ""Kubernetes DNS server"",\n    ""relation_description"": ""uses for service name resolution"",\n    ""summary_er"": ""The API server utilizes the Kubernetes DNS server for resolving service names and facilitating communication within the cluster.""\n  }\n]', '[\n  {\n    ""source"": ""Container Network Interface network plugin"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""manages networking for containers within the cluster"",\n    ""summary_er"": ""The Container Network Interface (CNI) network plugin manages networking for pods within a Kubernetes cluster, ensuring container communication and connectivity.""\n  },\n  {\n    ""source"": ""Container Network Interface network plugin"",\n    ""destination"": ""worker nodes"",\n    ""relation_description"": ""manages networking for containers within the cluster"",\n    ""summary_er"": ""The Container Network Interface (CNI) network plugin manages networking for worker nodes in a Kubernetes cluster, enabling container communication and connectivity.""\n  }\n]']","A Kubernetes cluster consists of two parts: the Control Plane, which controls the cluster and its components include etcd, API server, Scheduler, Controller Manager, and add-on components such as DNS server, Dashboard, Ingress controller, Heapster, and Container Network Interface plugin. The worker nodes run the Kubelet, Service Proxy, and Container Runtime, with Docker being a common choice. The distributed nature of these components allows for scalability and flexibility in managing containerized applications.","[{'highlight': 'A Kubernetes cluster is split into two parts: The Kubernetes Control Plane and (worker) nodes.'}, {'highlight': 'The components that make up the Control Plane are etcd, API server, Scheduler, and Controller Manager.'}, {'highlight': 'Components running on worker nodes include Kubelet, Kubernetes Service Proxy (kube-proxy), and Container Runtime (Docker, rkt, or others).'}, {'highlight': 'Add-on components required for the cluster include Kubernetes DNS server, Dashboard, Ingress controller, Heapster, and Container Network Interface network plugin.'}, {'highlight': 'Kubernetes components run as individual processes with inter-dependencies between them.'}]"
254,343,0,[],"311
Understanding the architecture
To get all the features Kubernetes provides, all these components need to be running.
But several can also perform useful work individually without the other components.
You’ll see how as we examine each of them.
HOW THESE COMPONENTS COMMUNICATE
Kubernetes system components communicate only with the API server. They don’t
talk to each other directly. The API server is the only component that communicates
with etcd. None of the other components communicate with etcd directly, but instead
modify the cluster state by talking to the API server.
 Connections between the API server and the other components are almost always
initiated by the components, as shown in figure 11.1. But the API server does connect
to the Kubelet when you use kubectl to fetch logs, use kubectl attach to connect to
a running container, or use the kubectl port-forward command.
NOTE
The kubectl attach command is similar to kubectl exec, but it attaches
to the main process running in the container instead of running an addi-
tional one.
RUNNING MULTIPLE INSTANCES OF INDIVIDUAL COMPONENTS
Although the components on the worker nodes all need to run on the same node,
the components of the Control Plane can easily be split across multiple servers. There
Checking the status of the Control Plane components
The API server exposes an API resource called ComponentStatus, which shows the
health status of each Control Plane component. You can list the components and
their statuses with kubectl:
$ kubectl get componentstatuses
NAME                 STATUS    MESSAGE              ERROR
scheduler            Healthy   ok
controller-manager   Healthy   ok
etcd-0               Healthy   {""health"": ""true""}
Control Plane (master node)
Worker node(s)
etcd
API server
kube-proxy
Kubelet
Scheduler
Controller
Manager
Controller
Runtime
Figure 11.1
Kubernetes 
components of the Control 
Plane and the worker nodes
 
","[  Control Plane (master node) Worker node(s)\nkube-proxy\netcd API server\nKubelet\nController\nScheduler\nManager Controller\nRuntime  \
0                                               None                                                                                     
1  Control Plane (master node)\netcd API server\n...                                                                                     
2                                               None                                                                                     
3                                               None                                                                                     
4                                               None                                                                                     

   Col1  Col2 Worker node(s)\nkube-proxy\nKubelet\nController\nRuntime  Col4  
0  None        Worker node(s)\nkube-proxy\nKubelet\nControlle...        None  
1              Worker node(s)\nkube-proxy\nKubelet\nControlle...        None  
2                                                           None        None  
3  None  None                                Controller\nRuntime        None  
4  None  None                                               None              ]","[{'entity': 'Kubernetes', 'description': 'Container orchestration system', 'category': 'software'}, {'entity': 'API server', 'description': 'Central component that communicates with etcd and other components', 'category': 'software'}, {'entity': 'etcd', 'description': 'Distributed key-value store used for cluster state management', 'category': 'database'}, {'entity': 'Kubelet', 'description': 'Agent running on each worker node, responsible for container execution', 'category': 'process'}, {'entity': 'Scheduler', 'description': 'Component that schedules containers to run on nodes', 'category': 'software'}, {'entity': 'Controller Manager', 'description': 'Component that manages the state of the cluster', 'category': 'software'}, {'entity': 'kubectl', 'description': 'Command-line tool for interacting with Kubernetes clusters', 'category': 'command'}, {'entity': 'attach', 'description': 'kubectl command to attach to a running container', 'category': 'command'}, {'entity': 'exec', 'description': 'kubectl command to run a command in a container', 'category': 'command'}, {'entity': 'port-forward', 'description': 'kubectl command to forward ports from a container to the host machine', 'category': 'command'}, {'entity': 'componentstatuses', 'description': 'API resource that shows the health status of each Control Plane component', 'category': 'software'}, {'entity': 'Control Plane', 'description': 'Components responsible for managing the cluster state, including API server, Scheduler, and Controller Manager', 'category': 'application'}, {'entity': 'Worker node(s)', 'description': 'Nodes that run Kubelet and other components', 'category': 'hardware'}, {'entity': 'kube-proxy', 'description': 'Component responsible for routing traffic to containers', 'category': 'software'}]","[{'source_entity': 'kubectl', 'description': 'used to attach', 'destination_entity': 'Controller Manager'}, {'source_entity': 'kubectl', 'description': 'used to attach', 'destination_entity': 'Scheduler'}, {'source_entity': 'kubectl', 'description': 'used to attach', 'destination_entity': 'kube-proxy'}, {'source_entity': 'kubectl', 'description': 'used to attach', 'destination_entity': 'etcd'}, {'source_entity': 'kubectl', 'description': 'used for port-forwarding', 'destination_entity': 'API server'}, {'source_entity': 'Kubelet', 'description': 'responsible for executing', 'destination_entity': 'exec'}, {'source_entity': 'Worker node(s)', 'description': 'run componentstatuses', 'destination_entity': 'componentstatuses'}, {'source_entity': 'kubectl', 'description': 'used to attach', 'destination_entity': 'Kubelet'}, {'source_entity': 'Controller Manager', 'description': 'manages the Control Plane', 'destination_entity': 'Control Plane'}, {'source_entity': 'Scheduler', 'description': 'schedules pods on nodes', 'destination_entity': 'Worker node(s)'}, {'source_entity': 'kube-proxy', 'description': 'handles network traffic', 'destination_entity': 'API server'}, {'source_entity': 'etcd', 'description': 'stores cluster data', 'destination_entity': 'Kubernetes'}]","['[\n  {\n    ""source"": ""kubectl"",\n    ""destination"": ""Pod"",\n    ""relation_description"": ""used to attach"",\n    ""summary_er"": ""Kubectl attaches to a Pod for executing commands within its containerized environment.""\n  },\n  {\n    ""source"": ""Controller Manager"",\n    ""destination"": ""Pod"",\n    ""relation_description"": ""manages"",\n    ""summary_er"": ""The Controller Manager manages the lifecycle of Pods, ensuring they are created, updated, and deleted as needed.""\n  }\n]', '[\n  {\n    ""source"": ""kubectl"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""used to attach"",\n    ""summary_er"": ""Kubectl is a command-line tool used to interact with Kubernetes clusters, attaching to pods for monitoring and management.""\n  },\n  {\n    ""source"": ""pod"",\n    ""destination"": ""Scheduler"",\n    ""relation_description"": ""assigns"",\n    ""summary_er"": ""The Scheduler in Kubernetes assigns resources to pods, ensuring efficient utilization of cluster capacity and optimal performance.""\n  }\n]', '[\n  {\n    ""source"": ""kubectl"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""used to attach"",\n    ""summary_er"": ""Kubectl attaches to a running pod, allowing for interactive shell access and debugging.""\n  },\n  {\n    ""source"": ""kube-proxy"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""related to"",\n    ""summary_er"": ""Kube-proxy is related to pods as it provides network proxying services for them.""\n  }\n]', '[\n  {\n    ""source"": ""kubectl"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""used to attach"",\n    ""summary_er"": ""Kubectl attaches to a running pod, allowing for interactive shell access and debugging.""\n  },\n  {\n    ""source"": ""kubectl"",\n    ""destination"": ""etcd"",\n    ""relation_description"": ""used to manage"",\n    ""summary_er"": ""Kubectl uses etcd as the central store of cluster configuration and state.""\n  }\n]', '[\n  {\n    ""source"": ""kubectl"",\n    ""destination"": ""API server"",\n    ""relation_description"": ""used for port-forwarding"",\n    ""summary_er"": ""Kubectl uses API server to perform port-forwarding, allowing users to access pod services from outside the cluster.""\n  }\n]', '[\n  {\n    ""source"": ""Kubelet"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""executing"",\n    ""summary_er"": ""Kubelet executes commands on a pod, running processes as if it were the pod itself.""\n  }\n]', '[\n  {\n    ""source"": ""Worker node(s)"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""run componentstatuses"",\n    ""summary_er"": ""Worker nodes can run `componentstatuses` command to check the status of various components in a Kubernetes cluster, which is used to manage and monitor pods.""\n  }\n]', '[\n  {\n    ""source"": ""kubectl"",\n    ""destination"": ""Kubelet"",\n    ""relation_description"": ""used to attach"",\n    ""summary_er"": ""kubectl attaches to Kubelet, allowing users to interact with the cluster and manage resources.""\n  }\n]', '[\n  {\n    ""source"": ""Controller Manager"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""manages"",\n    ""summary_er"": ""The Controller Manager component manages the Control Plane and ensures that a pod is running to handle incoming requests.""\n  }\n]', '[\n  {\n    ""source"": ""Scheduler"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""schedules pods on nodes"",\n    ""summary_er"": ""The Scheduler component assigns pods to worker nodes, ensuring efficient resource utilization and pod placement.""\n  },\n  {\n    ""source"": ""pod"",\n    ""destination"": ""Worker node(s)"",\n    ""relation_description"": ""runs on"",\n    ""summary_er"": ""A pod is executed on one or more Worker nodes, utilizing their computing resources for the pod\'s execution.""\n  }\n]', '[\n  {\n    ""source"": ""kube-proxy"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""handles network traffic"",\n    ""summary_er"": ""Kube-proxy manages network traffic for pods, ensuring efficient communication between them.""\n  },\n  {\n    ""source"": ""API server"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""manages API requests"",\n    ""summary_er"": ""The API server handles incoming requests and updates the state of pods accordingly.""\n  }\n]', '[{\n  ""source"": ""etcd"",\n  ""destination"": ""pod"",\n  ""relation_description"": ""stores cluster data"",\n  ""summary_er"": ""Etcd is a key-value store that manages cluster data for pods in Kubernetes, ensuring consistent configuration across nodes.""\n}]']","Kubernetes system components communicate through the API server, which connects to etcd. Components on the worker node run on the same node, but Control Plane components can be split across multiple servers. The API server exposes a ComponentStatus resource showing health status of each component. The kubectl get command displays statuses of all components.","[{'highlight': 'Kubernetes system components communicate only with the API server.'}, {'highlight': 'The API server is the only component that communicates with etcd.'}, {'highlight': 'Connections between the API server and the other components are almost always initiated by the components.'}, {'highlight': 'The Control Plane components can easily be split across multiple servers.'}, {'highlight': 'The API server exposes an API resource called ComponentStatus, which shows the health status of each Control Plane component.'}]"
255,344,0,[],"312
CHAPTER 11
Understanding Kubernetes internals
can be more than one instance of each Control Plane component running to ensure
high availability. While multiple instances of etcd and API server can be active at the
same time and do perform their jobs in parallel, only a single instance of the Sched-
uler and the Controller Manager may be active at a given time—with the others in
standby mode.
HOW COMPONENTS ARE RUN
The Control Plane components, as well as kube-proxy, can either be deployed on the
system directly or they can run as pods (as shown in listing 11.1). You may be surprised
to hear this, but it will all make sense later when we talk about the Kubelet. 
 The Kubelet is the only component that always runs as a regular system compo-
nent, and it’s the Kubelet that then runs all the other components as pods. To run the
Control Plane components as pods, the Kubelet is also deployed on the master. The
next listing shows pods in the kube-system namespace in a cluster created with
kubeadm, which is explained in appendix B.
$ kubectl get po -o custom-columns=POD:metadata.name,NODE:spec.nodeName 
➥ --sort-by spec.nodeName -n kube-system
POD                              NODE
kube-controller-manager-master   master      
kube-dns-2334855451-37d9k        master      
etcd-master                      master      
kube-apiserver-master            master      
kube-scheduler-master            master      
kube-flannel-ds-tgj9k            node1      
kube-proxy-ny3xm                 node1      
kube-flannel-ds-0eek8            node2      
kube-proxy-sp362                 node2      
kube-flannel-ds-r5yf4            node3      
kube-proxy-og9ac                 node3      
As you can see in the listing, all the Control Plane components are running as pods on
the master node. There are three worker nodes, and each one runs the kube-proxy
and a Flannel pod, which provides the overlay network for the pods (we’ll talk about
Flannel later). 
TIP
As shown in the listing, you can tell kubectl to display custom columns
with the -o custom-columns option and sort the resource list with --sort-by.
Now, let’s look at each of the components up close, starting with the lowest level com-
ponent of the Control Plane—the persistent storage.
11.1.2 How Kubernetes uses etcd
All the objects you’ve created throughout this book—Pods, ReplicationControllers,
Services, Secrets, and so on—need to be stored somewhere in a persistent manner so
their manifests survive API server restarts and failures. For this, Kubernetes uses etcd,
Listing 11.1
Kubernetes components running as pods
etcd, API server, Scheduler, 
Controller Manager, and 
the DNS server are running 
on the master.
The three nodes each run 
a Kube Proxy pod and a 
Flannel networking pod.
 
",[],"[{'entity': 'Control Plane', 'description': 'A set of components that manage the Kubernetes cluster.', 'category': 'application'}, {'entity': 'etcd', 'description': 'A distributed key-value store used by Kubernetes for persistent storage.', 'category': 'database'}, {'entity': 'API server', 'description': 'The primary interface for interacting with the Kubernetes cluster.', 'category': 'application'}, {'entity': 'Scheduler', 'description': 'Responsible for scheduling pods on nodes in the cluster.', 'category': 'process'}, {'entity': 'Controller Manager', 'description': 'Manages the lifecycle of controllers, such as ReplicaSets and Deployments.', 'category': 'process'}, {'entity': 'kube-proxy', 'description': 'A network proxy that provides load balancing and networking services for pods.', 'category': 'application'}, {'entity': 'Kubelet', 'description': 'The agent responsible for running containers on nodes in the cluster.', 'category': 'process'}, {'entity': 'Pod', 'description': 'A logical host that runs one or more containers.', 'category': 'container'}, {'entity': 'ReplicationController', 'description': 'Ensures a specified number of replicas of a pod are running at any given time.', 'category': 'application'}, {'entity': 'Service', 'description': 'Provides a network identity and load balancing for accessing applications in the cluster.', 'category': 'application'}, {'entity': 'Secrets', 'description': 'Stores sensitive information, such as passwords or API keys.', 'category': 'database'}, {'entity': 'Flannel', 'description': 'Provides an overlay network for pods in the cluster.', 'category': 'application'}, {'entity': 'kubectl', 'description': 'The command-line interface for interacting with the Kubernetes cluster.', 'category': 'command'}, {'entity': 'kubeadm', 'description': 'A tool for initializing and joining nodes to a Kubernetes cluster.', 'category': 'application'}]","[{'source_entity': '""kubeadm""', 'description': 'initiates', 'destination_entity': '""Service""'}, {'source_entity': '""kubeadm""', 'description': 'configures', 'destination_entity': '""ReplicationController""'}, {'source_entity': '""kubeadm""', 'description': 'installs', 'destination_entity': '""Flannel""'}, {'source_entity': '""kubectl""', 'description': 'interacts with', 'destination_entity': '""Service""'}, {'source_entity': '""Controller Manager""', 'description': 'manages', 'destination_entity': '""Pod""'}, {'source_entity': '""Scheduler""', 'description': 'allocates resources to', 'destination_entity': '""Pod""'}, {'source_entity': '""kube-proxy""', 'description': 'proxies traffic for', 'destination_entity': '""Service""'}, {'source_entity': '""Kubelet""', 'description': 'communicates with', 'destination_entity': '""etcd""'}, {'source_entity': '""Kubelet""', 'description': 'manages', 'destination_entity': '""Pod""'}, {'source_entity': '""Controller Manager""', 'description': 'coordinates', 'destination_entity': '""ReplicationController""'}, {'source_entity': '""API server""', 'description': 'exposes', 'destination_entity': '""Service""'}]","['[{\n  ""source"": ""kubeadm"",\n  ""destination"": ""pod"",\n  ""relation_description"": ""initiates"",\n  ""summary_er"": ""\\""Kubeadm initiates a pod to set up a Kubernetes cluster.\\""""\n}]', '[\n  {\n    ""source"": ""kubeadm"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""configures"",\n    ""summary_er"": ""Kubeadm configures a pod to run on a Kubernetes cluster.""\n  }\n]', '[\n  {\n    ""source"": ""kubeadm"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""installs"",\n    ""summary_er"": ""Kubeadm installs a pod, specifically Flannel, to enable networking in a Kubernetes cluster.""\n  }\n]', '[\n  {\n    ""source"": ""kubectl"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""interacts with"",\n    ""summary_er"": ""Kubectl, a command-line tool for Kubernetes, interacts with pods to manage containerized applications.""\n  },\n  {\n    ""source"": ""Service"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""exposes to"",\n    ""summary_er"": ""A Service exposes a pod\'s port to the outside world, allowing external access and communication.""\n  }\n]', '[\n  {\n    ""source"": ""Controller Manager"",\n    ""destination"": ""Pod"",\n    ""relation_description"": ""manages"",\n    ""summary_er"": ""The Controller Manager component in Kubernetes is responsible for managing and scheduling Pods, ensuring they run efficiently and effectively.""\n  }\n]', '[\n  {\n    ""source"": ""Scheduler"",\n    ""destination"": ""Pod"",\n    ""relation_description"": ""allocates resources to"",\n    ""summary_er"": ""The Scheduler entity allocates resources to a Pod, ensuring efficient resource utilization and allocation for containerized applications.""\n  }\n]', '[\n  {\n    ""source"": ""kube-proxy"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""proxies traffic for"",\n    ""summary_er"": ""Kube-proxy acts as a traffic proxy between services and pods, ensuring efficient communication within the cluster.""\n  }\n]', '[\n  {\n    ""source"": ""Kubelet"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""communicates with"",\n    ""summary_er"": ""Kubelet communicates with pods to manage and monitor them.""\n  }\n]', '[\n  {\n    ""source"": ""Kubelet"",\n    ""destination"": ""Pod"",\n    ""relation_description"": ""manages"",\n    ""summary_er"": ""The Kubelet manages a Pod by ensuring its lifecycle, including creation, execution, and termination.""\n  }\n]', '[\n  {\n    ""source"": ""Controller Manager"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""coordinates"",\n    ""summary_er"": ""The Controller Manager is responsible for coordinating the deployment of pods in a Kubernetes cluster.""\n  },\n  {\n    ""source"": ""ReplicationController"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""managed by"",\n    ""summary_er"": ""A ReplicationController ensures that a specified number of pod replicas are running at any given time.""\n  }\n]', '[\n  {\n    ""source"": ""API server"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""exposes"",\n    ""summary_er"": ""The API server exposes its functionality to a pod, allowing it to interact with the outside world.""\n  }\n]']","Kubernetes Control Plane components can have multiple instances of etcd and API server running for high availability. However, only one instance of Scheduler and Controller Manager may be active at a given time. These components, along with kube-proxy, can run on the system directly or as pods, with the Kubelet deploying them as pods. The Control Plane components are currently running as pods on the master node in the provided cluster, while worker nodes run kube-proxy and Flannel networking pods.","[{'highlight': 'Kubernetes Control Plane components can have multiple instances of etcd and API server running in parallel, but only one instance of Scheduler and Controller Manager may be active at a given time.'}, {'highlight': 'Control Plane components, including kube-proxy, can run either as system components or as pods, with the Kubelet responsible for running all other components as pods.'}, {'highlight': 'All Control Plane components are running as pods on the master node in a cluster created with kubeadm, except for the Kubelet which runs as a regular system component.'}, {'highlight': 'Kubernetes uses etcd to store objects such as Pods, ReplicationControllers, Services, Secrets, and others in a persistent manner so their manifests survive API server restarts and failures.'}, {'highlight': 'The Kubelet is responsible for running all other components as pods, including the Control Plane components, kube-proxy, and Flannel networking pod on worker nodes.'}]"
256,345,0,[],"313
Understanding the architecture
which is a fast, distributed, and consistent key-value store. Because it’s distributed,
you can run more than one etcd instance to provide both high availability and bet-
ter performance.
 The only component that talks to etcd directly is the Kubernetes API server. All
other components read and write data to etcd indirectly through the API server. This
brings a few benefits, among them a more robust optimistic locking system as well as
validation; and, by abstracting away the actual storage mechanism from all the other
components, it’s much simpler to replace it in the future. It’s worth emphasizing that
etcd is the only place Kubernetes stores cluster state and metadata.
HOW RESOURCES ARE STORED IN ETCD
As I’m writing this, Kubernetes can use either etcd version 2 or version 3, but version 3
is now recommended because of improved performance. etcd v2 stores keys in a hier-
archical key space, which makes key-value pairs similar to files in a file system. Each
key in etcd is either a directory, which contains other keys, or is a regular key with a
corresponding value. etcd v3 doesn’t support directories, but because the key format
remains the same (keys can include slashes), you can still think of them as being
grouped into directories. Kubernetes stores all its data in etcd under /registry. The
following listing shows a list of keys stored under /registry.
$ etcdctl ls /registry
/registry/configmaps
/registry/daemonsets
/registry/deployments
/registry/events
/registry/namespaces
/registry/pods
...
About optimistic concurrency control
Optimistic concurrency control (sometimes referred to as optimistic locking) is a
method where instead of locking a piece of data and preventing it from being read or
updated while the lock is in place, the piece of data includes a version number. Every
time the data is updated, the version number increases. When updating the data, the
version number is checked to see if it has increased between the time the client read
the data and the time it submits the update. If this happens, the update is rejected
and the client must re-read the new data and try to update it again. 
The result is that when two clients try to update the same data entry, only the first
one succeeds.
All Kubernetes resources include a metadata.resourceVersion field, which clients
need to pass back to the API server when updating an object. If the version doesn’t
match the one stored in etcd, the API server rejects the update.
Listing 11.2
Top-level entries stored in etcd by Kubernetes
 
",[],"[{'entity': 'etcd', 'description': 'a fast, distributed, and consistent key-value store', 'category': 'database'}, {'entity': 'Kubernetes API server', 'description': 'the only component that talks to etcd directly', 'category': 'application'}, {'entity': 'etcd instance', 'description': 'can be run multiple times for high availability and better performance', 'category': 'process'}, {'entity': 'optimistic locking system', 'description': 'a method where data includes a version number to prevent concurrent updates', 'category': 'process'}, {'entity': 'metadata.resourceVersion field', 'description': 'a field that clients need to pass back to the API server when updating an object', 'category': 'database'}, {'entity': 'etcdctl', 'description': 'a command-line tool for interacting with etcd', 'category': 'command'}, {'entity': '/registry', 'description': 'the top-level directory where Kubernetes stores all its data in etcd', 'category': 'directory'}, {'entity': 'configmaps', 'description': 'a type of resource stored in etcd under /registry/configmaps', 'category': 'resource'}, {'entity': 'daemonsets', 'description': 'a type of resource stored in etcd under /registry/daemonsets', 'category': 'resource'}, {'entity': 'deployments', 'description': 'a type of resource stored in etcd under /registry/deployments', 'category': 'resource'}, {'entity': 'events', 'description': 'a type of resource stored in etcd under /registry/events', 'category': 'resource'}, {'entity': 'namespaces', 'description': 'a type of resource stored in etcd under /registry/namespaces', 'category': 'resource'}, {'entity': 'pods', 'description': 'a type of resource stored in etcd under /registry/pods', 'category': 'resource'}]","[{'source_entity': '""etcd instance""', 'description': 'manages', 'destination_entity': '""registry""'}, {'source_entity': '""Kubernetes API server""', 'description': 'communicates with', 'destination_entity': '""etcd instance""'}, {'source_entity': '""etcdctl""', 'description': 'interacts with', 'destination_entity': '""etcd instance""'}, {'source_entity': '""Kubernetes API server""', 'description': 'uses', 'destination_entity': '""optimistic locking system""'}, {'source_entity': '""etcd instance""', 'description': 'stores', 'destination_entity': '""pods""'}, {'source_entity': '""Kubernetes API server""', 'description': 'manages', 'destination_entity': '""deployments""'}, {'source_entity': '""etcdctl""', 'description': 'queries', 'destination_entity': '""events""'}, {'source_entity': '""Kubernetes API server""', 'description': 'accesses', 'destination_entity': '""namespaces""'}, {'source_entity': '""daemonsets""', 'description': 'manages', 'destination_entity': '""configmaps""'}, {'source_entity': '""etcd instance""', 'description': 'maintains', 'destination_entity': '""metadata.resourceVersion field""'}]","['[\n  {\n    ""source"": ""etcd instance"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""manages"",\n    ""summary_er"": ""The etcd instance manages a pod, ensuring data consistency and synchronization across the cluster.""\n  },\n  {\n    ""source"": ""registry"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""pulls image from"",\n    ""summary_er"": ""The registry pulls an image from a pod, enabling containerization and deployment of applications.""\n  }\n]', '[\n  {\n    ""source"": ""Kubernetes API server"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""communicates with"",\n    ""summary_er"": ""The Kubernetes API server interacts with pods to manage containerized applications.""\n  },\n  {\n    ""source"": ""etcd instance"",\n    ""destination"": ""Kubernetes API server"",\n    ""relation_description"": ""communicates with"",\n    ""summary_er"": ""An etcd instance communicates with the Kubernetes API server to store and retrieve cluster data.""\n  }\n]', '[\n  {\n    ""source"": ""etcdctl"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""interacts with"",\n    ""summary_er"": ""etcdctl interacts with a pod to manage etcd instances.""\n  },\n  {\n    ""source"": ""etcd instance"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""managed by"",\n    ""summary_er"": ""an etcd instance is managed by a pod in the Kubernetes cluster.""\n  }\n]', '[\n  {\n    ""source"": ""Kubernetes API server"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""uses"",\n    ""summary_er"": ""The Kubernetes API server utilizes a pod to manage and orchestrate containerized applications, leveraging its resources for efficient deployment and scaling.""\n  }\n]', '[\n  {\n    ""source"": ""etcd instance"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""stores"",\n    ""summary_er"": ""An etcd instance stores data for a pod, ensuring high availability and consistency across the Kubernetes cluster.""\n  }\n]', '[\n  {\n    ""source"": ""Kubernetes API server"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""manages"",\n    ""summary_er"": ""The Kubernetes API server manages pods, ensuring they are running and functioning correctly.""\n  },\n  {\n    ""source"": ""Kubernetes API server"",\n    ""destination"": ""deployments"",\n    ""relation_description"": ""manages"",\n    ""summary_er"": ""The Kubernetes API server manages deployments, scaling and updating them as needed.""\n  }\n]', '[\n  {\n    ""source"": ""etcdctl"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""queries"",\n    ""summary_er"": ""Etcdctl uses Kubernetes API to query pod information.""\n  },\n  {\n    ""source"": ""etcdctl"",\n    ""destination"": ""events"",\n    ""relation_description"": """",\n    ""summary_er"": """"\n  }\n]', '[\n  {\n    ""source"": ""Kubernetes API server"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""accesses"",\n    ""summary_er"": ""The Kubernetes API server interacts with pods to manage and control containerized applications.""\n  }\n]', '[\n  {\n    ""source"": ""daemonsets"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""manages"",\n    ""summary_er"": ""\\""DaemonSets manage pods, ensuring a specified number of replicas are running at any given time.\\""""\n  },\n  {\n    ""source"": ""configmaps"",\n    ""destination"": """",\n    ""relation_description"": """",\n    ""summary_er"": """"\n  }\n]', '[\n  {\n    ""source"": ""etcd instance"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""maintains"",\n    ""summary_er"": ""The etcd instance manages and maintains the metadata of a pod, ensuring its configuration and state are up-to-date.""\n  }\n]']","Kubernetes stores cluster state and metadata in etcd, a fast, distributed key-value store. etcd v3 is recommended due to improved performance. Resources are stored under /registry with version numbers for optimistic concurrency control, preventing simultaneous updates.","[{'highlight': 'etcd is a fast, distributed, and consistent key-value store that provides high availability and better performance.'}, {'highlight': 'Kubernetes stores all its data in etcd under /registry, including configmaps, daemonsets, deployments, events, namespaces, pods, etc.'}, {'highlight': 'Optimistic concurrency control is used to prevent concurrent updates to the same data entry, where each update includes a version number that must match the one stored in etcd.'}, {'highlight': 'Kubernetes resources include a metadata.resourceVersion field that clients need to pass back to the API server when updating an object.'}, {'highlight': 'etcd v3 is now recommended over etcd v2 due to improved performance and better scalability.'}]"
257,346,0,[],"314
CHAPTER 11
Understanding Kubernetes internals
You’ll recognize that these keys correspond to the resource types you learned about in
the previous chapters. 
NOTE
If you’re using v3 of the etcd API, you can’t use the ls command to see
the contents of a directory. Instead, you can list all keys that start with a given
prefix with etcdctl get /registry --prefix=true.
The following listing shows the contents of the /registry/pods directory.
$ etcdctl ls /registry/pods
/registry/pods/default
/registry/pods/kube-system
As you can infer from the names, these two entries correspond to the default and the
kube-system namespaces, which means pods are stored per namespace. The follow-
ing listing shows the entries in the /registry/pods/default directory.
$ etcdctl ls /registry/pods/default
/registry/pods/default/kubia-159041347-xk0vc
/registry/pods/default/kubia-159041347-wt6ga
/registry/pods/default/kubia-159041347-hp2o5
Each entry corresponds to an individual pod. These aren’t directories, but key-value
entries. The following listing shows what’s stored in one of them.
$ etcdctl get /registry/pods/default/kubia-159041347-wt6ga
{""kind"":""Pod"",""apiVersion"":""v1"",""metadata"":{""name"":""kubia-159041347-wt6ga"",
""generateName"":""kubia-159041347-"",""namespace"":""default"",""selfLink"":...
You’ll recognize that this is nothing other than a pod definition in JSON format. The
API server stores the complete JSON representation of a resource in etcd. Because of
etcd’s hierarchical key space, you can think of all the stored resources as JSON files in
a filesystem. Simple, right?
WARNING
Prior to Kubernetes version 1.7, the JSON manifest of a Secret
resource was also stored like this (it wasn’t encrypted). If someone got direct
access to etcd, they knew all your Secrets. From version 1.7, Secrets are
encrypted and thus stored much more securely.
ENSURING THE CONSISTENCY AND VALIDITY OF STORED OBJECTS
Remember Google’s Borg and Omega systems mentioned in chapter 1, which are
what Kubernetes is based on? Like Kubernetes, Omega also uses a centralized store to
hold the state of the cluster, but in contrast, multiple Control Plane components
access the store directly. All these components need to make sure they all adhere to
Listing 11.3
Keys in the /registry/pods directory
Listing 11.4
etcd entries for pods in the default namespace
Listing 11.5
An etcd entry representing a pod
 
",[],"[{'entity': 'Kubernetes', 'description': 'Container orchestration system', 'category': 'software'}, {'entity': 'etcd', 'description': 'Distributed key-value store', 'category': 'database'}, {'entity': 'API server', 'description': 'Component that exposes the Kubernetes API', 'category': 'application'}, {'entity': 'Control Plane', 'description': 'Components that manage the cluster state', 'category': 'process'}, {'entity': 'Pods', 'description': 'Lightweight and portable container', 'category': 'container'}, {'entity': 'Namespaces', 'description': 'Logical isolation of resources within a cluster', 'category': 'application'}, {'entity': 'Secrets', 'description': 'Sensitive information stored in encrypted form', 'category': 'database'}, {'entity': 'JSON', 'description': 'Data format for storing resource definitions', 'category': 'data format'}, {'entity': 'etcdctl', 'description': 'Command-line tool for interacting with etcd', 'category': 'command'}, {'entity': '/registry/pods', 'description': 'Directory in etcd that stores pod information', 'category': 'directory'}, {'entity': '/registry/pods/default', 'description': 'Subdirectory of /registry/pods that stores default namespace pods', 'category': 'directory'}, {'entity': 'kubia-159041347-wt6ga', 'description': 'Pod name and identifier', 'category': 'container'}, {'entity': 'v1', 'description': 'API version for pod resource definition', 'category': 'data format'}]","[{'source_entity': '""/registry/pods""', 'description': 'lists', 'destination_entity': '""Pods""'}, {'source_entity': '""JSON""', 'description': 'format', 'destination_entity': '""/registry/pods/default""'}, {'source_entity': '""etcdctl""', 'description': 'manages', 'destination_entity': '""etcd""'}, {'source_entity': '""kubia-159041347-wt6ga""', 'description': 'runs', 'destination_entity': '""Kubernetes""'}, {'source_entity': '""/registry/pods/default""', 'description': 'contains', 'destination_entity': '""Secrets""'}, {'source_entity': '""Namespaces""', 'description': 'defines', 'destination_entity': '""Control Plane""'}, {'source_entity': '""API server""', 'description': 'hosts', 'destination_entity': '""Kubernetes""'}]","['[\n  {\n    ""source"": ""/registry/pods"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""lists"",\n    ""summary_er"": ""/registry/pods lists all available pods""\n  }\n]', '[\n  {\n    ""source"": ""JSON"",\n    ""destination"": ""/registry/pods/default"",\n    ""relation_description"": ""format"",\n    ""summary_er"": ""JSON format for storing data in a structured way, used to represent Kubernetes pod information.""\n  }\n]', '[\n  {\n    ""source"": ""etcdctl"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""manages"",\n    ""summary_er"": ""Etcdctl, a tool for managing etcd clusters, manages pods in a Kubernetes environment.""\n  }\n]', '[\n  {\n    ""source"": ""kubia-159041347-wt6ga"",\n    ""destination"": ""Pod"",\n    ""relation_description"": ""runs"",\n    ""summary_er"": ""The kubia-159041347-wt6ga container runs within a Pod in Kubernetes.""\n  }\n]', '[\n  {\n    ""source"": ""/registry/pods/default"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""contains"",\n    ""summary_er"": ""/registry/pods/default contains a pod, which is a container running an application or service.""\n  },\n  {\n    ""source"": ""pod"",\n    ""destination"": ""Secrets"",\n    ""relation_description"": ""uses"",\n    ""summary_er"": ""A pod uses Secrets to store sensitive information such as passwords and API keys.""\n  }\n]', '[\n  {\n    ""source"": ""Namespaces"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""defines"",\n    ""summary_er"": ""In Kubernetes, Namespaces define a logical isolation boundary for pods, allowing multiple users or teams to share the same cluster without conflicts.""\n  },\n  {\n    ""source"": ""Control Plane"",\n    ""destination"": ""Namespaces"",\n    ""relation_description"": ""manages"",\n    ""summary_er"": ""The Control Plane in Kubernetes manages and orchestrates Namespaces, ensuring proper resource allocation and isolation between them.""\n  }\n]', '[\n  {\n    ""source"": ""API server"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""hosts"",\n    ""summary_er"": ""The API server in Kubernetes hosts a pod, which is a containerized application that can be scaled and managed.""\n  }\n]']","Kubernetes stores resource types like pods, secrets, and services as key-value entries in etcd. These entries are JSON representations of the resources, with each entry corresponding to an individual pod or other resource. Prior to v1.7, secrets were stored unencrypted, but from then on they're encrypted for security.","[{'highlight': 'Kubernetes stores the complete JSON representation of a resource in etcd, which can be thought of as JSON files in a filesystem.'}, {'highlight': 'Prior to Kubernetes version 1.7, Secrets were stored in plain text, but from version 1.7, they are encrypted and stored more securely.'}, {'highlight': 'The API server stores the complete JSON representation of a resource in etcd, which includes pod definitions in JSON format.'}, {'highlight': ""Kubernetes uses a centralized store to hold the state of the cluster, similar to Google's Omega system, but with multiple Control Plane components accessing the store directly.""}, {'highlight': 'The /registry/pods directory contains key-value entries for individual pods, with each entry corresponding to an individual pod and stored in JSON format.'}]"
258,347,0,[],"315
Understanding the architecture
the same optimistic locking mechanism to handle conflicts properly. A single compo-
nent not adhering fully to the mechanism may lead to inconsistent data. 
 Kubernetes improves this by requiring all other Control Plane components to go
through the API server. This way updates to the cluster state are always consistent, because
the optimistic locking mechanism is implemented in a single place, so less chance exists,
if any, of error. The API server also makes sure that the data written to the store is always
valid and that changes to the data are only performed by authorized clients. 
ENSURING CONSISTENCY WHEN ETCD IS CLUSTERED
For ensuring high availability, you’ll usually run more than a single instance of etcd.
Multiple etcd instances will need to remain consistent. Such a distributed system
needs to reach a consensus on what the actual state is. etcd uses the RAFT consensus
algorithm to achieve this, which ensures that at any given moment, each node’s state is
either what the majority of the nodes agrees is the current state or is one of the previ-
ously agreed upon states. 
 Clients connecting to different nodes of an etcd cluster will either see the actual
current state or one of the states from the past (in Kubernetes, the only etcd client is
the API server, but there may be multiple instances). 
 The consensus algorithm requires a majority (or quorum) for the cluster to progress
to the next state. As a result, if the cluster splits into two disconnected groups of nodes,
the state in the two groups can never diverge, because to transition from the previous
state to the new one, there needs to be more than half of the nodes taking part in
the state change. If one group contains the majority of all nodes, the other one obvi-
ously doesn’t. The first group can modify the cluster state, whereas the other one can’t.
When the two groups reconnect, the second group can catch up with the state in the
first group (see figure 11.2).
Clients(s)
Clients(s)
Clients(s)
etcd-0
etcd-1
etcd-2
The nodes know
there are three nodes
in the etcd cluster.
etcd-0
etcd-1
These two nodes know
they still have quorum
and can accept state
changes from clients.
etcd-2
This node knows it does
not have quorum and
should therefore not
allow state changes.
Network
split
Figure 11.2
In a split-brain scenario, only the side which still has the majority (quorum) accepts 
state changes.
 
",[],"[{'entity': 'Kubernetes', 'description': 'Container orchestration system', 'category': 'software'}, {'entity': 'API server', 'description': 'Centralized entry point for all cluster state updates', 'category': 'software'}, {'entity': 'etcd', 'description': 'Distributed key-value store used by Kubernetes for storing cluster state', 'category': 'software'}, {'entity': 'RAFT consensus algorithm', 'description': 'Consensus protocol used by etcd to ensure consistency across nodes', 'category': 'algorithm'}, {'entity': 'Control Plane components', 'description': 'Components that manage the Kubernetes cluster, including the API server and etcd', 'category': 'software'}, {'entity': 'clients', 'description': 'Applications or services that connect to an etcd cluster to read or write data', 'category': 'application'}, {'entity': 'quorum', 'description': 'Majority of nodes required for a state change in an etcd cluster', 'category': 'concept'}, {'entity': 'state changes', 'description': 'Updates made to the cluster state by clients or other nodes', 'category': 'process'}]","[{'source_entity': '""Control Plane components""', 'description': 'maintain', 'destination_entity': '""quorum""'}, {'source_entity': '""Control Plane components""', 'description': 'ensure', 'destination_entity': '""RAFT consensus algorithm""'}, {'source_entity': '""Control Plane components""', 'description': 'coordinate', 'destination_entity': '""clients""'}, {'source_entity': '""etcd""', 'description': 'store', 'destination_entity': '""state changes""'}, {'source_entity': '""Kubernetes""', 'description': 'use', 'destination_entity': '""RAFT consensus algorithm""'}, {'source_entity': '""API server""', 'description': 'communicate with', 'destination_entity': '""Control Plane components""'}]","['[\n  {\n    ""source"": ""Control Plane components"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""maintain"",\n    ""summary_er"": ""The Control Plane components ensure the quorum of a pod by maintaining its stability and integrity.""\n  }\n]', '[\n  {\n    ""source"": ""Control Plane components"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""ensure"",\n    ""summary_er"": ""The Control Plane ensures the proper functioning of a pod by guaranteeing its availability and integrity through the RAFT consensus algorithm.""\n  },\n  {\n    ""source"": ""RAFT consensus algorithm"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""guarantee"",\n    ""summary_er"": ""The RAFT consensus algorithm guarantees the consistency and reliability of a pod\'s data by ensuring all nodes agree on its state.""\n  }\n]', '[\n  {\n    ""source"": ""Control Plane components"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""coordinate"",\n    ""summary_er"": ""The Control Plane coordinates with pods to manage cluster resources.""\n  }\n]', '[\n  {\n    ""source"": ""etcd"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""store"",\n    ""summary_er"": ""Etcd stores state changes for pods in a Kubernetes cluster.""\n  }\n]', '[\n  {\n    ""source"": ""Kubernetes"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""use"",\n    ""summary_er"": ""Kubernetes uses pods as the basic execution unit for applications, providing a flexible and scalable way to deploy and manage containerized workloads.""\n  },\n  {\n    ""source"": ""RAFT consensus algorithm"",\n    ""destination"": ""Kubernetes"",\n    ""relation_description"": ""uses"",\n    ""summary_er"": ""The RAFT consensus algorithm is used in Kubernetes to ensure that all nodes agree on the state of the cluster, providing high availability and fault tolerance.""\n  }\n]', '[\n  {\n    ""source"": ""API server"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""communicate with"",\n    ""summary_er"": ""The API server communicates with pods to manage incoming requests and send responses.""\n  },\n  {\n    ""source"": ""Control Plane components"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""manage"",\n    ""summary_er"": ""Control Plane components manage pods by scheduling, scaling, and monitoring them for optimal performance.""\n  }\n]']","Kubernetes ensures consistency by requiring all Control Plane components to go through the API server, implementing optimistic locking in a single place and validating data written to the store. In a distributed etcd cluster, RAFT consensus algorithm is used to reach a consensus on the actual state, ensuring that each node's state is either the current or previously agreed-upon state. This prevents split-brain scenarios where the cluster splits into two disconnected groups of nodes, allowing only the group with majority (quorum) to accept state changes.","[{'highlight': 'Kubernetes improves consistency by requiring all Control Plane components to go through the API server, ensuring updates to the cluster state are always consistent.'}, {'highlight': ""etcd uses the RAFT consensus algorithm to achieve high availability and ensure that at any given moment, each node's state is either what the majority of nodes agrees is the current state or one of the previously agreed upon states.""}, {'highlight': 'A split-brain scenario occurs when an etcd cluster splits into two disconnected groups of nodes, resulting in the state in the two groups never diverging, and only the side with the majority (quorum) accepting state changes.'}, {'highlight': 'The API server ensures that data written to the store is always valid and that changes to the data are only performed by authorized clients.'}, {'highlight': 'In a distributed etcd system, a consensus algorithm requires a majority (or quorum) for the cluster to progress to the next state, preventing the state in different groups of nodes from diverging.'}]"
259,348,0,[],"316
CHAPTER 11
Understanding Kubernetes internals
WHY THE NUMBER OF ETCD INSTANCES SHOULD BE AN ODD NUMBER
etcd is usually deployed with an odd number of instances. I’m sure you’d like to know
why. Let’s compare having two vs. having one instance. Having two instances requires
both instances to be present to have a majority. If either of them fails, the etcd cluster
can’t transition to a new state because no majority exists. Having two instances is worse
than having only a single instance. By having two, the chance of the whole cluster fail-
ing has increased by 100%, compared to that of a single-node cluster failing. 
 The same applies when comparing three vs. four etcd instances. With three instances,
one instance can fail and a majority (of two) still exists. With four instances, you need
three nodes for a majority (two aren’t enough). In both three- and four-instance clus-
ters, only a single instance may fail. But when running four instances, if one fails, a
higher possibility exists of an additional instance of the three remaining instances fail-
ing (compared to a three-node cluster with one failed node and two remaining nodes).
 Usually, for large clusters, an etcd cluster of five or seven nodes is sufficient. It can
handle a two- or a three-node failure, respectively, which suffices in almost all situations. 
11.1.3 What the API server does
The Kubernetes API server is the central component used by all other components
and by clients, such as kubectl. It provides a CRUD (Create, Read, Update, Delete)
interface for querying and modifying the cluster state over a RESTful API. It stores
that state in etcd.
 In addition to providing a consistent way of storing objects in etcd, it also performs
validation of those objects, so clients can’t store improperly configured objects (which
they could if they were writing to the store directly). Along with validation, it also han-
dles optimistic locking, so changes to an object are never overridden by other clients
in the event of concurrent updates.
 One of the API server’s clients is the command-line tool kubectl you’ve been
using from the beginning of the book. When creating a resource from a JSON file, for
example, kubectl posts the file’s contents to the API server through an HTTP POST
request. Figure 11.3 shows what happens inside the API server when it receives the
request. This is explained in more detail in the next few paragraphs.
API server
etcd
Authentication
plugin 1
Authentication
plugin 2
Authentication
plugin 3
Client
(
)
kubectl
HTTP POST
request
Authorization
plugin 1
Authorization
plugin 2
Authorization
plugin 3
Admission
control plugin 1
Admission
control plugin 2
Admission
control plugin 3
Resource
validation
Figure 11.3
The operation of the API server
 
","[Empty DataFrame
Columns: [HTTP POST
request
Client
(kubectl), API server
Authentication Authorization Admission
plugin 1 plugin 1 control plugin 1
Authentication Authorization Admission Resource
plugin 2 plugin 2 control plugin 2 validation
Authentication Authorization Admission
plugin 3 plugin 3 control plugin 3, etcd]
Index: []]","[{'entity': 'etcd', 'description': 'a distributed key-value store that serves as a central component for storing and managing cluster state', 'category': 'database'}, {'entity': 'Kubernetes API server', 'description': 'the central component used by all other components and clients, providing a CRUD interface over a RESTful API', 'category': 'application'}, {'entity': 'kubectl', 'description': 'a command-line tool that interacts with the Kubernetes API server through HTTP requests', 'category': 'client'}, {'entity': 'RESTful API', 'description': 'an architectural style for designing networked applications, emphasizing simplicity and scalability', 'category': 'protocol'}, {'entity': 'etcd cluster', 'description': 'a group of etcd instances working together to store and manage cluster state', 'category': 'database'}, {'entity': 'majority', 'description': 'the minimum number of etcd instances required for a quorum, ensuring the cluster can transition to a new state', 'category': 'concept'}, {'entity': 'CRUD interface', 'description': 'a set of operations (Create, Read, Update, Delete) provided by the Kubernetes API server for querying and modifying cluster state', 'category': 'protocol'}, {'entity': 'optimistic locking', 'description': 'a mechanism used by the Kubernetes API server to prevent changes to an object from being overridden by other clients in concurrent updates', 'category': 'concept'}, {'entity': 'admission control plugin', 'description': 'a component that validates and enforces admission rules for resources created through the Kubernetes API server', 'category': 'application'}, {'entity': 'resource validation', 'description': 'the process of verifying that a resource meets certain criteria before it is stored in etcd', 'category': 'concept'}, {'entity': 'HTTP POST request', 'description': 'a type of HTTP request used by kubectl to create resources through the Kubernetes API server', 'category': 'protocol'}]","[{'source_entity': '""kubectl""', 'description': 'uses', 'destination_entity': '""Kubernetes API server""'}, {'source_entity': '""admission control plugin""', 'description': 'implements', 'destination_entity': '""resource validation""'}, {'source_entity': '""CRUD interface""', 'description': 'provides', 'destination_entity': '""Kubernetes API server""'}, {'source_entity': '""etcd""', 'description': 'uses', 'destination_entity': '""majority""'}, {'source_entity': '""HTTP POST request""', 'description': 'sends to', 'destination_entity': '""Kubernetes API server""'}, {'source_entity': '""optimistic locking""', 'description': 'implements for', 'destination_entity': '""etcd cluster""'}, {'source_entity': '""resource validation""', 'description': 'performs on', 'destination_entity': '""CRUD interface""'}, {'source_entity': '""Kubernetes API server""', 'description': 'exposes a', 'destination_entity': '""RESTful API""'}]","['[\n  {\n    ""source"": ""kubectl"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""uses"",\n    ""summary_er"": ""The Kubernetes command-line tool (kubectl) uses a pod to execute commands and manage resources within a cluster.""\n  }\n]', '[\n  {\n    ""source"": ""admission control plugin"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""implements"",\n    ""summary_er"": ""The admission control plugin enforces resource validation for pods, ensuring they meet specific requirements before being deployed.""\n  }\n]', '[\n  {\n    ""source"": ""CRUD interface"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""provides"",\n    ""summary_er"": ""The CRUD interface provides a pod, which is a containerized application instance that can be managed by Kubernetes.""\n  }\n]', '[\n  {\n    ""source"": ""etcd"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""uses"",\n    ""summary_er"": ""Etcd, a distributed key-value store, uses pods to manage its data and provide high availability.""\n  },\n  {\n    ""source"": ""majority"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""majority"",\n    ""summary_er"": ""A majority of nodes in an etcd cluster must agree on the state of a pod before it can be considered stable.""\n  }\n]', '[\n  {\n    ""source"": ""HTTP POST request"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""sends to"",\n    ""summary_er"": ""An HTTP POST request sends data to a pod in Kubernetes, which is then processed by the API server.""\n  },\n  {\n    ""source"": ""Kubernetes API server"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""communicates with"",\n    ""summary_er"": ""The Kubernetes API server communicates with pods to manage and orchestrate containerized applications.""\n  }\n]', '[\n  {\n    ""source"": ""Optimistic Locking"",\n    ""destination"": ""Pod"",\n    ""relation_description"": ""implements for"",\n    ""summary_er"": ""Optimistic locking ensures data consistency in pods by implementing concurrency control mechanisms.""\n  },\n  {\n    ""source"": ""Optimistic Locking"",\n    ""destination"": ""Etcd Cluster"",\n    ""relation_description"": ""uses"",\n    ""summary_er"": ""Optimistic locking utilizes etcd cluster to manage concurrent access and ensure data integrity across distributed systems.""\n  }\n]', '[\n  {\n    ""source"": ""Resource Validation"",\n    ""destination"": ""Pod"",\n    ""relation_description"": ""performs on"",\n    ""summary_er"": ""The Resource Validation system checks and validates resources within a Pod, ensuring compliance with predefined rules.""\n  },\n  {\n    ""source"": ""CRUD Interface"",\n    ""destination"": ""Pod"",\n    ""relation_description"": ""interface for"",\n    ""summary_er"": ""The CRUD Interface provides a user-friendly interface to interact with a Pod, enabling read, update, and delete operations.""\n  }\n]', '[\n  {\n    ""source"": ""Kubernetes API server"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""exposes a RESTful API"",\n    ""summary_er"": ""The Kubernetes API server provides a RESTful interface to interact with pods, allowing for management and control of containerized applications.""\n  }\n]']","Kubernetes etcd clusters should have an odd number of instances, ideally 5 or 7, to handle failures and maintain a majority for state transitions. The API server provides a CRUD interface over RESTful API for querying and modifying cluster state, storing it in etcd, validating objects, and handling optimistic locking to prevent concurrent updates. Clients like kubectl post requests to the API server through HTTP POST.","[{'highlight': 'etcd should be deployed with an odd number of instances to ensure cluster stability and minimize the chance of failure.'}, {'highlight': 'Having two etcd instances is worse than having one instance, as it increases the chance of the whole cluster failing by 100% compared to a single-node cluster.'}, {'highlight': 'A typical etcd cluster for large clusters consists of five or seven nodes, which can handle a two- or three-node failure, respectively.'}, {'highlight': 'The Kubernetes API server provides a CRUD interface for querying and modifying the cluster state over a RESTful API and stores that state in etcd.'}, {'highlight': 'The API server performs validation of objects stored in etcd to prevent clients from storing improperly configured objects, and handles optimistic locking to prevent concurrent updates from overriding each other.'}]"
