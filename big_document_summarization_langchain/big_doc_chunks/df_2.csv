,page,img_cnt,img_npy_lst,text,tables,entities,relationships,summary_rel,summary,highlights
20,109,0,[],"77
Using namespaces to group resources
 But what about times when you want to split objects into separate, non-overlapping
groups? You may want to only operate inside one group at a time. For this and other
reasons, Kubernetes also groups objects into namespaces. These aren’t the Linux
namespaces we talked about in chapter 2, which are used to isolate processes from
each other. Kubernetes namespaces provide a scope for objects names. Instead of hav-
ing all your resources in one single namespace, you can split them into multiple name-
spaces, which also allows you to use the same resource names multiple times (across
different namespaces).
3.7.1
Understanding the need for namespaces
Using multiple namespaces allows you to split complex systems with numerous com-
ponents into smaller distinct groups. They can also be used for separating resources
in a multi-tenant environment, splitting up resources into production, development,
and QA environments, or in any other way you may need. Resource names only need
to be unique within a namespace. Two different namespaces can contain resources of
the same name. But, while most types of resources are namespaced, a few aren’t. One
of them is the Node resource, which is global and not tied to a single namespace.
You’ll learn about other cluster-level resources in later chapters.
 Let’s see how to use namespaces now.
3.7.2
Discovering other namespaces and their pods
First, let’s list all namespaces in your cluster:
$ kubectl get ns
NAME          LABELS    STATUS    AGE
default       <none>    Active    1h
kube-public   <none>    Active    1h
kube-system   <none>    Active    1h
Up to this point, you’ve operated only in the default namespace. When listing resources
with the kubectl get command, you’ve never specified the namespace explicitly, so
kubectl always defaulted to the default namespace, showing you only the objects in
that namespace. But as you can see from the list, the kube-public and the kube-system
namespaces also exist. Let’s look at the pods that belong to the kube-system name-
space, by telling kubectl to list pods in that namespace only:
$ kubectl get po --namespace kube-system
NAME                                 READY     STATUS    RESTARTS   AGE
fluentd-cloud-kubia-e8fe-node-txje   1/1       Running   0          1h
heapster-v11-fz1ge                   1/1       Running   0          1h
kube-dns-v9-p8a4t                    0/4       Pending   0          1h
kube-ui-v4-kdlai                     1/1       Running   0          1h
l7-lb-controller-v0.5.2-bue96        2/2       Running   92         1h
TIP
You can also use -n instead of --namespace.
 
",[],"[{'entity': 'namespaces', 'description': 'groups objects into namespaces for resource management', 'category': 'software'}, {'entity': 'Kubernetes', 'description': 'container orchestration system', 'category': 'software'}, {'entity': 'Linux namespaces', 'description': 'used to isolate processes from each other', 'category': 'software'}, {'entity': 'resources', 'description': 'managed by Kubernetes using namespaces', 'category': 'software'}, {'entity': 'names', 'description': 'only need to be unique within a namespace', 'category': 'software'}, {'entity': 'Node resource', 'description': 'global and not tied to a single namespace', 'category': 'software'}, {'entity': 'kubectl get command', 'description': 'used to list resources in a namespace', 'category': 'command'}, {'entity': 'namespace', 'description': 'a scope for objects names', 'category': 'hardware'}, {'entity': 'default namespace', 'description': 'the default namespace used by Kubernetes', 'category': 'software'}, {'entity': 'kube-public namespace', 'description': 'a namespace used by Kubernetes', 'category': 'software'}, {'entity': 'kube-system namespace', 'description': 'a namespace used by Kubernetes', 'category': 'software'}, {'entity': 'pods', 'description': 'managed by Kubernetes using namespaces', 'category': 'software'}, {'entity': 'fluentd-cloud-kubia-e8fe-node-txje pod', 'description': 'a pod in the kube-system namespace', 'category': 'software'}, {'entity': 'heapster-v11-fz1ge pod', 'description': 'a pod in the kube-system namespace', 'category': 'software'}, {'entity': 'kube-dns-v9-p8a4t pod', 'description': 'a pod in the kube-system namespace', 'category': 'software'}, {'entity': 'kube-ui-v4-kdlai pod', 'description': 'a pod in the kube-system namespace', 'category': 'software'}, {'entity': 'l7-lb-controller-v0.5.2-bue96 pod', 'description': 'a pod in the kube-system namespace', 'category': 'software'}]","[{'source_entity': '""l7-lb-controller-v0.5.2-bue96 pod""', 'description': 'runs within', 'destination_entity': '""default namespace""'}, {'source_entity': '""l7-lb-controller-v0.5.2-bue96 pod""', 'description': 'uses', 'destination_entity': '""Linux namespaces""'}, {'source_entity': '""heapster-v11-fz1ge pod""', 'description': 'monitors', 'destination_entity': '""pods""'}, {'source_entity': '""kubectl get command""', 'description': 'lists', 'destination_entity': '""namespaces""'}, {'source_entity': '""kube-system namespace""', 'description': 'belongs to', 'destination_entity': '""Kubernetes""'}, {'source_entity': '""kube-public namespace""', 'description': 'is a type of', 'destination_entity': '""namespace""'}, {'source_entity': '""kube-dns-v9-p8a4t pod""', 'description': 'resolves DNS for', 'destination_entity': '""pods""'}, {'source_entity': '""kube-ui-v4-kdlai pod""', 'description': 'provides UI for', 'destination_entity': '""Kubernetes""'}, {'source_entity': '""fluentd-cloud-kubia-e8fe-node-txje pod""', 'description': 'collects logs from', 'destination_entity': '""pods""'}, {'source_entity': '""resources""', 'description': 'are managed by', 'destination_entity': '""Kubernetes""'}, {'source_entity': '""names""', 'description': 'are used to identify', 'destination_entity': '""resources""'}, {'source_entity': '""Node resource""', 'description': 'is a type of', 'destination_entity': '""resources""'}]","['[\n  {\n    ""source"": ""l7-lb-controller-v0.5.2-bue96"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""runs within"",\n    ""summary_er"": ""The l7-lb-controller-v0.5.2-bue96 pod runs within a containerized environment.""\n  },\n  {\n    ""source"": ""default namespace"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""contains"",\n    ""summary_er"": ""The default namespace contains the pod, which is a deployable unit of an application.""\n  }\n]', '[\n  {\n    ""source"": ""l7-lb-controller-v0.5.2-bue96"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""uses"",\n    ""summary_er"": ""The l7-lb-controller-v0.5.2-bue96 pod utilizes a Linux namespace for its operation.""\n  }\n]', '[\n  {\n    ""source"": ""heapster-v11-fz1ge"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""monitors"",\n    ""summary_er"": ""Heapster monitors the heapster-v11-fz1ge pod\'s performance and resource utilization.""\n  },\n  {\n    ""source"": ""pods"",\n    ""destination"": ""heapster-v11-fz1ge"",\n    ""relation_description"": ""contains"",\n    ""summary_er"": ""The pods list contains information about the heapster-v11-fz1ge pod, including its status and metrics.""\n  }\n]', '[\n  {\n    ""source"": ""kubectl"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""lists"",\n    ""summary_er"": ""Kubectl command retrieves a list of running pods in a Kubernetes cluster.""\n  },\n  {\n    ""source"": ""kubectl"",\n    ""destination"": ""namespaces"",\n    ""relation_description"": ""lists"",\n    ""summary_er"": ""Kubectl command lists all namespaces in a Kubernetes cluster, providing information on each namespace\'s ID and name.""\n  }\n]', '[\n  {\n    ""source"": ""kube-system namespace"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""belongs to"",\n    ""summary_er"": ""The kube-system namespace contains pods that belong to it, providing a logical grouping for Kubernetes resources.""\n  },\n  {\n    ""source"": ""Kubernetes"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""contains"",\n    ""summary_er"": ""Kubernetes manages and orchestrates the lifecycle of pods, ensuring efficient resource utilization and scalability.""\n  }\n]', '[\n  {\n    ""source"": ""kube-public namespace"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""is a type of"",\n    ""summary_er"": ""The kube-public namespace is a type of pod that provides public data to all pods in a Kubernetes cluster.""\n  }\n]', '[\n  {\n    ""source"": ""kube-dns-v9-p8a4t pod"",\n    ""destination"": ""pods"",\n    ""relation_description"": ""resolves DNS for"",\n    ""summary_er"": ""The Kube-DNS pod resolves DNS queries for all pods in the cluster, ensuring they can communicate with each other.""\n  }\n]', '[\n  {\n    ""source"": ""kube-ui-v4-kdlai pod"",\n    ""destination"": ""Kubernetes"",\n    ""relation_description"": ""provides UI for"",\n    ""summary_er"": ""The kube-ui-v4-kdlai pod provides a user interface for Kubernetes, enabling users to interact with the system.""\n  }\n]', '[\n  {\n    ""source"": ""fluentd-cloud-kubia-e8fe-node-txje pod"",\n    ""destination"": ""pods"",\n    ""relation_description"": ""collects logs from"",\n    ""summary_er"": ""The fluentd-cloud-kubia-e8fe-node-txje pod collects logs from the pods.""\n  }\n]', '[\n  {\n    ""source"": ""resources"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""are managed by"",\n    ""summary_er"": ""Resources in Kubernetes are managed by pods, which are the basic execution units of a containerized application.""\n  },\n  {\n    ""source"": ""Kubernetes"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""basic execution unit"",\n    ""summary_er"": ""In Kubernetes, a pod is the basic execution unit that contains one or more containers and provides shared resources such as IP address and port space.""\n  }\n]', '[{""source"": ""names"", ""destination"": ""pod"", ""relation_description"": ""are used to identify"", ""summary_er"": ""Pod names serve as identifiers, allowing for easy reference and management.""}, {""source"": ""resources"", ""destination"": ""pod"", ""relation_description"": ""are used to identify"", ""summary_er"": ""Resources are utilized by pods to function properly, including CPU, memory, and storage allocations.""}]', '[\n  {\n    ""source"": ""Node resource"",\n    ""destination"": ""pod resources"",\n    ""relation_description"": ""is a type of"",\n    ""summary_er"": ""A node\'s resources are allocated to a pod, which can utilize them for execution.""\n  }\n]']","Kubernetes groups objects into namespaces, which provide a scope for object names and allow for separate, non-overlapping groups. Namespaces enable operating within one group at a time and using the same resource names multiple times across different namespaces. They can be used to split complex systems, separate resources in multi-tenant environments, or divide resources into production, development, and QA environments.","[{'highlight': 'Kubernetes groups objects into namespaces to provide a scope for object names and allow the same resource name to be used multiple times across different namespaces.'}, {'highlight': 'Namespaces in Kubernetes are not like Linux namespaces, which isolate processes from each other, but rather provide a way to split complex systems into smaller distinct groups or separate resources in a multi-tenant environment.'}, {'highlight': 'The Node resource is global and not tied to a single namespace, unlike most types of resources that are namespaced.'}, {'highlight': 'You can list all namespaces in your cluster using the command kubectl get ns and specify a namespace explicitly with the --namespace flag or -n shorthand.'}, {'highlight': 'Resource names only need to be unique within a namespace, allowing you to use the same name multiple times across different namespaces.'}]"
21,110,0,[],"78
CHAPTER 3
Pods: running containers in Kubernetes
You’ll learn about these pods later in the book (don’t worry if the pods shown here
don’t match the ones on your system exactly). It’s clear from the name of the name-
space that these are resources related to the Kubernetes system itself. By having
them in this separate namespace, it keeps everything nicely organized. If they were
all in the default namespace, mixed in with the resources you create yourself, you’d
have a hard time seeing what belongs where, and you might inadvertently delete sys-
tem resources. 
 Namespaces enable you to separate resources that don’t belong together into non-
overlapping groups. If several users or groups of users are using the same Kubernetes
cluster, and they each manage their own distinct set of resources, they should each use
their own namespace. This way, they don’t need to take any special care not to inad-
vertently modify or delete the other users’ resources and don’t need to concern them-
selves with name conflicts, because namespaces provide a scope for resource names,
as has already been mentioned.
  Besides isolating resources, namespaces are also used for allowing only certain users
access to particular resources and even for limiting the amount of computational
resources available to individual users. You’ll learn about this in chapters 12 through 14.
3.7.3
Creating a namespace
A namespace is a Kubernetes resource like any other, so you can create it by posting a
YAML file to the Kubernetes API server. Let’s see how to do this now. 
CREATING A NAMESPACE FROM A YAML FILE
First, create a custom-namespace.yaml file with the following listing’s contents (you’ll
find the file in the book’s code archive).
apiVersion: v1
kind: Namespace         
metadata:
  name: custom-namespace  
Now, use kubectl to post the file to the Kubernetes API server:
$ kubectl create -f custom-namespace.yaml
namespace ""custom-namespace"" created
CREATING A NAMESPACE WITH KUBECTL CREATE NAMESPACE
Although writing a file like the previous one isn’t a big deal, it’s still a hassle. Luckily,
you can also create namespaces with the dedicated kubectl create namespace com-
mand, which is quicker than writing a YAML file. By having you create a YAML mani-
fest for the namespace, I wanted to reinforce the idea that everything in Kubernetes
Listing 3.6
A YAML definition of a namespace: custom-namespace.yaml
This says you’re 
defining a namespace.
This is the name 
of the namespace.
 
",[],"[{'entity': 'Pods', 'description': 'running containers in Kubernetes', 'category': 'application'}, {'entity': 'namespaces', 'description': 'separate resources that don’t belong together into non-overlapping groups', 'category': 'database'}, {'entity': 'kubectl', 'description': 'command to post a YAML file to the Kubernetes API server', 'category': 'software'}, {'entity': 'YAML', 'description': 'file format for defining resources in Kubernetes', 'category': 'software'}, {'entity': 'apiVersion', 'description': 'field in YAML file to specify the API version', 'category': 'database'}, {'entity': 'kind', 'description': 'field in YAML file to specify the type of resource', 'category': 'database'}, {'entity': 'metadata', 'description': 'field in YAML file to specify metadata about the resource', 'category': 'database'}, {'entity': 'name', 'description': 'field in YAML file to specify the name of the namespace', 'category': 'database'}, {'entity': 'custom-namespace', 'description': 'example namespace created using YAML file', 'category': 'application'}, {'entity': 'kubectl create', 'description': 'command to create a namespace from a YAML file', 'category': 'software'}, {'entity': 'create namespace', 'description': 'dedicated command to create a namespace', 'category': 'software'}]","[{'source_entity': 'kubectl', 'description': 'creates a new namespace', 'destination_entity': 'namespaces'}, {'source_entity': 'kubectl create', 'description': 'executes a command to create a resource', 'destination_entity': 'Pods'}, {'source_entity': 'create namespace', 'description': 'specifies the action of creating a new namespace', 'destination_entity': 'namespaces'}, {'source_entity': 'kubectl', 'description': 'executes a command to create a resource', 'destination_entity': 'custom-namespace'}, {'source_entity': 'metadata', 'description': 'provides additional information about the namespace', 'destination_entity': 'namespaces'}, {'source_entity': 'YAML', 'description': 'defines the configuration for creating a new namespace', 'destination_entity': 'custom-namespace'}]","['[\n  {\n    ""source"": ""kubectl"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""creates a new"",\n    ""summary_er"": ""Using kubectl, a command-line tool, creates a new pod in a Kubernetes cluster.""\n  },\n  {\n    ""source"": ""kubectl"",\n    ""destination"": ""namespace"",\n    ""relation_description"": ""creates a new"",\n    ""summary_er"": ""Using kubectl, a command-line tool, creates a new namespace in a Kubernetes cluster.""\n  }\n]', '[\n  {\n    ""source"": ""kubectl"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""executes a command to create a resource"",\n    ""summary_er"": ""Kubectl creates a pod by executing a command that creates a new resource, resulting in the creation of a running pod.""\n  }\n]', '[\n  {\n    ""source"": ""create namespace"",\n    ""destination"": ""namespaces"",\n    ""relation_description"": ""specifies the action of creating a new namespace"",\n    ""summary_er"": ""Creating a new namespace involves specifying the name, labels, and annotations for the namespace, which is then created by the Kubernetes API server.""\n  }\n]', '[\n  {\n    ""source"": ""kubectl"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""executes a command to create a resource"",\n    ""summary_er"": ""Kubectl executes a command to create a pod in a specified namespace, utilizing Kubernetes API.""\n  }\n]', '[\n  {\n    ""source"": ""metadata"",\n    ""destination"": ""namespace"",\n    ""relation_description"": ""provides additional information about the namespace"",\n    ""summary_er"": ""Metadata provides context to the namespace, describing its properties and characteristics.""\n  },\n  {\n    ""source"": ""metadata"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""provides additional information about the pod"",\n    ""summary_er"": ""Metadata provides supplementary details about the pod, including its configuration and behavior.""\n  }\n]', '[\n  {\n    ""source"": ""YAML"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""defines the configuration for creating a new namespace"",\n    ""summary_er"": ""YAML defines the configuration for creating a pod, which in turn creates a custom namespace.""\n  },\n  {\n    ""source"": ""namespace"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""custom-namespace"",\n    ""summary_er"": ""A custom namespace is created to isolate the pod\'s resources and configuration.""\n  }\n]']","Namespaces in Kubernetes enable separation of resources into non-overlapping groups, isolating them from other users' resources. They can be created by posting a YAML file to the Kubernetes API server using kubectl create -f or kubectl create namespace command.","[{'highlight': 'Namespaces enable you to separate resources that don’t belong together into non-overlapping groups.'}, {'highlight': 'You can create a namespace by posting a YAML file to the Kubernetes API server using kubectl.'}, {'highlight': 'A namespace is a Kubernetes resource like any other, so it can be created with the dedicated kubectl create namespace command.'}, {'highlight': 'Namespaces are used for isolating resources, allowing only certain users access to particular resources, and limiting computational resources available to individual users.'}, {'highlight': 'You can also create namespaces using the kubectl create -f custom-namespace.yaml command.'}]"
22,111,0,[],"79
Using namespaces to group resources
has a corresponding API object that you can create, read, update, and delete by post-
ing a YAML manifest to the API server.
 You could have created the namespace like this:
$ kubectl create namespace custom-namespace
namespace ""custom-namespace"" created
NOTE
Although most objects’ names must conform to the naming conven-
tions specified in RFC 1035 (Domain names), which means they may contain
only letters, digits, dashes, and dots, namespaces (and a few others) aren’t
allowed to contain dots. 
3.7.4
Managing objects in other namespaces
To create resources in the namespace you’ve created, either add a namespace: custom-
namespace entry to the metadata section, or specify the namespace when creating the
resource with the kubectl create command:
$ kubectl create -f kubia-manual.yaml -n custom-namespace
pod ""kubia-manual"" created
You now have two pods with the same name (kubia-manual). One is in the default
namespace, and the other is in your custom-namespace.
 When listing, describing, modifying, or deleting objects in other namespaces, you
need to pass the --namespace (or -n) flag to kubectl. If you don’t specify the name-
space, kubectl performs the action in the default namespace configured in the cur-
rent kubectl context. The current context’s namespace and the current context itself
can be changed through kubectl config commands. To learn more about managing
kubectl contexts, refer to appendix A. 
TIP
To quickly switch to a different namespace, you can set up the following
alias: alias kcd='kubectl config set-context $(kubectl config current-
context) --namespace '. You can then switch between namespaces using kcd
some-namespace.
3.7.5
Understanding the isolation provided by namespaces
To wrap up this section about namespaces, let me explain what namespaces don’t pro-
vide—at least not out of the box. Although namespaces allow you to isolate objects
into distinct groups, which allows you to operate only on those belonging to the speci-
fied namespace, they don’t provide any kind of isolation of running objects. 
 For example, you may think that when different users deploy pods across different
namespaces, those pods are isolated from each other and can’t communicate, but that’s
not necessarily the case. Whether namespaces provide network isolation depends on
which networking solution is deployed with Kubernetes. When the solution doesn’t
provide inter-namespace network isolation, if a pod in namespace foo knows the IP
 
",[],"[{'entity': 'namespaces', 'description': 'A way to group resources in Kubernetes', 'category': 'software'}, {'entity': 'API object', 'description': 'An object that can be created, read, updated, and deleted by posting a YAML manifest to the API server', 'category': 'software'}, {'entity': 'kubectl', 'description': 'A command-line tool for managing Kubernetes resources', 'category': 'software'}, {'entity': 'create namespace', 'description': 'A command to create a new namespace in Kubernetes', 'category': 'command'}, {'entity': 'custom-namespace', 'description': 'A custom namespace created using the `kubectl create` command', 'category': 'software'}, {'entity': 'metadata section', 'description': 'A section in a YAML manifest that specifies the metadata for a resource', 'category': 'software'}, {'entity': 'kubia-manual.yaml', 'description': 'A YAML manifest file used to create a pod in a specific namespace', 'category': 'file'}, {'entity': 'pod', 'description': 'A container that can run one or more applications', 'category': 'software'}, {'entity': 'default namespace', 'description': 'The default namespace in which resources are created if no other namespace is specified', 'category': 'software'}, {'entity': '--namespace flag', 'description': 'A flag used with the `kubectl` command to specify a namespace for an action', 'category': 'flag'}, {'entity': 'kubectl config commands', 'description': 'Commands used to manage Kubernetes contexts and namespaces', 'category': 'software'}, {'entity': 'alias kcd', 'description': 'An alias created to quickly switch between namespaces using the `kubectl` command', 'category': 'command'}, {'entity': 'networking solution', 'description': 'A solution that provides network isolation between namespaces in Kubernetes', 'category': 'software'}, {'entity': 'inter-namespace network isolation', 'description': 'The ability of a networking solution to isolate pods across different namespaces', 'category': 'feature'}]","[{'source_entity': '""default namespace""', 'description': 'is used to create a new namespace', 'destination_entity': '""namespaces""'}, {'source_entity': '""kubectl config commands""', 'description': 'are used to configure kubectl for a specific namespace', 'destination_entity': '""default namespace""'}, {'source_entity': '""kubectl config commands""', 'description': ""can be used to create a new namespace using the '--namespace flag'"", 'destination_entity': '""--namespace flag""'}, {'source_entity': '""create namespace""', 'description': 'is a command used to create a new namespace', 'destination_entity': '""namespaces""'}, {'source_entity': '""pod""', 'description': ""can be created within a specific namespace using the '--namespace flag'"", 'destination_entity': '""--namespace flag""'}, {'source_entity': '""create namespace""', 'description': 'requires a metadata section to specify details about the new namespace', 'destination_entity': '""metadata section""'}, {'source_entity': '""namespaces""', 'description': 'can be used as an API object to manage namespaces within a cluster', 'destination_entity': '""API object""'}, {'source_entity': '""inter-namespace network isolation""', 'description': 'is achieved by configuring networking solutions for each namespace', 'destination_entity': '""networking solution""'}, {'source_entity': '""kubectl""', 'description': ""can be used to create a custom namespace using the 'create namespace' command"", 'destination_entity': '""custom-namespace""'}, {'source_entity': '""alias kcd""', 'description': ""is an alias for the 'kubectl config commands' which can be used to configure kubectl for a specific namespace"", 'destination_entity': '""kubectl config commands""'}]","['[\n  {\n    ""source"": ""default namespace"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""is used to create a new namespace"",\n    ""summary_er"": ""The default namespace is created to host a new pod, allowing for resource isolation and management.""\n  }\n]', '[\n  {\n    ""source"": ""kubectl config commands"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""are used to configure kubectl for a specific namespace"",\n    ""summary_er"": ""Configuring kubectl for a specific namespace allows users to manage pods within that namespace.""\n  }\n]', '[\n  {\n    ""source"": ""kubectl config commands"",\n    ""destination"": ""--namespace flag"",\n    ""relation_description"": ""can be used to create a new namespace"",\n    ""summary_er"": ""The \'kubectl config\' command can be used with \'--namespace\' flag to create a new namespace for pods.""\n  }\n]', '[\n  {\n    ""source"": ""create namespace"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""is a command used to create a new namespace"",\n    ""summary_er"": ""The \'create namespace\' command creates a new namespace, which is a logical isolation of resources in Kubernetes.""\n  }\n]', '[\n  {\n    ""source"": ""Pod"",\n    ""destination"": ""Namespace"",\n    ""relation_description"": ""can be created within a specific namespace using the \'--namespace flag\'"",\n    ""summary_er"": ""A pod can be created within a specified namespace by utilizing the \'--namespace\' flag.""\n  }\n]', '[\n  {\n    ""source"": ""create namespace"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""requires a metadata section to specify details about the new namespace"",\n    ""summary_er"": ""To create a namespace, a metadata section must be specified with details about the new namespace.""\n  },\n  {\n    ""source"": ""metadata section"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""specifies details about the new namespace"",\n    ""summary_er"": ""A metadata section specifies details about the new namespace for the pod.""\n  }\n]', '[\n  {\n    ""source"": ""namespaces"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""can be used as an API object to manage namespaces within a cluster"",\n    ""summary_er"": ""Namespaces can be managed using API objects, which enable cluster-wide management.""\n  }\n]', '[\n  {\n    ""source"": ""inter-namespace network isolation"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""is achieved by configuring networking solutions for each namespace"",\n    ""summary_er"": ""Inter-namespace isolation is enforced by setting up separate networking configurations for each pod, ensuring secure communication within namespaces.""\n  },\n  {\n    ""source"": ""inter-namespace network isolation"",\n    ""destination"": ""networking solution"",\n    ""relation_description"": ""is achieved by configuring networking solutions for each namespace"",\n    ""summary_er"": ""Inter-namespace isolation relies on customized networking solutions to establish secure connections between pods across different namespaces.""\n  }\n]', '[\n  {\n    ""source"": ""kubectl"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""can be used to create a custom namespace using the \'create namespace\' command"",\n    ""summary_er"": ""Kubectl can create custom namespaces for pods, utilizing the \'create namespace\' command.""\n  }\n]', '[\n  {\n    ""source"": ""alias kcd"",\n    ""destination"": ""kubectl config commands"",\n    ""relation_description"": ""is an alias for"",\n    ""summary_er"": ""Alias \'kcd\' is used to configure kubectl for a specific namespace, providing easy access to kubectl commands.""\n  },\n  {\n    ""source"": ""kubectl config commands"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""used to configure"",\n    ""summary_er"": ""Kubectl config commands are used to configure and manage pods in a Kubernetes cluster.""\n  }\n]']","Namespaces allow grouping resources and can be created using kubectl create command or by posting YAML manifest to API server. Resources in other namespaces can be managed by adding namespace entry to metadata section or specifying namespace with kubectl create command. Namespaces provide isolation for objects, but do not guarantee network isolation between pods across different namespaces.","[{'highlight': 'You can create a namespace using the command $ kubectl create namespace custom-namespace'}, {'highlight': ""Namespaces don't provide any kind of isolation of running objects, and pods across different namespaces can communicate with each other if the networking solution doesn't provide inter-namespace network isolation""}, {'highlight': 'To create resources in a specific namespace, you need to add a namespace: custom-namespace entry to the metadata section or specify the namespace when creating the resource with the kubectl create command'}, {'highlight': ""You can quickly switch between namespaces using an alias like alias kcd='kubectl config set-context $(kubectl config current-context) --namespace ' and then use kcd some-namespace to switch""}, {'highlight': ""Namespaces allow you to isolate objects into distinct groups, but they don't provide any kind of isolation of running objects out of the box""}]"
23,112,0,[],"80
CHAPTER 3
Pods: running containers in Kubernetes
address of a pod in namespace bar, there is nothing preventing it from sending traffic,
such as HTTP requests, to the other pod. 
3.8
Stopping and removing pods
You’ve created a number of pods, which should all still be running. You have four
pods running in the default namespace and one pod in custom-namespace. You’re
going to stop all of them now, because you don’t need them anymore.
3.8.1
Deleting a pod by name
First, delete the kubia-gpu pod by name:
$ kubectl delete po kubia-gpu
pod ""kubia-gpu"" deleted
By deleting a pod, you’re instructing Kubernetes to terminate all the containers that are
part of that pod. Kubernetes sends a SIGTERM signal to the process and waits a certain
number of seconds (30 by default) for it to shut down gracefully. If it doesn’t shut down
in time, the process is then killed through SIGKILL. To make sure your processes are
always shut down gracefully, they need to handle the SIGTERM signal properly. 
TIP
You can also delete more than one pod by specifying multiple, space-sep-
arated names (for example, kubectl delete po pod1 pod2).
3.8.2
Deleting pods using label selectors
Instead of specifying each pod to delete by name, you’ll now use what you’ve learned
about label selectors to stop both the kubia-manual and the kubia-manual-v2 pod.
Both pods include the creation_method=manual label, so you can delete them by
using a label selector:
$ kubectl delete po -l creation_method=manual
pod ""kubia-manual"" deleted
pod ""kubia-manual-v2"" deleted 
In the earlier microservices example, where you had tens (or possibly hundreds) of
pods, you could, for instance, delete all canary pods at once by specifying the
rel=canary label selector (visualized in figure 3.10):
$ kubectl delete po -l rel=canary
3.8.3
Deleting pods by deleting the whole namespace
Okay, back to your real pods. What about the pod in the custom-namespace? You no
longer need either the pods in that namespace, or the namespace itself. You can
 
",[],"[{'entity': 'Pod', 'description': 'A container running in Kubernetes', 'category': 'container'}, {'entity': 'Kubernetes', 'description': 'An open-source container orchestration system', 'category': 'software'}, {'entity': 'kubectl', 'description': 'The command-line tool for interacting with Kubernetes', 'category': 'command'}, {'entity': 'SIGTERM', 'description': 'A signal sent to a process to terminate it gracefully', 'category': 'signal'}, {'entity': 'SIGKILL', 'description': 'A signal sent to a process to kill it immediately', 'category': 'signal'}, {'entity': 'label selector', 'description': 'A way to select pods based on labels attached to them', 'category': 'selector'}, {'entity': 'namespace', 'description': 'A logical grouping of resources in Kubernetes', 'category': 'resource'}, {'entity': 'pod name', 'description': 'The unique identifier for a pod', 'category': 'identifier'}, {'entity': 'creation_method=manual label', 'description': 'A label attached to pods created manually', 'category': 'label'}, {'entity': 'rel=canary label', 'description': 'A label attached to canary pods', 'category': 'label'}]","[{'source_entity': '""Kubernetes""', 'description': 'manages', 'destination_entity': '""pod name""'}, {'source_entity': '""kubectl""', 'description': 'interacts with', 'destination_entity': '""Kubernetes""'}, {'source_entity': '""label selector""', 'description': 'applies to', 'destination_entity': '""Pod""'}, {'source_entity': '""SIGTERM""', 'description': 'sends signal to', 'destination_entity': '""pod name""'}, {'source_entity': '""SIGKILL""', 'description': 'terminates', 'destination_entity': '""pod name""'}, {'source_entity': '""namespace""', 'description': 'contains', 'destination_entity': '""Pod""'}, {'source_entity': '""creation_method=manual label""', 'description': 'applies to', 'destination_entity': '""Pod""'}, {'source_entity': '""rel=canary label""', 'description': 'applies to', 'destination_entity': '""Pod""'}]","['[\n  {\n    ""source"": ""Kubernetes"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""manages"",\n    ""summary_er"": ""Kubernetes manages a containerized application or service, in this case, a pod named \'pod name\'.""\n  }\n]', '[\n  {\n    ""source"": ""kubectl"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""interacts with"",\n    ""summary_er"": ""kubectl, a command-line tool, interacts with Kubernetes to manage and deploy pods.""\n  }\n]', '[\n  {\n    ""source"": ""Label Selector"",\n    ""destination"": ""Pod"",\n    ""relation_description"": ""applies to"",\n    ""summary_er"": ""A label selector is used to select a Pod based on its labels, allowing for targeted resource management and deployment.""\n  }\n]', '[\n  {\n    ""source"": ""SIGTERM"",\n    ""destination"": ""pod name"",\n    ""relation_description"": ""sends signal to"",\n    ""summary_er"": ""The SIGTERM signal is sent to a pod, instructing it to terminate its execution.""\n  }\n]', '[\n  {\n    ""source"": ""SIGKILL"",\n    ""destination"": ""pod name"",\n    ""relation_description"": ""terminates"",\n    ""summary_er"": ""The SIGKILL signal terminates a running pod, effectively killing it.""\n  }\n]', '[\n  {\n    ""source"": ""namespace"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""contains"",\n    ""summary_er"": ""A namespace in Kubernetes contains one or more pods, which are the basic execution units of a containerized application.""\n  }\n]', '[\n  {\n    ""source"": ""creation_method=manual label"",\n    ""destination"": ""Pod"",\n    ""relation_description"": ""applies to"",\n    ""summary_er"": ""Manual labels are applied to pods for identification and organization purposes.""\n  }\n]', '[\n  {\n    ""source"": ""Canary Label"",\n    ""destination"": ""Pod"",\n    ""relation_description"": ""applies to"",\n    ""summary_er"": ""A canary label is applied to a pod, indicating its purpose or characteristics.""\n  }\n]']","Pods in Kubernetes can communicate with each other within a namespace. To stop and remove pods, use kubectl delete command. Pods can be deleted by name, label selector, or even deleting the whole namespace. When deleting a pod, Kubernetes sends a SIGTERM signal to shut down containers, and if they don't respond, a SIGKILL signal is sent. It's essential for processes to handle the SIGTERM signal properly.","[{'highlight': 'You can delete a pod by specifying its name using the kubectl delete command: $ kubectl delete po <pod_name>'}, {'highlight': 'Kubernetes sends a SIGTERM signal to the process and waits 30 seconds for it to shut down gracefully, before killing it through SIGKILL'}, {'highlight': 'You can use label selectors to delete multiple pods at once using the kubectl delete command: $ kubectl delete po -l <label_selector>'}, {'highlight': 'Deleting a namespace will also delete all pods and resources within that namespace'}, {'highlight': 'To make sure processes are shut down gracefully, they need to handle the SIGTERM signal properly'}]"
24,113,0,[],"81
Stopping and removing pods
delete the whole namespace (the pods will be deleted along with the namespace auto-
matically), using the following command:
$ kubectl delete ns custom-namespace
namespace ""custom-namespace"" deleted
3.8.4
Deleting all pods in a namespace, while keeping the namespace
You’ve now cleaned up almost everything. But what about the pod you created with
the kubectl run command in chapter 2? That one is still running:
$ kubectl get pods
NAME            READY   STATUS    RESTARTS   AGE
kubia-zxzij     1/1     Running   0          1d    
This time, instead of deleting the specific pod, tell Kubernetes to delete all pods in the
current namespace by using the --all option:
$ kubectl delete po --all
pod ""kubia-zxzij"" deleted
Now, double check that no pods were left running:
$ kubectl get pods
NAME            READY   STATUS        RESTARTS   AGE
kubia-09as0     1/1     Running       0          1d    
kubia-zxzij     1/1     Terminating   0          1d    
UI pod
app: ui
rel: stable
rel=stable
app=ui
Account
Service
pod
app: as
rel: stable
app=as
app: pc
rel: stable
app=pc
app: sc
rel: stable
app=sc
app: os
rel: stable
app=os
Product
Catalog
pod
Shopping
Cart
pod
Order
Service
pod
UI pod
app: ui
rel: beta
rel=beta
app: pc
rel: beta
app: os
rel: beta
Product
Catalog
pod
Order
Service
pod
rel=canary
Account
Service
pod
app: as
rel: canary
app: pc
rel: canary
app: os
rel: canary
Product
Catalog
pod
Order
Service
pod
Figure 3.10
Selecting and deleting all canary pods through the rel=canary label selector
 
",[],"[{'entity': 'kubectl', 'description': 'command-line tool for managing Kubernetes clusters', 'category': 'software'}, {'entity': 'delete', 'description': 'command to delete resources in Kubernetes', 'category': 'software'}, {'entity': 'ns', 'description': 'namespace in Kubernetes', 'category': 'software'}, {'entity': 'custom-namespace', 'description': 'example namespace name', 'category': 'software'}, {'entity': 'pod', 'description': 'lightweight and ephemeral container in Kubernetes', 'category': 'software'}, {'entity': 'kubia-zxzij', 'description': 'example pod name', 'category': 'software'}, {'entity': '--all', 'description': 'option to delete all resources of a certain type', 'category': 'software'}, {'entity': 'kubectl get pods', 'description': 'command to list running pods in Kubernetes', 'category': 'software'}, {'entity': 'NAME', 'description': 'column header for pod names in the output of kubectl get pods', 'category': 'software'}, {'entity': 'READY', 'description': 'column header for pod readiness status in the output of kubectl get pods', 'category': 'software'}, {'entity': 'STATUS', 'description': 'column header for pod status in the output of kubectl get pods', 'category': 'software'}, {'entity': 'RESTARTS', 'description': 'column header for pod restart count in the output of kubectl get pods', 'category': 'software'}, {'entity': 'AGE', 'description': 'column header for pod creation time in the output of kubectl get pods', 'category': 'software'}, {'entity': 'ui', 'description': 'example application name', 'category': 'software'}, {'entity': 'app', 'description': 'label key for application names', 'category': 'software'}, {'entity': 'rel', 'description': 'label key for release versions', 'category': 'software'}, {'entity': 'stable', 'description': 'example release version', 'category': 'software'}, {'entity': 'as', 'description': 'example application name', 'category': 'software'}, {'entity': 'pc', 'description': 'example application name', 'category': 'software'}, {'entity': 'sc', 'description': 'example application name', 'category': 'software'}, {'entity': 'os', 'description': 'example application name', 'category': 'software'}, {'entity': 'Account Service', 'description': 'example service name', 'category': 'software'}, {'entity': 'Product Catalog', 'description': 'example service name', 'category': 'software'}, {'entity': 'Order Service', 'description': 'example service name', 'category': 'software'}, {'entity': 'Shopping Cart', 'description': 'example service name', 'category': 'software'}, {'entity': 'UI pod', 'description': 'example pod name for UI application', 'category': 'software'}, {'entity': 'canary', 'description': 'release version label selector', 'category': 'software'}]","[{'source_entity': '""kubectl""', 'description': 'executes', 'destination_entity': '""kubectl get pods""'}, {'source_entity': '""kubectl""', 'description': 'runs', 'destination_entity': '""--all""'}, {'source_entity': '""kubectl""', 'description': 'gets', 'destination_entity': '""pods""'}, {'source_entity': '""kubia-zxzij""', 'description': 'is a', 'destination_entity': '""pod""'}, {'source_entity': '""ui""', 'description': 'is part of', 'destination_entity': '""Shopping Cart""'}, {'source_entity': '""app""', 'description': 'runs in', 'destination_entity': '""custom-namespace""'}, {'source_entity': '""sc""', 'description': 'is a', 'destination_entity': '""Service Controller""'}, {'source_entity': '""pc""', 'description': 'is a', 'destination_entity': '""Product Catalog""'}, {'source_entity': '""kubectl get pods""', 'description': 'displays', 'destination_entity': '""STATUS""'}, {'source_entity': '""kubectl get pods""', 'description': 'shows', 'destination_entity': '""READY""'}, {'source_entity': '""kubia-zxzij""', 'description': 'has', 'destination_entity': '""AGE""'}, {'source_entity': '""Account Service""', 'description': 'is a', 'destination_entity': '""Service""'}, {'source_entity': '""Order Service""', 'description': 'is a', 'destination_entity': '""Service""'}, {'source_entity': '""Product Catalog""', 'description': 'contains', 'destination_entity': '""Product Information""'}]","['[\n  {\n    ""source"": ""kubectl"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""executes"",\n    ""summary_er"": ""\\""kubectl\\"" executes a command to retrieve information about running \\""pods\\"", which are the smallest deployable units in Kubernetes.""\n  }\n]', '[\n  {\n    ""source"": ""kubectl"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""runs"",\n    ""summary_er"": ""Kubectl command to run a pod on all nodes.""\n  }\n]', '[\n  {\n    ""source"": ""kubectl"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""gets"",\n    ""summary_er"": ""Kubernetes command-line tool retrieves information about a running pod.""\n  }\n]', '[\n  {\n    ""source"": ""kubia-zxzij"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""is a"",\n    ""summary_er"": ""Kubia is a pod that runs a simple web server.""\n  }\n]', '[\n  {\n    ""source"": ""ui"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""is part of"",\n    ""summary_er"": ""The UI component is a part of the Pod, which is a containerized application in Kubernetes.""\n  },\n  {\n    ""source"": ""Shopping Cart"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""is part of"",\n    ""summary_er"": ""The Shopping Cart feature is integrated into the Pod, allowing users to manage their cart within the application.""\n  }\n]', '[\n  {\n    ""source"": ""app"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""runs in"",\n    ""summary_er"": ""An application (app) runs within a containerized environment provided by a pod, utilizing Kubernetes to manage and orchestrate resources.""\n  }\n]', '[\n  {\n    ""source"": ""sc"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""is a"",\n    ""summary_er"": ""The Service Controller manages and orchestrates pods in a Kubernetes cluster.""\n  }\n]', '[\n  {\n    ""source"": ""pc"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""is a"",\n    ""summary_er"": ""The Product Catalog is a type of containerized application in Kubernetes, utilizing Docker for deployment and management.""\n  }\n]', '[\n  {\n    ""source"": ""kubectl"",\n    ""destination"": ""pods"",\n    ""relation_description"": ""displays"",\n    ""summary_er"": ""Kubernetes command to display running pods, providing their status and other details.""\n  },\n  {\n    ""source"": ""pods"",\n    ""destination"": ""STATUS"",\n    ""relation_description"": ""displays"",\n    ""summary_er"": ""Pods in a Kubernetes cluster have a status that indicates their current state, such as Running or Terminated.""\n  }\n]', '[\n  {\n    ""source"": ""kubectl"",\n    ""destination"": ""pods"",\n    ""relation_description"": ""get"",\n    ""summary_er"": ""Kubernetes command to retrieve a list of running pods, displaying their status and readiness.""\n  },\n  {\n    ""source"": ""pods"",\n    ""destination"": ""READY"",\n    ""relation_description"": ""status"",\n    ""summary_er"": ""Pods are reported as ready when they have completed initialization and are available for use.""\n  }\n]', '[\n  {\n    ""source"": ""kubia-zxzij"",\n    ""destination"": ""pod AGE"",\n    ""relation_description"": ""has"",\n    ""summary_er"": ""Kubernetes deployment \'kubia-zxzij\' has a pod named \'AGE\'.""\n  }\n]', '[\n  {\n    ""source"": ""Account Service"",\n    ""destination"": ""Pod"",\n    ""relation_description"": ""is a"",\n    ""summary_er"": ""The Account Service is an instance of a Pod, which is a containerized application running on Kubernetes.""\n  }\n]', '[\n  {\n    ""source"": ""Order Service"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""is a"",\n    ""summary_er"": ""The Order Service is a type of pod that handles order-related tasks.""\n  }\n]', '[\n  {\n    ""source"": ""Product Catalog"",\n    ""destination"": ""Product Information"",\n    ""relation_description"": ""contains"",\n    ""summary_er"": ""The Product Catalog contains detailed information about products, including product descriptions, images, and specifications.""\n  }\n]']","To delete all pods in a namespace, use the command $ kubectl delete po --all. This will delete all running and terminating pods in the current namespace. Alternatively, you can delete a specific pod by its name or delete all pods with a certain label using the label selector.",[{'highlight': 'You can delete a whole namespace using the command $ kubectl delete ns custom-namespace'}]
25,114,0,[],"82
CHAPTER 3
Pods: running containers in Kubernetes
Wait, what!?! The kubia-zxzij pod is terminating, but a new pod called kubia-09as0,
which wasn’t there before, has appeared. No matter how many times you delete all
pods, a new pod called kubia-something will emerge. 
 You may remember you created your first pod with the kubectl run command. In
chapter 2, I mentioned that this doesn’t create a pod directly, but instead creates a
ReplicationController, which then creates the pod. As soon as you delete a pod cre-
ated by the ReplicationController, it immediately creates a new one. To delete the
pod, you also need to delete the ReplicationController. 
3.8.5
Deleting (almost) all resources in a namespace
You can delete the ReplicationController and the pods, as well as all the Services
you’ve created, by deleting all resources in the current namespace with a single
command:
$ kubectl delete all --all
pod ""kubia-09as0"" deleted
replicationcontroller ""kubia"" deleted
service ""kubernetes"" deleted
service ""kubia-http"" deleted
The first all in the command specifies that you’re deleting resources of all types, and
the --all option specifies that you’re deleting all resource instances instead of speci-
fying them by name (you already used this option when you ran the previous delete
command).
NOTE
Deleting everything with the all keyword doesn’t delete absolutely
everything. Certain resources (like Secrets, which we’ll introduce in chapter 7)
are preserved and need to be deleted explicitly.
As it deletes resources, kubectl will print the name of every resource it deletes. In the
list, you should see the kubia ReplicationController and the kubia-http Service you
created in chapter 2. 
NOTE
The kubectl delete all --all command also deletes the kubernetes
Service, but it should be recreated automatically in a few moments.
3.9
Summary
After reading this chapter, you should now have a decent knowledge of the central
building block in Kubernetes. Every other concept you’ll learn about in the next few
chapters is directly related to pods. 
 In this chapter, you’ve learned
How to decide whether certain containers should be grouped together in a pod
or not.
 
",[],"[{'entity': 'Pod', 'description': 'running containers in Kubernetes', 'category': 'software'}, {'entity': 'ReplicationController', 'description': 'creates and manages pods in Kubernetes', 'category': 'software'}, {'entity': 'kubectl', 'description': 'command-line tool for interacting with Kubernetes', 'category': 'software'}, {'entity': 'Service', 'description': 'exposes an application running in a pod to the network', 'category': 'software'}, {'entity': 'Secrets', 'description': 'store sensitive information, like passwords or API keys', 'category': 'software'}, {'entity': 'namespace', 'description': 'logical grouping of resources in Kubernetes', 'category': 'software'}, {'entity': 'kubia-zxzij', 'description': 'pod name', 'category': 'software'}, {'entity': 'kubia-09as0', 'description': 'pod name', 'category': 'software'}, {'entity': 'kubia-something', 'description': 'pod name', 'category': 'software'}, {'entity': 'kubernetes Service', 'description': 'system service that provides a network interface for pods', 'category': 'software'}, {'entity': 'kubia-http Service', 'description': 'service that exposes the kubia application to the network', 'category': 'software'}]","[{'source_entity': 'Kubernetes Service', 'description': 'provides a network identity and load-balancing for the kubia-something Pod.', 'destination_entity': 'kubia-something'}, {'source_entity': 'ReplicationController', 'description': 'ensures that at least one instance of the kubia-http Service is running.', 'destination_entity': 'kubia-http Service'}, {'source_entity': 'kubectl', 'description': 'manages and configures the namespace for the kubia-zxzij Pod.', 'destination_entity': 'namespace'}, {'source_entity': 'Service', 'description': 'exposes the kubia-09as0 Pod to the outside world.', 'destination_entity': 'kubia-09as0'}, {'source_entity': 'Pod', 'description': 'runs a container with the kubia-http Service image.', 'destination_entity': 'kubia-http Service'}, {'source_entity': 'kubectl', 'description': 'manages and configures the Secrets for the kubia-zxzij Pod.', 'destination_entity': 'Secrets'}, {'source_entity': 'ReplicationController', 'description': 'ensures that at least one instance of the kubia-something Pod is running.', 'destination_entity': 'kubia-something'}, {'source_entity': 'Kubernetes Service', 'description': 'provides a network identity and load-balancing for the kubia-zxzij Pod.', 'destination_entity': 'kubia-zxzij'}]","['[\n  {\n    ""source"": ""Kubernetes Service"",\n    ""destination"": ""kubia-something"",\n    ""relation_description"": ""provides a network identity and load-balancing"",\n    ""summary_er"": ""The Kubernetes Service provides a network identity and load-balancing for the kubia-something Pod, ensuring efficient resource allocation.""\n  }\n]', '[\n  {\n    ""source"": ""ReplicationController"",\n    ""destination"": ""kubia-http Service"",\n    ""relation_description"": ""ensures that at least one instance of the kubia-http Service is running."",\n    ""summary_er"": ""The ReplicationController ensures a minimum number of kubia-http Service instances are running, guaranteeing availability.""\n  }\n]', '[\n  {\n    ""source"": ""kubectl"",\n    ""destination"": ""namespace"",\n    ""relation_description"": ""manages and configures"",\n    ""summary_er"": ""Kubectl manages and configures namespaces for Pods, ensuring proper resource allocation and access control.""\n  }\n]', '[\n  {\n    ""source"": ""Service"",\n    ""destination"": ""kubia-09as0"",\n    ""relation_description"": ""exposes the kubia-09as0 Pod to the outside world."",\n    ""summary_er"": ""A Service exposes a pod\'s IP address and port to the outside world, making it accessible from outside the cluster.""\n  }\n]', '[\n  {\n    ""source"": ""Pod"",\n    ""destination"": ""kubia-http Service"",\n    ""relation_description"": ""runs a container with the kubia-http Service image."",\n    ""summary_er"": ""A Pod runs a container with the kubia-http Service image, utilizing its functionality.""\n  }\n]', '[\n  {\n    ""source"": ""kubectl"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""manages and configures"",\n    ""summary_er"": ""Kubectl manages and configures pods, including the kubia-zxzij pod.""\n  },\n  {\n    ""source"": ""kubectl"",\n    ""destination"": ""Secrets"",\n    ""relation_description"": ""manages and configures"",\n    ""summary_er"": ""Kubectl manages and configures Secrets for the kubia-zxzij Pod.""\n  }\n]', '[\n  {\n    ""source"": ""ReplicationController"",\n    ""destination"": ""kubia-something"",\n    ""relation_description"": ""ensures that at least one instance of the Pod is running."",\n    ""summary_er"": ""The ReplicationController ensures a single kubia-something Pod is always running, maintaining availability.""\n  }\n]', '[\n  {\n    ""source"": ""Kubernetes Service"",\n    ""destination"": ""kubia-zxzij Pod"",\n    ""relation_description"": ""provides a network identity and load-balancing"",\n    ""summary_er"": ""The Kubernetes Service provides a network identity and load-balancing for the kubia-zxzij Pod, ensuring efficient resource allocation.""\n  }\n]']","Kubernetes pods run multiple containers as one entity, with kubectl commands like run and delete creating ReplicationControllers that manage pods. Deleting all resources in a namespace can be done with kubectl delete all --all, but note that some resources like Secrets are preserved and need to be deleted explicitly.","[{'highlight': 'The kubia-zxzij pod is terminating, but a new pod called kubia-09as0, which wasn’t there before, has appeared.'}, {'highlight': 'To delete the pod, you also need to delete the ReplicationController.'}, {'highlight': 'You can delete the ReplicationController and the pods, as well as all the Services you’ve created, by deleting all resources in the current namespace with a single command: $ kubectl delete all --all'}, {'highlight': 'Deleting everything with the all keyword doesn’t delete absolutely everything. Certain resources (like Secrets) are preserved and need to be deleted explicitly.'}, {'highlight': 'Every other concept you’ll learn about in the next few chapters is directly related to pods.'}]"
26,115,0,[],"83
Summary
Pods can run multiple processes and are similar to physical hosts in the non-
container world.
YAML or JSON descriptors can be written and used to create pods and then
examined to see the specification of a pod and its current state.
Labels and label selectors should be used to organize pods and easily perform
operations on multiple pods at once.
You can use node labels and selectors to schedule pods only to nodes that have
certain features.
Annotations allow attaching larger blobs of data to pods either by people or
tools and libraries.
Namespaces can be used to allow different teams to use the same cluster as
though they were using separate Kubernetes clusters.
How to use the kubectl explain command to quickly look up the information
on any Kubernetes resource. 
In the next chapter, you’ll learn about ReplicationControllers and other resources
that manage pods.
 
",[],"[{'entity': 'Pods', 'description': 'can run multiple processes and are similar to physical hosts in the non-container world.', 'category': 'container'}, {'entity': 'YAML', 'description': 'or JSON descriptors can be written and used to create pods', 'category': 'format'}, {'entity': 'JSON', 'description': 'descriptors can be written and used to create pods', 'category': 'format'}, {'entity': 'Labels', 'description': 'and label selectors should be used to organize pods', 'category': 'metadata'}, {'entity': 'Label Selectors', 'description': 'should be used to organize pods and easily perform operations on multiple pods at once.', 'category': 'metadata'}, {'entity': 'Node Labels', 'description': 'and selectors can be used to schedule pods only to nodes that have certain features.', 'category': 'node'}, {'entity': 'Selectors', 'description': 'can be used to schedule pods only to nodes that have certain features.', 'category': 'node'}, {'entity': 'Annotations', 'description': 'allow attaching larger blobs of data to pods either by people or tools and libraries.', 'category': 'metadata'}, {'entity': 'Namespaces', 'description': 'can be used to allow different teams to use the same cluster as though they were using separate Kubernetes clusters.', 'category': 'cluster'}, {'entity': 'kubectl explain command', 'description': 'can be used to quickly look up the information on any Kubernetes resource.', 'category': 'command'}, {'entity': 'ReplicationControllers', 'description': 'manage pods and will be covered in the next chapter.', 'category': 'resource'}]","[{'source_entity': '""JSON""', 'description': 'used to describe and define', 'destination_entity': '""Labels""'}, {'source_entity': '""JSON""', 'description': 'used to describe and define', 'destination_entity': '""Selectors""'}, {'source_entity': '""kubectl explain command""', 'description': 'provides detailed information about', 'destination_entity': '""ReplicationControllers""'}, {'source_entity': '""kubectl explain command""', 'description': 'provides detailed information about', 'destination_entity': '""Pods""'}, {'source_entity': '""Labels""', 'description': 'used to identify and select', 'destination_entity': '""Node Labels""'}, {'source_entity': '""Selectors""', 'description': 'used to select and filter', 'destination_entity': '""Pods""'}, {'source_entity': '""kubectl explain command""', 'description': 'provides detailed information about', 'destination_entity': '""YAML""'}, {'source_entity': '""Annotations""', 'description': 'used to add additional metadata', 'destination_entity': '""Pods""'}, {'source_entity': '""Namespaces""', 'description': 'used to group and isolate', 'destination_entity': '""ReplicationControllers""'}, {'source_entity': '""Label Selectors""', 'description': 'used to select and filter', 'destination_entity': '""Pods""'}]","['[\n  {\n    ""source"": ""JSON"",\n    ""destination"": ""Pod"",\n    ""relation_description"": ""used to describe and define"",\n    ""summary_er"": ""JSON is used to describe and define a Pod\'s properties, such as labels and annotations.""\n  },\n  {\n    ""source"": ""Labels"",\n    ""destination"": ""Pod"",\n    ""relation_description"": ""metadata attribute"",\n    ""summary_er"": ""Labels are metadata attributes that can be attached to a Pod to provide additional context and information.""\n  }\n]', '[\n  {\n    ""source"": ""JSON"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""used to describe and define"",\n    ""summary_er"": ""JSON is used to describe and define pods in Kubernetes, specifying labels and selectors for resource management.""\n  },\n  {\n    ""source"": ""Selectors"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""labels and annotations"",\n    ""summary_er"": ""Selectors are used to label and annotate pods in Kubernetes, enabling efficient resource allocation and management based on specific criteria.""\n  }\n]', '[\n  {\n    ""source"": ""kubectl explain command"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""provides detailed information about"",\n    ""summary_er"": ""The \'kubectl explain\' command provides a detailed description of Kubernetes resources, including pods, replication controllers, and services.""\n  },\n  {\n    ""source"": ""ReplicationControllers"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""manages"",\n    ""summary_er"": ""Replication Controllers manage multiple replicas of a pod to ensure high availability and scalability in a Kubernetes cluster.""\n  }\n]', '[\n  {\n    ""source"": ""kubectl explain command"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""provides detailed information about"",\n    ""summary_er"": ""The \'kubectl explain\' command provides in-depth details about Kubernetes resources, including pods, services, and more.""\n  }\n]', '[\n  {\n    ""source"": ""Labels"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""used to identify and select"",\n    ""summary_er"": ""Labels are used to identify and select pods in a Kubernetes cluster, allowing for efficient management and scaling.""\n  },\n  {\n    ""source"": ""Node Labels"",\n    ""destination"": ""node"",\n    ""relation_description"": ""used to identify and select"",\n    ""summary_er"": ""Node labels are used to identify and select nodes in a Kubernetes cluster, enabling targeted management and maintenance.""\n  }\n]', '[\n  {\n    ""source"": ""Selectors"",\n    ""destination"": ""Pods"",\n    ""relation_description"": ""used to select and filter"",\n    ""summary_er"": ""Selectors are used in Kubernetes to filter and select pods based on specific criteria, such as labels or annotations.""\n  }\n]', '[\n  {\n    ""source"": ""kubectl explain command"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""provides detailed information about"",\n    ""summary_er"": ""The \'kubectl explain\' command provides a detailed description of Kubernetes resources, including pods, services, and more.""\n  }\n]', '[\n  {\n    ""source"": ""Annotations"",\n    ""destination"": ""Pods"",\n    ""relation_description"": ""used to add additional metadata"",\n    ""summary_er"": ""Annotations are used to add extra information to a pod, such as labels and notes.""\n  }\n]', '[\n  {\n    ""source"": ""Namespaces"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""used to group and isolate"",\n    ""summary_er"": ""Namespaces are used to group and isolate pods, ensuring each pod has its own isolated network space.""\n  },\n  {\n    ""source"": ""ReplicationControllers"",\n    ""destination"": ""pod"",\n    ""relation_description"": """",\n    ""summary_er"": ""Replication Controllers ensure a specified number of identical pods are running at any given time.""\n  }\n]', '[\n  {\n    ""source"": ""Label Selectors"",\n    ""destination"": ""Pods"",\n    ""relation_description"": ""used to select and filter"",\n    ""summary_er"": ""Label Selectors are used to identify and filter Pods based on specific labels, allowing for targeted resource management and deployment.""\n  }\n]']","Pods can run multiple processes similar to physical hosts. They have YAML/JSON descriptors that define their specification and current state. Labels and selectors help organize and perform operations on multiple pods. Annotations attach data to pods, while namespaces allow different teams to use the same cluster as separate Kubernetes clusters. The kubectl explain command provides information on resources.","[{'highlight': 'Pods can run multiple processes and are similar to physical hosts in the non-container world.'}, {'highlight': 'YAML or JSON descriptors can be written and used to create pods and then examined to see the specification of a pod and its current state.'}, {'highlight': 'Labels and label selectors should be used to organize pods and easily perform operations on multiple pods at once.'}, {'highlight': 'Namespaces can be used to allow different teams to use the same cluster as though they were using separate Kubernetes clusters.'}, {'highlight': 'Annotations allow attaching larger blobs of data to pods either by people or tools and libraries.'}]"
27,116,0,[],"84
Replication and other
controllers: deploying
managed pods
As you’ve learned so far, pods represent the basic deployable unit in Kubernetes.
You know how to create, supervise, and manage them manually. But in real-world
use cases, you want your deployments to stay up and running automatically and
remain healthy without any manual intervention. To do this, you almost never cre-
ate pods directly. Instead, you create other types of resources, such as Replication-
Controllers or Deployments, which then create and manage the actual pods.
 When you create unmanaged pods (such as the ones you created in the previ-
ous chapter), a cluster node is selected to run the pod and then its containers are
run on that node. In this chapter, you’ll learn that Kubernetes then monitors
This chapter covers
Keeping pods healthy
Running multiple instances of the same pod
Automatically rescheduling pods after a node fails
Scaling pods horizontally
Running system-level pods on each cluster node
Running batch jobs
Scheduling jobs to run periodically or once in 
the future
 
",[],"[{'entity': 'Kubernetes', 'description': 'container orchestration system', 'category': 'software'}, {'entity': 'pods', 'description': 'basic deployable unit in Kubernetes', 'category': 'application'}, {'entity': 'Replication-Controllers', 'description': 'resource that creates and manages pods', 'category': 'application'}, {'entity': 'Deployments', 'description': 'resource that creates and manages pods', 'category': 'application'}, {'entity': 'cluster node', 'description': 'physical or virtual machine running Kubernetes', 'category': 'hardware'}, {'entity': 'containers', 'description': 'lightweight and standalone execution environment for applications', 'category': 'software'}, {'entity': 'Replication and other controllers', 'description': 'managed resources that create and manage pods', 'category': 'application'}, {'entity': 'Deployments', 'description': 'resource that creates and manages pods', 'category': 'application'}, {'entity': 'pods', 'description': 'basic deployable unit in Kubernetes', 'category': 'application'}, {'entity': 'node failure', 'description': 'event where a cluster node fails or becomes unavailable', 'category': 'hardware'}, {'entity': 'horizontal scaling', 'description': 'process of increasing the number of pods to meet demand', 'category': 'process'}, {'entity': 'system-level pods', 'description': 'pods that run on each cluster node and provide system services', 'category': 'application'}, {'entity': 'batch jobs', 'description': 'short-lived, non-interactive processes that perform a specific task', 'category': 'application'}, {'entity': 'scheduling jobs', 'description': 'process of running batch jobs periodically or once in the future', 'category': 'process'}]","[{'source_entity': '""node failure""', 'description': 'causes', 'destination_entity': '""cluster node""'}, {'source_entity': '""Replication and other controllers""', 'description': 'manage', 'destination_entity': '""pods""'}, {'source_entity': '""Replication and other controllers""', 'description': 'scale', 'destination_entity': '""horizontal scaling""'}, {'source_entity': '""scheduling jobs""', 'description': 'schedule', 'destination_entity': '""batch jobs""'}, {'source_entity': '""Kubernetes""', 'description': 'orchestrate', 'destination_entity': '""Deployments""'}, {'source_entity': '""Kubernetes""', 'description': 'manage', 'destination_entity': '""Replication-Controllers""'}, {'source_entity': '""system-level pods""', 'description': 'run', 'destination_entity': '""containers""'}]","['[\n  {\n    ""source"": ""node failure"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""causes"",\n    ""summary_er"": ""Node failures can cause pods to malfunction or become unresponsive due to loss of resources and dependencies.""\n  }\n]', '[\n  {\n    ""source"": ""Replication and other controllers"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""manage"",\n    ""summary_er"": ""Replication controllers manage the lifecycle of pods, ensuring they are created, updated, and deleted as needed.""\n  }\n]', '[\n  {\n    ""source"": ""Replication and other controllers"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""scale"",\n    ""summary_er"": ""Controllers manage pod replication by scaling up or down to meet demand, ensuring efficient resource utilization.""\n  },\n  {\n    ""source"": ""horizontal scaling"",\n    ""destination"": ""pod"",\n    ""relation_description"": """",\n    ""summary_er"": ""Horizontal scaling involves creating multiple replicas of a pod to distribute workload and improve performance.""\n  }\n]', '[\n  {\n    ""source"": ""scheduling jobs"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""schedule"",\n    ""summary_er"": ""Scheduling jobs involves assigning tasks to a pod, which is a containerized unit of execution in Kubernetes. This process ensures efficient resource utilization and streamlined job processing.""\n  }\n]', '[\n  {\n    ""source"": ""Kubernetes"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""orchestrate"",\n    ""summary_er"": ""Kubernetes orchestrates pods, managing containerized applications across clusters.""\n  },\n  {\n    ""source"": ""Deployments"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""managed by"",\n    ""summary_er"": ""Deployments manage and update pods in a Kubernetes cluster, ensuring consistent application state.""\n  }\n]', '[\n  {\n    ""source"": ""Kubernetes"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""manage"",\n    ""summary_er"": ""Kubernetes manages pods by ensuring they are running the correct number of replicas.""\n  }\n]', '[\n  {\n    ""source"": ""system-level pods"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""run"",\n    ""summary_er"": ""System-level pods execute containers within a Kubernetes cluster.""\n  }\n]']","Kubernetes manages pods automatically, using resources like Replication-Controllers and Deployments to create and manage pods. This chapter focuses on keeping pods healthy, running multiple instances of the same pod, automating rescheduling after a node fails, scaling pods horizontally, running system-level pods, and batch jobs, as well as scheduling periodic or future tasks.","[{'highlight': 'You almost never create pods directly, instead you create other types of resources such as Replication-Controllers or Deployments which then create and manage the actual pods.'}, {'highlight': 'Kubernetes monitors the cluster node where a pod is running and automatically reschedules it if the node fails.'}, {'highlight': 'This chapter covers keeping pods healthy, running multiple instances of the same pod, automatically rescheduling pods after a node fails, scaling pods horizontally, running system-level pods on each cluster node, running batch jobs, and scheduling jobs to run periodically or once in the future.'}, {'highlight': 'Replication-Controllers and Deployments are used to create and manage managed pods which stay up and running automatically without any manual intervention.'}, {'highlight': 'Pods represent the basic deployable unit in Kubernetes and can be created manually, but in real-world use cases, they are usually created by other types of resources such as Replication-Controllers or Deployments.'}]"
28,117,0,[],"85
Keeping pods healthy
those containers and automatically restarts them if they fail. But if the whole node
fails, the pods on the node are lost and will not be replaced with new ones, unless
those pods are managed by the previously mentioned ReplicationControllers or simi-
lar. In this chapter, you’ll learn how Kubernetes checks if a container is still alive and
restarts it if it isn’t. You’ll also learn how to run managed pods—both those that run
indefinitely and those that perform a single task and then stop. 
4.1
Keeping pods healthy
One of the main benefits of using Kubernetes is the ability to give it a list of contain-
ers and let it keep those containers running somewhere in the cluster. You do this by
creating a Pod resource and letting Kubernetes pick a worker node for it and run
the pod’s containers on that node. But what if one of those containers dies? What if
all containers of a pod die? 
 As soon as a pod is scheduled to a node, the Kubelet on that node will run its con-
tainers and, from then on, keep them running as long as the pod exists. If the con-
tainer’s main process crashes, the Kubelet will restart the container. If your
application has a bug that causes it to crash every once in a while, Kubernetes will
restart it automatically, so even without doing anything special in the app itself, run-
ning the app in Kubernetes automatically gives it the ability to heal itself. 
 But sometimes apps stop working without their process crashing. For example, a
Java app with a memory leak will start throwing OutOfMemoryErrors, but the JVM
process will keep running. It would be great to have a way for an app to signal to
Kubernetes that it’s no longer functioning properly and have Kubernetes restart it. 
 We’ve said that a container that crashes is restarted automatically, so maybe you’re
thinking you could catch these types of errors in the app and exit the process when
they occur. You can certainly do that, but it still doesn’t solve all your problems. 
 For example, what about those situations when your app stops responding because
it falls into an infinite loop or a deadlock? To make sure applications are restarted in
such cases, you must check an application’s health from the outside and not depend
on the app doing it internally. 
4.1.1
Introducing liveness probes
Kubernetes can check if a container is still alive through liveness probes. You can specify
a liveness probe for each container in the pod’s specification. Kubernetes will periodi-
cally execute the probe and restart the container if the probe fails. 
NOTE
Kubernetes also supports readiness probes, which we’ll learn about in the
next chapter. Be sure not to confuse the two. They’re used for two different
things.
Kubernetes can probe a container using one of the three mechanisms:
An HTTP GET probe performs an HTTP GET request on the container’s IP
address, a port and path you specify. If the probe receives a response, and the
 
",[],"[{'entity': 'Kubernetes', 'description': 'Container orchestration system', 'category': 'software'}, {'entity': 'Pods', 'description': 'Lightweight and portable container', 'category': 'container'}, {'entity': 'ReplicationControllers', 'description': 'Controller for managing multiple replicas of a pod', 'category': 'application'}, {'entity': 'Kubelet', 'description': 'Agent that runs on each node in the cluster', 'category': 'process'}, {'entity': 'Containers', 'description': 'Lightweight and portable executable package', 'category': 'container'}, {'entity': 'OOM Killer', 'description': 'Process that kills processes consuming excessive memory', 'category': 'process'}, {'entity': 'OutOfMemoryErrors', 'description': 'Error thrown when a process consumes excessive memory', 'category': 'error'}, {'entity': 'Java app', 'description': 'Example application with a memory leak', 'category': 'application'}, {'entity': 'JVM', 'description': 'Java Virtual Machine', 'category': 'process'}, {'entity': 'Liveness probes', 'description': 'Mechanism for checking if a container is still alive', 'category': 'feature'}, {'entity': 'Readiness probes', 'description': 'Mechanism for checking if a container is ready to receive traffic', 'category': 'feature'}, {'entity': 'HTTP GET probe', 'description': 'Type of liveness probe that performs an HTTP GET request', 'category': 'mechanism'}]","[{'source_entity': '""Java app""', 'description': 'causes', 'destination_entity': '""OutOfMemoryErrors""'}, {'source_entity': '""ReplicationControllers""', 'description': 'manages', 'destination_entity': '""Pods""'}, {'source_entity': '""OOM Killer""', 'description': 'kills', 'destination_entity': '""Containers""'}, {'source_entity': '""Kubelet""', 'description': 'monitors', 'destination_entity': '""Readiness probes""'}, {'source_entity': '""Java app""', 'description': 'experiences', 'destination_entity': '""OutOfMemoryErrors""'}, {'source_entity': '""OOM Killer""', 'description': 'terminates', 'destination_entity': '""Pods""'}, {'source_entity': '""Kubernetes""', 'description': 'utilizes', 'destination_entity': '""ReplicationControllers""'}, {'source_entity': '""Java app""', 'description': 'uses', 'destination_entity': '""Containers""'}, {'source_entity': '""OOM Killer""', 'description': 'detects', 'destination_entity': '""OutOfMemoryErrors""'}, {'source_entity': '""Kubelet""', 'description': 'executes', 'destination_entity': '""Liveness probes""'}]","['[\n  {\n    ""source"": ""Java app"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""causes"",\n    ""summary_er"": ""A Java application can cause a pod to run out of memory, leading to OutOfMemoryErrors.""\n  }\n]', '[\n  {\n    ""source"": ""ReplicationControllers"",\n    ""destination"": ""Pods"",\n    ""relation_description"": ""manages"",\n    ""summary_er"": ""Replication Controllers manage multiple Pods, ensuring a specified number of replicas are running at any given time.""\n  }\n]', '[\n  {\n    ""source"": ""OOM Killer"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""kills"",\n    ""summary_er"": ""The OOM Killer is a process that terminates a container when it exceeds its allocated memory, preventing an Out-Of-Memory (OOM) condition.""\n  }\n]', '[\n  {\n    ""source"": ""Kubelet"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""monitors"",\n    ""summary_er"": ""Kubelet continuously monitors the readiness of pods to ensure they are functioning correctly before scheduling them for execution.""\n  }\n]', '[\n  {\n    ""source"": ""Java app"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""experiences"",\n    ""summary_er"": ""A Java application experiences issues when running within a Kubernetes pod, potentially due to OutOfMemoryErrors.""\n  },\n  {\n    ""source"": ""OutOfMemoryErrors"",\n    ""destination"": ""Java app"",\n    ""relation_description"": ""causes"",\n    ""summary_er"": ""OutOfMemoryErrors in a Java application can cause performance degradation and crashes, requiring memory optimization and tuning.""\n  }\n]', '[\n  {\n    ""source"": ""OOM Killer"",\n    ""destination"": ""Pods"",\n    ""relation_description"": ""terminates"",\n    ""summary_er"": ""The OOM (Out Of Memory) Killer is a process that terminates pods when the system runs out of memory, preventing resource starvation and ensuring system stability.""\n  }\n]', '[\n  {\n    ""source"": ""Kubernetes"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""utilizes"",\n    ""summary_er"": ""Kubernetes manages and orchestrates containerized applications, utilizing pods as the basic execution unit.""\n  }\n]', '[\n  {\n    ""source"": ""Java app"",\n    ""destination"": ""Pod"",\n    ""relation_description"": ""uses"",\n    ""summary_er"": ""A Java application utilizes a containerized environment, leveraging the \'uses\' relation to interact with a pod in Kubernetes.""\n  }\n]', '[\n  {\n    ""source"": ""OOM Killer"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""detects"",\n    ""summary_er"": ""The OOM Killer is a mechanism in Kubernetes that detects and terminates pods consuming excessive memory, preventing OutOfMemoryErrors.""\n  }\n]', '[\n  {\n    ""source"": ""Kubelet"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""executes"",\n    ""summary_er"": ""The Kubelet executes a pod, which is a containerized application.""\n  }\n]']","Kubernetes checks if a container is alive through liveness probes and restarts it if it fails. Liveness probes can be specified for each container in a pod's specification. Kubernetes periodically executes the probe and restarts the container if it fails. This ensures that applications are restarted even if they stop working without crashing, such as due to memory leaks or infinite loops.","[{'highlight': 'Kubernetes can automatically restart containers that crash or fail, but if the whole node fails, pods on the node are lost unless managed by ReplicationControllers.'}, {'highlight': ""Liveness probes allow Kubernetes to check if a container is still alive and restart it if it isn't, providing a way to heal applications that stop working without crashing.""}, {'highlight': 'Kubernetes supports three mechanisms for probing containers: HTTP GET probe, TCP socket probe, and executable probe.'}, {'highlight': 'Liveness probes can be used to restart applications that fall into infinite loops or deadlocks, providing a way to ensure application health from the outside.'}, {'highlight': 'Readiness probes are supported by Kubernetes for checking if a container is ready to receive traffic, which will be covered in the next chapter.'}]"
29,118,0,[],"86
CHAPTER 4
Replication and other controllers: deploying managed pods
response code doesn’t represent an error (in other words, if the HTTP response
code is 2xx or 3xx), the probe is considered successful. If the server returns an
error response code or if it doesn’t respond at all, the probe is considered a fail-
ure and the container will be restarted as a result.
A TCP Socket probe tries to open a TCP connection to the specified port of the
container. If the connection is established successfully, the probe is successful.
Otherwise, the container is restarted.
An Exec probe executes an arbitrary command inside the container and checks
the command’s exit status code. If the status code is 0, the probe is successful.
All other codes are considered failures. 
4.1.2
Creating an HTTP-based liveness probe
Let’s see how to add a liveness probe to your Node.js app. Because it’s a web app, it
makes sense to add a liveness probe that will check whether its web server is serving
requests. But because this particular Node.js app is too simple to ever fail, you’ll need
to make the app fail artificially. 
 To properly demo liveness probes, you’ll modify the app slightly and make it
return a 500 Internal Server Error HTTP status code for each request after the fifth
one—your app will handle the first five client requests properly and then return an
error on every subsequent request. Thanks to the liveness probe, it should be restarted
when that happens, allowing it to properly handle client requests again.
 You can find the code of the new app in the book’s code archive (in the folder
Chapter04/kubia-unhealthy). I’ve pushed the container image to Docker Hub, so you
don’t need to build it yourself. 
 You’ll create a new pod that includes an HTTP GET liveness probe. The following
listing shows the YAML for the pod.
apiVersion: v1
kind: pod
metadata:
  name: kubia-liveness
spec:
  containers:
  - image: luksa/kubia-unhealthy   
    name: kubia
    livenessProbe:                 
      httpGet:                     
        path: /                     
        port: 8080       
Listing 4.1
Adding a liveness probe to a pod: kubia-liveness-probe.yaml
This is the image 
containing the 
(somewhat) 
broken app.
A liveness probe that will 
perform an HTTP GET
The path to 
request in the 
HTTP request
The network port
the probe should
connect to
 
",[],"[{'entity': 'TCP Socket', 'description': 'A type of probe that tries to open a TCP connection to the specified port of the container.', 'category': 'process'}, {'entity': 'Exec probe', 'description': ""A type of probe that executes an arbitrary command inside the container and checks the command's exit status code."", 'category': 'process'}, {'entity': 'HTTP GET liveness probe', 'description': 'A type of probe that performs an HTTP GET request to check whether a web server is serving requests.', 'category': 'process'}, {'entity': 'livenessProbe', 'description': 'A field in the pod specification that defines a liveness probe for the container.', 'category': 'field'}, {'entity': 'httpGet', 'description': 'A sub-field of livenessProbe that defines an HTTP GET request to be performed as part of the liveness probe.', 'category': 'sub-field'}, {'entity': 'path', 'description': 'A field in httpGet that specifies the path to be requested in the HTTP GET request.', 'category': 'field'}, {'entity': 'port', 'description': 'A field in httpGet that specifies the network port to which the probe should connect.', 'category': 'field'}, {'entity': 'apiVersion', 'description': 'A field in the pod specification that defines the API version of the object.', 'category': 'field'}, {'entity': 'kind', 'description': 'A field in the pod specification that defines the type of object being created.', 'category': 'field'}, {'entity': 'metadata', 'description': 'A field in the pod specification that contains metadata about the object.', 'category': 'field'}, {'entity': 'name', 'description': 'A sub-field of metadata that specifies the name of the pod.', 'category': 'sub-field'}, {'entity': 'spec', 'description': 'A field in the pod specification that defines the specifications for the container.', 'category': 'field'}, {'entity': 'containers', 'description': 'A sub-field of spec that lists the containers to be created.', 'category': 'sub-field'}, {'entity': 'image', 'description': 'A field in containers that specifies the image to be used for the container.', 'category': 'field'}, {'entity': 'name', 'description': 'A sub-field of containers that specifies the name of the container.', 'category': 'sub-field'}]","[{'source_entity': '""image""', 'description': 'is used to store', 'destination_entity': '""containers""'}, {'source_entity': '""HTTP GET liveness probe""', 'description': 'is used to check the health of', 'destination_entity': '""livenessProbe""'}, {'source_entity': '""Exec probe""', 'description': 'is used to execute a command and check the health of', 'destination_entity': '""containers""'}, {'source_entity': '""apiVersion""', 'description': 'specifies the version of the Kubernetes API', 'destination_entity': '""kind""'}, {'source_entity': '""spec""', 'description': 'defines the specifications for', 'destination_entity': '""containers""'}, {'source_entity': '""path""', 'description': 'specifies the path to', 'destination_entity': '""metadata""'}, {'source_entity': '""containers""', 'description': 'are used to store', 'destination_entity': '""image""'}, {'source_entity': '""kind""', 'description': 'specifies the type of Kubernetes resource', 'destination_entity': '""apiVersion""'}, {'source_entity': '""name""', 'description': 'gives a name to', 'destination_entity': '""containers""'}, {'source_entity': '""port""', 'description': 'specifies the port number for', 'destination_entity': '""httpGet""'}, {'source_entity': '""httpGet""', 'description': 'is used to make an HTTP GET request to', 'destination_entity': '""livenessProbe""'}, {'source_entity': '""TCP Socket""', 'description': 'is used to establish a connection with', 'destination_entity': '""metadata""'}]","['[\n  {\n    ""source"": ""image"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""is used to store"",\n    ""summary_er"": ""An image is a containerized application that stores data, and it is used in conjunction with a pod to run an application.""\n  },\n  {\n    ""source"": ""containers"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""stores"",\n    ""summary_er"": ""A container holds an application\'s code and dependencies, and it is stored within a pod to ensure efficient resource utilization.""\n  }\n]', '[\n  {\n    ""source"": ""HTTP GET liveness probe"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""is used to check the health of"",\n    ""summary_er"": ""The HTTP GET liveness probe is a mechanism to verify the pod\'s health by sending an HTTP request.""\n  }\n]', '[\n  {\n    ""source"": ""Exec probe"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""is used to execute a command and check the health of"",\n    ""summary_er"": ""Exec probe is used to run a command on a pod to verify its health, ensuring it\'s functioning correctly.""\n  }\n]', '[\n  {\n    ""source"": ""Kubernetes API"",\n    ""destination"": ""Pod"",\n    ""relation_description"": ""specifies the version of the Kubernetes API"",\n    ""summary_er"": ""The Kubernetes API version is specified for a pod, enabling communication between the pod and the API.""\n  },\n  {\n    ""source"": ""Kubernetes API"",\n    ""destination"": ""kind"",\n    ""relation_description"": ""defines the type of resource being described"",\n    ""summary_er"": ""The kind field in Kubernetes specifies the type of resource being described, such as a pod or deployment.""\n  }\n]', '[\n  {\n    ""source"": ""spec"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""defines the specifications for"",\n    ""summary_er"": ""The spec entity defines the specifications that are used to create a pod in Kubernetes.""\n  },\n  {\n    ""source"": ""spec"",\n    ""destination"": ""containers"",\n    ""relation_description"": ""defines the containers for"",\n    ""summary_er"": ""The spec entity defines the containers that are part of a pod in Kubernetes.""\n  }\n]', '[\n  {\n    ""source"": ""path"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""specifies the path to"",\n    ""summary_er"": ""The path attribute specifies the path to a Kubernetes pod, which is an essential component of a containerized application.""\n  },\n  {\n    ""source"": ""metadata"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""containerized application"",\n    ""summary_er"": ""Metadata provides information about a Kubernetes pod, including its name, namespace, and labels, making it easier to manage and monitor the application.""\n  }\n]', '[\n  {\n    ""source"": ""containers"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""are used to store"",\n    ""summary_er"": ""Containers are used to store images in a pod, allowing for efficient deployment and management of applications.""\n  },\n  {\n    ""source"": ""image"",\n    ""destination"": ""container"",\n    ""relation_description"": """",\n    ""summary_er"": ""An image is a template that defines the container\'s configuration, including its operating system, libraries, and application code.""\n  }\n]', '[\n  {\n    ""source"": ""Kubernetes Resource"",\n    ""destination"": ""Pod"",\n    ""relation_description"": ""specifies the type of Kubernetes resource"",\n    ""summary_er"": ""The source entity is a Kubernetes resource, which specifies its type. The destination entity is a Pod, which is a containerized application.""\n  },\n  {\n    ""source"": ""Kubernetes Resource"",\n    ""destination"": ""Pod"",\n    ""relation_description"": ""specifies the type of Kubernetes resource"",\n    ""summary_er"": ""The source entity is a Kubernetes resource, which specifies its type. The destination entity is a Pod, which is a containerized application.""\n  },\n  {\n    ""source"": ""API Version"",\n    ""destination"": ""Pod"",\n    ""relation_description"": ""specifies the API version of Kubernetes resource"",\n    ""summary_er"": ""The source entity is an API Version, which specifies the version of the Kubernetes resource. The destination entity is a Pod, which is a containerized application.""\n  }\n]', '[\n  {\n    ""source"": ""name"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""gives a name to"",\n    ""summary_er"": ""A Kubernetes pod\'s name is assigned by the user, providing a unique identifier for the containerized application.""\n  },\n  {\n    ""source"": ""containers"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""contains"",\n    ""summary_er"": ""A Kubernetes pod can contain one or more containers, which are the actual running applications within the pod.""\n  }\n]', '[\n  {\n    ""source"": ""pod"",\n    ""destination"": ""port"",\n    ""relation_description"": ""specifies the port number for"",\n    ""summary_er"": ""The source entity is a pod, which is a containerized application in Kubernetes. The destination entity is a port, which is used to expose a service on a specific network interface. The relation description specifies that this port is used by the pod.""\n  },\n  {\n    ""source"": ""pod"",\n    ""destination"": ""httpGet"",\n    ""relation_description"": ""exposes an HTTP endpoint for"",\n    ""summary_er"": ""The source entity is a pod, which is a containerized application in Kubernetes. The destination entity is an httpGet, which is used to expose an HTTP endpoint for the pod.""\n  }\n]', '[{\n  ""source"": ""httpGet"",\n  ""destination"": ""pod"",\n  ""relation_description"": ""is used to make an HTTP GET request to"",\n  ""summary_er"": ""The httpGet relation is used to send a GET request to a pod, allowing it to verify its liveness and readiness.""\n}]', '[\n  {\n    ""source"": ""TCP Socket"",\n    ""destination"": ""Pod"",\n    ""relation_description"": ""is used to establish a connection with"",\n    ""summary_er"": ""A TCP socket is used by a pod to establish a network connection, enabling communication between containers within the same pod or with other pods in the cluster.""\n  },\n  {\n    ""source"": ""metadata"",\n    ""destination"": ""Pod"",\n    ""relation_description"": ""is used to establish a connection with"",\n    ""summary_er"": ""Metadata is used by a pod to store and manage its configuration, labels, and annotations, providing essential information about the pod\'s identity and behavior.""\n  }\n]']","A liveness probe checks if a container is running correctly. A successful probe returns a 2xx or 3xx HTTP response code, while a failed probe returns an error code or no response at all. The chapter demonstrates creating a new pod with an HTTP GET liveness probe for a Node.js app that intentionally fails after five requests.","[{'highlight': ""A liveness probe is considered successful if the HTTP response code is 2xx or 3xx, otherwise it's a failure.""}, {'highlight': 'There are three types of probes: TCP Socket probe, Exec probe, and HTTP-based liveness probe.'}, {'highlight': 'A liveness probe can be added to a pod using YAML configuration, specifying the path, port, and command for the probe.'}, {'highlight': 'The liveness probe will restart the container if it fails, allowing it to properly handle client requests again.'}, {'highlight': 'A HTTP-based liveness probe can be used to check whether a web server is serving requests by sending an HTTP GET request and checking the response code.'}]"
