,page,img_cnt,img_npy_lst,text,tables,entities,relationships,summary_rel,summary,highlights
450,539,0,[],"507
Summary
Give you a few small tips on how to make your apps easier to manage by keep-
ing image sizes small, adding annotations and multi-dimensional labels to all
your resources, and making it easier to see why an application terminated.
Teach you how to develop Kubernetes apps and run them locally or in Mini-
kube before deploying them on a proper multi-node cluster.
In the next and final chapter, we’ll learn how you can extend Kubernetes with your
own custom API objects and controllers and how others have done it to create com-
plete Platform-as-a-Service solutions on top of Kubernetes.
 
",[],"[{'entity': 'image sizes', 'description': 'small image sizes for apps', 'category': 'software'}, {'entity': 'annotations', 'description': 'adding annotations to resources', 'category': 'software'}, {'entity': 'labels', 'description': 'multi-dimensional labels for resources', 'category': 'software'}, {'entity': 'Kubernetes', 'description': 'container orchestration system', 'category': 'software'}, {'entity': 'Mini-kube', 'description': 'local Kubernetes cluster', 'category': 'software'}, {'entity': 'API objects', 'description': 'custom API objects for Kubernetes', 'category': 'software'}, {'entity': 'controllers', 'description': 'custom controllers for Kubernetes', 'category': 'software'}, {'entity': 'Platform-as-a-Service', 'description': 'PaaS solutions on top of Kubernetes', 'category': 'software'}]","[{'source_entity': '""Mini-kube""', 'description': 'provides', 'destination_entity': '""Kubernetes""'}, {'source_entity': '""annotations""', 'description': 'are used to', 'destination_entity': '""API objects""'}, {'source_entity': '""image sizes""', 'description': 'can be managed by', 'destination_entity': '""controllers""'}, {'source_entity': '""Kubernetes""', 'description': 'is a', 'destination_entity': '""Platform-as-a-Service""'}, {'source_entity': '""labels""', 'description': 'are used to', 'destination_entity': '""API objects""'}]","['[\n  {\n    ""source"": ""Mini-kube"",\n    ""destination"": ""Pod"",\n    ""relation_description"": ""provides"",\n    ""summary_er"": ""Mini-kube, a lightweight version of Kubernetes, provides a pod for running containerized applications.""\n  }\n]', '[\n  {\n    ""source"": ""Kubernetes"",\n    ""destination"": ""Pod"",\n    ""relation_description"": ""are used to annotate"",\n    ""summary_er"": ""In Kubernetes, annotations are used to add metadata to API objects such as pods.""\n  },\n  {\n    ""source"": ""Docker"",\n    ""destination"": ""Container"",\n    ""relation_description"": ""is used to create"",\n    ""summary_er"": ""Docker is used to create containers that can run applications in a lightweight and portable way.""\n  }\n]', '[\n  {\n    ""source"": ""image sizes"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""can be managed by"",\n    ""summary_er"": ""Image sizes are managed by a pod, which is a containerized application that can run multiple containers.""\n  },\n  {\n    ""source"": ""controllers"",\n    ""destination"": ""pod"",\n    ""relation_description"": """",\n    ""summary_er"": ""Controllers manage pods, which are the basic execution unit in Kubernetes.""\n  }\n]', '[\n  {\n    ""source"": ""Kubernetes"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""is a"",\n    ""summary_er"": ""Kubernetes is a container orchestration platform that manages and runs pods, which are groups of one or more containers.""\n  },\n  {\n    ""source"": ""Kubernetes"",\n    ""destination"": ""Platform-as-a-Service"",\n    ""relation_description"": ""is a"",\n    ""summary_er"": ""Kubernetes is a type of Platform-as-a-Service (PaaS) that provides a managed environment for deploying and running applications.""\n  }\n]', '[\n  {\n    ""source"": ""Kubernetes"",\n    ""destination"": ""Pods"",\n    ""relation_description"": ""are used to"",\n    ""summary_er"": ""In Kubernetes, pods are the basic execution unit for containers. They provide a way to group one or more containers together and manage them as a single entity.""\n  },\n  {\n    ""source"": ""Docker"",\n    ""destination"": ""Containers"",\n    ""relation_description"": ""are used to"",\n    ""summary_er"": ""Docker is a containerization platform that allows developers to package their applications and dependencies into a single container, which can be run on any system with Docker installed.""\n  },\n  {\n    ""source"": ""Machine Learning"",\n    ""destination"": ""Models"",\n    ""relation_description"": ""are used for"",\n    ""summary_er"": ""In machine learning, models are trained on data to make predictions or classify inputs. They can be used for a wide range of tasks, from image classification to natural language processing.""\n  },\n  {\n    ""source"": ""Generative AI"",\n    ""destination"": ""Models"",\n    ""relation_description"": ""are used for"",\n    ""summary_er"": ""Generative AI models are trained on data to generate new, synthetic examples that resemble the original data. They can be used for tasks such as image and video generation.""\n  },\n  {\n    ""source"": ""Natural Language Understanding"",\n    ""destination"": ""Models"",\n    ""relation_description"": ""are used for"",\n    ""summary_er"": ""In natural language understanding, models are trained on text data to extract meaning and context. They can be used for tasks such as sentiment analysis and question answering.""\n  },\n  {\n    ""source"": ""Computer Vision"",\n    ""destination"": ""Models"",\n    ""relation_description"": ""are used for"",\n    ""summary_er"": ""In computer vision, models are trained on image data to extract features and make predictions. They can be used for tasks such as object detection and image classification.""\n  },\n  {\n    ""source"": ""Kubernetes"",\n    ""destination"": ""API objects"",\n    ""relation_description"": ""are part of"",\n    ""summary_er"": ""In Kubernetes, API objects are the building blocks of the system, providing a way to manage and interact with cluster resources such as pods, services, and persistent volumes.""\n  }\n]']","The document provides small tips for app management by keeping image sizes small, adding annotations and labels, and making termination reasons clear. It also teaches how to develop Kubernetes apps locally or in Mini-kube before deploying them on a multi-node cluster. Finally, it explains how to extend Kubernetes with custom API objects and controllers, enabling the creation of Platform-as-a-Service solutions.","[{'highlight': 'Keep image sizes small, add annotations and multi-dimensional labels to resources, and make it easier to see why an application terminated.'}]"
451,540,0,[],"508
Extending Kubernetes
You’re almost done. To wrap up, we’ll look at how you can define your own API
objects and create controllers for those objects. We’ll also look at how others have
extended Kubernetes and built Platform-as-a-Service solutions on top of it.
18.1
Defining custom API objects
Throughout the book, you’ve learned about the API objects that Kubernetes pro-
vides and how they’re used to build application systems. Currently, Kubernetes
users mostly use only these objects even though they represent relatively low-level,
generic concepts. 
This chapter covers
Adding custom objects to Kubernetes
Creating a controller for the custom object
Adding custom API servers
Self-provisioning of services with the Kubernetes 
Service Catalog
Red Hat’s OpenShift Container Platform
Deis Workflow and Helm
 
",[],"[{'entity': 'Kubernetes', 'description': 'container orchestration system', 'category': 'software'}, {'entity': 'API objects', 'description': 'customizable data structures in Kubernetes', 'category': 'software'}, {'entity': 'controllers', 'description': 'components that manage custom API objects', 'category': 'software'}, {'entity': 'Platform-as-a-Service (PaaS)', 'description': 'cloud computing model for deploying applications', 'category': 'application'}, {'entity': 'API servers', 'description': 'components that handle requests to custom API objects', 'category': 'software'}, {'entity': 'Service Catalog', 'description': 'Kubernetes feature for self-provisioning services', 'category': 'software'}, {'entity': 'OpenShift Container Platform', 'description': ""Red Hat's PaaS solution built on top of Kubernetes"", 'category': 'application'}, {'entity': 'Deis Workflow and Helm', 'description': 'tools for deploying applications to Kubernetes', 'category': 'software'}]","[{'source_entity': '""OpenShift Container Platform""', 'description': 'provides', 'destination_entity': '""API servers""'}, {'source_entity': '""OpenShift Container Platform""', 'description': 'supports', 'destination_entity': '""Platform-as-a-Service (PaaS)""'}, {'source_entity': '""API objects""', 'description': 'are managed by', 'destination_entity': '""controllers""'}, {'source_entity': '""OpenShift Container Platform""', 'description': 'integrates with', 'destination_entity': '""Service Catalog""'}, {'source_entity': '""Kubernetes""', 'description': 'is used by', 'destination_entity': '""OpenShift Container Platform""'}, {'source_entity': '""Deis Workflow and Helm""', 'description': 'are supported by', 'destination_entity': '""OpenShift Container Platform""'}, {'source_entity': '""API servers""', 'description': 'expose', 'destination_entity': '""API objects""'}]","['[\n  {\n    ""source"": ""OpenShift Container Platform"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""provides"",\n    ""summary_er"": ""OpenShift Container Platform provides a container runtime environment for pods, enabling scalable and efficient application deployment.""\n  }\n]', '[\n  {\n    ""source"": ""OpenShift Container Platform"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""supports"",\n    ""summary_er"": ""OpenShift Container Platform supports deployment and management of pods, providing a scalable and secure environment for applications.""\n  },\n  {\n    ""source"": ""OpenShift Container Platform"",\n    ""destination"": ""Platform-as-a-Service (PaaS)"",\n    ""relation_description"": ""is"",\n    ""summary_er"": ""OpenShift Container Platform is a PaaS that provides a managed application platform, enabling developers to focus on writing code rather than managing infrastructure.""\n  }\n]', '[\n  {\n    ""source"": ""API objects"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""are managed by"",\n    ""summary_er"": ""API objects are managed by pods, which are the basic execution unit in Kubernetes.""\n  },\n  {\n    ""source"": ""controllers"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""controllers"",\n    ""summary_er"": ""Controllers manage and orchestrate pods, ensuring they run as expected and scale accordingly.""\n  }\n]', '[\n  {\n    ""source"": ""OpenShift Container Platform"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""integrates with"",\n    ""summary_er"": ""OpenShift Container Platform integrates with pods to provide a scalable and secure environment for containerized applications.""\n  },\n  {\n    ""source"": ""Service Catalog"",\n    ""destination"": ""OpenShift Container Platform"",\n    ""relation_description"": ""integrated into"",\n    ""summary_er"": ""Service Catalog is integrated into OpenShift Container Platform to enable users to discover, select, and bind services to their applications.""\n  }\n]', '[\n  {\n    ""source"": ""Kubernetes"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""is used by"",\n    ""summary_er"": ""Kubernetes is a container orchestration system that automates pod management, ensuring efficient resource utilization and scalability.""\n  },\n  {\n    ""source"": ""OpenShift Container Platform"",\n    ""destination"": ""Kubernetes"",\n    ""relation_description"": ""uses"",\n    ""summary_er"": ""OpenShift Container Platform leverages Kubernetes to provide a scalable and secure container application platform.""\n  }\n]', '[\n  {\n    ""source"": ""Deis Workflow"",\n    ""destination"": ""Helm"",\n    ""relation_description"": ""are supported by"",\n    ""summary_er"": ""Deis Workflow utilizes Helm for package management and deployment.""\n  },\n  {\n    ""source"": ""Helm"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""and the destination pod"",\n    ""summary_er"": ""Helm manages and deploys pods in a containerized environment.""\n  },\n  {\n    ""source"": ""OpenShift Container Platform"",\n    ""destination"": ""Deis Workflow"",\n    ""relation_description"": ""are supported by"",\n    ""summary_er"": ""OpenShift supports Deis Workflow for application deployment and management.""\n  }\n]', '[\n  {\n    ""source"": ""API servers"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""expose"",\n    ""summary_er"": ""API servers expose API objects to clients through a pod, enabling secure and controlled access.""\n  }\n]']","This chapter covers extending Kubernetes by defining custom API objects, creating controllers for those objects, and adding custom API servers. It also explores how others have built Platform-as-a-Service solutions on top of Kubernetes, including Red Hat's OpenShift Container Platform and Deis Workflow.","[{'highlight': 'Defining custom API objects is a key aspect of extending Kubernetes, allowing users to create their own API objects and controllers.'}]"
452,541,0,[],"509
Defining custom API objects
 As the Kubernetes ecosystem evolves, you’ll see more and more high-level objects,
which will be much more specialized than the resources Kubernetes supports today.
Instead of dealing with Deployments, Services, ConfigMaps, and the like, you’ll create
and manage objects that represent whole applications or software services. A custom
controller will observe those high-level objects and create low-level objects based on
them. For example, to run a messaging broker inside a Kubernetes cluster, all you’ll
need to do is create an instance of a Queue resource and all the necessary Secrets,
Deployments, and Services will be created by a custom Queue controller. Kubernetes
already provides ways of adding custom resources like this. 
18.1.1 Introducing CustomResourceDefinitions
To define a new resource type, all you need to do is post a CustomResourceDefinition
object (CRD) to the Kubernetes API server. The CustomResourceDefinition object is
the description of the custom resource type. Once the CRD is posted, users can then
create instances of the custom resource by posting JSON or YAML manifests to the
API server, the same as with any other Kubernetes resource.
NOTE
Prior to Kubernetes 1.7, custom resources were defined through Third-
PartyResource objects, which were similar to CustomResourceDefinitions, but
were removed in version 1.8.
Creating a CRD so that users can create objects of the new type isn’t a useful feature if
those objects don’t make something tangible happen in the cluster. Each CRD will
usually also have an associated controller (an active component doing something
based on the custom objects), the same way that all the core Kubernetes resources
have an associated controller, as was explained in chapter 11. For this reason, to prop-
erly show what CustomResourceDefinitions allow you to do other than adding
instances of a custom object, a controller must be deployed as well. You’ll do that in
the next example.
INTRODUCING THE EXAMPLE CUSTOMRESOURCEDEFINITION
Let’s imagine you want to allow users of your Kubernetes cluster to run static websites
as easily as possible, without having to deal with Pods, Services, and other Kubernetes
resources. What you want to achieve is for users to create objects of type Website that
contain nothing more than the website’s name and the source from which the web-
site’s files (HTML, CSS, PNG, and others) should be obtained. You’ll use a Git reposi-
tory as the source of those files. When a user creates an instance of the Website
resource, you want Kubernetes to spin up a new web server pod and expose it through
a Service, as shown in figure 18.1.
 To create the Website resource, you want users to post manifests along the lines of
the one shown in the following listing.
 
 
 
 
",[],"[{'entity': 'Kubernetes', 'description': 'Container orchestration system', 'category': 'software'}, {'entity': 'Deployments', 'description': 'Kubernetes resource for managing application deployments', 'category': 'software'}, {'entity': 'Services', 'description': 'Kubernetes resource for exposing applications to the network', 'category': 'software'}, {'entity': 'ConfigMaps', 'description': 'Kubernetes resource for storing configuration data', 'category': 'software'}, {'entity': 'CustomResourceDefinitions', 'description': 'Kubernetes feature for defining custom resources', 'category': 'software'}, {'entity': 'CRD', 'description': 'Custom Resource Definition object in Kubernetes', 'category': 'software'}, {'entity': 'Queue resource', 'description': 'High-level object representing a messaging broker', 'category': 'software'}, {'entity': 'Secrets', 'description': 'Kubernetes resource for storing sensitive data', 'category': 'software'}, {'entity': 'Deployments', 'description': 'Kubernetes resource for managing application deployments', 'category': 'software'}, {'entity': 'Services', 'description': 'Kubernetes resource for exposing applications to the network', 'category': 'software'}, {'entity': 'Third-PartyResource', 'description': 'Deprecated Kubernetes feature for defining custom resources', 'category': 'software'}, {'entity': 'Controller', 'description': 'Active component in Kubernetes that observes and manages custom resources', 'category': 'software'}, {'entity': 'Pods', 'description': 'Kubernetes resource for running application containers', 'category': 'software'}, {'entity': 'Services', 'description': 'Kubernetes resource for exposing applications to the network', 'category': 'software'}, {'entity': 'Website resource', 'description': 'Custom resource type for running static websites in Kubernetes', 'category': 'software'}, {'entity': 'Git repository', 'description': 'Source of files for a static website', 'category': 'hardware'}]","[{'source_entity': 'ConfigMaps', 'description': 'are used to store configuration data as key-value pairs.', 'destination_entity': 'Deployments'}, {'source_entity': 'Deployments', 'description': 'can reference ConfigMaps for configuration data.', 'destination_entity': 'ConfigMaps'}, {'source_entity': 'Services', 'description': 'provide a network identity and load balancing for accessing applications.', 'destination_entity': 'Pods'}, {'source_entity': 'Secrets', 'description': 'are used to store sensitive information such as passwords or OAuth tokens.', 'destination_entity': 'Deployments'}, {'source_entity': 'Pods', 'description': 'can be created and managed by Deployments.', 'destination_entity': 'Deployments'}, {'source_entity': 'Git repository', 'description': 'is a centralized location for storing and managing source code.', 'destination_entity': 'Kubernetes'}, {'source_entity': 'Third-PartyResource', 'description': 'can be integrated with Kubernetes using APIs or other mechanisms.', 'destination_entity': 'Kubernetes'}, {'source_entity': 'Website resource', 'description': 'can be accessed and managed by Services in Kubernetes.', 'destination_entity': 'Services'}, {'source_entity': 'CustomResourceDefinitions', 'description': 'allow users to define their own resources within the Kubernetes API.', 'destination_entity': 'Kubernetes'}, {'source_entity': 'Queue resource', 'description': 'can be used as a message queue for applications in Kubernetes.', 'destination_entity': 'Pods'}, {'source_entity': 'Controller', 'description': 'is responsible for managing and controlling the state of resources within Kubernetes.', 'destination_entity': 'Kubernetes'}, {'source_entity': 'Kubernetes', 'description': 'provides a platform for deploying, scaling, and managing applications.', 'destination_entity': 'Deployments'}, {'source_entity': 'CRD', 'description': 'stands for Custom Resource Definition, which allows users to define their own resources within the Kubernetes API.', 'destination_entity': 'Kubernetes'}]","['[\n  {\n    ""source"": ""ConfigMaps"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""are used to store configuration data as key-value pairs."",\n    ""summary_er"": ""ConfigMaps provide a way to decouple configuration from deployment, allowing for easier management and updates of application settings.""\n  }\n]', '[\n  {\n    ""source"": ""Deployments"",\n    ""destination"": ""ConfigMaps"",\n    ""relation_description"": ""can reference"",\n    ""summary_er"": ""Deployments can reference ConfigMaps for configuration data.""\n  },\n  {\n    ""source"": ""Pods"",\n    ""destination"": ""ConfigMaps"",\n    ""relation_description"": ""reference"",\n    ""summary_er"": ""Pods reference ConfigMaps for configuration data.""\n  }\n]', '[\n  {\n    ""source"": ""Services"",\n    ""destination"": ""Pods"",\n    ""relation_description"": ""provide a network identity and load balancing for accessing applications."",\n    ""summary_er"": ""Services provide a unique network identity and load balancing for Pods, enabling access to applications.""\n  }\n]', '[\n  {\n    ""source"": ""Secrets"",\n    ""destination"": ""Pod"",\n    ""relation_description"": ""are used to store sensitive information"",\n    ""summary_er"": ""Secrets are used to securely store sensitive data like passwords or OAuth tokens, which can then be accessed by pods for authentication purposes.""\n  }\n]', '[\n  {\n    ""source"": ""Pods"",\n    ""destination"": ""Deployments"",\n    ""relation_description"": ""can be created and managed by"",\n    ""summary_er"": ""Pods can be dynamically scaled, updated, or rolled back using Deployments.""\n  }\n]', '[\n  {\n    ""source"": ""Git repository"",\n    ""destination"": ""Kubernetes"",\n    ""relation_description"": ""is a centralized location for storing and managing source code."",\n    ""summary_er"": ""A Git repository is used to store and manage source code, which is then deployed to Kubernetes for containerized execution.""\n  }\n]', '[\n  {\n    ""source"": ""Third-Party Resource"",\n    ""destination"": ""Kubernetes"",\n    ""relation_description"": ""can be integrated using APIs or other mechanisms"",\n    ""summary_er"": ""Third-party resources can be seamlessly integrated with Kubernetes via APIs, enabling efficient resource utilization and management.""\n  }\n]', '[\n  {\n    ""source"": ""Website resource"",\n    ""destination"": ""Services"",\n    ""relation_description"": ""can be accessed and managed by"",\n    ""summary_er"": ""A website\'s resources can be managed and accessed through Kubernetes services.""\n  }\n]', '[\n  {\n    ""source"": ""CustomResourceDefinitions"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""allow users to define their own resources within the Kubernetes API"",\n    ""summary_er"": ""CustomResourceDefinitions enable users to extend the Kubernetes API with custom resources, which can be used to manage pods and other cluster entities.""\n  }\n]', '[\n  {\n    ""source"": ""Queue resource"",\n    ""destination"": ""Pods"",\n    ""relation_description"": ""can be used as a message queue for applications in Kubernetes."",\n    ""summary_er"": ""A Queue resource can be utilized by Pods to act as a message queue for applications running within the Kubernetes environment.""\n  }\n]', '[\n  {\n    ""source"": ""Controller"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""is responsible for managing and controlling the state of resources within Kubernetes."",\n    ""summary_er"": ""The Controller manages Kubernetes resources, including pods, ensuring their proper functioning.""\n  }\n]', '[\n  {\n    ""source"": ""Kubernetes"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""provides a platform for deploying, scaling, and managing applications."",\n    ""summary_er"": ""Kubernetes provides a platform to deploy, scale, and manage pods, enabling efficient application management.""\n  }\n]', '[\n  {\n    ""source"": ""CRD"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""Custom Resource Definition"",\n    ""summary_er"": ""A CRD allows users to define custom resources within the Kubernetes API, enabling extension of the platform without modifying its core.""\n  }\n]']","Kubernetes allows defining custom API objects through CustomResourceDefinitions (CRD) which is a description of the custom resource type. A CRD can be posted to the Kubernetes API server, enabling users to create instances of the custom resource. Each CRD typically has an associated controller that makes something tangible happen in the cluster, such as spinning up a new web server pod and exposing it through a Service when creating an instance of the Website resource.","[{'highlight': 'Custom API objects can be defined in Kubernetes to represent whole applications or software services.'}, {'highlight': 'A custom controller will observe those high-level objects and create low-level objects based on them, such as running a messaging broker inside a Kubernetes cluster.'}, {'highlight': 'To define a new resource type, a CustomResourceDefinition object (CRD) must be posted to the Kubernetes API server.'}, {'highlight': 'Each CRD will usually have an associated controller that makes something tangible happen in the cluster, such as spinning up a new web server pod and exposing it through a Service.'}, {'highlight': 'Users can create instances of custom resources by posting JSON or YAML manifests to the API server, similar to creating any other Kubernetes resource.'}]"
453,542,0,[],"510
CHAPTER 18
Extending Kubernetes
kind: Website        
metadata:
  name: kubia             
spec:
  gitRepo: https://github.com/luksa/kubia-website-example.git   
Like all other resources, your resource contains a kind and a metadata.name field,
and like most resources, it also contains a spec section. It contains a single field called
gitRepo (you can choose the name)—it specifies the Git repository containing the
website’s files. You’ll also need to include an apiVersion field, but you don’t know yet
what its value must be for custom resources.
 If you try posting this resource to Kubernetes, you’ll receive an error because
Kubernetes doesn’t know what a Website object is yet:
$ kubectl create -f imaginary-kubia-website.yaml
error: unable to recognize ""imaginary-kubia-website.yaml"": no matches for 
➥ /, Kind=Website
Before you can create instances of your custom object, you need to make Kubernetes
recognize them.
CREATING A CUSTOMRESOURCEDEFINITION OBJECT
To make Kubernetes accept your custom Website resource instances, you need to post
the CustomResourceDefinition shown in the following listing to the API server.
apiVersion: apiextensions.k8s.io/v1beta1       
kind: CustomResourceDefinition                 
metadata:
  name: websites.extensions.example.com      
spec:
  scope: Namespaced                          
Listing 18.1
An imaginary custom resource: imaginary-kubia-website.yaml
Listing 18.2
A CustomResourceDefinition manifest: website-crd.yaml
Website
kind: Website
metadata:
name: kubia
spec:
gitRepo:
github.com/.../kubia.git
Pod:
kubia-website
Service:
kubia-website
Figure 18.1
Each Website object should result in the creation of a Service and an HTTP 
server Pod.
A custom 
object kind
The name of the website 
(used for naming the 
resulting Service and Pod)
The Git 
repository 
holding the 
website’s files
CustomResourceDefinitions belong 
to this API group and version.
The full
name of
your
custom
object
You want Website resources 
to be namespaced.
 
","[Empty DataFrame
Columns: [Website
kind: Website
metadata:
name: kubia
spec:
gitRepo:
github.com/.../kubia.git, Service: Pod:
kubia-website kubia-website]
Index: []]","[{'entity': 'kind', 'description': 'Resource type', 'category': 'software'}, {'entity': 'metadata', 'description': 'Metadata for the resource', 'category': 'software'}, {'entity': 'name', 'description': 'Name of the resource', 'category': 'software'}, {'entity': 'spec', 'description': 'Specification section for the resource', 'category': 'software'}, {'entity': 'gitRepo', 'description': ""Git repository containing the website's files"", 'category': 'software'}, {'entity': 'apiVersion', 'description': 'API version for custom resources', 'category': 'software'}, {'entity': 'kubectl', 'description': 'Command-line tool for interacting with Kubernetes', 'category': 'software'}, {'entity': 'CustomResourceDefinition', 'description': 'Object defining a custom resource', 'category': 'software'}, {'entity': 'scope', 'description': 'Scope of the custom resource (namespaced or cluster-wide)', 'category': 'software'}, {'entity': 'Namespaced', 'description': 'Scope for the custom resource (namespaced)', 'category': 'software'}, {'entity': 'Pod', 'description': 'Containerized process running on a node', 'category': 'container'}, {'entity': 'Service', 'description': 'Abstracted interface to a set of pods', 'category': 'container'}, {'entity': 'website-crd.yaml', 'description': 'File containing the CustomResourceDefinition manifest', 'category': 'software'}, {'entity': 'imaginary-kubia-website.yaml', 'description': 'File containing an imaginary custom resource definition', 'category': 'software'}]","[{'source_entity': '""metadata""', 'description': 'defines', 'destination_entity': '""Service""'}, {'source_entity': '""Service""', 'description': 'is a ', 'destination_entity': '""Namespaced""'}, {'source_entity': '""Pod""', 'description': 'contains', 'destination_entity': '""imaginary-kubia-website.yaml""'}, {'source_entity': '""spec""', 'description': 'defines the ', 'destination_entity': '""apiVersion""'}, {'source_entity': '""kubectl""', 'description': 'uses to', 'destination_entity': '""name""'}, {'source_entity': '""CustomResourceDefinition""', 'description': 'is a type of', 'destination_entity': '""kind""'}, {'source_entity': '""gitRepo""', 'description': 'contains the ', 'destination_entity': '""scope""'}]","['[\n  {\n    ""source"": ""metadata"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""defines"",\n    ""summary_er"": ""Metadata provides configuration details to a Pod, defining its characteristics.""\n  },\n  {\n    ""source"": ""pod"",\n    ""destination"": ""Service"",\n    ""relation_description"": ""exposes"",\n    ""summary_er"": ""A Pod exposes a Service, making it accessible from outside the cluster.""\n  }\n]', '[\n  {\n    ""source"": ""Service"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""is a"",\n    ""summary_er"": ""A Service is a resource that defines a set of pods and provides a network identity and load-balancing for accessing them.""\n  },\n  {\n    ""source"": ""Service"",\n    ""destination"": ""Namespaced"",\n    ""relation_description"": ""is a"",\n    ""summary_er"": ""A Namespaced Service is a service that is scoped to a specific namespace, providing access to pods within that namespace.""\n  }\n]', '[\n  {\n    ""source"": ""Pod"",\n    ""destination"": ""imaginary-kubia-website.yaml"",\n    ""relation_description"": ""contains"",\n    ""summary_er"": ""A Pod contains a configuration file, in this case imaginary-kubia-website.yaml, which defines its properties and behavior.""\n  }\n]', '[\n  {\n    ""source"": ""spec"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""defines the configuration for a Kubernetes Pod"",\n    ""summary_er"": ""The spec field defines the configuration for a pod, which is a logical host for one or more containers.""\n  },\n  {\n    ""source"": ""apiVersion"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""specifies the API version of the Kubernetes object"",\n    ""summary_er"": ""The apiVersion field specifies the API version of the pod, indicating the format of the configuration data.""\n  }\n]', '[\n  {\n    ""source"": ""kubectl"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""uses to"",\n    ""summary_er"": ""Kubectl uses pods for deployment, scaling, and management of containerized applications.""\n  },\n  {\n    ""source"": ""pod"",\n    ""destination"": ""name"",\n    ""relation_description"": ""has a"",\n    ""summary_er"": ""A pod has a unique name that identifies it within the Kubernetes cluster.""\n  }\n]', '[{""source"": ""CustomResourceDefinition"", ""destination"": ""pod"", ""relation_description"": ""is a type of"", ""summary_er"": ""A Custom Resource Definition (CRD) is a Kubernetes object that defines a custom resource, which can be used to create and manage pods.""}]', '[\n  {\n    ""source"": ""gitRepo"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""contains"",\n    ""summary_er"": ""A git repository contains a collection of files and directories that are used to manage source code for a project, which can be deployed as a pod in a Kubernetes cluster.""\n  },\n  {\n    ""source"": ""gitRepo"",\n    ""destination"": ""scope"",\n    ""relation_description"": ""within"",\n    ""summary_er"": ""A git repository is within the scope of a project\'s version control system, allowing developers to track changes and collaborate on code.""\n  }\n]']","Kubernetes custom resource is created by posting a CustomResourceDefinition to the API server. A custom resource definition object has apiVersion, kind, metadata name and spec with scope as Namespaced. It's used to make Kubernetes accept instances of custom Website resources which will result in creation of Service and Pod for each instance.","[{'highlight': 'To make Kubernetes accept your custom Website resource instances, you need to post the CustomResourceDefinition shown in the following listing to the API server.'}, {'highlight': 'A custom object kind is required for each Website object, which should result in the creation of a Service and an HTTP server Pod.'}, {'highlight': 'The name of the website (used for naming the resulting Service and Pod) must be specified in the metadata.name field.'}, {'highlight': 'CustomResourceDefinitions belong to this API group and version, which is apiextensions.k8s.io/v1beta1.'}, {'highlight': 'You want Website resources to be namespaced, so you need to specify scope: Namespaced in the CustomResourceDefinition manifest.'}]"
454,543,0,[],"511
Defining custom API objects
  group: extensions.example.com                
  version: v1                                  
  names:                                    
    kind: Website                           
    singular: website                       
    plural: websites                        
After you post the descriptor to Kubernetes, it will allow you to create any number of
instances of the custom Website resource. 
 You can create the CRD from the website-crd.yaml file available in the code archive:
$ kubectl create -f website-crd-definition.yaml
customresourcedefinition ""websites.extensions.example.com"" created
I’m sure you’re wondering about the long name of the CRD. Why not call it Website?
The reason is to prevent name clashes. By adding a suffix to the name of the CRD
(which will usually include the name of the organization that created the CRD), you
keep CRD names unique. Luckily, the long name doesn’t mean you’ll need to create
your Website resources with kind: websites.extensions.example.com, but as kind:
Website, as specified in the names.kind property of the CRD. The extensions.exam-
ple.com part is the API group of your resource. 
 You’ve seen how creating Deployment objects requires you to set apiVersion to
apps/v1beta1 instead of v1. The part before the slash is the API group (Deployments
belong to the apps API group), and the part after it is the version name (v1beta1 in
the case of Deployments). When creating instances of the custom Website resource,
the apiVersion property will need to be set to extensions.example.com/v1.
CREATING AN INSTANCE OF A CUSTOM RESOURCE
Considering what you learned, you’ll now create a proper YAML for your Website
resource instance. The YAML manifest is shown in the following listing.
apiVersion: extensions.example.com/v1       
kind: Website                               
metadata:
  name: kubia                                
spec:
  gitRepo: https://github.com/luksa/kubia-website-example.git
The kind of your resource is Website, and the apiVersion is composed of the API
group and the version number you defined in the CustomResourceDefinition.
 Create your Website object now:
$ kubectl create -f kubia-website.yaml
website ""kubia"" created
Listing 18.3
A custom Website resource: kubia-website.yaml
Define an API group and version 
of the Website resource.
You need to specify the various 
forms of the custom object’s name.
Your custom API
group and version
This manifest 
describes a Website 
resource instance.
The name of the 
Website instance
 
",[],"[{'entity': 'Custom Resource Definition', 'description': 'A CustomResourceDefinition (CRD) is used to define custom API objects.', 'category': 'Software'}, {'entity': 'Kubernetes', 'description': 'An open-source container orchestration system for automating the deployment, scaling, and management of containers.', 'category': 'Software'}, {'entity': 'API Group', 'description': 'A way to group related API resources together.', 'category': 'Software'}, {'entity': 'Version', 'description': 'The version number of an API resource.', 'category': 'Software'}, {'entity': 'Kind', 'description': 'The type or kind of a custom API object.', 'category': 'Software'}, {'entity': 'Website', 'description': 'A custom API object representing a website.', 'category': 'Software'}, {'entity': 'CRD', 'description': 'CustomResourceDefinition, used to define custom API objects.', 'category': 'Software'}, {'entity': 'kubectl', 'description': 'A command-line tool for interacting with a Kubernetes cluster.', 'category': 'Software'}, {'entity': 'Deployment', 'description': 'A type of Kubernetes resource that represents a set of replicas.', 'category': 'Software'}, {'entity': 'apps/v1beta1', 'description': 'The API group and version for Deployments.', 'category': 'Software'}, {'entity': 'extensions.example.com', 'description': 'The API group for the custom Website resource.', 'category': 'Software'}, {'entity': 'v1', 'description': 'The version number for the custom Website resource.', 'category': 'Software'}, {'entity': 'apiVersion', 'description': 'A property of a Kubernetes resource that specifies its API group and version.', 'category': 'Software'}, {'entity': 'kind', 'description': 'A property of a Kubernetes resource that specifies its type or kind.', 'category': 'Software'}, {'entity': 'metadata', 'description': 'A section of a Kubernetes resource that contains metadata about the resource.', 'category': 'Software'}, {'entity': 'name', 'description': 'A property of a Kubernetes resource that specifies its name.', 'category': 'Software'}, {'entity': 'spec', 'description': 'A section of a Kubernetes resource that contains the specification for the resource.', 'category': 'Software'}, {'entity': 'gitRepo', 'description': 'A property of a Website resource that specifies its Git repository URL.', 'category': 'Software'}]","[{'source_entity': '""CRD""', 'description': 'defines', 'destination_entity': '""metadata""'}, {'source_entity': '""Custom Resource Definition""', 'description': 'is a', 'destination_entity': '""Website""'}, {'source_entity': '""v1""', 'description': 'specifies the', 'destination_entity': '""apiVersion""'}, {'source_entity': '""extensions.example.com""', 'description': 'defines the', 'destination_entity': '""API Group""'}, {'source_entity': '""spec""', 'description': 'contains the', 'destination_entity': '""Deployment""'}, {'source_entity': '""apiVersion""', 'description': 'specifies the version of', 'destination_entity': '""kubectl""'}, {'source_entity': '""kubectl""', 'description': 'is used to manage', 'destination_entity': '""Deployment""'}, {'source_entity': '""Deployment""', 'description': 'has a', 'destination_entity': '""name""'}, {'source_entity': '""apps/v1beta1""', 'description': 'specifies the', 'destination_entity': '""API Group""'}, {'source_entity': '""Version""', 'description': 'is the current', 'destination_entity': '""API Group""'}, {'source_entity': '""API Group""', 'description': 'defines the group of', 'destination_entity': '""Kind""'}, {'source_entity': '""kind""', 'description': 'specifies the type of', 'destination_entity': '""gitRepo""'}, {'source_entity': '""Kubernetes""', 'description': 'is a container', 'destination_entity': '""Deployment""'}, {'source_entity': '""Kind""', 'description': 'defines the type of', 'destination_entity': '""gitRepo""'}]","['[\n  {\n    ""source"": ""CRD"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""defines"",\n    ""summary_er"": ""A Custom Resource Definition (CRD) in Kubernetes defines a new resource type, which can be used to create and manage pods.""\n  }\n]', '[\n  {\n    ""source"": ""Custom Resource Definition"",\n    ""destination"": ""Pod"",\n    ""relation_description"": ""is a"",\n    ""summary_er"": ""A Custom Resource Definition (CRD) is a Kubernetes object that defines a custom resource, which is a pod that can be managed by the cluster.""\n  },\n  {\n    ""source"": ""Custom Resource Definition"",\n    ""destination"": ""Website"",\n    ""relation_description"": ""is related to"",\n    ""summary_er"": ""A Custom Resource Definition (CRD) can be used to manage and configure a website, providing a structured way to define its properties and behavior.""\n  }\n]', '[\n  {\n    ""source"": ""v1"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""specifies the"",\n    ""summary_er"": ""In Kubernetes, v1 specifies the configuration for a pod, which is a container that can run one or more applications.""\n  },\n  {\n    ""source"": ""apiVersion"",\n    ""destination"": ""v1"",\n    ""relation_description"": ""defines"",\n    ""summary_er"": ""The apiVersion field defines the API version of Kubernetes, which in this case is v1, indicating the configuration format used.""\n  }\n]', '[{\n    ""source"": ""extensions.example.com"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""defines the API Group"",\n    ""summary_er"": ""Extensions in example.com define API groups for pods, enabling configuration and management of Kubernetes resources.""\n}]', '[\n  {\n    ""source"": ""Kubernetes"",\n    ""destination"": ""Pod"",\n    ""relation_description"": ""contains"",\n    ""summary_er"": ""In Kubernetes, a Pod is a logical host for one or more application containers. It contains the deployment and runtime environment for the containers.""\n  },\n  {\n    ""source"": ""Deployment"",\n    ""destination"": ""Pod"",\n    ""relation_description"": ""managed by"",\n    ""summary_er"": ""A Deployment in Kubernetes manages the rollout of new versions of an application, creating and updating Pods as needed to ensure high availability.""\n  }\n]', '[\n  {\n    ""source"": ""apiVersion"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""specifies the version of"",\n    ""summary_er"": ""The apiVersion field specifies the API version for a Kubernetes pod, which defines the format and structure of the pod\'s configuration.""\n  },\n  {\n    ""source"": ""kubectl"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""command to run"",\n    ""summary_er"": ""Kubectl is a command-line tool used to interact with a Kubernetes cluster, allowing users to create, manage, and delete pods, among other tasks.""\n  }\n]', '[\n  {\n    ""source"": ""kubectl"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""is used to manage"",\n    ""summary_er"": ""Kubectl is a command-line tool that manages and controls containerized applications, including pods.""\n  },\n  {\n    ""source"": ""Deployment"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""manages"",\n    ""summary_er"": ""A Deployment in Kubernetes manages the rollout of new versions of an application by creating or updating a set of replicas (pods).""\n  }\n]', '[\n  {\n    ""source"": ""Deployment"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""has a"",\n    ""summary_er"": ""A deployment in Kubernetes has one or more pods that run the application.""\n  }\n]', '[\n  {\n    ""source"": ""apps/v1beta1"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""specifies the"",\n    ""summary_er"": ""The API Group specifies the version of the Kubernetes API used to manage pods.""\n  }\n]', '[\n  {\n    ""source"": ""Version"",\n    ""destination"": ""Pod"",\n    ""relation_description"": ""is the current"",\n    ""summary_er"": ""The current version is associated with a running Pod, which represents a containerized application.""\n  },\n  {\n    ""source"": ""API Group"",\n    ""destination"": ""Kubernetes"",\n    ""relation_description"": "" "",\n    ""summary_er"": ""API Group is related to Kubernetes, which is an open-source container orchestration system.""\n  }\n]', '[\n  {\n    ""source"": ""API Group"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""defines the group of"",\n    ""summary_er"": ""The API Group defines a group of pods that share similar characteristics, such as deployment and scaling.""\n  },\n  {\n    ""source"": ""Kind"",\n    ""destination"": ""pod"",\n    ""relation_description"": """",\n    ""summary_er"": ""The Kind is a type or category of pod, defining its purpose and functionality within the Kubernetes cluster.""\n  }\n]', '[\n  {\n    ""source"": ""Kubernetes"",\n    ""destination"": ""Pod"",\n    ""relation_description"": ""specifies the type of"",\n    ""summary_er"": ""In Kubernetes, a Pod is an entity that can contain one or more application containers and shared resources.""\n  },\n  {\n    ""source"": ""Docker"",\n    ""destination"": ""Container"",\n    ""relation_description"": ""is used to create"",\n    ""summary_er"": ""Docker is used to create lightweight and portable Container images for applications.""\n  },\n  {\n    ""source"": ""Machine Learning"",\n    ""destination"": ""Model"",\n    ""relation_description"": ""refers to the process of"",\n    ""summary_er"": ""Machine Learning refers to the process of training a Model using algorithms and data to make predictions or decisions.""\n  },\n  {\n    ""source"": ""Generative AI"",\n    ""destination"": ""AI Model"",\n    ""relation_description"": ""is a type of"",\n    ""summary_er"": ""Generative AI is a type of AI Model that can generate new content, such as images or text, based on patterns and data.""\n  },\n  {\n    ""source"": ""Natural Language Understanding"",\n    ""destination"": ""Text Analysis"",\n    ""relation_description"": ""refers to the process of"",\n    ""summary_er"": ""Natural Language Understanding refers to the process of Text Analysis using algorithms and models to extract insights from text data.""\n  },\n  {\n    ""source"": ""Computer Vision"",\n    ""destination"": ""Image Analysis"",\n    ""relation_description"": ""is a field of study that deals with"",\n    ""summary_er"": ""Computer Vision is a field of study that deals with Image Analysis using algorithms and models to interpret visual data from images and videos.""\n  },\n  {\n    ""source"": ""Kubernetes"",\n    ""destination"": ""Docker"",\n    ""relation_description"": ""uses"",\n    ""summary_er"": ""Kubernetes uses Docker containers as the basic execution unit for applications, providing a portable and efficient way to deploy and manage them.""\n  }\n]', '[\n  {\n    ""source"": ""Kubernetes"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""is a container"",\n    ""summary_er"": ""Kubernetes is a container that manages and orchestrates pods, ensuring efficient resource utilization and scalability.""\n  }\n]', '[\n  {\n    ""source"": ""Kind"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""defines the type of"",\n    ""summary_er"": ""The Kind entity defines the type of a pod, which is a containerized application in Kubernetes.""\n  },\n  {\n    ""source"": ""gitRepo"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""used to deploy from"",\n    ""summary_er"": ""A gitRepo is used to deploy a pod, which is a containerized application in Kubernetes.""\n  }\n]']","A custom API object called Website is defined with group: extensions.example.com, version: v1, and names: kind: Website. After posting the descriptor to Kubernetes, instances of the custom Website resource can be created. A YAML manifest for a Website resource instance is shown, specifying apiVersion: extensions.example.com/v1, kind: Website, metadata: name: kubia, and spec: gitRepo: https://github.com/luksa/kubia-website-example.git.","[{'highlight': 'To create a custom API object, you need to define its group, version, and names in the CustomResourceDefinition (CRD).'}, {'highlight': ""The CRD's long name is used to prevent name clashes, but you can use the shorter 'kind' property when creating instances of the custom resource.""}, {'highlight': ""When creating an instance of a custom resource, you need to set the 'apiVersion' property to the API group and version number defined in the CRD.""}, {'highlight': ""You can create a YAML manifest for your custom Website resource instance using the 'kind', 'metadata', and 'spec' properties.""}, {'highlight': ""To create an instance of the custom Website resource, you need to use the 'kubectl create -f' command with the YAML manifest file.""}]"
455,544,0,[],"512
CHAPTER 18
Extending Kubernetes
The response tells you that the API server has accepted and stored your custom
Website object. Let’s see if you can now retrieve it. 
RETRIEVING INSTANCES OF A CUSTOM RESOURCE
List all the websites in your cluster:
$ kubectl get websites
NAME      KIND
kubia     Website.v1.extensions.example.com
As with existing Kubernetes resources, you can create and then list instances of cus-
tom resources. You can also use kubectl describe to see the details of your custom
object, or retrieve the whole YAML with kubectl get, as in the following listing.
$ kubectl get website kubia -o yaml
apiVersion: extensions.example.com/v1
kind: Website
metadata:
  creationTimestamp: 2017-02-26T15:53:21Z
  name: kubia
  namespace: default
  resourceVersion: ""57047""
  selfLink: /apis/extensions.example.com/v1/.../default/websites/kubia
  uid: b2eb6d99-fc3b-11e6-bd71-0800270a1c50
spec:
  gitRepo: https://github.com/luksa/kubia-website-example.git
Note that the resource includes everything that was in the original YAML definition,
and that Kubernetes has initialized additional metadata fields the way it does with all
other resources. 
DELETING AN INSTANCE OF A CUSTOM OBJECT
Obviously, in addition to creating and retrieving custom object instances, you can also
delete them:
$ kubectl delete website kubia
website ""kubia"" deleted
NOTE
You’re deleting an instance of a Website, not the Website CRD
resource. You could also delete the CRD object itself, but let’s hold off on that
for a while, because you’ll be creating additional Website instances in the
next section. 
Let’s go over everything you’ve done. By creating a CustomResourceDefinition object,
you can now store, retrieve, and delete custom objects through the Kubernetes API
server. These objects don’t do anything yet. You’ll need to create a controller to make
them do something. 
Listing 18.4
Full Website resource definition retrieved from the API server
 
",[],"[{'entity': 'kubectl', 'description': 'command-line tool for interacting with Kubernetes clusters', 'category': 'software'}, {'entity': 'get', 'description': 'kubectl command to retrieve resources from a cluster', 'category': 'software'}, {'entity': 'websites', 'description': 'custom resource type for storing website configurations', 'category': 'database'}, {'entity': 'kubia', 'description': 'instance of the custom Website resource', 'category': 'database'}, {'entity': 'Website.v1.extensions.example.com', 'description': 'API group and version for the custom Website resource', 'category': 'software'}, {'entity': 'extensions.example.com/v1', 'description': 'API group and version for the custom Website resource', 'category': 'software'}, {'entity': 'apiVersion', 'description': 'metadata field in the custom Website resource YAML definition', 'category': 'database'}, {'entity': 'kind', 'description': 'metadata field in the custom Website resource YAML definition', 'category': 'database'}, {'entity': 'metadata', 'description': 'section of the custom Website resource YAML definition containing metadata fields', 'category': 'database'}, {'entity': 'spec', 'description': 'section of the custom Website resource YAML definition containing configuration fields', 'category': 'database'}, {'entity': 'gitRepo', 'description': 'configuration field in the custom Website resource YAML definition specifying a Git repository URL', 'category': 'database'}, {'entity': 'kubectl delete', 'description': 'command to delete resources from a Kubernetes cluster', 'category': 'software'}, {'entity': 'website', 'description': 'resource type for storing website configurations', 'category': 'database'}, {'entity': 'CRD', 'description': 'Custom Resource Definition object used to define custom resource types in Kubernetes', 'category': 'software'}]","[{'source_entity': '""metadata""', 'description': 'defines metadata for the Website resource', 'destination_entity': '""extensions.example.com/v1""'}, {'source_entity': '""website""', 'description': 'specifies a website resource with API version ""extensions.example.com/v1""', 'destination_entity': '""Website.v1.extensions.example.com""'}, {'source_entity': '""websites""', 'description': 'lists multiple websites resources', 'destination_entity': '""website""'}, {'source_entity': '""kubectl delete""', 'description': 'deletes a Website resource with API version ""extensions.example.com/v1""', 'destination_entity': '""Website.v1.extensions.example.com""'}, {'source_entity': '""spec""', 'description': 'defines the specification for the Website resource', 'destination_entity': '""website""'}, {'source_entity': '""apiVersion""', 'description': 'specifies the API version for the Website resource', 'destination_entity': '""extensions.example.com/v1""'}, {'source_entity': '""kubectl""', 'description': 'executes a command to delete a Website resource', 'destination_entity': '""Website.v1.extensions.example.com""'}, {'source_entity': '""kubia""', 'description': 'specifies the name of the Kubernetes cluster', 'destination_entity': '""kubectl""'}, {'source_entity': '""kind""', 'description': 'defines the type of resource (Website)', 'destination_entity': '""website""'}, {'source_entity': '""gitRepo""', 'description': 'specifies the Git repository containing the CRD definition', 'destination_entity': '""CRD""'}, {'source_entity': '""get""', 'description': 'executes a command to retrieve information about the Website resource', 'destination_entity': '""website""'}]","['[\n  {\n    ""source"": ""metadata"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""defines metadata for the Website resource"",\n    ""summary_er"": ""Metadata configuration for a Kubernetes Pod, specifying additional attributes for the Website resource.""\n  }\n]', '[\n  {\n    ""source"": ""website"",\n    ""destination"": ""Pod"",\n    ""relation_description"": ""specifies a website resource with API version \\""extensions.example.com/v1\\"""",\n    ""summary_er"": ""The website resource is used to specify an extension of the pod with API version extensions.example.com/v1.""\n  }\n]', '[\n  {\n    ""source"": ""websites"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""lists multiple website resources"",\n    ""summary_er"": ""Websites list provides a collection of web resources, including websites, for users to access and utilize.""\n  }\n]', '[\n  {\n    ""source"": ""kubectl delete"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""deletes a Website resource with API version \\""extensions.example.com/v1\\"""",\n    ""summary_er"": ""\\""kubectl delete\\"" command deletes a Website pod with API version \\""extensions.example.com/v1\\"", affecting its lifecycle and potentially causing data loss if not properly managed.\\""""\n  }\n]', '[\n  {\n    ""source"": ""spec"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""defines the specification for the Website resource"",\n    ""summary_er"": ""The spec defines the configuration for a pod, which is a containerized unit of deployment.""\n  }\n]', '[\n  {\n    ""source"": ""apiVersion"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""specifies the API version"",\n    ""summary_er"": ""The API version for the Website resource is specified by this field, which affects how the pod behaves.""\n  }\n]', '[\n  {\n    ""source"": ""kubectl"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""executes a command to delete a Website resource"",\n    ""summary_er"": ""Kubectl deletes a pod by executing a command on the website resource, utilizing Kubernetes extensions.""\n  }\n]', '[\n  {\n    ""source"": ""kubia"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""specifies the name of the Kubernetes cluster"",\n    ""summary_er"": ""Kubernetes cluster name specified by kubia, referencing a pod within it.""\n  },\n  {\n    ""source"": ""kubectl"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""executes commands on the pod"",\n    ""summary_er"": ""kubectl executes commands on a pod, interacting with Kubernetes resources.""\n  }\n]', '[\n  {\n    ""source"": ""kind"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""defines the type of resource"",\n    ""summary_er"": ""The kind field defines the type of Kubernetes resource, such as a pod or service.""\n  },\n  {\n    ""source"": ""website"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""deployment target"",\n    ""summary_er"": ""A website is deployed to a specific pod in the cluster for execution and management.""\n  }\n]', '[\n  {\n    ""source"": ""gitRepo"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""specifies the Git repository containing the CRD definition"",\n    ""summary_er"": ""The gitRepo entity specifies the Git repository for a pod\'s CRD definition, which is used to define the structure and behavior of a Kubernetes resource.""\n  }\n]', '[\n  {\n    ""source"": ""get"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""executes a command to retrieve information about the Website resource"",\n    ""summary_er"": ""The \'get\' command retrieves website info using pod resources.""\n  }\n]']","You can now store, retrieve and delete custom resources through the Kubernetes API server after creating a CustomResourceDefinition object. These objects don't do anything yet and you'll need to create a controller to make them functional.",[{'highlight': 'You can now retrieve your custom Website object using kubectl get websites.'}]
456,545,0,[],"513
Defining custom API objects
 In general, the point of creating custom objects like this isn’t always to make some-
thing happen when the object is created. Certain custom objects are used to store data
instead of using a more generic mechanism such as a ConfigMap. Applications run-
ning inside pods can query the API server for those objects and read whatever is
stored in them. 
 But in this case, we said you wanted the existence of a Website object to result in
the spinning up of a web server serving the contents of the Git repository referenced
in the object. We’ll look at how to do that next.
18.1.2 Automating custom resources with custom controllers
To make your Website objects run a web server pod exposed through a Service, you’ll
need to build and deploy a Website controller, which will watch the API server for the
creation of Website objects and then create the Service and the web server Pod for
each of them. 
 To make sure the Pod is managed and survives node failures, the controller will
create a Deployment resource instead of an unmanaged Pod directly. The controller’s
operation is summarized in figure 18.2.
I’ve written a simple initial version of the controller, which works well enough to
show CRDs and the controller in action, but it’s far from being production-ready,
because it’s overly simplified. The container image is available at docker.io/luksa/
website-controller:latest, and the source code is at https:/
/github.com/luksa/k8s-
website-controller. Instead of going through its source code, I’ll explain what the con-
troller does.
API server
Websites
Website:
kubia
Deployments
Deployment:
kubia-website
Services
Service:
kubia-website
Website
controller
Watches
Creates
Figure 18.2
The Website controller 
watches for Website objects and 
creates a Deployment and a Service.
 
","[Empty DataFrame
Columns: [Watches
Website
controller
Creates, API server
Websites
Website:
kubia
Deployments
Deployment:
kubia-website
Services
Service:
kubia-website]
Index: []]","[{'entity': 'API', 'description': 'Application Programming Interface', 'category': 'software'}, {'entity': 'ConfigMap', 'description': 'A Kubernetes resource that stores configuration data as key-value pairs', 'category': 'database'}, {'entity': 'Pod', 'description': 'The basic execution unit in a containerized environment', 'category': 'container'}, {'entity': 'Service', 'description': 'A way to expose an application running inside a Pod to the outside world', 'category': 'network'}, {'entity': 'Deployment', 'description': 'A Kubernetes resource that manages the rollout and rollbacks of Pods', 'category': 'application'}, {'entity': 'Controller', 'description': 'A program that watches for specific events in a Kubernetes cluster and takes actions accordingly', 'category': 'software'}, {'entity': 'Website object', 'description': 'A custom API object used to store data about websites', 'category': 'database'}, {'entity': 'Git repository', 'description': 'A location where source code is stored using the Git version control system', 'category': 'software'}, {'entity': 'API server', 'description': 'The central component of a Kubernetes cluster that manages access to resources and data', 'category': 'network'}, {'entity': 'Website controller', 'description': 'A custom controller that watches for Website objects and creates a Deployment and Service accordingly', 'category': 'software'}, {'entity': 'CRD (Custom Resource Definition)', 'description': 'A Kubernetes resource that defines a new API object type', 'category': 'database'}]","[{'source_entity': '""Website controller""', 'description': 'manages', 'destination_entity': '""Service""'}, {'source_entity': '""Service""', 'description': 'provides', 'destination_entity': '""API server""'}, {'source_entity': '""Controller""', 'description': 'deploys', 'destination_entity': '""Deployment""'}, {'source_entity': '""Deployment""', 'description': 'manages', 'destination_entity': '""Pod""'}, {'source_entity': '""Website controller""', 'description': 'configures', 'destination_entity': '""ConfigMap""'}, {'source_entity': '""API server""', 'description': 'communicates with', 'destination_entity': '""API""'}, {'source_entity': '""Service""', 'description': 'accesses', 'destination_entity': '""Git repository""'}, {'source_entity': '""Controller""', 'description': 'defines', 'destination_entity': '""CRD (Custom Resource Definition)""'}, {'source_entity': '""Website controller""', 'description': 'manages', 'destination_entity': '""Website object""'}]","['[\n  {\n    ""source"": ""Website controller"",\n    ""destination"": ""Pod"",\n    ""relation_description"": ""manages"",\n    ""summary_er"": ""The Website controller manages a Pod, which is an instance of a containerized application.""\n  },\n  {\n    ""source"": ""Service"",\n    ""destination"": ""Pod"",\n    ""relation_description"": ""managed by"",\n    ""summary_er"": ""A Service is managed by one or more Pods, providing a stable network identity and load balancing for the application.""\n  }\n]', '[\n  {\n    ""source"": ""Service"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""provides"",\n    ""summary_er"": ""A Service provides a network interface to access a pod, allowing multiple requests to be sent to it.""\n  }\n]', '[\n  {\n    ""source"": ""Controller"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""deploys"",\n    ""summary_er"": ""A controller deploys a pod, managing its lifecycle and ensuring it runs smoothly.""\n  },\n  {\n    ""source"": ""Deployment"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""manages"",\n    ""summary_er"": ""A deployment manages one or more pods, scaling them up or down as needed to meet demand.""\n  }\n]', '[\n  {\n    ""source"": ""Deployment"",\n    ""destination"": ""Pod"",\n    ""relation_description"": ""manages"",\n    ""summary_er"": ""A Deployment manages one or more replicas of a Pod, ensuring that the desired state is maintained and updated.""\n  }\n]', '[\n  {\n    ""source"": ""Website controller"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""configures"",\n    ""summary_er"": ""The Website controller component configures a pod, ensuring it meets specific requirements for running a website.""\n  }\n]', '[\n  {\n    ""source"": ""API server"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""communicates with"",\n    ""summary_er"": ""The API server interacts with a pod to exchange data and requests.""\n  }\n]', '[\n  {\n    ""source"": ""Service"",\n    ""destination"": ""Pod"",\n    ""relation_description"": ""accesses"",\n    ""summary_er"": ""A service in Kubernetes accesses a pod, which is an instance of a container running an application.""\n  }\n]', '[\n  {\n    ""source"": ""Controller"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""defines"",\n    ""summary_er"": ""A controller in Kubernetes defines a pod, which is a logical host for one or more application containers.""\n  },\n  {\n    ""source"": ""CRD (Custom Resource Definition)"",\n    ""destination"": ""Controller"",\n    ""relation_description"": ""defines"",\n    ""summary_er"": ""A Custom Resource Definition (CRD) defines a controller in Kubernetes, which manages a specific resource type.""\n  }\n]', '[\n  {\n    ""source"": ""Website controller"",\n    ""destination"": ""Website object"",\n    ""relation_description"": ""manages"",\n    ""summary_er"": ""The Website controller manages the Website object, overseeing its lifecycle and ensuring it runs smoothly.""\n  }\n]']","A custom API object, such as a Website object, can be created to trigger the spinning up of a web server serving Git repository contents. A custom controller is needed to automate this process by watching the API server for Website object creation and creating a Deployment and Service for each one. This allows the Pod to be managed and survive node failures.","[{'highlight': 'Custom API objects can be used to store data instead of using a ConfigMap, allowing applications running inside pods to query the API server for those objects.'}, {'highlight': 'A custom Website controller is needed to automate the creation of a web server pod exposed through a Service for each Website object created in the API server.'}, {'highlight': 'The Website controller creates a Deployment resource instead of an unmanaged Pod directly, ensuring the Pod is managed and survives node failures.'}, {'highlight': 'A simple initial version of the Website controller is available at docker.io/luksa/website-controller:latest, with source code at https://github.com/luksa/k8s-website-controller.'}, {'highlight': 'The Website controller watches for Website objects and creates a Deployment and a Service for each one, as shown in Figure 18.2.'}]"
457,546,0,[],"514
CHAPTER 18
Extending Kubernetes
UNDERSTANDING WHAT THE WEBSITE CONTROLLER DOES
Immediately upon startup, the controller starts to watch Website objects by requesting
the following URL:
http://localhost:8001/apis/extensions.example.com/v1/websites?watch=true
You may recognize the hostname and port—the controller isn’t connecting to the
API server directly, but is instead connecting to the kubectl proxy process, which
runs in a sidecar container in the same pod and acts as the ambassador to the API
server (we examined the ambassador pattern in chapter 8). The proxy forwards the
request to the API server, taking care of both TLS encryption and authentication
(see figure 18.3).
Through the connection opened by this HTTP GET request, the API server will send
watch events for every change to any Website object.
 The API server sends the ADDED watch event every time a new Website object is cre-
ated. When the controller receives such an event, it extracts the Website’s name and
the URL of the Git repository from the Website object it received in the watch event
and creates a Deployment and a Service object by posting their JSON manifests to the
API server. 
 The Deployment resource contains a template for a pod with two containers
(shown in figure 18.4): one running an nginx server and another one running a git-
sync process, which keeps a local directory synced with the contents of a Git repo.
The local directory is shared with the nginx container through an emptyDir volume
(you did something similar to that in chapter 6, but instead of keeping the local
directory synced with a Git repo, you used a gitRepo volume to download the Git
repo’s contents at pod startup; the volume’s contents weren’t kept in sync with the
Git repo afterward). The Service is a NodePort Service, which exposes your web
server pod through a random port on each node (the same port is used on all
nodes). When a pod is created by the Deployment object, clients can access the web-
site through the node port.
Pod: website-controller
Container: main
Website controller
GET http://localhost:8001/apis/extensions.
example.com/v1/websites?watch=true
GET https://kubernetes:443/apis/extensions.
example.com/v1/websites?watch=true
Authorization: Bearer <token>
Container: proxy
kubectl proxy
API server
Figure 18.3
The Website controller talks to the API server through a proxy (in the ambassador container).
 
",[],"[{'entity': 'Kubernetes', 'description': 'Container orchestration system', 'category': 'software'}, {'entity': 'Website controller', 'description': 'Controller that watches Website objects', 'category': 'application'}, {'entity': 'API server', 'description': 'Server that handles API requests', 'category': 'application'}, {'entity': 'kubectl proxy', 'description': 'Proxy process that forwards requests to API server', 'category': 'process'}, {'entity': 'Deployment', 'description': 'Resource that creates a pod with two containers', 'category': 'resource'}, {'entity': 'Service', 'description': 'Resource that exposes a web server pod through a random port', 'category': 'resource'}, {'entity': 'Pod', 'description': 'Lightweight and portable container runtime', 'category': 'container'}, {'entity': 'Container', 'description': 'Isolated process that runs an application', 'category': 'container'}, {'entity': 'nginx server', 'description': 'Web server software', 'category': 'software'}, {'entity': 'git-sync process', 'description': 'Process that keeps a local directory synced with a Git repo', 'category': 'process'}, {'entity': 'Git repository', 'description': 'Repository of source code', 'category': 'database'}, {'entity': 'emptyDir volume', 'description': 'Volume that is shared between containers', 'category': 'volume'}, {'entity': 'NodePort Service', 'description': 'Service that exposes a pod through a random port on each node', 'category': 'resource'}, {'entity': 'API server URL', 'description': 'URL of the API server', 'category': 'url'}, {'entity': 'kubectl proxy process', 'description': 'Process that runs in a sidecar container and acts as an ambassador to the API server', 'category': 'process'}]","[{'source_entity': 'Website controller', 'description': ""uses to manage and control the website's resources"", 'destination_entity': 'Container'}, {'source_entity': 'Website controller', 'description': ""deploys and manages the website's services"", 'destination_entity': 'Service'}, {'source_entity': 'Website controller', 'description': 'manages and persists data for the website', 'destination_entity': 'emptyDir volume'}, {'source_entity': 'Container', 'description': 'runs as a process within the NodePort Service', 'destination_entity': 'NodePort Service'}, {'source_entity': 'Service', 'description': ""exposes the Pod's port to the outside world"", 'destination_entity': 'Pod'}, {'source_entity': 'emptyDir volume', 'description': 'provides temporary storage for the git-sync process', 'destination_entity': 'git-sync process'}, {'source_entity': 'NodePort Service', 'description': ""exposes the Pod's port to the outside world"", 'destination_entity': 'Pod'}, {'source_entity': 'nginx server', 'description': 'serves as a reverse proxy for the Deployment', 'destination_entity': 'Deployment'}, {'source_entity': 'git-sync process', 'description': 'syncs data from the Git repository', 'destination_entity': 'Git repository'}, {'source_entity': 'kubectl proxy process', 'description': 'proxies API server requests to the API server URL', 'destination_entity': 'API server URL'}, {'source_entity': 'Deployment', 'description': 'manages and updates the nginx server configuration', 'destination_entity': 'nginx server'}, {'source_entity': 'Kubernetes', 'description': 'orchestrates and manages the Deployment', 'destination_entity': 'Deployment'}, {'source_entity': 'kubectl proxy', 'description': 'proxies API server requests to the API server URL', 'destination_entity': 'API server URL'}, {'source_entity': 'API server URL', 'description': 'provides access to the Kubernetes API', 'destination_entity': 'Kubernetes'}]","['[\n  {\n    ""source"": ""Website Controller"",\n    ""destination"": ""Pod"",\n    ""relation_description"": ""uses to manage and control the website\'s resources"",\n    ""summary_er"": ""The Website Controller uses a Pod to manage and control the website\'s resources, ensuring efficient resource allocation and utilization.""\n  }\n]', '[\n  {\n    ""source"": ""Website controller"",\n    ""destination"": ""Pod"",\n    ""relation_description"": ""deploys and manages the website\'s services"",\n    ""summary_er"": ""The Website controller deploys and manages the website\'s services by interacting with the Pod, ensuring seamless service delivery.""\n  }\n]', '[\n  {\n    ""source"": ""Website controller"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""manages and persists data for the website"",\n    ""summary_er"": ""The Website controller manages data persistence for a pod, utilizing an emptyDir volume to store website-related data.""\n  }\n]', '[\n  {\n    ""source"": ""Container"",\n    ""destination"": ""NodePort Service"",\n    ""relation_description"": ""runs as a process within"",\n    ""summary_er"": ""A container runs as a process within a NodePort service, utilizing its port to expose an application to external traffic.""\n  }\n]', '[\n  {\n    ""source"": ""Service"",\n    ""destination"": ""Pod"",\n    ""relation_description"": ""exposes the Pod\'s port to the outside world"",\n    ""summary_er"": ""A Service exposes a Pod\'s port to the outside world, allowing external access to the Pod\'s resources.""\n  }\n]', '[\n  {\n    ""source"": ""emptyDir volume"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""provides temporary storage"",\n    ""summary_er"": ""The emptyDir volume provides temporary storage for the git-sync process, enabling it to run within a pod.""\n  }\n]', '[\n  {\n    ""source"": ""NodePort Service"",\n    ""destination"": ""Pod"",\n    ""relation_description"": ""exposes the Pod\'s port to the outside world"",\n    ""summary_er"": ""A NodePort Service allows external access to a Pod\'s port, making it accessible from outside the cluster.""\n  }\n]', '[\n  {\n    ""source"": ""nginx server"",\n    ""destination"": ""Deployment"",\n    ""relation_description"": ""serves as a reverse proxy"",\n    ""summary_er"": ""The nginx server acts as a reverse proxy for the Deployment, forwarding incoming requests to it.""\n  }\n]', '[\n  {\n    ""source"": ""Git-sync process"",\n    ""destination"": ""Git repository"",\n    ""relation_description"": ""syncs data"",\n    ""summary_er"": ""The Git-sync process synchronizes data from the Git repository to a destination pod, ensuring consistent and up-to-date information.""\n  }\n]', '[\n  {\n    ""source"": ""kubectl proxy process"",\n    ""destination"": ""API server URL"",\n    ""relation_description"": ""proxies API server requests"",\n    ""summary_er"": ""The kubectl proxy process forwards API server requests to the specified URL.""\n  }\n]', '[\n  {\n    ""source"": ""Deployment"",\n    ""destination"": ""Pod"",\n    ""relation_description"": ""manages and updates"",\n    ""summary_er"": ""A Deployment manages and updates the Nginx server configuration for a Pod.""\n  }\n]', '[\n  {\n    ""source"": ""Kubernetes"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""orchestrates and manages"",\n    ""summary_er"": ""Kubernetes manages and orchestrates pods, ensuring efficient resource utilization and scalability.""\n  },\n  {\n    ""source"": ""Deployment"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""managed by"",\n    ""summary_er"": ""Deployments manage the lifecycle of pods, including creation, scaling, and termination.""\n  }\n]', '[\n  {\n    ""source"": ""kubectl proxy"",\n    ""destination"": ""API server URL"",\n    ""relation_description"": ""proxies API server requests"",\n    ""summary_er"": ""Kubectl proxy forwards API requests to the API server URL, allowing external access to cluster resources.""\n  }\n]', '[\n  {\n    ""source"": ""API server URL"",\n    ""destination"": ""Kubernetes"",\n    ""relation_description"": ""provides access to the Kubernetes API"",\n    ""summary_er"": ""The API server URL grants access to the Kubernetes API, enabling management and control of Kubernetes resources.""\n  }\n]']","The Website controller connects to the kubectl proxy process, which forwards requests to the API server, allowing the API server to send watch events for every change to any Website object. When a new Website object is created, the API server sends an ADDED event, triggering the controller to create a Deployment and Service object with a template for a pod containing an nginx server and a git-sync process, exposing the web server through a random port on each node.","[{'highlight': 'The Kubernetes website controller starts watching Website objects immediately upon startup by requesting the URL http://localhost:8001/apis/extensions.example.com/v1/websites?watch=true.'}, {'highlight': 'The API server sends watch events for every change to any Website object, including an ADDED event when a new Website object is created.'}, {'highlight': ""The website controller extracts the Website's name and Git repository URL from the watch event and creates a Deployment and Service object by posting their JSON manifests to the API server.""}, {'highlight': 'The Deployment resource contains a template for a pod with two containers: one running an nginx server and another running a git-sync process that keeps a local directory synced with a Git repo.'}, {'highlight': 'A NodePort Service exposes the web server pod through a random port on each node, allowing clients to access the website through the node port.'}]"
458,547,1,[],"515
Defining custom API objects
The API server also sends a DELETED watch event when a Website resource instance is
deleted. Upon receiving the event, the controller deletes the Deployment and the Ser-
vice resources it created earlier. As soon as a user deletes the Website instance, the
controller will shut down and remove the web server serving that website.
NOTE
My oversimplified controller isn’t implemented properly. The way it
watches the API objects doesn’t guarantee it won’t miss individual watch
events. The proper way to watch objects through the API server is to not only
watch them, but also periodically re-list all objects in case any watch events
were missed. 
RUNNING THE CONTROLLER AS A POD
During development, I ran the controller on my local development laptop and used a
locally running kubectl proxy process (not running as a pod) as the ambassador to
the Kubernetes API server. This allowed me to develop quickly, because I didn’t need
to build a container image after every change to the source code and then run it
inside Kubernetes. 
 When I’m ready to deploy the controller into production, the best way is to run the
controller inside Kubernetes itself, the way you do with all the other core controllers.
To run the controller in Kubernetes, you can deploy it through a Deployment resource.
The following listing shows an example of such a Deployment.
apiVersion: apps/v1beta1
kind: Deployment
metadata:
  name: website-controller
spec:
  replicas: 1                      
  template:
Listing 18.5
A Website controller Deployment: website-controller.yaml
Pod
Webserver
container
Web client
git-sync
container
Serves website to
web client through
a random port
Clones Git repo
into volume and
keeps it synced
emptyDir
volume
Figure 18.4
The pod serving 
the website specified in the 
Website object
You’ll run a single 
replica of the 
controller.
 
",[],"[{'entity': 'API server', 'description': 'a component that sends DELETED watch events when a Website resource instance is deleted', 'category': 'software'}, {'entity': 'DELETED watch event', 'description': 'an event sent by the API server when a Website resource instance is deleted', 'category': 'process'}, {'entity': 'controller', 'description': 'a component that deletes Deployment and Service resources created earlier when a Website instance is deleted', 'category': 'software'}, {'entity': 'Deployment', 'description': 'a Kubernetes resource that manages replicas of a pod', 'category': 'application'}, {'entity': 'Service', 'description': 'a Kubernetes resource that provides a network identity and load balancing for accessing a pod', 'category': 'application'}, {'entity': 'kubectl proxy', 'description': 'a process that acts as an ambassador to the Kubernetes API server', 'category': 'process'}, {'entity': 'Kubernetes API server', 'description': 'a component that manages access to cluster resources', 'category': 'software'}, {'entity': 'Pod', 'description': 'a lightweight and portable container runtime environment', 'category': 'container'}, {'entity': 'Deployment resource', 'description': 'a Kubernetes resource that manages replicas of a pod', 'category': 'application'}, {'entity': 'apiVersion', 'description': 'a field in the Deployment resource that specifies the API version', 'category': 'software'}, {'entity': 'kind', 'description': 'a field in the Deployment resource that specifies the type of resource', 'category': 'software'}, {'entity': 'metadata', 'description': 'a field in the Deployment resource that provides metadata about the resource', 'category': 'software'}, {'entity': 'name', 'description': 'a field in the metadata that specifies the name of the resource', 'category': 'software'}, {'entity': 'spec', 'description': 'a field in the Deployment resource that specifies the desired state of the resource', 'category': 'software'}, {'entity': 'replicas', 'description': 'a field in the spec that specifies the number of replicas to run', 'category': 'software'}, {'entity': 'template', 'description': 'a field in the spec that specifies a template for the pod', 'category': 'container'}, {'entity': 'emptyDir', 'description': 'a volume type that provides an empty directory for use by a container', 'category': 'storage'}]","[{'source_entity': 'controller', 'description': 'manages', 'destination_entity': 'Service'}, {'source_entity': 'metadata', 'description': 'contains', 'destination_entity': 'replicas'}, {'source_entity': 'Pod', 'description': 'is created by', 'destination_entity': 'Deployment resource'}, {'source_entity': 'DELETED watch event', 'description': 'indicates', 'destination_entity': 'template'}, {'source_entity': 'Deployment resource', 'description': 'has', 'destination_entity': 'spec'}, {'source_entity': 'apiVersion', 'description': 'defines', 'destination_entity': 'Kubernetes API server'}, {'source_entity': 'emptyDir', 'description': 'is used by', 'destination_entity': 'Pod'}, {'source_entity': 'Deployment', 'description': 'manages', 'destination_entity': 'name'}, {'source_entity': 'kind', 'description': 'specifies', 'destination_entity': 'API server'}, {'source_entity': 'Kubernetes API server', 'description': 'uses', 'destination_entity': 'kubectl proxy'}]","['[\n  {\n    ""source"": ""controller"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""manages"",\n    ""summary_er"": ""The controller manages a pod, overseeing its lifecycle and ensuring it runs smoothly.""\n  }\n]', '[\n  {\n    ""source"": ""metadata"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""contains"",\n    ""summary_er"": ""Metadata provides configuration information for a pod, which is a logical host in Kubernetes.""\n  },\n  {\n    ""source"": ""pod"",\n    ""destination"": ""replicas"",\n    ""relation_description"": ""has"",\n    ""summary_er"": ""A pod can have multiple replicas, which are identical copies of the same container or application.""\n  }\n]', '[\n  {\n    ""source"": ""Pod"",\n    ""destination"": ""Deployment Resource"",\n    ""relation_description"": ""is created by"",\n    ""summary_er"": ""A Pod is dynamically created by a Deployment to host its containerized application.""\n  }\n]', '[\n  {\n    ""source"": ""DELETED watch event"",\n    ""destination"": ""pod template"",\n    ""relation_description"": ""indicates"",\n    ""summary_er"": ""The DELETED watch event indicates a change in the pod template, possibly due to deletion or modification of a container.""\n  }\n]', '[\n  {\n    ""source"": ""Deployment resource"",\n    ""destination"": ""pod spec"",\n    ""relation_description"": ""has"",\n    ""summary_er"": ""A deployment resource defines a pod template, which includes the pod\'s specification, such as container images and environment variables.""\n  }\n]', '[\n  {\n    ""source"": ""apiVersion"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""defines"",\n    ""summary_er"": ""The apiVersion field in a Kubernetes configuration defines a pod, which is a logical host for one or more application containers.""\n  }\n]', '[\n  {\n    ""source"": ""emptyDir"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""is used by"",\n    ""summary_er"": ""Empty Dir is a temporary storage volume used by a Pod to store ephemeral data.""\n  }\n]', '[\n  {\n    ""source"": ""Deployment"",\n    ""destination"": ""Pod"",\n    ""relation_description"": ""manages"",\n    ""summary_er"": ""A deployment manages one or more replicasets, which in turn manage pods. This allows for easy scaling and management of applications.""\n  }\n]', '[\n  {\n    ""source"": ""API server"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""specifies"",\n    ""summary_er"": ""The API server is responsible for serving the Kubernetes API, which specifies the configuration and behavior of a pod.""\n  }\n]', '[\n  {\n    ""source"": ""Kubernetes API server"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""uses"",\n    ""summary_er"": ""The Kubernetes API server interacts with pods to manage containerized applications.""\n  },\n  {\n    ""source"": ""kubectl proxy"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""accesses"",\n    ""summary_er"": ""kubectl proxy provides a web interface for accessing pod resources and logs.""\n  }\n]']","A custom API controller is created to manage Website resources, which are deleted by the API server and watched through periodic re-listing. The controller runs as a pod in Kubernetes for development and deployment, using a Deployment resource to ensure proper execution.","[{'highlight': 'When a Website resource instance is deleted, the controller deletes the Deployment and Service resources it created earlier.'}, {'highlight': 'The proper way to watch objects through the API server is to not only watch them, but also periodically re-list all objects in case any watch events were missed.'}, {'highlight': 'To run the controller in Kubernetes, you can deploy it through a Deployment resource using an example like apiVersion: apps/v1beta1 kind: Deployment metadata: name: website-controller spec: replicas: 1 template: ...'}, {'highlight': 'The controller will shut down and remove the web server serving that website as soon as a user deletes the Website instance.'}, {'highlight': 'Running the controller inside Kubernetes itself is the best way to deploy it into production, rather than running it on a local development laptop.'}]"
459,548,0,[],"516
CHAPTER 18
Extending Kubernetes
    metadata:
      name: website-controller
      labels:
        app: website-controller
    spec:
      serviceAccountName: website-controller    
      containers:                                    
      - name: main                                   
        image: luksa/website-controller              
      - name: proxy                                  
        image: luksa/kubectl-proxy:1.6.2             
As you can see, the Deployment deploys a single replica of a two-container pod. One
container runs your controller, whereas the other one is the ambassador container
used for simpler communication with the API server. The pod runs under its own spe-
cial ServiceAccount, so you’ll need to create it before you deploy the controller:
$ kubectl create serviceaccount website-controller
serviceaccount ""website-controller"" created
If Role Based Access Control (RBAC) is enabled in your cluster, Kubernetes will not
allow the controller to watch Website resources or create Deployments or Services. To
allow it to do that, you’ll need to bind the website-controller ServiceAccount to the
cluster-admin ClusterRole, by creating a ClusterRoleBinding like this:
$ kubectl create clusterrolebinding website-controller 
➥ --clusterrole=cluster-admin 
➥ --serviceaccount=default:website-controller
clusterrolebinding ""website-controller"" created
Once you have the ServiceAccount and ClusterRoleBinding in place, you can deploy
the controller’s Deployment. 
SEEING THE CONTROLLER IN ACTION
With the controller now running, create the kubia Website resource again:
$ kubectl create -f kubia-website.yaml
website ""kubia"" created
Now, let’s check the controller’s logs (shown in the following listing) to see if it has
received the watch event.
$ kubectl logs website-controller-2429717411-q43zs -c main
2017/02/26 16:54:41 website-controller started.
2017/02/26 16:54:47 Received watch event: ADDED: kubia: https://github.c...
2017/02/26 16:54:47 Creating services with name kubia-website in namespa... 
2017/02/26 16:54:47 Response status: 201 Created
2017/02/26 16:54:47 Creating deployments with name kubia-website in name... 
2017/02/26 16:54:47 Response status: 201 Created
Listing 18.6
Displaying logs of the Website controller
It will run 
under a special 
ServiceAccount.
Two containers: the 
main container and 
the proxy sidecar
 
",[],"[{'entity': 'metadata', 'description': 'a Kubernetes resource metadata', 'category': 'software'}, {'entity': 'name', 'description': 'the name of a Kubernetes resource', 'category': 'software'}, {'entity': 'labels', 'description': 'key-value pairs that provide additional information about a Kubernetes resource', 'category': 'software'}, {'entity': 'app', 'description': 'a label key for identifying an application', 'category': 'software'}, {'entity': 'spec', 'description': 'the specification of a Kubernetes resource', 'category': 'software'}, {'entity': 'serviceAccountName', 'description': 'the name of a service account', 'category': 'software'}, {'entity': 'containers', 'description': 'a list of containers in a pod', 'category': 'software'}, {'entity': 'main', 'description': 'the main container in a pod', 'category': 'software'}, {'entity': 'image', 'description': 'the image used to create a container', 'category': 'software'}, {'entity': 'luksa/website-controller', 'description': 'the image name for the website controller', 'category': 'software'}, {'entity': 'kubectl', 'description': 'a command-line tool for interacting with a Kubernetes cluster', 'category': 'software'}, {'entity': 'create', 'description': 'a command for creating a resource in a Kubernetes cluster', 'category': 'software'}, {'entity': 'serviceaccount', 'description': 'a type of Kubernetes resource that represents a service account', 'category': 'software'}, {'entity': 'Role Based Access Control (RBAC)', 'description': 'a mechanism for controlling access to resources in a Kubernetes cluster', 'category': 'software'}, {'entity': 'ClusterRoleBinding', 'description': 'a type of Kubernetes resource that represents a binding between a service account and a cluster role', 'category': 'software'}, {'entity': 'cluster-admin', 'description': 'a cluster role that provides full access to all resources in a Kubernetes cluster', 'category': 'software'}, {'entity': 'Deployment', 'description': 'a type of Kubernetes resource that represents a deployment of an application', 'category': 'software'}, {'entity': 'ServiceAccount', 'description': 'a type of Kubernetes resource that represents a service account', 'category': 'software'}, {'entity': 'ClusterRole', 'description': 'a type of Kubernetes resource that represents a cluster role', 'category': 'software'}, {'entity': 'ClusterRoleBinding', 'description': 'a type of Kubernetes resource that represents a binding between a service account and a cluster role', 'category': 'software'}, {'entity': 'kubia Website', 'description': 'a type of Kubernetes resource that represents the kubia website', 'category': 'software'}, {'entity': 'kubectl logs', 'description': 'a command for displaying the logs of a pod in a Kubernetes cluster', 'category': 'software'}, {'entity': 'website-controller', 'description': 'the name of the website controller service account', 'category': 'software'}, {'entity': 'main container', 'description': 'the main container in a pod', 'category': 'software'}, {'entity': 'proxy sidecar', 'description': 'a type of container that provides proxy functionality', 'category': 'software'}]","[{'source_entity': '""metadata""', 'description': 'defines', 'destination_entity': '""ClusterRole""'}, {'source_entity': '""ClusterRole""', 'description': 'implements', 'destination_entity': '""Role Based Access Control (RBAC)""'}, {'source_entity': '""spec""', 'description': 'contains', 'destination_entity': '""name""'}, {'source_entity': '""name""', 'description': 'is assigned to', 'destination_entity': '""containers""'}, {'source_entity': '""Deployment""', 'description': 'creates', 'destination_entity': '""ServiceAccount""'}, {'source_entity': '""create""', 'description': 'action performed by', 'destination_entity': '""kubectl logs""'}, {'source_entity': '""ServiceAccount""', 'description': 'is bound to', 'destination_entity': '""ClusterRoleBinding""'}, {'source_entity': '""image""', 'description': 'used by', 'destination_entity': '""main container""'}, {'source_entity': '""main container""', 'description': 'runs', 'destination_entity': '""kubia Website""'}, {'source_entity': '""kubectl logs""', 'description': 'displays', 'destination_entity': '""app labels""'}, {'source_entity': '""labels""', 'description': 'applied to', 'destination_entity': '""main container""'}, {'source_entity': '""kubectl""', 'description': 'executes', 'destination_entity': '""main container""'}, {'source_entity': '""serviceaccount""', 'description': 'is used by', 'destination_entity': '""website-controller""'}]","['[\n  {\n    ""source"": ""metadata"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""defines"",\n    ""summary_er"": ""The metadata defines a pod, which is a containerized application in Kubernetes.""\n  },\n  {\n    ""source"": ""ClusterRole"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""assigns permissions to"",\n    ""summary_er"": ""A ClusterRole assigns permissions to a pod, allowing it to access cluster resources.""\n  }\n]', '[\n  {\n    ""source"": ""ClusterRole"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""implements"",\n    ""summary_er"": ""A ClusterRole defines a set of permissions for pods, implementing Role-Based Access Control (RBAC) to manage access control within a Kubernetes cluster.""\n  }\n]', '[\n  {\n    ""source"": ""spec"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""contains"",\n    ""summary_er"": ""The Kubernetes configuration specification defines a pod, which is a logical host for one or more application containers.""\n  }\n]', '[\n  {\n    ""source"": ""Pod"",\n    ""destination"": ""Container"",\n    ""relation_description"": ""is assigned to"",\n    ""summary_er"": ""A container is a lightweight and portable executable that runs within a pod, providing isolation and resource management.""\n  },\n  {\n    ""source"": ""Pod"",\n    ""destination"": ""Containers"",\n    ""relation_description"": ""contains"",\n    ""summary_er"": ""A pod can contain one or more containers, which share the same network namespace and resources.""\n  }\n]', '[\n  {\n    ""source"": ""Deployment"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""creates"",\n    ""summary_er"": ""A Deployment in Kubernetes creates a ReplicaSet, which manages one or more identical pod replicas.""\n  },\n  {\n    ""source"": ""ServiceAccount"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""provides"",\n    ""summary_er"": ""A ServiceAccount provides an identity for pods to authenticate with the API server and access cluster resources.""\n  }\n]', '[\n  {\n    ""source"": ""Kubernetes API"",\n    ""destination"": ""Pod"",\n    ""relation_description"": ""action performed by"",\n    ""summary_er"": ""The Kubernetes API performs actions on a Pod, such as creating or deleting it.""\n  },\n  {\n    ""source"": ""kubectl command"",\n    ""destination"": ""Pod logs"",\n    ""relation_description"": ""retrieve output from"",\n    ""summary_er"": ""The kubectl logs command retrieves the output from a Pod\'s log stream.""\n  }\n]', '[\n  {\n    ""source"": ""ServiceAccount"",\n    ""destination"": ""Pod"",\n    ""relation_description"": ""is bound to"",\n    ""summary_er"": ""A ServiceAccount is bound to a Pod, providing identity and access credentials for the pod to interact with the Kubernetes API.""\n  },\n  {\n    ""source"": ""ClusterRoleBinding"",\n    ""destination"": ""ServiceAccount"",\n    ""relation_description"": ""binds to"",\n    ""summary_er"": ""A ClusterRoleBinding binds a ServiceAccount to a cluster-wide role, granting permissions and access to the service account across the entire cluster.""\n  }\n]', '[\n  {\n    ""source"": ""image"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""used by"",\n    ""summary_er"": ""An image is utilized by a pod, which is a containerized application in Kubernetes.""\n  },\n  {\n    ""source"": ""main container"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""used by"",\n    ""summary_er"": ""The main container is used by the pod, serving as its primary executable component.""\n  }\n]', '[\n  {\n    ""source"": ""main container"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""runs"",\n    ""summary_er"": ""The main container executes within a pod, utilizing the pod\'s resources and environment.""\n  }\n]', '[\n  {\n    ""source"": ""kubectl"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""displays logs"",\n    ""summary_er"": ""Kubectl command displays logs from a running pod.""\n  },\n  {\n    ""source"": ""app labels"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""labels application"",\n    ""summary_er"": ""App labels are used to identify and manage pods in a Kubernetes cluster.""\n  }\n]', '[\n  {\n    ""source"": ""labels"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""applied to"",\n    ""summary_er"": ""Labels are key-value pairs applied to a pod, providing metadata and configuration.""\n  },\n  {\n    ""source"": ""main container"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""container"",\n    ""summary_er"": ""The main container is the primary executable process running within a pod.""\n  }\n]', '[\n  {\n    ""source"": ""kubectl"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""executes"",\n    ""summary_er"": ""\\""kubectl\\"" executes a command on a \\""pod\\"", allowing for remote access and management of containerized applications.""\n  }\n]', '[\n  {\n    ""source"": ""serviceaccount"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""is used by"",\n    ""summary_er"": ""A service account is utilized by a pod to authenticate and authorize access to cluster resources.""\n  },\n  {\n    ""source"": ""website-controller"",\n    ""destination"": ""pod"",\n    ""relation_description"": ""is used by"",\n    ""summary_er"": ""The website controller is employed by a pod to manage and orchestrate web applications within the cluster.""\n  }\n]']","A Kubernetes Deployment is created with two containers, main and proxy, running under a special ServiceAccount. The controller watches for events and creates resources as needed. A ClusterRoleBinding is required to enable access control. The deployment can be tested by creating a kubia Website resource and checking the controller's logs for watch event and resource creation.","[{'highlight': 'The Deployment deploys a single replica of a two-container pod, one container running your controller and the other being the ambassador container for simpler communication with the API server.'}, {'highlight': 'To allow the controller to watch Website resources or create Deployments or Services, you need to bind the website-controller ServiceAccount to the cluster-admin ClusterRole using a ClusterRoleBinding.'}, {'highlight': ""The controller's Deployment can be deployed once the ServiceAccount and ClusterRoleBinding are in place.""}, {'highlight': ""To see the controller in action, create the kubia Website resource again after deploying the controller's Deployment.""}, {'highlight': ""The controller's logs show that it has received a watch event and created services and deployments with name kubia-website in namespace default.""}]"
