<html>
    <head>
        <meta charset="utf-8">
        
            <script>function neighbourhoodHighlight(params) {
  // console.log("in nieghbourhoodhighlight");
  allNodes = nodes.get({ returnType: "Object" });
  // originalNodes = JSON.parse(JSON.stringify(allNodes));
  // if something is selected:
  if (params.nodes.length > 0) {
    highlightActive = true;
    var i, j;
    var selectedNode = params.nodes[0];
    var degrees = 2;

    // mark all nodes as hard to read.
    for (let nodeId in allNodes) {
      // nodeColors[nodeId] = allNodes[nodeId].color;
      allNodes[nodeId].color = "rgba(200,200,200,0.5)";
      if (allNodes[nodeId].hiddenLabel === undefined) {
        allNodes[nodeId].hiddenLabel = allNodes[nodeId].label;
        allNodes[nodeId].label = undefined;
      }
    }
    var connectedNodes = network.getConnectedNodes(selectedNode);
    var allConnectedNodes = [];

    // get the second degree nodes
    for (i = 1; i < degrees; i++) {
      for (j = 0; j < connectedNodes.length; j++) {
        allConnectedNodes = allConnectedNodes.concat(
          network.getConnectedNodes(connectedNodes[j])
        );
      }
    }

    // all second degree nodes get a different color and their label back
    for (i = 0; i < allConnectedNodes.length; i++) {
      // allNodes[allConnectedNodes[i]].color = "pink";
      allNodes[allConnectedNodes[i]].color = "rgba(150,150,150,0.75)";
      if (allNodes[allConnectedNodes[i]].hiddenLabel !== undefined) {
        allNodes[allConnectedNodes[i]].label =
          allNodes[allConnectedNodes[i]].hiddenLabel;
        allNodes[allConnectedNodes[i]].hiddenLabel = undefined;
      }
    }

    // all first degree nodes get their own color and their label back
    for (i = 0; i < connectedNodes.length; i++) {
      // allNodes[connectedNodes[i]].color = undefined;
      allNodes[connectedNodes[i]].color = nodeColors[connectedNodes[i]];
      if (allNodes[connectedNodes[i]].hiddenLabel !== undefined) {
        allNodes[connectedNodes[i]].label =
          allNodes[connectedNodes[i]].hiddenLabel;
        allNodes[connectedNodes[i]].hiddenLabel = undefined;
      }
    }

    // the main node gets its own color and its label back.
    // allNodes[selectedNode].color = undefined;
    allNodes[selectedNode].color = nodeColors[selectedNode];
    if (allNodes[selectedNode].hiddenLabel !== undefined) {
      allNodes[selectedNode].label = allNodes[selectedNode].hiddenLabel;
      allNodes[selectedNode].hiddenLabel = undefined;
    }
  } else if (highlightActive === true) {
    // console.log("highlightActive was true");
    // reset all nodes
    for (let nodeId in allNodes) {
      // allNodes[nodeId].color = "purple";
      allNodes[nodeId].color = nodeColors[nodeId];
      // delete allNodes[nodeId].color;
      if (allNodes[nodeId].hiddenLabel !== undefined) {
        allNodes[nodeId].label = allNodes[nodeId].hiddenLabel;
        allNodes[nodeId].hiddenLabel = undefined;
      }
    }
    highlightActive = false;
  }

  // transform the object into an array
  var updateArray = [];
  if (params.nodes.length > 0) {
    for (let nodeId in allNodes) {
      if (allNodes.hasOwnProperty(nodeId)) {
        // console.log(allNodes[nodeId]);
        updateArray.push(allNodes[nodeId]);
      }
    }
    nodes.update(updateArray);
  } else {
    // console.log("Nothing was selected");
    for (let nodeId in allNodes) {
      if (allNodes.hasOwnProperty(nodeId)) {
        // console.log(allNodes[nodeId]);
        // allNodes[nodeId].color = {};
        updateArray.push(allNodes[nodeId]);
      }
    }
    nodes.update(updateArray);
  }
}

function filterHighlight(params) {
  allNodes = nodes.get({ returnType: "Object" });
  // if something is selected:
  if (params.nodes.length > 0) {
    filterActive = true;
    let selectedNodes = params.nodes;

    // hiding all nodes and saving the label
    for (let nodeId in allNodes) {
      allNodes[nodeId].hidden = true;
      if (allNodes[nodeId].savedLabel === undefined) {
        allNodes[nodeId].savedLabel = allNodes[nodeId].label;
        allNodes[nodeId].label = undefined;
      }
    }

    for (let i=0; i < selectedNodes.length; i++) {
      allNodes[selectedNodes[i]].hidden = false;
      if (allNodes[selectedNodes[i]].savedLabel !== undefined) {
        allNodes[selectedNodes[i]].label = allNodes[selectedNodes[i]].savedLabel;
        allNodes[selectedNodes[i]].savedLabel = undefined;
      }
    }

  } else if (filterActive === true) {
    // reset all nodes
    for (let nodeId in allNodes) {
      allNodes[nodeId].hidden = false;
      if (allNodes[nodeId].savedLabel !== undefined) {
        allNodes[nodeId].label = allNodes[nodeId].savedLabel;
        allNodes[nodeId].savedLabel = undefined;
      }
    }
    filterActive = false;
  }

  // transform the object into an array
  var updateArray = [];
  if (params.nodes.length > 0) {
    for (let nodeId in allNodes) {
      if (allNodes.hasOwnProperty(nodeId)) {
        updateArray.push(allNodes[nodeId]);
      }
    }
    nodes.update(updateArray);
  } else {
    for (let nodeId in allNodes) {
      if (allNodes.hasOwnProperty(nodeId)) {
        updateArray.push(allNodes[nodeId]);
      }
    }
    nodes.update(updateArray);
  }
}

function selectNode(nodes) {
  network.selectNodes(nodes);
  neighbourhoodHighlight({ nodes: nodes });
  return nodes;
}

function selectNodes(nodes) {
  network.selectNodes(nodes);
  filterHighlight({nodes: nodes});
  return nodes;
}

function highlightFilter(filter) {
  let selectedNodes = []
  let selectedProp = filter['property']
  if (filter['item'] === 'node') {
    let allNodes = nodes.get({ returnType: "Object" });
    for (let nodeId in allNodes) {
      if (allNodes[nodeId][selectedProp] && filter['value'].includes((allNodes[nodeId][selectedProp]).toString())) {
        selectedNodes.push(nodeId)
      }
    }
  }
  else if (filter['item'] === 'edge'){
    let allEdges = edges.get({returnType: 'object'});
    // check if the selected property exists for selected edge and select the nodes connected to the edge
    for (let edge in allEdges) {
      if (allEdges[edge][selectedProp] && filter['value'].includes((allEdges[edge][selectedProp]).toString())) {
        selectedNodes.push(allEdges[edge]['from'])
        selectedNodes.push(allEdges[edge]['to'])
      }
    }
  }
  selectNodes(selectedNodes)
}</script>
            <style>.vis-overlay{bottom:0;left:0;position:absolute;right:0;top:0;z-index:10}.vis-active{box-shadow:0 0 10px #86d5f8}.vis [class*=span]{min-height:0;width:auto}div.vis-color-picker{background-color:#fff;border-radius:15px;box-shadow:0 0 10px 0 rgba(0,0,0,.5);display:none;height:444px;left:30px;margin-left:30px;margin-top:-140px;padding:10px;position:absolute;top:0;width:310px;z-index:1}div.vis-color-picker div.vis-arrow{left:5px;position:absolute;top:147px}div.vis-color-picker div.vis-arrow:after,div.vis-color-picker div.vis-arrow:before{border:solid transparent;content:" ";height:0;pointer-events:none;position:absolute;right:100%;top:50%;width:0}div.vis-color-picker div.vis-arrow:after{border-color:hsla(0,0%,100%,0) #fff hsla(0,0%,100%,0) hsla(0,0%,100%,0);border-width:30px;margin-top:-30px}div.vis-color-picker div.vis-color{cursor:pointer;height:289px;position:absolute;width:289px}div.vis-color-picker div.vis-brightness{position:absolute;top:313px}div.vis-color-picker div.vis-opacity{position:absolute;top:350px}div.vis-color-picker div.vis-selector{background:#4c4c4c;background:-moz-linear-gradient(top,#4c4c4c 0,#595959 12%,#666 25%,#474747 39%,#2c2c2c 50%,#000 51%,#111 60%,#2b2b2b 76%,#1c1c1c 91%,#131313 100%);background:-webkit-gradient(linear,left top,left bottom,color-stop(0,#4c4c4c),color-stop(12%,#595959),color-stop(25%,#666),color-stop(39%,#474747),color-stop(50%,#2c2c2c),color-stop(51%,#000),color-stop(60%,#111),color-stop(76%,#2b2b2b),color-stop(91%,#1c1c1c),color-stop(100%,#131313));background:-webkit-linear-gradient(top,#4c4c4c,#595959 12%,#666 25%,#474747 39%,#2c2c2c 50%,#000 51%,#111 60%,#2b2b2b 76%,#1c1c1c 91%,#131313);background:-o-linear-gradient(top,#4c4c4c 0,#595959 12%,#666 25%,#474747 39%,#2c2c2c 50%,#000 51%,#111 60%,#2b2b2b 76%,#1c1c1c 91%,#131313 100%);background:-ms-linear-gradient(top,#4c4c4c 0,#595959 12%,#666 25%,#474747 39%,#2c2c2c 50%,#000 51%,#111 60%,#2b2b2b 76%,#1c1c1c 91%,#131313 100%);background:linear-gradient(180deg,#4c4c4c 0,#595959 12%,#666 25%,#474747 39%,#2c2c2c 50%,#000 51%,#111 60%,#2b2b2b 76%,#1c1c1c 91%,#131313);border:1px solid #fff;border-radius:15px;filter:progid:DXImageTransform.Microsoft.gradient(startColorstr="#4c4c4c",endColorstr="#131313",GradientType=0);height:15px;left:137px;position:absolute;top:137px;width:15px}div.vis-color-picker div.vis-new-color{left:159px;padding-right:2px;text-align:right}div.vis-color-picker div.vis-initial-color,div.vis-color-picker div.vis-new-color{border:1px solid rgba(0,0,0,.1);border-radius:5px;color:rgba(0,0,0,.4);font-size:10px;height:20px;line-height:20px;position:absolute;top:380px;vertical-align:middle;width:140px}div.vis-color-picker div.vis-initial-color{left:10px;padding-left:2px;text-align:left}div.vis-color-picker div.vis-label{left:10px;position:absolute;width:300px}div.vis-color-picker div.vis-label.vis-brightness{top:300px}div.vis-color-picker div.vis-label.vis-opacity{top:338px}div.vis-color-picker div.vis-button{background-color:#f7f7f7;border:2px solid #d9d9d9;border-radius:10px;cursor:pointer;height:25px;line-height:25px;position:absolute;text-align:center;top:410px;vertical-align:middle;width:68px}div.vis-color-picker div.vis-button.vis-cancel{left:5px}div.vis-color-picker div.vis-button.vis-load{left:82px}div.vis-color-picker div.vis-button.vis-apply{left:159px}div.vis-color-picker div.vis-button.vis-save{left:236px}div.vis-color-picker input.vis-range{height:20px;width:290px}div.vis-configuration{display:block;float:left;font-size:12px;position:relative}div.vis-configuration-wrapper{display:block;width:700px}div.vis-configuration-wrapper:after{clear:both;content:"";display:block}div.vis-configuration.vis-config-option-container{background-color:#fff;border:2px solid #f7f8fa;border-radius:4px;display:block;left:10px;margin-top:20px;padding-left:5px;width:495px}div.vis-configuration.vis-config-button{background-color:#f7f8fa;border:2px solid #ceced0;border-radius:4px;cursor:pointer;display:block;height:25px;left:10px;line-height:25px;margin-bottom:30px;margin-top:20px;padding-left:5px;vertical-align:middle;width:495px}div.vis-configuration.vis-config-button.hover{background-color:#4588e6;border:2px solid #214373;color:#fff}div.vis-configuration.vis-config-item{display:block;float:left;height:25px;line-height:25px;vertical-align:middle;width:495px}div.vis-configuration.vis-config-item.vis-config-s2{background-color:#f7f8fa;border-radius:3px;left:10px;padding-left:5px}div.vis-configuration.vis-config-item.vis-config-s3{background-color:#e4e9f0;border-radius:3px;left:20px;padding-left:5px}div.vis-configuration.vis-config-item.vis-config-s4{background-color:#cfd8e6;border-radius:3px;left:30px;padding-left:5px}div.vis-configuration.vis-config-header{font-size:18px;font-weight:700}div.vis-configuration.vis-config-label{height:25px;line-height:25px;width:120px}div.vis-configuration.vis-config-label.vis-config-s3{width:110px}div.vis-configuration.vis-config-label.vis-config-s4{width:100px}div.vis-configuration.vis-config-colorBlock{border:1px solid #444;border-radius:2px;cursor:pointer;height:19px;margin:0;padding:0;top:1px;width:30px}input.vis-configuration.vis-config-checkbox{left:-5px}input.vis-configuration.vis-config-rangeinput{margin:0;padding:1px;pointer-events:none;position:relative;top:-5px;width:60px}input.vis-configuration.vis-config-range{-webkit-appearance:none;background-color:transparent;border:0 solid #fff;height:20px;width:300px}input.vis-configuration.vis-config-range::-webkit-slider-runnable-track{background:#dedede;background:-moz-linear-gradient(top,#dedede 0,#c8c8c8 99%);background:-webkit-gradient(linear,left top,left bottom,color-stop(0,#dedede),color-stop(99%,#c8c8c8));background:-webkit-linear-gradient(top,#dedede,#c8c8c8 99%);background:-o-linear-gradient(top,#dedede 0,#c8c8c8 99%);background:-ms-linear-gradient(top,#dedede 0,#c8c8c8 99%);background:linear-gradient(180deg,#dedede 0,#c8c8c8 99%);border:1px solid #999;border-radius:3px;box-shadow:0 0 3px 0 #aaa;filter:progid:DXImageTransform.Microsoft.gradient(startColorstr="#dedede",endColorstr="#c8c8c8",GradientType=0);height:5px;width:300px}input.vis-configuration.vis-config-range::-webkit-slider-thumb{-webkit-appearance:none;background:#3876c2;background:-moz-linear-gradient(top,#3876c2 0,#385380 100%);background:-webkit-gradient(linear,left top,left bottom,color-stop(0,#3876c2),color-stop(100%,#385380));background:-webkit-linear-gradient(top,#3876c2,#385380);background:-o-linear-gradient(top,#3876c2 0,#385380 100%);background:-ms-linear-gradient(top,#3876c2 0,#385380 100%);background:linear-gradient(180deg,#3876c2 0,#385380);border:1px solid #14334b;border-radius:50%;box-shadow:0 0 1px 0 #111927;filter:progid:DXImageTransform.Microsoft.gradient(startColorstr="#3876c2",endColorstr="#385380",GradientType=0);height:17px;margin-top:-7px;width:17px}input.vis-configuration.vis-config-range:focus{outline:none}input.vis-configuration.vis-config-range:focus::-webkit-slider-runnable-track{background:#9d9d9d;background:-moz-linear-gradient(top,#9d9d9d 0,#c8c8c8 99%);background:-webkit-gradient(linear,left top,left bottom,color-stop(0,#9d9d9d),color-stop(99%,#c8c8c8));background:-webkit-linear-gradient(top,#9d9d9d,#c8c8c8 99%);background:-o-linear-gradient(top,#9d9d9d 0,#c8c8c8 99%);background:-ms-linear-gradient(top,#9d9d9d 0,#c8c8c8 99%);background:linear-gradient(180deg,#9d9d9d 0,#c8c8c8 99%);filter:progid:DXImageTransform.Microsoft.gradient(startColorstr="#9d9d9d",endColorstr="#c8c8c8",GradientType=0)}input.vis-configuration.vis-config-range::-moz-range-track{background:#dedede;background:-moz-linear-gradient(top,#dedede 0,#c8c8c8 99%);background:-webkit-gradient(linear,left top,left bottom,color-stop(0,#dedede),color-stop(99%,#c8c8c8));background:-webkit-linear-gradient(top,#dedede,#c8c8c8 99%);background:-o-linear-gradient(top,#dedede 0,#c8c8c8 99%);background:-ms-linear-gradient(top,#dedede 0,#c8c8c8 99%);background:linear-gradient(180deg,#dedede 0,#c8c8c8 99%);border:1px solid #999;border-radius:3px;box-shadow:0 0 3px 0 #aaa;filter:progid:DXImageTransform.Microsoft.gradient(startColorstr="#dedede",endColorstr="#c8c8c8",GradientType=0);height:10px;width:300px}input.vis-configuration.vis-config-range::-moz-range-thumb{background:#385380;border:none;border-radius:50%;height:16px;width:16px}input.vis-configuration.vis-config-range:-moz-focusring{outline:1px solid #fff;outline-offset:-1px}input.vis-configuration.vis-config-range::-ms-track{background:transparent;border-color:transparent;border-width:6px 0;color:transparent;height:5px;width:300px}input.vis-configuration.vis-config-range::-ms-fill-lower{background:#777;border-radius:10px}input.vis-configuration.vis-config-range::-ms-fill-upper{background:#ddd;border-radius:10px}input.vis-configuration.vis-config-range::-ms-thumb{background:#385380;border:none;border-radius:50%;height:16px;width:16px}input.vis-configuration.vis-config-range:focus::-ms-fill-lower{background:#888}input.vis-configuration.vis-config-range:focus::-ms-fill-upper{background:#ccc}.vis-configuration-popup{background:rgba(57,76,89,.85);border:2px solid #f2faff;border-radius:4px;color:#fff;font-size:14px;height:30px;line-height:30px;position:absolute;text-align:center;-webkit-transition:opacity .3s ease-in-out;-moz-transition:opacity .3s ease-in-out;transition:opacity .3s ease-in-out;width:150px}.vis-configuration-popup:after,.vis-configuration-popup:before{border:solid transparent;content:" ";height:0;left:100%;pointer-events:none;position:absolute;top:50%;width:0}.vis-configuration-popup:after{border-color:rgba(136,183,213,0) rgba(136,183,213,0) rgba(136,183,213,0) rgba(57,76,89,.85);border-width:8px;margin-top:-8px}.vis-configuration-popup:before{border-color:rgba(194,225,245,0) rgba(194,225,245,0) rgba(194,225,245,0) #f2faff;border-width:12px;margin-top:-12px}div.vis-tooltip{background-color:#f5f4ed;border:1px solid #808074;-moz-border-radius:3px;-webkit-border-radius:3px;border-radius:3px;box-shadow:3px 3px 10px rgba(0,0,0,.2);color:#000;font-family:verdana;font-size:14px;padding:5px;pointer-events:none;position:absolute;visibility:hidden;white-space:nowrap;z-index:5}div.vis-network div.vis-navigation div.vis-button{-webkit-touch-callout:none;background-position:2px 2px;background-repeat:no-repeat;-moz-border-radius:17px;border-radius:17px;cursor:pointer;display:inline-block;height:34px;position:absolute;-webkit-user-select:none;-khtml-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;width:34px}div.vis-network div.vis-navigation div.vis-button:hover{box-shadow:0 0 3px 3px rgba(56,207,21,.3)}div.vis-network div.vis-navigation div.vis-button:active{box-shadow:0 0 1px 3px rgba(56,207,21,.95)}div.vis-network div.vis-navigation div.vis-button.vis-up{background-image:url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAACXBIWXMAAAsTAAALEwEAmpwYAAAKT2lDQ1BQaG90b3Nob3AgSUNDIHByb2ZpbGUAAHjanVNnVFPpFj333vRCS4iAlEtvUhUIIFJCi4AUkSYqIQkQSoghodkVUcERRUUEG8igiAOOjoCMFVEsDIoK2AfkIaKOg6OIisr74Xuja9a89+bN/rXXPues852zzwfACAyWSDNRNYAMqUIeEeCDx8TG4eQuQIEKJHAAEAizZCFz/SMBAPh+PDwrIsAHvgABeNMLCADATZvAMByH/w/qQplcAYCEAcB0kThLCIAUAEB6jkKmAEBGAYCdmCZTAKAEAGDLY2LjAFAtAGAnf+bTAICd+Jl7AQBblCEVAaCRACATZYhEAGg7AKzPVopFAFgwABRmS8Q5ANgtADBJV2ZIALC3AMDOEAuyAAgMADBRiIUpAAR7AGDIIyN4AISZABRG8lc88SuuEOcqAAB4mbI8uSQ5RYFbCC1xB1dXLh4ozkkXKxQ2YQJhmkAuwnmZGTKBNA/g88wAAKCRFRHgg/P9eM4Ors7ONo62Dl8t6r8G/yJiYuP+5c+rcEAAAOF0ftH+LC+zGoA7BoBt/qIl7gRoXgugdfeLZrIPQLUAoOnaV/Nw+H48PEWhkLnZ2eXk5NhKxEJbYcpXff5nwl/AV/1s+X48/Pf14L7iJIEyXYFHBPjgwsz0TKUcz5IJhGLc5o9H/LcL//wd0yLESWK5WCoU41EScY5EmozzMqUiiUKSKcUl0v9k4t8s+wM+3zUAsGo+AXuRLahdYwP2SycQWHTA4vcAAPK7b8HUKAgDgGiD4c93/+8//UegJQCAZkmScQAAXkQkLlTKsz/HCAAARKCBKrBBG/TBGCzABhzBBdzBC/xgNoRCJMTCQhBCCmSAHHJgKayCQiiGzbAdKmAv1EAdNMBRaIaTcA4uwlW4Dj1wD/phCJ7BKLyBCQRByAgTYSHaiAFiilgjjggXmYX4IcFIBBKLJCDJiBRRIkuRNUgxUopUIFVIHfI9cgI5h1xGupE7yAAygvyGvEcxlIGyUT3UDLVDuag3GoRGogvQZHQxmo8WoJvQcrQaPYw2oefQq2gP2o8+Q8cwwOgYBzPEbDAuxsNCsTgsCZNjy7EirAyrxhqwVqwDu4n1Y8+xdwQSgUXACTYEd0IgYR5BSFhMWE7YSKggHCQ0EdoJNwkDhFHCJyKTqEu0JroR+cQYYjIxh1hILCPWEo8TLxB7iEPENyQSiUMyJ7mQAkmxpFTSEtJG0m5SI+ksqZs0SBojk8naZGuyBzmULCAryIXkneTD5DPkG+Qh8lsKnWJAcaT4U+IoUspqShnlEOU05QZlmDJBVaOaUt2ooVQRNY9aQq2htlKvUYeoEzR1mjnNgxZJS6WtopXTGmgXaPdpr+h0uhHdlR5Ol9BX0svpR+iX6AP0dwwNhhWDx4hnKBmbGAcYZxl3GK+YTKYZ04sZx1QwNzHrmOeZD5lvVVgqtip8FZHKCpVKlSaVGyovVKmqpqreqgtV81XLVI+pXlN9rkZVM1PjqQnUlqtVqp1Q61MbU2epO6iHqmeob1Q/pH5Z/YkGWcNMw09DpFGgsV/jvMYgC2MZs3gsIWsNq4Z1gTXEJrHN2Xx2KruY/R27iz2qqaE5QzNKM1ezUvOUZj8H45hx+Jx0TgnnKKeX836K3hTvKeIpG6Y0TLkxZVxrqpaXllirSKtRq0frvTau7aedpr1Fu1n7gQ5Bx0onXCdHZ4/OBZ3nU9lT3acKpxZNPTr1ri6qa6UbobtEd79up+6Ynr5egJ5Mb6feeb3n+hx9L/1U/W36p/VHDFgGswwkBtsMzhg8xTVxbzwdL8fb8VFDXcNAQ6VhlWGX4YSRudE8o9VGjUYPjGnGXOMk423GbcajJgYmISZLTepN7ppSTbmmKaY7TDtMx83MzaLN1pk1mz0x1zLnm+eb15vft2BaeFostqi2uGVJsuRaplnutrxuhVo5WaVYVVpds0atna0l1rutu6cRp7lOk06rntZnw7Dxtsm2qbcZsOXYBtuutm22fWFnYhdnt8Wuw+6TvZN9un2N/T0HDYfZDqsdWh1+c7RyFDpWOt6azpzuP33F9JbpL2dYzxDP2DPjthPLKcRpnVOb00dnF2e5c4PziIuJS4LLLpc+Lpsbxt3IveRKdPVxXeF60vWdm7Obwu2o26/uNu5p7ofcn8w0nymeWTNz0MPIQ+BR5dE/C5+VMGvfrH5PQ0+BZ7XnIy9jL5FXrdewt6V3qvdh7xc+9j5yn+M+4zw33jLeWV/MN8C3yLfLT8Nvnl+F30N/I/9k/3r/0QCngCUBZwOJgUGBWwL7+Hp8Ib+OPzrbZfay2e1BjKC5QRVBj4KtguXBrSFoyOyQrSH355jOkc5pDoVQfujW0Adh5mGLw34MJ4WHhVeGP45wiFga0TGXNXfR3ENz30T6RJZE3ptnMU85ry1KNSo+qi5qPNo3ujS6P8YuZlnM1VidWElsSxw5LiquNm5svt/87fOH4p3iC+N7F5gvyF1weaHOwvSFpxapLhIsOpZATIhOOJTwQRAqqBaMJfITdyWOCnnCHcJnIi/RNtGI2ENcKh5O8kgqTXqS7JG8NXkkxTOlLOW5hCepkLxMDUzdmzqeFpp2IG0yPTq9MYOSkZBxQqohTZO2Z+pn5mZ2y6xlhbL+xW6Lty8elQfJa7OQrAVZLQq2QqboVFoo1yoHsmdlV2a/zYnKOZarnivN7cyzytuQN5zvn//tEsIS4ZK2pYZLVy0dWOa9rGo5sjxxedsK4xUFK4ZWBqw8uIq2Km3VT6vtV5eufr0mek1rgV7ByoLBtQFr6wtVCuWFfevc1+1dT1gvWd+1YfqGnRs+FYmKrhTbF5cVf9go3HjlG4dvyr+Z3JS0qavEuWTPZtJm6ebeLZ5bDpaql+aXDm4N2dq0Dd9WtO319kXbL5fNKNu7g7ZDuaO/PLi8ZafJzs07P1SkVPRU+lQ27tLdtWHX+G7R7ht7vPY07NXbW7z3/T7JvttVAVVN1WbVZftJ+7P3P66Jqun4lvttXa1ObXHtxwPSA/0HIw6217nU1R3SPVRSj9Yr60cOxx++/p3vdy0NNg1VjZzG4iNwRHnk6fcJ3/ceDTradox7rOEH0x92HWcdL2pCmvKaRptTmvtbYlu6T8w+0dbq3nr8R9sfD5w0PFl5SvNUyWna6YLTk2fyz4ydlZ19fi753GDborZ752PO32oPb++6EHTh0kX/i+c7vDvOXPK4dPKy2+UTV7hXmq86X23qdOo8/pPTT8e7nLuarrlca7nuer21e2b36RueN87d9L158Rb/1tWeOT3dvfN6b/fF9/XfFt1+cif9zsu72Xcn7q28T7xf9EDtQdlD3YfVP1v+3Njv3H9qwHeg89HcR/cGhYPP/pH1jw9DBY+Zj8uGDYbrnjg+OTniP3L96fynQ89kzyaeF/6i/suuFxYvfvjV69fO0ZjRoZfyl5O/bXyl/erA6xmv28bCxh6+yXgzMV70VvvtwXfcdx3vo98PT+R8IH8o/2j5sfVT0Kf7kxmTk/8EA5jz/GMzLdsAAAAgY0hSTQAAeiUAAICDAAD5/wAAgOkAAHUwAADqYAAAOpgAABdvkl/FRgAABphJREFUeNqcV2twU9cR/nbPlVTHxpKRbNnBLyEbPyJisLEcPwgwUMKQtjNJAzNJZkgNNJOmJaZAaDKlxaXDTIBAcJtOOzSYKSkdiimhAdIMjyT4bYgBYxA2BgcUQPLrCiGDR4qt2x+yXTASFt1/957d7zt3z3d39xDCMQWUfgAz/RI/T4pSTAJpAGL8rECAXX7QFQGq9wOHOxYO1oCgjAdJj1wtB095Giv9TFuZAIWHAziATMPhTAwiHgUkYPXFJu92lMP/2MTpB1AKUCVEgNAcleUo1M+2F8TO6crSTncb1QleAOj2OTSX3Ge1p+Va42m5JrnzbnsCE8Ov+EHgpa0LPLvCJjZ/whuIlN8wAcXG+e1LUn9hm238QU84p1Ld83nsXvuO7Lq+LzKYGAT6/dn58m/HJTYf4O3EShkT8Irpzab1Uz9sGevT5+tWn+j6NB4A5hp/5NSr43xjfd5rW5tT9e3OAhCBiCua5/WsDEls/hdvYklZSwDefmrT8eXmtzuDkb5YZ33p9ndylICAVjWxf39xw/5g5Luv/9H84ZWNcwNEypZT87rXjqyJB85UYDMJYN3U7UdLJ6/6JlgqV517teRqf9uTlug8e1zEk27HgD22o98WsTBh8fWxvjm6ApdONbGvse8LM5NUPOm1Cfabuz3nACAgxX0QEFTJAnjNvLJ+Sepb14KRHnN+Ev+1XJOhZs3Qu1mbG97J2NQgsXroa1dtxrGuf8cHi1mUtPTay0lv1DMJSCRVLtoX+FgGgDQNysBAcez89l9nbbsQSji7rlXkEhjPxb/QatHOcFu0M9zz419oFSRhj/3PuaHiyqasv1Con9NGxHAYUsoCxAqImbYSgCWmFbZQwdsur7N0eC4m6tT6/jUZ750Zeb82c+OZGLWh/2p/W+Kfrmy0hIp/aVKpTSIJEqu2QgFx2iE8CwDp0RbH7Ljng/4yXr+XT3QdyhYsodS0slGr0g2OrEUK7eCrKW82SqzCVz3/yfb6vRwM4xn9rN7JkRkOQRLmfJn2LBPxQjDBqp9lD7XbX7X8pKTP160zR2bdeiX5jYeU/nLSTztNkem3XL5eXbltRUkonBxdgZ2IIUmahUxERQSCVT+rK5hzQ89xQ6P8VaaK1f5VmRvqQ4G+lba+nlnlb5brMhvlk7FBiaPzuwQEmEQhg5BOxMjWTncHc2501cQLkjDTsMCWpyuRQxFP0xXIJfp5FyVW4Zy7KajC06ItbiIGg6ZITBxDxIgbrr1jTSM0fibGIHz8O9sKK0GAibEua9spANh4aY2VmcEg+DEkiBgR/L2hYFgGtcErkQQAMVJgBxyy9hboZzv32v+Kpr7qbEECTAIMAoaJa3qPTmNiiAAgJAjk6J5xhu6HDAIgQYGLmI29PocmMcI8MNYvT1ckfzD9H/ub5br4e4Me9WfOKqtyX6Ud2cwC449PRamifDm6Auc0rTXokci+Xo1EAgBckiDuYGLjpTvntcGIA+SFcp6uUAaAI879VhWrRteYAqn/edq758brXJ1327QMhgJcZjA3EBjNrgZjOG1PkAjyTGENMjZPq5ECQ0MDE9ERBqFZrk0OJ3i4x/7vyIjBxGERt3takgVJEAp9xq3f769WiPDNvSsJdT3HDOEASPelmoBRYT3Kzt5uMtwauJEgSOCpwrk1DIJCoNUMwj9v7MweP9XSQ8/hJPp496fZTAICvLqcyv2B7nRbrgCA03JN5h8ub7A8VqpB437xHvsOy3l3cyaB4L2uqxhti1WLMcSgZQCw7+bOooO3Pk4JBZIYYXISMV5sKH59UePM10GESRGpIf/bE92HU452HywSJIGIllctrhp6YAK5+fHds0lLtJFMXNwkV6fFqA29mROefqiMJj1h6um4a5vY/92dKGaBxIhU5zJTWW2cJmEgGOmeb3c8FxAfb9mdf2RzyGGv5MvU7QwuEySwKHFp/c/M71zA/2F7b1RajnYdLAqMukMVu2YcfmDYE2MD7H+7/Xlq6cRIJqm4zXM+qd3TGjVBir43KSLlXjiELe5TsX+3/yW/ST45PaAHbKmccWh12AP93JNZywj0kSABIobpiXRHjtZ6faout2tyZMadGLXBCxBcvl6NfaAz+tKdFmObpzWl2+tIIBACYy0t/yj34M7HvsKUK+CGassvicX7alYDwwq+vykIEqPVa+Q9gdYk5+V+UE7lj3+FGbuBM/X5JUT8QwIVSSSZiTgmoFR2MfiqYFFPfjpkyrfWPopwxP47AP1pK1g9/dqeAAAAAElFTkSuQmCC");bottom:50px;left:55px}div.vis-network div.vis-navigation div.vis-button.vis-down{background-image:url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAACXBIWXMAAAsTAAALEwEAmpwYAAAKT2lDQ1BQaG90b3Nob3AgSUNDIHByb2ZpbGUAAHjanVNnVFPpFj333vRCS4iAlEtvUhUIIFJCi4AUkSYqIQkQSoghodkVUcERRUUEG8igiAOOjoCMFVEsDIoK2AfkIaKOg6OIisr74Xuja9a89+bN/rXXPues852zzwfACAyWSDNRNYAMqUIeEeCDx8TG4eQuQIEKJHAAEAizZCFz/SMBAPh+PDwrIsAHvgABeNMLCADATZvAMByH/w/qQplcAYCEAcB0kThLCIAUAEB6jkKmAEBGAYCdmCZTAKAEAGDLY2LjAFAtAGAnf+bTAICd+Jl7AQBblCEVAaCRACATZYhEAGg7AKzPVopFAFgwABRmS8Q5ANgtADBJV2ZIALC3AMDOEAuyAAgMADBRiIUpAAR7AGDIIyN4AISZABRG8lc88SuuEOcqAAB4mbI8uSQ5RYFbCC1xB1dXLh4ozkkXKxQ2YQJhmkAuwnmZGTKBNA/g88wAAKCRFRHgg/P9eM4Ors7ONo62Dl8t6r8G/yJiYuP+5c+rcEAAAOF0ftH+LC+zGoA7BoBt/qIl7gRoXgugdfeLZrIPQLUAoOnaV/Nw+H48PEWhkLnZ2eXk5NhKxEJbYcpXff5nwl/AV/1s+X48/Pf14L7iJIEyXYFHBPjgwsz0TKUcz5IJhGLc5o9H/LcL//wd0yLESWK5WCoU41EScY5EmozzMqUiiUKSKcUl0v9k4t8s+wM+3zUAsGo+AXuRLahdYwP2SycQWHTA4vcAAPK7b8HUKAgDgGiD4c93/+8//UegJQCAZkmScQAAXkQkLlTKsz/HCAAARKCBKrBBG/TBGCzABhzBBdzBC/xgNoRCJMTCQhBCCmSAHHJgKayCQiiGzbAdKmAv1EAdNMBRaIaTcA4uwlW4Dj1wD/phCJ7BKLyBCQRByAgTYSHaiAFiilgjjggXmYX4IcFIBBKLJCDJiBRRIkuRNUgxUopUIFVIHfI9cgI5h1xGupE7yAAygvyGvEcxlIGyUT3UDLVDuag3GoRGogvQZHQxmo8WoJvQcrQaPYw2oefQq2gP2o8+Q8cwwOgYBzPEbDAuxsNCsTgsCZNjy7EirAyrxhqwVqwDu4n1Y8+xdwQSgUXACTYEd0IgYR5BSFhMWE7YSKggHCQ0EdoJNwkDhFHCJyKTqEu0JroR+cQYYjIxh1hILCPWEo8TLxB7iEPENyQSiUMyJ7mQAkmxpFTSEtJG0m5SI+ksqZs0SBojk8naZGuyBzmULCAryIXkneTD5DPkG+Qh8lsKnWJAcaT4U+IoUspqShnlEOU05QZlmDJBVaOaUt2ooVQRNY9aQq2htlKvUYeoEzR1mjnNgxZJS6WtopXTGmgXaPdpr+h0uhHdlR5Ol9BX0svpR+iX6AP0dwwNhhWDx4hnKBmbGAcYZxl3GK+YTKYZ04sZx1QwNzHrmOeZD5lvVVgqtip8FZHKCpVKlSaVGyovVKmqpqreqgtV81XLVI+pXlN9rkZVM1PjqQnUlqtVqp1Q61MbU2epO6iHqmeob1Q/pH5Z/YkGWcNMw09DpFGgsV/jvMYgC2MZs3gsIWsNq4Z1gTXEJrHN2Xx2KruY/R27iz2qqaE5QzNKM1ezUvOUZj8H45hx+Jx0TgnnKKeX836K3hTvKeIpG6Y0TLkxZVxrqpaXllirSKtRq0frvTau7aedpr1Fu1n7gQ5Bx0onXCdHZ4/OBZ3nU9lT3acKpxZNPTr1ri6qa6UbobtEd79up+6Ynr5egJ5Mb6feeb3n+hx9L/1U/W36p/VHDFgGswwkBtsMzhg8xTVxbzwdL8fb8VFDXcNAQ6VhlWGX4YSRudE8o9VGjUYPjGnGXOMk423GbcajJgYmISZLTepN7ppSTbmmKaY7TDtMx83MzaLN1pk1mz0x1zLnm+eb15vft2BaeFostqi2uGVJsuRaplnutrxuhVo5WaVYVVpds0atna0l1rutu6cRp7lOk06rntZnw7Dxtsm2qbcZsOXYBtuutm22fWFnYhdnt8Wuw+6TvZN9un2N/T0HDYfZDqsdWh1+c7RyFDpWOt6azpzuP33F9JbpL2dYzxDP2DPjthPLKcRpnVOb00dnF2e5c4PziIuJS4LLLpc+Lpsbxt3IveRKdPVxXeF60vWdm7Obwu2o26/uNu5p7ofcn8w0nymeWTNz0MPIQ+BR5dE/C5+VMGvfrH5PQ0+BZ7XnIy9jL5FXrdewt6V3qvdh7xc+9j5yn+M+4zw33jLeWV/MN8C3yLfLT8Nvnl+F30N/I/9k/3r/0QCngCUBZwOJgUGBWwL7+Hp8Ib+OPzrbZfay2e1BjKC5QRVBj4KtguXBrSFoyOyQrSH355jOkc5pDoVQfujW0Adh5mGLw34MJ4WHhVeGP45wiFga0TGXNXfR3ENz30T6RJZE3ptnMU85ry1KNSo+qi5qPNo3ujS6P8YuZlnM1VidWElsSxw5LiquNm5svt/87fOH4p3iC+N7F5gvyF1weaHOwvSFpxapLhIsOpZATIhOOJTwQRAqqBaMJfITdyWOCnnCHcJnIi/RNtGI2ENcKh5O8kgqTXqS7JG8NXkkxTOlLOW5hCepkLxMDUzdmzqeFpp2IG0yPTq9MYOSkZBxQqohTZO2Z+pn5mZ2y6xlhbL+xW6Lty8elQfJa7OQrAVZLQq2QqboVFoo1yoHsmdlV2a/zYnKOZarnivN7cyzytuQN5zvn//tEsIS4ZK2pYZLVy0dWOa9rGo5sjxxedsK4xUFK4ZWBqw8uIq2Km3VT6vtV5eufr0mek1rgV7ByoLBtQFr6wtVCuWFfevc1+1dT1gvWd+1YfqGnRs+FYmKrhTbF5cVf9go3HjlG4dvyr+Z3JS0qavEuWTPZtJm6ebeLZ5bDpaql+aXDm4N2dq0Dd9WtO319kXbL5fNKNu7g7ZDuaO/PLi8ZafJzs07P1SkVPRU+lQ27tLdtWHX+G7R7ht7vPY07NXbW7z3/T7JvttVAVVN1WbVZftJ+7P3P66Jqun4lvttXa1ObXHtxwPSA/0HIw6217nU1R3SPVRSj9Yr60cOxx++/p3vdy0NNg1VjZzG4iNwRHnk6fcJ3/ceDTradox7rOEH0x92HWcdL2pCmvKaRptTmvtbYlu6T8w+0dbq3nr8R9sfD5w0PFl5SvNUyWna6YLTk2fyz4ydlZ19fi753GDborZ752PO32oPb++6EHTh0kX/i+c7vDvOXPK4dPKy2+UTV7hXmq86X23qdOo8/pPTT8e7nLuarrlca7nuer21e2b36RueN87d9L158Rb/1tWeOT3dvfN6b/fF9/XfFt1+cif9zsu72Xcn7q28T7xf9EDtQdlD3YfVP1v+3Njv3H9qwHeg89HcR/cGhYPP/pH1jw9DBY+Zj8uGDYbrnjg+OTniP3L96fynQ89kzyaeF/6i/suuFxYvfvjV69fO0ZjRoZfyl5O/bXyl/erA6xmv28bCxh6+yXgzMV70VvvtwXfcdx3vo98PT+R8IH8o/2j5sfVT0Kf7kxmTk/8EA5jz/GMzLdsAAAAgY0hSTQAAeiUAAICDAAD5/wAAgOkAAHUwAADqYAAAOpgAABdvkl/FRgAABpdJREFUeNqcV21QlNcVfp5zX9ikoAvLEsAIIgsoHwpqWAQUNKLNaNv8iZ1JMkNG6/Qj/dDUyCSTtCHpmEkwVk3TToZRMjXj5MOG2KidjIkxQYSAQUAtX6IgIN8su8KCoOzbH4sk4q5g77/33uee555z7rnneYmZDB2MKcJKlyYbqOsZVIgGEOgSHQoy4AKbFFjqAo5dWn/rNAh9OpO852oeJHYxtrmEu4WALhMbxG2ZE9uFAlImDRLY/t/y0b3Ig+u+iWOKsAlgIZSb0OIf15kWtKo1NXh1d5xxiSPEN2wUAHrGOg11jirjWVtJyFnb6YgrzoYwocClu0DI5guPDb43Y2LLp/Iaqf9JCGSErGvIifxd7aqQn/TOJCvFvZ8Hf9haEH+m/6sFQgHBv1Sts/15WmJLkeyl6FuFwFPzny1/ZdE7Nfg/xhv1uUmH2w6kggQp+yqze7d5JbZ8Im+KpucSwI6EN7/cYtlxZarBCts3ptfrtq9odjaGKihE+sV0vRC3u8RqWmmbij149W+Wd5p2rnET6bsqsntyb6+pO3KqkE8FvLxo74lNUX9s9uTJb8/9fG2L81KoogJFYfCm3b9usNq0MXxzw1RsUkDqQICPqf/b/q8sQi3j4WdmtV47OFgNAO6r+DEUFAtFAc9YtpXmRP6hxVsI24cvhyoqnFtrK6jM7isgBa3Dl0O94TeGb255MvzXpUIFjVrhxo/dzgoARBuwFQJkBK9reCnurxfvXX8CRW3yW1G749vT2Br7ysW0oNX1pKDTPG+rm1gHRbibAHLm/7522sKnQCZqFgCUaBCqaS/bEw9vqtWoQROf3dBBiT6KTACImZ3YueqhDdOWjDbFQ4IzIl4elNUX5begU1HD6lPRmULKeghhDcpqnUmZuD3+nkgTH6gZEE9ctlZSoGmG9UIynSCsQVndMyX+IZGiBoHMjHh2SreCglClaSBiSEG8cYnD24bv7CWms/3FocO3hnw13plTggAFb196NdlPM44tC0zrSg5ItXmyEz070UEKCMRqQgkkBQ9NvL2eSJ+revoJTORSpoT6do4/7/7UShBFHQexM+HdfyUHWO8iN/uaRzX3/QjUSLlnqM72F4cCRIY5u9Zf+Y+BAv4AvzpkQ7WAIBRujA/7Vg6cia9xlId6InafVEAAGnQMUCSkb6zTMPdBy8hU3JjrphIq+CrD+Mvxeyumrr+4IH9y7o2GF5eDghuuGx4L2zbWZ9Dc0RoQRbkkFNRdP2/0BH7EtLJLKCjr+zqh2l5u8haZ847vTBW24kRFQXKAtcsT5oqz3igQENIoECkjBJUDZSGewBlBj/ammjLrdX1c/t70ero34gMte9IByLLAjPrUwKweT5jawQshdIuGMiF5XEBU2koivBl9NeEfJeYHwuxtI81zPrn2z6ip60c6DkV1jLTOCTaE2HNjd5Z4s9MwWBOhqEHp/I9cWDtUrJNoHm4KO9P7hdnTBoMYXI8Gb6gVCg63FS53jg9O5tA57tSOdHywnCAygrJrfcTgUe5U2cvNHSPtYYoKCWlrTgsIneB2AfFR+4F4b6f9ZdTzF6P8Ytud407/dy/nL7k9X9i8J9l5y+Ef6RfbnjPvWa8N5suez+KFCgqyPY95Lnd3stv2AcBZ2+mFbze+lui1xc3dXCUUlPafXNx4/aKxcajWWNp/MklRw8/mPFntbd+h1oLE847KhQQxejVg36QQqD0MPTzHv42Ux+uGasJNBnPfwllJd71kkX7RQ3WDNf7dox3BLcNNs6vt34bbbvYHJhlTGp6O+JVHb0/2HJtX1PH+aqECqG/5YN1nlXcokGvvO6vCc4x+QskotxVHB/qa+xbOWuzw8NB3nuo+Ht0z2hHsuGU3GrWAoZfi3jrxgHpw3BPpobaCH7vbqOw6mHI836vYW3Eqcq9AtioqbJy7ufQ3lhfu8sR+s9+3vL8klACsQSu7AnxMY1MxH7YXJp7oPpLulrrj+9575Ni2aeVt1teWfEWfHQLCaspseHzOU7VWU+aM5G2NoyL4i+6j8XWDNQsmGsKu/cv+nTtjQb/mm7hfENyvqEAK5v8opjPJaL26KGBpd5TfguuBvuZRgBgY6zO0jlyZXXe9JqR+8MK8ntHOMHfHIkhu2b/0yIH7/oXJ0yFlxYnPUdRbvuILgO7+y+91l6Ka6M+cnCf4fMSypXvymHf/vzBTD3CuNGUFKT8lmK5Rs5ASqKiBlAGBXFaiSuni0fkp1pJ7Ed4e/xsAqLk46EWsG1EAAAAASUVORK5CYII=");bottom:10px;left:55px}div.vis-network div.vis-navigation div.vis-button.vis-left{background-image:url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAACXBIWXMAAAsTAAALEwEAmpwYAAAKT2lDQ1BQaG90b3Nob3AgSUNDIHByb2ZpbGUAAHjanVNnVFPpFj333vRCS4iAlEtvUhUIIFJCi4AUkSYqIQkQSoghodkVUcERRUUEG8igiAOOjoCMFVEsDIoK2AfkIaKOg6OIisr74Xuja9a89+bN/rXXPues852zzwfACAyWSDNRNYAMqUIeEeCDx8TG4eQuQIEKJHAAEAizZCFz/SMBAPh+PDwrIsAHvgABeNMLCADATZvAMByH/w/qQplcAYCEAcB0kThLCIAUAEB6jkKmAEBGAYCdmCZTAKAEAGDLY2LjAFAtAGAnf+bTAICd+Jl7AQBblCEVAaCRACATZYhEAGg7AKzPVopFAFgwABRmS8Q5ANgtADBJV2ZIALC3AMDOEAuyAAgMADBRiIUpAAR7AGDIIyN4AISZABRG8lc88SuuEOcqAAB4mbI8uSQ5RYFbCC1xB1dXLh4ozkkXKxQ2YQJhmkAuwnmZGTKBNA/g88wAAKCRFRHgg/P9eM4Ors7ONo62Dl8t6r8G/yJiYuP+5c+rcEAAAOF0ftH+LC+zGoA7BoBt/qIl7gRoXgugdfeLZrIPQLUAoOnaV/Nw+H48PEWhkLnZ2eXk5NhKxEJbYcpXff5nwl/AV/1s+X48/Pf14L7iJIEyXYFHBPjgwsz0TKUcz5IJhGLc5o9H/LcL//wd0yLESWK5WCoU41EScY5EmozzMqUiiUKSKcUl0v9k4t8s+wM+3zUAsGo+AXuRLahdYwP2SycQWHTA4vcAAPK7b8HUKAgDgGiD4c93/+8//UegJQCAZkmScQAAXkQkLlTKsz/HCAAARKCBKrBBG/TBGCzABhzBBdzBC/xgNoRCJMTCQhBCCmSAHHJgKayCQiiGzbAdKmAv1EAdNMBRaIaTcA4uwlW4Dj1wD/phCJ7BKLyBCQRByAgTYSHaiAFiilgjjggXmYX4IcFIBBKLJCDJiBRRIkuRNUgxUopUIFVIHfI9cgI5h1xGupE7yAAygvyGvEcxlIGyUT3UDLVDuag3GoRGogvQZHQxmo8WoJvQcrQaPYw2oefQq2gP2o8+Q8cwwOgYBzPEbDAuxsNCsTgsCZNjy7EirAyrxhqwVqwDu4n1Y8+xdwQSgUXACTYEd0IgYR5BSFhMWE7YSKggHCQ0EdoJNwkDhFHCJyKTqEu0JroR+cQYYjIxh1hILCPWEo8TLxB7iEPENyQSiUMyJ7mQAkmxpFTSEtJG0m5SI+ksqZs0SBojk8naZGuyBzmULCAryIXkneTD5DPkG+Qh8lsKnWJAcaT4U+IoUspqShnlEOU05QZlmDJBVaOaUt2ooVQRNY9aQq2htlKvUYeoEzR1mjnNgxZJS6WtopXTGmgXaPdpr+h0uhHdlR5Ol9BX0svpR+iX6AP0dwwNhhWDx4hnKBmbGAcYZxl3GK+YTKYZ04sZx1QwNzHrmOeZD5lvVVgqtip8FZHKCpVKlSaVGyovVKmqpqreqgtV81XLVI+pXlN9rkZVM1PjqQnUlqtVqp1Q61MbU2epO6iHqmeob1Q/pH5Z/YkGWcNMw09DpFGgsV/jvMYgC2MZs3gsIWsNq4Z1gTXEJrHN2Xx2KruY/R27iz2qqaE5QzNKM1ezUvOUZj8H45hx+Jx0TgnnKKeX836K3hTvKeIpG6Y0TLkxZVxrqpaXllirSKtRq0frvTau7aedpr1Fu1n7gQ5Bx0onXCdHZ4/OBZ3nU9lT3acKpxZNPTr1ri6qa6UbobtEd79up+6Ynr5egJ5Mb6feeb3n+hx9L/1U/W36p/VHDFgGswwkBtsMzhg8xTVxbzwdL8fb8VFDXcNAQ6VhlWGX4YSRudE8o9VGjUYPjGnGXOMk423GbcajJgYmISZLTepN7ppSTbmmKaY7TDtMx83MzaLN1pk1mz0x1zLnm+eb15vft2BaeFostqi2uGVJsuRaplnutrxuhVo5WaVYVVpds0atna0l1rutu6cRp7lOk06rntZnw7Dxtsm2qbcZsOXYBtuutm22fWFnYhdnt8Wuw+6TvZN9un2N/T0HDYfZDqsdWh1+c7RyFDpWOt6azpzuP33F9JbpL2dYzxDP2DPjthPLKcRpnVOb00dnF2e5c4PziIuJS4LLLpc+Lpsbxt3IveRKdPVxXeF60vWdm7Obwu2o26/uNu5p7ofcn8w0nymeWTNz0MPIQ+BR5dE/C5+VMGvfrH5PQ0+BZ7XnIy9jL5FXrdewt6V3qvdh7xc+9j5yn+M+4zw33jLeWV/MN8C3yLfLT8Nvnl+F30N/I/9k/3r/0QCngCUBZwOJgUGBWwL7+Hp8Ib+OPzrbZfay2e1BjKC5QRVBj4KtguXBrSFoyOyQrSH355jOkc5pDoVQfujW0Adh5mGLw34MJ4WHhVeGP45wiFga0TGXNXfR3ENz30T6RJZE3ptnMU85ry1KNSo+qi5qPNo3ujS6P8YuZlnM1VidWElsSxw5LiquNm5svt/87fOH4p3iC+N7F5gvyF1weaHOwvSFpxapLhIsOpZATIhOOJTwQRAqqBaMJfITdyWOCnnCHcJnIi/RNtGI2ENcKh5O8kgqTXqS7JG8NXkkxTOlLOW5hCepkLxMDUzdmzqeFpp2IG0yPTq9MYOSkZBxQqohTZO2Z+pn5mZ2y6xlhbL+xW6Lty8elQfJa7OQrAVZLQq2QqboVFoo1yoHsmdlV2a/zYnKOZarnivN7cyzytuQN5zvn//tEsIS4ZK2pYZLVy0dWOa9rGo5sjxxedsK4xUFK4ZWBqw8uIq2Km3VT6vtV5eufr0mek1rgV7ByoLBtQFr6wtVCuWFfevc1+1dT1gvWd+1YfqGnRs+FYmKrhTbF5cVf9go3HjlG4dvyr+Z3JS0qavEuWTPZtJm6ebeLZ5bDpaql+aXDm4N2dq0Dd9WtO319kXbL5fNKNu7g7ZDuaO/PLi8ZafJzs07P1SkVPRU+lQ27tLdtWHX+G7R7ht7vPY07NXbW7z3/T7JvttVAVVN1WbVZftJ+7P3P66Jqun4lvttXa1ObXHtxwPSA/0HIw6217nU1R3SPVRSj9Yr60cOxx++/p3vdy0NNg1VjZzG4iNwRHnk6fcJ3/ceDTradox7rOEH0x92HWcdL2pCmvKaRptTmvtbYlu6T8w+0dbq3nr8R9sfD5w0PFl5SvNUyWna6YLTk2fyz4ydlZ19fi753GDborZ752PO32oPb++6EHTh0kX/i+c7vDvOXPK4dPKy2+UTV7hXmq86X23qdOo8/pPTT8e7nLuarrlca7nuer21e2b36RueN87d9L158Rb/1tWeOT3dvfN6b/fF9/XfFt1+cif9zsu72Xcn7q28T7xf9EDtQdlD3YfVP1v+3Njv3H9qwHeg89HcR/cGhYPP/pH1jw9DBY+Zj8uGDYbrnjg+OTniP3L96fynQ89kzyaeF/6i/suuFxYvfvjV69fO0ZjRoZfyl5O/bXyl/erA6xmv28bCxh6+yXgzMV70VvvtwXfcdx3vo98PT+R8IH8o/2j5sfVT0Kf7kxmTk/8EA5jz/GMzLdsAAAAgY0hSTQAAeiUAAICDAAD5/wAAgOkAAHUwAADqYAAAOpgAABdvkl/FRgAABt5JREFUeNqsl2lUlOcVx//3Pi9DZRsGBgYiS2RYBQKIjAhEJW4pNrXNMbZpWtTGNkttYmJMG5soSZckRk+0p+dYPYY0Gk0ihlhRj63GhVUgBhDD5oIOy8AAMwzD4lCYtx+GqCQKuNyP7/Pc+3u2+7/3JUzEZFBYLh62S7yIZDmVBEIBqOwsQ4DNdtBFASq2A4cuZAwVgCCPF5LGHM0Chz+E1XamzUyAzCMO7IhMI+5MDCK+HpCANd+U2rYgC/Y7BoflYgVA2RAOoNYtyjDTe45+hk96e5QywaJR+NsAwDhocK61VCjLTYWaclNB0OW+en8mhl22g8C/rn7U+uGEwdov+C0i+Q0mIFWzoD7zwVU1czQ/6pjIreR3HPX5VL9jalHXiQgmBoH+XLHAtH5csDaXtxDLLzIBv5jyfOmG2H9U4S7snbpX43KaPpgBIhDx1rPzOlbfPC5GQT/nd1mS1zABa6PfPf5y5F/rcJeWpp7fPkly6f7KXBRCoOSATFfXll19x74HDsvFCghsJAG8HrvlvytCXm7EPVqc5wyzp5NX15muE1omKXXyMnd9yy5r5Q3wPghvJzrLAlimXV38+7D1DbhPFq1M6O4b6rPVWKsCBfHi5EWWv9TkQBYAEPpLvERMC9N8FtRvjt9dPl6wwo5jPvuas7WV5jNqEjz8wA+CBsaan+w9x1hrrXJtuaZX97ooLfqPLCUEGRR+iOwAsF2X98Uc30W3fb02u41frVqeVmo6FUkkwCAwCWxJ2Ls/0TPFNBb8TNdp9WvnVz4OAKdmX2QOzcMsAAjziDGMBd3asCF6SXHyknJTfqQTK+zpvhnVKT5zawCgzFTgN94pJXvP7gxxjTAIkpB+MnSWRMQZYEDnPVt/K4ejbZ/77726Lb6h95tAAiPELaJ1bcTbRfGeM8xv1azWSeyEa0P9igk+Nr1+oNFfkpwzJCJKIQA679ntN08yDXYo3qh+LuUrc0E4EcNL4dP7VNDzpU8FP3vpekoQQ5CEw4bPdEfa9+sAgEZUmkmAAAS5hLQ9p11XGO+pM8V5JLUfMeQARDMlEMKIGFOVCZYb0C7Fz0oeXmIZ6nZzYoV9od/jVS+GbahUOnn9b7T6sEOviUGyA8bMDlUa0W79wBW/bZf+lrY98cDBUI8YCxGDgHCJiVVEDN8R7QWAE8Z/+1mGut2i3eP1r0S+XRztkdBzq6NbF7WpbF3UprKxjvfHxbrfttla/QBArVDbJJIAQCURMRg8ugrKIAKBSNxzHtN3VdmxY0iQYSZmTeegwTlgknYAAB7RZBh2Nm7urbeeC1r19ROT52kWn3shfH2Fu1AO3RxjY/0fdac7/hPPJMDE11GC+HpBJmIEuAS3Oa6w01lybMbMgvgCE6O255zy24DeCr/Bvckn9+u8ZjXYIYvjxoMJy8oeXZrT9GHIqMWTwA2oI6cFMeDIcAiSEOyibXsmZG0hAFzuq1OyY6xBAnMJgdPOmks08zU/bbsB9x18P37PqS/b8+o/a96ZcLm3PmBH46Z5x40HW1eFvl4Uq0w0MwiCBOb7/qTsd6GvVY537DXWas1Iw1AiNJnOgwJi+bXhAbE08OnvaXSIW0TvYw88eaF/uM/WNdju3m5r9TlhPBzVNNDoPGC/5tRma/GJ80xqjPPUjVuvP2narrMOWd1Jlv/E1fN782UiNPZf9C/qOKa+ndOz2j+cz046sn+6KrVOsODirpOxld0lUxmEBK/ktvGgFd2l6taBZn9BAtEz5xYIvAn4/8rFKkgstAyZ6Yf+S67ezlkiSU73XXRV6xqh93TyssR4JF75efBvymLdE03jgT/Wb5tutLWpGbTm7wHZxQQAT+yDuKLyHRIk4cnAZ4pfCF9/HvfR9uh3xBxtz00BANsVDylnac6wAICaHMiBmW5NRLy4trcq0MtZ3RnpHme5H9AvjYeCc1t3pzMJgOSVnyw4eHZUB9Kyu68iMFPpysSppab8UJVC3Rnp/pDlXqF7mnYsdKQbv7cr6fDGW/Zczbt6jgUtV6kIlFxuyg/tH+6zJXmlGe8G+mlzdsyB1j3pTAwZ9q3/Sspbc9tmDwD0H3UffXCFlyuTlFpnPRdYb612c5c8+idPCu6fCLDKUubzsf6fSaWm0wmO9hbvZU8fDR2zoZ97OuppAu0UJEDEmOISZohT6q7Gek5rD3GN6FEp1DaAYB7sdNYPXPao7anS1Fmrg402g7+jYhGIaOXOaQc+uONfmCwZXJIf8xKx2KRgxYgOS+CROuyoyQKCxIhkOr4T6JWgxGnvZ1HWnf/CfHcBXxcnpRHxYwRKkUjSErFKkAQiNjP4kmBRTHbKm5KkKxwL+K39fwDX1XGF8ct++QAAAABJRU5ErkJggg==");bottom:10px;left:15px}div.vis-network div.vis-navigation div.vis-button.vis-right{background-image:url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAACXBIWXMAAAsTAAALEwEAmpwYAAAKT2lDQ1BQaG90b3Nob3AgSUNDIHByb2ZpbGUAAHjanVNnVFPpFj333vRCS4iAlEtvUhUIIFJCi4AUkSYqIQkQSoghodkVUcERRUUEG8igiAOOjoCMFVEsDIoK2AfkIaKOg6OIisr74Xuja9a89+bN/rXXPues852zzwfACAyWSDNRNYAMqUIeEeCDx8TG4eQuQIEKJHAAEAizZCFz/SMBAPh+PDwrIsAHvgABeNMLCADATZvAMByH/w/qQplcAYCEAcB0kThLCIAUAEB6jkKmAEBGAYCdmCZTAKAEAGDLY2LjAFAtAGAnf+bTAICd+Jl7AQBblCEVAaCRACATZYhEAGg7AKzPVopFAFgwABRmS8Q5ANgtADBJV2ZIALC3AMDOEAuyAAgMADBRiIUpAAR7AGDIIyN4AISZABRG8lc88SuuEOcqAAB4mbI8uSQ5RYFbCC1xB1dXLh4ozkkXKxQ2YQJhmkAuwnmZGTKBNA/g88wAAKCRFRHgg/P9eM4Ors7ONo62Dl8t6r8G/yJiYuP+5c+rcEAAAOF0ftH+LC+zGoA7BoBt/qIl7gRoXgugdfeLZrIPQLUAoOnaV/Nw+H48PEWhkLnZ2eXk5NhKxEJbYcpXff5nwl/AV/1s+X48/Pf14L7iJIEyXYFHBPjgwsz0TKUcz5IJhGLc5o9H/LcL//wd0yLESWK5WCoU41EScY5EmozzMqUiiUKSKcUl0v9k4t8s+wM+3zUAsGo+AXuRLahdYwP2SycQWHTA4vcAAPK7b8HUKAgDgGiD4c93/+8//UegJQCAZkmScQAAXkQkLlTKsz/HCAAARKCBKrBBG/TBGCzABhzBBdzBC/xgNoRCJMTCQhBCCmSAHHJgKayCQiiGzbAdKmAv1EAdNMBRaIaTcA4uwlW4Dj1wD/phCJ7BKLyBCQRByAgTYSHaiAFiilgjjggXmYX4IcFIBBKLJCDJiBRRIkuRNUgxUopUIFVIHfI9cgI5h1xGupE7yAAygvyGvEcxlIGyUT3UDLVDuag3GoRGogvQZHQxmo8WoJvQcrQaPYw2oefQq2gP2o8+Q8cwwOgYBzPEbDAuxsNCsTgsCZNjy7EirAyrxhqwVqwDu4n1Y8+xdwQSgUXACTYEd0IgYR5BSFhMWE7YSKggHCQ0EdoJNwkDhFHCJyKTqEu0JroR+cQYYjIxh1hILCPWEo8TLxB7iEPENyQSiUMyJ7mQAkmxpFTSEtJG0m5SI+ksqZs0SBojk8naZGuyBzmULCAryIXkneTD5DPkG+Qh8lsKnWJAcaT4U+IoUspqShnlEOU05QZlmDJBVaOaUt2ooVQRNY9aQq2htlKvUYeoEzR1mjnNgxZJS6WtopXTGmgXaPdpr+h0uhHdlR5Ol9BX0svpR+iX6AP0dwwNhhWDx4hnKBmbGAcYZxl3GK+YTKYZ04sZx1QwNzHrmOeZD5lvVVgqtip8FZHKCpVKlSaVGyovVKmqpqreqgtV81XLVI+pXlN9rkZVM1PjqQnUlqtVqp1Q61MbU2epO6iHqmeob1Q/pH5Z/YkGWcNMw09DpFGgsV/jvMYgC2MZs3gsIWsNq4Z1gTXEJrHN2Xx2KruY/R27iz2qqaE5QzNKM1ezUvOUZj8H45hx+Jx0TgnnKKeX836K3hTvKeIpG6Y0TLkxZVxrqpaXllirSKtRq0frvTau7aedpr1Fu1n7gQ5Bx0onXCdHZ4/OBZ3nU9lT3acKpxZNPTr1ri6qa6UbobtEd79up+6Ynr5egJ5Mb6feeb3n+hx9L/1U/W36p/VHDFgGswwkBtsMzhg8xTVxbzwdL8fb8VFDXcNAQ6VhlWGX4YSRudE8o9VGjUYPjGnGXOMk423GbcajJgYmISZLTepN7ppSTbmmKaY7TDtMx83MzaLN1pk1mz0x1zLnm+eb15vft2BaeFostqi2uGVJsuRaplnutrxuhVo5WaVYVVpds0atna0l1rutu6cRp7lOk06rntZnw7Dxtsm2qbcZsOXYBtuutm22fWFnYhdnt8Wuw+6TvZN9un2N/T0HDYfZDqsdWh1+c7RyFDpWOt6azpzuP33F9JbpL2dYzxDP2DPjthPLKcRpnVOb00dnF2e5c4PziIuJS4LLLpc+Lpsbxt3IveRKdPVxXeF60vWdm7Obwu2o26/uNu5p7ofcn8w0nymeWTNz0MPIQ+BR5dE/C5+VMGvfrH5PQ0+BZ7XnIy9jL5FXrdewt6V3qvdh7xc+9j5yn+M+4zw33jLeWV/MN8C3yLfLT8Nvnl+F30N/I/9k/3r/0QCngCUBZwOJgUGBWwL7+Hp8Ib+OPzrbZfay2e1BjKC5QRVBj4KtguXBrSFoyOyQrSH355jOkc5pDoVQfujW0Adh5mGLw34MJ4WHhVeGP45wiFga0TGXNXfR3ENz30T6RJZE3ptnMU85ry1KNSo+qi5qPNo3ujS6P8YuZlnM1VidWElsSxw5LiquNm5svt/87fOH4p3iC+N7F5gvyF1weaHOwvSFpxapLhIsOpZATIhOOJTwQRAqqBaMJfITdyWOCnnCHcJnIi/RNtGI2ENcKh5O8kgqTXqS7JG8NXkkxTOlLOW5hCepkLxMDUzdmzqeFpp2IG0yPTq9MYOSkZBxQqohTZO2Z+pn5mZ2y6xlhbL+xW6Lty8elQfJa7OQrAVZLQq2QqboVFoo1yoHsmdlV2a/zYnKOZarnivN7cyzytuQN5zvn//tEsIS4ZK2pYZLVy0dWOa9rGo5sjxxedsK4xUFK4ZWBqw8uIq2Km3VT6vtV5eufr0mek1rgV7ByoLBtQFr6wtVCuWFfevc1+1dT1gvWd+1YfqGnRs+FYmKrhTbF5cVf9go3HjlG4dvyr+Z3JS0qavEuWTPZtJm6ebeLZ5bDpaql+aXDm4N2dq0Dd9WtO319kXbL5fNKNu7g7ZDuaO/PLi8ZafJzs07P1SkVPRU+lQ27tLdtWHX+G7R7ht7vPY07NXbW7z3/T7JvttVAVVN1WbVZftJ+7P3P66Jqun4lvttXa1ObXHtxwPSA/0HIw6217nU1R3SPVRSj9Yr60cOxx++/p3vdy0NNg1VjZzG4iNwRHnk6fcJ3/ceDTradox7rOEH0x92HWcdL2pCmvKaRptTmvtbYlu6T8w+0dbq3nr8R9sfD5w0PFl5SvNUyWna6YLTk2fyz4ydlZ19fi753GDborZ752PO32oPb++6EHTh0kX/i+c7vDvOXPK4dPKy2+UTV7hXmq86X23qdOo8/pPTT8e7nLuarrlca7nuer21e2b36RueN87d9L158Rb/1tWeOT3dvfN6b/fF9/XfFt1+cif9zsu72Xcn7q28T7xf9EDtQdlD3YfVP1v+3Njv3H9qwHeg89HcR/cGhYPP/pH1jw9DBY+Zj8uGDYbrnjg+OTniP3L96fynQ89kzyaeF/6i/suuFxYvfvjV69fO0ZjRoZfyl5O/bXyl/erA6xmv28bCxh6+yXgzMV70VvvtwXfcdx3vo98PT+R8IH8o/2j5sfVT0Kf7kxmTk/8EA5jz/GMzLdsAAAAgY0hSTQAAeiUAAICDAAD5/wAAgOkAAHUwAADqYAAAOpgAABdvkl/FRgAABs1JREFUeNqsl3tQlOcVxp9z3m+XygK7C4sLxkW5o4CAkYssFSkRjabjJEOSJm1IbZx2krapiZdeprW0NVVJ0pqMM0kYJQlqkoZImGioE1ItiCAgIsFwE4Es99vCslwChf36xy5EW1A0Pn9+73fO772e93kJC5EMCszFd20SbyFZNpJAAACtjWUI8KAN1CRAJTbg9LXNU+dBkG+Xkm7Zmg4OWoUdNqZXmQCZHQFsz0yOcCYGEc8mJGDnl2UTh5AO2x2DA3OxDaAsCDvQ32VF11qP9aZYz6SeFeooi17pPQEAvZNdTnWWKnWFuVhfYT7v0zza4M3EsMk2EPgnNZusby8Y7P8x/5lI/gMTYNSnNKQt/0Xtev1DfQtZlaK+M54fmDJXXhg4G8zEINBfqlLMe28L9s/lQ8Tyr5iAJ32fK/tj+OFq3IUO1O+JyGk7GgsiEPFrlQ/07bixXdwEPckHWZJ3MgG7Qw9+/mLIS/W4SyXoNvQskpyHLg1e8CNQ3NI0laoje7Tg/8CBudgGgQwSwO/DD322ze/FFnxLRWhiBzUK94GLA2f9mSTjfU+7mjqyrVe+AX8I4aGgShbA0/47Sn4ZuLcR90ih6qih0anRiVprtUEQb43bYtlXmwNZAEDAj/ACMW1M8ExpeDXyWMVCEl4yF7vntR/zLeov8JJlWfZR+Y3N92+cx/reOmu1quNrk27EWW0xvWspJcigoNNkA4C3Yk59vH7xltvu3ktDxe7PX34ilQCQfeci1j2xfn94ZrGCneY8uxcHCnW/vbr9EQD4d2ITc8AprAOAQLewroVAAaB8oMiLiRHvmVy7znNTjWCFrXKoJOSHFQ+kvnF9f+jco07s91MFdwmSkHQuYB0T8WYwIcYj0bTQdRufGlFKJMFVaCb/GvZW6aGI4yeXOwd2mr/u05zsyDY+W5X64Nm+fO85NpuJiCFJTpslIoonADEeiT2zIzIXuh+o25PQNtbsNVMOBUn2g08MiSTHN3uZjNTEDr4dnX/6H+1H/XPasmKvW+sMGfW/MXzende4K3h/ibvSYxIAItyie/K7cgCitQxCIBFjpTrKMgM+WPfrhLbxFi9iMQtlYjAJSCSBSYBAIPBNI3p86TPXj8bk56R4PVylFE626uFLQc9efiTVPDmgBIAAtzALEYNBQRITa4kYix21FwBax655CVagPLk7806Pj1qo/7MraF/FQ14/aMhszYhvGqn3KTef89rklWrSKXUTkn3mtJK9Bzf3XJA0e/PcrdgxIwSCDPmbZMQgABJkDBKzvn+yy2npIv9xAPB1Ceo2jTZ7Gc8afipIgEhAkACDwcSQQZBIIGnx5it7gg+U3wgcnbZKR1r+FnW+v2DVtDwtXCXNSKz797oAwDzZ7ySRAIBBFsTXmBh1w1+oZ4J3h+wv9lUFdbMDOrO+5IAqWIGZthuV13nC77nKRx8r7PssyibLIkoT1/h65HsfzWyu5tF6NYNB4EYJzKUETqgcLNVv0D/cDQBrNAnm9+LOfTLfNB5u2hf5z+6TMexYji+tVdrM5leMbWOtSwQx/F1C2rcuebIqwSO568a4WmuN3mEYSiUi+pRl2l1pLvYBsKArUKVwnZRYgdHpMWVG4+/WXhwoDBXE7OmkHzJ6JNemLfv51bniGqzVPoIkyLbpfK7ZMFIkE6FlrMn7Ql+BbiHg+zXGbgLjylDpyosD58KZmKM0cfWHI9//aD5o1VCZrnO83VuQQOja5PMCfwK8n3K2ChIbLVOD9KB36le3A+u/s2Q81C2yRavQmQNdVnamLnmq4nHD9jpB0rwm77jpjTW9E906Bu18fWlWCQHAox9CtGoXTwmS8IThZyXPB+29inuoE6bMsDM9ufEAMNHqJuU8ljMtAKA2B7IhzaWNiLfWjVQb3J10/SGuEZZ7Af1X7+lluZ3HkpgEQPL291M+qbzJgXQcG60ypKlVTGwsMxcFaJW6/hDXVZZvCz3RlrmRiQHwy9nRn2bM6bnas4cLfH6s1RIorsJcFDA2PToR7Z7QezfQD9qzwvI6TyTZC47ttXeiT+2c1+wBgOndoTPLt7mrmCRjvfULQ4O1xsVVchu7b9GysYUAqy3lnsdNb0aXmQuj7PYWL2etuRl6S0OfXLjiGQIdEY6K5esc2BWhjvkqXLO6x08VPKxV6iYAwuBkv5NpvNmtbrhaX2+tWdY70eVNINhtLW0/sjrv6B0/YdJlcGlR2AvE4hUlKwHQ7BU5cz8LRx0HaPY7gXb53L/67+mUfudPmP/twOWS6AQi/j6B4iWS/IlYK+yGYJDB1wWLErLRKd/omOJbAWf03wEAyO9m+/TtS3AAAAAASUVORK5CYII=");bottom:10px;left:95px}div.vis-network div.vis-navigation div.vis-button.vis-zoomIn{background-image:url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAACXBIWXMAAAsTAAALEwEAmpwYAAAKT2lDQ1BQaG90b3Nob3AgSUNDIHByb2ZpbGUAAHjanVNnVFPpFj333vRCS4iAlEtvUhUIIFJCi4AUkSYqIQkQSoghodkVUcERRUUEG8igiAOOjoCMFVEsDIoK2AfkIaKOg6OIisr74Xuja9a89+bN/rXXPues852zzwfACAyWSDNRNYAMqUIeEeCDx8TG4eQuQIEKJHAAEAizZCFz/SMBAPh+PDwrIsAHvgABeNMLCADATZvAMByH/w/qQplcAYCEAcB0kThLCIAUAEB6jkKmAEBGAYCdmCZTAKAEAGDLY2LjAFAtAGAnf+bTAICd+Jl7AQBblCEVAaCRACATZYhEAGg7AKzPVopFAFgwABRmS8Q5ANgtADBJV2ZIALC3AMDOEAuyAAgMADBRiIUpAAR7AGDIIyN4AISZABRG8lc88SuuEOcqAAB4mbI8uSQ5RYFbCC1xB1dXLh4ozkkXKxQ2YQJhmkAuwnmZGTKBNA/g88wAAKCRFRHgg/P9eM4Ors7ONo62Dl8t6r8G/yJiYuP+5c+rcEAAAOF0ftH+LC+zGoA7BoBt/qIl7gRoXgugdfeLZrIPQLUAoOnaV/Nw+H48PEWhkLnZ2eXk5NhKxEJbYcpXff5nwl/AV/1s+X48/Pf14L7iJIEyXYFHBPjgwsz0TKUcz5IJhGLc5o9H/LcL//wd0yLESWK5WCoU41EScY5EmozzMqUiiUKSKcUl0v9k4t8s+wM+3zUAsGo+AXuRLahdYwP2SycQWHTA4vcAAPK7b8HUKAgDgGiD4c93/+8//UegJQCAZkmScQAAXkQkLlTKsz/HCAAARKCBKrBBG/TBGCzABhzBBdzBC/xgNoRCJMTCQhBCCmSAHHJgKayCQiiGzbAdKmAv1EAdNMBRaIaTcA4uwlW4Dj1wD/phCJ7BKLyBCQRByAgTYSHaiAFiilgjjggXmYX4IcFIBBKLJCDJiBRRIkuRNUgxUopUIFVIHfI9cgI5h1xGupE7yAAygvyGvEcxlIGyUT3UDLVDuag3GoRGogvQZHQxmo8WoJvQcrQaPYw2oefQq2gP2o8+Q8cwwOgYBzPEbDAuxsNCsTgsCZNjy7EirAyrxhqwVqwDu4n1Y8+xdwQSgUXACTYEd0IgYR5BSFhMWE7YSKggHCQ0EdoJNwkDhFHCJyKTqEu0JroR+cQYYjIxh1hILCPWEo8TLxB7iEPENyQSiUMyJ7mQAkmxpFTSEtJG0m5SI+ksqZs0SBojk8naZGuyBzmULCAryIXkneTD5DPkG+Qh8lsKnWJAcaT4U+IoUspqShnlEOU05QZlmDJBVaOaUt2ooVQRNY9aQq2htlKvUYeoEzR1mjnNgxZJS6WtopXTGmgXaPdpr+h0uhHdlR5Ol9BX0svpR+iX6AP0dwwNhhWDx4hnKBmbGAcYZxl3GK+YTKYZ04sZx1QwNzHrmOeZD5lvVVgqtip8FZHKCpVKlSaVGyovVKmqpqreqgtV81XLVI+pXlN9rkZVM1PjqQnUlqtVqp1Q61MbU2epO6iHqmeob1Q/pH5Z/YkGWcNMw09DpFGgsV/jvMYgC2MZs3gsIWsNq4Z1gTXEJrHN2Xx2KruY/R27iz2qqaE5QzNKM1ezUvOUZj8H45hx+Jx0TgnnKKeX836K3hTvKeIpG6Y0TLkxZVxrqpaXllirSKtRq0frvTau7aedpr1Fu1n7gQ5Bx0onXCdHZ4/OBZ3nU9lT3acKpxZNPTr1ri6qa6UbobtEd79up+6Ynr5egJ5Mb6feeb3n+hx9L/1U/W36p/VHDFgGswwkBtsMzhg8xTVxbzwdL8fb8VFDXcNAQ6VhlWGX4YSRudE8o9VGjUYPjGnGXOMk423GbcajJgYmISZLTepN7ppSTbmmKaY7TDtMx83MzaLN1pk1mz0x1zLnm+eb15vft2BaeFostqi2uGVJsuRaplnutrxuhVo5WaVYVVpds0atna0l1rutu6cRp7lOk06rntZnw7Dxtsm2qbcZsOXYBtuutm22fWFnYhdnt8Wuw+6TvZN9un2N/T0HDYfZDqsdWh1+c7RyFDpWOt6azpzuP33F9JbpL2dYzxDP2DPjthPLKcRpnVOb00dnF2e5c4PziIuJS4LLLpc+Lpsbxt3IveRKdPVxXeF60vWdm7Obwu2o26/uNu5p7ofcn8w0nymeWTNz0MPIQ+BR5dE/C5+VMGvfrH5PQ0+BZ7XnIy9jL5FXrdewt6V3qvdh7xc+9j5yn+M+4zw33jLeWV/MN8C3yLfLT8Nvnl+F30N/I/9k/3r/0QCngCUBZwOJgUGBWwL7+Hp8Ib+OPzrbZfay2e1BjKC5QRVBj4KtguXBrSFoyOyQrSH355jOkc5pDoVQfujW0Adh5mGLw34MJ4WHhVeGP45wiFga0TGXNXfR3ENz30T6RJZE3ptnMU85ry1KNSo+qi5qPNo3ujS6P8YuZlnM1VidWElsSxw5LiquNm5svt/87fOH4p3iC+N7F5gvyF1weaHOwvSFpxapLhIsOpZATIhOOJTwQRAqqBaMJfITdyWOCnnCHcJnIi/RNtGI2ENcKh5O8kgqTXqS7JG8NXkkxTOlLOW5hCepkLxMDUzdmzqeFpp2IG0yPTq9MYOSkZBxQqohTZO2Z+pn5mZ2y6xlhbL+xW6Lty8elQfJa7OQrAVZLQq2QqboVFoo1yoHsmdlV2a/zYnKOZarnivN7cyzytuQN5zvn//tEsIS4ZK2pYZLVy0dWOa9rGo5sjxxedsK4xUFK4ZWBqw8uIq2Km3VT6vtV5eufr0mek1rgV7ByoLBtQFr6wtVCuWFfevc1+1dT1gvWd+1YfqGnRs+FYmKrhTbF5cVf9go3HjlG4dvyr+Z3JS0qavEuWTPZtJm6ebeLZ5bDpaql+aXDm4N2dq0Dd9WtO319kXbL5fNKNu7g7ZDuaO/PLi8ZafJzs07P1SkVPRU+lQ27tLdtWHX+G7R7ht7vPY07NXbW7z3/T7JvttVAVVN1WbVZftJ+7P3P66Jqun4lvttXa1ObXHtxwPSA/0HIw6217nU1R3SPVRSj9Yr60cOxx++/p3vdy0NNg1VjZzG4iNwRHnk6fcJ3/ceDTradox7rOEH0x92HWcdL2pCmvKaRptTmvtbYlu6T8w+0dbq3nr8R9sfD5w0PFl5SvNUyWna6YLTk2fyz4ydlZ19fi753GDborZ752PO32oPb++6EHTh0kX/i+c7vDvOXPK4dPKy2+UTV7hXmq86X23qdOo8/pPTT8e7nLuarrlca7nuer21e2b36RueN87d9L158Rb/1tWeOT3dvfN6b/fF9/XfFt1+cif9zsu72Xcn7q28T7xf9EDtQdlD3YfVP1v+3Njv3H9qwHeg89HcR/cGhYPP/pH1jw9DBY+Zj8uGDYbrnjg+OTniP3L96fynQ89kzyaeF/6i/suuFxYvfvjV69fO0ZjRoZfyl5O/bXyl/erA6xmv28bCxh6+yXgzMV70VvvtwXfcdx3vo98PT+R8IH8o/2j5sfVT0Kf7kxmTk/8EA5jz/GMzLdsAAAAgY0hSTQAAeiUAAICDAAD5/wAAgOkAAHUwAADqYAAAOpgAABdvkl/FRgAABiBJREFUeNqkV2tQlOcVfp7zvgvDRe66y8htXUBR1GoFI+BtFJvRtjPJBGeaH2a8DGmbttgSTWbSJEw6TWOsrbbpTIeJZGqaTipTa6LJZDTVUTYQdNAohoso6qLucnERN0Axcb/8+HaJUHDX9Pz6vnnPe57vXJ5zzkeEIwaYcwBL/VrW0TCKqZANINEvBhSk3w9eUmC9HzjcsfarOhBGKJN84GkVJHcetvqFu4SAIYELYlpm4LpQQMqoQQKVnzeO7EYV/A8NnHMAGwHWQJmAjtg895LkFa7FU1d258UvGLBGpI4AQM9dd2TrwNn4016n9bS3LqNzsD1VKPAbfhCyqflR31thAzv+La+QxotCoNi6pn1D1s9aVli/3xtOVk72fjT1XVf17E9uHZspFBD8zdk13pdCAjsOyG6KUSEEnrT/tPHluW+cw7eQ19q2z6/t2rsYJEjZ07S6d+ukwI5/yQ7RxnYC2DZnx8dbHNs6xxs85T2R9GprZcmVwYs2BYWsmBzP83m7nIVJS73jdfdd+7PjjUu/XWUCGTtPre7ZHjxTY3Kq8DoV8Ou5u49snPGrKxN58syZ9aVXBztsigoUBd+Xt2NbfZ8llaVvah+vOz9hcX+CJenWp7eOOYS6ePpTU1w39vk+AwCzFPdDQbFGFPCUY2v9hqxfXJ0shNeHLtsUFc6UequbVvdVkwLX0GXbZPpl6Zuu/ij9x/VCBU1dU7bfdFYAIDsSFRCgeOqa9hfy/nDhwfwTKOrRd0U95n0iqch9+cKS5JVtpMCdkllhAhugCHcRwAb7z1tCEp8CCXAWAJRoCFXIYnti+sYWTQ0tll0wQMk+hGUAkBOX714xbV1IyuhxHhIMC/iR5OV9M2JmuhU1Vh7PXiakrIUQhcnLXeHQxPT4GyAtFqgwgAPF5iIFWkeu1SSLCKAweXn3/ZR5rXV7SddQpy3YDoNems9qTI5hGCitm1MOAAx0aaFCerTd84zjBed3Egq9ADA/rqD7Q3ctQC4REDmkYHb8goGgsR2tz5V0DV+xUdQoqAQ81RybU4IgFWgACgpaLLCIBUo0bv63y/aXy6+WBHWz4/IHSIGAuVooiaRgWqD3AsDVoQ6bEgtOrfJUhwrf0WUtk+r8sL6wvHvk5ijVUiJSRrQZuURtfoGMuaCoRyfP/yMy0XykgAA0DPRTxNp31x2ZFuUYBgB7bK7HNdhpKz6WXq6oQCooKghMKhkgji77vBoA1jkXlAvVfRQjFMUcmxSkRWd6gpjeu32R2kxTvyhKh1DQeud8fFBh26zfOe0xuR4JgAbzywCoRSzfeDUKatJKUQK+CjKiHZ6nZ2xzBnU7B9vixTy7qCHSQEhJU3+DtdT6mAcAFiWUeP/xyPH3Jwrfo3XzysemRcEA8F5RY8h6aPE1WwMLQ4OQ/EBANHmdGWHlzZyxk3ayB0m771yGooYy+KE0l35x0iBxZehS6ie9R1PCMaDvCzWDXA4hZ283ptwcvp6qqDBnyao6AWEQrBQQ/7y+d3YoA+NBTAaElo973p8tVFCQyipW+c3pdNu7BwBOe+tm/eniK/kPFWowpMfvuKrzzw80zSKIkWsJe0bHYu163BNwMwDsv7G36ODNtzMnM5IWZfeQgscbisvLPl1aDhLTo7I8k+n/p+dw5pGeg0WKGiS31K6vvTdmA7nx9uDZ9A3xMUIpbvSezE6MSOmbNWXewHhD6dH23o7BlqQvvrwTK6KQFpXl2WyvcE6LTB2eCPSdrurvmcUnO/cVfPD6pMteyfGs3QKpUFQoS9tU/xPH8xe+Tdd693pN/pHug0Xmqntvz1uLDo9Z9v5nnrn+dvujrI1JMUJd3OY7n97ua46douOGpkdlDoUDeG7g1NS/u/5a0Og9scCsB+ysWXSoMuyFftWJvM0E31SBjmWPznHPjy+8NjdhYfeMmJl3EiNSRgCi/25fpGu4M671zjlrm685s2fEnUoQ5lrLLW8uPLj3oX9hqgxIw8n8X1LU7yMkItCHzREZrGQV6ONmy5TggHk247sL/1jFqof/hRn/AWfqC0pI+QHBIk3tICXRrFTpF8hlJaqefh6yFxQ6HwQYlK8HAKyt3WsWxl7fAAAAAElFTkSuQmCC");bottom:10px;right:15px}div.vis-network div.vis-navigation div.vis-button.vis-zoomOut{background-image:url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAACXBIWXMAAAsTAAALEwEAmpwYAAAKT2lDQ1BQaG90b3Nob3AgSUNDIHByb2ZpbGUAAHjanVNnVFPpFj333vRCS4iAlEtvUhUIIFJCi4AUkSYqIQkQSoghodkVUcERRUUEG8igiAOOjoCMFVEsDIoK2AfkIaKOg6OIisr74Xuja9a89+bN/rXXPues852zzwfACAyWSDNRNYAMqUIeEeCDx8TG4eQuQIEKJHAAEAizZCFz/SMBAPh+PDwrIsAHvgABeNMLCADATZvAMByH/w/qQplcAYCEAcB0kThLCIAUAEB6jkKmAEBGAYCdmCZTAKAEAGDLY2LjAFAtAGAnf+bTAICd+Jl7AQBblCEVAaCRACATZYhEAGg7AKzPVopFAFgwABRmS8Q5ANgtADBJV2ZIALC3AMDOEAuyAAgMADBRiIUpAAR7AGDIIyN4AISZABRG8lc88SuuEOcqAAB4mbI8uSQ5RYFbCC1xB1dXLh4ozkkXKxQ2YQJhmkAuwnmZGTKBNA/g88wAAKCRFRHgg/P9eM4Ors7ONo62Dl8t6r8G/yJiYuP+5c+rcEAAAOF0ftH+LC+zGoA7BoBt/qIl7gRoXgugdfeLZrIPQLUAoOnaV/Nw+H48PEWhkLnZ2eXk5NhKxEJbYcpXff5nwl/AV/1s+X48/Pf14L7iJIEyXYFHBPjgwsz0TKUcz5IJhGLc5o9H/LcL//wd0yLESWK5WCoU41EScY5EmozzMqUiiUKSKcUl0v9k4t8s+wM+3zUAsGo+AXuRLahdYwP2SycQWHTA4vcAAPK7b8HUKAgDgGiD4c93/+8//UegJQCAZkmScQAAXkQkLlTKsz/HCAAARKCBKrBBG/TBGCzABhzBBdzBC/xgNoRCJMTCQhBCCmSAHHJgKayCQiiGzbAdKmAv1EAdNMBRaIaTcA4uwlW4Dj1wD/phCJ7BKLyBCQRByAgTYSHaiAFiilgjjggXmYX4IcFIBBKLJCDJiBRRIkuRNUgxUopUIFVIHfI9cgI5h1xGupE7yAAygvyGvEcxlIGyUT3UDLVDuag3GoRGogvQZHQxmo8WoJvQcrQaPYw2oefQq2gP2o8+Q8cwwOgYBzPEbDAuxsNCsTgsCZNjy7EirAyrxhqwVqwDu4n1Y8+xdwQSgUXACTYEd0IgYR5BSFhMWE7YSKggHCQ0EdoJNwkDhFHCJyKTqEu0JroR+cQYYjIxh1hILCPWEo8TLxB7iEPENyQSiUMyJ7mQAkmxpFTSEtJG0m5SI+ksqZs0SBojk8naZGuyBzmULCAryIXkneTD5DPkG+Qh8lsKnWJAcaT4U+IoUspqShnlEOU05QZlmDJBVaOaUt2ooVQRNY9aQq2htlKvUYeoEzR1mjnNgxZJS6WtopXTGmgXaPdpr+h0uhHdlR5Ol9BX0svpR+iX6AP0dwwNhhWDx4hnKBmbGAcYZxl3GK+YTKYZ04sZx1QwNzHrmOeZD5lvVVgqtip8FZHKCpVKlSaVGyovVKmqpqreqgtV81XLVI+pXlN9rkZVM1PjqQnUlqtVqp1Q61MbU2epO6iHqmeob1Q/pH5Z/YkGWcNMw09DpFGgsV/jvMYgC2MZs3gsIWsNq4Z1gTXEJrHN2Xx2KruY/R27iz2qqaE5QzNKM1ezUvOUZj8H45hx+Jx0TgnnKKeX836K3hTvKeIpG6Y0TLkxZVxrqpaXllirSKtRq0frvTau7aedpr1Fu1n7gQ5Bx0onXCdHZ4/OBZ3nU9lT3acKpxZNPTr1ri6qa6UbobtEd79up+6Ynr5egJ5Mb6feeb3n+hx9L/1U/W36p/VHDFgGswwkBtsMzhg8xTVxbzwdL8fb8VFDXcNAQ6VhlWGX4YSRudE8o9VGjUYPjGnGXOMk423GbcajJgYmISZLTepN7ppSTbmmKaY7TDtMx83MzaLN1pk1mz0x1zLnm+eb15vft2BaeFostqi2uGVJsuRaplnutrxuhVo5WaVYVVpds0atna0l1rutu6cRp7lOk06rntZnw7Dxtsm2qbcZsOXYBtuutm22fWFnYhdnt8Wuw+6TvZN9un2N/T0HDYfZDqsdWh1+c7RyFDpWOt6azpzuP33F9JbpL2dYzxDP2DPjthPLKcRpnVOb00dnF2e5c4PziIuJS4LLLpc+Lpsbxt3IveRKdPVxXeF60vWdm7Obwu2o26/uNu5p7ofcn8w0nymeWTNz0MPIQ+BR5dE/C5+VMGvfrH5PQ0+BZ7XnIy9jL5FXrdewt6V3qvdh7xc+9j5yn+M+4zw33jLeWV/MN8C3yLfLT8Nvnl+F30N/I/9k/3r/0QCngCUBZwOJgUGBWwL7+Hp8Ib+OPzrbZfay2e1BjKC5QRVBj4KtguXBrSFoyOyQrSH355jOkc5pDoVQfujW0Adh5mGLw34MJ4WHhVeGP45wiFga0TGXNXfR3ENz30T6RJZE3ptnMU85ry1KNSo+qi5qPNo3ujS6P8YuZlnM1VidWElsSxw5LiquNm5svt/87fOH4p3iC+N7F5gvyF1weaHOwvSFpxapLhIsOpZATIhOOJTwQRAqqBaMJfITdyWOCnnCHcJnIi/RNtGI2ENcKh5O8kgqTXqS7JG8NXkkxTOlLOW5hCepkLxMDUzdmzqeFpp2IG0yPTq9MYOSkZBxQqohTZO2Z+pn5mZ2y6xlhbL+xW6Lty8elQfJa7OQrAVZLQq2QqboVFoo1yoHsmdlV2a/zYnKOZarnivN7cyzytuQN5zvn//tEsIS4ZK2pYZLVy0dWOa9rGo5sjxxedsK4xUFK4ZWBqw8uIq2Km3VT6vtV5eufr0mek1rgV7ByoLBtQFr6wtVCuWFfevc1+1dT1gvWd+1YfqGnRs+FYmKrhTbF5cVf9go3HjlG4dvyr+Z3JS0qavEuWTPZtJm6ebeLZ5bDpaql+aXDm4N2dq0Dd9WtO319kXbL5fNKNu7g7ZDuaO/PLi8ZafJzs07P1SkVPRU+lQ27tLdtWHX+G7R7ht7vPY07NXbW7z3/T7JvttVAVVN1WbVZftJ+7P3P66Jqun4lvttXa1ObXHtxwPSA/0HIw6217nU1R3SPVRSj9Yr60cOxx++/p3vdy0NNg1VjZzG4iNwRHnk6fcJ3/ceDTradox7rOEH0x92HWcdL2pCmvKaRptTmvtbYlu6T8w+0dbq3nr8R9sfD5w0PFl5SvNUyWna6YLTk2fyz4ydlZ19fi753GDborZ752PO32oPb++6EHTh0kX/i+c7vDvOXPK4dPKy2+UTV7hXmq86X23qdOo8/pPTT8e7nLuarrlca7nuer21e2b36RueN87d9L158Rb/1tWeOT3dvfN6b/fF9/XfFt1+cif9zsu72Xcn7q28T7xf9EDtQdlD3YfVP1v+3Njv3H9qwHeg89HcR/cGhYPP/pH1jw9DBY+Zj8uGDYbrnjg+OTniP3L96fynQ89kzyaeF/6i/suuFxYvfvjV69fO0ZjRoZfyl5O/bXyl/erA6xmv28bCxh6+yXgzMV70VvvtwXfcdx3vo98PT+R8IH8o/2j5sfVT0Kf7kxmTk/8EA5jz/GMzLdsAAAAgY0hSTQAAeiUAAICDAAD5/wAAgOkAAHUwAADqYAAAOpgAABdvkl/FRgAABV5JREFUeNq0l2tQVVUYht/3W/vACMr16IFRQDiAgChpgiikMqY1WjnN9KsfGOXYTOVgkvbDUsZuXrK0qZmGUSvNspjI8TZOmo6AGBoZYly8YB6Qw80DBwQ6jJ3dj30OZZmiwvtv77XW96y91l7v9y1iMNLBuCI84tZkIXU9gwqxAILdokNBOtzgJQWWuYEDFxfcLAGh3y0k79iaD4mfjOVu4WYhoItngBiR6RkuFJAyEJBA3m/lri3Ih/uewXFFyAG4A8oAWkcm2meEzrFNH53Vkhg4xWnxCXcBQGu/3bfGeTbwjKPUcsZRElnfUxcuFLh1Nwh5vurx7s8GDbZ+L+tI/U0hkGGZX5c9/pXqOZYn2gazK8Vth0fvsRUknbx+bIJQQPCts/Mda+4KthbJFoqeKwSejX6pfO2kjytxH1pfuyqlsGH7dJAgZWvFo23L/9muboF+JxtE0/OEwMqJG46uSHinFvepTPO8lhGaX+fPHSdjCKaPy/b3v7az58h/wHFFyIHCRirgjUlbfsiJWXEFD6iUoOkdQaaQ6z9dP2YVahljF4+yXdvZ/evf4G+hQk2sEAUsti4vWxa35gKGSBMDp3T23OxxVXdXRijKovSFzrerC6ELAMT6IhcCZIyeX7c68YPzGGLlxq89PyM0q5YU2M1RuQAg0EERbiaA7Ohl1RgmPTM2p1qjBk1Mm6GDErsfswAgLiDZPmfMwrbhAqeHzm6P8Z9gV9SQdTx2lpCyAEKkhc62YZiVEjTdRgo0zXeBRnImAaSFzm7xdjjtOBGyvmZVZkNvfZjXDhU14+BToFEDKRAQpAJ0HRTjP6XHpYUKEX7RzS9bV5c+FJTmAICUgNSWQ/ZCgJwhIOJIQVLgFKcXvKHm9cyGvithFDUAFQqECho1CBUIggYapAJ1QEFBExNMYoISDU1/NIR9cvndTG/c2IBkp2fC8ZpQgknBGI/3AsDvvRfDlJhwem5zwYMs7VNlaUtbXE1h3mezj9mlGSsXrBkzkFsGKGoDmedBJLfLjxQQgAYdHRSxtPfbfceNsPYBQPTI+GZbT31YxrGIpYoKpIKigkAgFOggNBrbQBBCBaEM2L+iGGmTgnF+Uc1epqO/3VejAoAOUZSLQkFN17lAb4eVCe+VRvvHN4sH6t1feqAmMUGoPHvvhdLzTjzfKoj0sza/GLOy1Bu3vqc20Pgl5YIGkVOEZFZ0nLLMszzdDADTgjIdX6Uf3zfUx6m6u8riKRhOCcmDAqLCURo53Oe4rrsyUlGD0nlIqubdKNZJXOm9FH6y7Yh5uKBnO8vNTX2N4YoKE2fMLREQOsE8AfFN4/ak4QIfbd2XJFRQkLx85ruN7NTp2AoAZxwlCR9dWJc81NDdtoLkc86KBIJwXQ3aOpCPqwuhR2SPbCBlUc2NyogQX3N7wqgU51BAf2w9EFXUtCtLqADqS76ev6/ilgrk2q6esxHZgf5CySh3FMcG+5jbE0ZNdj4odHdDwWPGcZNNO1MPbrxtzdW4s+tI5HPBwQTTzziKY3v/7HGlhmS23g90T+OO5L1Nu7MMw3Fv/Tx1f97/FnsAYPui8/D4nBB/oZZR230uoq67auQoLaB37Iio3sEAK52nR39p+zS13HFiilHeYtOOabdC71jQzz2R+ALBbcrjWNF+cfaUwLSrk4KmtsT4T+gK9jG7AKKjv93X1lcfUNNVaantropqddnDCcIoa7lk29S92+/5CpOvQ04VJ79KUe/7iI/Hh40U6c3PyuPjhmWKN8G8Fvnw1A/zmX/vV5h/T+CXstRMUp4kOFOjZiUlWBkFQYdALitRZXRzf3RqWumdgF79NQDBOa2V/iYSHAAAAABJRU5ErkJggg==");bottom:10px;right:55px}div.vis-network div.vis-navigation div.vis-button.vis-zoomExtends{background-image:url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAACXBIWXMAAAsTAAALEwEAmpwYAAAKT2lDQ1BQaG90b3Nob3AgSUNDIHByb2ZpbGUAAHjanVNnVFPpFj333vRCS4iAlEtvUhUIIFJCi4AUkSYqIQkQSoghodkVUcERRUUEG8igiAOOjoCMFVEsDIoK2AfkIaKOg6OIisr74Xuja9a89+bN/rXXPues852zzwfACAyWSDNRNYAMqUIeEeCDx8TG4eQuQIEKJHAAEAizZCFz/SMBAPh+PDwrIsAHvgABeNMLCADATZvAMByH/w/qQplcAYCEAcB0kThLCIAUAEB6jkKmAEBGAYCdmCZTAKAEAGDLY2LjAFAtAGAnf+bTAICd+Jl7AQBblCEVAaCRACATZYhEAGg7AKzPVopFAFgwABRmS8Q5ANgtADBJV2ZIALC3AMDOEAuyAAgMADBRiIUpAAR7AGDIIyN4AISZABRG8lc88SuuEOcqAAB4mbI8uSQ5RYFbCC1xB1dXLh4ozkkXKxQ2YQJhmkAuwnmZGTKBNA/g88wAAKCRFRHgg/P9eM4Ors7ONo62Dl8t6r8G/yJiYuP+5c+rcEAAAOF0ftH+LC+zGoA7BoBt/qIl7gRoXgugdfeLZrIPQLUAoOnaV/Nw+H48PEWhkLnZ2eXk5NhKxEJbYcpXff5nwl/AV/1s+X48/Pf14L7iJIEyXYFHBPjgwsz0TKUcz5IJhGLc5o9H/LcL//wd0yLESWK5WCoU41EScY5EmozzMqUiiUKSKcUl0v9k4t8s+wM+3zUAsGo+AXuRLahdYwP2SycQWHTA4vcAAPK7b8HUKAgDgGiD4c93/+8//UegJQCAZkmScQAAXkQkLlTKsz/HCAAARKCBKrBBG/TBGCzABhzBBdzBC/xgNoRCJMTCQhBCCmSAHHJgKayCQiiGzbAdKmAv1EAdNMBRaIaTcA4uwlW4Dj1wD/phCJ7BKLyBCQRByAgTYSHaiAFiilgjjggXmYX4IcFIBBKLJCDJiBRRIkuRNUgxUopUIFVIHfI9cgI5h1xGupE7yAAygvyGvEcxlIGyUT3UDLVDuag3GoRGogvQZHQxmo8WoJvQcrQaPYw2oefQq2gP2o8+Q8cwwOgYBzPEbDAuxsNCsTgsCZNjy7EirAyrxhqwVqwDu4n1Y8+xdwQSgUXACTYEd0IgYR5BSFhMWE7YSKggHCQ0EdoJNwkDhFHCJyKTqEu0JroR+cQYYjIxh1hILCPWEo8TLxB7iEPENyQSiUMyJ7mQAkmxpFTSEtJG0m5SI+ksqZs0SBojk8naZGuyBzmULCAryIXkneTD5DPkG+Qh8lsKnWJAcaT4U+IoUspqShnlEOU05QZlmDJBVaOaUt2ooVQRNY9aQq2htlKvUYeoEzR1mjnNgxZJS6WtopXTGmgXaPdpr+h0uhHdlR5Ol9BX0svpR+iX6AP0dwwNhhWDx4hnKBmbGAcYZxl3GK+YTKYZ04sZx1QwNzHrmOeZD5lvVVgqtip8FZHKCpVKlSaVGyovVKmqpqreqgtV81XLVI+pXlN9rkZVM1PjqQnUlqtVqp1Q61MbU2epO6iHqmeob1Q/pH5Z/YkGWcNMw09DpFGgsV/jvMYgC2MZs3gsIWsNq4Z1gTXEJrHN2Xx2KruY/R27iz2qqaE5QzNKM1ezUvOUZj8H45hx+Jx0TgnnKKeX836K3hTvKeIpG6Y0TLkxZVxrqpaXllirSKtRq0frvTau7aedpr1Fu1n7gQ5Bx0onXCdHZ4/OBZ3nU9lT3acKpxZNPTr1ri6qa6UbobtEd79up+6Ynr5egJ5Mb6feeb3n+hx9L/1U/W36p/VHDFgGswwkBtsMzhg8xTVxbzwdL8fb8VFDXcNAQ6VhlWGX4YSRudE8o9VGjUYPjGnGXOMk423GbcajJgYmISZLTepN7ppSTbmmKaY7TDtMx83MzaLN1pk1mz0x1zLnm+eb15vft2BaeFostqi2uGVJsuRaplnutrxuhVo5WaVYVVpds0atna0l1rutu6cRp7lOk06rntZnw7Dxtsm2qbcZsOXYBtuutm22fWFnYhdnt8Wuw+6TvZN9un2N/T0HDYfZDqsdWh1+c7RyFDpWOt6azpzuP33F9JbpL2dYzxDP2DPjthPLKcRpnVOb00dnF2e5c4PziIuJS4LLLpc+Lpsbxt3IveRKdPVxXeF60vWdm7Obwu2o26/uNu5p7ofcn8w0nymeWTNz0MPIQ+BR5dE/C5+VMGvfrH5PQ0+BZ7XnIy9jL5FXrdewt6V3qvdh7xc+9j5yn+M+4zw33jLeWV/MN8C3yLfLT8Nvnl+F30N/I/9k/3r/0QCngCUBZwOJgUGBWwL7+Hp8Ib+OPzrbZfay2e1BjKC5QRVBj4KtguXBrSFoyOyQrSH355jOkc5pDoVQfujW0Adh5mGLw34MJ4WHhVeGP45wiFga0TGXNXfR3ENz30T6RJZE3ptnMU85ry1KNSo+qi5qPNo3ujS6P8YuZlnM1VidWElsSxw5LiquNm5svt/87fOH4p3iC+N7F5gvyF1weaHOwvSFpxapLhIsOpZATIhOOJTwQRAqqBaMJfITdyWOCnnCHcJnIi/RNtGI2ENcKh5O8kgqTXqS7JG8NXkkxTOlLOW5hCepkLxMDUzdmzqeFpp2IG0yPTq9MYOSkZBxQqohTZO2Z+pn5mZ2y6xlhbL+xW6Lty8elQfJa7OQrAVZLQq2QqboVFoo1yoHsmdlV2a/zYnKOZarnivN7cyzytuQN5zvn//tEsIS4ZK2pYZLVy0dWOa9rGo5sjxxedsK4xUFK4ZWBqw8uIq2Km3VT6vtV5eufr0mek1rgV7ByoLBtQFr6wtVCuWFfevc1+1dT1gvWd+1YfqGnRs+FYmKrhTbF5cVf9go3HjlG4dvyr+Z3JS0qavEuWTPZtJm6ebeLZ5bDpaql+aXDm4N2dq0Dd9WtO319kXbL5fNKNu7g7ZDuaO/PLi8ZafJzs07P1SkVPRU+lQ27tLdtWHX+G7R7ht7vPY07NXbW7z3/T7JvttVAVVN1WbVZftJ+7P3P66Jqun4lvttXa1ObXHtxwPSA/0HIw6217nU1R3SPVRSj9Yr60cOxx++/p3vdy0NNg1VjZzG4iNwRHnk6fcJ3/ceDTradox7rOEH0x92HWcdL2pCmvKaRptTmvtbYlu6T8w+0dbq3nr8R9sfD5w0PFl5SvNUyWna6YLTk2fyz4ydlZ19fi753GDborZ752PO32oPb++6EHTh0kX/i+c7vDvOXPK4dPKy2+UTV7hXmq86X23qdOo8/pPTT8e7nLuarrlca7nuer21e2b36RueN87d9L158Rb/1tWeOT3dvfN6b/fF9/XfFt1+cif9zsu72Xcn7q28T7xf9EDtQdlD3YfVP1v+3Njv3H9qwHeg89HcR/cGhYPP/pH1jw9DBY+Zj8uGDYbrnjg+OTniP3L96fynQ89kzyaeF/6i/suuFxYvfvjV69fO0ZjRoZfyl5O/bXyl/erA6xmv28bCxh6+yXgzMV70VvvtwXfcdx3vo98PT+R8IH8o/2j5sfVT0Kf7kxmTk/8EA5jz/GMzLdsAAAAgY0hSTQAAeiUAAICDAAD5/wAAgOkAAHUwAADqYAAAOpgAABdvkl/FRgAABptJREFUeNqsl21QlNcVx///cx9hIipuAJHasgHlRdw0xay7yK7smg6sb2DSdtqZduLUNENmOk1tQuM4U7UzTvshSRlFZzoNCWSSSTJp+6VNkLCAeQHBoCCgqNBE0wUqL+KuwIiiZZ9+eHa3aAS3Sf8zO8/L3nt+95x7z7n3YWlpKUQEJAEgch9+Jola9xEC2ADBVgAOKqwCYAqKDgUJBIHPBWwFWQNdbyZFBwAC0GGIAHQSj3/8HHRdhzYbdDfwg4IjAsGvICgXAroYBiCEDkBBACBZoyST4gDwQqh7mQ4cEkhQD0EBIIggRMQAh2EiEvEYAGrdR3YSqIYCIEDaotVDeYnu/ryEjSOr43PHl8WmTBPA6PRQ7IWJrvhT/ubkU/7m1EvX+1KEUh7Ug+WkPEXgdUSkR+xrd0NJ4qjr8AEI9pGAI7mo78mHfnF+Y/K2K7iHUheuvJG6cOUNz/LvDwPobrpSl/Ruf2VOy9UPs4RSTSANwH4Y449EVdnt9ojHIeghCHYLgR+n/7zt4Np32tIWZU4hSpnjVk1t/caPfOO3/f++MNH5TVJcisoEoo4ksgbsXwYfdR1+kQplQuCFNS82Pp/9+158RTkTC0ce0OKutQeOp5PME0qcUBqyBmwGOC8vz4AWVOyE4CUqYO/Dh+p3pj//Bb6mHllqCyxd8ODVT69+uFKoOYTSnzFg7SJpzHFNQYWiQrUIsCN9V+uOh375zz179pSGI1FSUuK12+2+aGDt7e3muro6T/h57969lZdvDrT+ZbA6n0B1nfPVN7e0PjMjIgIIdkEAR1JR329yDvaE0+l/hQKA1Wr1bd682SsikUW7K+O3PesTNvaSAiXaLhGBvO86RFEoJ4Adac+eDxsgiZKSEm9NTY3n5MmT5mjBHR0d5vr6es+mTZu8SqnI+x+s+Ol5jRo0auX1jtepQaEAADKWWIbcy7ZGUmb79u1eu93uI+mtra31HLj5TGDs9rBJICCNn1GRCKGCUJAUuzzw6CfbTB6Px7t27VofAG/YXl6Ceyw9LmvIN3UxZUafKRACWyCELcHVP3vk4fDabDZf+2N/D9g+fsLEEFSooFGDogZNFkBRgSCsTcWm066jgRAU4et/F5u9nxRosmCLRmE+QdgSXCNzhW/s9rDJ63wVJx77V+V8YS6UNaW8BdOcqzx+3Ujt0F8Bcr1GMIMU5CzJHZ+rg6IGCYV2PimoyIK6lzIWrxkPTVGmRoqJFCyLTZmeq4MB5f3BVADnbpcQkzStUQMAk0YKBPfzxlhA95NQQe43QBotBECAFFyZHo6dz6CKCizAPFPivzUWqxm2AqIgnwkFvZNn4uczGK3Hah7wpet98UZ85R8aKScIcXYEWpMLkx8fvleHpNjlAWtTsakQa0pVKGcJQqMGUqCHBvfdjp/gTP6xwFzg85PdyaH2J4SUowKiw3889e4KBACnT582W5uKTV2uusAdUFlgzBcFQoFGDT35HwW+82mhqaenxwwA4WtYfRNnUkMZUqsJpEkn8cXU5yktYw2JjsTCMQDwer0ekt6GhgZPUVGRd3fu7qjqdU9Mj7mlpcVD0tvS0uKxWCyVANB5rS3x8s3BFEUFgTTLtuZndQHLBMSfB6pyZtfqMDQ3NzfqTcJisficTqc3BI+8bxh9L8corarM3fnDoIT+rACAU/7m7MOfHbCEwQDQ2Njo6erqinqTOHfuXNjjiI23+ystZ8c7smmkWgVJcN++fRARfLDhlacEUqVEQ1nm77xPrHjSh/+Djo3WmN/s/6OHEOgIPr2h63tVuq5Dud1ukETWoK3zorkzTiiONn/TKlNM4lj24m+Pf13o2wOVHqGA5MsAXjKPrDaqnMvlQnjTzhy0Nlw0d5oI5p3yN62amrk+ve5B5+hXgb47WGX52+V3NgoFOvQKAGUkkTqcbZy5XC7XHYf4zEFr3aXU7jih5uidPPOtvsmzixZr8VMrHjBHddLsHj+Z9Fb/n9a1+T/JDaXey0IpEzEKkHnU8Jj79++PeEwSSimQRGP+Gz8j5DVFBVKQtjBj6JGlNt/D8Y+OpMdlTphiEqcB4tqtsVjfjUtLLkx0J/dOnjWPTg+lEARIEHwaQJVQIYggACC/qxi6rn8ZHL4XETSsf0MU1HOk/CFGYgAwskUqY5eBitRxzn7/a0V1EEBwdqkN6jPI7y4xPmHmC5unbWdQRMqP2d86qANOksU6gvmArNQRNClqABnQgYuK0krI+wCOAyH3DK/vqOXhaf3PAO7mIRjDNV25AAAAAElFTkSuQmCC");bottom:50px;right:15px}div.vis-network div.vis-manipulation{background:#fff;background:-moz-linear-gradient(top,#fff 0,#fcfcfc 48%,#fafafa 50%,#fcfcfc 100%);background:-webkit-gradient(linear,left top,left bottom,color-stop(0,#fff),color-stop(48%,#fcfcfc),color-stop(50%,#fafafa),color-stop(100%,#fcfcfc));background:-webkit-linear-gradient(top,#fff,#fcfcfc 48%,#fafafa 50%,#fcfcfc);background:-o-linear-gradient(top,#fff 0,#fcfcfc 48%,#fafafa 50%,#fcfcfc 100%);background:-ms-linear-gradient(top,#fff 0,#fcfcfc 48%,#fafafa 50%,#fcfcfc 100%);background:linear-gradient(180deg,#fff 0,#fcfcfc 48%,#fafafa 50%,#fcfcfc);border:0 solid #d6d9d8;border-bottom:1px;box-sizing:content-box;filter:progid:DXImageTransform.Microsoft.gradient(startColorstr="#ffffff",endColorstr="#fcfcfc",GradientType=0);height:28px;left:0;padding-top:4px;position:absolute;top:0;width:100%}div.vis-network button.vis-edit-mode,div.vis-network div.vis-edit-mode{height:30px;left:0;position:absolute;top:5px}div.vis-network button.vis-close{-webkit-touch-callout:none;background-color:transparent;background-image:url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAcAAAAHCAYAAADEUlfTAAAACXBIWXMAAAsTAAALEwEAmpwYAAAKT2lDQ1BQaG90b3Nob3AgSUNDIHByb2ZpbGUAAHjanVNnVFPpFj333vRCS4iAlEtvUhUIIFJCi4AUkSYqIQkQSoghodkVUcERRUUEG8igiAOOjoCMFVEsDIoK2AfkIaKOg6OIisr74Xuja9a89+bN/rXXPues852zzwfACAyWSDNRNYAMqUIeEeCDx8TG4eQuQIEKJHAAEAizZCFz/SMBAPh+PDwrIsAHvgABeNMLCADATZvAMByH/w/qQplcAYCEAcB0kThLCIAUAEB6jkKmAEBGAYCdmCZTAKAEAGDLY2LjAFAtAGAnf+bTAICd+Jl7AQBblCEVAaCRACATZYhEAGg7AKzPVopFAFgwABRmS8Q5ANgtADBJV2ZIALC3AMDOEAuyAAgMADBRiIUpAAR7AGDIIyN4AISZABRG8lc88SuuEOcqAAB4mbI8uSQ5RYFbCC1xB1dXLh4ozkkXKxQ2YQJhmkAuwnmZGTKBNA/g88wAAKCRFRHgg/P9eM4Ors7ONo62Dl8t6r8G/yJiYuP+5c+rcEAAAOF0ftH+LC+zGoA7BoBt/qIl7gRoXgugdfeLZrIPQLUAoOnaV/Nw+H48PEWhkLnZ2eXk5NhKxEJbYcpXff5nwl/AV/1s+X48/Pf14L7iJIEyXYFHBPjgwsz0TKUcz5IJhGLc5o9H/LcL//wd0yLESWK5WCoU41EScY5EmozzMqUiiUKSKcUl0v9k4t8s+wM+3zUAsGo+AXuRLahdYwP2SycQWHTA4vcAAPK7b8HUKAgDgGiD4c93/+8//UegJQCAZkmScQAAXkQkLlTKsz/HCAAARKCBKrBBG/TBGCzABhzBBdzBC/xgNoRCJMTCQhBCCmSAHHJgKayCQiiGzbAdKmAv1EAdNMBRaIaTcA4uwlW4Dj1wD/phCJ7BKLyBCQRByAgTYSHaiAFiilgjjggXmYX4IcFIBBKLJCDJiBRRIkuRNUgxUopUIFVIHfI9cgI5h1xGupE7yAAygvyGvEcxlIGyUT3UDLVDuag3GoRGogvQZHQxmo8WoJvQcrQaPYw2oefQq2gP2o8+Q8cwwOgYBzPEbDAuxsNCsTgsCZNjy7EirAyrxhqwVqwDu4n1Y8+xdwQSgUXACTYEd0IgYR5BSFhMWE7YSKggHCQ0EdoJNwkDhFHCJyKTqEu0JroR+cQYYjIxh1hILCPWEo8TLxB7iEPENyQSiUMyJ7mQAkmxpFTSEtJG0m5SI+ksqZs0SBojk8naZGuyBzmULCAryIXkneTD5DPkG+Qh8lsKnWJAcaT4U+IoUspqShnlEOU05QZlmDJBVaOaUt2ooVQRNY9aQq2htlKvUYeoEzR1mjnNgxZJS6WtopXTGmgXaPdpr+h0uhHdlR5Ol9BX0svpR+iX6AP0dwwNhhWDx4hnKBmbGAcYZxl3GK+YTKYZ04sZx1QwNzHrmOeZD5lvVVgqtip8FZHKCpVKlSaVGyovVKmqpqreqgtV81XLVI+pXlN9rkZVM1PjqQnUlqtVqp1Q61MbU2epO6iHqmeob1Q/pH5Z/YkGWcNMw09DpFGgsV/jvMYgC2MZs3gsIWsNq4Z1gTXEJrHN2Xx2KruY/R27iz2qqaE5QzNKM1ezUvOUZj8H45hx+Jx0TgnnKKeX836K3hTvKeIpG6Y0TLkxZVxrqpaXllirSKtRq0frvTau7aedpr1Fu1n7gQ5Bx0onXCdHZ4/OBZ3nU9lT3acKpxZNPTr1ri6qa6UbobtEd79up+6Ynr5egJ5Mb6feeb3n+hx9L/1U/W36p/VHDFgGswwkBtsMzhg8xTVxbzwdL8fb8VFDXcNAQ6VhlWGX4YSRudE8o9VGjUYPjGnGXOMk423GbcajJgYmISZLTepN7ppSTbmmKaY7TDtMx83MzaLN1pk1mz0x1zLnm+eb15vft2BaeFostqi2uGVJsuRaplnutrxuhVo5WaVYVVpds0atna0l1rutu6cRp7lOk06rntZnw7Dxtsm2qbcZsOXYBtuutm22fWFnYhdnt8Wuw+6TvZN9un2N/T0HDYfZDqsdWh1+c7RyFDpWOt6azpzuP33F9JbpL2dYzxDP2DPjthPLKcRpnVOb00dnF2e5c4PziIuJS4LLLpc+Lpsbxt3IveRKdPVxXeF60vWdm7Obwu2o26/uNu5p7ofcn8w0nymeWTNz0MPIQ+BR5dE/C5+VMGvfrH5PQ0+BZ7XnIy9jL5FXrdewt6V3qvdh7xc+9j5yn+M+4zw33jLeWV/MN8C3yLfLT8Nvnl+F30N/I/9k/3r/0QCngCUBZwOJgUGBWwL7+Hp8Ib+OPzrbZfay2e1BjKC5QRVBj4KtguXBrSFoyOyQrSH355jOkc5pDoVQfujW0Adh5mGLw34MJ4WHhVeGP45wiFga0TGXNXfR3ENz30T6RJZE3ptnMU85ry1KNSo+qi5qPNo3ujS6P8YuZlnM1VidWElsSxw5LiquNm5svt/87fOH4p3iC+N7F5gvyF1weaHOwvSFpxapLhIsOpZATIhOOJTwQRAqqBaMJfITdyWOCnnCHcJnIi/RNtGI2ENcKh5O8kgqTXqS7JG8NXkkxTOlLOW5hCepkLxMDUzdmzqeFpp2IG0yPTq9MYOSkZBxQqohTZO2Z+pn5mZ2y6xlhbL+xW6Lty8elQfJa7OQrAVZLQq2QqboVFoo1yoHsmdlV2a/zYnKOZarnivN7cyzytuQN5zvn//tEsIS4ZK2pYZLVy0dWOa9rGo5sjxxedsK4xUFK4ZWBqw8uIq2Km3VT6vtV5eufr0mek1rgV7ByoLBtQFr6wtVCuWFfevc1+1dT1gvWd+1YfqGnRs+FYmKrhTbF5cVf9go3HjlG4dvyr+Z3JS0qavEuWTPZtJm6ebeLZ5bDpaql+aXDm4N2dq0Dd9WtO319kXbL5fNKNu7g7ZDuaO/PLi8ZafJzs07P1SkVPRU+lQ27tLdtWHX+G7R7ht7vPY07NXbW7z3/T7JvttVAVVN1WbVZftJ+7P3P66Jqun4lvttXa1ObXHtxwPSA/0HIw6217nU1R3SPVRSj9Yr60cOxx++/p3vdy0NNg1VjZzG4iNwRHnk6fcJ3/ceDTradox7rOEH0x92HWcdL2pCmvKaRptTmvtbYlu6T8w+0dbq3nr8R9sfD5w0PFl5SvNUyWna6YLTk2fyz4ydlZ19fi753GDborZ752PO32oPb++6EHTh0kX/i+c7vDvOXPK4dPKy2+UTV7hXmq86X23qdOo8/pPTT8e7nLuarrlca7nuer21e2b36RueN87d9L158Rb/1tWeOT3dvfN6b/fF9/XfFt1+cif9zsu72Xcn7q28T7xf9EDtQdlD3YfVP1v+3Njv3H9qwHeg89HcR/cGhYPP/pH1jw9DBY+Zj8uGDYbrnjg+OTniP3L96fynQ89kzyaeF/6i/suuFxYvfvjV69fO0ZjRoZfyl5O/bXyl/erA6xmv28bCxh6+yXgzMV70VvvtwXfcdx3vo98PT+R8IH8o/2j5sfVT0Kf7kxmTk/8EA5jz/GMzLdsAADvGaVRYdFhNTDpjb20uYWRvYmUueG1wAAAAAAA8P3hwYWNrZXQgYmVnaW49Iu+7vyIgaWQ9Ilc1TTBNcENlaGlIenJlU3pOVGN6a2M5ZCI/Pgo8eDp4bXBtZXRhIHhtbG5zOng9ImFkb2JlOm5zOm1ldGEvIiB4OnhtcHRrPSJBZG9iZSBYTVAgQ29yZSA1LjUtYzAyMSA3OS4xNTQ5MTEsIDIwMTMvMTAvMjktMTE6NDc6MTYgICAgICAgICI+CiAgIDxyZGY6UkRGIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyI+CiAgICAgIDxyZGY6RGVzY3JpcHRpb24gcmRmOmFib3V0PSIiCiAgICAgICAgICAgIHhtbG5zOnhtcD0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLyIKICAgICAgICAgICAgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iCiAgICAgICAgICAgIHhtbG5zOnN0RXZ0PSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VFdmVudCMiCiAgICAgICAgICAgIHhtbG5zOmRjPSJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xLyIKICAgICAgICAgICAgeG1sbnM6cGhvdG9zaG9wPSJodHRwOi8vbnMuYWRvYmUuY29tL3Bob3Rvc2hvcC8xLjAvIgogICAgICAgICAgICB4bWxuczp0aWZmPSJodHRwOi8vbnMuYWRvYmUuY29tL3RpZmYvMS4wLyIKICAgICAgICAgICAgeG1sbnM6ZXhpZj0iaHR0cDovL25zLmFkb2JlLmNvbS9leGlmLzEuMC8iPgogICAgICAgICA8eG1wOkNyZWF0b3JUb29sPkFkb2JlIFBob3Rvc2hvcCBDQyAoV2luZG93cyk8L3htcDpDcmVhdG9yVG9vbD4KICAgICAgICAgPHhtcDpDcmVhdGVEYXRlPjIwMTQtMDItMTRUMTE6NTU6MzUrMDE6MDA8L3htcDpDcmVhdGVEYXRlPgogICAgICAgICA8eG1wOk1ldGFkYXRhRGF0ZT4yMDE0LTAyLTE0VDEyOjA1OjE3KzAxOjAwPC94bXA6TWV0YWRhdGFEYXRlPgogICAgICAgICA8eG1wOk1vZGlmeURhdGU+MjAxNC0wMi0xNFQxMjowNToxNyswMTowMDwveG1wOk1vZGlmeURhdGU+CiAgICAgICAgIDx4bXBNTTpJbnN0YW5jZUlEPnhtcC5paWQ6NjU0YmM5YmQtMWI2Yi1jYjRhLTllOWQtNWY2MzgxNDVjZjk0PC94bXBNTTpJbnN0YW5jZUlEPgogICAgICAgICA8eG1wTU06RG9jdW1lbnRJRD54bXAuZGlkOjk4MmM2MGIwLWUzZjMtMDk0MC04MjU0LTFiZTliNWE0ZTE4MzwveG1wTU06RG9jdW1lbnRJRD4KICAgICAgICAgPHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD54bXAuZGlkOjk4MmM2MGIwLWUzZjMtMDk0MC04MjU0LTFiZTliNWE0ZTE4MzwveG1wTU06T3JpZ2luYWxEb2N1bWVudElEPgogICAgICAgICA8eG1wTU06SGlzdG9yeT4KICAgICAgICAgICAgPHJkZjpTZXE+CiAgICAgICAgICAgICAgIDxyZGY6bGkgcmRmOnBhcnNlVHlwZT0iUmVzb3VyY2UiPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6YWN0aW9uPmNyZWF0ZWQ8L3N0RXZ0OmFjdGlvbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0Omluc3RhbmNlSUQ+eG1wLmlpZDo5ODJjNjBiMC1lM2YzLTA5NDAtODI1NC0xYmU5YjVhNGUxODM8L3N0RXZ0Omluc3RhbmNlSUQ+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDp3aGVuPjIwMTQtMDItMTRUMTE6NTU6MzUrMDE6MDA8L3N0RXZ0OndoZW4+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDpzb2Z0d2FyZUFnZW50PkFkb2JlIFBob3Rvc2hvcCBDQyAoV2luZG93cyk8L3N0RXZ0OnNvZnR3YXJlQWdlbnQ+CiAgICAgICAgICAgICAgIDwvcmRmOmxpPgogICAgICAgICAgICAgICA8cmRmOmxpIHJkZjpwYXJzZVR5cGU9IlJlc291cmNlIj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OmFjdGlvbj5zYXZlZDwvc3RFdnQ6YWN0aW9uPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6aW5zdGFuY2VJRD54bXAuaWlkOjIxODYxNmM2LTM1MWMtNDI0OS04YWFkLWJkZDQ2ZTczNWE0NDwvc3RFdnQ6aW5zdGFuY2VJRD4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OndoZW4+MjAxNC0wMi0xNFQxMTo1NTozNSswMTowMDwvc3RFdnQ6d2hlbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OnNvZnR3YXJlQWdlbnQ+QWRvYmUgUGhvdG9zaG9wIENDIChXaW5kb3dzKTwvc3RFdnQ6c29mdHdhcmVBZ2VudD4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OmNoYW5nZWQ+Lzwvc3RFdnQ6Y2hhbmdlZD4KICAgICAgICAgICAgICAgPC9yZGY6bGk+CiAgICAgICAgICAgICAgIDxyZGY6bGkgcmRmOnBhcnNlVHlwZT0iUmVzb3VyY2UiPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6YWN0aW9uPnNhdmVkPC9zdEV2dDphY3Rpb24+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDppbnN0YW5jZUlEPnhtcC5paWQ6NjU0YmM5YmQtMWI2Yi1jYjRhLTllOWQtNWY2MzgxNDVjZjk0PC9zdEV2dDppbnN0YW5jZUlEPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6d2hlbj4yMDE0LTAyLTE0VDEyOjA1OjE3KzAxOjAwPC9zdEV2dDp3aGVuPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6c29mdHdhcmVBZ2VudD5BZG9iZSBQaG90b3Nob3AgQ0MgKFdpbmRvd3MpPC9zdEV2dDpzb2Z0d2FyZUFnZW50PgogICAgICAgICAgICAgICAgICA8c3RFdnQ6Y2hhbmdlZD4vPC9zdEV2dDpjaGFuZ2VkPgogICAgICAgICAgICAgICA8L3JkZjpsaT4KICAgICAgICAgICAgPC9yZGY6U2VxPgogICAgICAgICA8L3htcE1NOkhpc3Rvcnk+CiAgICAgICAgIDxkYzpmb3JtYXQ+aW1hZ2UvcG5nPC9kYzpmb3JtYXQ+CiAgICAgICAgIDxwaG90b3Nob3A6Q29sb3JNb2RlPjM8L3Bob3Rvc2hvcDpDb2xvck1vZGU+CiAgICAgICAgIDxwaG90b3Nob3A6SUNDUHJvZmlsZT5zUkdCIElFQzYxOTY2LTIuMTwvcGhvdG9zaG9wOklDQ1Byb2ZpbGU+CiAgICAgICAgIDx0aWZmOk9yaWVudGF0aW9uPjE8L3RpZmY6T3JpZW50YXRpb24+CiAgICAgICAgIDx0aWZmOlhSZXNvbHV0aW9uPjcyMDAwMC8xMDAwMDwvdGlmZjpYUmVzb2x1dGlvbj4KICAgICAgICAgPHRpZmY6WVJlc29sdXRpb24+NzIwMDAwLzEwMDAwPC90aWZmOllSZXNvbHV0aW9uPgogICAgICAgICA8dGlmZjpSZXNvbHV0aW9uVW5pdD4yPC90aWZmOlJlc29sdXRpb25Vbml0PgogICAgICAgICA8ZXhpZjpDb2xvclNwYWNlPjE8L2V4aWY6Q29sb3JTcGFjZT4KICAgICAgICAgPGV4aWY6UGl4ZWxYRGltZW5zaW9uPjc8L2V4aWY6UGl4ZWxYRGltZW5zaW9uPgogICAgICAgICA8ZXhpZjpQaXhlbFlEaW1lbnNpb24+NzwvZXhpZjpQaXhlbFlEaW1lbnNpb24+CiAgICAgIDwvcmRmOkRlc2NyaXB0aW9uPgogICA8L3JkZjpSREY+CjwveDp4bXBtZXRhPgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgIAo8P3hwYWNrZXQgZW5kPSJ3Ij8+cZUZMwAAACBjSFJNAAB6JQAAgIMAAPn/AACA6QAAdTAAAOpgAAA6mAAAF2+SX8VGAAAA2ElEQVR42gDLADT/AS0tLUQFBQUVFxcXtPHx8fPl5eUNCAgITCkpKesEHx8fGgYGBjH+/v4a+Pj4qgQEBFU6OjodMTExzwQUFBSvEBAQEfX19SD19fVqNDQ0CElJSd/9/f2vAwEBAfrn5+fkBwcHLRYWFgsXFxfz29vbo9LS0uwDDQ0NDfPz81orKysXIyMj+ODg4Avh4eEa/f391gMkJCRYPz8/KUhISOMCAgKh8fHxHRsbGx4UFBQQBDk5OeY7Ozv7CAgItPb29vMEBASaJSUlTQ0NDesDAEwpT0Ko8Ri2AAAAAElFTkSuQmCC");background-position:20px 3px;background-repeat:no-repeat;border:none;cursor:pointer;height:30px;position:absolute;right:0;top:0;-webkit-user-select:none;-khtml-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;width:30px}div.vis-network button.vis-close:hover{opacity:.6}div.vis-network div.vis-edit-mode button.vis-button,div.vis-network div.vis-manipulation button.vis-button{-webkit-touch-callout:none;background-color:transparent;background-position:0 0;background-repeat:no-repeat;border:none;-moz-border-radius:15px;border-radius:15px;box-sizing:content-box;cursor:pointer;float:left;font-family:verdana;font-size:12px;height:24px;margin-left:10px;padding:0 8px;-webkit-user-select:none;-khtml-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}div.vis-network div.vis-manipulation button.vis-button:hover{box-shadow:1px 1px 8px rgba(0,0,0,.2)}div.vis-network div.vis-manipulation button.vis-button:active{box-shadow:1px 1px 8px rgba(0,0,0,.5)}div.vis-network div.vis-manipulation button.vis-button.vis-back{background-image:url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAACXBIWXMAAAsTAAALEwEAmpwYAAAKT2lDQ1BQaG90b3Nob3AgSUNDIHByb2ZpbGUAAHjanVNnVFPpFj333vRCS4iAlEtvUhUIIFJCi4AUkSYqIQkQSoghodkVUcERRUUEG8igiAOOjoCMFVEsDIoK2AfkIaKOg6OIisr74Xuja9a89+bN/rXXPues852zzwfACAyWSDNRNYAMqUIeEeCDx8TG4eQuQIEKJHAAEAizZCFz/SMBAPh+PDwrIsAHvgABeNMLCADATZvAMByH/w/qQplcAYCEAcB0kThLCIAUAEB6jkKmAEBGAYCdmCZTAKAEAGDLY2LjAFAtAGAnf+bTAICd+Jl7AQBblCEVAaCRACATZYhEAGg7AKzPVopFAFgwABRmS8Q5ANgtADBJV2ZIALC3AMDOEAuyAAgMADBRiIUpAAR7AGDIIyN4AISZABRG8lc88SuuEOcqAAB4mbI8uSQ5RYFbCC1xB1dXLh4ozkkXKxQ2YQJhmkAuwnmZGTKBNA/g88wAAKCRFRHgg/P9eM4Ors7ONo62Dl8t6r8G/yJiYuP+5c+rcEAAAOF0ftH+LC+zGoA7BoBt/qIl7gRoXgugdfeLZrIPQLUAoOnaV/Nw+H48PEWhkLnZ2eXk5NhKxEJbYcpXff5nwl/AV/1s+X48/Pf14L7iJIEyXYFHBPjgwsz0TKUcz5IJhGLc5o9H/LcL//wd0yLESWK5WCoU41EScY5EmozzMqUiiUKSKcUl0v9k4t8s+wM+3zUAsGo+AXuRLahdYwP2SycQWHTA4vcAAPK7b8HUKAgDgGiD4c93/+8//UegJQCAZkmScQAAXkQkLlTKsz/HCAAARKCBKrBBG/TBGCzABhzBBdzBC/xgNoRCJMTCQhBCCmSAHHJgKayCQiiGzbAdKmAv1EAdNMBRaIaTcA4uwlW4Dj1wD/phCJ7BKLyBCQRByAgTYSHaiAFiilgjjggXmYX4IcFIBBKLJCDJiBRRIkuRNUgxUopUIFVIHfI9cgI5h1xGupE7yAAygvyGvEcxlIGyUT3UDLVDuag3GoRGogvQZHQxmo8WoJvQcrQaPYw2oefQq2gP2o8+Q8cwwOgYBzPEbDAuxsNCsTgsCZNjy7EirAyrxhqwVqwDu4n1Y8+xdwQSgUXACTYEd0IgYR5BSFhMWE7YSKggHCQ0EdoJNwkDhFHCJyKTqEu0JroR+cQYYjIxh1hILCPWEo8TLxB7iEPENyQSiUMyJ7mQAkmxpFTSEtJG0m5SI+ksqZs0SBojk8naZGuyBzmULCAryIXkneTD5DPkG+Qh8lsKnWJAcaT4U+IoUspqShnlEOU05QZlmDJBVaOaUt2ooVQRNY9aQq2htlKvUYeoEzR1mjnNgxZJS6WtopXTGmgXaPdpr+h0uhHdlR5Ol9BX0svpR+iX6AP0dwwNhhWDx4hnKBmbGAcYZxl3GK+YTKYZ04sZx1QwNzHrmOeZD5lvVVgqtip8FZHKCpVKlSaVGyovVKmqpqreqgtV81XLVI+pXlN9rkZVM1PjqQnUlqtVqp1Q61MbU2epO6iHqmeob1Q/pH5Z/YkGWcNMw09DpFGgsV/jvMYgC2MZs3gsIWsNq4Z1gTXEJrHN2Xx2KruY/R27iz2qqaE5QzNKM1ezUvOUZj8H45hx+Jx0TgnnKKeX836K3hTvKeIpG6Y0TLkxZVxrqpaXllirSKtRq0frvTau7aedpr1Fu1n7gQ5Bx0onXCdHZ4/OBZ3nU9lT3acKpxZNPTr1ri6qa6UbobtEd79up+6Ynr5egJ5Mb6feeb3n+hx9L/1U/W36p/VHDFgGswwkBtsMzhg8xTVxbzwdL8fb8VFDXcNAQ6VhlWGX4YSRudE8o9VGjUYPjGnGXOMk423GbcajJgYmISZLTepN7ppSTbmmKaY7TDtMx83MzaLN1pk1mz0x1zLnm+eb15vft2BaeFostqi2uGVJsuRaplnutrxuhVo5WaVYVVpds0atna0l1rutu6cRp7lOk06rntZnw7Dxtsm2qbcZsOXYBtuutm22fWFnYhdnt8Wuw+6TvZN9un2N/T0HDYfZDqsdWh1+c7RyFDpWOt6azpzuP33F9JbpL2dYzxDP2DPjthPLKcRpnVOb00dnF2e5c4PziIuJS4LLLpc+Lpsbxt3IveRKdPVxXeF60vWdm7Obwu2o26/uNu5p7ofcn8w0nymeWTNz0MPIQ+BR5dE/C5+VMGvfrH5PQ0+BZ7XnIy9jL5FXrdewt6V3qvdh7xc+9j5yn+M+4zw33jLeWV/MN8C3yLfLT8Nvnl+F30N/I/9k/3r/0QCngCUBZwOJgUGBWwL7+Hp8Ib+OPzrbZfay2e1BjKC5QRVBj4KtguXBrSFoyOyQrSH355jOkc5pDoVQfujW0Adh5mGLw34MJ4WHhVeGP45wiFga0TGXNXfR3ENz30T6RJZE3ptnMU85ry1KNSo+qi5qPNo3ujS6P8YuZlnM1VidWElsSxw5LiquNm5svt/87fOH4p3iC+N7F5gvyF1weaHOwvSFpxapLhIsOpZATIhOOJTwQRAqqBaMJfITdyWOCnnCHcJnIi/RNtGI2ENcKh5O8kgqTXqS7JG8NXkkxTOlLOW5hCepkLxMDUzdmzqeFpp2IG0yPTq9MYOSkZBxQqohTZO2Z+pn5mZ2y6xlhbL+xW6Lty8elQfJa7OQrAVZLQq2QqboVFoo1yoHsmdlV2a/zYnKOZarnivN7cyzytuQN5zvn//tEsIS4ZK2pYZLVy0dWOa9rGo5sjxxedsK4xUFK4ZWBqw8uIq2Km3VT6vtV5eufr0mek1rgV7ByoLBtQFr6wtVCuWFfevc1+1dT1gvWd+1YfqGnRs+FYmKrhTbF5cVf9go3HjlG4dvyr+Z3JS0qavEuWTPZtJm6ebeLZ5bDpaql+aXDm4N2dq0Dd9WtO319kXbL5fNKNu7g7ZDuaO/PLi8ZafJzs07P1SkVPRU+lQ27tLdtWHX+G7R7ht7vPY07NXbW7z3/T7JvttVAVVN1WbVZftJ+7P3P66Jqun4lvttXa1ObXHtxwPSA/0HIw6217nU1R3SPVRSj9Yr60cOxx++/p3vdy0NNg1VjZzG4iNwRHnk6fcJ3/ceDTradox7rOEH0x92HWcdL2pCmvKaRptTmvtbYlu6T8w+0dbq3nr8R9sfD5w0PFl5SvNUyWna6YLTk2fyz4ydlZ19fi753GDborZ752PO32oPb++6EHTh0kX/i+c7vDvOXPK4dPKy2+UTV7hXmq86X23qdOo8/pPTT8e7nLuarrlca7nuer21e2b36RueN87d9L158Rb/1tWeOT3dvfN6b/fF9/XfFt1+cif9zsu72Xcn7q28T7xf9EDtQdlD3YfVP1v+3Njv3H9qwHeg89HcR/cGhYPP/pH1jw9DBY+Zj8uGDYbrnjg+OTniP3L96fynQ89kzyaeF/6i/suuFxYvfvjV69fO0ZjRoZfyl5O/bXyl/erA6xmv28bCxh6+yXgzMV70VvvtwXfcdx3vo98PT+R8IH8o/2j5sfVT0Kf7kxmTk/8EA5jz/GMzLdsAAEEOaVRYdFhNTDpjb20uYWRvYmUueG1wAAAAAAA8P3hwYWNrZXQgYmVnaW49Iu+7vyIgaWQ9Ilc1TTBNcENlaGlIenJlU3pOVGN6a2M5ZCI/Pgo8eDp4bXBtZXRhIHhtbG5zOng9ImFkb2JlOm5zOm1ldGEvIiB4OnhtcHRrPSJBZG9iZSBYTVAgQ29yZSA1LjUtYzAyMSA3OS4xNTQ5MTEsIDIwMTMvMTAvMjktMTE6NDc6MTYgICAgICAgICI+CiAgIDxyZGY6UkRGIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyI+CiAgICAgIDxyZGY6RGVzY3JpcHRpb24gcmRmOmFib3V0PSIiCiAgICAgICAgICAgIHhtbG5zOnhtcD0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLyIKICAgICAgICAgICAgeG1sbnM6ZGM9Imh0dHA6Ly9wdXJsLm9yZy9kYy9lbGVtZW50cy8xLjEvIgogICAgICAgICAgICB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIKICAgICAgICAgICAgeG1sbnM6c3RFdnQ9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZUV2ZW50IyIKICAgICAgICAgICAgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiCiAgICAgICAgICAgIHhtbG5zOnBob3Rvc2hvcD0iaHR0cDovL25zLmFkb2JlLmNvbS9waG90b3Nob3AvMS4wLyIKICAgICAgICAgICAgeG1sbnM6dGlmZj0iaHR0cDovL25zLmFkb2JlLmNvbS90aWZmLzEuMC8iCiAgICAgICAgICAgIHhtbG5zOmV4aWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20vZXhpZi8xLjAvIj4KICAgICAgICAgPHhtcDpDcmVhdG9yVG9vbD5BZG9iZSBQaG90b3Nob3AgQ0MgKFdpbmRvd3MpPC94bXA6Q3JlYXRvclRvb2w+CiAgICAgICAgIDx4bXA6Q3JlYXRlRGF0ZT4yMDE0LTAxLTIyVDE5OjI0OjUxKzAxOjAwPC94bXA6Q3JlYXRlRGF0ZT4KICAgICAgICAgPHhtcDpNZXRhZGF0YURhdGU+MjAxNC0wMi0wNFQxNTowMTowOSswMTowMDwveG1wOk1ldGFkYXRhRGF0ZT4KICAgICAgICAgPHhtcDpNb2RpZnlEYXRlPjIwMTQtMDItMDRUMTU6MDE6MDkrMDE6MDA8L3htcDpNb2RpZnlEYXRlPgogICAgICAgICA8ZGM6Zm9ybWF0PmltYWdlL3BuZzwvZGM6Zm9ybWF0PgogICAgICAgICA8eG1wTU06SW5zdGFuY2VJRD54bXAuaWlkOmI2YjQwMjVkLTAxNjQtMzU0OC1hOTdlLTQ4ZmYxMWM3NTYzMzwveG1wTU06SW5zdGFuY2VJRD4KICAgICAgICAgPHhtcE1NOkRvY3VtZW50SUQ+eG1wLmRpZDpFQTc2MkY5Njc0ODNFMzExOTQ4QkQxM0UyQkU3OTlBMTwveG1wTU06RG9jdW1lbnRJRD4KICAgICAgICAgPHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD54bXAuZGlkOjczQjYyQUFEOTE4M0UzMTE5NDhCRDEzRTJCRTc5OUExPC94bXBNTTpPcmlnaW5hbERvY3VtZW50SUQ+CiAgICAgICAgIDx4bXBNTTpIaXN0b3J5PgogICAgICAgICAgICA8cmRmOlNlcT4KICAgICAgICAgICAgICAgPHJkZjpsaSByZGY6cGFyc2VUeXBlPSJSZXNvdXJjZSI+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDphY3Rpb24+Y3JlYXRlZDwvc3RFdnQ6YWN0aW9uPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6aW5zdGFuY2VJRD54bXAuaWlkOjczQjYyQUFEOTE4M0UzMTE5NDhCRDEzRTJCRTc5OUExPC9zdEV2dDppbnN0YW5jZUlEPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6d2hlbj4yMDE0LTAxLTIyVDE5OjI0OjUxKzAxOjAwPC9zdEV2dDp3aGVuPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6c29mdHdhcmVBZ2VudD5BZG9iZSBQaG90b3Nob3AgQ1M2IChXaW5kb3dzKTwvc3RFdnQ6c29mdHdhcmVBZ2VudD4KICAgICAgICAgICAgICAgPC9yZGY6bGk+CiAgICAgICAgICAgICAgIDxyZGY6bGkgcmRmOnBhcnNlVHlwZT0iUmVzb3VyY2UiPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6YWN0aW9uPnNhdmVkPC9zdEV2dDphY3Rpb24+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDppbnN0YW5jZUlEPnhtcC5paWQ6RUE2MEEyNEUxOTg0RTMxMUFEQUZFRkU2RUMzMzNFMDM8L3N0RXZ0Omluc3RhbmNlSUQ+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDp3aGVuPjIwMTQtMDEtMjNUMTk6MTg6MDcrMDE6MDA8L3N0RXZ0OndoZW4+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDpzb2Z0d2FyZUFnZW50PkFkb2JlIFBob3Rvc2hvcCBDUzYgKFdpbmRvd3MpPC9zdEV2dDpzb2Z0d2FyZUFnZW50PgogICAgICAgICAgICAgICAgICA8c3RFdnQ6Y2hhbmdlZD4vPC9zdEV2dDpjaGFuZ2VkPgogICAgICAgICAgICAgICA8L3JkZjpsaT4KICAgICAgICAgICAgICAgPHJkZjpsaSByZGY6cGFyc2VUeXBlPSJSZXNvdXJjZSI+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDphY3Rpb24+c2F2ZWQ8L3N0RXZ0OmFjdGlvbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0Omluc3RhbmNlSUQ+eG1wLmlpZDpmOWQ3OGY4ZC1lNzY0LTc1NDgtODZiNy1iNmQ1OGMzZDg2OTc8L3N0RXZ0Omluc3RhbmNlSUQ+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDp3aGVuPjIwMTQtMDItMDRUMTU6MDE6MDkrMDE6MDA8L3N0RXZ0OndoZW4+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDpzb2Z0d2FyZUFnZW50PkFkb2JlIFBob3Rvc2hvcCBDQyAoV2luZG93cyk8L3N0RXZ0OnNvZnR3YXJlQWdlbnQ+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDpjaGFuZ2VkPi88L3N0RXZ0OmNoYW5nZWQ+CiAgICAgICAgICAgICAgIDwvcmRmOmxpPgogICAgICAgICAgICAgICA8cmRmOmxpIHJkZjpwYXJzZVR5cGU9IlJlc291cmNlIj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OmFjdGlvbj5jb252ZXJ0ZWQ8L3N0RXZ0OmFjdGlvbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OnBhcmFtZXRlcnM+ZnJvbSBhcHBsaWNhdGlvbi92bmQuYWRvYmUucGhvdG9zaG9wIHRvIGltYWdlL3BuZzwvc3RFdnQ6cGFyYW1ldGVycz4KICAgICAgICAgICAgICAgPC9yZGY6bGk+CiAgICAgICAgICAgICAgIDxyZGY6bGkgcmRmOnBhcnNlVHlwZT0iUmVzb3VyY2UiPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6YWN0aW9uPmRlcml2ZWQ8L3N0RXZ0OmFjdGlvbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OnBhcmFtZXRlcnM+Y29udmVydGVkIGZyb20gYXBwbGljYXRpb24vdm5kLmFkb2JlLnBob3Rvc2hvcCB0byBpbWFnZS9wbmc8L3N0RXZ0OnBhcmFtZXRlcnM+CiAgICAgICAgICAgICAgIDwvcmRmOmxpPgogICAgICAgICAgICAgICA8cmRmOmxpIHJkZjpwYXJzZVR5cGU9IlJlc291cmNlIj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OmFjdGlvbj5zYXZlZDwvc3RFdnQ6YWN0aW9uPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6aW5zdGFuY2VJRD54bXAuaWlkOmI2YjQwMjVkLTAxNjQtMzU0OC1hOTdlLTQ4ZmYxMWM3NTYzMzwvc3RFdnQ6aW5zdGFuY2VJRD4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OndoZW4+MjAxNC0wMi0wNFQxNTowMTowOSswMTowMDwvc3RFdnQ6d2hlbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OnNvZnR3YXJlQWdlbnQ+QWRvYmUgUGhvdG9zaG9wIENDIChXaW5kb3dzKTwvc3RFdnQ6c29mdHdhcmVBZ2VudD4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OmNoYW5nZWQ+Lzwvc3RFdnQ6Y2hhbmdlZD4KICAgICAgICAgICAgICAgPC9yZGY6bGk+CiAgICAgICAgICAgIDwvcmRmOlNlcT4KICAgICAgICAgPC94bXBNTTpIaXN0b3J5PgogICAgICAgICA8eG1wTU06RGVyaXZlZEZyb20gcmRmOnBhcnNlVHlwZT0iUmVzb3VyY2UiPgogICAgICAgICAgICA8c3RSZWY6aW5zdGFuY2VJRD54bXAuaWlkOmY5ZDc4ZjhkLWU3NjQtNzU0OC04NmI3LWI2ZDU4YzNkODY5Nzwvc3RSZWY6aW5zdGFuY2VJRD4KICAgICAgICAgICAgPHN0UmVmOmRvY3VtZW50SUQ+eG1wLmRpZDpFQTc2MkY5Njc0ODNFMzExOTQ4QkQxM0UyQkU3OTlBMTwvc3RSZWY6ZG9jdW1lbnRJRD4KICAgICAgICAgICAgPHN0UmVmOm9yaWdpbmFsRG9jdW1lbnRJRD54bXAuZGlkOjczQjYyQUFEOTE4M0UzMTE5NDhCRDEzRTJCRTc5OUExPC9zdFJlZjpvcmlnaW5hbERvY3VtZW50SUQ+CiAgICAgICAgIDwveG1wTU06RGVyaXZlZEZyb20+CiAgICAgICAgIDxwaG90b3Nob3A6Q29sb3JNb2RlPjM8L3Bob3Rvc2hvcDpDb2xvck1vZGU+CiAgICAgICAgIDxwaG90b3Nob3A6SUNDUHJvZmlsZT5zUkdCIElFQzYxOTY2LTIuMTwvcGhvdG9zaG9wOklDQ1Byb2ZpbGU+CiAgICAgICAgIDx0aWZmOk9yaWVudGF0aW9uPjE8L3RpZmY6T3JpZW50YXRpb24+CiAgICAgICAgIDx0aWZmOlhSZXNvbHV0aW9uPjcyMDA5MC8xMDAwMDwvdGlmZjpYUmVzb2x1dGlvbj4KICAgICAgICAgPHRpZmY6WVJlc29sdXRpb24+NzIwMDkwLzEwMDAwPC90aWZmOllSZXNvbHV0aW9uPgogICAgICAgICA8dGlmZjpSZXNvbHV0aW9uVW5pdD4yPC90aWZmOlJlc29sdXRpb25Vbml0PgogICAgICAgICA8ZXhpZjpDb2xvclNwYWNlPjE8L2V4aWY6Q29sb3JTcGFjZT4KICAgICAgICAgPGV4aWY6UGl4ZWxYRGltZW5zaW9uPjI0PC9leGlmOlBpeGVsWERpbWVuc2lvbj4KICAgICAgICAgPGV4aWY6UGl4ZWxZRGltZW5zaW9uPjI0PC9leGlmOlBpeGVsWURpbWVuc2lvbj4KICAgICAgPC9yZGY6RGVzY3JpcHRpb24+CiAgIDwvcmRmOlJERj4KPC94OnhtcG1ldGE+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgCjw/eHBhY2tldCBlbmQ9InciPz4jq1U/AAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAAVTSURBVHjanFVfTFNnFP+d77ve8qeVFbBrpcVgRrCRFikFByLxwSAaE32oRCHD6JMxxhhn8G2RxxH3MsOTbyYsmCAxPMmMMYtkIUYmK60OO0qAK23BFlNob0uh3x7WS5jLZPpLbm6+k/P9zrm5v9855PF4UFhYCABgjIExBgAgIqRSqRIi6gDQRkQ1RGTB3wgR0e8AHgH4Sa/XR/EBiAiJRAJ04cIF5Ofng4g2n0gkUkxENwF0c843LzHGQEQQQkCLExEA9ALotVgsUQAQQmgNQhJCbF5kjCEUCl0moj4t5na7fTU1NUpVVVXUYrEkASAcDhe8efOmxOfzWScmJqoBdBNR99LS0hWz2dynNSSEAF28eBGFhYVgjCEcDn9HRD1EhIMHD3o9Hs9kWVlZAh9BKBQqGB4edr58+dKZ+6JbJpOpBwBWV1fB6+rqIMsyIpHIFcZYL2MMra2tY5cuXRrfuXNnBtvAYDBk3G63oqpqZm5uzgrgSDKZjBoMhueZTAbc5XIhFouVEtFTxhiOHTs2dv78eS8+Efv374+oqpqZnZ21cs5PJJPJPlmWkyynnBuMMTQ0NHi7uro+mVyDx+Pxulwu71ZOlkqlSonoJhGhvb39s8k1nDx50ss5hyRJN9PpdKlERB2aWjSVaEilUvzBgwcORVEs5eXloXPnzk1sV8BkMiUdDofP7/dXZ7PZDilnIhw4cGBeS1pbW2P37t1zBwKBikQiUUREWFhYsHHO0d7evm0Ru90+/+rVq2rO+XGJiJxEhMrKyhgAjI6OWoeHh5tWVla+4JzDZrO9bW5unhwcHGzz+/32np4e+xaDbfoHAMxmc6ijo2O0oqIiJkkSNjY2HBIRmRljMJvNyWfPnln7+/tPMMZQXl6+0NbW9qK2tjYcj8floaEhqKpq+HCkbD3PzMwYBgYG0NXV9UuusFna2kEgELAQEQ4dOvSis7PzN41Ar9dnrl27NqCNkv/C3bt3zy4tLVmICJxzEBFJRBQmorLFxcWCqqqq0Pj4eO3Y2JhbUZTdra2tL2pra8OJRGLHnTt3zkqS9K+huHU4EhHMZnMoGo0W5OIh7nK5jjLGKq1W69vDhw8rRqMxMjc3t2t5eXnX5ORklc/nM+fl5SWnpqa+0uv1K/n5+Ws6nW5NluXNd15e3ppOp1uz2WyzZ86cGQ0Gg6ZAIFCZzWZ/lYjokRDiuN/vt7W0tMw3NTUpbrd78P79++5gMFgRiUTKHj58WMYYQ3V19etTp05tq6Lp6Wkb5xxCiEfc7XZPM8a6FxcXTfX19a/1en2Gcy5qamreNjY2/qGq6joRZe12+9Tp06e3JY/FYgWPHz8+mhvr3/CWlpbk+vp6PmOseWVlBS6XS9GSJUkSdrs93NDQ8Oe+ffvC/8fJIyMjddFo9Esi6pVleVjT2m0A8Hq9zqGhIefnjoknT544A4GAM/eDbxMReFNTE0pKSpKqqsaI6Pj8/LxVVdWM3W6PfCr5xMTE1zllXS0uLn6aSqXAGxsbodPpoNfrn6uqCs75EUVRrJFIZMfevXsXdTrdxseIE4mEPDIyUu/3++tynd8yGo29RIR0Og26fv06ioqKwBgD5xzv3r27zBjrIyJIkgSHwzFZWVmp7NmzJ1ZaWpoAgGg0WqgoSvHMzIw1GAw6tvjhitFo7NPW5fv370Hd3d0oKCgA53zTQMvLy+VCiKuSJH0rSdLmztZytIWv5RPRD0T0Y3Fx8dzWfby6ugopHo//w4mcc8iyPMc5v5FOp7/PZrOdQohWInIC2C2EgBBigYi8Qoifs9lsv06nWyIiaFxagXg8jr8GAGxuIe7LBeWhAAAAAElFTkSuQmCC")}div.vis-network div.vis-manipulation div.vis-none:hover{box-shadow:1px 1px 8px transparent;cursor:default}div.vis-network div.vis-manipulation div.vis-none:active{box-shadow:1px 1px 8px transparent}div.vis-network div.vis-manipulation div.vis-none{line-height:23px;padding:0}div.vis-network div.vis-manipulation div.notification{font-weight:700;margin:2px}div.vis-network div.vis-manipulation button.vis-button.vis-add{background-image:url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAACXBIWXMAAAsTAAALEwEAmpwYAAAKT2lDQ1BQaG90b3Nob3AgSUNDIHByb2ZpbGUAAHjanVNnVFPpFj333vRCS4iAlEtvUhUIIFJCi4AUkSYqIQkQSoghodkVUcERRUUEG8igiAOOjoCMFVEsDIoK2AfkIaKOg6OIisr74Xuja9a89+bN/rXXPues852zzwfACAyWSDNRNYAMqUIeEeCDx8TG4eQuQIEKJHAAEAizZCFz/SMBAPh+PDwrIsAHvgABeNMLCADATZvAMByH/w/qQplcAYCEAcB0kThLCIAUAEB6jkKmAEBGAYCdmCZTAKAEAGDLY2LjAFAtAGAnf+bTAICd+Jl7AQBblCEVAaCRACATZYhEAGg7AKzPVopFAFgwABRmS8Q5ANgtADBJV2ZIALC3AMDOEAuyAAgMADBRiIUpAAR7AGDIIyN4AISZABRG8lc88SuuEOcqAAB4mbI8uSQ5RYFbCC1xB1dXLh4ozkkXKxQ2YQJhmkAuwnmZGTKBNA/g88wAAKCRFRHgg/P9eM4Ors7ONo62Dl8t6r8G/yJiYuP+5c+rcEAAAOF0ftH+LC+zGoA7BoBt/qIl7gRoXgugdfeLZrIPQLUAoOnaV/Nw+H48PEWhkLnZ2eXk5NhKxEJbYcpXff5nwl/AV/1s+X48/Pf14L7iJIEyXYFHBPjgwsz0TKUcz5IJhGLc5o9H/LcL//wd0yLESWK5WCoU41EScY5EmozzMqUiiUKSKcUl0v9k4t8s+wM+3zUAsGo+AXuRLahdYwP2SycQWHTA4vcAAPK7b8HUKAgDgGiD4c93/+8//UegJQCAZkmScQAAXkQkLlTKsz/HCAAARKCBKrBBG/TBGCzABhzBBdzBC/xgNoRCJMTCQhBCCmSAHHJgKayCQiiGzbAdKmAv1EAdNMBRaIaTcA4uwlW4Dj1wD/phCJ7BKLyBCQRByAgTYSHaiAFiilgjjggXmYX4IcFIBBKLJCDJiBRRIkuRNUgxUopUIFVIHfI9cgI5h1xGupE7yAAygvyGvEcxlIGyUT3UDLVDuag3GoRGogvQZHQxmo8WoJvQcrQaPYw2oefQq2gP2o8+Q8cwwOgYBzPEbDAuxsNCsTgsCZNjy7EirAyrxhqwVqwDu4n1Y8+xdwQSgUXACTYEd0IgYR5BSFhMWE7YSKggHCQ0EdoJNwkDhFHCJyKTqEu0JroR+cQYYjIxh1hILCPWEo8TLxB7iEPENyQSiUMyJ7mQAkmxpFTSEtJG0m5SI+ksqZs0SBojk8naZGuyBzmULCAryIXkneTD5DPkG+Qh8lsKnWJAcaT4U+IoUspqShnlEOU05QZlmDJBVaOaUt2ooVQRNY9aQq2htlKvUYeoEzR1mjnNgxZJS6WtopXTGmgXaPdpr+h0uhHdlR5Ol9BX0svpR+iX6AP0dwwNhhWDx4hnKBmbGAcYZxl3GK+YTKYZ04sZx1QwNzHrmOeZD5lvVVgqtip8FZHKCpVKlSaVGyovVKmqpqreqgtV81XLVI+pXlN9rkZVM1PjqQnUlqtVqp1Q61MbU2epO6iHqmeob1Q/pH5Z/YkGWcNMw09DpFGgsV/jvMYgC2MZs3gsIWsNq4Z1gTXEJrHN2Xx2KruY/R27iz2qqaE5QzNKM1ezUvOUZj8H45hx+Jx0TgnnKKeX836K3hTvKeIpG6Y0TLkxZVxrqpaXllirSKtRq0frvTau7aedpr1Fu1n7gQ5Bx0onXCdHZ4/OBZ3nU9lT3acKpxZNPTr1ri6qa6UbobtEd79up+6Ynr5egJ5Mb6feeb3n+hx9L/1U/W36p/VHDFgGswwkBtsMzhg8xTVxbzwdL8fb8VFDXcNAQ6VhlWGX4YSRudE8o9VGjUYPjGnGXOMk423GbcajJgYmISZLTepN7ppSTbmmKaY7TDtMx83MzaLN1pk1mz0x1zLnm+eb15vft2BaeFostqi2uGVJsuRaplnutrxuhVo5WaVYVVpds0atna0l1rutu6cRp7lOk06rntZnw7Dxtsm2qbcZsOXYBtuutm22fWFnYhdnt8Wuw+6TvZN9un2N/T0HDYfZDqsdWh1+c7RyFDpWOt6azpzuP33F9JbpL2dYzxDP2DPjthPLKcRpnVOb00dnF2e5c4PziIuJS4LLLpc+Lpsbxt3IveRKdPVxXeF60vWdm7Obwu2o26/uNu5p7ofcn8w0nymeWTNz0MPIQ+BR5dE/C5+VMGvfrH5PQ0+BZ7XnIy9jL5FXrdewt6V3qvdh7xc+9j5yn+M+4zw33jLeWV/MN8C3yLfLT8Nvnl+F30N/I/9k/3r/0QCngCUBZwOJgUGBWwL7+Hp8Ib+OPzrbZfay2e1BjKC5QRVBj4KtguXBrSFoyOyQrSH355jOkc5pDoVQfujW0Adh5mGLw34MJ4WHhVeGP45wiFga0TGXNXfR3ENz30T6RJZE3ptnMU85ry1KNSo+qi5qPNo3ujS6P8YuZlnM1VidWElsSxw5LiquNm5svt/87fOH4p3iC+N7F5gvyF1weaHOwvSFpxapLhIsOpZATIhOOJTwQRAqqBaMJfITdyWOCnnCHcJnIi/RNtGI2ENcKh5O8kgqTXqS7JG8NXkkxTOlLOW5hCepkLxMDUzdmzqeFpp2IG0yPTq9MYOSkZBxQqohTZO2Z+pn5mZ2y6xlhbL+xW6Lty8elQfJa7OQrAVZLQq2QqboVFoo1yoHsmdlV2a/zYnKOZarnivN7cyzytuQN5zvn//tEsIS4ZK2pYZLVy0dWOa9rGo5sjxxedsK4xUFK4ZWBqw8uIq2Km3VT6vtV5eufr0mek1rgV7ByoLBtQFr6wtVCuWFfevc1+1dT1gvWd+1YfqGnRs+FYmKrhTbF5cVf9go3HjlG4dvyr+Z3JS0qavEuWTPZtJm6ebeLZ5bDpaql+aXDm4N2dq0Dd9WtO319kXbL5fNKNu7g7ZDuaO/PLi8ZafJzs07P1SkVPRU+lQ27tLdtWHX+G7R7ht7vPY07NXbW7z3/T7JvttVAVVN1WbVZftJ+7P3P66Jqun4lvttXa1ObXHtxwPSA/0HIw6217nU1R3SPVRSj9Yr60cOxx++/p3vdy0NNg1VjZzG4iNwRHnk6fcJ3/ceDTradox7rOEH0x92HWcdL2pCmvKaRptTmvtbYlu6T8w+0dbq3nr8R9sfD5w0PFl5SvNUyWna6YLTk2fyz4ydlZ19fi753GDborZ752PO32oPb++6EHTh0kX/i+c7vDvOXPK4dPKy2+UTV7hXmq86X23qdOo8/pPTT8e7nLuarrlca7nuer21e2b36RueN87d9L158Rb/1tWeOT3dvfN6b/fF9/XfFt1+cif9zsu72Xcn7q28T7xf9EDtQdlD3YfVP1v+3Njv3H9qwHeg89HcR/cGhYPP/pH1jw9DBY+Zj8uGDYbrnjg+OTniP3L96fynQ89kzyaeF/6i/suuFxYvfvjV69fO0ZjRoZfyl5O/bXyl/erA6xmv28bCxh6+yXgzMV70VvvtwXfcdx3vo98PT+R8IH8o/2j5sfVT0Kf7kxmTk/8EA5jz/GMzLdsAAEEOaVRYdFhNTDpjb20uYWRvYmUueG1wAAAAAAA8P3hwYWNrZXQgYmVnaW49Iu+7vyIgaWQ9Ilc1TTBNcENlaGlIenJlU3pOVGN6a2M5ZCI/Pgo8eDp4bXBtZXRhIHhtbG5zOng9ImFkb2JlOm5zOm1ldGEvIiB4OnhtcHRrPSJBZG9iZSBYTVAgQ29yZSA1LjUtYzAyMSA3OS4xNTQ5MTEsIDIwMTMvMTAvMjktMTE6NDc6MTYgICAgICAgICI+CiAgIDxyZGY6UkRGIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyI+CiAgICAgIDxyZGY6RGVzY3JpcHRpb24gcmRmOmFib3V0PSIiCiAgICAgICAgICAgIHhtbG5zOnhtcD0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLyIKICAgICAgICAgICAgeG1sbnM6ZGM9Imh0dHA6Ly9wdXJsLm9yZy9kYy9lbGVtZW50cy8xLjEvIgogICAgICAgICAgICB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIKICAgICAgICAgICAgeG1sbnM6c3RFdnQ9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZUV2ZW50IyIKICAgICAgICAgICAgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiCiAgICAgICAgICAgIHhtbG5zOnBob3Rvc2hvcD0iaHR0cDovL25zLmFkb2JlLmNvbS9waG90b3Nob3AvMS4wLyIKICAgICAgICAgICAgeG1sbnM6dGlmZj0iaHR0cDovL25zLmFkb2JlLmNvbS90aWZmLzEuMC8iCiAgICAgICAgICAgIHhtbG5zOmV4aWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20vZXhpZi8xLjAvIj4KICAgICAgICAgPHhtcDpDcmVhdG9yVG9vbD5BZG9iZSBQaG90b3Nob3AgQ0MgKFdpbmRvd3MpPC94bXA6Q3JlYXRvclRvb2w+CiAgICAgICAgIDx4bXA6Q3JlYXRlRGF0ZT4yMDE0LTAxLTIyVDE5OjI0OjUxKzAxOjAwPC94bXA6Q3JlYXRlRGF0ZT4KICAgICAgICAgPHhtcDpNZXRhZGF0YURhdGU+MjAxNC0wMi0wNFQxNDo0MDoyOSswMTowMDwveG1wOk1ldGFkYXRhRGF0ZT4KICAgICAgICAgPHhtcDpNb2RpZnlEYXRlPjIwMTQtMDItMDRUMTQ6NDA6MjkrMDE6MDA8L3htcDpNb2RpZnlEYXRlPgogICAgICAgICA8ZGM6Zm9ybWF0PmltYWdlL3BuZzwvZGM6Zm9ybWF0PgogICAgICAgICA8eG1wTU06SW5zdGFuY2VJRD54bXAuaWlkOjVkNWIwNmQwLTVmMjAtOGE0NC1hMzIwLWZmMTEzMzQwNDc0YjwveG1wTU06SW5zdGFuY2VJRD4KICAgICAgICAgPHhtcE1NOkRvY3VtZW50SUQ+eG1wLmRpZDpFQTc2MkY5Njc0ODNFMzExOTQ4QkQxM0UyQkU3OTlBMTwveG1wTU06RG9jdW1lbnRJRD4KICAgICAgICAgPHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD54bXAuZGlkOjczQjYyQUFEOTE4M0UzMTE5NDhCRDEzRTJCRTc5OUExPC94bXBNTTpPcmlnaW5hbERvY3VtZW50SUQ+CiAgICAgICAgIDx4bXBNTTpIaXN0b3J5PgogICAgICAgICAgICA8cmRmOlNlcT4KICAgICAgICAgICAgICAgPHJkZjpsaSByZGY6cGFyc2VUeXBlPSJSZXNvdXJjZSI+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDphY3Rpb24+Y3JlYXRlZDwvc3RFdnQ6YWN0aW9uPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6aW5zdGFuY2VJRD54bXAuaWlkOjczQjYyQUFEOTE4M0UzMTE5NDhCRDEzRTJCRTc5OUExPC9zdEV2dDppbnN0YW5jZUlEPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6d2hlbj4yMDE0LTAxLTIyVDE5OjI0OjUxKzAxOjAwPC9zdEV2dDp3aGVuPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6c29mdHdhcmVBZ2VudD5BZG9iZSBQaG90b3Nob3AgQ1M2IChXaW5kb3dzKTwvc3RFdnQ6c29mdHdhcmVBZ2VudD4KICAgICAgICAgICAgICAgPC9yZGY6bGk+CiAgICAgICAgICAgICAgIDxyZGY6bGkgcmRmOnBhcnNlVHlwZT0iUmVzb3VyY2UiPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6YWN0aW9uPnNhdmVkPC9zdEV2dDphY3Rpb24+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDppbnN0YW5jZUlEPnhtcC5paWQ6RUE2MEEyNEUxOTg0RTMxMUFEQUZFRkU2RUMzMzNFMDM8L3N0RXZ0Omluc3RhbmNlSUQ+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDp3aGVuPjIwMTQtMDEtMjNUMTk6MTg6MDcrMDE6MDA8L3N0RXZ0OndoZW4+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDpzb2Z0d2FyZUFnZW50PkFkb2JlIFBob3Rvc2hvcCBDUzYgKFdpbmRvd3MpPC9zdEV2dDpzb2Z0d2FyZUFnZW50PgogICAgICAgICAgICAgICAgICA8c3RFdnQ6Y2hhbmdlZD4vPC9zdEV2dDpjaGFuZ2VkPgogICAgICAgICAgICAgICA8L3JkZjpsaT4KICAgICAgICAgICAgICAgPHJkZjpsaSByZGY6cGFyc2VUeXBlPSJSZXNvdXJjZSI+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDphY3Rpb24+c2F2ZWQ8L3N0RXZ0OmFjdGlvbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0Omluc3RhbmNlSUQ+eG1wLmlpZDo2OWVmYWE1NS01ZTI5LTIzNGUtYTUzMy0xNDkxYjM1NDNmYmE8L3N0RXZ0Omluc3RhbmNlSUQ+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDp3aGVuPjIwMTQtMDItMDRUMTQ6NDA6MjkrMDE6MDA8L3N0RXZ0OndoZW4+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDpzb2Z0d2FyZUFnZW50PkFkb2JlIFBob3Rvc2hvcCBDQyAoV2luZG93cyk8L3N0RXZ0OnNvZnR3YXJlQWdlbnQ+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDpjaGFuZ2VkPi88L3N0RXZ0OmNoYW5nZWQ+CiAgICAgICAgICAgICAgIDwvcmRmOmxpPgogICAgICAgICAgICAgICA8cmRmOmxpIHJkZjpwYXJzZVR5cGU9IlJlc291cmNlIj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OmFjdGlvbj5jb252ZXJ0ZWQ8L3N0RXZ0OmFjdGlvbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OnBhcmFtZXRlcnM+ZnJvbSBhcHBsaWNhdGlvbi92bmQuYWRvYmUucGhvdG9zaG9wIHRvIGltYWdlL3BuZzwvc3RFdnQ6cGFyYW1ldGVycz4KICAgICAgICAgICAgICAgPC9yZGY6bGk+CiAgICAgICAgICAgICAgIDxyZGY6bGkgcmRmOnBhcnNlVHlwZT0iUmVzb3VyY2UiPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6YWN0aW9uPmRlcml2ZWQ8L3N0RXZ0OmFjdGlvbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OnBhcmFtZXRlcnM+Y29udmVydGVkIGZyb20gYXBwbGljYXRpb24vdm5kLmFkb2JlLnBob3Rvc2hvcCB0byBpbWFnZS9wbmc8L3N0RXZ0OnBhcmFtZXRlcnM+CiAgICAgICAgICAgICAgIDwvcmRmOmxpPgogICAgICAgICAgICAgICA8cmRmOmxpIHJkZjpwYXJzZVR5cGU9IlJlc291cmNlIj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OmFjdGlvbj5zYXZlZDwvc3RFdnQ6YWN0aW9uPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6aW5zdGFuY2VJRD54bXAuaWlkOjVkNWIwNmQwLTVmMjAtOGE0NC1hMzIwLWZmMTEzMzQwNDc0Yjwvc3RFdnQ6aW5zdGFuY2VJRD4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OndoZW4+MjAxNC0wMi0wNFQxNDo0MDoyOSswMTowMDwvc3RFdnQ6d2hlbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OnNvZnR3YXJlQWdlbnQ+QWRvYmUgUGhvdG9zaG9wIENDIChXaW5kb3dzKTwvc3RFdnQ6c29mdHdhcmVBZ2VudD4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OmNoYW5nZWQ+Lzwvc3RFdnQ6Y2hhbmdlZD4KICAgICAgICAgICAgICAgPC9yZGY6bGk+CiAgICAgICAgICAgIDwvcmRmOlNlcT4KICAgICAgICAgPC94bXBNTTpIaXN0b3J5PgogICAgICAgICA8eG1wTU06RGVyaXZlZEZyb20gcmRmOnBhcnNlVHlwZT0iUmVzb3VyY2UiPgogICAgICAgICAgICA8c3RSZWY6aW5zdGFuY2VJRD54bXAuaWlkOjY5ZWZhYTU1LTVlMjktMjM0ZS1hNTMzLTE0OTFiMzU0M2ZiYTwvc3RSZWY6aW5zdGFuY2VJRD4KICAgICAgICAgICAgPHN0UmVmOmRvY3VtZW50SUQ+eG1wLmRpZDpFQTc2MkY5Njc0ODNFMzExOTQ4QkQxM0UyQkU3OTlBMTwvc3RSZWY6ZG9jdW1lbnRJRD4KICAgICAgICAgICAgPHN0UmVmOm9yaWdpbmFsRG9jdW1lbnRJRD54bXAuZGlkOjczQjYyQUFEOTE4M0UzMTE5NDhCRDEzRTJCRTc5OUExPC9zdFJlZjpvcmlnaW5hbERvY3VtZW50SUQ+CiAgICAgICAgIDwveG1wTU06RGVyaXZlZEZyb20+CiAgICAgICAgIDxwaG90b3Nob3A6Q29sb3JNb2RlPjM8L3Bob3Rvc2hvcDpDb2xvck1vZGU+CiAgICAgICAgIDxwaG90b3Nob3A6SUNDUHJvZmlsZT5zUkdCIElFQzYxOTY2LTIuMTwvcGhvdG9zaG9wOklDQ1Byb2ZpbGU+CiAgICAgICAgIDx0aWZmOk9yaWVudGF0aW9uPjE8L3RpZmY6T3JpZW50YXRpb24+CiAgICAgICAgIDx0aWZmOlhSZXNvbHV0aW9uPjcyMDA5MC8xMDAwMDwvdGlmZjpYUmVzb2x1dGlvbj4KICAgICAgICAgPHRpZmY6WVJlc29sdXRpb24+NzIwMDkwLzEwMDAwPC90aWZmOllSZXNvbHV0aW9uPgogICAgICAgICA8dGlmZjpSZXNvbHV0aW9uVW5pdD4yPC90aWZmOlJlc29sdXRpb25Vbml0PgogICAgICAgICA8ZXhpZjpDb2xvclNwYWNlPjE8L2V4aWY6Q29sb3JTcGFjZT4KICAgICAgICAgPGV4aWY6UGl4ZWxYRGltZW5zaW9uPjI0PC9leGlmOlBpeGVsWERpbWVuc2lvbj4KICAgICAgICAgPGV4aWY6UGl4ZWxZRGltZW5zaW9uPjI0PC9leGlmOlBpeGVsWURpbWVuc2lvbj4KICAgICAgPC9yZGY6RGVzY3JpcHRpb24+CiAgIDwvcmRmOlJERj4KPC94OnhtcG1ldGE+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgCjw/eHBhY2tldCBlbmQ9InciPz5WKqp9AAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAAYXSURBVHjafFZtUFTXGX7e9z27sveuMCwYV8ElrA7YSFYHtJUPkaaI0aRqG8wP00zUzljDINNSA/2ROtpO24SxnahlxjYd7SSjmUkymcxYlDhQPzHGisEVp8HwYWCVVVgEsrsuLnL74+5uqTF9Z+7cO/d8PO95zvO851BlZSV0XQcAMDOYGQBARDhX3JRmMDYZwLPMWAzGHACYIgwS46oBNBNwtOL8CwE8EkSEUCgE2rJlC2w2G4go8Zwo/bMDgnoG6gxLfAAAYvPDMCCszKTAMIAGAhrWnf15AAAMwwARIRKJgDZv3gy73Q4iAjPjxIr9VVOMRhbAYKB8zvrO0llrfEsdKwLZek6YAPSFvtSu3GtLawu0ZJ6625SHGBQB1T88t6MxvopgMAjaunUrdF0HM+P4yv27DMYeJmB1RqW3Jnf3tQX2p0L4P9EXuqEd7PmDp+XuMU9sRbvXnnt1TxxACgoKYLVacbzsQDUJGkSATe6qi28uPtzusM6Kxie6NHLGUX3lxVUNX9StPHnn4wy3njuUYcu6n2pNi66avcEXnByP/nv8aiaIyrqz2gO5A9+9FI1GIfn5+WhZdTAdjFMkwMvZOy7uWnTAOz3L4Yk71m3t69fdfTDoUGTBeHTUfiHQ6lo7Z2OXJvpDAChKe+aOCdKRKWxZ2+1qb3yyd3GYmRkQ7GQBVs99wfv6on3eR2k4PdTkDEbH7IuS8/svld/561PJS/pDk1/bzwx94pze7xc5v/H+YPY6r5BAkdrJzODTK46lE6PeYEJt7u+8j+OZwCBiEAgAoNgKJoEQf6PvNvdrXgtZoNhSf7q0KZ3B2AQmVMze0Jmt54S/DcDCVig2NcvEUGxJAE4Pl+YOr0iv6BRSIPAmBeBZAmHlE2sH4p1uhrq1s0MnnEQMBsf8wRASAICQQCCITN1X7/sOuc0kgOVp3/fPs2WHv+coG7gQOJUnLGsUCTxEjPzUohEA+NfIWUdtx0+efzA1kSSkIGyBAQNCKgHAEBAJ3u79U7kiAcWoem/gb5Fd33nrH3kp+SMWtuAB+GllMJxMjCx9QRgA3uiqL5kwHiTlpxb3smlfMDGYGPP1hcMAkJvs8ScpfdJspdj+MK6Pf+5+u29vyb4lR4+BGEziVESAkEpw6Av1OhUpHCz4qOXbzFWz4Ncdj/v/o08Lt92ODDgZDCEFJYoUGH4mzugP92puPTf0pD3H7wvfdFZdqSxnMtWjoGAAmG9fOLxjwesdjT2/XzIQ7ks3sycYMSEwGHNtWf5bkX5NkYCJBxUBXiGV0XHvosOt54Zey33j/K+8P33++vjnbiGJbbLE+J9SANAb6nJ2B79wcUwETAwQQ7fMjPzMvfP8ja87HUIKMOiaAqMZhrGmLdAy78eZrwwsTS0eObTs+IdtgVanxBUExqGbb5VzrIISGIoUXsmqbgEhJldCQWqRf27SvPAn/o8XmgLhZsUkR4ll37mhk3n94Z4OlzY/7NLcYZfm7o1z2zT4vsvUNSXqprBCkmiTFbPX90/fh8GIT2sf+zTPdDMf4dVnNg4z+E0ixsGeBs9jd5ViSgLHjCb/peaR+MD3d4/ZJg2llyuG2Vwy7QWAs8PNnn1f7vkGSGxAzE6mk+kxkx/p/4unffSCR0hAoL1EBCYiPNdWNcwkNQTCR7feWX6g+7f/A7I8rcw/U6UEe0Ndrhc/W7mtL9ztmqlSgstSS/zTJ28dalpOpkRryrwbhwBACgsLMWPGDOT4ll3qyeqAkJTdCF7P/CrUY/GkLL1rE+2hTbSH8+0Lb/WEuhzhyaA905blf9Vd/895WnZwLHrPevir/cvOB1oLYpTtLrm6oYGIMDExAaqtrUVKSgqYGSKCk0WHq5ikkWEWtNL0imv5qUW+RclLRjJsrhBAuH1/QL8R7HR4xy5nescuP23E6hOA6mLv+sb4uTw6Ogqqq6uDpmkQkcStorX4XRcM1FjZ+kvFFjCJKU1WpkNJJUqIMtX1RyLeX3JtQ0JRhmGYZ/L27duRnJycuFGISOJ9pqh5lrB6iYgqGOxRrOaa54DcZmKvkJxk8JHC9rKh+KVhOsD4+Dj+MwADIf8n5m4xGwAAAABJRU5ErkJggg==")}div.vis-network div.vis-edit-mode button.vis-button.vis-edit,div.vis-network div.vis-manipulation button.vis-button.vis-edit{background-image:url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAACXBIWXMAAAsTAAALEwEAmpwYAAAKT2lDQ1BQaG90b3Nob3AgSUNDIHByb2ZpbGUAAHjanVNnVFPpFj333vRCS4iAlEtvUhUIIFJCi4AUkSYqIQkQSoghodkVUcERRUUEG8igiAOOjoCMFVEsDIoK2AfkIaKOg6OIisr74Xuja9a89+bN/rXXPues852zzwfACAyWSDNRNYAMqUIeEeCDx8TG4eQuQIEKJHAAEAizZCFz/SMBAPh+PDwrIsAHvgABeNMLCADATZvAMByH/w/qQplcAYCEAcB0kThLCIAUAEB6jkKmAEBGAYCdmCZTAKAEAGDLY2LjAFAtAGAnf+bTAICd+Jl7AQBblCEVAaCRACATZYhEAGg7AKzPVopFAFgwABRmS8Q5ANgtADBJV2ZIALC3AMDOEAuyAAgMADBRiIUpAAR7AGDIIyN4AISZABRG8lc88SuuEOcqAAB4mbI8uSQ5RYFbCC1xB1dXLh4ozkkXKxQ2YQJhmkAuwnmZGTKBNA/g88wAAKCRFRHgg/P9eM4Ors7ONo62Dl8t6r8G/yJiYuP+5c+rcEAAAOF0ftH+LC+zGoA7BoBt/qIl7gRoXgugdfeLZrIPQLUAoOnaV/Nw+H48PEWhkLnZ2eXk5NhKxEJbYcpXff5nwl/AV/1s+X48/Pf14L7iJIEyXYFHBPjgwsz0TKUcz5IJhGLc5o9H/LcL//wd0yLESWK5WCoU41EScY5EmozzMqUiiUKSKcUl0v9k4t8s+wM+3zUAsGo+AXuRLahdYwP2SycQWHTA4vcAAPK7b8HUKAgDgGiD4c93/+8//UegJQCAZkmScQAAXkQkLlTKsz/HCAAARKCBKrBBG/TBGCzABhzBBdzBC/xgNoRCJMTCQhBCCmSAHHJgKayCQiiGzbAdKmAv1EAdNMBRaIaTcA4uwlW4Dj1wD/phCJ7BKLyBCQRByAgTYSHaiAFiilgjjggXmYX4IcFIBBKLJCDJiBRRIkuRNUgxUopUIFVIHfI9cgI5h1xGupE7yAAygvyGvEcxlIGyUT3UDLVDuag3GoRGogvQZHQxmo8WoJvQcrQaPYw2oefQq2gP2o8+Q8cwwOgYBzPEbDAuxsNCsTgsCZNjy7EirAyrxhqwVqwDu4n1Y8+xdwQSgUXACTYEd0IgYR5BSFhMWE7YSKggHCQ0EdoJNwkDhFHCJyKTqEu0JroR+cQYYjIxh1hILCPWEo8TLxB7iEPENyQSiUMyJ7mQAkmxpFTSEtJG0m5SI+ksqZs0SBojk8naZGuyBzmULCAryIXkneTD5DPkG+Qh8lsKnWJAcaT4U+IoUspqShnlEOU05QZlmDJBVaOaUt2ooVQRNY9aQq2htlKvUYeoEzR1mjnNgxZJS6WtopXTGmgXaPdpr+h0uhHdlR5Ol9BX0svpR+iX6AP0dwwNhhWDx4hnKBmbGAcYZxl3GK+YTKYZ04sZx1QwNzHrmOeZD5lvVVgqtip8FZHKCpVKlSaVGyovVKmqpqreqgtV81XLVI+pXlN9rkZVM1PjqQnUlqtVqp1Q61MbU2epO6iHqmeob1Q/pH5Z/YkGWcNMw09DpFGgsV/jvMYgC2MZs3gsIWsNq4Z1gTXEJrHN2Xx2KruY/R27iz2qqaE5QzNKM1ezUvOUZj8H45hx+Jx0TgnnKKeX836K3hTvKeIpG6Y0TLkxZVxrqpaXllirSKtRq0frvTau7aedpr1Fu1n7gQ5Bx0onXCdHZ4/OBZ3nU9lT3acKpxZNPTr1ri6qa6UbobtEd79up+6Ynr5egJ5Mb6feeb3n+hx9L/1U/W36p/VHDFgGswwkBtsMzhg8xTVxbzwdL8fb8VFDXcNAQ6VhlWGX4YSRudE8o9VGjUYPjGnGXOMk423GbcajJgYmISZLTepN7ppSTbmmKaY7TDtMx83MzaLN1pk1mz0x1zLnm+eb15vft2BaeFostqi2uGVJsuRaplnutrxuhVo5WaVYVVpds0atna0l1rutu6cRp7lOk06rntZnw7Dxtsm2qbcZsOXYBtuutm22fWFnYhdnt8Wuw+6TvZN9un2N/T0HDYfZDqsdWh1+c7RyFDpWOt6azpzuP33F9JbpL2dYzxDP2DPjthPLKcRpnVOb00dnF2e5c4PziIuJS4LLLpc+Lpsbxt3IveRKdPVxXeF60vWdm7Obwu2o26/uNu5p7ofcn8w0nymeWTNz0MPIQ+BR5dE/C5+VMGvfrH5PQ0+BZ7XnIy9jL5FXrdewt6V3qvdh7xc+9j5yn+M+4zw33jLeWV/MN8C3yLfLT8Nvnl+F30N/I/9k/3r/0QCngCUBZwOJgUGBWwL7+Hp8Ib+OPzrbZfay2e1BjKC5QRVBj4KtguXBrSFoyOyQrSH355jOkc5pDoVQfujW0Adh5mGLw34MJ4WHhVeGP45wiFga0TGXNXfR3ENz30T6RJZE3ptnMU85ry1KNSo+qi5qPNo3ujS6P8YuZlnM1VidWElsSxw5LiquNm5svt/87fOH4p3iC+N7F5gvyF1weaHOwvSFpxapLhIsOpZATIhOOJTwQRAqqBaMJfITdyWOCnnCHcJnIi/RNtGI2ENcKh5O8kgqTXqS7JG8NXkkxTOlLOW5hCepkLxMDUzdmzqeFpp2IG0yPTq9MYOSkZBxQqohTZO2Z+pn5mZ2y6xlhbL+xW6Lty8elQfJa7OQrAVZLQq2QqboVFoo1yoHsmdlV2a/zYnKOZarnivN7cyzytuQN5zvn//tEsIS4ZK2pYZLVy0dWOa9rGo5sjxxedsK4xUFK4ZWBqw8uIq2Km3VT6vtV5eufr0mek1rgV7ByoLBtQFr6wtVCuWFfevc1+1dT1gvWd+1YfqGnRs+FYmKrhTbF5cVf9go3HjlG4dvyr+Z3JS0qavEuWTPZtJm6ebeLZ5bDpaql+aXDm4N2dq0Dd9WtO319kXbL5fNKNu7g7ZDuaO/PLi8ZafJzs07P1SkVPRU+lQ27tLdtWHX+G7R7ht7vPY07NXbW7z3/T7JvttVAVVN1WbVZftJ+7P3P66Jqun4lvttXa1ObXHtxwPSA/0HIw6217nU1R3SPVRSj9Yr60cOxx++/p3vdy0NNg1VjZzG4iNwRHnk6fcJ3/ceDTradox7rOEH0x92HWcdL2pCmvKaRptTmvtbYlu6T8w+0dbq3nr8R9sfD5w0PFl5SvNUyWna6YLTk2fyz4ydlZ19fi753GDborZ752PO32oPb++6EHTh0kX/i+c7vDvOXPK4dPKy2+UTV7hXmq86X23qdOo8/pPTT8e7nLuarrlca7nuer21e2b36RueN87d9L158Rb/1tWeOT3dvfN6b/fF9/XfFt1+cif9zsu72Xcn7q28T7xf9EDtQdlD3YfVP1v+3Njv3H9qwHeg89HcR/cGhYPP/pH1jw9DBY+Zj8uGDYbrnjg+OTniP3L96fynQ89kzyaeF/6i/suuFxYvfvjV69fO0ZjRoZfyl5O/bXyl/erA6xmv28bCxh6+yXgzMV70VvvtwXfcdx3vo98PT+R8IH8o/2j5sfVT0Kf7kxmTk/8EA5jz/GMzLdsAAEEOaVRYdFhNTDpjb20uYWRvYmUueG1wAAAAAAA8P3hwYWNrZXQgYmVnaW49Iu+7vyIgaWQ9Ilc1TTBNcENlaGlIenJlU3pOVGN6a2M5ZCI/Pgo8eDp4bXBtZXRhIHhtbG5zOng9ImFkb2JlOm5zOm1ldGEvIiB4OnhtcHRrPSJBZG9iZSBYTVAgQ29yZSA1LjUtYzAyMSA3OS4xNTQ5MTEsIDIwMTMvMTAvMjktMTE6NDc6MTYgICAgICAgICI+CiAgIDxyZGY6UkRGIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyI+CiAgICAgIDxyZGY6RGVzY3JpcHRpb24gcmRmOmFib3V0PSIiCiAgICAgICAgICAgIHhtbG5zOnhtcD0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLyIKICAgICAgICAgICAgeG1sbnM6ZGM9Imh0dHA6Ly9wdXJsLm9yZy9kYy9lbGVtZW50cy8xLjEvIgogICAgICAgICAgICB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIKICAgICAgICAgICAgeG1sbnM6c3RFdnQ9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZUV2ZW50IyIKICAgICAgICAgICAgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiCiAgICAgICAgICAgIHhtbG5zOnBob3Rvc2hvcD0iaHR0cDovL25zLmFkb2JlLmNvbS9waG90b3Nob3AvMS4wLyIKICAgICAgICAgICAgeG1sbnM6dGlmZj0iaHR0cDovL25zLmFkb2JlLmNvbS90aWZmLzEuMC8iCiAgICAgICAgICAgIHhtbG5zOmV4aWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20vZXhpZi8xLjAvIj4KICAgICAgICAgPHhtcDpDcmVhdG9yVG9vbD5BZG9iZSBQaG90b3Nob3AgQ0MgKFdpbmRvd3MpPC94bXA6Q3JlYXRvclRvb2w+CiAgICAgICAgIDx4bXA6Q3JlYXRlRGF0ZT4yMDE0LTAxLTIyVDE5OjI0OjUxKzAxOjAwPC94bXA6Q3JlYXRlRGF0ZT4KICAgICAgICAgPHhtcDpNZXRhZGF0YURhdGU+MjAxNC0wMi0wNVQxNDoxMjoyNSswMTowMDwveG1wOk1ldGFkYXRhRGF0ZT4KICAgICAgICAgPHhtcDpNb2RpZnlEYXRlPjIwMTQtMDItMDVUMTQ6MTI6MjUrMDE6MDA8L3htcDpNb2RpZnlEYXRlPgogICAgICAgICA8ZGM6Zm9ybWF0PmltYWdlL3BuZzwvZGM6Zm9ybWF0PgogICAgICAgICA8eG1wTU06SW5zdGFuY2VJRD54bXAuaWlkOjY5OTM3ZGZjLTJjNzQtYTU0YS05OTIzLTQyMmZhNDNkMjljNDwveG1wTU06SW5zdGFuY2VJRD4KICAgICAgICAgPHhtcE1NOkRvY3VtZW50SUQ+eG1wLmRpZDpFQTc2MkY5Njc0ODNFMzExOTQ4QkQxM0UyQkU3OTlBMTwveG1wTU06RG9jdW1lbnRJRD4KICAgICAgICAgPHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD54bXAuZGlkOjczQjYyQUFEOTE4M0UzMTE5NDhCRDEzRTJCRTc5OUExPC94bXBNTTpPcmlnaW5hbERvY3VtZW50SUQ+CiAgICAgICAgIDx4bXBNTTpIaXN0b3J5PgogICAgICAgICAgICA8cmRmOlNlcT4KICAgICAgICAgICAgICAgPHJkZjpsaSByZGY6cGFyc2VUeXBlPSJSZXNvdXJjZSI+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDphY3Rpb24+Y3JlYXRlZDwvc3RFdnQ6YWN0aW9uPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6aW5zdGFuY2VJRD54bXAuaWlkOjczQjYyQUFEOTE4M0UzMTE5NDhCRDEzRTJCRTc5OUExPC9zdEV2dDppbnN0YW5jZUlEPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6d2hlbj4yMDE0LTAxLTIyVDE5OjI0OjUxKzAxOjAwPC9zdEV2dDp3aGVuPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6c29mdHdhcmVBZ2VudD5BZG9iZSBQaG90b3Nob3AgQ1M2IChXaW5kb3dzKTwvc3RFdnQ6c29mdHdhcmVBZ2VudD4KICAgICAgICAgICAgICAgPC9yZGY6bGk+CiAgICAgICAgICAgICAgIDxyZGY6bGkgcmRmOnBhcnNlVHlwZT0iUmVzb3VyY2UiPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6YWN0aW9uPnNhdmVkPC9zdEV2dDphY3Rpb24+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDppbnN0YW5jZUlEPnhtcC5paWQ6RUE2MEEyNEUxOTg0RTMxMUFEQUZFRkU2RUMzMzNFMDM8L3N0RXZ0Omluc3RhbmNlSUQ+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDp3aGVuPjIwMTQtMDEtMjNUMTk6MTg6MDcrMDE6MDA8L3N0RXZ0OndoZW4+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDpzb2Z0d2FyZUFnZW50PkFkb2JlIFBob3Rvc2hvcCBDUzYgKFdpbmRvd3MpPC9zdEV2dDpzb2Z0d2FyZUFnZW50PgogICAgICAgICAgICAgICAgICA8c3RFdnQ6Y2hhbmdlZD4vPC9zdEV2dDpjaGFuZ2VkPgogICAgICAgICAgICAgICA8L3JkZjpsaT4KICAgICAgICAgICAgICAgPHJkZjpsaSByZGY6cGFyc2VUeXBlPSJSZXNvdXJjZSI+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDphY3Rpb24+c2F2ZWQ8L3N0RXZ0OmFjdGlvbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0Omluc3RhbmNlSUQ+eG1wLmlpZDozOWNhNzE5ZC03YzNlLTUyNGEtYmY1NS03NGVmMmM1MzE0YTc8L3N0RXZ0Omluc3RhbmNlSUQ+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDp3aGVuPjIwMTQtMDItMDVUMTQ6MTI6MjUrMDE6MDA8L3N0RXZ0OndoZW4+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDpzb2Z0d2FyZUFnZW50PkFkb2JlIFBob3Rvc2hvcCBDQyAoV2luZG93cyk8L3N0RXZ0OnNvZnR3YXJlQWdlbnQ+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDpjaGFuZ2VkPi88L3N0RXZ0OmNoYW5nZWQ+CiAgICAgICAgICAgICAgIDwvcmRmOmxpPgogICAgICAgICAgICAgICA8cmRmOmxpIHJkZjpwYXJzZVR5cGU9IlJlc291cmNlIj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OmFjdGlvbj5jb252ZXJ0ZWQ8L3N0RXZ0OmFjdGlvbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OnBhcmFtZXRlcnM+ZnJvbSBhcHBsaWNhdGlvbi92bmQuYWRvYmUucGhvdG9zaG9wIHRvIGltYWdlL3BuZzwvc3RFdnQ6cGFyYW1ldGVycz4KICAgICAgICAgICAgICAgPC9yZGY6bGk+CiAgICAgICAgICAgICAgIDxyZGY6bGkgcmRmOnBhcnNlVHlwZT0iUmVzb3VyY2UiPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6YWN0aW9uPmRlcml2ZWQ8L3N0RXZ0OmFjdGlvbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OnBhcmFtZXRlcnM+Y29udmVydGVkIGZyb20gYXBwbGljYXRpb24vdm5kLmFkb2JlLnBob3Rvc2hvcCB0byBpbWFnZS9wbmc8L3N0RXZ0OnBhcmFtZXRlcnM+CiAgICAgICAgICAgICAgIDwvcmRmOmxpPgogICAgICAgICAgICAgICA8cmRmOmxpIHJkZjpwYXJzZVR5cGU9IlJlc291cmNlIj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OmFjdGlvbj5zYXZlZDwvc3RFdnQ6YWN0aW9uPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6aW5zdGFuY2VJRD54bXAuaWlkOjY5OTM3ZGZjLTJjNzQtYTU0YS05OTIzLTQyMmZhNDNkMjljNDwvc3RFdnQ6aW5zdGFuY2VJRD4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OndoZW4+MjAxNC0wMi0wNVQxNDoxMjoyNSswMTowMDwvc3RFdnQ6d2hlbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OnNvZnR3YXJlQWdlbnQ+QWRvYmUgUGhvdG9zaG9wIENDIChXaW5kb3dzKTwvc3RFdnQ6c29mdHdhcmVBZ2VudD4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OmNoYW5nZWQ+Lzwvc3RFdnQ6Y2hhbmdlZD4KICAgICAgICAgICAgICAgPC9yZGY6bGk+CiAgICAgICAgICAgIDwvcmRmOlNlcT4KICAgICAgICAgPC94bXBNTTpIaXN0b3J5PgogICAgICAgICA8eG1wTU06RGVyaXZlZEZyb20gcmRmOnBhcnNlVHlwZT0iUmVzb3VyY2UiPgogICAgICAgICAgICA8c3RSZWY6aW5zdGFuY2VJRD54bXAuaWlkOjM5Y2E3MTlkLTdjM2UtNTI0YS1iZjU1LTc0ZWYyYzUzMTRhNzwvc3RSZWY6aW5zdGFuY2VJRD4KICAgICAgICAgICAgPHN0UmVmOmRvY3VtZW50SUQ+eG1wLmRpZDpFQTc2MkY5Njc0ODNFMzExOTQ4QkQxM0UyQkU3OTlBMTwvc3RSZWY6ZG9jdW1lbnRJRD4KICAgICAgICAgICAgPHN0UmVmOm9yaWdpbmFsRG9jdW1lbnRJRD54bXAuZGlkOjczQjYyQUFEOTE4M0UzMTE5NDhCRDEzRTJCRTc5OUExPC9zdFJlZjpvcmlnaW5hbERvY3VtZW50SUQ+CiAgICAgICAgIDwveG1wTU06RGVyaXZlZEZyb20+CiAgICAgICAgIDxwaG90b3Nob3A6Q29sb3JNb2RlPjM8L3Bob3Rvc2hvcDpDb2xvck1vZGU+CiAgICAgICAgIDxwaG90b3Nob3A6SUNDUHJvZmlsZT5zUkdCIElFQzYxOTY2LTIuMTwvcGhvdG9zaG9wOklDQ1Byb2ZpbGU+CiAgICAgICAgIDx0aWZmOk9yaWVudGF0aW9uPjE8L3RpZmY6T3JpZW50YXRpb24+CiAgICAgICAgIDx0aWZmOlhSZXNvbHV0aW9uPjcyMDA5MC8xMDAwMDwvdGlmZjpYUmVzb2x1dGlvbj4KICAgICAgICAgPHRpZmY6WVJlc29sdXRpb24+NzIwMDkwLzEwMDAwPC90aWZmOllSZXNvbHV0aW9uPgogICAgICAgICA8dGlmZjpSZXNvbHV0aW9uVW5pdD4yPC90aWZmOlJlc29sdXRpb25Vbml0PgogICAgICAgICA8ZXhpZjpDb2xvclNwYWNlPjE8L2V4aWY6Q29sb3JTcGFjZT4KICAgICAgICAgPGV4aWY6UGl4ZWxYRGltZW5zaW9uPjI0PC9leGlmOlBpeGVsWERpbWVuc2lvbj4KICAgICAgICAgPGV4aWY6UGl4ZWxZRGltZW5zaW9uPjI0PC9leGlmOlBpeGVsWURpbWVuc2lvbj4KICAgICAgPC9yZGY6RGVzY3JpcHRpb24+CiAgIDwvcmRmOlJERj4KPC94OnhtcG1ldGE+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgCjw/eHBhY2tldCBlbmQ9InciPz4ykninAAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAAYpSURBVHjafFZtTFvnFX7Oea+NudiY2Hwam4CBlgQwXdKREDKUoYg0jbRJ29RJ2VZ1mjRFUxSpA3VTfkzJfkQbS7spU6rtx5Z2UtppScjaHxvLuiatWi2jLEoMIUDCh23g2gbj7+tPuPvhOurawPl1dc99n+c55z33fV46ceIEZFkGADAziAgAQERoe/9ZK4GPM/AcgbsIXAcABCgMvkfAqAa89eDoJyF8LogIqqqChoaGYDAYHr8kItS8uc8iIH6iAa9IkAo5EAQX8pqmgUVBCBggYFgDhv0/GAsBgKZpICJkMhnQ4OAgZFkGEYGZUXmp+0cS+CKBwWA0DVRPOg5Zl2q6zaHyJlnVAMQXVTkwHrUqH0Xsvn+tdQAAMQDgpPLS2MViFY8rkGUZzIzaS/t/xqCzGggtz9e697zsnKhoLUtim4jOq/LE6x7X0nsh16dEZ5a/O3a2SCAOHjwInU6Hujd6ThJ4mCDQ+b2G232v7v6vwarPbQn8MGlMr+X0kpE3Wr5Zt5hL5HPhqYSdQIfKJ+yhxDPKWC6Xg+jt7UXD5b5KBt1kCHS85Ljd8/On3NupfnhFaZj4rWff1B98B1R/hnUmKd36bdtCNl4g0en4edNE/cXwLq8qMTMIPAQwmo/WuHvObA8+9c58k/dKtD0TyZWXN5YGA7ej7epKxspM//7SoNOdWc/Jyq2wiwhDzPxT8cP0jys3VMM7OmL0/77zn4Ydui3b8uiK0jD7RrA77c9Wd57cefPpF+2T6bWsFPWkaiPTCWvTsZpHFU+XrS+8G3AR08F6X+1FJvBxQQzHQOWk2SmrW4FPX/U2LVwPuDZj+fJKl2khPpeyAqA9rzR/YqwuiWXX8taN/CabGkrVuq9YJlkQQDjOAJ5jAhz9Vt9W4N5/rNp8I+vtMV/aZm4zLnUNNt0urdYnF68HWoJj4Wo1mLGUNRr8LEgDgNqeCh8xQIKOsgC7iAjVe83rT9zQa8uNM28u70kspessu8q8zq/V3NcZpVzb9+0zmVhOvvvrhaMVzrJg0zeq7xMVCCwdpnWSGBqjUyJwLTFgbvxie3w31uoWR1Y74r60rdxZqrR8q85t2W2MGCp12bm/KC3hyaSTiMhxuGrKcahqpbjOaDOoEhOEoFqJQCCJvqA85I6bfTdDjQlf2lbxVNlS6wt19yy7jRHZZlDnrinNj/6sHMhnNw2Ogco7O79e5fm/xQywRBBCEAuwn4gQ96bkYj4Vyuq9N1Z3Bj4Od5bs0MXt/dZZ21ctiqFan174q985P+Lfp+U1g7XDON/1ctP458WlVjLyJhOISZE0wM0S1QfuRC3lTjkJAKKEtNC9eIOhSh9xHLZOJRZTFuXDsEoStLkR/768ummsaJG9Pb9oe+9J+xaeSVokiQDSJphAo5uaBuWjiKP4QTqS1cUWU7ayesN66wu22frD1vmVW6GW6T8u9eVjGyZzs+w78Nqu0a2mbvVu1KEJQAgeZRL0liQYyx+GOmKeQpu0rMYsAJPNEFGD2dLodLIy6c9Ys7G8yeSUl3tf2/X3rcBVJSOv34l3sCBogi7z1LH/rBHjl4IJ93/ncQFAnjeImJD0Z8zuCwu9q3djDXqTlAKID5xv+9t2R8n8VcUFBljQ8Gyfe40BYBM4DwDLt8Kue79ZcFkbzfEdbUbv+oN4c9KTtsfm1MbYQqqh+2zrVZYKs/7Ef+byimt1POYiJhDhPBFBIiIEXhxfs7/dfYoIF+auBfYTE/pebx/V8hqBP2ODvD34yvuh/WCAmU75Bx6sIgaI/v5+6PV6JLqUsYr7dpDAoehs0h73pHTWrvKgThYbRSt9UmSjef3MpaUvBz4O72UmADgTOPJguGiZor+/HyUlJWBmJFz+D8xTtlUiOpbwpmrmrweeSXrT+g11k4SBN3RGKUcAVCVdFhyP1nreDbY//NPyEXUlU/Pp4XYycGT6V0Ux2WwWdO7cOZSWlkII8diX7SPPNgDaKdbxoNAxwATBAEkEEgSWCEQAqPAMwqvMdCEwMO0tVqZpWsGTT58+DaPR+PhGIYQAAAgh0P7B3ioW/B0iGiCGiwXbCuOHFSJys6AbYFye2T+xWhT3WYJEIoH/DQBMw3kes8OJPgAAAABJRU5ErkJggg==")}div.vis-network div.vis-edit-mode button.vis-button.vis-edit.vis-edit-mode{background-color:#fcfcfc;border:1px solid #ccc}div.vis-network div.vis-manipulation button.vis-button.vis-connect{background-image:url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAACXBIWXMAAAsTAAALEwEAmpwYAAAKT2lDQ1BQaG90b3Nob3AgSUNDIHByb2ZpbGUAAHjanVNnVFPpFj333vRCS4iAlEtvUhUIIFJCi4AUkSYqIQkQSoghodkVUcERRUUEG8igiAOOjoCMFVEsDIoK2AfkIaKOg6OIisr74Xuja9a89+bN/rXXPues852zzwfACAyWSDNRNYAMqUIeEeCDx8TG4eQuQIEKJHAAEAizZCFz/SMBAPh+PDwrIsAHvgABeNMLCADATZvAMByH/w/qQplcAYCEAcB0kThLCIAUAEB6jkKmAEBGAYCdmCZTAKAEAGDLY2LjAFAtAGAnf+bTAICd+Jl7AQBblCEVAaCRACATZYhEAGg7AKzPVopFAFgwABRmS8Q5ANgtADBJV2ZIALC3AMDOEAuyAAgMADBRiIUpAAR7AGDIIyN4AISZABRG8lc88SuuEOcqAAB4mbI8uSQ5RYFbCC1xB1dXLh4ozkkXKxQ2YQJhmkAuwnmZGTKBNA/g88wAAKCRFRHgg/P9eM4Ors7ONo62Dl8t6r8G/yJiYuP+5c+rcEAAAOF0ftH+LC+zGoA7BoBt/qIl7gRoXgugdfeLZrIPQLUAoOnaV/Nw+H48PEWhkLnZ2eXk5NhKxEJbYcpXff5nwl/AV/1s+X48/Pf14L7iJIEyXYFHBPjgwsz0TKUcz5IJhGLc5o9H/LcL//wd0yLESWK5WCoU41EScY5EmozzMqUiiUKSKcUl0v9k4t8s+wM+3zUAsGo+AXuRLahdYwP2SycQWHTA4vcAAPK7b8HUKAgDgGiD4c93/+8//UegJQCAZkmScQAAXkQkLlTKsz/HCAAARKCBKrBBG/TBGCzABhzBBdzBC/xgNoRCJMTCQhBCCmSAHHJgKayCQiiGzbAdKmAv1EAdNMBRaIaTcA4uwlW4Dj1wD/phCJ7BKLyBCQRByAgTYSHaiAFiilgjjggXmYX4IcFIBBKLJCDJiBRRIkuRNUgxUopUIFVIHfI9cgI5h1xGupE7yAAygvyGvEcxlIGyUT3UDLVDuag3GoRGogvQZHQxmo8WoJvQcrQaPYw2oefQq2gP2o8+Q8cwwOgYBzPEbDAuxsNCsTgsCZNjy7EirAyrxhqwVqwDu4n1Y8+xdwQSgUXACTYEd0IgYR5BSFhMWE7YSKggHCQ0EdoJNwkDhFHCJyKTqEu0JroR+cQYYjIxh1hILCPWEo8TLxB7iEPENyQSiUMyJ7mQAkmxpFTSEtJG0m5SI+ksqZs0SBojk8naZGuyBzmULCAryIXkneTD5DPkG+Qh8lsKnWJAcaT4U+IoUspqShnlEOU05QZlmDJBVaOaUt2ooVQRNY9aQq2htlKvUYeoEzR1mjnNgxZJS6WtopXTGmgXaPdpr+h0uhHdlR5Ol9BX0svpR+iX6AP0dwwNhhWDx4hnKBmbGAcYZxl3GK+YTKYZ04sZx1QwNzHrmOeZD5lvVVgqtip8FZHKCpVKlSaVGyovVKmqpqreqgtV81XLVI+pXlN9rkZVM1PjqQnUlqtVqp1Q61MbU2epO6iHqmeob1Q/pH5Z/YkGWcNMw09DpFGgsV/jvMYgC2MZs3gsIWsNq4Z1gTXEJrHN2Xx2KruY/R27iz2qqaE5QzNKM1ezUvOUZj8H45hx+Jx0TgnnKKeX836K3hTvKeIpG6Y0TLkxZVxrqpaXllirSKtRq0frvTau7aedpr1Fu1n7gQ5Bx0onXCdHZ4/OBZ3nU9lT3acKpxZNPTr1ri6qa6UbobtEd79up+6Ynr5egJ5Mb6feeb3n+hx9L/1U/W36p/VHDFgGswwkBtsMzhg8xTVxbzwdL8fb8VFDXcNAQ6VhlWGX4YSRudE8o9VGjUYPjGnGXOMk423GbcajJgYmISZLTepN7ppSTbmmKaY7TDtMx83MzaLN1pk1mz0x1zLnm+eb15vft2BaeFostqi2uGVJsuRaplnutrxuhVo5WaVYVVpds0atna0l1rutu6cRp7lOk06rntZnw7Dxtsm2qbcZsOXYBtuutm22fWFnYhdnt8Wuw+6TvZN9un2N/T0HDYfZDqsdWh1+c7RyFDpWOt6azpzuP33F9JbpL2dYzxDP2DPjthPLKcRpnVOb00dnF2e5c4PziIuJS4LLLpc+Lpsbxt3IveRKdPVxXeF60vWdm7Obwu2o26/uNu5p7ofcn8w0nymeWTNz0MPIQ+BR5dE/C5+VMGvfrH5PQ0+BZ7XnIy9jL5FXrdewt6V3qvdh7xc+9j5yn+M+4zw33jLeWV/MN8C3yLfLT8Nvnl+F30N/I/9k/3r/0QCngCUBZwOJgUGBWwL7+Hp8Ib+OPzrbZfay2e1BjKC5QRVBj4KtguXBrSFoyOyQrSH355jOkc5pDoVQfujW0Adh5mGLw34MJ4WHhVeGP45wiFga0TGXNXfR3ENz30T6RJZE3ptnMU85ry1KNSo+qi5qPNo3ujS6P8YuZlnM1VidWElsSxw5LiquNm5svt/87fOH4p3iC+N7F5gvyF1weaHOwvSFpxapLhIsOpZATIhOOJTwQRAqqBaMJfITdyWOCnnCHcJnIi/RNtGI2ENcKh5O8kgqTXqS7JG8NXkkxTOlLOW5hCepkLxMDUzdmzqeFpp2IG0yPTq9MYOSkZBxQqohTZO2Z+pn5mZ2y6xlhbL+xW6Lty8elQfJa7OQrAVZLQq2QqboVFoo1yoHsmdlV2a/zYnKOZarnivN7cyzytuQN5zvn//tEsIS4ZK2pYZLVy0dWOa9rGo5sjxxedsK4xUFK4ZWBqw8uIq2Km3VT6vtV5eufr0mek1rgV7ByoLBtQFr6wtVCuWFfevc1+1dT1gvWd+1YfqGnRs+FYmKrhTbF5cVf9go3HjlG4dvyr+Z3JS0qavEuWTPZtJm6ebeLZ5bDpaql+aXDm4N2dq0Dd9WtO319kXbL5fNKNu7g7ZDuaO/PLi8ZafJzs07P1SkVPRU+lQ27tLdtWHX+G7R7ht7vPY07NXbW7z3/T7JvttVAVVN1WbVZftJ+7P3P66Jqun4lvttXa1ObXHtxwPSA/0HIw6217nU1R3SPVRSj9Yr60cOxx++/p3vdy0NNg1VjZzG4iNwRHnk6fcJ3/ceDTradox7rOEH0x92HWcdL2pCmvKaRptTmvtbYlu6T8w+0dbq3nr8R9sfD5w0PFl5SvNUyWna6YLTk2fyz4ydlZ19fi753GDborZ752PO32oPb++6EHTh0kX/i+c7vDvOXPK4dPKy2+UTV7hXmq86X23qdOo8/pPTT8e7nLuarrlca7nuer21e2b36RueN87d9L158Rb/1tWeOT3dvfN6b/fF9/XfFt1+cif9zsu72Xcn7q28T7xf9EDtQdlD3YfVP1v+3Njv3H9qwHeg89HcR/cGhYPP/pH1jw9DBY+Zj8uGDYbrnjg+OTniP3L96fynQ89kzyaeF/6i/suuFxYvfvjV69fO0ZjRoZfyl5O/bXyl/erA6xmv28bCxh6+yXgzMV70VvvtwXfcdx3vo98PT+R8IH8o/2j5sfVT0Kf7kxmTk/8EA5jz/GMzLdsAAEEOaVRYdFhNTDpjb20uYWRvYmUueG1wAAAAAAA8P3hwYWNrZXQgYmVnaW49Iu+7vyIgaWQ9Ilc1TTBNcENlaGlIenJlU3pOVGN6a2M5ZCI/Pgo8eDp4bXBtZXRhIHhtbG5zOng9ImFkb2JlOm5zOm1ldGEvIiB4OnhtcHRrPSJBZG9iZSBYTVAgQ29yZSA1LjUtYzAyMSA3OS4xNTQ5MTEsIDIwMTMvMTAvMjktMTE6NDc6MTYgICAgICAgICI+CiAgIDxyZGY6UkRGIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyI+CiAgICAgIDxyZGY6RGVzY3JpcHRpb24gcmRmOmFib3V0PSIiCiAgICAgICAgICAgIHhtbG5zOnhtcD0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLyIKICAgICAgICAgICAgeG1sbnM6ZGM9Imh0dHA6Ly9wdXJsLm9yZy9kYy9lbGVtZW50cy8xLjEvIgogICAgICAgICAgICB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIKICAgICAgICAgICAgeG1sbnM6c3RFdnQ9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZUV2ZW50IyIKICAgICAgICAgICAgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiCiAgICAgICAgICAgIHhtbG5zOnBob3Rvc2hvcD0iaHR0cDovL25zLmFkb2JlLmNvbS9waG90b3Nob3AvMS4wLyIKICAgICAgICAgICAgeG1sbnM6dGlmZj0iaHR0cDovL25zLmFkb2JlLmNvbS90aWZmLzEuMC8iCiAgICAgICAgICAgIHhtbG5zOmV4aWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20vZXhpZi8xLjAvIj4KICAgICAgICAgPHhtcDpDcmVhdG9yVG9vbD5BZG9iZSBQaG90b3Nob3AgQ0MgKFdpbmRvd3MpPC94bXA6Q3JlYXRvclRvb2w+CiAgICAgICAgIDx4bXA6Q3JlYXRlRGF0ZT4yMDE0LTAxLTIyVDE5OjI0OjUxKzAxOjAwPC94bXA6Q3JlYXRlRGF0ZT4KICAgICAgICAgPHhtcDpNZXRhZGF0YURhdGU+MjAxNC0wMi0wNFQxNDozODo1NyswMTowMDwveG1wOk1ldGFkYXRhRGF0ZT4KICAgICAgICAgPHhtcDpNb2RpZnlEYXRlPjIwMTQtMDItMDRUMTQ6Mzg6NTcrMDE6MDA8L3htcDpNb2RpZnlEYXRlPgogICAgICAgICA8ZGM6Zm9ybWF0PmltYWdlL3BuZzwvZGM6Zm9ybWF0PgogICAgICAgICA8eG1wTU06SW5zdGFuY2VJRD54bXAuaWlkOjlmYjUwMDU0LWE3ODEtMWQ0OC05ZTllLTU2ZWQ5YzhlYjdjNjwveG1wTU06SW5zdGFuY2VJRD4KICAgICAgICAgPHhtcE1NOkRvY3VtZW50SUQ+eG1wLmRpZDpFQTc2MkY5Njc0ODNFMzExOTQ4QkQxM0UyQkU3OTlBMTwveG1wTU06RG9jdW1lbnRJRD4KICAgICAgICAgPHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD54bXAuZGlkOjczQjYyQUFEOTE4M0UzMTE5NDhCRDEzRTJCRTc5OUExPC94bXBNTTpPcmlnaW5hbERvY3VtZW50SUQ+CiAgICAgICAgIDx4bXBNTTpIaXN0b3J5PgogICAgICAgICAgICA8cmRmOlNlcT4KICAgICAgICAgICAgICAgPHJkZjpsaSByZGY6cGFyc2VUeXBlPSJSZXNvdXJjZSI+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDphY3Rpb24+Y3JlYXRlZDwvc3RFdnQ6YWN0aW9uPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6aW5zdGFuY2VJRD54bXAuaWlkOjczQjYyQUFEOTE4M0UzMTE5NDhCRDEzRTJCRTc5OUExPC9zdEV2dDppbnN0YW5jZUlEPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6d2hlbj4yMDE0LTAxLTIyVDE5OjI0OjUxKzAxOjAwPC9zdEV2dDp3aGVuPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6c29mdHdhcmVBZ2VudD5BZG9iZSBQaG90b3Nob3AgQ1M2IChXaW5kb3dzKTwvc3RFdnQ6c29mdHdhcmVBZ2VudD4KICAgICAgICAgICAgICAgPC9yZGY6bGk+CiAgICAgICAgICAgICAgIDxyZGY6bGkgcmRmOnBhcnNlVHlwZT0iUmVzb3VyY2UiPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6YWN0aW9uPnNhdmVkPC9zdEV2dDphY3Rpb24+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDppbnN0YW5jZUlEPnhtcC5paWQ6RUE2MEEyNEUxOTg0RTMxMUFEQUZFRkU2RUMzMzNFMDM8L3N0RXZ0Omluc3RhbmNlSUQ+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDp3aGVuPjIwMTQtMDEtMjNUMTk6MTg6MDcrMDE6MDA8L3N0RXZ0OndoZW4+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDpzb2Z0d2FyZUFnZW50PkFkb2JlIFBob3Rvc2hvcCBDUzYgKFdpbmRvd3MpPC9zdEV2dDpzb2Z0d2FyZUFnZW50PgogICAgICAgICAgICAgICAgICA8c3RFdnQ6Y2hhbmdlZD4vPC9zdEV2dDpjaGFuZ2VkPgogICAgICAgICAgICAgICA8L3JkZjpsaT4KICAgICAgICAgICAgICAgPHJkZjpsaSByZGY6cGFyc2VUeXBlPSJSZXNvdXJjZSI+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDphY3Rpb24+c2F2ZWQ8L3N0RXZ0OmFjdGlvbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0Omluc3RhbmNlSUQ+eG1wLmlpZDo3ZWRhMjI0MC0yYTQxLTNlNDQtYWM2My1iNzNiYTE5OWI3Y2E8L3N0RXZ0Omluc3RhbmNlSUQ+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDp3aGVuPjIwMTQtMDItMDRUMTQ6Mzg6NTcrMDE6MDA8L3N0RXZ0OndoZW4+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDpzb2Z0d2FyZUFnZW50PkFkb2JlIFBob3Rvc2hvcCBDQyAoV2luZG93cyk8L3N0RXZ0OnNvZnR3YXJlQWdlbnQ+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDpjaGFuZ2VkPi88L3N0RXZ0OmNoYW5nZWQ+CiAgICAgICAgICAgICAgIDwvcmRmOmxpPgogICAgICAgICAgICAgICA8cmRmOmxpIHJkZjpwYXJzZVR5cGU9IlJlc291cmNlIj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OmFjdGlvbj5jb252ZXJ0ZWQ8L3N0RXZ0OmFjdGlvbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OnBhcmFtZXRlcnM+ZnJvbSBhcHBsaWNhdGlvbi92bmQuYWRvYmUucGhvdG9zaG9wIHRvIGltYWdlL3BuZzwvc3RFdnQ6cGFyYW1ldGVycz4KICAgICAgICAgICAgICAgPC9yZGY6bGk+CiAgICAgICAgICAgICAgIDxyZGY6bGkgcmRmOnBhcnNlVHlwZT0iUmVzb3VyY2UiPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6YWN0aW9uPmRlcml2ZWQ8L3N0RXZ0OmFjdGlvbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OnBhcmFtZXRlcnM+Y29udmVydGVkIGZyb20gYXBwbGljYXRpb24vdm5kLmFkb2JlLnBob3Rvc2hvcCB0byBpbWFnZS9wbmc8L3N0RXZ0OnBhcmFtZXRlcnM+CiAgICAgICAgICAgICAgIDwvcmRmOmxpPgogICAgICAgICAgICAgICA8cmRmOmxpIHJkZjpwYXJzZVR5cGU9IlJlc291cmNlIj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OmFjdGlvbj5zYXZlZDwvc3RFdnQ6YWN0aW9uPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6aW5zdGFuY2VJRD54bXAuaWlkOjlmYjUwMDU0LWE3ODEtMWQ0OC05ZTllLTU2ZWQ5YzhlYjdjNjwvc3RFdnQ6aW5zdGFuY2VJRD4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OndoZW4+MjAxNC0wMi0wNFQxNDozODo1NyswMTowMDwvc3RFdnQ6d2hlbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OnNvZnR3YXJlQWdlbnQ+QWRvYmUgUGhvdG9zaG9wIENDIChXaW5kb3dzKTwvc3RFdnQ6c29mdHdhcmVBZ2VudD4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OmNoYW5nZWQ+Lzwvc3RFdnQ6Y2hhbmdlZD4KICAgICAgICAgICAgICAgPC9yZGY6bGk+CiAgICAgICAgICAgIDwvcmRmOlNlcT4KICAgICAgICAgPC94bXBNTTpIaXN0b3J5PgogICAgICAgICA8eG1wTU06RGVyaXZlZEZyb20gcmRmOnBhcnNlVHlwZT0iUmVzb3VyY2UiPgogICAgICAgICAgICA8c3RSZWY6aW5zdGFuY2VJRD54bXAuaWlkOjdlZGEyMjQwLTJhNDEtM2U0NC1hYzYzLWI3M2JhMTk5YjdjYTwvc3RSZWY6aW5zdGFuY2VJRD4KICAgICAgICAgICAgPHN0UmVmOmRvY3VtZW50SUQ+eG1wLmRpZDpFQTc2MkY5Njc0ODNFMzExOTQ4QkQxM0UyQkU3OTlBMTwvc3RSZWY6ZG9jdW1lbnRJRD4KICAgICAgICAgICAgPHN0UmVmOm9yaWdpbmFsRG9jdW1lbnRJRD54bXAuZGlkOjczQjYyQUFEOTE4M0UzMTE5NDhCRDEzRTJCRTc5OUExPC9zdFJlZjpvcmlnaW5hbERvY3VtZW50SUQ+CiAgICAgICAgIDwveG1wTU06RGVyaXZlZEZyb20+CiAgICAgICAgIDxwaG90b3Nob3A6Q29sb3JNb2RlPjM8L3Bob3Rvc2hvcDpDb2xvck1vZGU+CiAgICAgICAgIDxwaG90b3Nob3A6SUNDUHJvZmlsZT5zUkdCIElFQzYxOTY2LTIuMTwvcGhvdG9zaG9wOklDQ1Byb2ZpbGU+CiAgICAgICAgIDx0aWZmOk9yaWVudGF0aW9uPjE8L3RpZmY6T3JpZW50YXRpb24+CiAgICAgICAgIDx0aWZmOlhSZXNvbHV0aW9uPjcyMDA5MC8xMDAwMDwvdGlmZjpYUmVzb2x1dGlvbj4KICAgICAgICAgPHRpZmY6WVJlc29sdXRpb24+NzIwMDkwLzEwMDAwPC90aWZmOllSZXNvbHV0aW9uPgogICAgICAgICA8dGlmZjpSZXNvbHV0aW9uVW5pdD4yPC90aWZmOlJlc29sdXRpb25Vbml0PgogICAgICAgICA8ZXhpZjpDb2xvclNwYWNlPjE8L2V4aWY6Q29sb3JTcGFjZT4KICAgICAgICAgPGV4aWY6UGl4ZWxYRGltZW5zaW9uPjI0PC9leGlmOlBpeGVsWERpbWVuc2lvbj4KICAgICAgICAgPGV4aWY6UGl4ZWxZRGltZW5zaW9uPjI0PC9leGlmOlBpeGVsWURpbWVuc2lvbj4KICAgICAgPC9yZGY6RGVzY3JpcHRpb24+CiAgIDwvcmRmOlJERj4KPC94OnhtcG1ldGE+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgCjw/eHBhY2tldCBlbmQ9InciPz4ubxs+AAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAAUtSURBVHjajJZ/bNT1Gcdfz/P53PV6B4W7VltLqdAaplIOiMOoyxxJCSs/Gv/yB4gzJroAosmmDklwkYWR0bQsdmkykoojTpcsWYLxD/lRZdMQkTHRtkLZRqG0tIVe7662vTu43n32x/VKZ/jh89cn38/zvN7P5/l88zwf2blzJz6fDwARQUSm1n8s31CM0/VAnbNmsUPuAsDpgEO+Bg4C7//iyv5hvmMiQiqVQpqamvB6vVNwEeG1JZtCBrYi/MrkAwDNgjhwAlbzICBLA0rDb0+/839C6XQaaWxspLCw8Dp86cbNmqVFJQddE6KzdjZ9D89g+B6fSyCOcyn1nxil+O9xKg5HqWFSHGXLjrP7W/ICqVQK2bNnDz6fDxFh65KNvxbHDhF4rJj2bXPo+IGfcW5h5xL4f99P+FCEMIAob75x9t0dAMlkElNXV4e1lteXbNqiQoMaeOFOjrdU868SD2luYyEP6dUh+sYmSHeOU6GO5Z8VLx5+NNZxIpPJ5AS2L3upROCoCvz8Lo7vnkf77cAHhpiz/zIL9vWz8L8p/NvupmM0Q7pjnAoLqz8tDrc8MnQqYVUVhVdF4LEg7b+rvDn8wDDlH0WoPpukLJImSBaMwjcJqmwWts2jPZLG/8kwYVFeVdXXZcFf4yVDc2cNKfBFmD9X+0ncCP58F48eG+Feo2CAUkvs4dl0V/uJvdXLiiV+ut++n7YLSfxPfMMG54ChzB3WIesVWB2i82bw1AR6fJR7C4VsfYiv6u/k3A9nEgP4zXke8DiYHyAOMK+QxPIgnZ9GqSHr1itQJ8DK2fTerDQ+S/bHRXQJaHSCwNIZ2Xh+7+S3VAmwNMBA/tuPZtErgKquUmdMWIFlRURvdamRNEXGwIWrlP47pTMzLiunxghGMwTLvcTWlHAp77s4QNSrYMQtss6ZMgWqCm5cHoDHO1nbk6K8zEN8+3zatv2Hn1b59EqJZdxmYUERg9P9KwpIiAOTdWUWBXuLzB/vZG3P1Un4PNp2d1MbmyD45TWCxuCsQm0x56bHGHFYEZwxok7toAA9Sfw3hCcoL/NOwi9QO5wmWO1j4JEgZxTkodmcWRGkf3pcX0r8xoAaBixKu4U5/xwndM+0tpAvS6mP+PZK2nb1UBvPEKwKMLDvPj4ESGc55lGy303sdJKQdZB2rkMdctAB/4gzN+/Q2ENNd4LyUi/xN+bTtquX2thk5nk4wI3gAF+OMNcA1nFQDfK+BY5GqbkwWabTY5QZhXWlnNx1ntrY1Rz87fuvw29m/Sn8J+PUGAFj5T19baA1IspuBZp7cx1x4SwG1cEf+lgRSROs8jGwb+Ht4QB/GSSsAhYano39LWIBxNEIbP14hPDuiyS2VtJuHXQlKKvxM/jiXDq/D/xPlwifGMkJZB2NIoKpr69nxeiZxLHicFSFVWfGqBidIP3LSjrWltD94CyufF/4kQgPuVz2Lz93+dDRa9eu5QQ8Hg8/iXee+Dy4CKMs7xqn4nwKz9IirhQqmVuB42m8ey+x7LMoD6iAON782eChhqmRuXfvXgKBAKqKqtI0/8nNKrQI4BVYXkzHgzPpC88gWuHL/caXrhLoGiN0apSKr0ZZRBZM7q2w5ZnLR1oAnHOMjY0hra2tFBQUYIyZmstvVT1Z6eDlAuEVq7merxmwueNPDXy9PvybjKP5mctHLk4/XTKZRJqbm/H7/VNw1VyEMYbW4FN3WNWnnchKoy5sHeVGBRX6VWi3ymFx7r11Ix8MTX/y5C2RSPC/AQB61erowbpqSwAAAABJRU5ErkJggg==")}div.vis-network div.vis-manipulation button.vis-button.vis-delete{background-image:url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAACXBIWXMAAAsTAAALEwEAmpwYAAAKT2lDQ1BQaG90b3Nob3AgSUNDIHByb2ZpbGUAAHjanVNnVFPpFj333vRCS4iAlEtvUhUIIFJCi4AUkSYqIQkQSoghodkVUcERRUUEG8igiAOOjoCMFVEsDIoK2AfkIaKOg6OIisr74Xuja9a89+bN/rXXPues852zzwfACAyWSDNRNYAMqUIeEeCDx8TG4eQuQIEKJHAAEAizZCFz/SMBAPh+PDwrIsAHvgABeNMLCADATZvAMByH/w/qQplcAYCEAcB0kThLCIAUAEB6jkKmAEBGAYCdmCZTAKAEAGDLY2LjAFAtAGAnf+bTAICd+Jl7AQBblCEVAaCRACATZYhEAGg7AKzPVopFAFgwABRmS8Q5ANgtADBJV2ZIALC3AMDOEAuyAAgMADBRiIUpAAR7AGDIIyN4AISZABRG8lc88SuuEOcqAAB4mbI8uSQ5RYFbCC1xB1dXLh4ozkkXKxQ2YQJhmkAuwnmZGTKBNA/g88wAAKCRFRHgg/P9eM4Ors7ONo62Dl8t6r8G/yJiYuP+5c+rcEAAAOF0ftH+LC+zGoA7BoBt/qIl7gRoXgugdfeLZrIPQLUAoOnaV/Nw+H48PEWhkLnZ2eXk5NhKxEJbYcpXff5nwl/AV/1s+X48/Pf14L7iJIEyXYFHBPjgwsz0TKUcz5IJhGLc5o9H/LcL//wd0yLESWK5WCoU41EScY5EmozzMqUiiUKSKcUl0v9k4t8s+wM+3zUAsGo+AXuRLahdYwP2SycQWHTA4vcAAPK7b8HUKAgDgGiD4c93/+8//UegJQCAZkmScQAAXkQkLlTKsz/HCAAARKCBKrBBG/TBGCzABhzBBdzBC/xgNoRCJMTCQhBCCmSAHHJgKayCQiiGzbAdKmAv1EAdNMBRaIaTcA4uwlW4Dj1wD/phCJ7BKLyBCQRByAgTYSHaiAFiilgjjggXmYX4IcFIBBKLJCDJiBRRIkuRNUgxUopUIFVIHfI9cgI5h1xGupE7yAAygvyGvEcxlIGyUT3UDLVDuag3GoRGogvQZHQxmo8WoJvQcrQaPYw2oefQq2gP2o8+Q8cwwOgYBzPEbDAuxsNCsTgsCZNjy7EirAyrxhqwVqwDu4n1Y8+xdwQSgUXACTYEd0IgYR5BSFhMWE7YSKggHCQ0EdoJNwkDhFHCJyKTqEu0JroR+cQYYjIxh1hILCPWEo8TLxB7iEPENyQSiUMyJ7mQAkmxpFTSEtJG0m5SI+ksqZs0SBojk8naZGuyBzmULCAryIXkneTD5DPkG+Qh8lsKnWJAcaT4U+IoUspqShnlEOU05QZlmDJBVaOaUt2ooVQRNY9aQq2htlKvUYeoEzR1mjnNgxZJS6WtopXTGmgXaPdpr+h0uhHdlR5Ol9BX0svpR+iX6AP0dwwNhhWDx4hnKBmbGAcYZxl3GK+YTKYZ04sZx1QwNzHrmOeZD5lvVVgqtip8FZHKCpVKlSaVGyovVKmqpqreqgtV81XLVI+pXlN9rkZVM1PjqQnUlqtVqp1Q61MbU2epO6iHqmeob1Q/pH5Z/YkGWcNMw09DpFGgsV/jvMYgC2MZs3gsIWsNq4Z1gTXEJrHN2Xx2KruY/R27iz2qqaE5QzNKM1ezUvOUZj8H45hx+Jx0TgnnKKeX836K3hTvKeIpG6Y0TLkxZVxrqpaXllirSKtRq0frvTau7aedpr1Fu1n7gQ5Bx0onXCdHZ4/OBZ3nU9lT3acKpxZNPTr1ri6qa6UbobtEd79up+6Ynr5egJ5Mb6feeb3n+hx9L/1U/W36p/VHDFgGswwkBtsMzhg8xTVxbzwdL8fb8VFDXcNAQ6VhlWGX4YSRudE8o9VGjUYPjGnGXOMk423GbcajJgYmISZLTepN7ppSTbmmKaY7TDtMx83MzaLN1pk1mz0x1zLnm+eb15vft2BaeFostqi2uGVJsuRaplnutrxuhVo5WaVYVVpds0atna0l1rutu6cRp7lOk06rntZnw7Dxtsm2qbcZsOXYBtuutm22fWFnYhdnt8Wuw+6TvZN9un2N/T0HDYfZDqsdWh1+c7RyFDpWOt6azpzuP33F9JbpL2dYzxDP2DPjthPLKcRpnVOb00dnF2e5c4PziIuJS4LLLpc+Lpsbxt3IveRKdPVxXeF60vWdm7Obwu2o26/uNu5p7ofcn8w0nymeWTNz0MPIQ+BR5dE/C5+VMGvfrH5PQ0+BZ7XnIy9jL5FXrdewt6V3qvdh7xc+9j5yn+M+4zw33jLeWV/MN8C3yLfLT8Nvnl+F30N/I/9k/3r/0QCngCUBZwOJgUGBWwL7+Hp8Ib+OPzrbZfay2e1BjKC5QRVBj4KtguXBrSFoyOyQrSH355jOkc5pDoVQfujW0Adh5mGLw34MJ4WHhVeGP45wiFga0TGXNXfR3ENz30T6RJZE3ptnMU85ry1KNSo+qi5qPNo3ujS6P8YuZlnM1VidWElsSxw5LiquNm5svt/87fOH4p3iC+N7F5gvyF1weaHOwvSFpxapLhIsOpZATIhOOJTwQRAqqBaMJfITdyWOCnnCHcJnIi/RNtGI2ENcKh5O8kgqTXqS7JG8NXkkxTOlLOW5hCepkLxMDUzdmzqeFpp2IG0yPTq9MYOSkZBxQqohTZO2Z+pn5mZ2y6xlhbL+xW6Lty8elQfJa7OQrAVZLQq2QqboVFoo1yoHsmdlV2a/zYnKOZarnivN7cyzytuQN5zvn//tEsIS4ZK2pYZLVy0dWOa9rGo5sjxxedsK4xUFK4ZWBqw8uIq2Km3VT6vtV5eufr0mek1rgV7ByoLBtQFr6wtVCuWFfevc1+1dT1gvWd+1YfqGnRs+FYmKrhTbF5cVf9go3HjlG4dvyr+Z3JS0qavEuWTPZtJm6ebeLZ5bDpaql+aXDm4N2dq0Dd9WtO319kXbL5fNKNu7g7ZDuaO/PLi8ZafJzs07P1SkVPRU+lQ27tLdtWHX+G7R7ht7vPY07NXbW7z3/T7JvttVAVVN1WbVZftJ+7P3P66Jqun4lvttXa1ObXHtxwPSA/0HIw6217nU1R3SPVRSj9Yr60cOxx++/p3vdy0NNg1VjZzG4iNwRHnk6fcJ3/ceDTradox7rOEH0x92HWcdL2pCmvKaRptTmvtbYlu6T8w+0dbq3nr8R9sfD5w0PFl5SvNUyWna6YLTk2fyz4ydlZ19fi753GDborZ752PO32oPb++6EHTh0kX/i+c7vDvOXPK4dPKy2+UTV7hXmq86X23qdOo8/pPTT8e7nLuarrlca7nuer21e2b36RueN87d9L158Rb/1tWeOT3dvfN6b/fF9/XfFt1+cif9zsu72Xcn7q28T7xf9EDtQdlD3YfVP1v+3Njv3H9qwHeg89HcR/cGhYPP/pH1jw9DBY+Zj8uGDYbrnjg+OTniP3L96fynQ89kzyaeF/6i/suuFxYvfvjV69fO0ZjRoZfyl5O/bXyl/erA6xmv28bCxh6+yXgzMV70VvvtwXfcdx3vo98PT+R8IH8o/2j5sfVT0Kf7kxmTk/8EA5jz/GMzLdsAAEEOaVRYdFhNTDpjb20uYWRvYmUueG1wAAAAAAA8P3hwYWNrZXQgYmVnaW49Iu+7vyIgaWQ9Ilc1TTBNcENlaGlIenJlU3pOVGN6a2M5ZCI/Pgo8eDp4bXBtZXRhIHhtbG5zOng9ImFkb2JlOm5zOm1ldGEvIiB4OnhtcHRrPSJBZG9iZSBYTVAgQ29yZSA1LjUtYzAyMSA3OS4xNTQ5MTEsIDIwMTMvMTAvMjktMTE6NDc6MTYgICAgICAgICI+CiAgIDxyZGY6UkRGIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyI+CiAgICAgIDxyZGY6RGVzY3JpcHRpb24gcmRmOmFib3V0PSIiCiAgICAgICAgICAgIHhtbG5zOnhtcD0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLyIKICAgICAgICAgICAgeG1sbnM6ZGM9Imh0dHA6Ly9wdXJsLm9yZy9kYy9lbGVtZW50cy8xLjEvIgogICAgICAgICAgICB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIKICAgICAgICAgICAgeG1sbnM6c3RFdnQ9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZUV2ZW50IyIKICAgICAgICAgICAgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiCiAgICAgICAgICAgIHhtbG5zOnBob3Rvc2hvcD0iaHR0cDovL25zLmFkb2JlLmNvbS9waG90b3Nob3AvMS4wLyIKICAgICAgICAgICAgeG1sbnM6dGlmZj0iaHR0cDovL25zLmFkb2JlLmNvbS90aWZmLzEuMC8iCiAgICAgICAgICAgIHhtbG5zOmV4aWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20vZXhpZi8xLjAvIj4KICAgICAgICAgPHhtcDpDcmVhdG9yVG9vbD5BZG9iZSBQaG90b3Nob3AgQ0MgKFdpbmRvd3MpPC94bXA6Q3JlYXRvclRvb2w+CiAgICAgICAgIDx4bXA6Q3JlYXRlRGF0ZT4yMDE0LTAxLTIyVDE5OjI0OjUxKzAxOjAwPC94bXA6Q3JlYXRlRGF0ZT4KICAgICAgICAgPHhtcDpNZXRhZGF0YURhdGU+MjAxNC0wMi0wNFQxNDo0MTowNCswMTowMDwveG1wOk1ldGFkYXRhRGF0ZT4KICAgICAgICAgPHhtcDpNb2RpZnlEYXRlPjIwMTQtMDItMDRUMTQ6NDE6MDQrMDE6MDA8L3htcDpNb2RpZnlEYXRlPgogICAgICAgICA8ZGM6Zm9ybWF0PmltYWdlL3BuZzwvZGM6Zm9ybWF0PgogICAgICAgICA8eG1wTU06SW5zdGFuY2VJRD54bXAuaWlkOjc3NDkzYmUxLTEyZGItOTg0NC1iNDYyLTg2NGVmNGIzMzM3MTwveG1wTU06SW5zdGFuY2VJRD4KICAgICAgICAgPHhtcE1NOkRvY3VtZW50SUQ+eG1wLmRpZDpFQTc2MkY5Njc0ODNFMzExOTQ4QkQxM0UyQkU3OTlBMTwveG1wTU06RG9jdW1lbnRJRD4KICAgICAgICAgPHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD54bXAuZGlkOjczQjYyQUFEOTE4M0UzMTE5NDhCRDEzRTJCRTc5OUExPC94bXBNTTpPcmlnaW5hbERvY3VtZW50SUQ+CiAgICAgICAgIDx4bXBNTTpIaXN0b3J5PgogICAgICAgICAgICA8cmRmOlNlcT4KICAgICAgICAgICAgICAgPHJkZjpsaSByZGY6cGFyc2VUeXBlPSJSZXNvdXJjZSI+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDphY3Rpb24+Y3JlYXRlZDwvc3RFdnQ6YWN0aW9uPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6aW5zdGFuY2VJRD54bXAuaWlkOjczQjYyQUFEOTE4M0UzMTE5NDhCRDEzRTJCRTc5OUExPC9zdEV2dDppbnN0YW5jZUlEPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6d2hlbj4yMDE0LTAxLTIyVDE5OjI0OjUxKzAxOjAwPC9zdEV2dDp3aGVuPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6c29mdHdhcmVBZ2VudD5BZG9iZSBQaG90b3Nob3AgQ1M2IChXaW5kb3dzKTwvc3RFdnQ6c29mdHdhcmVBZ2VudD4KICAgICAgICAgICAgICAgPC9yZGY6bGk+CiAgICAgICAgICAgICAgIDxyZGY6bGkgcmRmOnBhcnNlVHlwZT0iUmVzb3VyY2UiPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6YWN0aW9uPnNhdmVkPC9zdEV2dDphY3Rpb24+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDppbnN0YW5jZUlEPnhtcC5paWQ6RUE2MEEyNEUxOTg0RTMxMUFEQUZFRkU2RUMzMzNFMDM8L3N0RXZ0Omluc3RhbmNlSUQ+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDp3aGVuPjIwMTQtMDEtMjNUMTk6MTg6MDcrMDE6MDA8L3N0RXZ0OndoZW4+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDpzb2Z0d2FyZUFnZW50PkFkb2JlIFBob3Rvc2hvcCBDUzYgKFdpbmRvd3MpPC9zdEV2dDpzb2Z0d2FyZUFnZW50PgogICAgICAgICAgICAgICAgICA8c3RFdnQ6Y2hhbmdlZD4vPC9zdEV2dDpjaGFuZ2VkPgogICAgICAgICAgICAgICA8L3JkZjpsaT4KICAgICAgICAgICAgICAgPHJkZjpsaSByZGY6cGFyc2VUeXBlPSJSZXNvdXJjZSI+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDphY3Rpb24+c2F2ZWQ8L3N0RXZ0OmFjdGlvbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0Omluc3RhbmNlSUQ+eG1wLmlpZDowNmE3NWYwMy04MDdhLWUzNGYtYjk1Zi1jZGU2MjM0Mzg4OGY8L3N0RXZ0Omluc3RhbmNlSUQ+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDp3aGVuPjIwMTQtMDItMDRUMTQ6NDE6MDQrMDE6MDA8L3N0RXZ0OndoZW4+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDpzb2Z0d2FyZUFnZW50PkFkb2JlIFBob3Rvc2hvcCBDQyAoV2luZG93cyk8L3N0RXZ0OnNvZnR3YXJlQWdlbnQ+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDpjaGFuZ2VkPi88L3N0RXZ0OmNoYW5nZWQ+CiAgICAgICAgICAgICAgIDwvcmRmOmxpPgogICAgICAgICAgICAgICA8cmRmOmxpIHJkZjpwYXJzZVR5cGU9IlJlc291cmNlIj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OmFjdGlvbj5jb252ZXJ0ZWQ8L3N0RXZ0OmFjdGlvbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OnBhcmFtZXRlcnM+ZnJvbSBhcHBsaWNhdGlvbi92bmQuYWRvYmUucGhvdG9zaG9wIHRvIGltYWdlL3BuZzwvc3RFdnQ6cGFyYW1ldGVycz4KICAgICAgICAgICAgICAgPC9yZGY6bGk+CiAgICAgICAgICAgICAgIDxyZGY6bGkgcmRmOnBhcnNlVHlwZT0iUmVzb3VyY2UiPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6YWN0aW9uPmRlcml2ZWQ8L3N0RXZ0OmFjdGlvbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OnBhcmFtZXRlcnM+Y29udmVydGVkIGZyb20gYXBwbGljYXRpb24vdm5kLmFkb2JlLnBob3Rvc2hvcCB0byBpbWFnZS9wbmc8L3N0RXZ0OnBhcmFtZXRlcnM+CiAgICAgICAgICAgICAgIDwvcmRmOmxpPgogICAgICAgICAgICAgICA8cmRmOmxpIHJkZjpwYXJzZVR5cGU9IlJlc291cmNlIj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OmFjdGlvbj5zYXZlZDwvc3RFdnQ6YWN0aW9uPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6aW5zdGFuY2VJRD54bXAuaWlkOjc3NDkzYmUxLTEyZGItOTg0NC1iNDYyLTg2NGVmNGIzMzM3MTwvc3RFdnQ6aW5zdGFuY2VJRD4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OndoZW4+MjAxNC0wMi0wNFQxNDo0MTowNCswMTowMDwvc3RFdnQ6d2hlbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OnNvZnR3YXJlQWdlbnQ+QWRvYmUgUGhvdG9zaG9wIENDIChXaW5kb3dzKTwvc3RFdnQ6c29mdHdhcmVBZ2VudD4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OmNoYW5nZWQ+Lzwvc3RFdnQ6Y2hhbmdlZD4KICAgICAgICAgICAgICAgPC9yZGY6bGk+CiAgICAgICAgICAgIDwvcmRmOlNlcT4KICAgICAgICAgPC94bXBNTTpIaXN0b3J5PgogICAgICAgICA8eG1wTU06RGVyaXZlZEZyb20gcmRmOnBhcnNlVHlwZT0iUmVzb3VyY2UiPgogICAgICAgICAgICA8c3RSZWY6aW5zdGFuY2VJRD54bXAuaWlkOjA2YTc1ZjAzLTgwN2EtZTM0Zi1iOTVmLWNkZTYyMzQzODg4Zjwvc3RSZWY6aW5zdGFuY2VJRD4KICAgICAgICAgICAgPHN0UmVmOmRvY3VtZW50SUQ+eG1wLmRpZDpFQTc2MkY5Njc0ODNFMzExOTQ4QkQxM0UyQkU3OTlBMTwvc3RSZWY6ZG9jdW1lbnRJRD4KICAgICAgICAgICAgPHN0UmVmOm9yaWdpbmFsRG9jdW1lbnRJRD54bXAuZGlkOjczQjYyQUFEOTE4M0UzMTE5NDhCRDEzRTJCRTc5OUExPC9zdFJlZjpvcmlnaW5hbERvY3VtZW50SUQ+CiAgICAgICAgIDwveG1wTU06RGVyaXZlZEZyb20+CiAgICAgICAgIDxwaG90b3Nob3A6Q29sb3JNb2RlPjM8L3Bob3Rvc2hvcDpDb2xvck1vZGU+CiAgICAgICAgIDxwaG90b3Nob3A6SUNDUHJvZmlsZT5zUkdCIElFQzYxOTY2LTIuMTwvcGhvdG9zaG9wOklDQ1Byb2ZpbGU+CiAgICAgICAgIDx0aWZmOk9yaWVudGF0aW9uPjE8L3RpZmY6T3JpZW50YXRpb24+CiAgICAgICAgIDx0aWZmOlhSZXNvbHV0aW9uPjcyMDA5MC8xMDAwMDwvdGlmZjpYUmVzb2x1dGlvbj4KICAgICAgICAgPHRpZmY6WVJlc29sdXRpb24+NzIwMDkwLzEwMDAwPC90aWZmOllSZXNvbHV0aW9uPgogICAgICAgICA8dGlmZjpSZXNvbHV0aW9uVW5pdD4yPC90aWZmOlJlc29sdXRpb25Vbml0PgogICAgICAgICA8ZXhpZjpDb2xvclNwYWNlPjE8L2V4aWY6Q29sb3JTcGFjZT4KICAgICAgICAgPGV4aWY6UGl4ZWxYRGltZW5zaW9uPjI0PC9leGlmOlBpeGVsWERpbWVuc2lvbj4KICAgICAgICAgPGV4aWY6UGl4ZWxZRGltZW5zaW9uPjI0PC9leGlmOlBpeGVsWURpbWVuc2lvbj4KICAgICAgPC9yZGY6RGVzY3JpcHRpb24+CiAgIDwvcmRmOlJERj4KPC94OnhtcG1ldGE+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgCjw/eHBhY2tldCBlbmQ9InciPz4aYJzYAAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAAYGSURBVHjalJZ7UJTnFcZ/73m/72PdJY1RbhoQp6lkXRAvmIYxdCUadLVOozPNtGObap1JsKipjiShbdoRbeKEiQHpQK3xj0xa03aamTbaTGyAYV1QGeqFi+JyiZFLAlmESBkWRmS3fyzslGkmnZ5/v/M873Oe75zzvqqoqAibzQaAiKCUAkApRdHIK/NFsx2NR91nOSILADDoJyzNaM4xxbtvPHh0iC+JiYkJ1OHDh4mJiUEpFSXPv/ziPC28TIiXDCOSrAClQDSEpsCwJPIhrEBRQpiSytXlQwDhcBilFPfu3UMVFxdjt9ujFTzfcLBADCoEEAFr1ZbrrNjch2vtEImPBgHob7fTcWE+bVXJNJ/NiFQlEGLvieXHKmYqGB8fRx05cgSbzYaIsPvywV8pKFaA7fGtLTzz61YWpo/xVTHQbufsq5lcez9zWuWhk5mvFwMEg0H0+vXrMU2Tn1wp3CtCiQ5DjGd3A/m/v8IDCZP8r4iNmyRrWx/j/5qktykZpXKzAjVDVxPzGqemptDr1q1jX3NRnIJarcDKK2hgR2ULXRfncv7UYv7xpovhnhiW5Mz+kefeSKO6LJ1A1xzEuk/Ojm4mRibpuZaMZW3OCtRUND60NmiICCIUShisx7a2sLMiQn4s77uEQgIabnqdfHIlgT1/qQeg8vs5dHhdCNB1wYn3RIiC995j26stjAbsNH+YiZJCESnS1Y/XxIXu8r4YIPv/VkVs3CTnTy2ms34xro1+sp9po6sxlTu34ultmsPVvy6is86FCHgO+DDs49zpjufBpCG+seYOC9OHaTidieicb9ouVAhKtouAseI710ma7pLuqwmgYfHqAFt+6WdLoQ/LBl11Lm7VudAa8vb72PCin9TlAWIsGGhLACD+kSAZnusYBii1XQAPYWDllt6ov2lrBkDBR2+6Ofuak2//3M+G/T4wAAPW7fPhKfRTVeqk9qQbFKRmDUTxS3N7QYGYmwzCkqklBGlPDEcTNv+sg9tNCbTXuvBWujE0bHrZj9JE1B/wU1Pm5PwJN6YBS9a2kVvQEcWnrh5GTFD3lxkYkqRMgYQlwVldUvDnen73LHTUuqitdKM0eAr9AFQfd1J/yo2aJn+2sn4Wdn5qEFODJskgBIjx5T0uCrQA08pnIjS9PERDjPnfOKXAMEBECUoGEIHBj+2zkt76UQ6dXheGAev3+cg74Kf6uJPqcicbfuond7cPy4SOiy7+tD9nFvZurx00KOk3CNEC+mE+vjSPBc7IWqgqTaPT60IMcO/xsXGa3HfKjRgRdbl7/KDg0jtubje6aHj7c7J3dgLQ2zoPwwQ91SooOQdAW1VKVMHty0kA5Bb48BycJn/LjWFGbLv4thvvb53kFvjJ+XEdWkPfjQVR/CcNKYgGMc8JWt5Fa2j+MIPPuyI2pa4IoHSkt6vLIuRaQ9q32khzt4GCxtNu6k46GeiIR2lIfDQQsafPzq1LGRGL9Gk9d+vrwewvfHPQOoexQVjxdB/auk/zmaUMdsfz6bVUtIalT7bxveP1ZHh6GPDPYeSzeD69kcpIfxymFWLNrka+ljhBTWkWwz2JiJT84YHnz2iPx0P20PkmRF5i6HYiwZFJsn/YzdezbzE3cQibY5xV266z6RfXohakb+xB9CjanCD9qTbW7Grk4WV38VZm0l6dhQiEw9taHSuDqrS0FIfDwXM3X9mHMsvRAk/sauDpQy38P+GtzOTGB9mEpkD0C2dS8n8zOjqK9ng8WJZFU+JTjasGvaCNXPpvJBPoMlm0OoDNMfWVxONfWNSUPUZ7TUQ56tCZlPwSgMnJSVRpaSmxsbFE1raw82ZxAZZRQUiBYUKGp5UlOX2krBzmoUVjiIKhHge9rfPo+Wcy3ZeXIYASgL1/X5RfMXMvj46OosrLy7HZbGitUUohIuzoem0RofALaOsghgWGjky0MiJTL8b0lOvI8hN1DKXKP0jd3TNTWDgcJhgMoo4ePYrD4Yi+KmaeLlprnrtXFo9h/AAlG1AqE8yFmBrC+jO0bgH9EVpO/1F2Dc5g//OAsbEx/j0Af+USsQynL1UAAAAASUVORK5CYII=")}div.vis-network div.vis-edit-mode div.vis-label,div.vis-network div.vis-manipulation div.vis-label{line-height:25px;margin:0 0 0 23px}div.vis-network div.vis-manipulation div.vis-separator-line{background-color:#bdbdbd;display:inline-block;float:left;height:21px;margin:0 7px 0 15px;width:1px}</style>
            <script>/**
 * vis-network
 * https://visjs.github.io/vis-network/
 *
 * A dynamic, browser-based visualization library.
 *
 * @version 9.1.2
 * @date    2022-03-28T20:17:35.342Z
 *
 * @copyright (c) 2011-2017 Almende B.V, http://almende.com
 * @copyright (c) 2017-2019 visjs contributors, https://github.com/visjs
 *
 * @license
 * vis.js is dual licensed under both
 *
 *   1. The Apache 2.0 License
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *   and
 *
 *   2. The MIT License
 *      http://opensource.org/licenses/MIT
 *
 * vis.js may be distributed under either license.
 */
!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?e(exports):"function"==typeof define&&define.amd?define(["exports"],e):e((t="undefined"!=typeof globalThis?globalThis:t||self).vis=t.vis||{})}(this,(function(t){"use strict";var e="undefined"!=typeof globalThis?globalThis:"undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:{},i=function(t){return t&&t.Math==Math&&t},n=i("object"==typeof globalThis&&globalThis)||i("object"==typeof window&&window)||i("object"==typeof self&&self)||i("object"==typeof e&&e)||function(){return this}()||Function("return this")(),o=function(t){try{return!!t()}catch(t){return!0}},r=!o((function(){var t=function(){}.bind();return"function"!=typeof t||t.hasOwnProperty("prototype")})),s=r,a=Function.prototype,h=a.apply,l=a.call,d="object"==typeof Reflect&&Reflect.apply||(s?l.bind(h):function(){return l.apply(h,arguments)}),c=r,u=Function.prototype,f=u.bind,p=u.call,v=c&&f.bind(p,p),g=c?function(t){return t&&v(t)}:function(t){return t&&function(){return p.apply(t,arguments)}},y=function(t){return"function"==typeof t},m={},b=!o((function(){return 7!=Object.defineProperty({},1,{get:function(){return 7}})[1]})),w=r,k=Function.prototype.call,_=w?k.bind(k):function(){return k.apply(k,arguments)},x={},E={}.propertyIsEnumerable,O=Object.getOwnPropertyDescriptor,C=O&&!E.call({1:2},1);x.f=C?function(t){var e=O(this,t);return!!e&&e.enumerable}:E;var S,T,M=function(t,e){return{enumerable:!(1&t),configurable:!(2&t),writable:!(4&t),value:e}},P=g,D=P({}.toString),I=P("".slice),B=function(t){return I(D(t),8,-1)},z=g,N=o,F=B,A=n.Object,j=z("".split),R=N((function(){return!A("z").propertyIsEnumerable(0)}))?function(t){return"String"==F(t)?j(t,""):A(t)}:A,L=n.TypeError,H=function(t){if(null==t)throw L("Can't call method on "+t);return t},W=R,q=H,V=function(t){return W(q(t))},U=y,Y=function(t){return"object"==typeof t?null!==t:U(t)},X={},G=X,K=n,$=y,Z=function(t){return $(t)?t:void 0},Q=function(t,e){return arguments.length<2?Z(G[t])||Z(K[t]):G[t]&&G[t][e]||K[t]&&K[t][e]},J=g({}.isPrototypeOf),tt=Q("navigator","userAgent")||"",et=n,it=tt,nt=et.process,ot=et.Deno,rt=nt&&nt.versions||ot&&ot.version,st=rt&&rt.v8;st&&(T=(S=st.split("."))[0]>0&&S[0]<4?1:+(S[0]+S[1])),!T&&it&&(!(S=it.match(/Edge\/(\d+)/))||S[1]>=74)&&(S=it.match(/Chrome\/(\d+)/))&&(T=+S[1]);var at=T,ht=at,lt=o,dt=!!Object.getOwnPropertySymbols&&!lt((function(){var t=Symbol();return!String(t)||!(Object(t)instanceof Symbol)||!Symbol.sham&&ht&&ht<41})),ct=dt&&!Symbol.sham&&"symbol"==typeof Symbol.iterator,ut=Q,ft=y,pt=J,vt=ct,gt=n.Object,yt=vt?function(t){return"symbol"==typeof t}:function(t){var e=ut("Symbol");return ft(e)&&pt(e.prototype,gt(t))},mt=n.String,bt=function(t){try{return mt(t)}catch(t){return"Object"}},wt=y,kt=bt,_t=n.TypeError,xt=function(t){if(wt(t))return t;throw _t(kt(t)+" is not a function")},Et=xt,Ot=function(t,e){var i=t[e];return null==i?void 0:Et(i)},Ct=_,St=y,Tt=Y,Mt=n.TypeError,Pt={exports:{}},Dt=n,It=Object.defineProperty,Bt=function(t,e){try{It(Dt,t,{value:e,configurable:!0,writable:!0})}catch(i){Dt[t]=e}return e},zt="__core-js_shared__",Nt=n[zt]||Bt(zt,{}),Ft=Nt;(Pt.exports=function(t,e){return Ft[t]||(Ft[t]=void 0!==e?e:{})})("versions",[]).push({version:"3.21.1",mode:"pure",copyright:"© 2014-2022 Denis Pushkarev (zloirock.ru)",license:"https://github.com/zloirock/core-js/blob/v3.21.1/LICENSE",source:"https://github.com/zloirock/core-js"});var At=H,jt=n.Object,Rt=function(t){return jt(At(t))},Lt=Rt,Ht=g({}.hasOwnProperty),Wt=Object.hasOwn||function(t,e){return Ht(Lt(t),e)},qt=g,Vt=0,Ut=Math.random(),Yt=qt(1..toString),Xt=function(t){return"Symbol("+(void 0===t?"":t)+")_"+Yt(++Vt+Ut,36)},Gt=n,Kt=Pt.exports,$t=Wt,Zt=Xt,Qt=dt,Jt=ct,te=Kt("wks"),ee=Gt.Symbol,ie=ee&&ee.for,ne=Jt?ee:ee&&ee.withoutSetter||Zt,oe=function(t){if(!$t(te,t)||!Qt&&"string"!=typeof te[t]){var e="Symbol."+t;Qt&&$t(ee,t)?te[t]=ee[t]:te[t]=Jt&&ie?ie(e):ne(e)}return te[t]},re=_,se=Y,ae=yt,he=Ot,le=function(t,e){var i,n;if("string"===e&&St(i=t.toString)&&!Tt(n=Ct(i,t)))return n;if(St(i=t.valueOf)&&!Tt(n=Ct(i,t)))return n;if("string"!==e&&St(i=t.toString)&&!Tt(n=Ct(i,t)))return n;throw Mt("Can't convert object to primitive value")},de=oe,ce=n.TypeError,ue=de("toPrimitive"),fe=function(t,e){if(!se(t)||ae(t))return t;var i,n=he(t,ue);if(n){if(void 0===e&&(e="default"),i=re(n,t,e),!se(i)||ae(i))return i;throw ce("Can't convert object to primitive value")}return void 0===e&&(e="number"),le(t,e)},pe=yt,ve=function(t){var e=fe(t,"string");return pe(e)?e:e+""},ge=Y,ye=n.document,me=ge(ye)&&ge(ye.createElement),be=function(t){return me?ye.createElement(t):{}},we=be,ke=!b&&!o((function(){return 7!=Object.defineProperty(we("div"),"a",{get:function(){return 7}}).a})),_e=b,xe=_,Ee=x,Oe=M,Ce=V,Se=ve,Te=Wt,Me=ke,Pe=Object.getOwnPropertyDescriptor;m.f=_e?Pe:function(t,e){if(t=Ce(t),e=Se(e),Me)try{return Pe(t,e)}catch(t){}if(Te(t,e))return Oe(!xe(Ee.f,t,e),t[e])};var De=o,Ie=y,Be=/#|\.prototype\./,ze=function(t,e){var i=Fe[Ne(t)];return i==je||i!=Ae&&(Ie(e)?De(e):!!e)},Ne=ze.normalize=function(t){return String(t).replace(Be,".").toLowerCase()},Fe=ze.data={},Ae=ze.NATIVE="N",je=ze.POLYFILL="P",Re=ze,Le=xt,He=r,We=g(g.bind),qe=function(t,e){return Le(t),void 0===e?t:He?We(t,e):function(){return t.apply(e,arguments)}},Ve={},Ue=b&&o((function(){return 42!=Object.defineProperty((function(){}),"prototype",{value:42,writable:!1}).prototype})),Ye=n,Xe=Y,Ge=Ye.String,Ke=Ye.TypeError,$e=function(t){if(Xe(t))return t;throw Ke(Ge(t)+" is not an object")},Ze=b,Qe=ke,Je=Ue,ti=$e,ei=ve,ii=n.TypeError,ni=Object.defineProperty,oi=Object.getOwnPropertyDescriptor,ri="enumerable",si="configurable",ai="writable";Ve.f=Ze?Je?function(t,e,i){if(ti(t),e=ei(e),ti(i),"function"==typeof t&&"prototype"===e&&"value"in i&&ai in i&&!i.writable){var n=oi(t,e);n&&n.writable&&(t[e]=i.value,i={configurable:si in i?i.configurable:n.configurable,enumerable:ri in i?i.enumerable:n.enumerable,writable:!1})}return ni(t,e,i)}:ni:function(t,e,i){if(ti(t),e=ei(e),ti(i),Qe)try{return ni(t,e,i)}catch(t){}if("get"in i||"set"in i)throw ii("Accessors not supported");return"value"in i&&(t[e]=i.value),t};var hi=Ve,li=M,di=b?function(t,e,i){return hi.f(t,e,li(1,i))}:function(t,e,i){return t[e]=i,t},ci=n,ui=d,fi=g,pi=y,vi=m.f,gi=Re,yi=X,mi=qe,bi=di,wi=Wt,ki=function(t){var e=function(i,n,o){if(this instanceof e){switch(arguments.length){case 0:return new t;case 1:return new t(i);case 2:return new t(i,n)}return new t(i,n,o)}return ui(t,this,arguments)};return e.prototype=t.prototype,e},_i=function(t,e){var i,n,o,r,s,a,h,l,d=t.target,c=t.global,u=t.stat,f=t.proto,p=c?ci:u?ci[d]:(ci[d]||{}).prototype,v=c?yi:yi[d]||bi(yi,d,{})[d],g=v.prototype;for(o in e)i=!gi(c?o:d+(u?".":"#")+o,t.forced)&&p&&wi(p,o),s=v[o],i&&(a=t.noTargetGet?(l=vi(p,o))&&l.value:p[o]),r=i&&a?a:e[o],i&&typeof s==typeof r||(h=t.bind&&i?mi(r,ci):t.wrap&&i?ki(r):f&&pi(r)?fi(r):r,(t.sham||r&&r.sham||s&&s.sham)&&bi(h,"sham",!0),bi(v,o,h),f&&(wi(yi,n=d+"Prototype")||bi(yi,n,{}),bi(yi[n],o,r),t.real&&g&&!g[o]&&bi(g,o,r)))},xi=Math.ceil,Ei=Math.floor,Oi=function(t){var e=+t;return e!=e||0===e?0:(e>0?Ei:xi)(e)},Ci=Oi,Si=Math.max,Ti=Math.min,Mi=function(t,e){var i=Ci(t);return i<0?Si(i+e,0):Ti(i,e)},Pi=Oi,Di=Math.min,Ii=function(t){return t>0?Di(Pi(t),9007199254740991):0},Bi=function(t){return Ii(t.length)},zi=V,Ni=Mi,Fi=Bi,Ai=function(t){return function(e,i,n){var o,r=zi(e),s=Fi(r),a=Ni(n,s);if(t&&i!=i){for(;s>a;)if((o=r[a++])!=o)return!0}else for(;s>a;a++)if((t||a in r)&&r[a]===i)return t||a||0;return!t&&-1}},ji={includes:Ai(!0),indexOf:Ai(!1)},Ri={},Li=Wt,Hi=V,Wi=ji.indexOf,qi=Ri,Vi=g([].push),Ui=function(t,e){var i,n=Hi(t),o=0,r=[];for(i in n)!Li(qi,i)&&Li(n,i)&&Vi(r,i);for(;e.length>o;)Li(n,i=e[o++])&&(~Wi(r,i)||Vi(r,i));return r},Yi=["constructor","hasOwnProperty","isPrototypeOf","propertyIsEnumerable","toLocaleString","toString","valueOf"],Xi=Ui,Gi=Yi,Ki=Object.keys||function(t){return Xi(t,Gi)},$i={};$i.f=Object.getOwnPropertySymbols;var Zi=b,Qi=g,Ji=_,tn=o,en=Ki,nn=$i,on=x,rn=Rt,sn=R,an=Object.assign,hn=Object.defineProperty,ln=Qi([].concat),dn=!an||tn((function(){if(Zi&&1!==an({b:1},an(hn({},"a",{enumerable:!0,get:function(){hn(this,"b",{value:3,enumerable:!1})}}),{b:2})).b)return!0;var t={},e={},i=Symbol(),n="abcdefghijklmnopqrst";return t[i]=7,n.split("").forEach((function(t){e[t]=t})),7!=an({},t)[i]||en(an({},e)).join("")!=n}))?function(t,e){for(var i=rn(t),n=arguments.length,o=1,r=nn.f,s=on.f;n>o;)for(var a,h=sn(arguments[o++]),l=r?ln(en(h),r(h)):en(h),d=l.length,c=0;d>c;)a=l[c++],Zi&&!Ji(s,h,a)||(i[a]=h[a]);return i}:an,cn=dn;_i({target:"Object",stat:!0,forced:Object.assign!==cn},{assign:cn});var un=X.Object.assign,fn=g([].slice),pn=g,vn=xt,gn=Y,yn=Wt,mn=fn,bn=r,wn=n.Function,kn=pn([].concat),_n=pn([].join),xn={},En=function(t,e,i){if(!yn(xn,e)){for(var n=[],o=0;o<e;o++)n[o]="a["+o+"]";xn[e]=wn("C,a","return new C("+_n(n,",")+")")}return xn[e](t,i)},On=bn?wn.bind:function(t){var e=vn(this),i=e.prototype,n=mn(arguments,1),o=function(){var i=kn(n,mn(arguments));return this instanceof o?En(e,i.length,i):e.apply(t,i)};return gn(i)&&(o.prototype=i),o},Cn=On;_i({target:"Function",proto:!0,forced:Function.bind!==Cn},{bind:Cn});var Sn=X,Tn=function(t){return Sn[t+"Prototype"]},Mn=Tn("Function").bind,Pn=J,Dn=Mn,In=Function.prototype,Bn=function(t){var e=t.bind;return t===In||Pn(In,t)&&e===In.bind?Dn:e},zn=Bn;function Nn(t,e,i,n){t.beginPath(),t.arc(e,i,n,0,2*Math.PI,!1),t.closePath()}function Fn(t,e,i,n,o,r){var s=Math.PI/180;n-2*r<0&&(r=n/2),o-2*r<0&&(r=o/2),t.beginPath(),t.moveTo(e+r,i),t.lineTo(e+n-r,i),t.arc(e+n-r,i+r,r,270*s,360*s,!1),t.lineTo(e+n,i+o-r),t.arc(e+n-r,i+o-r,r,0,90*s,!1),t.lineTo(e+r,i+o),t.arc(e+r,i+o-r,r,90*s,180*s,!1),t.lineTo(e,i+r),t.arc(e+r,i+r,r,180*s,270*s,!1),t.closePath()}function An(t,e,i,n,o){var r=.5522848,s=n/2*r,a=o/2*r,h=e+n,l=i+o,d=e+n/2,c=i+o/2;t.beginPath(),t.moveTo(e,c),t.bezierCurveTo(e,c-a,d-s,i,d,i),t.bezierCurveTo(d+s,i,h,c-a,h,c),t.bezierCurveTo(h,c+a,d+s,l,d,l),t.bezierCurveTo(d-s,l,e,c+a,e,c),t.closePath()}function jn(t,e,i,n,o){var r=o*(1/3),s=.5522848,a=n/2*s,h=r/2*s,l=e+n,d=i+r,c=e+n/2,u=i+r/2,f=i+(o-r/2),p=i+o;t.beginPath(),t.moveTo(l,u),t.bezierCurveTo(l,u+h,c+a,d,c,d),t.bezierCurveTo(c-a,d,e,u+h,e,u),t.bezierCurveTo(e,u-h,c-a,i,c,i),t.bezierCurveTo(c+a,i,l,u-h,l,u),t.lineTo(l,f),t.bezierCurveTo(l,f+h,c+a,p,c,p),t.bezierCurveTo(c-a,p,e,f+h,e,f),t.lineTo(e,u)}function Rn(t,e,i,n,o,r){t.beginPath(),t.moveTo(e,i);for(var s=r.length,a=n-e,h=o-i,l=h/a,d=Math.sqrt(a*a+h*h),c=0,u=!0,f=0,p=+r[0];d>=.1;)(p=+r[c++%s])>d&&(p=d),f=Math.sqrt(p*p/(1+l*l)),e+=f=a<0?-f:f,i+=l*f,!0===u?t.lineTo(e,i):t.moveTo(e,i),d-=p,u=!u}var Ln={circle:Nn,dashedLine:Rn,database:jn,diamond:function(t,e,i,n){t.beginPath(),t.lineTo(e,i+n),t.lineTo(e+n,i),t.lineTo(e,i-n),t.lineTo(e-n,i),t.closePath()},ellipse:An,ellipse_vis:An,hexagon:function(t,e,i,n){t.beginPath();var o=2*Math.PI/6;t.moveTo(e+n,i);for(var r=1;r<6;r++)t.lineTo(e+n*Math.cos(o*r),i+n*Math.sin(o*r));t.closePath()},roundRect:Fn,square:function(t,e,i,n){t.beginPath(),t.rect(e-n,i-n,2*n,2*n),t.closePath()},star:function(t,e,i,n){t.beginPath(),i+=.1*(n*=.82);for(var o=0;o<10;o++){var r=o%2==0?1.3*n:.5*n;t.lineTo(e+r*Math.sin(2*o*Math.PI/10),i-r*Math.cos(2*o*Math.PI/10))}t.closePath()},triangle:function(t,e,i,n){t.beginPath(),i+=.275*(n*=1.15);var o=2*n,r=o/2,s=Math.sqrt(3)/6*o,a=Math.sqrt(o*o-r*r);t.moveTo(e,i-(a-s)),t.lineTo(e+r,i+s),t.lineTo(e-r,i+s),t.lineTo(e,i-(a-s)),t.closePath()},triangleDown:function(t,e,i,n){t.beginPath(),i-=.275*(n*=1.15);var o=2*n,r=o/2,s=Math.sqrt(3)/6*o,a=Math.sqrt(o*o-r*r);t.moveTo(e,i+(a-s)),t.lineTo(e+r,i-s),t.lineTo(e-r,i-s),t.lineTo(e,i+(a-s)),t.closePath()}};var Hn={exports:{}};!function(t){function e(t){if(t)return function(t){for(var i in e.prototype)t[i]=e.prototype[i];return t}(t)}t.exports=e,e.prototype.on=e.prototype.addEventListener=function(t,e){return this._callbacks=this._callbacks||{},(this._callbacks["$"+t]=this._callbacks["$"+t]||[]).push(e),this},e.prototype.once=function(t,e){function i(){this.off(t,i),e.apply(this,arguments)}return i.fn=e,this.on(t,i),this},e.prototype.off=e.prototype.removeListener=e.prototype.removeAllListeners=e.prototype.removeEventListener=function(t,e){if(this._callbacks=this._callbacks||{},0==arguments.length)return this._callbacks={},this;var i,n=this._callbacks["$"+t];if(!n)return this;if(1==arguments.length)return delete this._callbacks["$"+t],this;for(var o=0;o<n.length;o++)if((i=n[o])===e||i.fn===e){n.splice(o,1);break}return 0===n.length&&delete this._callbacks["$"+t],this},e.prototype.emit=function(t){this._callbacks=this._callbacks||{};for(var e=new Array(arguments.length-1),i=this._callbacks["$"+t],n=1;n<arguments.length;n++)e[n-1]=arguments[n];if(i){n=0;for(var o=(i=i.slice(0)).length;n<o;++n)i[n].apply(this,e)}return this},e.prototype.listeners=function(t){return this._callbacks=this._callbacks||{},this._callbacks["$"+t]||[]},e.prototype.hasListeners=function(t){return!!this.listeners(t).length}}(Hn);var Wn=Hn.exports,qn={};qn[oe("toStringTag")]="z";var Vn="[object z]"===String(qn),Un=n,Yn=Vn,Xn=y,Gn=B,Kn=oe("toStringTag"),$n=Un.Object,Zn="Arguments"==Gn(function(){return arguments}()),Qn=Yn?Gn:function(t){var e,i,n;return void 0===t?"Undefined":null===t?"Null":"string"==typeof(i=function(t,e){try{return t[e]}catch(t){}}(e=$n(t),Kn))?i:Zn?Gn(e):"Object"==(n=Gn(e))&&Xn(e.callee)?"Arguments":n},Jn=Qn,to=n.String,eo=function(t){if("Symbol"===Jn(t))throw TypeError("Cannot convert a Symbol value to a string");return to(t)},io=g,no=Oi,oo=eo,ro=H,so=io("".charAt),ao=io("".charCodeAt),ho=io("".slice),lo=function(t){return function(e,i){var n,o,r=oo(ro(e)),s=no(i),a=r.length;return s<0||s>=a?t?"":void 0:(n=ao(r,s))<55296||n>56319||s+1===a||(o=ao(r,s+1))<56320||o>57343?t?so(r,s):n:t?ho(r,s,s+2):o-56320+(n-55296<<10)+65536}},co={codeAt:lo(!1),charAt:lo(!0)},uo=y,fo=Nt,po=g(Function.toString);uo(fo.inspectSource)||(fo.inspectSource=function(t){return po(t)});var vo,go,yo,mo=fo.inspectSource,bo=y,wo=mo,ko=n.WeakMap,_o=bo(ko)&&/native code/.test(wo(ko)),xo=Pt.exports,Eo=Xt,Oo=xo("keys"),Co=function(t){return Oo[t]||(Oo[t]=Eo(t))},So=_o,To=n,Mo=g,Po=Y,Do=di,Io=Wt,Bo=Nt,zo=Co,No=Ri,Fo="Object already initialized",Ao=To.TypeError,jo=To.WeakMap;if(So||Bo.state){var Ro=Bo.state||(Bo.state=new jo),Lo=Mo(Ro.get),Ho=Mo(Ro.has),Wo=Mo(Ro.set);vo=function(t,e){if(Ho(Ro,t))throw new Ao(Fo);return e.facade=t,Wo(Ro,t,e),e},go=function(t){return Lo(Ro,t)||{}},yo=function(t){return Ho(Ro,t)}}else{var qo=zo("state");No[qo]=!0,vo=function(t,e){if(Io(t,qo))throw new Ao(Fo);return e.facade=t,Do(t,qo,e),e},go=function(t){return Io(t,qo)?t[qo]:{}},yo=function(t){return Io(t,qo)}}var Vo={set:vo,get:go,has:yo,enforce:function(t){return yo(t)?go(t):vo(t,{})},getterFor:function(t){return function(e){var i;if(!Po(e)||(i=go(e)).type!==t)throw Ao("Incompatible receiver, "+t+" required");return i}}},Uo=b,Yo=Wt,Xo=Function.prototype,Go=Uo&&Object.getOwnPropertyDescriptor,Ko=Yo(Xo,"name"),$o={EXISTS:Ko,PROPER:Ko&&"something"===function(){}.name,CONFIGURABLE:Ko&&(!Uo||Uo&&Go(Xo,"name").configurable)},Zo={},Qo=b,Jo=Ue,tr=Ve,er=$e,ir=V,nr=Ki;Zo.f=Qo&&!Jo?Object.defineProperties:function(t,e){er(t);for(var i,n=ir(e),o=nr(e),r=o.length,s=0;r>s;)tr.f(t,i=o[s++],n[i]);return t};var or,rr=Q("document","documentElement"),sr=$e,ar=Zo,hr=Yi,lr=Ri,dr=rr,cr=be,ur=Co("IE_PROTO"),fr=function(){},pr=function(t){return"<script>"+t+"</"+"script>"},vr=function(t){t.write(pr("")),t.close();var e=t.parentWindow.Object;return t=null,e},gr=function(){try{or=new ActiveXObject("htmlfile")}catch(t){}var t,e;gr="undefined"!=typeof document?document.domain&&or?vr(or):((e=cr("iframe")).style.display="none",dr.appendChild(e),e.src=String("javascript:"),(t=e.contentWindow.document).open(),t.write(pr("document.F=Object")),t.close(),t.F):vr(or);for(var i=hr.length;i--;)delete gr.prototype[hr[i]];return gr()};lr[ur]=!0;var yr,mr,br,wr=Object.create||function(t,e){var i;return null!==t?(fr.prototype=sr(t),i=new fr,fr.prototype=null,i[ur]=t):i=gr(),void 0===e?i:ar.f(i,e)},kr=!o((function(){function t(){}return t.prototype.constructor=null,Object.getPrototypeOf(new t)!==t.prototype})),_r=n,xr=Wt,Er=y,Or=Rt,Cr=kr,Sr=Co("IE_PROTO"),Tr=_r.Object,Mr=Tr.prototype,Pr=Cr?Tr.getPrototypeOf:function(t){var e=Or(t);if(xr(e,Sr))return e[Sr];var i=e.constructor;return Er(i)&&e instanceof i?i.prototype:e instanceof Tr?Mr:null},Dr=di,Ir=function(t,e,i,n){n&&n.enumerable?t[e]=i:Dr(t,e,i)},Br=o,zr=y,Nr=wr,Fr=Pr,Ar=Ir,jr=oe("iterator"),Rr=!1;[].keys&&("next"in(br=[].keys())?(mr=Fr(Fr(br)))!==Object.prototype&&(yr=mr):Rr=!0);var Lr=null==yr||Br((function(){var t={};return yr[jr].call(t)!==t}));zr((yr=Lr?{}:Nr(yr))[jr])||Ar(yr,jr,(function(){return this}));var Hr={IteratorPrototype:yr,BUGGY_SAFARI_ITERATORS:Rr},Wr=Qn,qr=Vn?{}.toString:function(){return"[object "+Wr(this)+"]"},Vr=Vn,Ur=Ve.f,Yr=di,Xr=Wt,Gr=qr,Kr=oe("toStringTag"),$r=function(t,e,i,n){if(t){var o=i?t:t.prototype;Xr(o,Kr)||Ur(o,Kr,{configurable:!0,value:e}),n&&!Vr&&Yr(o,"toString",Gr)}},Zr={},Qr=Hr.IteratorPrototype,Jr=wr,ts=M,es=$r,is=Zr,ns=function(){return this},os=n,rs=y,ss=os.String,as=os.TypeError,hs=g,ls=$e,ds=function(t){if("object"==typeof t||rs(t))return t;throw as("Can't set "+ss(t)+" as a prototype")},cs=Object.setPrototypeOf||("__proto__"in{}?function(){var t,e=!1,i={};try{(t=hs(Object.getOwnPropertyDescriptor(Object.prototype,"__proto__").set))(i,[]),e=i instanceof Array}catch(t){}return function(i,n){return ls(i),ds(n),e?t(i,n):i.__proto__=n,i}}():void 0),us=_i,fs=_,ps=function(t,e,i,n){var o=e+" Iterator";return t.prototype=Jr(Qr,{next:ts(+!n,i)}),es(t,o,!1,!0),is[o]=ns,t},vs=Pr,gs=$r,ys=Ir,ms=Zr,bs=$o.PROPER,ws=Hr.BUGGY_SAFARI_ITERATORS,ks=oe("iterator"),_s="keys",xs="values",Es="entries",Os=function(){return this},Cs=function(t,e,i,n,o,r,s){ps(i,e,n);var a,h,l,d=function(t){if(t===o&&v)return v;if(!ws&&t in f)return f[t];switch(t){case _s:case xs:case Es:return function(){return new i(this,t)}}return function(){return new i(this)}},c=e+" Iterator",u=!1,f=t.prototype,p=f[ks]||f["@@iterator"]||o&&f[o],v=!ws&&p||d(o),g="Array"==e&&f.entries||p;if(g&&(a=vs(g.call(new t)))!==Object.prototype&&a.next&&(gs(a,c,!0,!0),ms[c]=Os),bs&&o==xs&&p&&p.name!==xs&&(u=!0,v=function(){return fs(p,this)}),o)if(h={values:d(xs),keys:r?v:d(_s),entries:d(Es)},s)for(l in h)(ws||u||!(l in f))&&ys(f,l,h[l]);else us({target:e,proto:!0,forced:ws||u},h);return s&&f[ks]!==v&&ys(f,ks,v,{name:o}),ms[e]=v,h},Ss=co.charAt,Ts=eo,Ms=Vo,Ps=Cs,Ds="String Iterator",Is=Ms.set,Bs=Ms.getterFor(Ds);Ps(String,"String",(function(t){Is(this,{type:Ds,string:Ts(t),index:0})}),(function(){var t,e=Bs(this),i=e.string,n=e.index;return n>=i.length?{value:void 0,done:!0}:(t=Ss(i,n),e.index+=t.length,{value:t,done:!1})}));var zs=_,Ns=$e,Fs=Ot,As=function(t,e,i){var n,o;Ns(t);try{if(!(n=Fs(t,"return"))){if("throw"===e)throw i;return i}n=zs(n,t)}catch(t){o=!0,n=t}if("throw"===e)throw i;if(o)throw n;return Ns(n),i},js=$e,Rs=As,Ls=Zr,Hs=oe("iterator"),Ws=Array.prototype,qs=function(t){return void 0!==t&&(Ls.Array===t||Ws[Hs]===t)},Vs=g,Us=o,Ys=y,Xs=Qn,Gs=mo,Ks=function(){},$s=[],Zs=Q("Reflect","construct"),Qs=/^\s*(?:class|function)\b/,Js=Vs(Qs.exec),ta=!Qs.exec(Ks),ea=function(t){if(!Ys(t))return!1;try{return Zs(Ks,$s,t),!0}catch(t){return!1}},ia=function(t){if(!Ys(t))return!1;switch(Xs(t)){case"AsyncFunction":case"GeneratorFunction":case"AsyncGeneratorFunction":return!1}try{return ta||!!Js(Qs,Gs(t))}catch(t){return!0}};ia.sham=!0;var na=!Zs||Us((function(){var t;return ea(ea.call)||!ea(Object)||!ea((function(){t=!0}))||t}))?ia:ea,oa=ve,ra=Ve,sa=M,aa=function(t,e,i){var n=oa(e);n in t?ra.f(t,n,sa(0,i)):t[n]=i},ha=Qn,la=Ot,da=Zr,ca=oe("iterator"),ua=function(t){if(null!=t)return la(t,ca)||la(t,"@@iterator")||da[ha(t)]},fa=_,pa=xt,va=$e,ga=bt,ya=ua,ma=n.TypeError,ba=function(t,e){var i=arguments.length<2?ya(t):e;if(pa(i))return va(fa(i,t));throw ma(ga(t)+" is not iterable")},wa=qe,ka=_,_a=Rt,xa=function(t,e,i,n){try{return n?e(js(i)[0],i[1]):e(i)}catch(e){Rs(t,"throw",e)}},Ea=qs,Oa=na,Ca=Bi,Sa=aa,Ta=ba,Ma=ua,Pa=n.Array,Da=oe("iterator"),Ia=!1;try{var Ba=0,za={next:function(){return{done:!!Ba++}},return:function(){Ia=!0}};za[Da]=function(){return this},Array.from(za,(function(){throw 2}))}catch(t){}var Na=function(t){var e=_a(t),i=Oa(this),n=arguments.length,o=n>1?arguments[1]:void 0,r=void 0!==o;r&&(o=wa(o,n>2?arguments[2]:void 0));var s,a,h,l,d,c,u=Ma(e),f=0;if(!u||this==Pa&&Ea(u))for(s=Ca(e),a=i?new this(s):Pa(s);s>f;f++)c=r?o(e[f],f):e[f],Sa(a,f,c);else for(d=(l=Ta(e,u)).next,a=i?new this:[];!(h=ka(d,l)).done;f++)c=r?xa(l,o,[h.value,f],!0):h.value,Sa(a,f,c);return a.length=f,a},Fa=function(t,e){if(!e&&!Ia)return!1;var i=!1;try{var n={};n[Da]=function(){return{next:function(){return{done:i=!0}}}},t(n)}catch(t){}return i};_i({target:"Array",stat:!0,forced:!Fa((function(t){Array.from(t)}))},{from:Na});var Aa=X.Array.from,ja=Aa,Ra=V,La=Zr,Ha=Vo;Ve.f;var Wa=Cs,qa="Array Iterator",Va=Ha.set,Ua=Ha.getterFor(qa);Wa(Array,"Array",(function(t,e){Va(this,{type:qa,target:Ra(t),index:0,kind:e})}),(function(){var t=Ua(this),e=t.target,i=t.kind,n=t.index++;return!e||n>=e.length?(t.target=void 0,{value:void 0,done:!0}):"keys"==i?{value:n,done:!1}:"values"==i?{value:e[n],done:!1}:{value:[n,e[n]],done:!1}}),"values"),La.Arguments=La.Array;var Ya=ua,Xa={CSSRuleList:0,CSSStyleDeclaration:0,CSSValueList:0,ClientRectList:0,DOMRectList:0,DOMStringList:0,DOMTokenList:1,DataTransferItemList:0,FileList:0,HTMLAllCollection:0,HTMLCollection:0,HTMLFormElement:0,HTMLSelectElement:0,MediaList:0,MimeTypeArray:0,NamedNodeMap:0,NodeList:1,PaintRequestList:0,Plugin:0,PluginArray:0,SVGLengthList:0,SVGNumberList:0,SVGPathSegList:0,SVGPointList:0,SVGStringList:0,SVGTransformList:0,SourceBufferList:0,StyleSheetList:0,TextTrackCueList:0,TextTrackList:0,TouchList:0},Ga=n,Ka=Qn,$a=di,Za=Zr,Qa=oe("toStringTag");for(var Ja in Xa){var th=Ga[Ja],eh=th&&th.prototype;eh&&Ka(eh)!==Qa&&$a(eh,Qa,Ja),Za[Ja]=Za.Array}var ih=Ya,nh=B,oh=Array.isArray||function(t){return"Array"==nh(t)},rh={},sh=Ui,ah=Yi.concat("length","prototype");rh.f=Object.getOwnPropertyNames||function(t){return sh(t,ah)};var hh={},lh=Mi,dh=Bi,ch=aa,uh=n.Array,fh=Math.max,ph=function(t,e,i){for(var n=dh(t),o=lh(e,n),r=lh(void 0===i?n:i,n),s=uh(fh(r-o,0)),a=0;o<r;o++,a++)ch(s,a,t[o]);return s.length=a,s},vh=B,gh=V,yh=rh.f,mh=ph,bh="object"==typeof window&&window&&Object.getOwnPropertyNames?Object.getOwnPropertyNames(window):[];hh.f=function(t){return bh&&"Window"==vh(t)?function(t){try{return yh(t)}catch(t){return mh(bh)}}(t):yh(gh(t))};var wh={},kh=oe;wh.f=kh;var _h=X,xh=Wt,Eh=wh,Oh=Ve.f,Ch=function(t){var e=_h.Symbol||(_h.Symbol={});xh(e,t)||Oh(e,t,{value:Eh.f(t)})},Sh=n,Th=oh,Mh=na,Ph=Y,Dh=oe("species"),Ih=Sh.Array,Bh=function(t){var e;return Th(t)&&(e=t.constructor,(Mh(e)&&(e===Ih||Th(e.prototype))||Ph(e)&&null===(e=e[Dh]))&&(e=void 0)),void 0===e?Ih:e},zh=function(t,e){return new(Bh(t))(0===e?0:e)},Nh=qe,Fh=R,Ah=Rt,jh=Bi,Rh=zh,Lh=g([].push),Hh=function(t){var e=1==t,i=2==t,n=3==t,o=4==t,r=6==t,s=7==t,a=5==t||r;return function(h,l,d,c){for(var u,f,p=Ah(h),v=Fh(p),g=Nh(l,d),y=jh(v),m=0,b=c||Rh,w=e?b(h,y):i||s?b(h,0):void 0;y>m;m++)if((a||m in v)&&(f=g(u=v[m],m,p),t))if(e)w[m]=f;else if(f)switch(t){case 3:return!0;case 5:return u;case 6:return m;case 2:Lh(w,u)}else switch(t){case 4:return!1;case 7:Lh(w,u)}return r?-1:n||o?o:w}},Wh={forEach:Hh(0),map:Hh(1),filter:Hh(2),some:Hh(3),every:Hh(4),find:Hh(5),findIndex:Hh(6),filterReject:Hh(7)},qh=_i,Vh=n,Uh=Q,Yh=d,Xh=_,Gh=g,Kh=b,$h=dt,Zh=o,Qh=Wt,Jh=oh,tl=y,el=Y,il=J,nl=yt,ol=$e,rl=Rt,sl=V,al=ve,hl=eo,ll=M,dl=wr,cl=Ki,ul=rh,fl=hh,pl=$i,vl=m,gl=Ve,yl=Zo,ml=x,bl=fn,wl=Ir,kl=Pt.exports,_l=Ri,xl=Xt,El=oe,Ol=wh,Cl=Ch,Sl=$r,Tl=Vo,Ml=Wh.forEach,Pl=Co("hidden"),Dl="Symbol",Il=El("toPrimitive"),Bl=Tl.set,zl=Tl.getterFor(Dl),Nl=Object.prototype,Fl=Vh.Symbol,Al=Fl&&Fl.prototype,jl=Vh.TypeError,Rl=Vh.QObject,Ll=Uh("JSON","stringify"),Hl=vl.f,Wl=gl.f,ql=fl.f,Vl=ml.f,Ul=Gh([].push),Yl=kl("symbols"),Xl=kl("op-symbols"),Gl=kl("string-to-symbol-registry"),Kl=kl("symbol-to-string-registry"),$l=kl("wks"),Zl=!Rl||!Rl.prototype||!Rl.prototype.findChild,Ql=Kh&&Zh((function(){return 7!=dl(Wl({},"a",{get:function(){return Wl(this,"a",{value:7}).a}})).a}))?function(t,e,i){var n=Hl(Nl,e);n&&delete Nl[e],Wl(t,e,i),n&&t!==Nl&&Wl(Nl,e,n)}:Wl,Jl=function(t,e){var i=Yl[t]=dl(Al);return Bl(i,{type:Dl,tag:t,description:e}),Kh||(i.description=e),i},td=function(t,e,i){t===Nl&&td(Xl,e,i),ol(t);var n=al(e);return ol(i),Qh(Yl,n)?(i.enumerable?(Qh(t,Pl)&&t[Pl][n]&&(t[Pl][n]=!1),i=dl(i,{enumerable:ll(0,!1)})):(Qh(t,Pl)||Wl(t,Pl,ll(1,{})),t[Pl][n]=!0),Ql(t,n,i)):Wl(t,n,i)},ed=function(t,e){ol(t);var i=sl(e),n=cl(i).concat(rd(i));return Ml(n,(function(e){Kh&&!Xh(id,i,e)||td(t,e,i[e])})),t},id=function(t){var e=al(t),i=Xh(Vl,this,e);return!(this===Nl&&Qh(Yl,e)&&!Qh(Xl,e))&&(!(i||!Qh(this,e)||!Qh(Yl,e)||Qh(this,Pl)&&this[Pl][e])||i)},nd=function(t,e){var i=sl(t),n=al(e);if(i!==Nl||!Qh(Yl,n)||Qh(Xl,n)){var o=Hl(i,n);return!o||!Qh(Yl,n)||Qh(i,Pl)&&i[Pl][n]||(o.enumerable=!0),o}},od=function(t){var e=ql(sl(t)),i=[];return Ml(e,(function(t){Qh(Yl,t)||Qh(_l,t)||Ul(i,t)})),i},rd=function(t){var e=t===Nl,i=ql(e?Xl:sl(t)),n=[];return Ml(i,(function(t){!Qh(Yl,t)||e&&!Qh(Nl,t)||Ul(n,Yl[t])})),n};if($h||(Fl=function(){if(il(Al,this))throw jl("Symbol is not a constructor");var t=arguments.length&&void 0!==arguments[0]?hl(arguments[0]):void 0,e=xl(t),i=function(t){this===Nl&&Xh(i,Xl,t),Qh(this,Pl)&&Qh(this[Pl],e)&&(this[Pl][e]=!1),Ql(this,e,ll(1,t))};return Kh&&Zl&&Ql(Nl,e,{configurable:!0,set:i}),Jl(e,t)},wl(Al=Fl.prototype,"toString",(function(){return zl(this).tag})),wl(Fl,"withoutSetter",(function(t){return Jl(xl(t),t)})),ml.f=id,gl.f=td,yl.f=ed,vl.f=nd,ul.f=fl.f=od,pl.f=rd,Ol.f=function(t){return Jl(El(t),t)},Kh&&Wl(Al,"description",{configurable:!0,get:function(){return zl(this).description}})),qh({global:!0,wrap:!0,forced:!$h,sham:!$h},{Symbol:Fl}),Ml(cl($l),(function(t){Cl(t)})),qh({target:Dl,stat:!0,forced:!$h},{for:function(t){var e=hl(t);if(Qh(Gl,e))return Gl[e];var i=Fl(e);return Gl[e]=i,Kl[i]=e,i},keyFor:function(t){if(!nl(t))throw jl(t+" is not a symbol");if(Qh(Kl,t))return Kl[t]},useSetter:function(){Zl=!0},useSimple:function(){Zl=!1}}),qh({target:"Object",stat:!0,forced:!$h,sham:!Kh},{create:function(t,e){return void 0===e?dl(t):ed(dl(t),e)},defineProperty:td,defineProperties:ed,getOwnPropertyDescriptor:nd}),qh({target:"Object",stat:!0,forced:!$h},{getOwnPropertyNames:od,getOwnPropertySymbols:rd}),qh({target:"Object",stat:!0,forced:Zh((function(){pl.f(1)}))},{getOwnPropertySymbols:function(t){return pl.f(rl(t))}}),Ll){var sd=!$h||Zh((function(){var t=Fl();return"[null]"!=Ll([t])||"{}"!=Ll({a:t})||"{}"!=Ll(Object(t))}));qh({target:"JSON",stat:!0,forced:sd},{stringify:function(t,e,i){var n=bl(arguments),o=e;if((el(e)||void 0!==t)&&!nl(t))return Jh(e)||(e=function(t,e){if(tl(o)&&(e=Xh(o,this,t,e)),!nl(e))return e}),n[1]=e,Yh(Ll,null,n)}})}if(!Al[Il]){var ad=Al.valueOf;wl(Al,Il,(function(t){return Xh(ad,this)}))}Sl(Fl,Dl),_l[Pl]=!0;var hd=X.Object.getOwnPropertySymbols,ld={exports:{}},dd=_i,cd=o,ud=V,fd=m.f,pd=b,vd=cd((function(){fd(1)}));dd({target:"Object",stat:!0,forced:!pd||vd,sham:!pd},{getOwnPropertyDescriptor:function(t,e){return fd(ud(t),e)}});var gd=X.Object,yd=ld.exports=function(t,e){return gd.getOwnPropertyDescriptor(t,e)};gd.getOwnPropertyDescriptor.sham&&(yd.sham=!0);var md=ld.exports,bd=md,wd=Q,kd=rh,_d=$i,xd=$e,Ed=g([].concat),Od=wd("Reflect","ownKeys")||function(t){var e=kd.f(xd(t)),i=_d.f;return i?Ed(e,i(t)):e},Cd=Od,Sd=V,Td=m,Md=aa;_i({target:"Object",stat:!0,sham:!b},{getOwnPropertyDescriptors:function(t){for(var e,i,n=Sd(t),o=Td.f,r=Cd(n),s={},a=0;r.length>a;)void 0!==(i=o(n,e=r[a++]))&&Md(s,e,i);return s}});var Pd=X.Object.getOwnPropertyDescriptors,Dd={exports:{}},Id=_i,Bd=b,zd=Zo.f;Id({target:"Object",stat:!0,forced:Object.defineProperties!==zd,sham:!Bd},{defineProperties:zd});var Nd=X.Object,Fd=Dd.exports=function(t,e){return Nd.defineProperties(t,e)};Nd.defineProperties.sham&&(Fd.sham=!0);var Ad=Dd.exports,jd={exports:{}},Rd=_i,Ld=b,Hd=Ve.f;Rd({target:"Object",stat:!0,forced:Object.defineProperty!==Hd,sham:!Ld},{defineProperty:Hd});var Wd=X.Object,qd=jd.exports=function(t,e,i){return Wd.defineProperty(t,e,i)};Wd.defineProperty.sham&&(qd.sham=!0);var Vd=jd.exports,Ud=Vd;function Yd(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}var Xd=Vd;function Gd(t,e){for(var i=0;i<e.length;i++){var n=e[i];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Xd(t,n.key,n)}}function Kd(t,e,i){return e&&Gd(t.prototype,e),i&&Gd(t,i),Xd(t,"prototype",{writable:!1}),t}function $d(t,e,i){return e in t?Xd(t,e,{value:i,enumerable:!0,configurable:!0,writable:!0}):t[e]=i,t}_i({target:"Array",stat:!0},{isArray:oh});var Zd=X.Array.isArray,Qd=Zd;var Jd=o,tc=at,ec=oe("species"),ic=function(t){return tc>=51||!Jd((function(){var e=[];return(e.constructor={})[ec]=function(){return{foo:1}},1!==e[t](Boolean).foo}))},nc=_i,oc=n,rc=o,sc=oh,ac=Y,hc=Rt,lc=Bi,dc=aa,cc=zh,uc=ic,fc=at,pc=oe("isConcatSpreadable"),vc=9007199254740991,gc="Maximum allowed index exceeded",yc=oc.TypeError,mc=fc>=51||!rc((function(){var t=[];return t[pc]=!1,t.concat()[0]!==t})),bc=uc("concat"),wc=function(t){if(!ac(t))return!1;var e=t[pc];return void 0!==e?!!e:sc(t)};nc({target:"Array",proto:!0,forced:!mc||!bc},{concat:function(t){var e,i,n,o,r,s=hc(this),a=cc(s,0),h=0;for(e=-1,n=arguments.length;e<n;e++)if(wc(r=-1===e?s:arguments[e])){if(h+(o=lc(r))>vc)throw yc(gc);for(i=0;i<o;i++,h++)i in r&&dc(a,h,r[i])}else{if(h>=vc)throw yc(gc);dc(a,h++,r)}return a.length=h,a}}),Ch("asyncIterator"),Ch("hasInstance"),Ch("isConcatSpreadable"),Ch("iterator"),Ch("match"),Ch("matchAll"),Ch("replace"),Ch("search"),Ch("species"),Ch("split"),Ch("toPrimitive"),Ch("toStringTag"),Ch("unscopables"),$r(n.JSON,"JSON",!0);var kc=X.Symbol,_c=kc;Ch("asyncDispose"),Ch("dispose"),Ch("matcher"),Ch("metadata"),Ch("observable"),Ch("patternMatch"),Ch("replaceAll");var xc=_c;var Ec=_i,Oc=n,Cc=oh,Sc=na,Tc=Y,Mc=Mi,Pc=Bi,Dc=V,Ic=aa,Bc=oe,zc=fn,Nc=ic("slice"),Fc=Bc("species"),Ac=Oc.Array,jc=Math.max;Ec({target:"Array",proto:!0,forced:!Nc},{slice:function(t,e){var i,n,o,r=Dc(this),s=Pc(r),a=Mc(t,s),h=Mc(void 0===e?s:e,s);if(Cc(r)&&(i=r.constructor,(Sc(i)&&(i===Ac||Cc(i.prototype))||Tc(i)&&null===(i=i[Fc]))&&(i=void 0),i===Ac||void 0===i))return zc(r,a,h);for(n=new(void 0===i?Ac:i)(jc(h-a,0)),o=0;a<h;a++,o++)a in r&&Ic(n,o,r[a]);return n.length=o,n}});var Rc=Tn("Array").slice,Lc=J,Hc=Rc,Wc=Array.prototype,qc=function(t){var e=t.slice;return t===Wc||Lc(Wc,t)&&e===Wc.slice?Hc:e},Vc=qc,Uc=Vc,Yc=Aa;function Xc(t,e){(null==e||e>t.length)&&(e=t.length);for(var i=0,n=new Array(e);i<e;i++)n[i]=t[i];return n}function Gc(t,e){var i;if(t){if("string"==typeof t)return Xc(t,e);var n=Uc(i=Object.prototype.toString.call(t)).call(i,8,-1);return"Object"===n&&t.constructor&&(n=t.constructor.name),"Map"===n||"Set"===n?Yc(t):"Arguments"===n||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)?Xc(t,e):void 0}}function Kc(t,e){return function(t){if(Qd(t))return t}(t)||function(t,e){var i=null==t?null:void 0!==xc&&ih(t)||t["@@iterator"];if(null!=i){var n,o,r=[],s=!0,a=!1;try{for(i=i.call(t);!(s=(n=i.next()).done)&&(r.push(n.value),!e||r.length!==e);s=!0);}catch(t){a=!0,o=t}finally{try{s||null==i.return||i.return()}finally{if(a)throw o}}return r}}(t,e)||Gc(t,e)||function(){throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}var $c=wh.f("iterator"),Zc=$c;function Qc(t){return Qc="function"==typeof xc&&"symbol"==typeof Zc?function(t){return typeof t}:function(t){return t&&"function"==typeof xc&&t.constructor===xc&&t!==xc.prototype?"symbol":typeof t},Qc(t)}function Jc(t){return function(t){if(Qd(t))return Xc(t)}(t)||function(t){if(void 0!==xc&&null!=ih(t)||null!=t["@@iterator"])return Yc(t)}(t)||Gc(t)||function(){throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}var tu=kc,eu=Tn("Array").concat,iu=J,nu=eu,ou=Array.prototype,ru=function(t){var e=t.concat;return t===ou||iu(ou,t)&&e===ou.concat?nu:e},su=ru,au=Vc;_i({target:"Reflect",stat:!0},{ownKeys:Od});var hu=X.Reflect.ownKeys,lu=Zd,du=Wh.map;_i({target:"Array",proto:!0,forced:!ic("map")},{map:function(t){return du(this,t,arguments.length>1?arguments[1]:void 0)}});var cu=Tn("Array").map,uu=J,fu=cu,pu=Array.prototype,vu=function(t){var e=t.map;return t===pu||uu(pu,t)&&e===pu.map?fu:e},gu=vu,yu=Rt,mu=Ki;_i({target:"Object",stat:!0,forced:o((function(){mu(1)}))},{keys:function(t){return mu(yu(t))}});var bu=X.Object.keys,wu=_i,ku=g,_u=n.Date,xu=ku(_u.prototype.getTime);wu({target:"Date",stat:!0},{now:function(){return xu(new _u)}});var Eu=X.Date.now,Ou=o,Cu=function(t,e){var i=[][t];return!!i&&Ou((function(){i.call(null,e||function(){return 1},1)}))},Su=Wh.forEach,Tu=Cu("forEach")?[].forEach:function(t){return Su(this,t,arguments.length>1?arguments[1]:void 0)};_i({target:"Array",proto:!0,forced:[].forEach!=Tu},{forEach:Tu});var Mu=Tn("Array").forEach,Pu=Qn,Du=Wt,Iu=J,Bu=Mu,zu=Array.prototype,Nu={DOMTokenList:!0,NodeList:!0},Fu=function(t){var e=t.forEach;return t===zu||Iu(zu,t)&&e===zu.forEach||Du(Nu,Pu(t))?Bu:e},Au=_i,ju=oh,Ru=g([].reverse),Lu=[1,2];Au({target:"Array",proto:!0,forced:String(Lu)===String(Lu.reverse())},{reverse:function(){return ju(this)&&(this.length=this.length),Ru(this)}});var Hu=Tn("Array").reverse,Wu=J,qu=Hu,Vu=Array.prototype,Uu=function(t){var e=t.reverse;return t===Vu||Wu(Vu,t)&&e===Vu.reverse?qu:e},Yu=Uu,Xu=_i,Gu=n,Ku=Mi,$u=Oi,Zu=Bi,Qu=Rt,Ju=zh,tf=aa,ef=ic("splice"),nf=Gu.TypeError,of=Math.max,rf=Math.min,sf=9007199254740991,af="Maximum allowed length exceeded";Xu({target:"Array",proto:!0,forced:!ef},{splice:function(t,e){var i,n,o,r,s,a,h=Qu(this),l=Zu(h),d=Ku(t,l),c=arguments.length;if(0===c?i=n=0:1===c?(i=0,n=l-d):(i=c-2,n=rf(of($u(e),0),l-d)),l+i-n>sf)throw nf(af);for(o=Ju(h,n),r=0;r<n;r++)(s=d+r)in h&&tf(o,r,h[s]);if(o.length=n,i<n){for(r=d;r<l-n;r++)a=r+i,(s=r+n)in h?h[a]=h[s]:delete h[a];for(r=l;r>l-n+i;r--)delete h[r-1]}else if(i>n)for(r=l-n;r>d;r--)a=r+i-1,(s=r+n-1)in h?h[a]=h[s]:delete h[a];for(r=0;r<i;r++)h[r+d]=arguments[r+2];return h.length=l-n+i,o}});var hf=Tn("Array").splice,lf=J,df=hf,cf=Array.prototype,uf=function(t){var e=t.splice;return t===cf||lf(cf,t)&&e===cf.splice?df:e},ff=uf,pf=ji.includes;_i({target:"Array",proto:!0},{includes:function(t){return pf(this,t,arguments.length>1?arguments[1]:void 0)}});var vf=Tn("Array").includes,gf=Y,yf=B,mf=oe("match"),bf=function(t){var e;return gf(t)&&(void 0!==(e=t[mf])?!!e:"RegExp"==yf(t))},wf=n.TypeError,kf=oe("match"),_f=_i,xf=function(t){if(bf(t))throw wf("The method doesn't accept regular expressions");return t},Ef=H,Of=eo,Cf=function(t){var e=/./;try{"/./"[t](e)}catch(i){try{return e[kf]=!1,"/./"[t](e)}catch(t){}}return!1},Sf=g("".indexOf);_f({target:"String",proto:!0,forced:!Cf("includes")},{includes:function(t){return!!~Sf(Of(Ef(this)),Of(xf(t)),arguments.length>1?arguments[1]:void 0)}});var Tf=Tn("String").includes,Mf=J,Pf=vf,Df=Tf,If=Array.prototype,Bf=String.prototype,zf=function(t){var e=t.includes;return t===If||Mf(If,t)&&e===If.includes?Pf:"string"==typeof t||t===Bf||Mf(Bf,t)&&e===Bf.includes?Df:e},Nf=zf,Ff=Rt,Af=Pr,jf=kr;_i({target:"Object",stat:!0,forced:o((function(){Af(1)})),sham:!jf},{getPrototypeOf:function(t){return Af(Ff(t))}});var Rf=X.Object.getPrototypeOf,Lf=Rf,Hf=Wh.filter;_i({target:"Array",proto:!0,forced:!ic("filter")},{filter:function(t){return Hf(this,t,arguments.length>1?arguments[1]:void 0)}});var Wf=Tn("Array").filter,qf=J,Vf=Wf,Uf=Array.prototype,Yf=function(t){var e=t.filter;return t===Uf||qf(Uf,t)&&e===Uf.filter?Vf:e},Xf=Yf,Gf=b,Kf=g,$f=Ki,Zf=V,Qf=Kf(x.f),Jf=Kf([].push),tp=function(t){return function(e){for(var i,n=Zf(e),o=$f(n),r=o.length,s=0,a=[];r>s;)i=o[s++],Gf&&!Qf(n,i)||Jf(a,t?[i,n[i]]:n[i]);return a}},ep={entries:tp(!0),values:tp(!1)}.values;_i({target:"Object",stat:!0},{values:function(t){return ep(t)}});var ip=X.Object.values,np="\t\n\v\f\r                　\u2028\u2029\ufeff",op=H,rp=eo,sp=g("".replace),ap="[\t\n\v\f\r                　\u2028\u2029\ufeff]",hp=RegExp("^"+ap+ap+"*"),lp=RegExp(ap+ap+"*$"),dp=function(t){return function(e){var i=rp(op(e));return 1&t&&(i=sp(i,hp,"")),2&t&&(i=sp(i,lp,"")),i}},cp={start:dp(1),end:dp(2),trim:dp(3)},up=n,fp=o,pp=g,vp=eo,gp=cp.trim,yp=np,mp=up.parseInt,bp=up.Symbol,wp=bp&&bp.iterator,kp=/^[+-]?0x/i,_p=pp(kp.exec),xp=8!==mp(yp+"08")||22!==mp(yp+"0x16")||wp&&!fp((function(){mp(Object(wp))}))?function(t,e){var i=gp(vp(t));return mp(i,e>>>0||(_p(kp,i)?16:10))}:mp;_i({global:!0,forced:parseInt!=xp},{parseInt:xp});var Ep=X.parseInt,Op=_i,Cp=ji.indexOf,Sp=Cu,Tp=g([].indexOf),Mp=!!Tp&&1/Tp([1],1,-0)<0,Pp=Sp("indexOf");Op({target:"Array",proto:!0,forced:Mp||!Pp},{indexOf:function(t){var e=arguments.length>1?arguments[1]:void 0;return Mp?Tp(this,t,e)||0:Cp(this,t,e)}});var Dp=Tn("Array").indexOf,Ip=J,Bp=Dp,zp=Array.prototype,Np=function(t){var e=t.indexOf;return t===zp||Ip(zp,t)&&e===zp.indexOf?Bp:e},Fp=Np,Ap=$o.PROPER,jp=o,Rp=np,Lp=cp.trim;_i({target:"String",proto:!0,forced:function(t){return jp((function(){return!!Rp[t]()||"​᠎"!=="​᠎"[t]()||Ap&&Rp[t].name!==t}))}("trim")},{trim:function(){return Lp(this)}});var Hp=Tn("String").trim,Wp=J,qp=Hp,Vp=String.prototype,Up=function(t){var e=t.trim;return"string"==typeof t||t===Vp||Wp(Vp,t)&&e===Vp.trim?qp:e},Yp=Up;_i({target:"Object",stat:!0,sham:!b},{create:wr});var Xp=X.Object,Gp=function(t,e){return Xp.create(t,e)},Kp=Gp,$p=_i,Zp=Q,Qp=d,Jp=g,tv=o,ev=n.Array,iv=Zp("JSON","stringify"),nv=Jp(/./.exec),ov=Jp("".charAt),rv=Jp("".charCodeAt),sv=Jp("".replace),av=Jp(1..toString),hv=/[\uD800-\uDFFF]/g,lv=/^[\uD800-\uDBFF]$/,dv=/^[\uDC00-\uDFFF]$/,cv=function(t,e,i){var n=ov(i,e-1),o=ov(i,e+1);return nv(lv,t)&&!nv(dv,o)||nv(dv,t)&&!nv(lv,n)?"\\u"+av(rv(t,0),16):t},uv=tv((function(){return'"\\udf06\\ud834"'!==iv("\udf06\ud834")||'"\\udead"'!==iv("\udead")}));iv&&$p({target:"JSON",stat:!0,forced:uv},{stringify:function(t,e,i){for(var n=0,o=arguments.length,r=ev(o);n<o;n++)r[n]=arguments[n];var s=Qp(iv,null,r);return"string"==typeof s?sv(s,hv,cv):s}});var fv=X,pv=d;fv.JSON||(fv.JSON={stringify:JSON.stringify});var vv=function(t,e,i){return pv(fv.JSON.stringify,null,arguments)},gv=vv,yv=n.TypeError,mv=_i,bv=n,wv=d,kv=y,_v=fn,xv=function(t,e){if(t<e)throw yv("Not enough arguments");return t},Ev=/MSIE .\./.test(tt),Ov=bv.Function,Cv=function(t){return function(e,i){var n=xv(arguments.length,1)>2,o=kv(e)?e:Ov(e),r=n?_v(arguments,2):void 0;return t(n?function(){wv(o,this,r)}:o,i)}};mv({global:!0,bind:!0,forced:Ev},{setTimeout:Cv(bv.setTimeout),setInterval:Cv(bv.setInterval)});var Sv=X.setTimeout,Tv=Rt,Mv=Mi,Pv=Bi,Dv=function(t){for(var e=Tv(this),i=Pv(e),n=arguments.length,o=Mv(n>1?arguments[1]:void 0,i),r=n>2?arguments[2]:void 0,s=void 0===r?i:Mv(r,i);s>o;)e[o++]=t;return e};_i({target:"Array",proto:!0},{fill:Dv});var Iv,Bv=Tn("Array").fill,zv=J,Nv=Bv,Fv=Array.prototype,Av=function(t){var e=t.fill;return t===Fv||zv(Fv,t)&&e===Fv.fill?Nv:e},jv=Av;function Rv(){return Rv=Object.assign||function(t){for(var e=1;e<arguments.length;e++){var i=arguments[e];for(var n in i)Object.prototype.hasOwnProperty.call(i,n)&&(t[n]=i[n])}return t},Rv.apply(this,arguments)}function Lv(t,e){t.prototype=Object.create(e.prototype),t.prototype.constructor=t,t.__proto__=e}function Hv(t){if(void 0===t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return t}Iv="function"!=typeof Object.assign?function(t){if(null==t)throw new TypeError("Cannot convert undefined or null to object");for(var e=Object(t),i=1;i<arguments.length;i++){var n=arguments[i];if(null!=n)for(var o in n)n.hasOwnProperty(o)&&(e[o]=n[o])}return e}:Object.assign;var Wv,qv=Iv,Vv=["","webkit","Moz","MS","ms","o"],Uv="undefined"==typeof document?{style:{}}:document.createElement("div"),Yv=Math.round,Xv=Math.abs,Gv=Date.now;function Kv(t,e){for(var i,n,o=e[0].toUpperCase()+e.slice(1),r=0;r<Vv.length;){if((n=(i=Vv[r])?i+o:e)in t)return n;r++}}Wv="undefined"==typeof window?{}:window;var $v=Kv(Uv.style,"touchAction"),Zv=void 0!==$v;var Qv="compute",Jv="auto",tg="manipulation",eg="none",ig="pan-x",ng="pan-y",og=function(){if(!Zv)return!1;var t={},e=Wv.CSS&&Wv.CSS.supports;return["auto","manipulation","pan-y","pan-x","pan-x pan-y","none"].forEach((function(i){return t[i]=!e||Wv.CSS.supports("touch-action",i)})),t}(),rg="ontouchstart"in Wv,sg=void 0!==Kv(Wv,"PointerEvent"),ag=rg&&/mobile|tablet|ip(ad|hone|od)|android/i.test(navigator.userAgent),hg="touch",lg="mouse",dg=16,cg=24,ug=["x","y"],fg=["clientX","clientY"];function pg(t,e,i){var n;if(t)if(t.forEach)t.forEach(e,i);else if(void 0!==t.length)for(n=0;n<t.length;)e.call(i,t[n],n,t),n++;else for(n in t)t.hasOwnProperty(n)&&e.call(i,t[n],n,t)}function vg(t,e){return"function"==typeof t?t.apply(e&&e[0]||void 0,e):t}function gg(t,e){return t.indexOf(e)>-1}var yg=function(){function t(t,e){this.manager=t,this.set(e)}var e=t.prototype;return e.set=function(t){t===Qv&&(t=this.compute()),Zv&&this.manager.element.style&&og[t]&&(this.manager.element.style[$v]=t),this.actions=t.toLowerCase().trim()},e.update=function(){this.set(this.manager.options.touchAction)},e.compute=function(){var t=[];return pg(this.manager.recognizers,(function(e){vg(e.options.enable,[e])&&(t=t.concat(e.getTouchAction()))})),function(t){if(gg(t,eg))return eg;var e=gg(t,ig),i=gg(t,ng);return e&&i?eg:e||i?e?ig:ng:gg(t,tg)?tg:Jv}(t.join(" "))},e.preventDefaults=function(t){var e=t.srcEvent,i=t.offsetDirection;if(this.manager.session.prevented)e.preventDefault();else{var n=this.actions,o=gg(n,eg)&&!og.none,r=gg(n,ng)&&!og["pan-y"],s=gg(n,ig)&&!og["pan-x"];if(o){var a=1===t.pointers.length,h=t.distance<2,l=t.deltaTime<250;if(a&&h&&l)return}if(!s||!r)return o||r&&6&i||s&&i&cg?this.preventSrc(e):void 0}},e.preventSrc=function(t){this.manager.session.prevented=!0,t.preventDefault()},t}();function mg(t,e){for(;t;){if(t===e)return!0;t=t.parentNode}return!1}function bg(t){var e=t.length;if(1===e)return{x:Yv(t[0].clientX),y:Yv(t[0].clientY)};for(var i=0,n=0,o=0;o<e;)i+=t[o].clientX,n+=t[o].clientY,o++;return{x:Yv(i/e),y:Yv(n/e)}}function wg(t){for(var e=[],i=0;i<t.pointers.length;)e[i]={clientX:Yv(t.pointers[i].clientX),clientY:Yv(t.pointers[i].clientY)},i++;return{timeStamp:Gv(),pointers:e,center:bg(e),deltaX:t.deltaX,deltaY:t.deltaY}}function kg(t,e,i){i||(i=ug);var n=e[i[0]]-t[i[0]],o=e[i[1]]-t[i[1]];return Math.sqrt(n*n+o*o)}function _g(t,e,i){i||(i=ug);var n=e[i[0]]-t[i[0]],o=e[i[1]]-t[i[1]];return 180*Math.atan2(o,n)/Math.PI}function xg(t,e){return t===e?1:Xv(t)>=Xv(e)?t<0?2:4:e<0?8:dg}function Eg(t,e,i){return{x:e/t||0,y:i/t||0}}function Og(t,e){var i=t.session,n=e.pointers,o=n.length;i.firstInput||(i.firstInput=wg(e)),o>1&&!i.firstMultiple?i.firstMultiple=wg(e):1===o&&(i.firstMultiple=!1);var r=i.firstInput,s=i.firstMultiple,a=s?s.center:r.center,h=e.center=bg(n);e.timeStamp=Gv(),e.deltaTime=e.timeStamp-r.timeStamp,e.angle=_g(a,h),e.distance=kg(a,h),function(t,e){var i=e.center,n=t.offsetDelta||{},o=t.prevDelta||{},r=t.prevInput||{};1!==e.eventType&&4!==r.eventType||(o=t.prevDelta={x:r.deltaX||0,y:r.deltaY||0},n=t.offsetDelta={x:i.x,y:i.y}),e.deltaX=o.x+(i.x-n.x),e.deltaY=o.y+(i.y-n.y)}(i,e),e.offsetDirection=xg(e.deltaX,e.deltaY);var l,d,c=Eg(e.deltaTime,e.deltaX,e.deltaY);e.overallVelocityX=c.x,e.overallVelocityY=c.y,e.overallVelocity=Xv(c.x)>Xv(c.y)?c.x:c.y,e.scale=s?(l=s.pointers,kg((d=n)[0],d[1],fg)/kg(l[0],l[1],fg)):1,e.rotation=s?function(t,e){return _g(e[1],e[0],fg)+_g(t[1],t[0],fg)}(s.pointers,n):0,e.maxPointers=i.prevInput?e.pointers.length>i.prevInput.maxPointers?e.pointers.length:i.prevInput.maxPointers:e.pointers.length,function(t,e){var i,n,o,r,s=t.lastInterval||e,a=e.timeStamp-s.timeStamp;if(8!==e.eventType&&(a>25||void 0===s.velocity)){var h=e.deltaX-s.deltaX,l=e.deltaY-s.deltaY,d=Eg(a,h,l);n=d.x,o=d.y,i=Xv(d.x)>Xv(d.y)?d.x:d.y,r=xg(h,l),t.lastInterval=e}else i=s.velocity,n=s.velocityX,o=s.velocityY,r=s.direction;e.velocity=i,e.velocityX=n,e.velocityY=o,e.direction=r}(i,e);var u,f=t.element,p=e.srcEvent;mg(u=p.composedPath?p.composedPath()[0]:p.path?p.path[0]:p.target,f)&&(f=u),e.target=f}function Cg(t,e,i){var n=i.pointers.length,o=i.changedPointers.length,r=1&e&&n-o==0,s=12&e&&n-o==0;i.isFirst=!!r,i.isFinal=!!s,r&&(t.session={}),i.eventType=e,Og(t,i),t.emit("hammer.input",i),t.recognize(i),t.session.prevInput=i}function Sg(t){return t.trim().split(/\s+/g)}function Tg(t,e,i){pg(Sg(e),(function(e){t.addEventListener(e,i,!1)}))}function Mg(t,e,i){pg(Sg(e),(function(e){t.removeEventListener(e,i,!1)}))}function Pg(t){var e=t.ownerDocument||t;return e.defaultView||e.parentWindow||window}var Dg=function(){function t(t,e){var i=this;this.manager=t,this.callback=e,this.element=t.element,this.target=t.options.inputTarget,this.domHandler=function(e){vg(t.options.enable,[t])&&i.handler(e)},this.init()}var e=t.prototype;return e.handler=function(){},e.init=function(){this.evEl&&Tg(this.element,this.evEl,this.domHandler),this.evTarget&&Tg(this.target,this.evTarget,this.domHandler),this.evWin&&Tg(Pg(this.element),this.evWin,this.domHandler)},e.destroy=function(){this.evEl&&Mg(this.element,this.evEl,this.domHandler),this.evTarget&&Mg(this.target,this.evTarget,this.domHandler),this.evWin&&Mg(Pg(this.element),this.evWin,this.domHandler)},t}();function Ig(t,e,i){if(t.indexOf&&!i)return t.indexOf(e);for(var n=0;n<t.length;){if(i&&t[n][i]==e||!i&&t[n]===e)return n;n++}return-1}var Bg={pointerdown:1,pointermove:2,pointerup:4,pointercancel:8,pointerout:8},zg={2:hg,3:"pen",4:lg,5:"kinect"},Ng="pointerdown",Fg="pointermove pointerup pointercancel";Wv.MSPointerEvent&&!Wv.PointerEvent&&(Ng="MSPointerDown",Fg="MSPointerMove MSPointerUp MSPointerCancel");var Ag=function(t){function e(){var i,n=e.prototype;return n.evEl=Ng,n.evWin=Fg,(i=t.apply(this,arguments)||this).store=i.manager.session.pointerEvents=[],i}return Lv(e,t),e.prototype.handler=function(t){var e=this.store,i=!1,n=t.type.toLowerCase().replace("ms",""),o=Bg[n],r=zg[t.pointerType]||t.pointerType,s=r===hg,a=Ig(e,t.pointerId,"pointerId");1&o&&(0===t.button||s)?a<0&&(e.push(t),a=e.length-1):12&o&&(i=!0),a<0||(e[a]=t,this.callback(this.manager,o,{pointers:e,changedPointers:[t],pointerType:r,srcEvent:t}),i&&e.splice(a,1))},e}(Dg);function jg(t){return Array.prototype.slice.call(t,0)}function Rg(t,e,i){for(var n=[],o=[],r=0;r<t.length;){var s=e?t[r][e]:t[r];Ig(o,s)<0&&n.push(t[r]),o[r]=s,r++}return i&&(n=e?n.sort((function(t,i){return t[e]>i[e]})):n.sort()),n}var Lg={touchstart:1,touchmove:2,touchend:4,touchcancel:8},Hg="touchstart touchmove touchend touchcancel",Wg=function(t){function e(){var i;return e.prototype.evTarget=Hg,(i=t.apply(this,arguments)||this).targetIds={},i}return Lv(e,t),e.prototype.handler=function(t){var e=Lg[t.type],i=qg.call(this,t,e);i&&this.callback(this.manager,e,{pointers:i[0],changedPointers:i[1],pointerType:hg,srcEvent:t})},e}(Dg);function qg(t,e){var i,n,o=jg(t.touches),r=this.targetIds;if(3&e&&1===o.length)return r[o[0].identifier]=!0,[o,o];var s=jg(t.changedTouches),a=[],h=this.target;if(n=o.filter((function(t){return mg(t.target,h)})),1===e)for(i=0;i<n.length;)r[n[i].identifier]=!0,i++;for(i=0;i<s.length;)r[s[i].identifier]&&a.push(s[i]),12&e&&delete r[s[i].identifier],i++;return a.length?[Rg(n.concat(a),"identifier",!0),a]:void 0}var Vg={mousedown:1,mousemove:2,mouseup:4},Ug="mousedown",Yg="mousemove mouseup",Xg=function(t){function e(){var i,n=e.prototype;return n.evEl=Ug,n.evWin=Yg,(i=t.apply(this,arguments)||this).pressed=!1,i}return Lv(e,t),e.prototype.handler=function(t){var e=Vg[t.type];1&e&&0===t.button&&(this.pressed=!0),2&e&&1!==t.which&&(e=4),this.pressed&&(4&e&&(this.pressed=!1),this.callback(this.manager,e,{pointers:[t],changedPointers:[t],pointerType:lg,srcEvent:t}))},e}(Dg);function Gg(t){var e=t.changedPointers[0];if(e.identifier===this.primaryTouch){var i={x:e.clientX,y:e.clientY},n=this.lastTouches;this.lastTouches.push(i);setTimeout((function(){var t=n.indexOf(i);t>-1&&n.splice(t,1)}),2500)}}function Kg(t,e){1&t?(this.primaryTouch=e.changedPointers[0].identifier,Gg.call(this,e)):12&t&&Gg.call(this,e)}function $g(t){for(var e=t.srcEvent.clientX,i=t.srcEvent.clientY,n=0;n<this.lastTouches.length;n++){var o=this.lastTouches[n],r=Math.abs(e-o.x),s=Math.abs(i-o.y);if(r<=25&&s<=25)return!0}return!1}var Zg=function(){return function(t){function e(e,i){var n;return(n=t.call(this,e,i)||this).handler=function(t,e,i){var o=i.pointerType===hg,r=i.pointerType===lg;if(!(r&&i.sourceCapabilities&&i.sourceCapabilities.firesTouchEvents)){if(o)Kg.call(Hv(Hv(n)),e,i);else if(r&&$g.call(Hv(Hv(n)),i))return;n.callback(t,e,i)}},n.touch=new Wg(n.manager,n.handler),n.mouse=new Xg(n.manager,n.handler),n.primaryTouch=null,n.lastTouches=[],n}return Lv(e,t),e.prototype.destroy=function(){this.touch.destroy(),this.mouse.destroy()},e}(Dg)}();function Qg(t,e,i){return!!Array.isArray(t)&&(pg(t,i[e],i),!0)}var Jg=32,ty=1;function ey(t,e){var i=e.manager;return i?i.get(t):t}function iy(t){return 16&t?"cancel":8&t?"end":4&t?"move":2&t?"start":""}var ny=function(){function t(t){void 0===t&&(t={}),this.options=Rv({enable:!0},t),this.id=ty++,this.manager=null,this.state=1,this.simultaneous={},this.requireFail=[]}var e=t.prototype;return e.set=function(t){return qv(this.options,t),this.manager&&this.manager.touchAction.update(),this},e.recognizeWith=function(t){if(Qg(t,"recognizeWith",this))return this;var e=this.simultaneous;return e[(t=ey(t,this)).id]||(e[t.id]=t,t.recognizeWith(this)),this},e.dropRecognizeWith=function(t){return Qg(t,"dropRecognizeWith",this)||(t=ey(t,this),delete this.simultaneous[t.id]),this},e.requireFailure=function(t){if(Qg(t,"requireFailure",this))return this;var e=this.requireFail;return-1===Ig(e,t=ey(t,this))&&(e.push(t),t.requireFailure(this)),this},e.dropRequireFailure=function(t){if(Qg(t,"dropRequireFailure",this))return this;t=ey(t,this);var e=Ig(this.requireFail,t);return e>-1&&this.requireFail.splice(e,1),this},e.hasRequireFailures=function(){return this.requireFail.length>0},e.canRecognizeWith=function(t){return!!this.simultaneous[t.id]},e.emit=function(t){var e=this,i=this.state;function n(i){e.manager.emit(i,t)}i<8&&n(e.options.event+iy(i)),n(e.options.event),t.additionalEvent&&n(t.additionalEvent),i>=8&&n(e.options.event+iy(i))},e.tryEmit=function(t){if(this.canEmit())return this.emit(t);this.state=Jg},e.canEmit=function(){for(var t=0;t<this.requireFail.length;){if(!(33&this.requireFail[t].state))return!1;t++}return!0},e.recognize=function(t){var e=qv({},t);if(!vg(this.options.enable,[this,e]))return this.reset(),void(this.state=Jg);56&this.state&&(this.state=1),this.state=this.process(e),30&this.state&&this.tryEmit(e)},e.process=function(t){},e.getTouchAction=function(){},e.reset=function(){},t}(),oy=function(t){function e(e){var i;return void 0===e&&(e={}),(i=t.call(this,Rv({event:"tap",pointers:1,taps:1,interval:300,time:250,threshold:9,posThreshold:10},e))||this).pTime=!1,i.pCenter=!1,i._timer=null,i._input=null,i.count=0,i}Lv(e,t);var i=e.prototype;return i.getTouchAction=function(){return[tg]},i.process=function(t){var e=this,i=this.options,n=t.pointers.length===i.pointers,o=t.distance<i.threshold,r=t.deltaTime<i.time;if(this.reset(),1&t.eventType&&0===this.count)return this.failTimeout();if(o&&r&&n){if(4!==t.eventType)return this.failTimeout();var s=!this.pTime||t.timeStamp-this.pTime<i.interval,a=!this.pCenter||kg(this.pCenter,t.center)<i.posThreshold;if(this.pTime=t.timeStamp,this.pCenter=t.center,a&&s?this.count+=1:this.count=1,this._input=t,0===this.count%i.taps)return this.hasRequireFailures()?(this._timer=setTimeout((function(){e.state=8,e.tryEmit()}),i.interval),2):8}return Jg},i.failTimeout=function(){var t=this;return this._timer=setTimeout((function(){t.state=Jg}),this.options.interval),Jg},i.reset=function(){clearTimeout(this._timer)},i.emit=function(){8===this.state&&(this._input.tapCount=this.count,this.manager.emit(this.options.event,this._input))},e}(ny),ry=function(t){function e(e){return void 0===e&&(e={}),t.call(this,Rv({pointers:1},e))||this}Lv(e,t);var i=e.prototype;return i.attrTest=function(t){var e=this.options.pointers;return 0===e||t.pointers.length===e},i.process=function(t){var e=this.state,i=t.eventType,n=6&e,o=this.attrTest(t);return n&&(8&i||!o)?16|e:n||o?4&i?8|e:2&e?4|e:2:Jg},e}(ny);function sy(t){return t===dg?"down":8===t?"up":2===t?"left":4===t?"right":""}var ay=function(t){function e(e){var i;return void 0===e&&(e={}),(i=t.call(this,Rv({event:"pan",threshold:10,pointers:1,direction:30},e))||this).pX=null,i.pY=null,i}Lv(e,t);var i=e.prototype;return i.getTouchAction=function(){var t=this.options.direction,e=[];return 6&t&&e.push(ng),t&cg&&e.push(ig),e},i.directionTest=function(t){var e=this.options,i=!0,n=t.distance,o=t.direction,r=t.deltaX,s=t.deltaY;return o&e.direction||(6&e.direction?(o=0===r?1:r<0?2:4,i=r!==this.pX,n=Math.abs(t.deltaX)):(o=0===s?1:s<0?8:dg,i=s!==this.pY,n=Math.abs(t.deltaY))),t.direction=o,i&&n>e.threshold&&o&e.direction},i.attrTest=function(t){return ry.prototype.attrTest.call(this,t)&&(2&this.state||!(2&this.state)&&this.directionTest(t))},i.emit=function(e){this.pX=e.deltaX,this.pY=e.deltaY;var i=sy(e.direction);i&&(e.additionalEvent=this.options.event+i),t.prototype.emit.call(this,e)},e}(ry),hy=function(t){function e(e){return void 0===e&&(e={}),t.call(this,Rv({event:"swipe",threshold:10,velocity:.3,direction:30,pointers:1},e))||this}Lv(e,t);var i=e.prototype;return i.getTouchAction=function(){return ay.prototype.getTouchAction.call(this)},i.attrTest=function(e){var i,n=this.options.direction;return 30&n?i=e.overallVelocity:6&n?i=e.overallVelocityX:n&cg&&(i=e.overallVelocityY),t.prototype.attrTest.call(this,e)&&n&e.offsetDirection&&e.distance>this.options.threshold&&e.maxPointers===this.options.pointers&&Xv(i)>this.options.velocity&&4&e.eventType},i.emit=function(t){var e=sy(t.offsetDirection);e&&this.manager.emit(this.options.event+e,t),this.manager.emit(this.options.event,t)},e}(ry),ly=function(t){function e(e){return void 0===e&&(e={}),t.call(this,Rv({event:"pinch",threshold:0,pointers:2},e))||this}Lv(e,t);var i=e.prototype;return i.getTouchAction=function(){return[eg]},i.attrTest=function(e){return t.prototype.attrTest.call(this,e)&&(Math.abs(e.scale-1)>this.options.threshold||2&this.state)},i.emit=function(e){if(1!==e.scale){var i=e.scale<1?"in":"out";e.additionalEvent=this.options.event+i}t.prototype.emit.call(this,e)},e}(ry),dy=function(t){function e(e){return void 0===e&&(e={}),t.call(this,Rv({event:"rotate",threshold:0,pointers:2},e))||this}Lv(e,t);var i=e.prototype;return i.getTouchAction=function(){return[eg]},i.attrTest=function(e){return t.prototype.attrTest.call(this,e)&&(Math.abs(e.rotation)>this.options.threshold||2&this.state)},e}(ry),cy=function(t){function e(e){var i;return void 0===e&&(e={}),(i=t.call(this,Rv({event:"press",pointers:1,time:251,threshold:9},e))||this)._timer=null,i._input=null,i}Lv(e,t);var i=e.prototype;return i.getTouchAction=function(){return[Jv]},i.process=function(t){var e=this,i=this.options,n=t.pointers.length===i.pointers,o=t.distance<i.threshold,r=t.deltaTime>i.time;if(this._input=t,!o||!n||12&t.eventType&&!r)this.reset();else if(1&t.eventType)this.reset(),this._timer=setTimeout((function(){e.state=8,e.tryEmit()}),i.time);else if(4&t.eventType)return 8;return Jg},i.reset=function(){clearTimeout(this._timer)},i.emit=function(t){8===this.state&&(t&&4&t.eventType?this.manager.emit(this.options.event+"up",t):(this._input.timeStamp=Gv(),this.manager.emit(this.options.event,this._input)))},e}(ny),uy={domEvents:!1,touchAction:Qv,enable:!0,inputTarget:null,inputClass:null,cssProps:{userSelect:"none",touchSelect:"none",touchCallout:"none",contentZooming:"none",userDrag:"none",tapHighlightColor:"rgba(0,0,0,0)"}},fy=[[dy,{enable:!1}],[ly,{enable:!1},["rotate"]],[hy,{direction:6}],[ay,{direction:6},["swipe"]],[oy],[oy,{event:"doubletap",taps:2},["tap"]],[cy]];function py(t,e){var i,n=t.element;n.style&&(pg(t.options.cssProps,(function(o,r){i=Kv(n.style,r),e?(t.oldCssProps[i]=n.style[i],n.style[i]=o):n.style[i]=t.oldCssProps[i]||""})),e||(t.oldCssProps={}))}var vy=function(){function t(t,e){var i,n=this;this.options=qv({},uy,e||{}),this.options.inputTarget=this.options.inputTarget||t,this.handlers={},this.session={},this.recognizers=[],this.oldCssProps={},this.element=t,this.input=new((i=this).options.inputClass||(sg?Ag:ag?Wg:rg?Zg:Xg))(i,Cg),this.touchAction=new yg(this,this.options.touchAction),py(this,!0),pg(this.options.recognizers,(function(t){var e=n.add(new t[0](t[1]));t[2]&&e.recognizeWith(t[2]),t[3]&&e.requireFailure(t[3])}),this)}var e=t.prototype;return e.set=function(t){return qv(this.options,t),t.touchAction&&this.touchAction.update(),t.inputTarget&&(this.input.destroy(),this.input.target=t.inputTarget,this.input.init()),this},e.stop=function(t){this.session.stopped=t?2:1},e.recognize=function(t){var e=this.session;if(!e.stopped){var i;this.touchAction.preventDefaults(t);var n=this.recognizers,o=e.curRecognizer;(!o||o&&8&o.state)&&(e.curRecognizer=null,o=null);for(var r=0;r<n.length;)i=n[r],2===e.stopped||o&&i!==o&&!i.canRecognizeWith(o)?i.reset():i.recognize(t),!o&&14&i.state&&(e.curRecognizer=i,o=i),r++}},e.get=function(t){if(t instanceof ny)return t;for(var e=this.recognizers,i=0;i<e.length;i++)if(e[i].options.event===t)return e[i];return null},e.add=function(t){if(Qg(t,"add",this))return this;var e=this.get(t.options.event);return e&&this.remove(e),this.recognizers.push(t),t.manager=this,this.touchAction.update(),t},e.remove=function(t){if(Qg(t,"remove",this))return this;var e=this.get(t);if(t){var i=this.recognizers,n=Ig(i,e);-1!==n&&(i.splice(n,1),this.touchAction.update())}return this},e.on=function(t,e){if(void 0===t||void 0===e)return this;var i=this.handlers;return pg(Sg(t),(function(t){i[t]=i[t]||[],i[t].push(e)})),this},e.off=function(t,e){if(void 0===t)return this;var i=this.handlers;return pg(Sg(t),(function(t){e?i[t]&&i[t].splice(Ig(i[t],e),1):delete i[t]})),this},e.emit=function(t,e){this.options.domEvents&&function(t,e){var i=document.createEvent("Event");i.initEvent(t,!0,!0),i.gesture=e,e.target.dispatchEvent(i)}(t,e);var i=this.handlers[t]&&this.handlers[t].slice();if(i&&i.length){e.type=t,e.preventDefault=function(){e.srcEvent.preventDefault()};for(var n=0;n<i.length;)i[n](e),n++}},e.destroy=function(){this.element&&py(this,!1),this.handlers={},this.session={},this.input.destroy(),this.element=null},t}(),gy={touchstart:1,touchmove:2,touchend:4,touchcancel:8},yy="touchstart",my="touchstart touchmove touchend touchcancel",by=function(t){function e(){var i,n=e.prototype;return n.evTarget=yy,n.evWin=my,(i=t.apply(this,arguments)||this).started=!1,i}return Lv(e,t),e.prototype.handler=function(t){var e=gy[t.type];if(1===e&&(this.started=!0),this.started){var i=wy.call(this,t,e);12&e&&i[0].length-i[1].length==0&&(this.started=!1),this.callback(this.manager,e,{pointers:i[0],changedPointers:i[1],pointerType:hg,srcEvent:t})}},e}(Dg);function wy(t,e){var i=jg(t.touches),n=jg(t.changedTouches);return 12&e&&(i=Rg(i.concat(n),"identifier",!0)),[i,n]}function ky(t,e,i){var n="DEPRECATED METHOD: "+e+"\n"+i+" AT \n";return function(){var e=new Error("get-stack-trace"),i=e&&e.stack?e.stack.replace(/^[^\(]+?[\n$]/gm,"").replace(/^\s+at\s+/gm,"").replace(/^Object.<anonymous>\s*\(/gm,"{anonymous}()@"):"Unknown Stack Trace",o=window.console&&(window.console.warn||window.console.log);return o&&o.call(window.console,n,i),t.apply(this,arguments)}}var _y=ky((function(t,e,i){for(var n=Object.keys(e),o=0;o<n.length;)(!i||i&&void 0===t[n[o]])&&(t[n[o]]=e[n[o]]),o++;return t}),"extend","Use `assign`."),xy=ky((function(t,e){return _y(t,e,!0)}),"merge","Use `assign`.");function Ey(t,e,i){var n,o=e.prototype;(n=t.prototype=Object.create(o)).constructor=t,n._super=o,i&&qv(n,i)}function Oy(t,e){return function(){return t.apply(e,arguments)}}var Cy=function(){var t=function(t,e){return void 0===e&&(e={}),new vy(t,Rv({recognizers:fy.concat()},e))};return t.VERSION="2.0.17-rc",t.DIRECTION_ALL=30,t.DIRECTION_DOWN=dg,t.DIRECTION_LEFT=2,t.DIRECTION_RIGHT=4,t.DIRECTION_UP=8,t.DIRECTION_HORIZONTAL=6,t.DIRECTION_VERTICAL=cg,t.DIRECTION_NONE=1,t.DIRECTION_DOWN=dg,t.INPUT_START=1,t.INPUT_MOVE=2,t.INPUT_END=4,t.INPUT_CANCEL=8,t.STATE_POSSIBLE=1,t.STATE_BEGAN=2,t.STATE_CHANGED=4,t.STATE_ENDED=8,t.STATE_RECOGNIZED=8,t.STATE_CANCELLED=16,t.STATE_FAILED=Jg,t.Manager=vy,t.Input=Dg,t.TouchAction=yg,t.TouchInput=Wg,t.MouseInput=Xg,t.PointerEventInput=Ag,t.TouchMouseInput=Zg,t.SingleTouchInput=by,t.Recognizer=ny,t.AttrRecognizer=ry,t.Tap=oy,t.Pan=ay,t.Swipe=hy,t.Pinch=ly,t.Rotate=dy,t.Press=cy,t.on=Tg,t.off=Mg,t.each=pg,t.merge=xy,t.extend=_y,t.bindFn=Oy,t.assign=qv,t.inherit=Ey,t.bindFn=Oy,t.prefixed=Kv,t.toArray=jg,t.inArray=Ig,t.uniqueArray=Rg,t.splitStr=Sg,t.boolOrFn=vg,t.hasParent=mg,t.addEventListeners=Tg,t.removeEventListeners=Mg,t.defaults=qv({},uy,{preset:fy}),t}(),Sy=Cy;function Ty(t,e){var i=bu(t);if(hd){var n=hd(t);e&&(n=Xf(n).call(n,(function(e){return bd(t,e).enumerable}))),i.push.apply(i,n)}return i}function My(t){for(var e=1;e<arguments.length;e++){var i,n,o=null!=arguments[e]?arguments[e]:{};e%2?Fu(i=Ty(Object(o),!0)).call(i,(function(e){$d(t,e,o[e])})):Pd?Ad(t,Pd(o)):Fu(n=Ty(Object(o))).call(n,(function(e){Ud(t,e,bd(o,e))}))}return t}function Py(t,e){var i=void 0!==tu&&ih(t)||t["@@iterator"];if(!i){if(lu(t)||(i=function(t,e){var i;if(!t)return;if("string"==typeof t)return Dy(t,e);var n=au(i=Object.prototype.toString.call(t)).call(i,8,-1);"Object"===n&&t.constructor&&(n=t.constructor.name);if("Map"===n||"Set"===n)return ja(t);if("Arguments"===n||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))return Dy(t,e)}(t))||e&&t&&"number"==typeof t.length){i&&(t=i);var n=0,o=function(){};return{s:o,n:function(){return n>=t.length?{done:!0}:{done:!1,value:t[n++]}},e:function(t){throw t},f:o}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}var r,s=!0,a=!1;return{s:function(){i=i.call(t)},n:function(){var t=i.next();return s=t.done,t},e:function(t){a=!0,r=t},f:function(){try{s||null==i.return||i.return()}finally{if(a)throw r}}}}function Dy(t,e){(null==e||e>t.length)&&(e=t.length);for(var i=0,n=new Array(e);i<e;i++)n[i]=t[i];return n}var Iy=tu("DELETE");function By(t){for(var e,i=arguments.length,n=new Array(i>1?i-1:0),o=1;o<i;o++)n[o-1]=arguments[o];return zy.apply(void 0,su(e=[{},t]).call(e,n))}function zy(){var t=Ny.apply(void 0,arguments);return Ay(t),t}function Ny(){for(var t=arguments.length,e=new Array(t),i=0;i<t;i++)e[i]=arguments[i];if(e.length<2)return e[0];var n;if(e.length>2)return Ny.apply(void 0,su(n=[zy(e[0],e[1])]).call(n,Jc(au(e).call(e,2))));var o,r=e[0],s=e[1],a=Py(hu(s));try{for(a.s();!(o=a.n()).done;){var h=o.value;Object.prototype.propertyIsEnumerable.call(s,h)&&(s[h]===Iy?delete r[h]:null===r[h]||null===s[h]||"object"!==Qc(r[h])||"object"!==Qc(s[h])||lu(r[h])||lu(s[h])?r[h]=Fy(s[h]):r[h]=Ny(r[h],s[h]))}}catch(t){a.e(t)}finally{a.f()}return r}function Fy(t){return lu(t)?gu(t).call(t,(function(t){return Fy(t)})):"object"===Qc(t)&&null!==t?Ny({},t):t}function Ay(t){for(var e=0,i=bu(t);e<i.length;e++){var n=i[e];t[n]===Iy?delete t[n]:"object"===Qc(t[n])&&null!==t[n]&&Ay(t[n])}}function jy(){for(var t=arguments.length,e=new Array(t),i=0;i<t;i++)e[i]=arguments[i];return Ry(e.length?e:[Eu()])}function Ry(t){var e=function(){for(var t=Ly(),e=t(" "),i=t(" "),n=t(" "),o=0;o<arguments.length;o++)(e-=t(o<0||arguments.length<=o?void 0:arguments[o]))<0&&(e+=1),(i-=t(o<0||arguments.length<=o?void 0:arguments[o]))<0&&(i+=1),(n-=t(o<0||arguments.length<=o?void 0:arguments[o]))<0&&(n+=1);return[e,i,n]}(t),i=Kc(e,3),n=i[0],o=i[1],r=i[2],s=1,a=function(){var t=2091639*n+2.3283064365386963e-10*s;return n=o,o=r,r=t-(s=0|t)};return a.uint32=function(){return 4294967296*a()},a.fract53=function(){return a()+11102230246251565e-32*(2097152*a()|0)},a.algorithm="Alea",a.seed=t,a.version="0.9",a}function Ly(){var t=4022871197;return function(e){for(var i=e.toString(),n=0;n<i.length;n++){var o=.02519603282416938*(t+=i.charCodeAt(n));o-=t=o>>>0,t=(o*=t)>>>0,t+=4294967296*(o-=t)}return 2.3283064365386963e-10*(t>>>0)}}var Hy="undefined"!=typeof window?window.Hammer||Sy:function(){return function(){var t=function(){};return{on:t,off:t,destroy:t,emit:t,get:function(){return{set:t}}}}()};function Wy(t){var e,i=this;this._cleanupQueue=[],this.active=!1,this._dom={container:t,overlay:document.createElement("div")},this._dom.overlay.classList.add("vis-overlay"),this._dom.container.appendChild(this._dom.overlay),this._cleanupQueue.push((function(){i._dom.overlay.parentNode.removeChild(i._dom.overlay)}));var n=Hy(this._dom.overlay);n.on("tap",zn(e=this._onTapOverlay).call(e,this)),this._cleanupQueue.push((function(){n.destroy()}));var o=["tap","doubletap","press","pinch","pan","panstart","panmove","panend"];Fu(o).call(o,(function(t){n.on(t,(function(t){t.srcEvent.stopPropagation()}))})),document&&document.body&&(this._onClick=function(e){(function(t,e){for(;t;){if(t===e)return!0;t=t.parentNode}return!1})(e.target,t)||i.deactivate()},document.body.addEventListener("click",this._onClick),this._cleanupQueue.push((function(){document.body.removeEventListener("click",i._onClick)}))),this._escListener=function(t){("key"in t?"Escape"===t.key:27===t.keyCode)&&i.deactivate()}}Wn(Wy.prototype),Wy.current=null,Wy.prototype.destroy=function(){var t,e;this.deactivate();var i,n=Py(Yu(t=ff(e=this._cleanupQueue).call(e,0)).call(t));try{for(n.s();!(i=n.n()).done;){(0,i.value)()}}catch(t){n.e(t)}finally{n.f()}},Wy.prototype.activate=function(){Wy.current&&Wy.current.deactivate(),Wy.current=this,this.active=!0,this._dom.overlay.style.display="none",this._dom.container.classList.add("vis-active"),this.emit("change"),this.emit("activate"),document.body.addEventListener("keydown",this._escListener)},Wy.prototype.deactivate=function(){this.active=!1,this._dom.overlay.style.display="block",this._dom.container.classList.remove("vis-active"),document.body.removeEventListener("keydown",this._escListener),this.emit("change"),this.emit("deactivate")},Wy.prototype._onTapOverlay=function(t){this.activate(),t.srcEvent.stopPropagation()};var qy=/^\/?Date\((-?\d+)/i,Vy=/^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i,Uy=/^#?([a-f\d])([a-f\d])([a-f\d])$/i,Yy=/^rgb\( *(1?\d{1,2}|2[0-4]\d|25[0-5]) *, *(1?\d{1,2}|2[0-4]\d|25[0-5]) *, *(1?\d{1,2}|2[0-4]\d|25[0-5]) *\)$/i,Xy=/^rgba\( *(1?\d{1,2}|2[0-4]\d|25[0-5]) *, *(1?\d{1,2}|2[0-4]\d|25[0-5]) *, *(1?\d{1,2}|2[0-4]\d|25[0-5]) *, *([01]|0?\.\d+) *\)$/i;function Gy(t){return t instanceof Number||"number"==typeof t}function Ky(t){if(t)for(;!0===t.hasChildNodes();){var e=t.firstChild;e&&(Ky(e),t.removeChild(e))}}function $y(t){return t instanceof String||"string"==typeof t}function Zy(t){return"object"===Qc(t)&&null!==t}function Qy(t,e,i,n){var o=!1;!0===n&&(o=null===e[i]&&void 0!==t[i]),o?delete t[i]:t[i]=e[i]}function Jy(t,e){var i=arguments.length>2&&void 0!==arguments[2]&&arguments[2];for(var n in t)if(void 0!==e[n])if(null===e[n]||"object"!==Qc(e[n]))Qy(t,e,n,i);else{var o=t[n],r=e[n];Zy(o)&&Zy(r)&&Jy(o,r,i)}}var tm=un;function em(t,e,i){var n=arguments.length>3&&void 0!==arguments[3]&&arguments[3];if(lu(i))throw new TypeError("Arrays are not supported by deepExtend");for(var o=0;o<t.length;o++){var r=t[o];if(Object.prototype.hasOwnProperty.call(i,r))if(i[r]&&i[r].constructor===Object)void 0===e[r]&&(e[r]={}),e[r].constructor===Object?nm(e[r],i[r],!1,n):Qy(e,i,r,n);else{if(lu(i[r]))throw new TypeError("Arrays are not supported by deepExtend");Qy(e,i,r,n)}}return e}function im(t,e,i){var n=arguments.length>3&&void 0!==arguments[3]&&arguments[3];if(lu(i))throw new TypeError("Arrays are not supported by deepExtend");for(var o in i)if(Object.prototype.hasOwnProperty.call(i,o)&&!Nf(t).call(t,o))if(i[o]&&i[o].constructor===Object)void 0===e[o]&&(e[o]={}),e[o].constructor===Object?nm(e[o],i[o]):Qy(e,i,o,n);else if(lu(i[o])){e[o]=[];for(var r=0;r<i[o].length;r++)e[o].push(i[o][r])}else Qy(e,i,o,n);return e}function nm(t,e){var i=arguments.length>2&&void 0!==arguments[2]&&arguments[2],n=arguments.length>3&&void 0!==arguments[3]&&arguments[3];for(var o in e)if(Object.prototype.hasOwnProperty.call(e,o)||!0===i)if("object"===Qc(e[o])&&null!==e[o]&&Lf(e[o])===Object.prototype)void 0===t[o]?t[o]=nm({},e[o],i):"object"===Qc(t[o])&&null!==t[o]&&Lf(t[o])===Object.prototype?nm(t[o],e[o],i):Qy(t,e,o,n);else if(lu(e[o])){var r;t[o]=au(r=e[o]).call(r)}else Qy(t,e,o,n);return t}function om(t,e){var i;return su(i=[]).call(i,Jc(t),[e])}function rm(t){return au(t).call(t)}function sm(t){return t.getBoundingClientRect().left}function am(t){return t.getBoundingClientRect().top}function hm(t,e){if(lu(t))for(var i=t.length,n=0;n<i;n++)e(t[n],n,t);else for(var o in t)Object.prototype.hasOwnProperty.call(t,o)&&e(t[o],o,t)}var lm=ip;function dm(t,e,i,n){var o;t.addEventListener?(void 0===n&&(n=!1),"mousewheel"===e&&Nf(o=navigator.userAgent).call(o,"Firefox")&&(e="DOMMouseScroll"),t.addEventListener(e,i,n)):t.attachEvent("on"+e,i)}function cm(t,e,i,n){var o;t.removeEventListener?(void 0===n&&(n=!1),"mousewheel"===e&&Nf(o=navigator.userAgent).call(o,"Firefox")&&(e="DOMMouseScroll"),t.removeEventListener(e,i,n)):t.detachEvent("on"+e,i)}var um={asBoolean:function(t,e){return"function"==typeof t&&(t=t()),null!=t?0!=t:e||null},asNumber:function(t,e){return"function"==typeof t&&(t=t()),null!=t?Number(t)||e||null:e||null},asString:function(t,e){return"function"==typeof t&&(t=t()),null!=t?String(t):e||null},asSize:function(t,e){return"function"==typeof t&&(t=t()),$y(t)?t:Gy(t)?t+"px":e||null},asElement:function(t,e){return"function"==typeof t&&(t=t()),t||e||null}};function fm(t){var e;switch(t.length){case 3:case 4:return(e=Uy.exec(t))?{r:Ep(e[1]+e[1],16),g:Ep(e[2]+e[2],16),b:Ep(e[3]+e[3],16)}:null;case 6:case 7:return(e=Vy.exec(t))?{r:Ep(e[1],16),g:Ep(e[2],16),b:Ep(e[3],16)}:null;default:return null}}function pm(t,e){if(Nf(t).call(t,"rgba"))return t;if(Nf(t).call(t,"rgb")){var i=t.substr(Fp(t).call(t,"(")+1).replace(")","").split(",");return"rgba("+i[0]+","+i[1]+","+i[2]+","+e+")"}var n=fm(t);return null==n?t:"rgba("+n.r+","+n.g+","+n.b+","+e+")"}function vm(t,e,i){var n;return"#"+au(n=((1<<24)+(t<<16)+(e<<8)+i).toString(16)).call(n,1)}function gm(t,e){if($y(t)){var i=t;if(Em(i)){var n,o=gu(n=i.substr(4).substr(0,i.length-5).split(",")).call(n,(function(t){return Ep(t)}));i=vm(o[0],o[1],o[2])}if(!0===xm(i)){var r=_m(i),s={h:r.h,s:.8*r.s,v:Math.min(1,1.02*r.v)},a={h:r.h,s:Math.min(1,1.25*r.s),v:.8*r.v},h=km(a.h,a.s,a.v),l=km(s.h,s.s,s.v);return{background:i,border:h,highlight:{background:l,border:h},hover:{background:l,border:h}}}return{background:i,border:i,highlight:{background:i,border:i},hover:{background:i,border:i}}}return e?{background:t.background||e.background,border:t.border||e.border,highlight:$y(t.highlight)?{border:t.highlight,background:t.highlight}:{background:t.highlight&&t.highlight.background||e.highlight.background,border:t.highlight&&t.highlight.border||e.highlight.border},hover:$y(t.hover)?{border:t.hover,background:t.hover}:{border:t.hover&&t.hover.border||e.hover.border,background:t.hover&&t.hover.background||e.hover.background}}:{background:t.background||void 0,border:t.border||void 0,highlight:$y(t.highlight)?{border:t.highlight,background:t.highlight}:{background:t.highlight&&t.highlight.background||void 0,border:t.highlight&&t.highlight.border||void 0},hover:$y(t.hover)?{border:t.hover,background:t.hover}:{border:t.hover&&t.hover.border||void 0,background:t.hover&&t.hover.background||void 0}}}function ym(t,e,i){t/=255,e/=255,i/=255;var n=Math.min(t,Math.min(e,i)),o=Math.max(t,Math.max(e,i));return n===o?{h:0,s:0,v:n}:{h:60*((t===n?3:i===n?1:5)-(t===n?e-i:i===n?t-e:i-t)/(o-n))/360,s:(o-n)/o,v:o}}var mm=function(t){var e,i={};return Fu(e=t.split(";")).call(e,(function(t){if(""!=Yp(t).call(t)){var e,n,o=t.split(":"),r=Yp(e=o[0]).call(e),s=Yp(n=o[1]).call(n);i[r]=s}})),i},bm=function(t){var e;return gu(e=bu(t)).call(e,(function(e){return e+": "+t[e]})).join("; ")};function wm(t,e,i){var n,o,r,s=Math.floor(6*t),a=6*t-s,h=i*(1-e),l=i*(1-a*e),d=i*(1-(1-a)*e);switch(s%6){case 0:n=i,o=d,r=h;break;case 1:n=l,o=i,r=h;break;case 2:n=h,o=i,r=d;break;case 3:n=h,o=l,r=i;break;case 4:n=d,o=h,r=i;break;case 5:n=i,o=h,r=l}return{r:Math.floor(255*n),g:Math.floor(255*o),b:Math.floor(255*r)}}function km(t,e,i){var n=wm(t,e,i);return vm(n.r,n.g,n.b)}function _m(t){var e=fm(t);if(!e)throw new TypeError("'".concat(t,"' is not a valid color."));return ym(e.r,e.g,e.b)}function xm(t){return/(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)/i.test(t)}function Em(t){return Yy.test(t)}function Om(t){return Xy.test(t)}function Cm(t){if(null===t||"object"!==Qc(t))return null;if(t instanceof Element)return t;var e=Kp(t);for(var i in t)Object.prototype.hasOwnProperty.call(t,i)&&"object"==Qc(t[i])&&(e[i]=Cm(t[i]));return e}function Sm(t,e,i){var n=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{},o=function(t){return null!=t},r=function(t){return null!==t&&"object"===Qc(t)},s=function(t){for(var e in t)if(Object.prototype.hasOwnProperty.call(t,e))return!1;return!0};if(!r(t))throw new Error("Parameter mergeTarget must be an object");if(!r(e))throw new Error("Parameter options must be an object");if(!o(i))throw new Error("Parameter option must have a value");if(!r(n))throw new Error("Parameter globalOptions must be an object");var a=function(t,e,i){r(t[i])||(t[i]={});var n=e[i],o=t[i];for(var s in n)Object.prototype.hasOwnProperty.call(n,s)&&(o[s]=n[s])},h=e[i],l=r(n)&&!s(n),d=l?n[i]:void 0,c=d?d.enabled:void 0;if(void 0!==h){if("boolean"==typeof h)return r(t[i])||(t[i]={}),void(t[i].enabled=h);if(null===h&&!r(t[i])){if(!o(d))return;t[i]=Kp(d)}if(r(h)){var u=!0;void 0!==h.enabled?u=h.enabled:void 0!==c&&(u=d.enabled),a(t,e,i),t[i].enabled=u}}}var Tm={linear:function(t){return t},easeInQuad:function(t){return t*t},easeOutQuad:function(t){return t*(2-t)},easeInOutQuad:function(t){return t<.5?2*t*t:(4-2*t)*t-1},easeInCubic:function(t){return t*t*t},easeOutCubic:function(t){return--t*t*t+1},easeInOutCubic:function(t){return t<.5?4*t*t*t:(t-1)*(2*t-2)*(2*t-2)+1},easeInQuart:function(t){return t*t*t*t},easeOutQuart:function(t){return 1- --t*t*t*t},easeInOutQuart:function(t){return t<.5?8*t*t*t*t:1-8*--t*t*t*t},easeInQuint:function(t){return t*t*t*t*t},easeOutQuint:function(t){return 1+--t*t*t*t*t},easeInOutQuint:function(t){return t<.5?16*t*t*t*t*t:1+16*--t*t*t*t*t}};function Mm(t,e){var i;lu(e)||(e=[e]);var n,o=Py(t);try{for(o.s();!(n=o.n()).done;){var r=n.value;if(r){i=r[e[0]];for(var s=1;s<e.length;s++)i&&(i=i[e[s]]);if(void 0!==i)break}}}catch(t){o.e(t)}finally{o.f()}return i}var Pm={black:"#000000",navy:"#000080",darkblue:"#00008B",mediumblue:"#0000CD",blue:"#0000FF",darkgreen:"#006400",green:"#008000",teal:"#008080",darkcyan:"#008B8B",deepskyblue:"#00BFFF",darkturquoise:"#00CED1",mediumspringgreen:"#00FA9A",lime:"#00FF00",springgreen:"#00FF7F",aqua:"#00FFFF",cyan:"#00FFFF",midnightblue:"#191970",dodgerblue:"#1E90FF",lightseagreen:"#20B2AA",forestgreen:"#228B22",seagreen:"#2E8B57",darkslategray:"#2F4F4F",limegreen:"#32CD32",mediumseagreen:"#3CB371",turquoise:"#40E0D0",royalblue:"#4169E1",steelblue:"#4682B4",darkslateblue:"#483D8B",mediumturquoise:"#48D1CC",indigo:"#4B0082",darkolivegreen:"#556B2F",cadetblue:"#5F9EA0",cornflowerblue:"#6495ED",mediumaquamarine:"#66CDAA",dimgray:"#696969",slateblue:"#6A5ACD",olivedrab:"#6B8E23",slategray:"#708090",lightslategray:"#778899",mediumslateblue:"#7B68EE",lawngreen:"#7CFC00",chartreuse:"#7FFF00",aquamarine:"#7FFFD4",maroon:"#800000",purple:"#800080",olive:"#808000",gray:"#808080",skyblue:"#87CEEB",lightskyblue:"#87CEFA",blueviolet:"#8A2BE2",darkred:"#8B0000",darkmagenta:"#8B008B",saddlebrown:"#8B4513",darkseagreen:"#8FBC8F",lightgreen:"#90EE90",mediumpurple:"#9370D8",darkviolet:"#9400D3",palegreen:"#98FB98",darkorchid:"#9932CC",yellowgreen:"#9ACD32",sienna:"#A0522D",brown:"#A52A2A",darkgray:"#A9A9A9",lightblue:"#ADD8E6",greenyellow:"#ADFF2F",paleturquoise:"#AFEEEE",lightsteelblue:"#B0C4DE",powderblue:"#B0E0E6",firebrick:"#B22222",darkgoldenrod:"#B8860B",mediumorchid:"#BA55D3",rosybrown:"#BC8F8F",darkkhaki:"#BDB76B",silver:"#C0C0C0",mediumvioletred:"#C71585",indianred:"#CD5C5C",peru:"#CD853F",chocolate:"#D2691E",tan:"#D2B48C",lightgrey:"#D3D3D3",palevioletred:"#D87093",thistle:"#D8BFD8",orchid:"#DA70D6",goldenrod:"#DAA520",crimson:"#DC143C",gainsboro:"#DCDCDC",plum:"#DDA0DD",burlywood:"#DEB887",lightcyan:"#E0FFFF",lavender:"#E6E6FA",darksalmon:"#E9967A",violet:"#EE82EE",palegoldenrod:"#EEE8AA",lightcoral:"#F08080",khaki:"#F0E68C",aliceblue:"#F0F8FF",honeydew:"#F0FFF0",azure:"#F0FFFF",sandybrown:"#F4A460",wheat:"#F5DEB3",beige:"#F5F5DC",whitesmoke:"#F5F5F5",mintcream:"#F5FFFA",ghostwhite:"#F8F8FF",salmon:"#FA8072",antiquewhite:"#FAEBD7",linen:"#FAF0E6",lightgoldenrodyellow:"#FAFAD2",oldlace:"#FDF5E6",red:"#FF0000",fuchsia:"#FF00FF",magenta:"#FF00FF",deeppink:"#FF1493",orangered:"#FF4500",tomato:"#FF6347",hotpink:"#FF69B4",coral:"#FF7F50",darkorange:"#FF8C00",lightsalmon:"#FFA07A",orange:"#FFA500",lightpink:"#FFB6C1",pink:"#FFC0CB",gold:"#FFD700",peachpuff:"#FFDAB9",navajowhite:"#FFDEAD",moccasin:"#FFE4B5",bisque:"#FFE4C4",mistyrose:"#FFE4E1",blanchedalmond:"#FFEBCD",papayawhip:"#FFEFD5",lavenderblush:"#FFF0F5",seashell:"#FFF5EE",cornsilk:"#FFF8DC",lemonchiffon:"#FFFACD",floralwhite:"#FFFAF0",snow:"#FFFAFA",yellow:"#FFFF00",lightyellow:"#FFFFE0",ivory:"#FFFFF0",white:"#FFFFFF"},Dm=function(){function t(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1;Yd(this,t),this.pixelRatio=e,this.generated=!1,this.centerCoordinates={x:144.5,y:144.5},this.r=289*.49,this.color={r:255,g:255,b:255,a:1},this.hueCircle=void 0,this.initialColor={r:255,g:255,b:255,a:1},this.previousColor=void 0,this.applied=!1,this.updateCallback=function(){},this.closeCallback=function(){},this._create()}return Kd(t,[{key:"insertTo",value:function(t){void 0!==this.hammer&&(this.hammer.destroy(),this.hammer=void 0),this.container=t,this.container.appendChild(this.frame),this._bindHammer(),this._setSize()}},{key:"setUpdateCallback",value:function(t){if("function"!=typeof t)throw new Error("Function attempted to set as colorPicker update callback is not a function.");this.updateCallback=t}},{key:"setCloseCallback",value:function(t){if("function"!=typeof t)throw new Error("Function attempted to set as colorPicker closing callback is not a function.");this.closeCallback=t}},{key:"_isColorString",value:function(t){if("string"==typeof t)return Pm[t]}},{key:"setColor",value:function(t){var e=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];if("none"!==t){var i,n=this._isColorString(t);if(void 0!==n&&(t=n),!0===$y(t)){if(!0===Em(t)){var o=t.substr(4).substr(0,t.length-5).split(",");i={r:o[0],g:o[1],b:o[2],a:1}}else if(!0===Om(t)){var r=t.substr(5).substr(0,t.length-6).split(",");i={r:r[0],g:r[1],b:r[2],a:r[3]}}else if(!0===xm(t)){var s=fm(t);i={r:s.r,g:s.g,b:s.b,a:1}}}else if(t instanceof Object&&void 0!==t.r&&void 0!==t.g&&void 0!==t.b){var a=void 0!==t.a?t.a:"1.0";i={r:t.r,g:t.g,b:t.b,a:a}}if(void 0===i)throw new Error("Unknown color passed to the colorPicker. Supported are strings: rgb, hex, rgba. Object: rgb ({r:r,g:g,b:b,[a:a]}). Supplied: "+gv(t));this._setColor(i,e)}}},{key:"show",value:function(){void 0!==this.closeCallback&&(this.closeCallback(),this.closeCallback=void 0),this.applied=!1,this.frame.style.display="block",this._generateHueCircle()}},{key:"_hide",value:function(){var t=this,e=!(arguments.length>0&&void 0!==arguments[0])||arguments[0];!0===e&&(this.previousColor=un({},this.color)),!0===this.applied&&this.updateCallback(this.initialColor),this.frame.style.display="none",Sv((function(){void 0!==t.closeCallback&&(t.closeCallback(),t.closeCallback=void 0)}),0)}},{key:"_save",value:function(){this.updateCallback(this.color),this.applied=!1,this._hide()}},{key:"_apply",value:function(){this.applied=!0,this.updateCallback(this.color),this._updatePicker(this.color)}},{key:"_loadLast",value:function(){void 0!==this.previousColor?this.setColor(this.previousColor,!1):alert("There is no last color to load...")}},{key:"_setColor",value:function(t){var e=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];!0===e&&(this.initialColor=un({},t)),this.color=t;var i=ym(t.r,t.g,t.b),n=2*Math.PI,o=this.r*i.s,r=this.centerCoordinates.x+o*Math.sin(n*i.h),s=this.centerCoordinates.y+o*Math.cos(n*i.h);this.colorPickerSelector.style.left=r-.5*this.colorPickerSelector.clientWidth+"px",this.colorPickerSelector.style.top=s-.5*this.colorPickerSelector.clientHeight+"px",this._updatePicker(t)}},{key:"_setOpacity",value:function(t){this.color.a=t/100,this._updatePicker(this.color)}},{key:"_setBrightness",value:function(t){var e=ym(this.color.r,this.color.g,this.color.b);e.v=t/100;var i=wm(e.h,e.s,e.v);i.a=this.color.a,this.color=i,this._updatePicker()}},{key:"_updatePicker",value:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:this.color,e=ym(t.r,t.g,t.b),i=this.colorPickerCanvas.getContext("2d");void 0===this.pixelRation&&(this.pixelRatio=(window.devicePixelRatio||1)/(i.webkitBackingStorePixelRatio||i.mozBackingStorePixelRatio||i.msBackingStorePixelRatio||i.oBackingStorePixelRatio||i.backingStorePixelRatio||1)),i.setTransform(this.pixelRatio,0,0,this.pixelRatio,0,0);var n=this.colorPickerCanvas.clientWidth,o=this.colorPickerCanvas.clientHeight;i.clearRect(0,0,n,o),i.putImageData(this.hueCircle,0,0),i.fillStyle="rgba(0,0,0,"+(1-e.v)+")",i.circle(this.centerCoordinates.x,this.centerCoordinates.y,this.r),jv(i).call(i),this.brightnessRange.value=100*e.v,this.opacityRange.value=100*t.a,this.initialColorDiv.style.backgroundColor="rgba("+this.initialColor.r+","+this.initialColor.g+","+this.initialColor.b+","+this.initialColor.a+")",this.newColorDiv.style.backgroundColor="rgba("+this.color.r+","+this.color.g+","+this.color.b+","+this.color.a+")"}},{key:"_setSize",value:function(){this.colorPickerCanvas.style.width="100%",this.colorPickerCanvas.style.height="100%",this.colorPickerCanvas.width=289*this.pixelRatio,this.colorPickerCanvas.height=289*this.pixelRatio}},{key:"_create",value:function(){var t,e,i,n;if(this.frame=document.createElement("div"),this.frame.className="vis-color-picker",this.colorPickerDiv=document.createElement("div"),this.colorPickerSelector=document.createElement("div"),this.colorPickerSelector.className="vis-selector",this.colorPickerDiv.appendChild(this.colorPickerSelector),this.colorPickerCanvas=document.createElement("canvas"),this.colorPickerDiv.appendChild(this.colorPickerCanvas),this.colorPickerCanvas.getContext){var o=this.colorPickerCanvas.getContext("2d");this.pixelRatio=(window.devicePixelRatio||1)/(o.webkitBackingStorePixelRatio||o.mozBackingStorePixelRatio||o.msBackingStorePixelRatio||o.oBackingStorePixelRatio||o.backingStorePixelRatio||1),this.colorPickerCanvas.getContext("2d").setTransform(this.pixelRatio,0,0,this.pixelRatio,0,0)}else{var r=document.createElement("DIV");r.style.color="red",r.style.fontWeight="bold",r.style.padding="10px",r.innerText="Error: your browser does not support HTML canvas",this.colorPickerCanvas.appendChild(r)}this.colorPickerDiv.className="vis-color",this.opacityDiv=document.createElement("div"),this.opacityDiv.className="vis-opacity",this.brightnessDiv=document.createElement("div"),this.brightnessDiv.className="vis-brightness",this.arrowDiv=document.createElement("div"),this.arrowDiv.className="vis-arrow",this.opacityRange=document.createElement("input");try{this.opacityRange.type="range",this.opacityRange.min="0",this.opacityRange.max="100"}catch(t){}this.opacityRange.value="100",this.opacityRange.className="vis-range",this.brightnessRange=document.createElement("input");try{this.brightnessRange.type="range",this.brightnessRange.min="0",this.brightnessRange.max="100"}catch(t){}this.brightnessRange.value="100",this.brightnessRange.className="vis-range",this.opacityDiv.appendChild(this.opacityRange),this.brightnessDiv.appendChild(this.brightnessRange);var s=this;this.opacityRange.onchange=function(){s._setOpacity(this.value)},this.opacityRange.oninput=function(){s._setOpacity(this.value)},this.brightnessRange.onchange=function(){s._setBrightness(this.value)},this.brightnessRange.oninput=function(){s._setBrightness(this.value)},this.brightnessLabel=document.createElement("div"),this.brightnessLabel.className="vis-label vis-brightness",this.brightnessLabel.innerText="brightness:",this.opacityLabel=document.createElement("div"),this.opacityLabel.className="vis-label vis-opacity",this.opacityLabel.innerText="opacity:",this.newColorDiv=document.createElement("div"),this.newColorDiv.className="vis-new-color",this.newColorDiv.innerText="new",this.initialColorDiv=document.createElement("div"),this.initialColorDiv.className="vis-initial-color",this.initialColorDiv.innerText="initial",this.cancelButton=document.createElement("div"),this.cancelButton.className="vis-button vis-cancel",this.cancelButton.innerText="cancel",this.cancelButton.onclick=zn(t=this._hide).call(t,this,!1),this.applyButton=document.createElement("div"),this.applyButton.className="vis-button vis-apply",this.applyButton.innerText="apply",this.applyButton.onclick=zn(e=this._apply).call(e,this),this.saveButton=document.createElement("div"),this.saveButton.className="vis-button vis-save",this.saveButton.innerText="save",this.saveButton.onclick=zn(i=this._save).call(i,this),this.loadButton=document.createElement("div"),this.loadButton.className="vis-button vis-load",this.loadButton.innerText="load last",this.loadButton.onclick=zn(n=this._loadLast).call(n,this),this.frame.appendChild(this.colorPickerDiv),this.frame.appendChild(this.arrowDiv),this.frame.appendChild(this.brightnessLabel),this.frame.appendChild(this.brightnessDiv),this.frame.appendChild(this.opacityLabel),this.frame.appendChild(this.opacityDiv),this.frame.appendChild(this.newColorDiv),this.frame.appendChild(this.initialColorDiv),this.frame.appendChild(this.cancelButton),this.frame.appendChild(this.applyButton),this.frame.appendChild(this.saveButton),this.frame.appendChild(this.loadButton)}},{key:"_bindHammer",value:function(){var t=this;this.drag={},this.pinch={},this.hammer=new Hy(this.colorPickerCanvas),this.hammer.get("pinch").set({enable:!0}),this.hammer.on("hammer.input",(function(e){e.isFirst&&t._moveSelector(e)})),this.hammer.on("tap",(function(e){t._moveSelector(e)})),this.hammer.on("panstart",(function(e){t._moveSelector(e)})),this.hammer.on("panmove",(function(e){t._moveSelector(e)})),this.hammer.on("panend",(function(e){t._moveSelector(e)}))}},{key:"_generateHueCircle",value:function(){if(!1===this.generated){var t=this.colorPickerCanvas.getContext("2d");void 0===this.pixelRation&&(this.pixelRatio=(window.devicePixelRatio||1)/(t.webkitBackingStorePixelRatio||t.mozBackingStorePixelRatio||t.msBackingStorePixelRatio||t.oBackingStorePixelRatio||t.backingStorePixelRatio||1)),t.setTransform(this.pixelRatio,0,0,this.pixelRatio,0,0);var e,i,n,o,r=this.colorPickerCanvas.clientWidth,s=this.colorPickerCanvas.clientHeight;t.clearRect(0,0,r,s),this.centerCoordinates={x:.5*r,y:.5*s},this.r=.49*r;var a,h=2*Math.PI/360,l=1/this.r;for(n=0;n<360;n++)for(o=0;o<this.r;o++)e=this.centerCoordinates.x+o*Math.sin(h*n),i=this.centerCoordinates.y+o*Math.cos(h*n),a=wm(.002777777777777778*n,o*l,1),t.fillStyle="rgb("+a.r+","+a.g+","+a.b+")",t.fillRect(e-.5,i-.5,2,2);t.strokeStyle="rgba(0,0,0,1)",t.circle(this.centerCoordinates.x,this.centerCoordinates.y,this.r),t.stroke(),this.hueCircle=t.getImageData(0,0,r,s)}this.generated=!0}},{key:"_moveSelector",value:function(t){var e=this.colorPickerDiv.getBoundingClientRect(),i=t.center.x-e.left,n=t.center.y-e.top,o=.5*this.colorPickerDiv.clientHeight,r=.5*this.colorPickerDiv.clientWidth,s=i-r,a=n-o,h=Math.atan2(s,a),l=.98*Math.min(Math.sqrt(s*s+a*a),r),d=Math.cos(h)*l+o,c=Math.sin(h)*l+r;this.colorPickerSelector.style.top=d-.5*this.colorPickerSelector.clientHeight+"px",this.colorPickerSelector.style.left=c-.5*this.colorPickerSelector.clientWidth+"px";var u=h/(2*Math.PI);u=u<0?u+1:u;var f=l/this.r,p=ym(this.color.r,this.color.g,this.color.b);p.h=u,p.s=f;var v=wm(p.h,p.s,p.v);v.a=this.color.a,this.color=v,this.initialColorDiv.style.backgroundColor="rgba("+this.initialColor.r+","+this.initialColor.g+","+this.initialColor.b+","+this.initialColor.a+")",this.newColorDiv.style.backgroundColor="rgba("+this.color.r+","+this.color.g+","+this.color.b+","+this.color.a+")"}}]),t}();function Im(){for(var t=arguments.length,e=new Array(t),i=0;i<t;i++)e[i]=arguments[i];if(e.length<1)throw new TypeError("Invalid arguments.");if(1===e.length)return document.createTextNode(e[0]);var n=document.createElement(e[0]);return n.appendChild(Im.apply(void 0,Jc(au(e).call(e,1)))),n}var Bm,zm=function(){function t(e,i,n){var o=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:function(){return!1};Yd(this,t),this.parent=e,this.changedOptions=[],this.container=i,this.allowCreation=!1,this.hideOption=r,this.options={},this.initialized=!1,this.popupCounter=0,this.defaultOptions={enabled:!1,filter:!0,container:void 0,showButton:!0},un(this.options,this.defaultOptions),this.configureOptions=n,this.moduleOptions={},this.domElements=[],this.popupDiv={},this.popupLimit=5,this.popupHistory={},this.colorPicker=new Dm(o),this.wrapper=void 0}return Kd(t,[{key:"setOptions",value:function(t){if(void 0!==t){this.popupHistory={},this._removePopup();var e=!0;if("string"==typeof t)this.options.filter=t;else if(lu(t))this.options.filter=t.join();else if("object"===Qc(t)){if(null==t)throw new TypeError("options cannot be null");void 0!==t.container&&(this.options.container=t.container),void 0!==Xf(t)&&(this.options.filter=Xf(t)),void 0!==t.showButton&&(this.options.showButton=t.showButton),void 0!==t.enabled&&(e=t.enabled)}else"boolean"==typeof t?(this.options.filter=!0,e=t):"function"==typeof t&&(this.options.filter=t,e=!0);!1===Xf(this.options)&&(e=!1),this.options.enabled=e}this._clean()}},{key:"setModuleOptions",value:function(t){this.moduleOptions=t,!0===this.options.enabled&&(this._clean(),void 0!==this.options.container&&(this.container=this.options.container),this._create())}},{key:"_create",value:function(){this._clean(),this.changedOptions=[];var t=Xf(this.options),e=0,i=!1;for(var n in this.configureOptions)Object.prototype.hasOwnProperty.call(this.configureOptions,n)&&(this.allowCreation=!1,i=!1,"function"==typeof t?i=(i=t(n,[]))||this._handleObject(this.configureOptions[n],[n],!0):!0!==t&&-1===Fp(t).call(t,n)||(i=!0),!1!==i&&(this.allowCreation=!0,e>0&&this._makeItem([]),this._makeHeader(n),this._handleObject(this.configureOptions[n],[n])),e++);this._makeButton(),this._push()}},{key:"_push",value:function(){this.wrapper=document.createElement("div"),this.wrapper.className="vis-configuration-wrapper",this.container.appendChild(this.wrapper);for(var t=0;t<this.domElements.length;t++)this.wrapper.appendChild(this.domElements[t]);this._showPopupIfNeeded()}},{key:"_clean",value:function(){for(var t=0;t<this.domElements.length;t++)this.wrapper.removeChild(this.domElements[t]);void 0!==this.wrapper&&(this.container.removeChild(this.wrapper),this.wrapper=void 0),this.domElements=[],this._removePopup()}},{key:"_getValue",value:function(t){for(var e=this.moduleOptions,i=0;i<t.length;i++){if(void 0===e[t[i]]){e=void 0;break}e=e[t[i]]}return e}},{key:"_makeItem",value:function(t){if(!0===this.allowCreation){var e=document.createElement("div");e.className="vis-configuration vis-config-item vis-config-s"+t.length;for(var i=arguments.length,n=new Array(i>1?i-1:0),o=1;o<i;o++)n[o-1]=arguments[o];return Fu(n).call(n,(function(t){e.appendChild(t)})),this.domElements.push(e),this.domElements.length}return 0}},{key:"_makeHeader",value:function(t){var e=document.createElement("div");e.className="vis-configuration vis-config-header",e.innerText=t,this._makeItem([],e)}},{key:"_makeLabel",value:function(t,e){var i=arguments.length>2&&void 0!==arguments[2]&&arguments[2],n=document.createElement("div");if(n.className="vis-configuration vis-config-label vis-config-s"+e.length,!0===i){for(;n.firstChild;)n.removeChild(n.firstChild);n.appendChild(Im("i","b",t))}else n.innerText=t+":";return n}},{key:"_makeDropdown",value:function(t,e,i){var n=document.createElement("select");n.className="vis-configuration vis-config-select";var o=0;void 0!==e&&-1!==Fp(t).call(t,e)&&(o=Fp(t).call(t,e));for(var r=0;r<t.length;r++){var s=document.createElement("option");s.value=t[r],r===o&&(s.selected="selected"),s.innerText=t[r],n.appendChild(s)}var a=this;n.onchange=function(){a._update(this.value,i)};var h=this._makeLabel(i[i.length-1],i);this._makeItem(i,h,n)}},{key:"_makeRange",value:function(t,e,i){var n=t[0],o=t[1],r=t[2],s=t[3],a=document.createElement("input");a.className="vis-configuration vis-config-range";try{a.type="range",a.min=o,a.max=r}catch(t){}a.step=s;var h="",l=0;if(void 0!==e){var d=1.2;e<0&&e*d<o?(a.min=Math.ceil(e*d),l=a.min,h="range increased"):e/d<o&&(a.min=Math.ceil(e/d),l=a.min,h="range increased"),e*d>r&&1!==r&&(a.max=Math.ceil(e*d),l=a.max,h="range increased"),a.value=e}else a.value=n;var c=document.createElement("input");c.className="vis-configuration vis-config-rangeinput",c.value=a.value;var u=this;a.onchange=function(){c.value=this.value,u._update(Number(this.value),i)},a.oninput=function(){c.value=this.value};var f=this._makeLabel(i[i.length-1],i),p=this._makeItem(i,f,a,c);""!==h&&this.popupHistory[p]!==l&&(this.popupHistory[p]=l,this._setupPopup(h,p))}},{key:"_makeButton",value:function(){var t=this;if(!0===this.options.showButton){var e=document.createElement("div");e.className="vis-configuration vis-config-button",e.innerText="generate options",e.onclick=function(){t._printOptions()},e.onmouseover=function(){e.className="vis-configuration vis-config-button hover"},e.onmouseout=function(){e.className="vis-configuration vis-config-button"},this.optionsContainer=document.createElement("div"),this.optionsContainer.className="vis-configuration vis-config-option-container",this.domElements.push(this.optionsContainer),this.domElements.push(e)}}},{key:"_setupPopup",value:function(t,e){var i=this;if(!0===this.initialized&&!0===this.allowCreation&&this.popupCounter<this.popupLimit){var n=document.createElement("div");n.id="vis-configuration-popup",n.className="vis-configuration-popup",n.innerText=t,n.onclick=function(){i._removePopup()},this.popupCounter+=1,this.popupDiv={html:n,index:e}}}},{key:"_removePopup",value:function(){void 0!==this.popupDiv.html&&(this.popupDiv.html.parentNode.removeChild(this.popupDiv.html),clearTimeout(this.popupDiv.hideTimeout),clearTimeout(this.popupDiv.deleteTimeout),this.popupDiv={})}},{key:"_showPopupIfNeeded",value:function(){var t=this;if(void 0!==this.popupDiv.html){var e=this.domElements[this.popupDiv.index].getBoundingClientRect();this.popupDiv.html.style.left=e.left+"px",this.popupDiv.html.style.top=e.top-30+"px",document.body.appendChild(this.popupDiv.html),this.popupDiv.hideTimeout=Sv((function(){t.popupDiv.html.style.opacity=0}),1500),this.popupDiv.deleteTimeout=Sv((function(){t._removePopup()}),1800)}}},{key:"_makeCheckbox",value:function(t,e,i){var n=document.createElement("input");n.type="checkbox",n.className="vis-configuration vis-config-checkbox",n.checked=t,void 0!==e&&(n.checked=e,e!==t&&("object"===Qc(t)?e!==t.enabled&&this.changedOptions.push({path:i,value:e}):this.changedOptions.push({path:i,value:e})));var o=this;n.onchange=function(){o._update(this.checked,i)};var r=this._makeLabel(i[i.length-1],i);this._makeItem(i,r,n)}},{key:"_makeTextInput",value:function(t,e,i){var n=document.createElement("input");n.type="text",n.className="vis-configuration vis-config-text",n.value=e,e!==t&&this.changedOptions.push({path:i,value:e});var o=this;n.onchange=function(){o._update(this.value,i)};var r=this._makeLabel(i[i.length-1],i);this._makeItem(i,r,n)}},{key:"_makeColorField",value:function(t,e,i){var n=this,o=t[1],r=document.createElement("div");"none"!==(e=void 0===e?o:e)?(r.className="vis-configuration vis-config-colorBlock",r.style.backgroundColor=e):r.className="vis-configuration vis-config-colorBlock none",e=void 0===e?o:e,r.onclick=function(){n._showColorPicker(e,r,i)};var s=this._makeLabel(i[i.length-1],i);this._makeItem(i,s,r)}},{key:"_showColorPicker",value:function(t,e,i){var n=this;e.onclick=function(){},this.colorPicker.insertTo(e),this.colorPicker.show(),this.colorPicker.setColor(t),this.colorPicker.setUpdateCallback((function(t){var o="rgba("+t.r+","+t.g+","+t.b+","+t.a+")";e.style.backgroundColor=o,n._update(o,i)})),this.colorPicker.setCloseCallback((function(){e.onclick=function(){n._showColorPicker(t,e,i)}}))}},{key:"_handleObject",value:function(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[],i=arguments.length>2&&void 0!==arguments[2]&&arguments[2],n=!1,o=Xf(this.options),r=!1;for(var s in t)if(Object.prototype.hasOwnProperty.call(t,s)){n=!0;var a=t[s],h=om(e,s);if("function"==typeof o&&!1===(n=o(s,e))&&!lu(a)&&"string"!=typeof a&&"boolean"!=typeof a&&a instanceof Object&&(this.allowCreation=!1,n=this._handleObject(a,h,!0),this.allowCreation=!1===i),!1!==n){r=!0;var l=this._getValue(h);if(lu(a))this._handleArray(a,l,h);else if("string"==typeof a)this._makeTextInput(a,l,h);else if("boolean"==typeof a)this._makeCheckbox(a,l,h);else if(a instanceof Object){if(!this.hideOption(e,s,this.moduleOptions))if(void 0!==a.enabled){var d=om(h,"enabled"),c=this._getValue(d);if(!0===c){var u=this._makeLabel(s,h,!0);this._makeItem(h,u),r=this._handleObject(a,h)||r}else this._makeCheckbox(a,c,h)}else{var f=this._makeLabel(s,h,!0);this._makeItem(h,f),r=this._handleObject(a,h)||r}}else console.error("dont know how to handle",a,s,h)}}return r}},{key:"_handleArray",value:function(t,e,i){"string"==typeof t[0]&&"color"===t[0]?(this._makeColorField(t,e,i),t[1]!==e&&this.changedOptions.push({path:i,value:e})):"string"==typeof t[0]?(this._makeDropdown(t,e,i),t[0]!==e&&this.changedOptions.push({path:i,value:e})):"number"==typeof t[0]&&(this._makeRange(t,e,i),t[0]!==e&&this.changedOptions.push({path:i,value:Number(e)}))}},{key:"_update",value:function(t,e){var i=this._constructOptions(t,e);this.parent.body&&this.parent.body.emitter&&this.parent.body.emitter.emit&&this.parent.body.emitter.emit("configChange",i),this.initialized=!0,this.parent.setOptions(i)}},{key:"_constructOptions",value:function(t,e){var i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},n=i;t="false"!==(t="true"===t||t)&&t;for(var o=0;o<e.length;o++)"global"!==e[o]&&(void 0===n[e[o]]&&(n[e[o]]={}),o!==e.length-1?n=n[e[o]]:n[e[o]]=t);return i}},{key:"_printOptions",value:function(){for(var t=this.getOptions();this.optionsContainer.firstChild;)this.optionsContainer.removeChild(this.optionsContainer.firstChild);this.optionsContainer.appendChild(Im("pre","const options = "+gv(t,null,2)))}},{key:"getOptions",value:function(){for(var t={},e=0;e<this.changedOptions.length;e++)this._constructOptions(this.changedOptions[e].value,this.changedOptions[e].path,t);return t}}]),t}(),Nm=function(){function t(e,i){Yd(this,t),this.container=e,this.overflowMethod=i||"cap",this.x=0,this.y=0,this.padding=5,this.hidden=!1,this.frame=document.createElement("div"),this.frame.className="vis-tooltip",this.container.appendChild(this.frame)}return Kd(t,[{key:"setPosition",value:function(t,e){this.x=Ep(t),this.y=Ep(e)}},{key:"setText",value:function(t){if(t instanceof Element){for(;this.frame.firstChild;)this.frame.removeChild(this.frame.firstChild);this.frame.appendChild(t)}else this.frame.innerText=t}},{key:"show",value:function(t){if(void 0===t&&(t=!0),!0===t){var e=this.frame.clientHeight,i=this.frame.clientWidth,n=this.frame.parentNode.clientHeight,o=this.frame.parentNode.clientWidth,r=0,s=0;if("flip"==this.overflowMethod){var a=!1,h=!0;this.y-e<this.padding&&(h=!1),this.x+i>o-this.padding&&(a=!0),r=a?this.x-i:this.x,s=h?this.y-e:this.y}else(s=this.y-e)+e+this.padding>n&&(s=n-e-this.padding),s<this.padding&&(s=this.padding),(r=this.x)+i+this.padding>o&&(r=o-i-this.padding),r<this.padding&&(r=this.padding);this.frame.style.left=r+"px",this.frame.style.top=s+"px",this.frame.style.visibility="visible",this.hidden=!1}else this.hide()}},{key:"hide",value:function(){this.hidden=!0,this.frame.style.left="0",this.frame.style.top="0",this.frame.style.visibility="hidden"}},{key:"destroy",value:function(){this.frame.parentNode.removeChild(this.frame)}}]),t}(),Fm=!1,Am="background: #FFeeee; color: #dd0000",jm=function(){function t(){Yd(this,t)}return Kd(t,null,[{key:"validate",value:function(e,i,n){Fm=!1,Bm=i;var o=i;return void 0!==n&&(o=i[n]),t.parse(e,o,[]),Fm}},{key:"parse",value:function(e,i,n){for(var o in e)Object.prototype.hasOwnProperty.call(e,o)&&t.check(o,e,i,n)}},{key:"check",value:function(e,i,n,o){if(void 0!==n[e]||void 0!==n.__any__){var r=e,s=!0;void 0===n[e]&&void 0!==n.__any__&&(r="__any__",s="object"===t.getType(i[e]));var a=n[r];s&&void 0!==a.__type__&&(a=a.__type__),t.checkFields(e,i,n,r,a,o)}else t.getSuggestion(e,n,o)}},{key:"checkFields",value:function(e,i,n,o,r,s){var a=function(i){console.error("%c"+i+t.printLocation(s,e),Am)},h=t.getType(i[e]),l=r[h];void 0!==l?"array"===t.getType(l)&&-1===Fp(l).call(l,i[e])?(a('Invalid option detected in "'+e+'". Allowed values are:'+t.print(l)+' not "'+i[e]+'". '),Fm=!0):"object"===h&&"__any__"!==o&&(s=om(s,e),t.parse(i[e],n[o],s)):void 0===r.any&&(a('Invalid type received for "'+e+'". Expected: '+t.print(bu(r))+". Received ["+h+'] "'+i[e]+'"'),Fm=!0)}},{key:"getType",value:function(t){var e=Qc(t);return"object"===e?null===t?"null":t instanceof Boolean?"boolean":t instanceof Number?"number":t instanceof String?"string":lu(t)?"array":t instanceof Date?"date":void 0!==t.nodeType?"dom":!0===t._isAMomentObject?"moment":"object":"number"===e?"number":"boolean"===e?"boolean":"string"===e?"string":void 0===e?"undefined":e}},{key:"getSuggestion",value:function(e,i,n){var o,r=t.findInOptions(e,i,n,!1),s=t.findInOptions(e,Bm,[],!0);o=void 0!==r.indexMatch?" in "+t.printLocation(r.path,e,"")+'Perhaps it was incomplete? Did you mean: "'+r.indexMatch+'"?\n\n':s.distance<=4&&r.distance>s.distance?" in "+t.printLocation(r.path,e,"")+"Perhaps it was misplaced? Matching option found at: "+t.printLocation(s.path,s.closestMatch,""):r.distance<=8?'. Did you mean "'+r.closestMatch+'"?'+t.printLocation(r.path,e):". Did you mean one of these: "+t.print(bu(i))+t.printLocation(n,e),console.error('%cUnknown option detected: "'+e+'"'+o,Am),Fm=!0}},{key:"findInOptions",value:function(e,i,n){var o=arguments.length>3&&void 0!==arguments[3]&&arguments[3],r=1e9,s="",a=[],h=e.toLowerCase(),l=void 0;for(var d in i){var c=void 0;if(void 0!==i[d].__type__&&!0===o){var u=t.findInOptions(e,i[d],om(n,d));r>u.distance&&(s=u.closestMatch,a=u.path,r=u.distance,l=u.indexMatch)}else{var f;-1!==Fp(f=d.toLowerCase()).call(f,h)&&(l=d),r>(c=t.levenshteinDistance(e,d))&&(s=d,a=rm(n),r=c)}}return{closestMatch:s,path:a,distance:r,indexMatch:l}}},{key:"printLocation",value:function(t,e){for(var i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"Problem value found at: \n",n="\n\n"+i+"options = {\n",o=0;o<t.length;o++){for(var r=0;r<o+1;r++)n+="  ";n+=t[o]+": {\n"}for(var s=0;s<t.length+1;s++)n+="  ";n+=e+"\n";for(var a=0;a<t.length+1;a++){for(var h=0;h<t.length-a;h++)n+="  ";n+="}\n"}return n+"\n\n"}},{key:"print",value:function(t){return gv(t).replace(/(")|(\[)|(\])|(,"__type__")/g,"").replace(/(,)/g,", ")}},{key:"levenshteinDistance",value:function(t,e){if(0===t.length)return e.length;if(0===e.length)return t.length;var i,n,o=[];for(i=0;i<=e.length;i++)o[i]=[i];for(n=0;n<=t.length;n++)o[0][n]=n;for(i=1;i<=e.length;i++)for(n=1;n<=t.length;n++)e.charAt(i-1)==t.charAt(n-1)?o[i][n]=o[i-1][n-1]:o[i][n]=Math.min(o[i-1][n-1]+1,Math.min(o[i][n-1]+1,o[i-1][n]+1));return o[e.length][t.length]}}]),t}(),Rm=Wy,Lm=Dm,Hm=zm,Wm=Hy,qm=Nm,Vm=Am,Um=jm,Ym=Object.freeze({__proto__:null,Activator:Rm,Alea:jy,ColorPicker:Lm,Configurator:Hm,DELETE:Iy,HSVToHex:km,HSVToRGB:wm,Hammer:Wm,Popup:qm,RGBToHSV:ym,RGBToHex:vm,VALIDATOR_PRINT_STYLE:Vm,Validator:Um,addClassName:function(t,e){var i=t.className.split(" "),n=e.split(" ");i=su(i).call(i,Xf(n).call(n,(function(t){return!Nf(i).call(i,t)}))),t.className=i.join(" ")},addCssText:function(t,e){var i=mm(t.style.cssText),n=mm(e),o=My(My({},i),n);t.style.cssText=bm(o)},addEventListener:dm,binarySearchCustom:function(t,e,i,n){for(var o=0,r=0,s=t.length-1;r<=s&&o<1e4;){var a=Math.floor((r+s)/2),h=t[a],l=e(void 0===n?h[i]:h[i][n]);if(0==l)return a;-1==l?r=a+1:s=a-1,o++}return-1},binarySearchValue:function(t,e,i,n,o){var r,s,a,h,l=0,d=0,c=t.length-1;for(o=null!=o?o:function(t,e){return t==e?0:t<e?-1:1};d<=c&&l<1e4;){if(h=Math.floor(.5*(c+d)),r=t[Math.max(0,h-1)][i],s=t[h][i],a=t[Math.min(t.length-1,h+1)][i],0==o(s,e))return h;if(o(r,e)<0&&o(s,e)>0)return"before"==n?Math.max(0,h-1):h;if(o(s,e)<0&&o(a,e)>0)return"before"==n?h:Math.min(t.length-1,h+1);o(s,e)<0?d=h+1:c=h-1,l++}return-1},bridgeObject:Cm,copyAndExtendArray:om,copyArray:rm,deepExtend:nm,deepObjectAssign:zy,easingFunctions:Tm,equalArray:function(t,e){if(t.length!==e.length)return!1;for(var i=0,n=t.length;i<n;i++)if(t[i]!=e[i])return!1;return!0},extend:tm,fillIfDefined:Jy,forEach:hm,getAbsoluteLeft:sm,getAbsoluteRight:function(t){return t.getBoundingClientRect().right},getAbsoluteTop:am,getScrollBarWidth:function(){var t=document.createElement("p");t.style.width="100%",t.style.height="200px";var e=document.createElement("div");e.style.position="absolute",e.style.top="0px",e.style.left="0px",e.style.visibility="hidden",e.style.width="200px",e.style.height="150px",e.style.overflow="hidden",e.appendChild(t),document.body.appendChild(e);var i=t.offsetWidth;e.style.overflow="scroll";var n=t.offsetWidth;return i==n&&(n=e.clientWidth),document.body.removeChild(e),i-n},getTarget:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:window.event,e=null;return t&&(t.target?e=t.target:t.srcElement&&(e=t.srcElement)),e instanceof Element&&(null==e.nodeType||3!=e.nodeType||(e=e.parentNode)instanceof Element)?e:null},getType:function(t){var e=Qc(t);return"object"===e?null===t?"null":t instanceof Boolean?"Boolean":t instanceof Number?"Number":t instanceof String?"String":lu(t)?"Array":t instanceof Date?"Date":"Object":"number"===e?"Number":"boolean"===e?"Boolean":"string"===e?"String":void 0===e?"undefined":e},hasParent:function(t,e){for(var i=t;i;){if(i===e)return!0;if(!i.parentNode)return!1;i=i.parentNode}return!1},hexToHSV:_m,hexToRGB:fm,insertSort:function(t,e){for(var i=0;i<t.length;i++){var n=t[i],o=void 0;for(o=i;o>0&&e(n,t[o-1])<0;o--)t[o]=t[o-1];t[o]=n}return t},isDate:function(t){if(t instanceof Date)return!0;if($y(t)){if(qy.exec(t))return!0;if(!isNaN(Date.parse(t)))return!0}return!1},isNumber:Gy,isObject:Zy,isString:$y,isValidHex:xm,isValidRGB:Em,isValidRGBA:Om,mergeOptions:Sm,option:um,overrideOpacity:pm,parseColor:gm,preventDefault:function(t){t||(t=window.event),t&&(t.preventDefault?t.preventDefault():t.returnValue=!1)},pureDeepObjectAssign:By,recursiveDOMDelete:Ky,removeClassName:function(t,e){var i=t.className.split(" "),n=e.split(" ");i=Xf(i).call(i,(function(t){return!Nf(n).call(n,t)})),t.className=i.join(" ")},removeCssText:function(t,e){var i=mm(t.style.cssText),n=mm(e);for(var o in n)Object.prototype.hasOwnProperty.call(n,o)&&delete i[o];t.style.cssText=bm(i)},removeEventListener:cm,selectiveBridgeObject:function(t,e){if(null!==e&&"object"===Qc(e)){for(var i=Kp(e),n=0;n<t.length;n++)Object.prototype.hasOwnProperty.call(e,t[n])&&"object"==Qc(e[t[n]])&&(i[t[n]]=Cm(e[t[n]]));return i}return null},selectiveDeepExtend:em,selectiveExtend:function(t,e){if(!lu(t))throw new Error("Array with property names expected as first argument");for(var i=arguments.length,n=new Array(i>2?i-2:0),o=2;o<i;o++)n[o-2]=arguments[o];for(var r=0,s=n;r<s.length;r++)for(var a=s[r],h=0;h<t.length;h++){var l=t[h];a&&Object.prototype.hasOwnProperty.call(a,l)&&(e[l]=a[l])}return e},selectiveNotDeepExtend:im,throttle:function(t){var e=!1;return function(){e||(e=!0,requestAnimationFrame((function(){e=!1,t()})))}},toArray:lm,topMost:Mm,updateProperty:function(t,e,i){return t[e]!==i&&(t[e]=i,!0)}});function Xm(t){return eb=t,function(){var t={};ib=0,void(nb=eb.charAt(0)),pb(),"strict"===ob&&(t.strict=!0,pb());"graph"!==ob&&"digraph"!==ob||(t.type=ob,pb());rb===Qm&&(t.id=ob,pb());if("{"!=ob)throw wb("Angle bracket { expected");if(pb(),vb(t),"}"!=ob)throw wb("Angle bracket } expected");if(pb(),""!==ob)throw wb("End of file expected");return pb(),delete t.node,delete t.edge,delete t.graph,t}()}var Gm={fontsize:"font.size",fontcolor:"font.color",labelfontcolor:"font.color",fontname:"font.face",color:["color.border","color.background"],fillcolor:"color.background",tooltip:"title",labeltooltip:"title"},Km=Kp(Gm);Km.color="color.color",Km.style="dashes";var $m=0,Zm=1,Qm=2,Jm=3,tb={"{":!0,"}":!0,"[":!0,"]":!0,";":!0,"=":!0,",":!0,"->":!0,"--":!0},eb="",ib=0,nb="",ob="",rb=$m;function sb(){ib++,nb=eb.charAt(ib)}function ab(){return eb.charAt(ib+1)}function hb(t){var e=t.charCodeAt(0);return e<47?35===e||46===e:e<59?e>47:e<91?e>64:e<96?95===e:e<123&&e>96}function lb(t,e){if(t||(t={}),e)for(var i in e)e.hasOwnProperty(i)&&(t[i]=e[i]);return t}function db(t,e,i){for(var n=e.split("."),o=t;n.length;){var r=n.shift();n.length?(o[r]||(o[r]={}),o=o[r]):o[r]=i}}function cb(t,e){for(var i,n,o=null,r=[t],s=t;s.parent;)r.push(s.parent),s=s.parent;if(s.nodes)for(i=0,n=s.nodes.length;i<n;i++)if(e.id===s.nodes[i].id){o=s.nodes[i];break}for(o||(o={id:e.id},t.node&&(o.attr=lb(o.attr,t.node))),i=r.length-1;i>=0;i--){var a,h=r[i];h.nodes||(h.nodes=[]),-1===Fp(a=h.nodes).call(a,o)&&h.nodes.push(o)}e.attr&&(o.attr=lb(o.attr,e.attr))}function ub(t,e){if(t.edges||(t.edges=[]),t.edges.push(e),t.edge){var i=lb({},t.edge);e.attr=lb(i,e.attr)}}function fb(t,e,i,n,o){var r={from:e,to:i,type:n};return t.edge&&(r.attr=lb({},t.edge)),r.attr=lb(r.attr||{},o),null!=o&&o.hasOwnProperty("arrows")&&null!=o.arrows&&(r.arrows={to:{enabled:!0,type:o.arrows.type}},o.arrows=null),r}function pb(){for(rb=$m,ob="";" "===nb||"\t"===nb||"\n"===nb||"\r"===nb;)sb();do{var t=!1;if("#"===nb){for(var e=ib-1;" "===eb.charAt(e)||"\t"===eb.charAt(e);)e--;if("\n"===eb.charAt(e)||""===eb.charAt(e)){for(;""!=nb&&"\n"!=nb;)sb();t=!0}}if("/"===nb&&"/"===ab()){for(;""!=nb&&"\n"!=nb;)sb();t=!0}if("/"===nb&&"*"===ab()){for(;""!=nb;){if("*"===nb&&"/"===ab()){sb(),sb();break}sb()}t=!0}for(;" "===nb||"\t"===nb||"\n"===nb||"\r"===nb;)sb()}while(t);if(""!==nb){var i=nb+ab();if(tb[i])return rb=Zm,ob=i,sb(),void sb();if(tb[nb])return rb=Zm,ob=nb,void sb();if(hb(nb)||"-"===nb){for(ob+=nb,sb();hb(nb);)ob+=nb,sb();return"false"===ob?ob=!1:"true"===ob?ob=!0:isNaN(Number(ob))||(ob=Number(ob)),void(rb=Qm)}if('"'===nb){for(sb();""!=nb&&('"'!=nb||'"'===nb&&'"'===ab());)'"'===nb?(ob+=nb,sb()):"\\"===nb&&"n"===ab()?(ob+="\n",sb()):ob+=nb,sb();if('"'!=nb)throw wb('End of string " expected');return sb(),void(rb=Qm)}for(rb=Jm;""!=nb;)ob+=nb,sb();throw new SyntaxError('Syntax error in part "'+kb(ob,30)+'"')}rb=Zm}function vb(t){for(;""!==ob&&"}"!=ob;)gb(t),";"===ob&&pb()}function gb(t){var e=yb(t);if(e)mb(t,e);else{var i=function(t){if("node"===ob)return pb(),t.node=bb(),"node";if("edge"===ob)return pb(),t.edge=bb(),"edge";if("graph"===ob)return pb(),t.graph=bb(),"graph";return null}(t);if(!i){if(rb!=Qm)throw wb("Identifier expected");var n=ob;if(pb(),"="===ob){if(pb(),rb!=Qm)throw wb("Identifier expected");t[n]=ob,pb()}else!function(t,e){var i={id:e},n=bb();n&&(i.attr=n);cb(t,i),mb(t,e)}(t,n)}}}function yb(t){var e=null;if("subgraph"===ob&&((e={}).type="subgraph",pb(),rb===Qm&&(e.id=ob,pb())),"{"===ob){if(pb(),e||(e={}),e.parent=t,e.node=t.node,e.edge=t.edge,e.graph=t.graph,vb(e),"}"!=ob)throw wb("Angle bracket } expected");pb(),delete e.node,delete e.edge,delete e.graph,delete e.parent,t.subgraphs||(t.subgraphs=[]),t.subgraphs.push(e)}return e}function mb(t,e){for(;"->"===ob||"--"===ob;){var i,n=ob;pb();var o=yb(t);if(o)i=o;else{if(rb!=Qm)throw wb("Identifier or subgraph expected");cb(t,{id:i=ob}),pb()}ub(t,fb(t,e,i,n,bb())),e=i}}function bb(){for(var t,e,i=null,n={dashed:!0,solid:!1,dotted:[1,5]},o={dot:"circle",box:"box",crow:"crow",curve:"curve",icurve:"inv_curve",normal:"triangle",inv:"inv_triangle",diamond:"diamond",tee:"bar",vee:"vee"},r=new Array,s=new Array;"["===ob;){for(pb(),i={};""!==ob&&"]"!=ob;){if(rb!=Qm)throw wb("Attribute name expected");var a=ob;if(pb(),"="!=ob)throw wb("Equal sign = expected");if(pb(),rb!=Qm)throw wb("Attribute value expected");var h=ob;"style"===a&&(h=n[h]),"arrowhead"===a&&(a="arrows",h={to:{enabled:!0,type:o[h]}}),"arrowtail"===a&&(a="arrows",h={from:{enabled:!0,type:o[h]}}),r.push({attr:i,name:a,value:h}),s.push(a),pb(),","==ob&&pb()}if("]"!=ob)throw wb("Bracket ] expected");pb()}if(Nf(s).call(s,"dir")){var l={arrows:{}};for(t=0;t<r.length;t++)if("arrows"===r[t].name)if(null!=r[t].value.to)l.arrows.to=t;else{if(null==r[t].value.from)throw wb("Invalid value of arrows");l.arrows.from=t}else"dir"===r[t].name&&(l.dir=t);var d,c,u=r[l.dir].value;if(!Nf(s).call(s,"arrows"))if("both"===u)r.push({attr:r[l.dir].attr,name:"arrows",value:{to:{enabled:!0}}}),l.arrows.to=r.length-1,r.push({attr:r[l.dir].attr,name:"arrows",value:{from:{enabled:!0}}}),l.arrows.from=r.length-1;else if("forward"===u)r.push({attr:r[l.dir].attr,name:"arrows",value:{to:{enabled:!0}}}),l.arrows.to=r.length-1;else if("back"===u)r.push({attr:r[l.dir].attr,name:"arrows",value:{from:{enabled:!0}}}),l.arrows.from=r.length-1;else{if("none"!==u)throw wb('Invalid dir type "'+u+'"');r.push({attr:r[l.dir].attr,name:"arrows",value:""}),l.arrows.to=r.length-1}if("both"===u)l.arrows.to&&l.arrows.from?(c=r[l.arrows.to].value.to.type,d=r[l.arrows.from].value.from.type,r[l.arrows.to]={attr:r[l.arrows.to].attr,name:r[l.arrows.to].name,value:{to:{enabled:!0,type:c},from:{enabled:!0,type:d}}},ff(r).call(r,l.arrows.from,1)):l.arrows.to?(c=r[l.arrows.to].value.to.type,d="arrow",r[l.arrows.to]={attr:r[l.arrows.to].attr,name:r[l.arrows.to].name,value:{to:{enabled:!0,type:c},from:{enabled:!0,type:d}}}):l.arrows.from&&(c="arrow",d=r[l.arrows.from].value.from.type,r[l.arrows.from]={attr:r[l.arrows.from].attr,name:r[l.arrows.from].name,value:{to:{enabled:!0,type:c},from:{enabled:!0,type:d}}});else if("back"===u)l.arrows.to&&l.arrows.from?(c="",d=r[l.arrows.from].value.from.type,r[l.arrows.from]={attr:r[l.arrows.from].attr,name:r[l.arrows.from].name,value:{to:{enabled:!0,type:c},from:{enabled:!0,type:d}}}):l.arrows.to?(c="",d="arrow",l.arrows.from=l.arrows.to,r[l.arrows.from]={attr:r[l.arrows.from].attr,name:r[l.arrows.from].name,value:{to:{enabled:!0,type:c},from:{enabled:!0,type:d}}}):l.arrows.from&&(c="",d=r[l.arrows.from].value.from.type,r[l.arrows.to]={attr:r[l.arrows.from].attr,name:r[l.arrows.from].name,value:{to:{enabled:!0,type:c},from:{enabled:!0,type:d}}}),r[l.arrows.from]={attr:r[l.arrows.from].attr,name:r[l.arrows.from].name,value:{from:{enabled:!0,type:r[l.arrows.from].value.from.type}}};else if("none"===u){var f;r[f=l.arrows.to?l.arrows.to:l.arrows.from]={attr:r[f].attr,name:r[f].name,value:""}}else{if("forward"!==u)throw wb('Invalid dir type "'+u+'"');l.arrows.to&&l.arrows.from||l.arrows.to?(c=r[l.arrows.to].value.to.type,d="",r[l.arrows.to]={attr:r[l.arrows.to].attr,name:r[l.arrows.to].name,value:{to:{enabled:!0,type:c},from:{enabled:!0,type:d}}}):l.arrows.from&&(c="arrow",d="",l.arrows.to=l.arrows.from,r[l.arrows.to]={attr:r[l.arrows.to].attr,name:r[l.arrows.to].name,value:{to:{enabled:!0,type:c},from:{enabled:!0,type:d}}}),r[l.arrows.to]={attr:r[l.arrows.to].attr,name:r[l.arrows.to].name,value:{to:{enabled:!0,type:r[l.arrows.to].value.to.type}}}}ff(r).call(r,l.dir,1)}if(Nf(s).call(s,"penwidth")){var p=[];for(e=r.length,t=0;t<e;t++)"width"!==r[t].name&&("penwidth"===r[t].name&&(r[t].name="width"),p.push(r[t]));r=p}for(e=r.length,t=0;t<e;t++)db(r[t].attr,r[t].name,r[t].value);return i}function wb(t){return new SyntaxError(t+', got "'+kb(ob,30)+'" (char '+ib+")")}function kb(t,e){return t.length<=e?t:t.substr(0,27)+"..."}function _b(t,e,i){for(var n=e.split("."),o=n.pop(),r=t,s=0;s<n.length;s++){var a=n[s];a in r||(r[a]={}),r=r[a]}return r[o]=i,t}function xb(t,e){var i={};for(var n in t)if(t.hasOwnProperty(n)){var o=e[n];lu(o)?Fu(o).call(o,(function(e){_b(i,e,t[n])})):_b(i,"string"==typeof o?o:n,t[n])}return i}function Eb(t){var e,i=Xm(t),n={nodes:[],edges:[],options:{}};i.nodes&&Fu(e=i.nodes).call(e,(function(t){var e={id:t.id,label:String(t.label||t.id)};lb(e,xb(t.attr,Gm)),e.image&&(e.shape="image"),n.nodes.push(e)}));if(i.edges){var o,r=function(t){var e={from:t.from,to:t.to};return lb(e,xb(t.attr,Km)),null==e.arrows&&"->"===t.type&&(e.arrows="to"),e};Fu(o=i.edges).call(o,(function(t){var e,i,o,s,a,h,l;(e=t.from instanceof Object?t.from.nodes:{id:t.from},i=t.to instanceof Object?t.to.nodes:{id:t.to},t.from instanceof Object&&t.from.edges)&&Fu(o=t.from.edges).call(o,(function(t){var e=r(t);n.edges.push(e)}));(a=i,h=function(e,i){var o=fb(n,e.id,i.id,t.type,t.attr),s=r(o);n.edges.push(s)},lu(s=e)?Fu(s).call(s,(function(t){lu(a)?Fu(a).call(a,(function(e){h(t,e)})):h(t,a)})):lu(a)?Fu(a).call(a,(function(t){h(s,t)})):h(s,a),t.to instanceof Object&&t.to.edges)&&Fu(l=t.to.edges).call(l,(function(t){var e=r(t);n.edges.push(e)}))}))}return i.attr&&(n.options=i.attr),n}var Ob=Object.freeze({__proto__:null,parseDOT:Xm,DOTToGraph:Eb});function Cb(t,e){var i,n={edges:{inheritColor:!1},nodes:{fixed:!1,parseColor:!1}};null!=e&&(null!=e.fixed&&(n.nodes.fixed=e.fixed),null!=e.parseColor&&(n.nodes.parseColor=e.parseColor),null!=e.inheritColor&&(n.edges.inheritColor=e.inheritColor));var o=t.edges,r=gu(o).call(o,(function(t){var e={from:t.source,id:t.id,to:t.target};return null!=t.attributes&&(e.attributes=t.attributes),null!=t.label&&(e.label=t.label),null!=t.attributes&&null!=t.attributes.title&&(e.title=t.attributes.title),"Directed"===t.type&&(e.arrows="to"),t.color&&!1===n.edges.inheritColor&&(e.color=t.color),e}));return{nodes:gu(i=t.nodes).call(i,(function(t){var e={id:t.id,fixed:n.nodes.fixed&&null!=t.x&&null!=t.y};return null!=t.attributes&&(e.attributes=t.attributes),null!=t.label&&(e.label=t.label),null!=t.size&&(e.size=t.size),null!=t.attributes&&null!=t.attributes.title&&(e.title=t.attributes.title),null!=t.title&&(e.title=t.title),null!=t.x&&(e.x=t.x),null!=t.y&&(e.y=t.y),null!=t.color&&(!0===n.nodes.parseColor?e.color=t.color:e.color={background:t.color,border:t.color,highlight:{background:t.color,border:t.color},hover:{background:t.color,border:t.color}}),e})),edges:r}}var Sb=Object.freeze({__proto__:null,parseGephi:Cb}),Tb=Object.freeze({__proto__:null,en:{addDescription:"Click in an empty space to place a new node.",addEdge:"Add Edge",addNode:"Add Node",back:"Back",close:"Close",createEdgeError:"Cannot link edges to a cluster.",del:"Delete selected",deleteClusterError:"Clusters cannot be deleted.",edgeDescription:"Click on a node and drag the edge to another node to connect them.",edit:"Edit",editClusterError:"Clusters cannot be edited.",editEdge:"Edit Edge",editEdgeDescription:"Click on the control points and drag them to a node to connect to it.",editNode:"Edit Node"},de:{addDescription:"Klicke auf eine freie Stelle, um einen neuen Knoten zu plazieren.",addEdge:"Kante hinzufügen",addNode:"Knoten hinzufügen",back:"Zurück",close:"Schließen",createEdgeError:"Es ist nicht möglich, Kanten mit Clustern zu verbinden.",del:"Lösche Auswahl",deleteClusterError:"Cluster können nicht gelöscht werden.",edgeDescription:"Klicke auf einen Knoten und ziehe die Kante zu einem anderen Knoten, um diese zu verbinden.",edit:"Editieren",editClusterError:"Cluster können nicht editiert werden.",editEdge:"Kante editieren",editEdgeDescription:"Klicke auf die Verbindungspunkte und ziehe diese auf einen Knoten, um sie zu verbinden.",editNode:"Knoten editieren"},es:{addDescription:"Haga clic en un lugar vacío para colocar un nuevo nodo.",addEdge:"Añadir arista",addNode:"Añadir nodo",back:"Atrás",close:"Cerrar",createEdgeError:"No se puede conectar una arista a un grupo.",del:"Eliminar selección",deleteClusterError:"No es posible eliminar grupos.",edgeDescription:"Haga clic en un nodo y arrastre la arista hacia otro nodo para conectarlos.",edit:"Editar",editClusterError:"No es posible editar grupos.",editEdge:"Editar arista",editEdgeDescription:"Haga clic en un punto de control y arrastrelo a un nodo para conectarlo.",editNode:"Editar nodo"},it:{addDescription:"Clicca per aggiungere un nuovo nodo",addEdge:"Aggiungi un vertice",addNode:"Aggiungi un nodo",back:"Indietro",close:"Chiudere",createEdgeError:"Non si possono collegare vertici ad un cluster",del:"Cancella la selezione",deleteClusterError:"I cluster non possono essere cancellati",edgeDescription:"Clicca su un nodo e trascinalo ad un altro nodo per connetterli.",edit:"Modifica",editClusterError:"I clusters non possono essere modificati.",editEdge:"Modifica il vertice",editEdgeDescription:"Clicca sui Punti di controllo e trascinali ad un nodo per connetterli.",editNode:"Modifica il nodo"},nl:{addDescription:"Klik op een leeg gebied om een nieuwe node te maken.",addEdge:"Link toevoegen",addNode:"Node toevoegen",back:"Terug",close:"Sluiten",createEdgeError:"Kan geen link maken naar een cluster.",del:"Selectie verwijderen",deleteClusterError:"Clusters kunnen niet worden verwijderd.",edgeDescription:"Klik op een node en sleep de link naar een andere node om ze te verbinden.",edit:"Wijzigen",editClusterError:"Clusters kunnen niet worden aangepast.",editEdge:"Link wijzigen",editEdgeDescription:"Klik op de verbindingspunten en sleep ze naar een node om daarmee te verbinden.",editNode:"Node wijzigen"},pt:{addDescription:"Clique em um espaço em branco para adicionar um novo nó",addEdge:"Adicionar aresta",addNode:"Adicionar nó",back:"Voltar",close:"Fechar",createEdgeError:"Não foi possível linkar arestas a um cluster.",del:"Remover selecionado",deleteClusterError:"Clusters não puderam ser removidos.",edgeDescription:"Clique em um nó e arraste a aresta até outro nó para conectá-los",edit:"Editar",editClusterError:"Clusters não puderam ser editados.",editEdge:"Editar aresta",editEdgeDescription:"Clique nos pontos de controle e os arraste para um nó para conectá-los",editNode:"Editar nó"},ru:{addDescription:"Кликните в свободное место, чтобы добавить новый узел.",addEdge:"Добавить ребро",addNode:"Добавить узел",back:"Назад",close:"Закрывать",createEdgeError:"Невозможно соединить ребра в кластер.",del:"Удалить выбранное",deleteClusterError:"Кластеры не могут быть удалены",edgeDescription:"Кликните на узел и протяните ребро к другому узлу, чтобы соединить их.",edit:"Редактировать",editClusterError:"Кластеры недоступны для редактирования.",editEdge:"Редактировать ребро",editEdgeDescription:"Кликните на контрольные точки и перетащите их в узел, чтобы подключиться к нему.",editNode:"Редактировать узел"},cn:{addDescription:"单击空白处放置新节点。",addEdge:"添加连接线",addNode:"添加节点",back:"返回",close:"關閉",createEdgeError:"无法将连接线连接到群集。",del:"删除选定",deleteClusterError:"无法删除群集。",edgeDescription:"单击某个节点并将该连接线拖动到另一个节点以连接它们。",edit:"编辑",editClusterError:"无法编辑群集。",editEdge:"编辑连接线",editEdgeDescription:"单击控制节点并将它们拖到节点上连接。",editNode:"编辑节点"},uk:{addDescription:"Kлікніть на вільне місце, щоб додати новий вузол.",addEdge:"Додати край",addNode:"Додати вузол",back:"Назад",close:"Закрити",createEdgeError:"Не можливо об'єднати краї в групу.",del:"Видалити обране",deleteClusterError:"Групи не можуть бути видалені.",edgeDescription:"Клікніть на вузол і перетягніть край до іншого вузла, щоб їх з'єднати.",edit:"Редагувати",editClusterError:"Групи недоступні для редагування.",editEdge:"Редагувати край",editEdgeDescription:"Клікніть на контрольні точки і перетягніть їх у вузол, щоб підключитися до нього.",editNode:"Редагувати вузол"},fr:{addDescription:"Cliquez dans un endroit vide pour placer un nœud.",addEdge:"Ajouter un lien",addNode:"Ajouter un nœud",back:"Retour",close:"Fermer",createEdgeError:"Impossible de créer un lien vers un cluster.",del:"Effacer la sélection",deleteClusterError:"Les clusters ne peuvent pas être effacés.",edgeDescription:"Cliquez sur un nœud et glissez le lien vers un autre nœud pour les connecter.",edit:"Éditer",editClusterError:"Les clusters ne peuvent pas être édités.",editEdge:"Éditer le lien",editEdgeDescription:"Cliquez sur les points de contrôle et glissez-les pour connecter un nœud.",editNode:"Éditer le nœud"},cs:{addDescription:"Kluknutím do prázdného prostoru můžete přidat nový vrchol.",addEdge:"Přidat hranu",addNode:"Přidat vrchol",back:"Zpět",close:"Zavřít",createEdgeError:"Nelze připojit hranu ke shluku.",del:"Smazat výběr",deleteClusterError:"Nelze mazat shluky.",edgeDescription:"Přetažením z jednoho vrcholu do druhého můžete spojit tyto vrcholy novou hranou.",edit:"Upravit",editClusterError:"Nelze upravovat shluky.",editEdge:"Upravit hranu",editEdgeDescription:"Přetažením kontrolního vrcholu hrany ji můžete připojit k jinému vrcholu.",editNode:"Upravit vrchol"}});var Mb=function(){function t(){Yd(this,t),this.NUM_ITERATIONS=4,this.image=new Image,this.canvas=document.createElement("canvas")}return Kd(t,[{key:"init",value:function(){if(!this.initialized()){this.src=this.image.src;var t=this.image.width,e=this.image.height;this.width=t,this.height=e;var i=Math.floor(e/2),n=Math.floor(e/4),o=Math.floor(e/8),r=Math.floor(e/16),s=Math.floor(t/2),a=Math.floor(t/4),h=Math.floor(t/8),l=Math.floor(t/16);this.canvas.width=3*a,this.canvas.height=i,this.coordinates=[[0,0,s,i],[s,0,a,n],[s,n,h,o],[5*h,n,l,r]],this._fillMipMap()}}},{key:"initialized",value:function(){return void 0!==this.coordinates}},{key:"_fillMipMap",value:function(){var t=this.canvas.getContext("2d"),e=this.coordinates[0];t.drawImage(this.image,e[0],e[1],e[2],e[3]);for(var i=1;i<this.NUM_ITERATIONS;i++){var n=this.coordinates[i-1],o=this.coordinates[i];t.drawImage(this.canvas,n[0],n[1],n[2],n[3],o[0],o[1],o[2],o[3])}}},{key:"drawImageAtPosition",value:function(t,e,i,n,o,r){if(this.initialized())if(e>2){e*=.5;for(var s=0;e>2&&s<this.NUM_ITERATIONS;)e*=.5,s+=1;s>=this.NUM_ITERATIONS&&(s=this.NUM_ITERATIONS-1);var a=this.coordinates[s];t.drawImage(this.canvas,a[0],a[1],a[2],a[3],i,n,o,r)}else t.drawImage(this.image,i,n,o,r)}}]),t}(),Pb=function(){function t(e){Yd(this,t),this.images={},this.imageBroken={},this.callback=e}return Kd(t,[{key:"_tryloadBrokenUrl",value:function(t,e,i){void 0!==t&&void 0!==i&&(void 0!==e?(i.image.onerror=function(){console.error("Could not load brokenImage:",e)},i.image.src=e):console.warn("No broken url image defined"))}},{key:"_redrawWithImage",value:function(t){this.callback&&this.callback(t)}},{key:"load",value:function(t,e){var i=this,n=this.images[t];if(n)return n;var o=new Mb;return this.images[t]=o,o.image.onload=function(){i._fixImageCoordinates(o.image),o.init(),i._redrawWithImage(o)},o.image.onerror=function(){console.error("Could not load image:",t),i._tryloadBrokenUrl(t,e,o)},o.image.src=t,o}},{key:"_fixImageCoordinates",value:function(t){0===t.width&&(document.body.appendChild(t),t.width=t.offsetWidth,t.height=t.offsetHeight,document.body.removeChild(t))}}]),t}(),Db={exports:{}},Ib=o((function(){if("function"==typeof ArrayBuffer){var t=new ArrayBuffer(8);Object.isExtensible(t)&&Object.defineProperty(t,"a",{value:8})}})),Bb=o,zb=Y,Nb=B,Fb=Ib,Ab=Object.isExtensible,jb=Bb((function(){Ab(1)}))||Fb?function(t){return!!zb(t)&&((!Fb||"ArrayBuffer"!=Nb(t))&&(!Ab||Ab(t)))}:Ab,Rb=!o((function(){return Object.isExtensible(Object.preventExtensions({}))})),Lb=_i,Hb=g,Wb=Ri,qb=Y,Vb=Wt,Ub=Ve.f,Yb=rh,Xb=hh,Gb=jb,Kb=Rb,$b=!1,Zb=Xt("meta"),Qb=0,Jb=function(t){Ub(t,Zb,{value:{objectID:"O"+Qb++,weakData:{}}})},tw=Db.exports={enable:function(){tw.enable=function(){},$b=!0;var t=Yb.f,e=Hb([].splice),i={};i[Zb]=1,t(i).length&&(Yb.f=function(i){for(var n=t(i),o=0,r=n.length;o<r;o++)if(n[o]===Zb){e(n,o,1);break}return n},Lb({target:"Object",stat:!0,forced:!0},{getOwnPropertyNames:Xb.f}))},fastKey:function(t,e){if(!qb(t))return"symbol"==typeof t?t:("string"==typeof t?"S":"P")+t;if(!Vb(t,Zb)){if(!Gb(t))return"F";if(!e)return"E";Jb(t)}return t[Zb].objectID},getWeakData:function(t,e){if(!Vb(t,Zb)){if(!Gb(t))return!0;if(!e)return!1;Jb(t)}return t[Zb].weakData},onFreeze:function(t){return Kb&&$b&&Gb(t)&&!Vb(t,Zb)&&Jb(t),t}};Wb[Zb]=!0;var ew=qe,iw=_,nw=$e,ow=bt,rw=qs,sw=Bi,aw=J,hw=ba,lw=ua,dw=As,cw=n.TypeError,uw=function(t,e){this.stopped=t,this.result=e},fw=uw.prototype,pw=function(t,e,i){var n,o,r,s,a,h,l,d=i&&i.that,c=!(!i||!i.AS_ENTRIES),u=!(!i||!i.IS_ITERATOR),f=!(!i||!i.INTERRUPTED),p=ew(e,d),v=function(t){return n&&dw(n,"normal",t),new uw(!0,t)},g=function(t){return c?(nw(t),f?p(t[0],t[1],v):p(t[0],t[1])):f?p(t,v):p(t)};if(u)n=t;else{if(!(o=lw(t)))throw cw(ow(t)+" is not iterable");if(rw(o)){for(r=0,s=sw(t);s>r;r++)if((a=g(t[r]))&&aw(fw,a))return a;return new uw(!1)}n=hw(t,o)}for(h=n.next;!(l=iw(h,n)).done;){try{a=g(l.value)}catch(t){dw(n,"throw",t)}if("object"==typeof a&&a&&aw(fw,a))return a}return new uw(!1)},vw=J,gw=n.TypeError,yw=function(t,e){if(vw(e,t))return t;throw gw("Incorrect invocation")},mw=_i,bw=n,ww=Db.exports,kw=o,_w=di,xw=pw,Ew=yw,Ow=y,Cw=Y,Sw=$r,Tw=Ve.f,Mw=Wh.forEach,Pw=b,Dw=Vo.set,Iw=Vo.getterFor,Bw=function(t,e,i){var n,o=-1!==t.indexOf("Map"),r=-1!==t.indexOf("Weak"),s=o?"set":"add",a=bw[t],h=a&&a.prototype,l={};if(Pw&&Ow(a)&&(r||h.forEach&&!kw((function(){(new a).entries().next()})))){var d=(n=e((function(e,i){Dw(Ew(e,d),{type:t,collection:new a}),null!=i&&xw(i,e[s],{that:e,AS_ENTRIES:o})}))).prototype,c=Iw(t);Mw(["add","clear","delete","forEach","get","has","set","keys","values","entries"],(function(t){var e="add"==t||"set"==t;!(t in h)||r&&"clear"==t||_w(d,t,(function(i,n){var o=c(this).collection;if(!e&&r&&!Cw(i))return"get"==t&&void 0;var s=o[t](0===i?0:i,n);return e?this:s}))})),r||Tw(d,"size",{configurable:!0,get:function(){return c(this).collection.size}})}else n=i.getConstructor(e,t,o,s),ww.enable();return Sw(n,t,!1,!0),l[t]=n,mw({global:!0,forced:!0},l),r||i.setStrong(n,t,o),n},zw=Ir,Nw=function(t,e,i){for(var n in e)i&&i.unsafe&&t[n]?t[n]=e[n]:zw(t,n,e[n],i);return t},Fw=Q,Aw=Ve,jw=b,Rw=oe("species"),Lw=Ve.f,Hw=wr,Ww=Nw,qw=qe,Vw=yw,Uw=pw,Yw=Cs,Xw=function(t){var e=Fw(t),i=Aw.f;jw&&e&&!e[Rw]&&i(e,Rw,{configurable:!0,get:function(){return this}})},Gw=b,Kw=Db.exports.fastKey,$w=Vo.set,Zw=Vo.getterFor,Qw={getConstructor:function(t,e,i,n){var o=t((function(t,o){Vw(t,r),$w(t,{type:e,index:Hw(null),first:void 0,last:void 0,size:0}),Gw||(t.size=0),null!=o&&Uw(o,t[n],{that:t,AS_ENTRIES:i})})),r=o.prototype,s=Zw(e),a=function(t,e,i){var n,o,r=s(t),a=h(t,e);return a?a.value=i:(r.last=a={index:o=Kw(e,!0),key:e,value:i,previous:n=r.last,next:void 0,removed:!1},r.first||(r.first=a),n&&(n.next=a),Gw?r.size++:t.size++,"F"!==o&&(r.index[o]=a)),t},h=function(t,e){var i,n=s(t),o=Kw(e);if("F"!==o)return n.index[o];for(i=n.first;i;i=i.next)if(i.key==e)return i};return Ww(r,{clear:function(){for(var t=s(this),e=t.index,i=t.first;i;)i.removed=!0,i.previous&&(i.previous=i.previous.next=void 0),delete e[i.index],i=i.next;t.first=t.last=void 0,Gw?t.size=0:this.size=0},delete:function(t){var e=this,i=s(e),n=h(e,t);if(n){var o=n.next,r=n.previous;delete i.index[n.index],n.removed=!0,r&&(r.next=o),o&&(o.previous=r),i.first==n&&(i.first=o),i.last==n&&(i.last=r),Gw?i.size--:e.size--}return!!n},forEach:function(t){for(var e,i=s(this),n=qw(t,arguments.length>1?arguments[1]:void 0);e=e?e.next:i.first;)for(n(e.value,e.key,this);e&&e.removed;)e=e.previous},has:function(t){return!!h(this,t)}}),Ww(r,i?{get:function(t){var e=h(this,t);return e&&e.value},set:function(t,e){return a(this,0===t?0:t,e)}}:{add:function(t){return a(this,t=0===t?0:t,t)}}),Gw&&Lw(r,"size",{get:function(){return s(this).size}}),o},setStrong:function(t,e,i){var n=e+" Iterator",o=Zw(e),r=Zw(n);Yw(t,e,(function(t,e){$w(this,{type:n,target:t,state:o(t),kind:e,last:void 0})}),(function(){for(var t=r(this),e=t.kind,i=t.last;i&&i.removed;)i=i.previous;return t.target&&(t.last=i=i?i.next:t.state.first)?"keys"==e?{value:i.key,done:!1}:"values"==e?{value:i.value,done:!1}:{value:[i.key,i.value],done:!1}:(t.target=void 0,{value:void 0,done:!0})}),i?"entries":"values",!i,!0),Xw(e)}};Bw("Map",(function(t){return function(){return t(this,arguments.length?arguments[0]:void 0)}}),Qw);var Jw=X.Map,tk=function(){function t(){Yd(this,t),this.clear(),this._defaultIndex=0,this._groupIndex=0,this._defaultGroups=[{border:"#2B7CE9",background:"#97C2FC",highlight:{border:"#2B7CE9",background:"#D2E5FF"},hover:{border:"#2B7CE9",background:"#D2E5FF"}},{border:"#FFA500",background:"#FFFF00",highlight:{border:"#FFA500",background:"#FFFFA3"},hover:{border:"#FFA500",background:"#FFFFA3"}},{border:"#FA0A10",background:"#FB7E81",highlight:{border:"#FA0A10",background:"#FFAFB1"},hover:{border:"#FA0A10",background:"#FFAFB1"}},{border:"#41A906",background:"#7BE141",highlight:{border:"#41A906",background:"#A1EC76"},hover:{border:"#41A906",background:"#A1EC76"}},{border:"#E129F0",background:"#EB7DF4",highlight:{border:"#E129F0",background:"#F0B3F5"},hover:{border:"#E129F0",background:"#F0B3F5"}},{border:"#7C29F0",background:"#AD85E4",highlight:{border:"#7C29F0",background:"#D3BDF0"},hover:{border:"#7C29F0",background:"#D3BDF0"}},{border:"#C37F00",background:"#FFA807",highlight:{border:"#C37F00",background:"#FFCA66"},hover:{border:"#C37F00",background:"#FFCA66"}},{border:"#4220FB",background:"#6E6EFD",highlight:{border:"#4220FB",background:"#9B9BFD"},hover:{border:"#4220FB",background:"#9B9BFD"}},{border:"#FD5A77",background:"#FFC0CB",highlight:{border:"#FD5A77",background:"#FFD1D9"},hover:{border:"#FD5A77",background:"#FFD1D9"}},{border:"#4AD63A",background:"#C2FABC",highlight:{border:"#4AD63A",background:"#E6FFE3"},hover:{border:"#4AD63A",background:"#E6FFE3"}},{border:"#990000",background:"#EE0000",highlight:{border:"#BB0000",background:"#FF3333"},hover:{border:"#BB0000",background:"#FF3333"}},{border:"#FF6000",background:"#FF6000",highlight:{border:"#FF6000",background:"#FF6000"},hover:{border:"#FF6000",background:"#FF6000"}},{border:"#97C2FC",background:"#2B7CE9",highlight:{border:"#D2E5FF",background:"#2B7CE9"},hover:{border:"#D2E5FF",background:"#2B7CE9"}},{border:"#399605",background:"#255C03",highlight:{border:"#399605",background:"#255C03"},hover:{border:"#399605",background:"#255C03"}},{border:"#B70054",background:"#FF007E",highlight:{border:"#B70054",background:"#FF007E"},hover:{border:"#B70054",background:"#FF007E"}},{border:"#AD85E4",background:"#7C29F0",highlight:{border:"#D3BDF0",background:"#7C29F0"},hover:{border:"#D3BDF0",background:"#7C29F0"}},{border:"#4557FA",background:"#000EA1",highlight:{border:"#6E6EFD",background:"#000EA1"},hover:{border:"#6E6EFD",background:"#000EA1"}},{border:"#FFC0CB",background:"#FD5A77",highlight:{border:"#FFD1D9",background:"#FD5A77"},hover:{border:"#FFD1D9",background:"#FD5A77"}},{border:"#C2FABC",background:"#74D66A",highlight:{border:"#E6FFE3",background:"#74D66A"},hover:{border:"#E6FFE3",background:"#74D66A"}},{border:"#EE0000",background:"#990000",highlight:{border:"#FF3333",background:"#BB0000"},hover:{border:"#FF3333",background:"#BB0000"}}],this.options={},this.defaultOptions={useDefaultGroups:!0},un(this.options,this.defaultOptions)}return Kd(t,[{key:"setOptions",value:function(t){var e=["useDefaultGroups"];if(void 0!==t)for(var i in t)if(Object.prototype.hasOwnProperty.call(t,i)&&-1===Fp(e).call(e,i)){var n=t[i];this.add(i,n)}}},{key:"clear",value:function(){this._groups=new Jw,this._groupNames=[]}},{key:"get",value:function(t){var e=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],i=this._groups.get(t);if(void 0===i&&e)if(!1===this.options.useDefaultGroups&&this._groupNames.length>0){var n=this._groupIndex%this._groupNames.length;++this._groupIndex,(i={}).color=this._groups.get(this._groupNames[n]),this._groups.set(t,i)}else{var o=this._defaultIndex%this._defaultGroups.length;this._defaultIndex++,(i={}).color=this._defaultGroups[o],this._groups.set(t,i)}return i}},{key:"add",value:function(t,e){return this._groups.has(t)||this._groupNames.push(t),this._groups.set(t,e),e}}]),t}();_i({target:"Number",stat:!0},{isNaN:function(t){return t!=t}});var ek=X.Number.isNaN,ik=n.isFinite,nk=Number.isFinite||function(t){return"number"==typeof t&&ik(t)};_i({target:"Number",stat:!0},{isFinite:nk});var ok=X.Number.isFinite,rk=Wh.some;_i({target:"Array",proto:!0,forced:!Cu("some")},{some:function(t){return rk(this,t,arguments.length>1?arguments[1]:void 0)}});var sk=Tn("Array").some,ak=J,hk=sk,lk=Array.prototype,dk=function(t){var e=t.some;return t===lk||ak(lk,t)&&e===lk.some?hk:e},ck=dk,uk=na,fk=bt,pk=n.TypeError,vk=_i,gk=d,yk=On,mk=function(t){if(uk(t))return t;throw pk(fk(t)+" is not a constructor")},bk=$e,wk=Y,kk=wr,_k=o,xk=Q("Reflect","construct"),Ek=Object.prototype,Ok=[].push,Ck=_k((function(){function t(){}return!(xk((function(){}),[],t)instanceof t)})),Sk=!_k((function(){xk((function(){}))})),Tk=Ck||Sk;vk({target:"Reflect",stat:!0,forced:Tk,sham:Tk},{construct:function(t,e){mk(t),bk(e);var i=arguments.length<3?t:mk(arguments[2]);if(Sk&&!Ck)return xk(t,e,i);if(t==i){switch(e.length){case 0:return new t;case 1:return new t(e[0]);case 2:return new t(e[0],e[1]);case 3:return new t(e[0],e[1],e[2]);case 4:return new t(e[0],e[1],e[2],e[3])}var n=[null];return gk(Ok,n,e),new(gk(yk,t,n))}var o=i.prototype,r=kk(wk(o)?o:Ek),s=gk(t,r,e);return wk(s)?s:r}});var Mk=X.Reflect.construct;function Pk(t){if(void 0===t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return t}var Dk=Gp;_i({target:"Object",stat:!0},{setPrototypeOf:cs});var Ik=X.Object.setPrototypeOf;function Bk(t,e){return Bk=Ik||function(t,e){return t.__proto__=e,t},Bk(t,e)}function zk(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");t.prototype=Dk(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),Xd(t,"prototype",{writable:!1}),e&&Bk(t,e)}function Nk(t,e){if(e&&("object"===Qc(e)||"function"==typeof e))return e;if(void 0!==e)throw new TypeError("Derived constructors may only return object or undefined");return Pk(t)}var Fk=Rf;function Ak(t){return Ak=Ik?Fk:function(t){return t.__proto__||Fk(t)},Ak(t)}var jk={exports:{}};!function(t){var e=function(t){var e,i=Object.prototype,n=i.hasOwnProperty,o="function"==typeof Symbol?Symbol:{},r=o.iterator||"@@iterator",s=o.asyncIterator||"@@asyncIterator",a=o.toStringTag||"@@toStringTag";function h(t,e,i){return Object.defineProperty(t,e,{value:i,enumerable:!0,configurable:!0,writable:!0}),t[e]}try{h({},"")}catch(t){h=function(t,e,i){return t[e]=i}}function l(t,e,i,n){var o=e&&e.prototype instanceof g?e:g,r=Object.create(o.prototype),s=new T(n||[]);return r._invoke=function(t,e,i){var n=c;return function(o,r){if(n===f)throw new Error("Generator is already running");if(n===p){if("throw"===o)throw r;return P()}for(i.method=o,i.arg=r;;){var s=i.delegate;if(s){var a=O(s,i);if(a){if(a===v)continue;return a}}if("next"===i.method)i.sent=i._sent=i.arg;else if("throw"===i.method){if(n===c)throw n=p,i.arg;i.dispatchException(i.arg)}else"return"===i.method&&i.abrupt("return",i.arg);n=f;var h=d(t,e,i);if("normal"===h.type){if(n=i.done?p:u,h.arg===v)continue;return{value:h.arg,done:i.done}}"throw"===h.type&&(n=p,i.method="throw",i.arg=h.arg)}}}(t,i,s),r}function d(t,e,i){try{return{type:"normal",arg:t.call(e,i)}}catch(t){return{type:"throw",arg:t}}}t.wrap=l;var c="suspendedStart",u="suspendedYield",f="executing",p="completed",v={};function g(){}function y(){}function m(){}var b={};h(b,r,(function(){return this}));var w=Object.getPrototypeOf,k=w&&w(w(M([])));k&&k!==i&&n.call(k,r)&&(b=k);var _=m.prototype=g.prototype=Object.create(b);function x(t){["next","throw","return"].forEach((function(e){h(t,e,(function(t){return this._invoke(e,t)}))}))}function E(t,e){function i(o,r,s,a){var h=d(t[o],t,r);if("throw"!==h.type){var l=h.arg,c=l.value;return c&&"object"==typeof c&&n.call(c,"__await")?e.resolve(c.__await).then((function(t){i("next",t,s,a)}),(function(t){i("throw",t,s,a)})):e.resolve(c).then((function(t){l.value=t,s(l)}),(function(t){return i("throw",t,s,a)}))}a(h.arg)}var o;this._invoke=function(t,n){function r(){return new e((function(e,o){i(t,n,e,o)}))}return o=o?o.then(r,r):r()}}function O(t,i){var n=t.iterator[i.method];if(n===e){if(i.delegate=null,"throw"===i.method){if(t.iterator.return&&(i.method="return",i.arg=e,O(t,i),"throw"===i.method))return v;i.method="throw",i.arg=new TypeError("The iterator does not provide a 'throw' method")}return v}var o=d(n,t.iterator,i.arg);if("throw"===o.type)return i.method="throw",i.arg=o.arg,i.delegate=null,v;var r=o.arg;return r?r.done?(i[t.resultName]=r.value,i.next=t.nextLoc,"return"!==i.method&&(i.method="next",i.arg=e),i.delegate=null,v):r:(i.method="throw",i.arg=new TypeError("iterator result is not an object"),i.delegate=null,v)}function C(t){var e={tryLoc:t[0]};1 in t&&(e.catchLoc=t[1]),2 in t&&(e.finallyLoc=t[2],e.afterLoc=t[3]),this.tryEntries.push(e)}function S(t){var e=t.completion||{};e.type="normal",delete e.arg,t.completion=e}function T(t){this.tryEntries=[{tryLoc:"root"}],t.forEach(C,this),this.reset(!0)}function M(t){if(t){var i=t[r];if(i)return i.call(t);if("function"==typeof t.next)return t;if(!isNaN(t.length)){var o=-1,s=function i(){for(;++o<t.length;)if(n.call(t,o))return i.value=t[o],i.done=!1,i;return i.value=e,i.done=!0,i};return s.next=s}}return{next:P}}function P(){return{value:e,done:!0}}return y.prototype=m,h(_,"constructor",m),h(m,"constructor",y),y.displayName=h(m,a,"GeneratorFunction"),t.isGeneratorFunction=function(t){var e="function"==typeof t&&t.constructor;return!!e&&(e===y||"GeneratorFunction"===(e.displayName||e.name))},t.mark=function(t){return Object.setPrototypeOf?Object.setPrototypeOf(t,m):(t.__proto__=m,h(t,a,"GeneratorFunction")),t.prototype=Object.create(_),t},t.awrap=function(t){return{__await:t}},x(E.prototype),h(E.prototype,s,(function(){return this})),t.AsyncIterator=E,t.async=function(e,i,n,o,r){void 0===r&&(r=Promise);var s=new E(l(e,i,n,o),r);return t.isGeneratorFunction(i)?s:s.next().then((function(t){return t.done?t.value:s.next()}))},x(_),h(_,a,"Generator"),h(_,r,(function(){return this})),h(_,"toString",(function(){return"[object Generator]"})),t.keys=function(t){var e=[];for(var i in t)e.push(i);return e.reverse(),function i(){for(;e.length;){var n=e.pop();if(n in t)return i.value=n,i.done=!1,i}return i.done=!0,i}},t.values=M,T.prototype={constructor:T,reset:function(t){if(this.prev=0,this.next=0,this.sent=this._sent=e,this.done=!1,this.delegate=null,this.method="next",this.arg=e,this.tryEntries.forEach(S),!t)for(var i in this)"t"===i.charAt(0)&&n.call(this,i)&&!isNaN(+i.slice(1))&&(this[i]=e)},stop:function(){this.done=!0;var t=this.tryEntries[0].completion;if("throw"===t.type)throw t.arg;return this.rval},dispatchException:function(t){if(this.done)throw t;var i=this;function o(n,o){return a.type="throw",a.arg=t,i.next=n,o&&(i.method="next",i.arg=e),!!o}for(var r=this.tryEntries.length-1;r>=0;--r){var s=this.tryEntries[r],a=s.completion;if("root"===s.tryLoc)return o("end");if(s.tryLoc<=this.prev){var h=n.call(s,"catchLoc"),l=n.call(s,"finallyLoc");if(h&&l){if(this.prev<s.catchLoc)return o(s.catchLoc,!0);if(this.prev<s.finallyLoc)return o(s.finallyLoc)}else if(h){if(this.prev<s.catchLoc)return o(s.catchLoc,!0)}else{if(!l)throw new Error("try statement without catch or finally");if(this.prev<s.finallyLoc)return o(s.finallyLoc)}}}},abrupt:function(t,e){for(var i=this.tryEntries.length-1;i>=0;--i){var o=this.tryEntries[i];if(o.tryLoc<=this.prev&&n.call(o,"finallyLoc")&&this.prev<o.finallyLoc){var r=o;break}}r&&("break"===t||"continue"===t)&&r.tryLoc<=e&&e<=r.finallyLoc&&(r=null);var s=r?r.completion:{};return s.type=t,s.arg=e,r?(this.method="next",this.next=r.finallyLoc,v):this.complete(s)},complete:function(t,e){if("throw"===t.type)throw t.arg;return"break"===t.type||"continue"===t.type?this.next=t.arg:"return"===t.type?(this.rval=this.arg=t.arg,this.method="return",this.next="end"):"normal"===t.type&&e&&(this.next=e),v},finish:function(t){for(var e=this.tryEntries.length-1;e>=0;--e){var i=this.tryEntries[e];if(i.finallyLoc===t)return this.complete(i.completion,i.afterLoc),S(i),v}},catch:function(t){for(var e=this.tryEntries.length-1;e>=0;--e){var i=this.tryEntries[e];if(i.tryLoc===t){var n=i.completion;if("throw"===n.type){var o=n.arg;S(i)}return o}}throw new Error("illegal catch attempt")},delegateYield:function(t,i,n){return this.delegate={iterator:M(t),resultName:i,nextLoc:n},"next"===this.method&&(this.arg=e),v}},t}(t.exports);try{regeneratorRuntime=e}catch(t){"object"==typeof globalThis?globalThis.regeneratorRuntime=e:Function("r","regeneratorRuntime = r")(e)}}(jk);var Rk=jk.exports,Lk=xt,Hk=Rt,Wk=R,qk=Bi,Vk=n.TypeError,Uk=function(t){return function(e,i,n,o){Lk(i);var r=Hk(e),s=Wk(r),a=qk(r),h=t?a-1:0,l=t?-1:1;if(n<2)for(;;){if(h in s){o=s[h],h+=l;break}if(h+=l,t?h<0:a<=h)throw Vk("Reduce of empty array with no initial value")}for(;t?h>=0:a>h;h+=l)h in s&&(o=i(o,s[h],h,r));return o}},Yk={left:Uk(!1),right:Uk(!0)},Xk="process"==B(n.process),Gk=Yk.left,Kk=at,$k=Xk;_i({target:"Array",proto:!0,forced:!Cu("reduce")||!$k&&Kk>79&&Kk<83},{reduce:function(t){var e=arguments.length;return Gk(this,t,e,e>1?arguments[1]:void 0)}});var Zk=Tn("Array").reduce,Qk=J,Jk=Zk,t_=Array.prototype,e_=function(t){var e=t.reduce;return t===t_||Qk(t_,t)&&e===t_.reduce?Jk:e},i_=e_,n_=oh,o_=Bi,r_=qe,s_=n.TypeError,a_=function(t,e,i,n,o,r,s,a){for(var h,l,d=o,c=0,u=!!s&&r_(s,a);c<n;){if(c in i){if(h=u?u(i[c],c,e):i[c],r>0&&n_(h))l=o_(h),d=a_(t,e,h,l,d,r-1)-1;else{if(d>=9007199254740991)throw s_("Exceed the acceptable array length");t[d]=h}d++}c++}return d},h_=a_,l_=xt,d_=Rt,c_=Bi,u_=zh;_i({target:"Array",proto:!0},{flatMap:function(t){var e,i=d_(this),n=c_(i);return l_(t),(e=u_(i,0)).length=h_(e,i,i,n,0,1,t,arguments.length>1?arguments[1]:void 0),e}});var f_=Tn("Array").flatMap,p_=J,v_=f_,g_=Array.prototype,y_=function(t){var e=t.flatMap;return t===g_||p_(g_,t)&&e===g_.flatMap?v_:e},m_=y_;Bw("Set",(function(t){return function(){return t(this,arguments.length?arguments[0]:void 0)}}),Qw);var b_=X.Set,w_=$c,k_=ba,__=ph,x_=Math.floor,E_=function(t,e){var i=t.length,n=x_(i/2);return i<8?O_(t,e):C_(t,E_(__(t,0,n),e),E_(__(t,n),e),e)},O_=function(t,e){for(var i,n,o=t.length,r=1;r<o;){for(n=r,i=t[r];n&&e(t[n-1],i)>0;)t[n]=t[--n];n!==r++&&(t[n]=i)}return t},C_=function(t,e,i,n){for(var o=e.length,r=i.length,s=0,a=0;s<o||a<r;)t[s+a]=s<o&&a<r?n(e[s],i[a])<=0?e[s++]:i[a++]:s<o?e[s++]:i[a++];return t},S_=E_,T_=tt.match(/firefox\/(\d+)/i),M_=!!T_&&+T_[1],P_=/MSIE|Trident/.test(tt),D_=tt.match(/AppleWebKit\/(\d+)\./),I_=!!D_&&+D_[1],B_=_i,z_=g,N_=xt,F_=Rt,A_=Bi,j_=eo,R_=o,L_=S_,H_=Cu,W_=M_,q_=P_,V_=at,U_=I_,Y_=[],X_=z_(Y_.sort),G_=z_(Y_.push),K_=R_((function(){Y_.sort(void 0)})),$_=R_((function(){Y_.sort(null)})),Z_=H_("sort"),Q_=!R_((function(){if(V_)return V_<70;if(!(W_&&W_>3)){if(q_)return!0;if(U_)return U_<603;var t,e,i,n,o="";for(t=65;t<76;t++){switch(e=String.fromCharCode(t),t){case 66:case 69:case 70:case 72:i=3;break;case 68:case 71:i=4;break;default:i=2}for(n=0;n<47;n++)Y_.push({k:e+n,v:i})}for(Y_.sort((function(t,e){return e.v-t.v})),n=0;n<Y_.length;n++)e=Y_[n].k.charAt(0),o.charAt(o.length-1)!==e&&(o+=e);return"DGBEFHACIJK"!==o}}));B_({target:"Array",proto:!0,forced:K_||!$_||!Z_||!Q_},{sort:function(t){void 0!==t&&N_(t);var e=F_(this);if(Q_)return void 0===t?X_(e):X_(e,t);var i,n,o=[],r=A_(e);for(n=0;n<r;n++)n in e&&G_(o,e[n]);for(L_(o,function(t){return function(e,i){return void 0===i?-1:void 0===e?1:void 0!==t?+t(e,i)||0:j_(e)>j_(i)?1:-1}}(t)),i=o.length,n=0;n<i;)e[n]=o[n++];for(;n<r;)delete e[n++];return e}});var J_,tx=Tn("Array").sort,ex=J,ix=tx,nx=Array.prototype,ox=function(t){var e=t.sort;return t===nx||ex(nx,t)&&e===nx.sort?ix:e},rx=ox,sx=Tn("Array").keys,ax=Qn,hx=Wt,lx=J,dx=sx,cx=Array.prototype,ux={DOMTokenList:!0,NodeList:!0},fx=function(t){var e=t.keys;return t===cx||lx(cx,t)&&e===cx.keys||hx(ux,ax(t))?dx:e},px=Tn("Array").values,vx=Qn,gx=Wt,yx=J,mx=px,bx=Array.prototype,wx={DOMTokenList:!0,NodeList:!0},kx=function(t){var e=t.values;return t===bx||yx(bx,t)&&e===bx.values||gx(wx,vx(t))?mx:e},_x=Tn("Array").entries,xx=Qn,Ex=Wt,Ox=J,Cx=_x,Sx=Array.prototype,Tx={DOMTokenList:!0,NodeList:!0},Mx=function(t){var e=t.entries;return t===Sx||Ox(Sx,t)&&e===Sx.entries||Ex(Tx,xx(t))?Cx:e},Px=new Uint8Array(16);function Dx(){if(!J_&&!(J_="undefined"!=typeof crypto&&crypto.getRandomValues&&crypto.getRandomValues.bind(crypto)||"undefined"!=typeof msCrypto&&"function"==typeof msCrypto.getRandomValues&&msCrypto.getRandomValues.bind(msCrypto)))throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");return J_(Px)}var Ix=/^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;function Bx(t){return"string"==typeof t&&Ix.test(t)}for(var zx,Nx=[],Fx=0;Fx<256;++Fx)Nx.push((Fx+256).toString(16).substr(1));function Ax(t,e,i){var n=(t=t||{}).random||(t.rng||Dx)();if(n[6]=15&n[6]|64,n[8]=63&n[8]|128,e){i=i||0;for(var o=0;o<16;++o)e[i+o]=n[o];return e}return function(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,i=(Nx[t[e+0]]+Nx[t[e+1]]+Nx[t[e+2]]+Nx[t[e+3]]+"-"+Nx[t[e+4]]+Nx[t[e+5]]+"-"+Nx[t[e+6]]+Nx[t[e+7]]+"-"+Nx[t[e+8]]+Nx[t[e+9]]+"-"+Nx[t[e+10]]+Nx[t[e+11]]+Nx[t[e+12]]+Nx[t[e+13]]+Nx[t[e+14]]+Nx[t[e+15]]).toLowerCase();if(!Bx(i))throw TypeError("Stringified UUID is invalid");return i}(n)}function jx(t,e){var i=bu(t);if(hd){var n=hd(t);e&&(n=Xf(n).call(n,(function(e){return bd(t,e).enumerable}))),i.push.apply(i,n)}return i}function Rx(t){for(var e=1;e<arguments.length;e++){var i,n,o=null!=arguments[e]?arguments[e]:{};e%2?Fu(i=jx(Object(o),!0)).call(i,(function(e){$d(t,e,o[e])})):Pd?Ad(t,Pd(o)):Fu(n=jx(Object(o))).call(n,(function(e){Ud(t,e,bd(o,e))}))}return t}function Lx(t){var e=function(){if("undefined"==typeof Reflect||!Mk)return!1;if(Mk.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Mk(Boolean,[],(function(){}))),!0}catch(t){return!1}}();return function(){var i,n=Ak(t);if(e){var o=Ak(this).constructor;i=Mk(n,arguments,o)}else i=n.apply(this,arguments);return Nk(this,i)}}function Hx(t,e){var i=void 0!==tu&&ih(t)||t["@@iterator"];if(!i){if(lu(t)||(i=function(t,e){var i;if(!t)return;if("string"==typeof t)return Wx(t,e);var n=au(i=Object.prototype.toString.call(t)).call(i,8,-1);"Object"===n&&t.constructor&&(n=t.constructor.name);if("Map"===n||"Set"===n)return ja(t);if("Arguments"===n||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))return Wx(t,e)}(t))||e&&t&&"number"==typeof t.length){i&&(t=i);var n=0,o=function(){};return{s:o,n:function(){return n>=t.length?{done:!0}:{done:!1,value:t[n++]}},e:function(t){throw t},f:o}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}var r,s=!0,a=!1;return{s:function(){i=i.call(t)},n:function(){var t=i.next();return s=t.done,t},e:function(t){a=!0,r=t},f:function(){try{s||null==i.return||i.return()}finally{if(a)throw r}}}}function Wx(t,e){(null==e||e>t.length)&&(e=t.length);for(var i=0,n=new Array(e);i<e;i++)n[i]=t[i];return n}var qx=function(){function t(e,i,n){var o,r,s;Yd(this,t),$d(this,"_source",void 0),$d(this,"_transformers",void 0),$d(this,"_target",void 0),$d(this,"_listeners",{add:zn(o=this._add).call(o,this),remove:zn(r=this._remove).call(r,this),update:zn(s=this._update).call(s,this)}),this._source=e,this._transformers=i,this._target=n}return Kd(t,[{key:"all",value:function(){return this._target.update(this._transformItems(this._source.get())),this}},{key:"start",value:function(){return this._source.on("add",this._listeners.add),this._source.on("remove",this._listeners.remove),this._source.on("update",this._listeners.update),this}},{key:"stop",value:function(){return this._source.off("add",this._listeners.add),this._source.off("remove",this._listeners.remove),this._source.off("update",this._listeners.update),this}},{key:"_transformItems",value:function(t){var e;return i_(e=this._transformers).call(e,(function(t,e){return e(t)}),t)}},{key:"_add",value:function(t,e){null!=e&&this._target.add(this._transformItems(this._source.get(e.items)))}},{key:"_update",value:function(t,e){null!=e&&this._target.update(this._transformItems(this._source.get(e.items)))}},{key:"_remove",value:function(t,e){null!=e&&this._target.remove(this._transformItems(e.oldData))}}]),t}(),Vx=function(){function t(e){Yd(this,t),$d(this,"_source",void 0),$d(this,"_transformers",[]),this._source=e}return Kd(t,[{key:"filter",value:function(t){return this._transformers.push((function(e){return Xf(e).call(e,t)})),this}},{key:"map",value:function(t){return this._transformers.push((function(e){return gu(e).call(e,t)})),this}},{key:"flatMap",value:function(t){return this._transformers.push((function(e){return m_(e).call(e,t)})),this}},{key:"to",value:function(t){return new qx(this._source,this._transformers,t)}}]),t}();function Ux(t){return"string"==typeof t||"number"==typeof t}var Yx=function(){function t(e){Yd(this,t),$d(this,"delay",void 0),$d(this,"max",void 0),$d(this,"_queue",[]),$d(this,"_timeout",null),$d(this,"_extended",null),this.delay=null,this.max=1/0,this.setOptions(e)}return Kd(t,[{key:"setOptions",value:function(t){t&&void 0!==t.delay&&(this.delay=t.delay),t&&void 0!==t.max&&(this.max=t.max),this._flushIfNeeded()}},{key:"destroy",value:function(){if(this.flush(),this._extended){for(var t=this._extended.object,e=this._extended.methods,i=0;i<e.length;i++){var n=e[i];n.original?t[n.name]=n.original:delete t[n.name]}this._extended=null}}},{key:"replace",value:function(t,e){var i=this,n=t[e];if(!n)throw new Error("Method "+e+" undefined");t[e]=function(){for(var t=arguments.length,e=new Array(t),o=0;o<t;o++)e[o]=arguments[o];i.queue({args:e,fn:n,context:this})}}},{key:"queue",value:function(t){"function"==typeof t?this._queue.push({fn:t}):this._queue.push(t),this._flushIfNeeded()}},{key:"_flushIfNeeded",value:function(){var t=this;this._queue.length>this.max&&this.flush(),null!=this._timeout&&(clearTimeout(this._timeout),this._timeout=null),this.queue.length>0&&"number"==typeof this.delay&&(this._timeout=Sv((function(){t.flush()}),this.delay))}},{key:"flush",value:function(){var t,e;Fu(t=ff(e=this._queue).call(e,0)).call(t,(function(t){t.fn.apply(t.context||t.fn,t.args||[])}))}}],[{key:"extend",value:function(e,i){var n=new t(i);if(void 0!==e.flush)throw new Error("Target object already has a property flush");e.flush=function(){n.flush()};var o=[{name:"flush",original:void 0}];if(i&&i.replace)for(var r=0;r<i.replace.length;r++){var s=i.replace[r];o.push({name:s,original:e[s]}),n.replace(e,s)}return n._extended={object:e,methods:o},n}}]),t}(),Xx=function(){function t(){Yd(this,t),$d(this,"_subscribers",{"*":[],add:[],remove:[],update:[]}),$d(this,"subscribe",t.prototype.on),$d(this,"unsubscribe",t.prototype.off)}return Kd(t,[{key:"_trigger",value:function(t,e,i){var n,o;if("*"===t)throw new Error("Cannot trigger event *");Fu(n=su(o=[]).call(o,Jc(this._subscribers[t]),Jc(this._subscribers["*"]))).call(n,(function(n){n(t,e,null!=i?i:null)}))}},{key:"on",value:function(t,e){"function"==typeof e&&this._subscribers[t].push(e)}},{key:"off",value:function(t,e){var i;this._subscribers[t]=Xf(i=this._subscribers[t]).call(i,(function(t){return t!==e}))}}]),t}();zx=w_;var Gx=function(){function t(e){Yd(this,t),$d(this,"_pairs",void 0),this._pairs=e}return Kd(t,[{key:zx,value:Rk.mark((function t(){var e,i,n,o,r;return Rk.wrap((function(t){for(;;)switch(t.prev=t.next){case 0:e=Hx(this._pairs),t.prev=1,e.s();case 3:if((i=e.n()).done){t.next=9;break}return n=Kc(i.value,2),o=n[0],r=n[1],t.next=7,[o,r];case 7:t.next=3;break;case 9:t.next=14;break;case 11:t.prev=11,t.t0=t.catch(1),e.e(t.t0);case 14:return t.prev=14,e.f(),t.finish(14);case 17:case"end":return t.stop()}}),t,this,[[1,11,14,17]])}))},{key:"entries",value:Rk.mark((function t(){var e,i,n,o,r;return Rk.wrap((function(t){for(;;)switch(t.prev=t.next){case 0:e=Hx(this._pairs),t.prev=1,e.s();case 3:if((i=e.n()).done){t.next=9;break}return n=Kc(i.value,2),o=n[0],r=n[1],t.next=7,[o,r];case 7:t.next=3;break;case 9:t.next=14;break;case 11:t.prev=11,t.t0=t.catch(1),e.e(t.t0);case 14:return t.prev=14,e.f(),t.finish(14);case 17:case"end":return t.stop()}}),t,this,[[1,11,14,17]])}))},{key:"keys",value:Rk.mark((function t(){var e,i,n,o;return Rk.wrap((function(t){for(;;)switch(t.prev=t.next){case 0:e=Hx(this._pairs),t.prev=1,e.s();case 3:if((i=e.n()).done){t.next=9;break}return n=Kc(i.value,1),o=n[0],t.next=7,o;case 7:t.next=3;break;case 9:t.next=14;break;case 11:t.prev=11,t.t0=t.catch(1),e.e(t.t0);case 14:return t.prev=14,e.f(),t.finish(14);case 17:case"end":return t.stop()}}),t,this,[[1,11,14,17]])}))},{key:"values",value:Rk.mark((function t(){var e,i,n,o;return Rk.wrap((function(t){for(;;)switch(t.prev=t.next){case 0:e=Hx(this._pairs),t.prev=1,e.s();case 3:if((i=e.n()).done){t.next=9;break}return n=Kc(i.value,2),o=n[1],t.next=7,o;case 7:t.next=3;break;case 9:t.next=14;break;case 11:t.prev=11,t.t0=t.catch(1),e.e(t.t0);case 14:return t.prev=14,e.f(),t.finish(14);case 17:case"end":return t.stop()}}),t,this,[[1,11,14,17]])}))},{key:"toIdArray",value:function(){var t;return gu(t=Jc(this._pairs)).call(t,(function(t){return t[0]}))}},{key:"toItemArray",value:function(){var t;return gu(t=Jc(this._pairs)).call(t,(function(t){return t[1]}))}},{key:"toEntryArray",value:function(){return Jc(this._pairs)}},{key:"toObjectMap",value:function(){var t,e=Kp(null),i=Hx(this._pairs);try{for(i.s();!(t=i.n()).done;){var n=Kc(t.value,2),o=n[0],r=n[1];e[o]=r}}catch(t){i.e(t)}finally{i.f()}return e}},{key:"toMap",value:function(){return new Jw(this._pairs)}},{key:"toIdSet",value:function(){return new b_(this.toIdArray())}},{key:"toItemSet",value:function(){return new b_(this.toItemArray())}},{key:"cache",value:function(){return new t(Jc(this._pairs))}},{key:"distinct",value:function(t){var e,i=new b_,n=Hx(this._pairs);try{for(n.s();!(e=n.n()).done;){var o=Kc(e.value,2),r=o[0],s=o[1];i.add(t(s,r))}}catch(t){n.e(t)}finally{n.f()}return i}},{key:"filter",value:function(e){var i=this._pairs;return new t($d({},w_,Rk.mark((function t(){var n,o,r,s,a;return Rk.wrap((function(t){for(;;)switch(t.prev=t.next){case 0:n=Hx(i),t.prev=1,n.s();case 3:if((o=n.n()).done){t.next=10;break}if(r=Kc(o.value,2),s=r[0],a=r[1],!e(a,s)){t.next=8;break}return t.next=8,[s,a];case 8:t.next=3;break;case 10:t.next=15;break;case 12:t.prev=12,t.t0=t.catch(1),n.e(t.t0);case 15:return t.prev=15,n.f(),t.finish(15);case 18:case"end":return t.stop()}}),t,null,[[1,12,15,18]])}))))}},{key:"forEach",value:function(t){var e,i=Hx(this._pairs);try{for(i.s();!(e=i.n()).done;){var n=Kc(e.value,2),o=n[0];t(n[1],o)}}catch(t){i.e(t)}finally{i.f()}}},{key:"map",value:function(e){var i=this._pairs;return new t($d({},w_,Rk.mark((function t(){var n,o,r,s,a;return Rk.wrap((function(t){for(;;)switch(t.prev=t.next){case 0:n=Hx(i),t.prev=1,n.s();case 3:if((o=n.n()).done){t.next=9;break}return r=Kc(o.value,2),s=r[0],a=r[1],t.next=7,[s,e(a,s)];case 7:t.next=3;break;case 9:t.next=14;break;case 11:t.prev=11,t.t0=t.catch(1),n.e(t.t0);case 14:return t.prev=14,n.f(),t.finish(14);case 17:case"end":return t.stop()}}),t,null,[[1,11,14,17]])}))))}},{key:"max",value:function(t){var e=k_(this._pairs),i=e.next();if(i.done)return null;for(var n=i.value[1],o=t(i.value[1],i.value[0]);!(i=e.next()).done;){var r=Kc(i.value,2),s=r[0],a=r[1],h=t(a,s);h>o&&(o=h,n=a)}return n}},{key:"min",value:function(t){var e=k_(this._pairs),i=e.next();if(i.done)return null;for(var n=i.value[1],o=t(i.value[1],i.value[0]);!(i=e.next()).done;){var r=Kc(i.value,2),s=r[0],a=r[1],h=t(a,s);h<o&&(o=h,n=a)}return n}},{key:"reduce",value:function(t,e){var i,n=Hx(this._pairs);try{for(n.s();!(i=n.n()).done;){var o=Kc(i.value,2),r=o[0];e=t(e,o[1],r)}}catch(t){n.e(t)}finally{n.f()}return e}},{key:"sort",value:function(e){var i=this;return new t($d({},w_,(function(){var t;return k_(rx(t=Jc(i._pairs)).call(t,(function(t,i){var n=Kc(t,2),o=n[0],r=n[1],s=Kc(i,2),a=s[0],h=s[1];return e(r,h,o,a)})))})))}}]),t}();var Kx=function(t){zk(i,t);var e=Lx(i);function i(t,n){var o;return Yd(this,i),$d(Pk(o=e.call(this)),"flush",void 0),$d(Pk(o),"length",void 0),$d(Pk(o),"_options",void 0),$d(Pk(o),"_data",void 0),$d(Pk(o),"_idProp",void 0),$d(Pk(o),"_queue",null),t&&!lu(t)&&(n=t,t=[]),o._options=n||{},o._data=new Jw,o.length=0,o._idProp=o._options.fieldId||"id",t&&t.length&&o.add(t),o.setOptions(n),o}return Kd(i,[{key:"idProp",get:function(){return this._idProp}},{key:"setOptions",value:function(t){t&&void 0!==t.queue&&(!1===t.queue?this._queue&&(this._queue.destroy(),this._queue=null):(this._queue||(this._queue=Yx.extend(this,{replace:["add","update","remove"]})),t.queue&&"object"===Qc(t.queue)&&this._queue.setOptions(t.queue)))}},{key:"add",value:function(t,e){var i,n=this,o=[];if(lu(t)){var r=gu(t).call(t,(function(t){return t[n._idProp]}));if(ck(r).call(r,(function(t){return n._data.has(t)})))throw new Error("A duplicate id was found in the parameter array.");for(var s=0,a=t.length;s<a;s++)i=this._addItem(t[s]),o.push(i)}else{if(!t||"object"!==Qc(t))throw new Error("Unknown dataType");i=this._addItem(t),o.push(i)}return o.length&&this._trigger("add",{items:o},e),o}},{key:"update",value:function(t,e){var i=this,n=[],o=[],r=[],s=[],a=this._idProp,h=function(t){var e=t[a];if(null!=e&&i._data.has(e)){var h=t,l=un({},i._data.get(e)),d=i._updateItem(h);o.push(d),s.push(h),r.push(l)}else{var c=i._addItem(t);n.push(c)}};if(lu(t))for(var l=0,d=t.length;l<d;l++)t[l]&&"object"===Qc(t[l])?h(t[l]):console.warn("Ignoring input item, which is not an object at index "+l);else{if(!t||"object"!==Qc(t))throw new Error("Unknown dataType");h(t)}if(n.length&&this._trigger("add",{items:n},e),o.length){var c={items:o,oldData:r,data:s};this._trigger("update",c,e)}return su(n).call(n,o)}},{key:"updateOnly",value:function(t,e){var i,n=this;lu(t)||(t=[t]);var o=gu(i=gu(t).call(t,(function(t){var e=n._data.get(t[n._idProp]);if(null==e)throw new Error("Updating non-existent items is not allowed.");return{oldData:e,update:t}}))).call(i,(function(t){var e=t.oldData,i=t.update,o=e[n._idProp],r=By(e,i);return n._data.set(o,r),{id:o,oldData:e,updatedData:r}}));if(o.length){var r={items:gu(o).call(o,(function(t){return t.id})),oldData:gu(o).call(o,(function(t){return t.oldData})),data:gu(o).call(o,(function(t){return t.updatedData}))};return this._trigger("update",r,e),r.items}return[]}},{key:"get",value:function(t,e){var i=void 0,n=void 0,o=void 0;Ux(t)?(i=t,o=e):lu(t)?(n=t,o=e):o=t;var r,s=o&&"Object"===o.returnType?"Object":"Array",a=o&&Xf(o),h=[],l=void 0,d=void 0,c=void 0;if(null!=i)(l=this._data.get(i))&&a&&!a(l)&&(l=void 0);else if(null!=n)for(var u=0,f=n.length;u<f;u++)null==(l=this._data.get(n[u]))||a&&!a(l)||h.push(l);else for(var p,v=0,g=(d=Jc(fx(p=this._data).call(p))).length;v<g;v++)c=d[v],null==(l=this._data.get(c))||a&&!a(l)||h.push(l);if(o&&o.order&&null==i&&this._sort(h,o.order),o&&o.fields){var y=o.fields;if(null!=i&&null!=l)l=this._filterFields(l,y);else for(var m=0,b=h.length;m<b;m++)h[m]=this._filterFields(h[m],y)}if("Object"==s){for(var w={},k=0,_=h.length;k<_;k++){var x=h[k];w[x[this._idProp]]=x}return w}return null!=i?null!==(r=l)&&void 0!==r?r:null:h}},{key:"getIds",value:function(t){var e=this._data,i=t&&Xf(t),n=t&&t.order,o=Jc(fx(e).call(e)),r=[];if(i)if(n){for(var s=[],a=0,h=o.length;a<h;a++){var l=o[a],d=this._data.get(l);null!=d&&i(d)&&s.push(d)}this._sort(s,n);for(var c=0,u=s.length;c<u;c++)r.push(s[c][this._idProp])}else for(var f=0,p=o.length;f<p;f++){var v=o[f],g=this._data.get(v);null!=g&&i(g)&&r.push(g[this._idProp])}else if(n){for(var y=[],m=0,b=o.length;m<b;m++){var w=o[m];y.push(e.get(w))}this._sort(y,n);for(var k=0,_=y.length;k<_;k++)r.push(y[k][this._idProp])}else for(var x=0,E=o.length;x<E;x++){var O=o[x],C=e.get(O);null!=C&&r.push(C[this._idProp])}return r}},{key:"getDataSet",value:function(){return this}},{key:"forEach",value:function(t,e){var i=e&&Xf(e),n=this._data,o=Jc(fx(n).call(n));if(e&&e.order)for(var r=this.get(e),s=0,a=r.length;s<a;s++){var h=r[s];t(h,h[this._idProp])}else for(var l=0,d=o.length;l<d;l++){var c=o[l],u=this._data.get(c);null==u||i&&!i(u)||t(u,c)}}},{key:"map",value:function(t,e){for(var i=e&&Xf(e),n=[],o=this._data,r=Jc(fx(o).call(o)),s=0,a=r.length;s<a;s++){var h=r[s],l=this._data.get(h);null==l||i&&!i(l)||n.push(t(l,h))}return e&&e.order&&this._sort(n,e.order),n}},{key:"_filterFields",value:function(t,e){var i;return t?i_(i=lu(e)?e:bu(e)).call(i,(function(e,i){return e[i]=t[i],e}),{}):t}},{key:"_sort",value:function(t,e){if("string"==typeof e){var i=e;rx(t).call(t,(function(t,e){var n=t[i],o=e[i];return n>o?1:n<o?-1:0}))}else{if("function"!=typeof e)throw new TypeError("Order must be a function or a string");rx(t).call(t,e)}}},{key:"remove",value:function(t,e){for(var i=[],n=[],o=lu(t)?t:[t],r=0,s=o.length;r<s;r++){var a=this._remove(o[r]);if(a){var h=a[this._idProp];null!=h&&(i.push(h),n.push(a))}}return i.length&&this._trigger("remove",{items:i,oldData:n},e),i}},{key:"_remove",value:function(t){var e;if(Ux(t)?e=t:t&&"object"===Qc(t)&&(e=t[this._idProp]),null!=e&&this._data.has(e)){var i=this._data.get(e)||null;return this._data.delete(e),--this.length,i}return null}},{key:"clear",value:function(t){for(var e,i=Jc(fx(e=this._data).call(e)),n=[],o=0,r=i.length;o<r;o++)n.push(this._data.get(i[o]));return this._data.clear(),this.length=0,this._trigger("remove",{items:i,oldData:n},t),i}},{key:"max",value:function(t){var e,i,n=null,o=null,r=Hx(kx(e=this._data).call(e));try{for(r.s();!(i=r.n()).done;){var s=i.value,a=s[t];"number"==typeof a&&(null==o||a>o)&&(n=s,o=a)}}catch(t){r.e(t)}finally{r.f()}return n||null}},{key:"min",value:function(t){var e,i,n=null,o=null,r=Hx(kx(e=this._data).call(e));try{for(r.s();!(i=r.n()).done;){var s=i.value,a=s[t];"number"==typeof a&&(null==o||a<o)&&(n=s,o=a)}}catch(t){r.e(t)}finally{r.f()}return n||null}},{key:"distinct",value:function(t){for(var e=this._data,i=Jc(fx(e).call(e)),n=[],o=0,r=0,s=i.length;r<s;r++){for(var a=i[r],h=e.get(a)[t],l=!1,d=0;d<o;d++)if(n[d]==h){l=!0;break}l||void 0===h||(n[o]=h,o++)}return n}},{key:"_addItem",value:function(t){var e=function(t,e){return null==t[e]&&(t[e]=Ax()),t}(t,this._idProp),i=e[this._idProp];if(this._data.has(i))throw new Error("Cannot add item: item with id "+i+" already exists");return this._data.set(i,e),++this.length,i}},{key:"_updateItem",value:function(t){var e=t[this._idProp];if(null==e)throw new Error("Cannot update item: item has no id (item: "+gv(t)+")");var i=this._data.get(e);if(!i)throw new Error("Cannot update item: no item with id "+e+" found");return this._data.set(e,Rx(Rx({},i),t)),e}},{key:"stream",value:function(t){if(t){var e=this._data;return new Gx($d({},w_,Rk.mark((function i(){var n,o,r,s;return Rk.wrap((function(i){for(;;)switch(i.prev=i.next){case 0:n=Hx(t),i.prev=1,n.s();case 3:if((o=n.n()).done){i.next=11;break}if(r=o.value,null==(s=e.get(r))){i.next=9;break}return i.next=9,[r,s];case 9:i.next=3;break;case 11:i.next=16;break;case 13:i.prev=13,i.t0=i.catch(1),n.e(i.t0);case 16:return i.prev=16,n.f(),i.finish(16);case 19:case"end":return i.stop()}}),i,null,[[1,13,16,19]])}))))}var i;return new Gx($d({},w_,zn(i=Mx(this._data)).call(i,this._data)))}}]),i}(Xx),$x=function(t){zk(i,t);var e=Lx(i);function i(t,n){var o,r;return Yd(this,i),$d(Pk(r=e.call(this)),"length",0),$d(Pk(r),"_listener",void 0),$d(Pk(r),"_data",void 0),$d(Pk(r),"_ids",new b_),$d(Pk(r),"_options",void 0),r._options=n||{},r._listener=zn(o=r._onEvent).call(o,Pk(r)),r.setData(t),r}return Kd(i,[{key:"idProp",get:function(){return this.getDataSet().idProp}},{key:"setData",value:function(t){if(this._data){this._data.off&&this._data.off("*",this._listener);var e=this._data.getIds({filter:Xf(this._options)}),i=this._data.get(e);this._ids.clear(),this.length=0,this._trigger("remove",{items:e,oldData:i})}if(null!=t){this._data=t;for(var n=this._data.getIds({filter:Xf(this._options)}),o=0,r=n.length;o<r;o++){var s=n[o];this._ids.add(s)}this.length=n.length,this._trigger("add",{items:n})}else this._data=new Kx;this._data.on&&this._data.on("*",this._listener)}},{key:"refresh",value:function(){for(var t=this._data.getIds({filter:Xf(this._options)}),e=Jc(this._ids),i={},n=[],o=[],r=[],s=0,a=t.length;s<a;s++){var h=t[s];i[h]=!0,this._ids.has(h)||(n.push(h),this._ids.add(h))}for(var l=0,d=e.length;l<d;l++){var c=e[l],u=this._data.get(c);null==u?console.error("If you see this, report it please."):i[c]||(o.push(c),r.push(u),this._ids.delete(c))}this.length+=n.length-o.length,n.length&&this._trigger("add",{items:n}),o.length&&this._trigger("remove",{items:o,oldData:r})}},{key:"get",value:function(t,e){if(null==this._data)return null;var i,n=null;Ux(t)||lu(t)?(n=t,i=e):i=t;var o=un({},this._options,i),r=Xf(this._options),s=i&&Xf(i);return r&&s&&(o.filter=function(t){return r(t)&&s(t)}),null==n?this._data.get(o):this._data.get(n,o)}},{key:"getIds",value:function(t){if(this._data.length){var e,i=Xf(this._options),n=null!=t?Xf(t):null;return e=n?i?function(t){return i(t)&&n(t)}:n:i,this._data.getIds({filter:e,order:t&&t.order})}return[]}},{key:"forEach",value:function(t,e){if(this._data){var i,n,o=Xf(this._options),r=e&&Xf(e);n=r?o?function(t){return o(t)&&r(t)}:r:o,Fu(i=this._data).call(i,t,{filter:n,order:e&&e.order})}}},{key:"map",value:function(t,e){if(this._data){var i,n,o=Xf(this._options),r=e&&Xf(e);return n=r?o?function(t){return o(t)&&r(t)}:r:o,gu(i=this._data).call(i,t,{filter:n,order:e&&e.order})}return[]}},{key:"getDataSet",value:function(){return this._data.getDataSet()}},{key:"stream",value:function(t){var e;return this._data.stream(t||$d({},w_,zn(e=fx(this._ids)).call(e,this._ids)))}},{key:"dispose",value:function(){var t;null!==(t=this._data)&&void 0!==t&&t.off&&this._data.off("*",this._listener);var e,n="This data view has already been disposed of.",o={get:function(){throw new Error(n)},set:function(){throw new Error(n)},configurable:!1},r=Hx(hu(i.prototype));try{for(r.s();!(e=r.n()).done;){var s=e.value;Ud(this,s,o)}}catch(t){r.e(t)}finally{r.f()}}},{key:"_onEvent",value:function(t,e,i){if(e&&e.items&&this._data){var n=e.items,o=[],r=[],s=[],a=[],h=[],l=[];switch(t){case"add":for(var d=0,c=n.length;d<c;d++){var u=n[d];this.get(u)&&(this._ids.add(u),o.push(u))}break;case"update":for(var f=0,p=n.length;f<p;f++){var v=n[f];this.get(v)?this._ids.has(v)?(r.push(v),h.push(e.data[f]),a.push(e.oldData[f])):(this._ids.add(v),o.push(v)):this._ids.has(v)&&(this._ids.delete(v),s.push(v),l.push(e.oldData[f]))}break;case"remove":for(var g=0,y=n.length;g<y;g++){var m=n[g];this._ids.has(m)&&(this._ids.delete(m),s.push(m),l.push(e.oldData[g]))}}this.length+=o.length-s.length,o.length&&this._trigger("add",{items:o},i),r.length&&this._trigger("update",{items:r,oldData:a,data:h},i),s.length&&this._trigger("remove",{items:s,oldData:l},i)}}}]),i}(Xx);function Zx(t,e){return"object"===Qc(e)&&null!==e&&t===e.idProp&&"function"==typeof e.add&&"function"==typeof e.clear&&"function"==typeof e.distinct&&"function"==typeof Fu(e)&&"function"==typeof e.get&&"function"==typeof e.getDataSet&&"function"==typeof e.getIds&&"number"==typeof e.length&&"function"==typeof gu(e)&&"function"==typeof e.max&&"function"==typeof e.min&&"function"==typeof e.off&&"function"==typeof e.on&&"function"==typeof e.remove&&"function"==typeof e.setOptions&&"function"==typeof e.stream&&"function"==typeof e.update&&"function"==typeof e.updateOnly}function Qx(t,e){return"object"===Qc(e)&&null!==e&&t===e.idProp&&"function"==typeof Fu(e)&&"function"==typeof e.get&&"function"==typeof e.getDataSet&&"function"==typeof e.getIds&&"number"==typeof e.length&&"function"==typeof gu(e)&&"function"==typeof e.off&&"function"==typeof e.on&&"function"==typeof e.stream&&Zx(t,e.getDataSet())}var Jx=Object.freeze({__proto__:null,DELETE:Iy,DataSet:Kx,DataStream:Gx,DataView:$x,Queue:Yx,createNewDataPipeFrom:function(t){return new Vx(t)},isDataSetLike:Zx,isDataViewLike:Qx}),tE=n,eE=o,iE=eo,nE=cp.trim,oE=g("".charAt),rE=tE.parseFloat,sE=tE.Symbol,aE=sE&&sE.iterator,hE=1/rE("\t\n\v\f\r                　\u2028\u2029\ufeff-0")!=-1/0||aE&&!eE((function(){rE(Object(aE))}))?function(t){var e=nE(iE(t)),i=rE(e);return 0===i&&"-"==oE(e,0)?-0:i}:rE;_i({global:!0,forced:parseFloat!=hE},{parseFloat:hE});var lE=X.parseFloat,dE=_i,cE=o,uE=hh.f;dE({target:"Object",stat:!0,forced:cE((function(){return!Object.getOwnPropertyNames(1)}))},{getOwnPropertyNames:uE});var fE=X.Object,pE=function(t){return fE.getOwnPropertyNames(t)},vE=pE;function gE(t,e){var i=["node","edge","label"],n=!0,o=Mm(e,"chosen");if("boolean"==typeof o)n=o;else if("object"===Qc(o)){if(-1===Fp(i).call(i,t))throw new Error("choosify: subOption '"+t+"' should be one of '"+i.join("', '")+"'");var r=Mm(e,["chosen",t]);"boolean"!=typeof r&&"function"!=typeof r||(n=r)}return n}function yE(t,e,i){if(t.width<=0||t.height<=0)return!1;if(void 0!==i){var n={x:e.x-i.x,y:e.y-i.y};if(0!==i.angle){var o=-i.angle;e={x:Math.cos(o)*n.x-Math.sin(o)*n.y,y:Math.sin(o)*n.x+Math.cos(o)*n.y}}else e=n}var r=t.x+t.width,s=t.y+t.width;return t.left<e.x&&r>e.x&&t.top<e.y&&s>e.y}function mE(t){return"string"==typeof t&&""!==t}function bE(t,e,i,n){var o=n.x,r=n.y;if("function"==typeof n.distanceToBorder){var s=n.distanceToBorder(t,e),a=Math.sin(e)*s,h=Math.cos(e)*s;h===s?(o+=s,r=n.y):a===s?(o=n.x,r-=s):(o+=h,r-=a)}else n.shape.width>n.shape.height?(o=n.x+.5*n.shape.width,r=n.y-i):(o=n.x+i,r=n.y-.5*n.shape.height);return{x:o,y:r}}var wE=function(){function t(e){Yd(this,t),this.measureText=e,this.current=0,this.width=0,this.height=0,this.lines=[]}return Kd(t,[{key:"_add",value:function(t,e){var i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"normal";void 0===this.lines[t]&&(this.lines[t]={width:0,height:0,blocks:[]});var n=e;void 0!==e&&""!==e||(n=" ");var o=this.measureText(n,i),r=un({},kx(o));r.text=e,r.width=o.width,r.mod=i,void 0!==e&&""!==e||(r.width=0),this.lines[t].blocks.push(r),this.lines[t].width+=r.width}},{key:"curWidth",value:function(){var t=this.lines[this.current];return void 0===t?0:t.width}},{key:"append",value:function(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"normal";this._add(this.current,t,e)}},{key:"newLine",value:function(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"normal";this._add(this.current,t,e),this.current++}},{key:"determineLineHeights",value:function(){for(var t=0;t<this.lines.length;t++){var e=this.lines[t],i=0;if(void 0!==e.blocks)for(var n=0;n<e.blocks.length;n++){var o=e.blocks[n];i<o.height&&(i=o.height)}e.height=i}}},{key:"determineLabelSize",value:function(){for(var t=0,e=0,i=0;i<this.lines.length;i++){var n=this.lines[i];n.width>t&&(t=n.width),e+=n.height}this.width=t,this.height=e}},{key:"removeEmptyBlocks",value:function(){for(var t=[],e=0;e<this.lines.length;e++){var i=this.lines[e];if(0!==i.blocks.length&&(e!==this.lines.length-1||0!==i.width)){var n={};un(n,i),n.blocks=[];for(var o=void 0,r=[],s=0;s<i.blocks.length;s++){var a=i.blocks[s];0!==a.width?r.push(a):void 0===o&&(o=a)}0===r.length&&void 0!==o&&r.push(o),n.blocks=r,t.push(n)}}return t}},{key:"finalize",value:function(){this.determineLineHeights(),this.determineLabelSize();var t=this.removeEmptyBlocks();return{width:this.width,height:this.height,lines:t}}}]),t}(),kE={"<b>":/<b>/,"<i>":/<i>/,"<code>":/<code>/,"</b>":/<\/b>/,"</i>":/<\/i>/,"</code>":/<\/code>/,"*":/\*/,_:/_/,"`":/`/,afterBold:/[^*]/,afterItal:/[^_]/,afterMono:/[^`]/},_E=function(){function t(e){Yd(this,t),this.text=e,this.bold=!1,this.ital=!1,this.mono=!1,this.spacing=!1,this.position=0,this.buffer="",this.modStack=[],this.blocks=[]}return Kd(t,[{key:"mod",value:function(){return 0===this.modStack.length?"normal":this.modStack[0]}},{key:"modName",value:function(){return 0===this.modStack.length?"normal":"mono"===this.modStack[0]?"mono":this.bold&&this.ital?"boldital":this.bold?"bold":this.ital?"ital":void 0}},{key:"emitBlock",value:function(){this.spacing&&(this.add(" "),this.spacing=!1),this.buffer.length>0&&(this.blocks.push({text:this.buffer,mod:this.modName()}),this.buffer="")}},{key:"add",value:function(t){" "===t&&(this.spacing=!0),this.spacing&&(this.buffer+=" ",this.spacing=!1)," "!=t&&(this.buffer+=t)}},{key:"parseWS",value:function(t){return!!/[ \t]/.test(t)&&(this.mono?this.add(t):this.spacing=!0,!0)}},{key:"setTag",value:function(t){this.emitBlock(),this[t]=!0,this.modStack.unshift(t)}},{key:"unsetTag",value:function(t){this.emitBlock(),this[t]=!1,this.modStack.shift()}},{key:"parseStartTag",value:function(t,e){return!(this.mono||this[t]||!this.match(e))&&(this.setTag(t),!0)}},{key:"match",value:function(t){var e=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],i=this.prepareRegExp(t),n=Kc(i,2),o=n[0],r=n[1],s=o.test(this.text.substr(this.position,r));return s&&e&&(this.position+=r-1),s}},{key:"parseEndTag",value:function(t,e,i){var n=this.mod()===t;return!(!(n="mono"===t?n&&this.mono:n&&!this.mono)||!this.match(e))&&(void 0!==i?(this.position===this.text.length-1||this.match(i,!1))&&this.unsetTag(t):this.unsetTag(t),!0)}},{key:"replace",value:function(t,e){return!!this.match(t)&&(this.add(e),this.position+=length-1,!0)}},{key:"prepareRegExp",value:function(t){var e,i;if(t instanceof RegExp)i=t,e=1;else{var n=kE[t];i=void 0!==n?n:new RegExp(t),e=t.length}return[i,e]}}]),t}(),xE=function(){function t(e,i,n,o){var r=this;Yd(this,t),this.ctx=e,this.parent=i,this.selected=n,this.hover=o;this.lines=new wE((function(t,i){if(void 0===t)return 0;var s=r.parent.getFormattingValues(e,n,o,i),a=0;""!==t&&(a=r.ctx.measureText(t).width);return{width:a,values:s}}))}return Kd(t,[{key:"process",value:function(t){if(!mE(t))return this.lines.finalize();var e=this.parent.fontOptions;t=(t=t.replace(/\r\n/g,"\n")).replace(/\r/g,"\n");var i=String(t).split("\n"),n=i.length;if(e.multi)for(var o=0;o<n;o++){var r=this.splitBlocks(i[o],e.multi);if(void 0!==r)if(0!==r.length){if(e.maxWdt>0)for(var s=0;s<r.length;s++){var a=r[s].mod,h=r[s].text;this.splitStringIntoLines(h,a,!0)}else for(var l=0;l<r.length;l++){var d=r[l].mod,c=r[l].text;this.lines.append(c,d)}this.lines.newLine()}else this.lines.newLine("")}else if(e.maxWdt>0)for(var u=0;u<n;u++)this.splitStringIntoLines(i[u]);else for(var f=0;f<n;f++)this.lines.newLine(i[f]);return this.lines.finalize()}},{key:"decodeMarkupSystem",value:function(t){var e="none";return"markdown"===t||"md"===t?e="markdown":!0!==t&&"html"!==t||(e="html"),e}},{key:"splitHtmlBlocks",value:function(t){for(var e=new _E(t),i=function(t){return!!/&/.test(t)&&(e.replace(e.text,"&lt;","<")||e.replace(e.text,"&amp;","&")||e.add("&"),!0)};e.position<e.text.length;){var n=e.text.charAt(e.position);e.parseWS(n)||/</.test(n)&&(e.parseStartTag("bold","<b>")||e.parseStartTag("ital","<i>")||e.parseStartTag("mono","<code>")||e.parseEndTag("bold","</b>")||e.parseEndTag("ital","</i>")||e.parseEndTag("mono","</code>"))||i(n)||e.add(n),e.position++}return e.emitBlock(),e.blocks}},{key:"splitMarkdownBlocks",value:function(t){for(var e=this,i=new _E(t),n=!0,o=function(t){return!!/\\/.test(t)&&(i.position<e.text.length+1&&(i.position++,t=e.text.charAt(i.position),/ \t/.test(t)?i.spacing=!0:(i.add(t),n=!1)),!0)};i.position<i.text.length;){var r=i.text.charAt(i.position);i.parseWS(r)||o(r)||(n||i.spacing)&&(i.parseStartTag("bold","*")||i.parseStartTag("ital","_")||i.parseStartTag("mono","`"))||i.parseEndTag("bold","*","afterBold")||i.parseEndTag("ital","_","afterItal")||i.parseEndTag("mono","`","afterMono")||(i.add(r),n=!1),i.position++}return i.emitBlock(),i.blocks}},{key:"splitBlocks",value:function(t,e){var i=this.decodeMarkupSystem(e);return"none"===i?[{text:t,mod:"normal"}]:"markdown"===i?this.splitMarkdownBlocks(t):"html"===i?this.splitHtmlBlocks(t):void 0}},{key:"overMaxWidth",value:function(t){var e=this.ctx.measureText(t).width;return this.lines.curWidth()+e>this.parent.fontOptions.maxWdt}},{key:"getLongestFit",value:function(t){for(var e="",i=0;i<t.length;){var n=e+(""===e?"":" ")+t[i];if(this.overMaxWidth(n))break;e=n,i++}return i}},{key:"getLongestFitWord",value:function(t){for(var e=0;e<t.length&&!this.overMaxWidth(au(t).call(t,0,e));)e++;return e}},{key:"splitStringIntoLines",value:function(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"normal",i=arguments.length>2&&void 0!==arguments[2]&&arguments[2];this.parent.getFormattingValues(this.ctx,this.selected,this.hover,e);for(var n=(t=(t=t.replace(/^( +)/g,"$1\r")).replace(/([^\r][^ ]*)( +)/g,"$1\r$2\r")).split("\r");n.length>0;){var o=this.getLongestFit(n);if(0===o){var r=n[0],s=this.getLongestFitWord(r);this.lines.newLine(au(r).call(r,0,s),e),n[0]=au(r).call(r,s)}else{var a=o;" "===n[o-1]?o--:" "===n[a]&&a++;var h=au(n).call(n,0,o).join("");o==n.length&&i?this.lines.append(h,e):this.lines.newLine(h,e),n=au(n).call(n,a)}}}}]),t}(),EE=["bold","ital","boldital","mono"],OE=function(){function t(e,i){var n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];Yd(this,t),this.body=e,this.pointToSelf=!1,this.baseSize=void 0,this.fontOptions={},this.setOptions(i),this.size={top:0,left:0,width:0,height:0,yLine:0},this.isEdgeLabel=n}return Kd(t,[{key:"setOptions",value:function(t){if(this.elementOptions=t,this.initFontOptions(t.font),mE(t.label)?this.labelDirty=!0:t.label=void 0,void 0!==t.font&&null!==t.font)if("string"==typeof t.font)this.baseSize=this.fontOptions.size;else if("object"===Qc(t.font)){var e=t.font.size;void 0!==e&&(this.baseSize=e)}}},{key:"initFontOptions",value:function(e){var i=this;hm(EE,(function(t){i.fontOptions[t]={}})),t.parseFontString(this.fontOptions,e)?this.fontOptions.vadjust=0:hm(e,(function(t,e){null!=t&&"object"!==Qc(t)&&(i.fontOptions[e]=t)}))}},{key:"constrain",value:function(t){var e={constrainWidth:!1,maxWdt:-1,minWdt:-1,constrainHeight:!1,minHgt:-1,valign:"middle"},i=Mm(t,"widthConstraint");if("number"==typeof i)e.maxWdt=Number(i),e.minWdt=Number(i);else if("object"===Qc(i)){var n=Mm(t,["widthConstraint","maximum"]);"number"==typeof n&&(e.maxWdt=Number(n));var o=Mm(t,["widthConstraint","minimum"]);"number"==typeof o&&(e.minWdt=Number(o))}var r=Mm(t,"heightConstraint");if("number"==typeof r)e.minHgt=Number(r);else if("object"===Qc(r)){var s=Mm(t,["heightConstraint","minimum"]);"number"==typeof s&&(e.minHgt=Number(s));var a=Mm(t,["heightConstraint","valign"]);"string"==typeof a&&("top"!==a&&"bottom"!==a||(e.valign=a))}return e}},{key:"update",value:function(t,e){this.setOptions(t,!0),this.propagateFonts(e),nm(this.fontOptions,this.constrain(e)),this.fontOptions.chooser=gE("label",e)}},{key:"adjustSizes",value:function(t){var e=t?t.right+t.left:0;this.fontOptions.constrainWidth&&(this.fontOptions.maxWdt-=e,this.fontOptions.minWdt-=e);var i=t?t.top+t.bottom:0;this.fontOptions.constrainHeight&&(this.fontOptions.minHgt-=i)}},{key:"addFontOptionsToPile",value:function(t,e){for(var i=0;i<e.length;++i)this.addFontToPile(t,e[i])}},{key:"addFontToPile",value:function(t,e){if(void 0!==e&&void 0!==e.font&&null!==e.font){var i=e.font;t.push(i)}}},{key:"getBasicOptions",value:function(e){for(var i={},n=0;n<e.length;++n){var o=e[n],r={};t.parseFontString(r,o)&&(o=r),hm(o,(function(t,e){void 0!==t&&(Object.prototype.hasOwnProperty.call(i,e)||(-1!==Fp(EE).call(EE,e)?i[e]={}:i[e]=t))}))}return i}},{key:"getFontOption",value:function(e,i,n){for(var o,r=0;r<e.length;++r){var s=e[r];if(Object.prototype.hasOwnProperty.call(s,i)){if(null==(o=s[i]))continue;var a={};if(t.parseFontString(a,o)&&(o=a),Object.prototype.hasOwnProperty.call(o,n))return o[n]}}if(Object.prototype.hasOwnProperty.call(this.fontOptions,n))return this.fontOptions[n];throw new Error("Did not find value for multi-font for property: '"+n+"'")}},{key:"getFontOptions",value:function(t,e){for(var i={},n=["color","size","face","mod","vadjust"],o=0;o<n.length;++o){var r=n[o];i[r]=this.getFontOption(t,e,r)}return i}},{key:"propagateFonts",value:function(t){var e=this,i=[];this.addFontOptionsToPile(i,t),this.fontOptions=this.getBasicOptions(i);for(var n=function(t){var n=EE[t],o=e.fontOptions[n];hm(e.getFontOptions(i,n),(function(t,e){o[e]=t})),o.size=Number(o.size),o.vadjust=Number(o.vadjust)},o=0;o<EE.length;++o)n(o)}},{key:"draw",value:function(t,e,i,n,o){var r=arguments.length>5&&void 0!==arguments[5]?arguments[5]:"middle";if(void 0!==this.elementOptions.label){var s=this.fontOptions.size*this.body.view.scale;this.elementOptions.label&&s<this.elementOptions.scaling.label.drawThreshold-1||(s>=this.elementOptions.scaling.label.maxVisible&&(s=Number(this.elementOptions.scaling.label.maxVisible)/this.body.view.scale),this.calculateLabelSize(t,n,o,e,i,r),this._drawBackground(t),this._drawText(t,e,this.size.yLine,r,s))}}},{key:"_drawBackground",value:function(t){if(void 0!==this.fontOptions.background&&"none"!==this.fontOptions.background){t.fillStyle=this.fontOptions.background;var e=this.getSize();t.fillRect(e.left,e.top,e.width,e.height)}}},{key:"_drawText",value:function(t,e,i){var n=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"middle",o=arguments.length>4?arguments[4]:void 0,r=this._setAlignment(t,e,i,n),s=Kc(r,2);e=s[0],i=s[1],t.textAlign="left",e-=this.size.width/2,this.fontOptions.valign&&this.size.height>this.size.labelHeight&&("top"===this.fontOptions.valign&&(i-=(this.size.height-this.size.labelHeight)/2),"bottom"===this.fontOptions.valign&&(i+=(this.size.height-this.size.labelHeight)/2));for(var a=0;a<this.lineCount;a++){var h=this.lines[a];if(h&&h.blocks){var l=0;this.isEdgeLabel||"center"===this.fontOptions.align?l+=(this.size.width-h.width)/2:"right"===this.fontOptions.align&&(l+=this.size.width-h.width);for(var d=0;d<h.blocks.length;d++){var c=h.blocks[d];t.font=c.font;var u=this._getColor(c.color,o,c.strokeColor),f=Kc(u,2),p=f[0],v=f[1];c.strokeWidth>0&&(t.lineWidth=c.strokeWidth,t.strokeStyle=v,t.lineJoin="round"),t.fillStyle=p,c.strokeWidth>0&&t.strokeText(c.text,e+l,i+c.vadjust),t.fillText(c.text,e+l,i+c.vadjust),l+=c.width}i+=h.height}}}},{key:"_setAlignment",value:function(t,e,i,n){if(this.isEdgeLabel&&"horizontal"!==this.fontOptions.align&&!1===this.pointToSelf){e=0,i=0;"top"===this.fontOptions.align?(t.textBaseline="alphabetic",i-=4):"bottom"===this.fontOptions.align?(t.textBaseline="hanging",i+=4):t.textBaseline="middle"}else t.textBaseline=n;return[e,i]}},{key:"_getColor",value:function(t,e,i){var n=t||"#000000",o=i||"#ffffff";if(e<=this.elementOptions.scaling.label.drawThreshold){var r=Math.max(0,Math.min(1,1-(this.elementOptions.scaling.label.drawThreshold-e)));n=pm(n,r),o=pm(o,r)}return[n,o]}},{key:"getTextSize",value:function(t){var e=arguments.length>1&&void 0!==arguments[1]&&arguments[1],i=arguments.length>2&&void 0!==arguments[2]&&arguments[2];return this._processLabel(t,e,i),{width:this.size.width,height:this.size.height,lineCount:this.lineCount}}},{key:"getSize",value:function(){var t=this.size.left,e=this.size.top-1;if(this.isEdgeLabel){var i=.5*-this.size.width;switch(this.fontOptions.align){case"middle":t=i,e=.5*-this.size.height;break;case"top":t=i,e=-(this.size.height+2);break;case"bottom":t=i,e=2}}return{left:t,top:e,width:this.size.width,height:this.size.height}}},{key:"calculateLabelSize",value:function(t,e,i){var n=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0,o=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,r=arguments.length>5&&void 0!==arguments[5]?arguments[5]:"middle";this._processLabel(t,e,i),this.size.left=n-.5*this.size.width,this.size.top=o-.5*this.size.height,this.size.yLine=o+.5*(1-this.lineCount)*this.fontOptions.size,"hanging"===r&&(this.size.top+=.5*this.fontOptions.size,this.size.top+=4,this.size.yLine+=4)}},{key:"getFormattingValues",value:function(t,e,i,n){var o=function(t,e,i){return"normal"===e?"mod"===i?"":t[i]:void 0!==t[e][i]?t[e][i]:t[i]},r={color:o(this.fontOptions,n,"color"),size:o(this.fontOptions,n,"size"),face:o(this.fontOptions,n,"face"),mod:o(this.fontOptions,n,"mod"),vadjust:o(this.fontOptions,n,"vadjust"),strokeWidth:this.fontOptions.strokeWidth,strokeColor:this.fontOptions.strokeColor};(e||i)&&("normal"===n&&!0===this.fontOptions.chooser&&this.elementOptions.labelHighlightBold?r.mod="bold":"function"==typeof this.fontOptions.chooser&&this.fontOptions.chooser(r,this.elementOptions.id,e,i));var s="";return void 0!==r.mod&&""!==r.mod&&(s+=r.mod+" "),s+=r.size+"px "+r.face,t.font=s.replace(/"/g,""),r.font=t.font,r.height=r.size,r}},{key:"differentState",value:function(t,e){return t!==this.selectedState||e!==this.hoverState}},{key:"_processLabelText",value:function(t,e,i,n){return new xE(t,this,e,i).process(n)}},{key:"_processLabel",value:function(t,e,i){if(!1!==this.labelDirty||this.differentState(e,i)){var n=this._processLabelText(t,e,i,this.elementOptions.label);this.fontOptions.minWdt>0&&n.width<this.fontOptions.minWdt&&(n.width=this.fontOptions.minWdt),this.size.labelHeight=n.height,this.fontOptions.minHgt>0&&n.height<this.fontOptions.minHgt&&(n.height=this.fontOptions.minHgt),this.lines=n.lines,this.lineCount=n.lines.length,this.size.width=n.width,this.size.height=n.height,this.selectedState=e,this.hoverState=i,this.labelDirty=!1}}},{key:"visible",value:function(){return 0!==this.size.width&&0!==this.size.height&&void 0!==this.elementOptions.label&&!(this.fontOptions.size*this.body.view.scale<this.elementOptions.scaling.label.drawThreshold-1)}}],[{key:"parseFontString",value:function(t,e){if(!e||"string"!=typeof e)return!1;var i=e.split(" ");return t.size=+i[0].replace("px",""),t.face=i[1],t.color=i[2],!0}}]),t}(),CE=function(){function t(e,i,n){Yd(this,t),this.body=i,this.labelModule=n,this.setOptions(e),this.top=void 0,this.left=void 0,this.height=void 0,this.width=void 0,this.radius=void 0,this.margin=void 0,this.refreshNeeded=!0,this.boundingBox={top:0,left:0,right:0,bottom:0}}return Kd(t,[{key:"setOptions",value:function(t){this.options=t}},{key:"_setMargins",value:function(t){this.margin={},this.options.margin&&("object"==Qc(this.options.margin)?(this.margin.top=this.options.margin.top,this.margin.right=this.options.margin.right,this.margin.bottom=this.options.margin.bottom,this.margin.left=this.options.margin.left):(this.margin.top=this.options.margin,this.margin.right=this.options.margin,this.margin.bottom=this.options.margin,this.margin.left=this.options.margin)),t.adjustSizes(this.margin)}},{key:"_distanceToBorder",value:function(t,e){var i=this.options.borderWidth;return t&&this.resize(t),Math.min(Math.abs(this.width/2/Math.cos(e)),Math.abs(this.height/2/Math.sin(e)))+i}},{key:"enableShadow",value:function(t,e){e.shadow&&(t.shadowColor=e.shadowColor,t.shadowBlur=e.shadowSize,t.shadowOffsetX=e.shadowX,t.shadowOffsetY=e.shadowY)}},{key:"disableShadow",value:function(t,e){e.shadow&&(t.shadowColor="rgba(0,0,0,0)",t.shadowBlur=0,t.shadowOffsetX=0,t.shadowOffsetY=0)}},{key:"enableBorderDashes",value:function(t,e){if(!1!==e.borderDashes)if(void 0!==t.setLineDash){var i=e.borderDashes;!0===i&&(i=[5,15]),t.setLineDash(i)}else console.warn("setLineDash is not supported in this browser. The dashed borders cannot be used."),this.options.shapeProperties.borderDashes=!1,e.borderDashes=!1}},{key:"disableBorderDashes",value:function(t,e){!1!==e.borderDashes&&(void 0!==t.setLineDash?t.setLineDash([0]):(console.warn("setLineDash is not supported in this browser. The dashed borders cannot be used."),this.options.shapeProperties.borderDashes=!1,e.borderDashes=!1))}},{key:"needsRefresh",value:function(t,e){return!0===this.refreshNeeded?(this.refreshNeeded=!1,!0):void 0===this.width||this.labelModule.differentState(t,e)}},{key:"initContextForDraw",value:function(t,e){var i=e.borderWidth/this.body.view.scale;t.lineWidth=Math.min(this.width,i),t.strokeStyle=e.borderColor,t.fillStyle=e.color}},{key:"performStroke",value:function(t,e){var i=e.borderWidth/this.body.view.scale;t.save(),i>0&&(this.enableBorderDashes(t,e),t.stroke(),this.disableBorderDashes(t,e)),t.restore()}},{key:"performFill",value:function(t,e){t.save(),t.fillStyle=e.color,this.enableShadow(t,e),jv(t).call(t),this.disableShadow(t,e),t.restore(),this.performStroke(t,e)}},{key:"_addBoundingBoxMargin",value:function(t){this.boundingBox.left-=t,this.boundingBox.top-=t,this.boundingBox.bottom+=t,this.boundingBox.right+=t}},{key:"_updateBoundingBox",value:function(t,e,i,n,o){void 0!==i&&this.resize(i,n,o),this.left=t-this.width/2,this.top=e-this.height/2,this.boundingBox.left=this.left,this.boundingBox.top=this.top,this.boundingBox.bottom=this.top+this.height,this.boundingBox.right=this.left+this.width}},{key:"updateBoundingBox",value:function(t,e,i,n,o){this._updateBoundingBox(t,e,i,n,o)}},{key:"getDimensionsFromLabel",value:function(t,e,i){this.textSize=this.labelModule.getTextSize(t,e,i);var n=this.textSize.width,o=this.textSize.height;return 0===n&&(n=14,o=14),{width:n,height:o}}}]),t}();function SE(t){var e=function(){if("undefined"==typeof Reflect||!Mk)return!1;if(Mk.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Mk(Boolean,[],(function(){}))),!0}catch(t){return!1}}();return function(){var i,n=Ak(t);if(e){var o=Ak(this).constructor;i=Mk(n,arguments,o)}else i=n.apply(this,arguments);return Nk(this,i)}}var TE=function(t){zk(i,t);var e=SE(i);function i(t,n,o){var r;return Yd(this,i),(r=e.call(this,t,n,o))._setMargins(o),r}return Kd(i,[{key:"resize",value:function(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.selected,i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:this.hover;if(this.needsRefresh(e,i)){var n=this.getDimensionsFromLabel(t,e,i);this.width=n.width+this.margin.right+this.margin.left,this.height=n.height+this.margin.top+this.margin.bottom,this.radius=this.width/2}}},{key:"draw",value:function(t,e,i,n,o,r){this.resize(t,n,o),this.left=e-this.width/2,this.top=i-this.height/2,this.initContextForDraw(t,r),Fn(t,this.left,this.top,this.width,this.height,r.borderRadius),this.performFill(t,r),this.updateBoundingBox(e,i,t,n,o),this.labelModule.draw(t,this.left+this.textSize.width/2+this.margin.left,this.top+this.textSize.height/2+this.margin.top,n,o)}},{key:"updateBoundingBox",value:function(t,e,i,n,o){this._updateBoundingBox(t,e,i,n,o);var r=this.options.shapeProperties.borderRadius;this._addBoundingBoxMargin(r)}},{key:"distanceToBorder",value:function(t,e){t&&this.resize(t);var i=this.options.borderWidth;return Math.min(Math.abs(this.width/2/Math.cos(e)),Math.abs(this.height/2/Math.sin(e)))+i}}]),i}(CE);function ME(t){var e=function(){if("undefined"==typeof Reflect||!Mk)return!1;if(Mk.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Mk(Boolean,[],(function(){}))),!0}catch(t){return!1}}();return function(){var i,n=Ak(t);if(e){var o=Ak(this).constructor;i=Mk(n,arguments,o)}else i=n.apply(this,arguments);return Nk(this,i)}}var PE=function(t){zk(i,t);var e=ME(i);function i(t,n,o){var r;return Yd(this,i),(r=e.call(this,t,n,o)).labelOffset=0,r.selected=!1,r}return Kd(i,[{key:"setOptions",value:function(t,e,i){this.options=t,void 0===e&&void 0===i||this.setImages(e,i)}},{key:"setImages",value:function(t,e){e&&this.selected?(this.imageObj=e,this.imageObjAlt=t):(this.imageObj=t,this.imageObjAlt=e)}},{key:"switchImages",value:function(t){var e=t&&!this.selected||!t&&this.selected;if(this.selected=t,void 0!==this.imageObjAlt&&e){var i=this.imageObj;this.imageObj=this.imageObjAlt,this.imageObjAlt=i}}},{key:"_getImagePadding",value:function(){var t={top:0,right:0,bottom:0,left:0};if(this.options.imagePadding){var e=this.options.imagePadding;"object"==Qc(e)?(t.top=e.top,t.right=e.right,t.bottom=e.bottom,t.left=e.left):(t.top=e,t.right=e,t.bottom=e,t.left=e)}return t}},{key:"_resizeImage",value:function(){var t,e;if(!1===this.options.shapeProperties.useImageSize){var i=1,n=1;this.imageObj.width&&this.imageObj.height&&(this.imageObj.width>this.imageObj.height?i=this.imageObj.width/this.imageObj.height:n=this.imageObj.height/this.imageObj.width),t=2*this.options.size*i,e=2*this.options.size*n}else{var o=this._getImagePadding();t=this.imageObj.width+o.left+o.right,e=this.imageObj.height+o.top+o.bottom}this.width=t,this.height=e,this.radius=.5*this.width}},{key:"_drawRawCircle",value:function(t,e,i,n){this.initContextForDraw(t,n),Nn(t,e,i,n.size),this.performFill(t,n)}},{key:"_drawImageAtPosition",value:function(t,e){if(0!=this.imageObj.width){t.globalAlpha=void 0!==e.opacity?e.opacity:1,this.enableShadow(t,e);var i=1;!0===this.options.shapeProperties.interpolation&&(i=this.imageObj.width/this.width/this.body.view.scale);var n=this._getImagePadding(),o=this.left+n.left,r=this.top+n.top,s=this.width-n.left-n.right,a=this.height-n.top-n.bottom;this.imageObj.drawImageAtPosition(t,i,o,r,s,a),this.disableShadow(t,e)}}},{key:"_drawImageLabel",value:function(t,e,i,n,o){var r=0;if(void 0!==this.height){r=.5*this.height;var s=this.labelModule.getTextSize(t,n,o);s.lineCount>=1&&(r+=s.height/2)}var a=i+r;this.options.label&&(this.labelOffset=r),this.labelModule.draw(t,e,a,n,o,"hanging")}}]),i}(CE);function DE(t){var e=function(){if("undefined"==typeof Reflect||!Mk)return!1;if(Mk.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Mk(Boolean,[],(function(){}))),!0}catch(t){return!1}}();return function(){var i,n=Ak(t);if(e){var o=Ak(this).constructor;i=Mk(n,arguments,o)}else i=n.apply(this,arguments);return Nk(this,i)}}var IE=function(t){zk(i,t);var e=DE(i);function i(t,n,o){var r;return Yd(this,i),(r=e.call(this,t,n,o))._setMargins(o),r}return Kd(i,[{key:"resize",value:function(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.selected,i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:this.hover;if(this.needsRefresh(e,i)){var n=this.getDimensionsFromLabel(t,e,i),o=Math.max(n.width+this.margin.right+this.margin.left,n.height+this.margin.top+this.margin.bottom);this.options.size=o/2,this.width=o,this.height=o,this.radius=this.width/2}}},{key:"draw",value:function(t,e,i,n,o,r){this.resize(t,n,o),this.left=e-this.width/2,this.top=i-this.height/2,this._drawRawCircle(t,e,i,r),this.updateBoundingBox(e,i),this.labelModule.draw(t,this.left+this.textSize.width/2+this.margin.left,i,n,o)}},{key:"updateBoundingBox",value:function(t,e){this.boundingBox.top=e-this.options.size,this.boundingBox.left=t-this.options.size,this.boundingBox.right=t+this.options.size,this.boundingBox.bottom=e+this.options.size}},{key:"distanceToBorder",value:function(t){return t&&this.resize(t),.5*this.width}}]),i}(PE);function BE(t){var e=function(){if("undefined"==typeof Reflect||!Mk)return!1;if(Mk.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Mk(Boolean,[],(function(){}))),!0}catch(t){return!1}}();return function(){var i,n=Ak(t);if(e){var o=Ak(this).constructor;i=Mk(n,arguments,o)}else i=n.apply(this,arguments);return Nk(this,i)}}var zE=function(t){zk(i,t);var e=BE(i);function i(t,n,o,r,s){var a;return Yd(this,i),(a=e.call(this,t,n,o)).setImages(r,s),a}return Kd(i,[{key:"resize",value:function(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.selected,i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:this.hover,n=void 0===this.imageObj.src||void 0===this.imageObj.width||void 0===this.imageObj.height;if(n){var o=2*this.options.size;return this.width=o,this.height=o,void(this.radius=.5*this.width)}this.needsRefresh(e,i)&&this._resizeImage()}},{key:"draw",value:function(t,e,i,n,o,r){this.switchImages(n),this.resize();var s=e,a=i;"top-left"===this.options.shapeProperties.coordinateOrigin?(this.left=e,this.top=i,s+=this.width/2,a+=this.height/2):(this.left=e-this.width/2,this.top=i-this.height/2),this._drawRawCircle(t,s,a,r),t.save(),t.clip(),this._drawImageAtPosition(t,r),t.restore(),this._drawImageLabel(t,s,a,n,o),this.updateBoundingBox(e,i)}},{key:"updateBoundingBox",value:function(t,e){"top-left"===this.options.shapeProperties.coordinateOrigin?(this.boundingBox.top=e,this.boundingBox.left=t,this.boundingBox.right=t+2*this.options.size,this.boundingBox.bottom=e+2*this.options.size):(this.boundingBox.top=e-this.options.size,this.boundingBox.left=t-this.options.size,this.boundingBox.right=t+this.options.size,this.boundingBox.bottom=e+this.options.size),this.boundingBox.left=Math.min(this.boundingBox.left,this.labelModule.size.left),this.boundingBox.right=Math.max(this.boundingBox.right,this.labelModule.size.left+this.labelModule.size.width),this.boundingBox.bottom=Math.max(this.boundingBox.bottom,this.boundingBox.bottom+this.labelOffset)}},{key:"distanceToBorder",value:function(t){return t&&this.resize(t),.5*this.width}}]),i}(PE);function NE(t){var e=function(){if("undefined"==typeof Reflect||!Mk)return!1;if(Mk.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Mk(Boolean,[],(function(){}))),!0}catch(t){return!1}}();return function(){var i,n=Ak(t);if(e){var o=Ak(this).constructor;i=Mk(n,arguments,o)}else i=n.apply(this,arguments);return Nk(this,i)}}var FE=function(t){zk(i,t);var e=NE(i);function i(t,n,o){return Yd(this,i),e.call(this,t,n,o)}return Kd(i,[{key:"resize",value:function(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.selected,i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:this.hover,n=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{size:this.options.size};if(this.needsRefresh(e,i)){var o,r;this.labelModule.getTextSize(t,e,i);var s=2*n.size;this.width=null!==(o=this.customSizeWidth)&&void 0!==o?o:s,this.height=null!==(r=this.customSizeHeight)&&void 0!==r?r:s,this.radius=.5*this.width}}},{key:"_drawShape",value:function(t,e,i,n,o,r,s,a){var h,l=this;return this.resize(t,r,s,a),this.left=n-this.width/2,this.top=o-this.height/2,this.initContextForDraw(t,a),(h=e,Object.prototype.hasOwnProperty.call(Ln,h)?Ln[h]:function(t){for(var e=arguments.length,i=new Array(e>1?e-1:0),n=1;n<e;n++)i[n-1]=arguments[n];CanvasRenderingContext2D.prototype[h].call(t,i)})(t,n,o,a.size),this.performFill(t,a),void 0!==this.options.icon&&void 0!==this.options.icon.code&&(t.font=(r?"bold ":"")+this.height/2+"px "+(this.options.icon.face||"FontAwesome"),t.fillStyle=this.options.icon.color||"black",t.textAlign="center",t.textBaseline="middle",t.fillText(this.options.icon.code,n,o)),{drawExternalLabel:function(){if(void 0!==l.options.label){l.labelModule.calculateLabelSize(t,r,s,n,o,"hanging");var e=o+.5*l.height+.5*l.labelModule.size.height;l.labelModule.draw(t,n,e,r,s,"hanging")}l.updateBoundingBox(n,o)}}}},{key:"updateBoundingBox",value:function(t,e){this.boundingBox.top=e-this.options.size,this.boundingBox.left=t-this.options.size,this.boundingBox.right=t+this.options.size,this.boundingBox.bottom=e+this.options.size,void 0!==this.options.label&&this.labelModule.size.width>0&&(this.boundingBox.left=Math.min(this.boundingBox.left,this.labelModule.size.left),this.boundingBox.right=Math.max(this.boundingBox.right,this.labelModule.size.left+this.labelModule.size.width),this.boundingBox.bottom=Math.max(this.boundingBox.bottom,this.boundingBox.bottom+this.labelModule.size.height))}}]),i}(CE);function AE(t,e){var i=bu(t);if(hd){var n=hd(t);e&&(n=Xf(n).call(n,(function(e){return bd(t,e).enumerable}))),i.push.apply(i,n)}return i}function jE(t){for(var e=1;e<arguments.length;e++){var i,n,o=null!=arguments[e]?arguments[e]:{};e%2?Fu(i=AE(Object(o),!0)).call(i,(function(e){$d(t,e,o[e])})):Pd?Ad(t,Pd(o)):Fu(n=AE(Object(o))).call(n,(function(e){Ud(t,e,bd(o,e))}))}return t}function RE(t){var e=function(){if("undefined"==typeof Reflect||!Mk)return!1;if(Mk.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Mk(Boolean,[],(function(){}))),!0}catch(t){return!1}}();return function(){var i,n=Ak(t);if(e){var o=Ak(this).constructor;i=Mk(n,arguments,o)}else i=n.apply(this,arguments);return Nk(this,i)}}var LE=function(t){zk(i,t);var e=RE(i);function i(t,n,o,r){var s;return Yd(this,i),(s=e.call(this,t,n,o,r)).ctxRenderer=r,s}return Kd(i,[{key:"draw",value:function(t,e,i,n,o,r){this.resize(t,n,o,r),this.left=e-this.width/2,this.top=i-this.height/2,t.save();var s=this.ctxRenderer({ctx:t,id:this.options.id,x:e,y:i,state:{selected:n,hover:o},style:jE({},r),label:this.options.label});if(null!=s.drawNode&&s.drawNode(),t.restore(),s.drawExternalLabel){var a=s.drawExternalLabel;s.drawExternalLabel=function(){t.save(),a(),t.restore()}}return s.nodeDimensions&&(this.customSizeWidth=s.nodeDimensions.width,this.customSizeHeight=s.nodeDimensions.height),s}},{key:"distanceToBorder",value:function(t,e){return this._distanceToBorder(t,e)}}]),i}(FE);function HE(t){var e=function(){if("undefined"==typeof Reflect||!Mk)return!1;if(Mk.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Mk(Boolean,[],(function(){}))),!0}catch(t){return!1}}();return function(){var i,n=Ak(t);if(e){var o=Ak(this).constructor;i=Mk(n,arguments,o)}else i=n.apply(this,arguments);return Nk(this,i)}}var WE=function(t){zk(i,t);var e=HE(i);function i(t,n,o){var r;return Yd(this,i),(r=e.call(this,t,n,o))._setMargins(o),r}return Kd(i,[{key:"resize",value:function(t,e,i){if(this.needsRefresh(e,i)){var n=this.getDimensionsFromLabel(t,e,i).width+this.margin.right+this.margin.left;this.width=n,this.height=n,this.radius=this.width/2}}},{key:"draw",value:function(t,e,i,n,o,r){this.resize(t,n,o),this.left=e-this.width/2,this.top=i-this.height/2,this.initContextForDraw(t,r),jn(t,e-this.width/2,i-this.height/2,this.width,this.height),this.performFill(t,r),this.updateBoundingBox(e,i,t,n,o),this.labelModule.draw(t,this.left+this.textSize.width/2+this.margin.left,this.top+this.textSize.height/2+this.margin.top,n,o)}},{key:"distanceToBorder",value:function(t,e){return this._distanceToBorder(t,e)}}]),i}(CE);function qE(t){var e=function(){if("undefined"==typeof Reflect||!Mk)return!1;if(Mk.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Mk(Boolean,[],(function(){}))),!0}catch(t){return!1}}();return function(){var i,n=Ak(t);if(e){var o=Ak(this).constructor;i=Mk(n,arguments,o)}else i=n.apply(this,arguments);return Nk(this,i)}}var VE=function(t){zk(i,t);var e=qE(i);function i(t,n,o){return Yd(this,i),e.call(this,t,n,o)}return Kd(i,[{key:"draw",value:function(t,e,i,n,o,r){return this._drawShape(t,"diamond",4,e,i,n,o,r)}},{key:"distanceToBorder",value:function(t,e){return this._distanceToBorder(t,e)}}]),i}(FE);function UE(t){var e=function(){if("undefined"==typeof Reflect||!Mk)return!1;if(Mk.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Mk(Boolean,[],(function(){}))),!0}catch(t){return!1}}();return function(){var i,n=Ak(t);if(e){var o=Ak(this).constructor;i=Mk(n,arguments,o)}else i=n.apply(this,arguments);return Nk(this,i)}}var YE=function(t){zk(i,t);var e=UE(i);function i(t,n,o){return Yd(this,i),e.call(this,t,n,o)}return Kd(i,[{key:"draw",value:function(t,e,i,n,o,r){return this._drawShape(t,"circle",2,e,i,n,o,r)}},{key:"distanceToBorder",value:function(t){return t&&this.resize(t),this.options.size}}]),i}(FE);function XE(t){var e=function(){if("undefined"==typeof Reflect||!Mk)return!1;if(Mk.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Mk(Boolean,[],(function(){}))),!0}catch(t){return!1}}();return function(){var i,n=Ak(t);if(e){var o=Ak(this).constructor;i=Mk(n,arguments,o)}else i=n.apply(this,arguments);return Nk(this,i)}}var GE=function(t){zk(i,t);var e=XE(i);function i(t,n,o){return Yd(this,i),e.call(this,t,n,o)}return Kd(i,[{key:"resize",value:function(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.selected,i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:this.hover;if(this.needsRefresh(e,i)){var n=this.getDimensionsFromLabel(t,e,i);this.height=2*n.height,this.width=n.width+n.height,this.radius=.5*this.width}}},{key:"draw",value:function(t,e,i,n,o,r){this.resize(t,n,o),this.left=e-.5*this.width,this.top=i-.5*this.height,this.initContextForDraw(t,r),An(t,this.left,this.top,this.width,this.height),this.performFill(t,r),this.updateBoundingBox(e,i,t,n,o),this.labelModule.draw(t,e,i,n,o)}},{key:"distanceToBorder",value:function(t,e){t&&this.resize(t);var i=.5*this.width,n=.5*this.height,o=Math.sin(e)*i,r=Math.cos(e)*n;return i*n/Math.sqrt(o*o+r*r)}}]),i}(CE);function KE(t){var e=function(){if("undefined"==typeof Reflect||!Mk)return!1;if(Mk.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Mk(Boolean,[],(function(){}))),!0}catch(t){return!1}}();return function(){var i,n=Ak(t);if(e){var o=Ak(this).constructor;i=Mk(n,arguments,o)}else i=n.apply(this,arguments);return Nk(this,i)}}var $E=function(t){zk(i,t);var e=KE(i);function i(t,n,o){var r;return Yd(this,i),(r=e.call(this,t,n,o))._setMargins(o),r}return Kd(i,[{key:"resize",value:function(t,e,i){this.needsRefresh(e,i)&&(this.iconSize={width:Number(this.options.icon.size),height:Number(this.options.icon.size)},this.width=this.iconSize.width+this.margin.right+this.margin.left,this.height=this.iconSize.height+this.margin.top+this.margin.bottom,this.radius=.5*this.width)}},{key:"draw",value:function(t,e,i,n,o,r){var s=this;return this.resize(t,n,o),this.options.icon.size=this.options.icon.size||50,this.left=e-this.width/2,this.top=i-this.height/2,this._icon(t,e,i,n,o,r),{drawExternalLabel:function(){if(void 0!==s.options.label){s.labelModule.draw(t,s.left+s.iconSize.width/2+s.margin.left,i+s.height/2+5,n)}s.updateBoundingBox(e,i)}}}},{key:"updateBoundingBox",value:function(t,e){if(this.boundingBox.top=e-.5*this.options.icon.size,this.boundingBox.left=t-.5*this.options.icon.size,this.boundingBox.right=t+.5*this.options.icon.size,this.boundingBox.bottom=e+.5*this.options.icon.size,void 0!==this.options.label&&this.labelModule.size.width>0){this.boundingBox.left=Math.min(this.boundingBox.left,this.labelModule.size.left),this.boundingBox.right=Math.max(this.boundingBox.right,this.labelModule.size.left+this.labelModule.size.width),this.boundingBox.bottom=Math.max(this.boundingBox.bottom,this.boundingBox.bottom+this.labelModule.size.height+5)}}},{key:"_icon",value:function(t,e,i,n,o,r){var s=Number(this.options.icon.size);void 0!==this.options.icon.code?(t.font=[null!=this.options.icon.weight?this.options.icon.weight:n?"bold":"",(null!=this.options.icon.weight&&n?5:0)+s+"px",this.options.icon.face].join(" "),t.fillStyle=this.options.icon.color||"black",t.textAlign="center",t.textBaseline="middle",this.enableShadow(t,r),t.fillText(this.options.icon.code,e,i),this.disableShadow(t,r)):console.error("When using the icon shape, you need to define the code in the icon options object. This can be done per node or globally.")}},{key:"distanceToBorder",value:function(t,e){return this._distanceToBorder(t,e)}}]),i}(CE);function ZE(t){var e=function(){if("undefined"==typeof Reflect||!Mk)return!1;if(Mk.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Mk(Boolean,[],(function(){}))),!0}catch(t){return!1}}();return function(){var i,n=Ak(t);if(e){var o=Ak(this).constructor;i=Mk(n,arguments,o)}else i=n.apply(this,arguments);return Nk(this,i)}}var QE=function(t){zk(i,t);var e=ZE(i);function i(t,n,o,r,s){var a;return Yd(this,i),(a=e.call(this,t,n,o)).setImages(r,s),a}return Kd(i,[{key:"resize",value:function(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.selected,i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:this.hover,n=void 0===this.imageObj.src||void 0===this.imageObj.width||void 0===this.imageObj.height;if(n){var o=2*this.options.size;return this.width=o,void(this.height=o)}this.needsRefresh(e,i)&&this._resizeImage()}},{key:"draw",value:function(t,e,i,n,o,r){t.save(),this.switchImages(n),this.resize();var s=e,a=i;if("top-left"===this.options.shapeProperties.coordinateOrigin?(this.left=e,this.top=i,s+=this.width/2,a+=this.height/2):(this.left=e-this.width/2,this.top=i-this.height/2),!0===this.options.shapeProperties.useBorderWithImage){var h=this.options.borderWidth,l=this.options.borderWidthSelected||2*this.options.borderWidth,d=(n?l:h)/this.body.view.scale;t.lineWidth=Math.min(this.width,d),t.beginPath();var c=n?this.options.color.highlight.border:o?this.options.color.hover.border:this.options.color.border,u=n?this.options.color.highlight.background:o?this.options.color.hover.background:this.options.color.background;void 0!==r.opacity&&(c=pm(c,r.opacity),u=pm(u,r.opacity)),t.strokeStyle=c,t.fillStyle=u,t.rect(this.left-.5*t.lineWidth,this.top-.5*t.lineWidth,this.width+t.lineWidth,this.height+t.lineWidth),jv(t).call(t),this.performStroke(t,r),t.closePath()}this._drawImageAtPosition(t,r),this._drawImageLabel(t,s,a,n,o),this.updateBoundingBox(e,i),t.restore()}},{key:"updateBoundingBox",value:function(t,e){this.resize(),"top-left"===this.options.shapeProperties.coordinateOrigin?(this.left=t,this.top=e):(this.left=t-this.width/2,this.top=e-this.height/2),this.boundingBox.left=this.left,this.boundingBox.top=this.top,this.boundingBox.bottom=this.top+this.height,this.boundingBox.right=this.left+this.width,void 0!==this.options.label&&this.labelModule.size.width>0&&(this.boundingBox.left=Math.min(this.boundingBox.left,this.labelModule.size.left),this.boundingBox.right=Math.max(this.boundingBox.right,this.labelModule.size.left+this.labelModule.size.width),this.boundingBox.bottom=Math.max(this.boundingBox.bottom,this.boundingBox.bottom+this.labelOffset))}},{key:"distanceToBorder",value:function(t,e){return this._distanceToBorder(t,e)}}]),i}(PE);function JE(t){var e=function(){if("undefined"==typeof Reflect||!Mk)return!1;if(Mk.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Mk(Boolean,[],(function(){}))),!0}catch(t){return!1}}();return function(){var i,n=Ak(t);if(e){var o=Ak(this).constructor;i=Mk(n,arguments,o)}else i=n.apply(this,arguments);return Nk(this,i)}}var tO=function(t){zk(i,t);var e=JE(i);function i(t,n,o){return Yd(this,i),e.call(this,t,n,o)}return Kd(i,[{key:"draw",value:function(t,e,i,n,o,r){return this._drawShape(t,"square",2,e,i,n,o,r)}},{key:"distanceToBorder",value:function(t,e){return this._distanceToBorder(t,e)}}]),i}(FE);function eO(t){var e=function(){if("undefined"==typeof Reflect||!Mk)return!1;if(Mk.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Mk(Boolean,[],(function(){}))),!0}catch(t){return!1}}();return function(){var i,n=Ak(t);if(e){var o=Ak(this).constructor;i=Mk(n,arguments,o)}else i=n.apply(this,arguments);return Nk(this,i)}}var iO=function(t){zk(i,t);var e=eO(i);function i(t,n,o){return Yd(this,i),e.call(this,t,n,o)}return Kd(i,[{key:"draw",value:function(t,e,i,n,o,r){return this._drawShape(t,"hexagon",4,e,i,n,o,r)}},{key:"distanceToBorder",value:function(t,e){return this._distanceToBorder(t,e)}}]),i}(FE);function nO(t){var e=function(){if("undefined"==typeof Reflect||!Mk)return!1;if(Mk.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Mk(Boolean,[],(function(){}))),!0}catch(t){return!1}}();return function(){var i,n=Ak(t);if(e){var o=Ak(this).constructor;i=Mk(n,arguments,o)}else i=n.apply(this,arguments);return Nk(this,i)}}var oO=function(t){zk(i,t);var e=nO(i);function i(t,n,o){return Yd(this,i),e.call(this,t,n,o)}return Kd(i,[{key:"draw",value:function(t,e,i,n,o,r){return this._drawShape(t,"star",4,e,i,n,o,r)}},{key:"distanceToBorder",value:function(t,e){return this._distanceToBorder(t,e)}}]),i}(FE);function rO(t){var e=function(){if("undefined"==typeof Reflect||!Mk)return!1;if(Mk.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Mk(Boolean,[],(function(){}))),!0}catch(t){return!1}}();return function(){var i,n=Ak(t);if(e){var o=Ak(this).constructor;i=Mk(n,arguments,o)}else i=n.apply(this,arguments);return Nk(this,i)}}var sO=function(t){zk(i,t);var e=rO(i);function i(t,n,o){var r;return Yd(this,i),(r=e.call(this,t,n,o))._setMargins(o),r}return Kd(i,[{key:"resize",value:function(t,e,i){this.needsRefresh(e,i)&&(this.textSize=this.labelModule.getTextSize(t,e,i),this.width=this.textSize.width+this.margin.right+this.margin.left,this.height=this.textSize.height+this.margin.top+this.margin.bottom,this.radius=.5*this.width)}},{key:"draw",value:function(t,e,i,n,o,r){this.resize(t,n,o),this.left=e-this.width/2,this.top=i-this.height/2,this.enableShadow(t,r),this.labelModule.draw(t,this.left+this.textSize.width/2+this.margin.left,this.top+this.textSize.height/2+this.margin.top,n,o),this.disableShadow(t,r),this.updateBoundingBox(e,i,t,n,o)}},{key:"distanceToBorder",value:function(t,e){return this._distanceToBorder(t,e)}}]),i}(CE);function aO(t){var e=function(){if("undefined"==typeof Reflect||!Mk)return!1;if(Mk.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Mk(Boolean,[],(function(){}))),!0}catch(t){return!1}}();return function(){var i,n=Ak(t);if(e){var o=Ak(this).constructor;i=Mk(n,arguments,o)}else i=n.apply(this,arguments);return Nk(this,i)}}var hO=function(t){zk(i,t);var e=aO(i);function i(t,n,o){return Yd(this,i),e.call(this,t,n,o)}return Kd(i,[{key:"draw",value:function(t,e,i,n,o,r){return this._drawShape(t,"triangle",3,e,i,n,o,r)}},{key:"distanceToBorder",value:function(t,e){return this._distanceToBorder(t,e)}}]),i}(FE);function lO(t){var e=function(){if("undefined"==typeof Reflect||!Mk)return!1;if(Mk.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Mk(Boolean,[],(function(){}))),!0}catch(t){return!1}}();return function(){var i,n=Ak(t);if(e){var o=Ak(this).constructor;i=Mk(n,arguments,o)}else i=n.apply(this,arguments);return Nk(this,i)}}var dO=function(t){zk(i,t);var e=lO(i);function i(t,n,o){return Yd(this,i),e.call(this,t,n,o)}return Kd(i,[{key:"draw",value:function(t,e,i,n,o,r){return this._drawShape(t,"triangleDown",3,e,i,n,o,r)}},{key:"distanceToBorder",value:function(t,e){return this._distanceToBorder(t,e)}}]),i}(FE);function cO(t,e){var i=bu(t);if(hd){var n=hd(t);e&&(n=Xf(n).call(n,(function(e){return bd(t,e).enumerable}))),i.push.apply(i,n)}return i}function uO(t){for(var e=1;e<arguments.length;e++){var i,n,o=null!=arguments[e]?arguments[e]:{};e%2?Fu(i=cO(Object(o),!0)).call(i,(function(e){$d(t,e,o[e])})):Pd?Ad(t,Pd(o)):Fu(n=cO(Object(o))).call(n,(function(e){Ud(t,e,bd(o,e))}))}return t}var fO=function(){function t(e,i,n,o,r,s){Yd(this,t),this.options=Cm(r),this.globalOptions=r,this.defaultOptions=s,this.body=i,this.edges=[],this.id=void 0,this.imagelist=n,this.grouplist=o,this.x=void 0,this.y=void 0,this.baseSize=this.options.size,this.baseFontSize=this.options.font.size,this.predefinedPosition=!1,this.selected=!1,this.hover=!1,this.labelModule=new OE(this.body,this.options,!1),this.setOptions(e)}return Kd(t,[{key:"attachEdge",value:function(t){var e;-1===Fp(e=this.edges).call(e,t)&&this.edges.push(t)}},{key:"detachEdge",value:function(t){var e,i,n=Fp(e=this.edges).call(e,t);-1!=n&&ff(i=this.edges).call(i,n,1)}},{key:"setOptions",value:function(e){var i=this.options.shape;if(e){if(void 0!==e.color&&(this._localColor=e.color),void 0!==e.id&&(this.id=e.id),void 0===this.id)throw new Error("Node must have an id");t.checkMass(e,this.id),void 0!==e.x&&(null===e.x?(this.x=void 0,this.predefinedPosition=!1):(this.x=Ep(e.x),this.predefinedPosition=!0)),void 0!==e.y&&(null===e.y?(this.y=void 0,this.predefinedPosition=!1):(this.y=Ep(e.y),this.predefinedPosition=!0)),void 0!==e.size&&(this.baseSize=e.size),void 0!==e.value&&(e.value=lE(e.value)),t.parseOptions(this.options,e,!0,this.globalOptions,this.grouplist);var n=[e,this.options,this.defaultOptions];return this.chooser=gE("node",n),this._load_images(),this.updateLabelModule(e),void 0!==e.opacity&&t.checkOpacity(e.opacity)&&(this.options.opacity=e.opacity),this.updateShape(i),void 0!==e.hidden||void 0!==e.physics}}},{key:"_load_images",value:function(){if(("circularImage"===this.options.shape||"image"===this.options.shape)&&void 0===this.options.image)throw new Error("Option image must be defined for node type '"+this.options.shape+"'");if(void 0!==this.options.image){if(void 0===this.imagelist)throw new Error("Internal Error: No images provided");if("string"==typeof this.options.image)this.imageObj=this.imagelist.load(this.options.image,this.options.brokenImage,this.id);else{if(void 0===this.options.image.unselected)throw new Error("No unselected image provided");this.imageObj=this.imagelist.load(this.options.image.unselected,this.options.brokenImage,this.id),void 0!==this.options.image.selected?this.imageObjAlt=this.imagelist.load(this.options.image.selected,this.options.brokenImage,this.id):this.imageObjAlt=void 0}}}},{key:"getFormattingValues",value:function(){var t={color:this.options.color.background,opacity:this.options.opacity,borderWidth:this.options.borderWidth,borderColor:this.options.color.border,size:this.options.size,borderDashes:this.options.shapeProperties.borderDashes,borderRadius:this.options.shapeProperties.borderRadius,shadow:this.options.shadow.enabled,shadowColor:this.options.shadow.color,shadowSize:this.options.shadow.size,shadowX:this.options.shadow.x,shadowY:this.options.shadow.y};if(this.selected||this.hover?!0===this.chooser?this.selected?(null!=this.options.borderWidthSelected?t.borderWidth=this.options.borderWidthSelected:t.borderWidth*=2,t.color=this.options.color.highlight.background,t.borderColor=this.options.color.highlight.border,t.shadow=this.options.shadow.enabled):this.hover&&(t.color=this.options.color.hover.background,t.borderColor=this.options.color.hover.border,t.shadow=this.options.shadow.enabled):"function"==typeof this.chooser&&(this.chooser(t,this.options.id,this.selected,this.hover),!1===t.shadow&&(t.shadowColor===this.options.shadow.color&&t.shadowSize===this.options.shadow.size&&t.shadowX===this.options.shadow.x&&t.shadowY===this.options.shadow.y||(t.shadow=!0))):t.shadow=this.options.shadow.enabled,void 0!==this.options.opacity){var e=this.options.opacity;t.borderColor=pm(t.borderColor,e),t.color=pm(t.color,e),t.shadowColor=pm(t.shadowColor,e)}return t}},{key:"updateLabelModule",value:function(e){void 0!==this.options.label&&null!==this.options.label||(this.options.label=""),t.updateGroupOptions(this.options,uO(uO({},e),{},{color:e&&e.color||this._localColor||void 0}),this.grouplist);var i=this.grouplist.get(this.options.group,!1),n=[e,this.options,i,this.globalOptions,this.defaultOptions];this.labelModule.update(this.options,n),void 0!==this.labelModule.baseSize&&(this.baseFontSize=this.labelModule.baseSize)}},{key:"updateShape",value:function(t){if(t===this.options.shape&&this.shape)this.shape.setOptions(this.options,this.imageObj,this.imageObjAlt);else switch(this.options.shape){case"box":this.shape=new TE(this.options,this.body,this.labelModule);break;case"circle":this.shape=new IE(this.options,this.body,this.labelModule);break;case"circularImage":this.shape=new zE(this.options,this.body,this.labelModule,this.imageObj,this.imageObjAlt);break;case"custom":this.shape=new LE(this.options,this.body,this.labelModule,this.options.ctxRenderer);break;case"database":this.shape=new WE(this.options,this.body,this.labelModule);break;case"diamond":this.shape=new VE(this.options,this.body,this.labelModule);break;case"dot":this.shape=new YE(this.options,this.body,this.labelModule);break;case"ellipse":default:this.shape=new GE(this.options,this.body,this.labelModule);break;case"icon":this.shape=new $E(this.options,this.body,this.labelModule);break;case"image":this.shape=new QE(this.options,this.body,this.labelModule,this.imageObj,this.imageObjAlt);break;case"square":this.shape=new tO(this.options,this.body,this.labelModule);break;case"hexagon":this.shape=new iO(this.options,this.body,this.labelModule);break;case"star":this.shape=new oO(this.options,this.body,this.labelModule);break;case"text":this.shape=new sO(this.options,this.body,this.labelModule);break;case"triangle":this.shape=new hO(this.options,this.body,this.labelModule);break;case"triangleDown":this.shape=new dO(this.options,this.body,this.labelModule)}this.needsRefresh()}},{key:"select",value:function(){this.selected=!0,this.needsRefresh()}},{key:"unselect",value:function(){this.selected=!1,this.needsRefresh()}},{key:"needsRefresh",value:function(){this.shape.refreshNeeded=!0}},{key:"getTitle",value:function(){return this.options.title}},{key:"distanceToBorder",value:function(t,e){return this.shape.distanceToBorder(t,e)}},{key:"isFixed",value:function(){return this.options.fixed.x&&this.options.fixed.y}},{key:"isSelected",value:function(){return this.selected}},{key:"getValue",value:function(){return this.options.value}},{key:"getLabelSize",value:function(){return this.labelModule.size()}},{key:"setValueRange",value:function(t,e,i){if(void 0!==this.options.value){var n=this.options.scaling.customScalingFunction(t,e,i,this.options.value),o=this.options.scaling.max-this.options.scaling.min;if(!0===this.options.scaling.label.enabled){var r=this.options.scaling.label.max-this.options.scaling.label.min;this.options.font.size=this.options.scaling.label.min+n*r}this.options.size=this.options.scaling.min+n*o}else this.options.size=this.baseSize,this.options.font.size=this.baseFontSize;this.updateLabelModule()}},{key:"draw",value:function(t){var e=this.getFormattingValues();return this.shape.draw(t,this.x,this.y,this.selected,this.hover,e)||{}}},{key:"updateBoundingBox",value:function(t){this.shape.updateBoundingBox(this.x,this.y,t)}},{key:"resize",value:function(t){var e=this.getFormattingValues();this.shape.resize(t,this.selected,this.hover,e)}},{key:"getItemsOnPoint",value:function(t){var e=[];return this.labelModule.visible()&&yE(this.labelModule.getSize(),t)&&e.push({nodeId:this.id,labelId:0}),yE(this.shape.boundingBox,t)&&e.push({nodeId:this.id}),e}},{key:"isOverlappingWith",value:function(t){return this.shape.left<t.right&&this.shape.left+this.shape.width>t.left&&this.shape.top<t.bottom&&this.shape.top+this.shape.height>t.top}},{key:"isBoundingBoxOverlappingWith",value:function(t){return this.shape.boundingBox.left<t.right&&this.shape.boundingBox.right>t.left&&this.shape.boundingBox.top<t.bottom&&this.shape.boundingBox.bottom>t.top}}],[{key:"checkOpacity",value:function(t){return 0<=t&&t<=1}},{key:"checkCoordinateOrigin",value:function(t){return void 0===t||"center"===t||"top-left"===t}},{key:"updateGroupOptions",value:function(e,i,n){var o;if(void 0!==n){var r=e.group;if(void 0!==i&&void 0!==i.group&&r!==i.group)throw new Error("updateGroupOptions: group values in options don't match.");if("number"==typeof r||"string"==typeof r&&""!=r){var s=n.get(r);void 0!==s.opacity&&void 0===i.opacity&&(t.checkOpacity(s.opacity)||(console.error("Invalid option for node opacity. Value must be between 0 and 1, found: "+s.opacity),s.opacity=void 0));var a=Xf(o=vE(i)).call(o,(function(t){return null!=i[t]}));a.push("font"),im(a,e,s),e.color=gm(e.color)}}}},{key:"parseOptions",value:function(e,i){var n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],o=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{},r=arguments.length>4?arguments[4]:void 0,s=["color","fixed","shadow"];if(im(s,e,i,n),t.checkMass(i),void 0!==e.opacity&&(t.checkOpacity(e.opacity)||(console.error("Invalid option for node opacity. Value must be between 0 and 1, found: "+e.opacity),e.opacity=void 0)),void 0!==i.opacity&&(t.checkOpacity(i.opacity)||(console.error("Invalid option for node opacity. Value must be between 0 and 1, found: "+i.opacity),i.opacity=void 0)),i.shapeProperties&&!t.checkCoordinateOrigin(i.shapeProperties.coordinateOrigin)&&console.error("Invalid option for node coordinateOrigin, found: "+i.shapeProperties.coordinateOrigin),Sm(e,i,"shadow",o),void 0!==i.color&&null!==i.color){var a=gm(i.color);Jy(e.color,a)}else!0===n&&null===i.color&&(e.color=Cm(o.color));void 0!==i.fixed&&null!==i.fixed&&("boolean"==typeof i.fixed?(e.fixed.x=i.fixed,e.fixed.y=i.fixed):(void 0!==i.fixed.x&&"boolean"==typeof i.fixed.x&&(e.fixed.x=i.fixed.x),void 0!==i.fixed.y&&"boolean"==typeof i.fixed.y&&(e.fixed.y=i.fixed.y))),!0===n&&null===i.font&&(e.font=Cm(o.font)),t.updateGroupOptions(e,i,r),void 0!==i.scaling&&Sm(e.scaling,i.scaling,"label",o.scaling)}},{key:"checkMass",value:function(t,e){if(void 0!==t.mass&&t.mass<=0){var i="";void 0!==e&&(i=" in node id: "+e),console.error("%cNegative or zero mass disallowed"+i+", setting mass to 1.",Vm),t.mass=1}}}]),t}();function pO(t,e){var i=void 0!==tu&&ih(t)||t["@@iterator"];if(!i){if(lu(t)||(i=function(t,e){var i;if(!t)return;if("string"==typeof t)return vO(t,e);var n=au(i=Object.prototype.toString.call(t)).call(i,8,-1);"Object"===n&&t.constructor&&(n=t.constructor.name);if("Map"===n||"Set"===n)return ja(t);if("Arguments"===n||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))return vO(t,e)}(t))||e&&t&&"number"==typeof t.length){i&&(t=i);var n=0,o=function(){};return{s:o,n:function(){return n>=t.length?{done:!0}:{done:!1,value:t[n++]}},e:function(t){throw t},f:o}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}var r,s=!0,a=!1;return{s:function(){i=i.call(t)},n:function(){var t=i.next();return s=t.done,t},e:function(t){a=!0,r=t},f:function(){try{s||null==i.return||i.return()}finally{if(a)throw r}}}}function vO(t,e){(null==e||e>t.length)&&(e=t.length);for(var i=0,n=new Array(e);i<e;i++)n[i]=t[i];return n}var gO=function(){function t(e,i,n,o){var r,s=this;if(Yd(this,t),this.body=e,this.images=i,this.groups=n,this.layoutEngine=o,this.body.functions.createNode=zn(r=this.create).call(r,this),this.nodesListeners={add:function(t,e){s.add(e.items)},update:function(t,e){s.update(e.items,e.data,e.oldData)},remove:function(t,e){s.remove(e.items)}},this.defaultOptions={borderWidth:1,borderWidthSelected:void 0,brokenImage:void 0,color:{border:"#2B7CE9",background:"#97C2FC",highlight:{border:"#2B7CE9",background:"#D2E5FF"},hover:{border:"#2B7CE9",background:"#D2E5FF"}},opacity:void 0,fixed:{x:!1,y:!1},font:{color:"#343434",size:14,face:"arial",background:"none",strokeWidth:0,strokeColor:"#ffffff",align:"center",vadjust:0,multi:!1,bold:{mod:"bold"},boldital:{mod:"bold italic"},ital:{mod:"italic"},mono:{mod:"",size:15,face:"monospace",vadjust:2}},group:void 0,hidden:!1,icon:{face:"FontAwesome",code:void 0,size:50,color:"#2B7CE9"},image:void 0,imagePadding:{top:0,right:0,bottom:0,left:0},label:void 0,labelHighlightBold:!0,level:void 0,margin:{top:5,right:5,bottom:5,left:5},mass:1,physics:!0,scaling:{min:10,max:30,label:{enabled:!1,min:14,max:30,maxVisible:30,drawThreshold:5},customScalingFunction:function(t,e,i,n){if(e===t)return.5;var o=1/(e-t);return Math.max(0,(n-t)*o)}},shadow:{enabled:!1,color:"rgba(0,0,0,0.5)",size:10,x:5,y:5},shape:"ellipse",shapeProperties:{borderDashes:!1,borderRadius:6,interpolation:!0,useImageSize:!1,useBorderWithImage:!1,coordinateOrigin:"center"},size:25,title:void 0,value:void 0,x:void 0,y:void 0},this.defaultOptions.mass<=0)throw"Internal error: mass in defaultOptions of NodesHandler may not be zero or negative";this.options=Cm(this.defaultOptions),this.bindEventListeners()}return Kd(t,[{key:"bindEventListeners",value:function(){var t,e,i=this;this.body.emitter.on("refreshNodes",zn(t=this.refresh).call(t,this)),this.body.emitter.on("refresh",zn(e=this.refresh).call(e,this)),this.body.emitter.on("destroy",(function(){hm(i.nodesListeners,(function(t,e){i.body.data.nodes&&i.body.data.nodes.off(e,t)})),delete i.body.functions.createNode,delete i.nodesListeners.add,delete i.nodesListeners.update,delete i.nodesListeners.remove,delete i.nodesListeners}))}},{key:"setOptions",value:function(t){if(void 0!==t){if(fO.parseOptions(this.options,t),void 0!==t.opacity&&(ek(t.opacity)||!ok(t.opacity)||t.opacity<0||t.opacity>1?console.error("Invalid option for node opacity. Value must be between 0 and 1, found: "+t.opacity):this.options.opacity=t.opacity),void 0!==t.shape)for(var e in this.body.nodes)Object.prototype.hasOwnProperty.call(this.body.nodes,e)&&this.body.nodes[e].updateShape();if(void 0!==t.font||void 0!==t.widthConstraint||void 0!==t.heightConstraint)for(var i=0,n=bu(this.body.nodes);i<n.length;i++){var o=n[i];this.body.nodes[o].updateLabelModule(),this.body.nodes[o].needsRefresh()}if(void 0!==t.size)for(var r in this.body.nodes)Object.prototype.hasOwnProperty.call(this.body.nodes,r)&&this.body.nodes[r].needsRefresh();void 0===t.hidden&&void 0===t.physics||this.body.emitter.emit("_dataChanged")}}},{key:"setData",value:function(t){var e=arguments.length>1&&void 0!==arguments[1]&&arguments[1],i=this.body.data.nodes;if(Qx("id",t))this.body.data.nodes=t;else if(lu(t))this.body.data.nodes=new Kx,this.body.data.nodes.add(t);else{if(t)throw new TypeError("Array or DataSet expected");this.body.data.nodes=new Kx}if(i&&hm(this.nodesListeners,(function(t,e){i.off(e,t)})),this.body.nodes={},this.body.data.nodes){var n=this;hm(this.nodesListeners,(function(t,e){n.body.data.nodes.on(e,t)}));var o=this.body.data.nodes.getIds();this.add(o,!0)}!1===e&&this.body.emitter.emit("_dataChanged")}},{key:"add",value:function(t){for(var e,i=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=[],o=0;o<t.length;o++){e=t[o];var r=this.body.data.nodes.get(e),s=this.create(r);n.push(s),this.body.nodes[e]=s}this.layoutEngine.positionInitially(n),!1===i&&this.body.emitter.emit("_dataChanged")}},{key:"update",value:function(t,e,i){for(var n=this.body.nodes,o=!1,r=0;r<t.length;r++){var s=t[r],a=n[s],h=e[r];void 0!==a?a.setOptions(h)&&(o=!0):(o=!0,a=this.create(h),n[s]=a)}o||void 0===i||(o=ck(e).call(e,(function(t,e){var n=i[e];return n&&n.level!==t.level}))),!0===o?this.body.emitter.emit("_dataChanged"):this.body.emitter.emit("_dataUpdated")}},{key:"remove",value:function(t){for(var e=this.body.nodes,i=0;i<t.length;i++){delete e[t[i]]}this.body.emitter.emit("_dataChanged")}},{key:"create",value:function(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:fO;return new e(t,this.body,this.images,this.groups,this.options,this.defaultOptions)}},{key:"refresh",value:function(){var t=this,e=arguments.length>0&&void 0!==arguments[0]&&arguments[0];hm(this.body.nodes,(function(i,n){var o=t.body.data.nodes.get(n);void 0!==o&&(!0===e&&i.setOptions({x:null,y:null}),i.setOptions({fixed:!1}),i.setOptions(o))}))}},{key:"getPositions",value:function(t){var e={};if(void 0!==t){if(!0===lu(t)){for(var i=0;i<t.length;i++)if(void 0!==this.body.nodes[t[i]]){var n=this.body.nodes[t[i]];e[t[i]]={x:Math.round(n.x),y:Math.round(n.y)}}}else if(void 0!==this.body.nodes[t]){var o=this.body.nodes[t];e[t]={x:Math.round(o.x),y:Math.round(o.y)}}}else for(var r=0;r<this.body.nodeIndices.length;r++){var s=this.body.nodes[this.body.nodeIndices[r]];e[this.body.nodeIndices[r]]={x:Math.round(s.x),y:Math.round(s.y)}}return e}},{key:"getPosition",value:function(t){if(null==t)throw new TypeError("No id was specified for getPosition method.");if(null==this.body.nodes[t])throw new ReferenceError("NodeId provided for getPosition does not exist. Provided: ".concat(t));return{x:Math.round(this.body.nodes[t].x),y:Math.round(this.body.nodes[t].y)}}},{key:"storePositions",value:function(){var t,e=[],i=this.body.data.nodes.getDataSet(),n=pO(i.get());try{for(n.s();!(t=n.n()).done;){var o=t.value,r=o.id,s=this.body.nodes[r],a=Math.round(s.x),h=Math.round(s.y);o.x===a&&o.y===h||e.push({id:r,x:a,y:h})}}catch(t){n.e(t)}finally{n.f()}i.update(e)}},{key:"getBoundingBox",value:function(t){if(void 0!==this.body.nodes[t])return this.body.nodes[t].shape.boundingBox}},{key:"getConnectedNodes",value:function(t,e){var i=[];if(void 0!==this.body.nodes[t])for(var n=this.body.nodes[t],o={},r=0;r<n.edges.length;r++){var s=n.edges[r];"to"!==e&&s.toId==n.id?void 0===o[s.fromId]&&(i.push(s.fromId),o[s.fromId]=!0):"from"!==e&&s.fromId==n.id&&void 0===o[s.toId]&&(i.push(s.toId),o[s.toId]=!0)}return i}},{key:"getConnectedEdges",value:function(t){var e=[];if(void 0!==this.body.nodes[t])for(var i=this.body.nodes[t],n=0;n<i.edges.length;n++)e.push(i.edges[n].id);else console.error("NodeId provided for getConnectedEdges does not exist. Provided: ",t);return e}},{key:"moveNode",value:function(t,e,i){var n=this;void 0!==this.body.nodes[t]?(this.body.nodes[t].x=Number(e),this.body.nodes[t].y=Number(i),Sv((function(){n.body.emitter.emit("startSimulation")}),0)):console.error("Node id supplied to moveNode does not exist. Provided: ",t)}}]),t}(),yO=Wt,mO=_,bO=Y,wO=$e,kO=function(t){return void 0!==t&&(yO(t,"value")||yO(t,"writable"))},_O=m,xO=Pr;_i({target:"Reflect",stat:!0},{get:function t(e,i){var n,o,r=arguments.length<3?e:arguments[2];return wO(e)===r?e[i]:(n=_O.f(e,i))?kO(n)?n.value:void 0===n.get?void 0:mO(n.get,r):bO(o=xO(e))?t(o,i,r):void 0}});var EO=X.Reflect.get,OO=md;function CO(t,e){for(;!Object.prototype.hasOwnProperty.call(t,e)&&null!==(t=Ak(t)););return t}function SO(){return SO="undefined"!=typeof Reflect&&EO?EO:function(t,e,i){var n=CO(t,e);if(n){var o=OO(n,e);return o.get?o.get.call(arguments.length<3?t:i):o.value}},SO.apply(this,arguments)}var TO=_i,MO=Math.hypot,PO=Math.abs,DO=Math.sqrt;TO({target:"Math",stat:!0,forced:!!MO&&MO(1/0,NaN)!==1/0},{hypot:function(t,e){for(var i,n,o=0,r=0,s=arguments.length,a=0;r<s;)a<(i=PO(arguments[r++]))?(o=o*(n=a/i)*n+1,a=i):o+=i>0?(n=i/a)*n:i;return a===1/0?1/0:a*DO(o)}});var IO=X.Math.hypot;function BO(t){var e=function(){if("undefined"==typeof Reflect||!Mk)return!1;if(Mk.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Mk(Boolean,[],(function(){}))),!0}catch(t){return!1}}();return function(){var i,n=Ak(t);if(e){var o=Ak(this).constructor;i=Mk(n,arguments,o)}else i=n.apply(this,arguments);return Nk(this,i)}}var zO=function(){function t(){Yd(this,t)}return Kd(t,null,[{key:"transform",value:function(t,e){lu(t)||(t=[t]);for(var i=e.point.x,n=e.point.y,o=e.angle,r=e.length,s=0;s<t.length;++s){var a=t[s],h=a.x*Math.cos(o)-a.y*Math.sin(o),l=a.x*Math.sin(o)+a.y*Math.cos(o);a.x=i+r*h,a.y=n+r*l}}},{key:"drawPath",value:function(t,e){t.beginPath(),t.moveTo(e[0].x,e[0].y);for(var i=1;i<e.length;++i)t.lineTo(e[i].x,e[i].y);t.closePath()}}]),t}(),NO=function(t){zk(i,t);var e=BO(i);function i(){return Yd(this,i),e.apply(this,arguments)}return Kd(i,null,[{key:"draw",value:function(t,e){if(e.image){t.save(),t.translate(e.point.x,e.point.y),t.rotate(Math.PI/2+e.angle);var i=null!=e.imageWidth?e.imageWidth:e.image.width,n=null!=e.imageHeight?e.imageHeight:e.image.height;e.image.drawImageAtPosition(t,1,-i/2,0,i,n),t.restore()}return!1}}]),i}(zO),FO=function(t){zk(i,t);var e=BO(i);function i(){return Yd(this,i),e.apply(this,arguments)}return Kd(i,null,[{key:"draw",value:function(t,e){var i=[{x:0,y:0},{x:-1,y:.3},{x:-.9,y:0},{x:-1,y:-.3}];return zO.transform(i,e),zO.drawPath(t,i),!0}}]),i}(zO),AO=function(){function t(){Yd(this,t)}return Kd(t,null,[{key:"draw",value:function(t,e){var i=[{x:-1,y:0},{x:0,y:.3},{x:-.4,y:0},{x:0,y:-.3}];return zO.transform(i,e),zO.drawPath(t,i),!0}}]),t}(),jO=function(){function t(){Yd(this,t)}return Kd(t,null,[{key:"draw",value:function(t,e){var i={x:-.4,y:0};zO.transform(i,e),t.strokeStyle=t.fillStyle,t.fillStyle="rgba(0, 0, 0, 0)";var n=Math.PI,o=e.angle-n/2,r=e.angle+n/2;return t.beginPath(),t.arc(i.x,i.y,.4*e.length,o,r,!1),t.stroke(),!0}}]),t}(),RO=function(){function t(){Yd(this,t)}return Kd(t,null,[{key:"draw",value:function(t,e){var i={x:-.3,y:0};zO.transform(i,e),t.strokeStyle=t.fillStyle,t.fillStyle="rgba(0, 0, 0, 0)";var n=Math.PI,o=e.angle+n/2,r=e.angle+3*n/2;return t.beginPath(),t.arc(i.x,i.y,.4*e.length,o,r,!1),t.stroke(),!0}}]),t}(),LO=function(){function t(){Yd(this,t)}return Kd(t,null,[{key:"draw",value:function(t,e){var i=[{x:.02,y:0},{x:-1,y:.3},{x:-1,y:-.3}];return zO.transform(i,e),zO.drawPath(t,i),!0}}]),t}(),HO=function(){function t(){Yd(this,t)}return Kd(t,null,[{key:"draw",value:function(t,e){var i=[{x:0,y:.3},{x:0,y:-.3},{x:-1,y:0}];return zO.transform(i,e),zO.drawPath(t,i),!0}}]),t}(),WO=function(){function t(){Yd(this,t)}return Kd(t,null,[{key:"draw",value:function(t,e){var i={x:-.4,y:0};return zO.transform(i,e),Nn(t,i.x,i.y,.4*e.length),!0}}]),t}(),qO=function(){function t(){Yd(this,t)}return Kd(t,null,[{key:"draw",value:function(t,e){var i=[{x:0,y:.5},{x:0,y:-.5},{x:-.15,y:-.5},{x:-.15,y:.5}];return zO.transform(i,e),zO.drawPath(t,i),!0}}]),t}(),VO=function(){function t(){Yd(this,t)}return Kd(t,null,[{key:"draw",value:function(t,e){var i=[{x:0,y:.3},{x:0,y:-.3},{x:-.6,y:-.3},{x:-.6,y:.3}];return zO.transform(i,e),zO.drawPath(t,i),!0}}]),t}(),UO=function(){function t(){Yd(this,t)}return Kd(t,null,[{key:"draw",value:function(t,e){var i=[{x:0,y:0},{x:-.5,y:-.3},{x:-1,y:0},{x:-.5,y:.3}];return zO.transform(i,e),zO.drawPath(t,i),!0}}]),t}(),YO=function(){function t(){Yd(this,t)}return Kd(t,null,[{key:"draw",value:function(t,e){var i=[{x:-1,y:.3},{x:-.5,y:0},{x:-1,y:-.3},{x:0,y:0}];return zO.transform(i,e),zO.drawPath(t,i),!0}}]),t}(),XO=function(){function t(){Yd(this,t)}return Kd(t,null,[{key:"draw",value:function(t,e){var i;switch(e.type&&(i=e.type.toLowerCase()),i){case"image":return NO.draw(t,e);case"circle":return WO.draw(t,e);case"box":return VO.draw(t,e);case"crow":return AO.draw(t,e);case"curve":return jO.draw(t,e);case"diamond":return UO.draw(t,e);case"inv_curve":return RO.draw(t,e);case"triangle":return LO.draw(t,e);case"inv_triangle":return HO.draw(t,e);case"bar":return qO.draw(t,e);case"vee":return YO.draw(t,e);default:return FO.draw(t,e)}}}]),t}();function GO(t,e){var i=bu(t);if(hd){var n=hd(t);e&&(n=Xf(n).call(n,(function(e){return bd(t,e).enumerable}))),i.push.apply(i,n)}return i}function KO(t){for(var e=1;e<arguments.length;e++){var i,n,o=null!=arguments[e]?arguments[e]:{};e%2?Fu(i=GO(Object(o),!0)).call(i,(function(e){$d(t,e,o[e])})):Pd?Ad(t,Pd(o)):Fu(n=GO(Object(o))).call(n,(function(e){Ud(t,e,bd(o,e))}))}return t}var $O=function(){function t(e,i,n){Yd(this,t),this._body=i,this._labelModule=n,this.color={},this.colorDirty=!0,this.hoverWidth=1.5,this.selectionWidth=2,this.setOptions(e),this.fromPoint=this.from,this.toPoint=this.to}return Kd(t,[{key:"connect",value:function(){this.from=this._body.nodes[this.options.from],this.to=this._body.nodes[this.options.to]}},{key:"cleanup",value:function(){return!1}},{key:"setOptions",value:function(t){this.options=t,this.from=this._body.nodes[this.options.from],this.to=this._body.nodes[this.options.to],this.id=this.options.id}},{key:"drawLine",value:function(t,e,i,n){var o=arguments.length>4&&void 0!==arguments[4]?arguments[4]:this.getViaNode();t.strokeStyle=this.getColor(t,e),t.lineWidth=e.width,!1!==e.dashes?this._drawDashedLine(t,e,o):this._drawLine(t,e,o)}},{key:"_drawLine",value:function(t,e,i,n,o){if(this.from!=this.to)this._line(t,e,i,n,o);else{var r=Kc(this._getCircleData(t),3),s=r[0],a=r[1],h=r[2];this._circle(t,e,s,a,h)}}},{key:"_drawDashedLine",value:function(t,e,i,n,o){t.lineCap="round";var r=lu(e.dashes)?e.dashes:[5,5];if(void 0!==t.setLineDash){if(t.save(),t.setLineDash(r),t.lineDashOffset=0,this.from!=this.to)this._line(t,e,i);else{var s=Kc(this._getCircleData(t),3),a=s[0],h=s[1],l=s[2];this._circle(t,e,a,h,l)}t.setLineDash([0]),t.lineDashOffset=0,t.restore()}else{if(this.from!=this.to)Rn(t,this.from.x,this.from.y,this.to.x,this.to.y,r);else{var d=Kc(this._getCircleData(t),3),c=d[0],u=d[1],f=d[2];this._circle(t,e,c,u,f)}this.enableShadow(t,e),t.stroke(),this.disableShadow(t,e)}}},{key:"findBorderPosition",value:function(t,e,i){return this.from!=this.to?this._findBorderPosition(t,e,i):this._findBorderPositionCircle(t,e,i)}},{key:"findBorderPositions",value:function(t){if(this.from!=this.to)return{from:this._findBorderPosition(this.from,t),to:this._findBorderPosition(this.to,t)};var e,i=Kc(au(e=this._getCircleData(t)).call(e,0,2),2),n=i[0],o=i[1];return{from:this._findBorderPositionCircle(this.from,t,{x:n,y:o,low:.25,high:.6,direction:-1}),to:this._findBorderPositionCircle(this.from,t,{x:n,y:o,low:.6,high:.8,direction:1})}}},{key:"_getCircleData",value:function(t){var e=this.options.selfReference.size;void 0!==t&&void 0===this.from.shape.width&&this.from.shape.resize(t);var i=bE(t,this.options.selfReference.angle,e,this.from);return[i.x,i.y,e]}},{key:"_pointOnCircle",value:function(t,e,i,n){var o=2*n*Math.PI;return{x:t+i*Math.cos(o),y:e-i*Math.sin(o)}}},{key:"_findBorderPositionCircle",value:function(t,e,i){var n,o=i.x,r=i.y,s=i.low,a=i.high,h=i.direction,l=this.options.selfReference.size,d=.5*(s+a),c=0;!0===this.options.arrowStrikethrough&&(-1===h?c=this.options.endPointOffset.from:1===h&&(c=this.options.endPointOffset.to));var u=0;do{d=.5*(s+a),n=this._pointOnCircle(o,r,l,d);var f=Math.atan2(t.y-n.y,t.x-n.x),p=t.distanceToBorder(e,f)+c-Math.sqrt(Math.pow(n.x-t.x,2)+Math.pow(n.y-t.y,2));if(Math.abs(p)<.05)break;p>0?h>0?s=d:a=d:h>0?a=d:s=d,++u}while(s<=a&&u<10);return KO(KO({},n),{},{t:d})}},{key:"getLineWidth",value:function(t,e){return!0===t?Math.max(this.selectionWidth,.3/this._body.view.scale):!0===e?Math.max(this.hoverWidth,.3/this._body.view.scale):Math.max(this.options.width,.3/this._body.view.scale)}},{key:"getColor",value:function(t,e){if(!1!==e.inheritsColor){if("both"===e.inheritsColor&&this.from.id!==this.to.id){var i=t.createLinearGradient(this.from.x,this.from.y,this.to.x,this.to.y),n=this.from.options.color.highlight.border,o=this.to.options.color.highlight.border;return!1===this.from.selected&&!1===this.to.selected?(n=pm(this.from.options.color.border,e.opacity),o=pm(this.to.options.color.border,e.opacity)):!0===this.from.selected&&!1===this.to.selected?o=this.to.options.color.border:!1===this.from.selected&&!0===this.to.selected&&(n=this.from.options.color.border),i.addColorStop(0,n),i.addColorStop(1,o),i}return"to"===e.inheritsColor?pm(this.to.options.color.border,e.opacity):pm(this.from.options.color.border,e.opacity)}return pm(e.color,e.opacity)}},{key:"_circle",value:function(t,e,i,n,o){this.enableShadow(t,e);var r=0,s=2*Math.PI;if(!this.options.selfReference.renderBehindTheNode){var a=this.options.selfReference.angle,h=this.options.selfReference.angle+Math.PI,l=this._findBorderPositionCircle(this.from,t,{x:i,y:n,low:a,high:h,direction:-1}),d=this._findBorderPositionCircle(this.from,t,{x:i,y:n,low:a,high:h,direction:1});r=Math.atan2(l.y-n,l.x-i),s=Math.atan2(d.y-n,d.x-i)}t.beginPath(),t.arc(i,n,o,r,s,!1),t.stroke(),this.disableShadow(t,e)}},{key:"getDistanceToEdge",value:function(t,e,i,n,o,r){if(this.from!=this.to)return this._getDistanceToEdge(t,e,i,n,o,r);var s=Kc(this._getCircleData(void 0),3),a=s[0],h=s[1],l=s[2],d=a-o,c=h-r;return Math.abs(Math.sqrt(d*d+c*c)-l)}},{key:"_getDistanceToLine",value:function(t,e,i,n,o,r){var s=i-t,a=n-e,h=((o-t)*s+(r-e)*a)/(s*s+a*a);h>1?h=1:h<0&&(h=0);var l=t+h*s-o,d=e+h*a-r;return Math.sqrt(l*l+d*d)}},{key:"getArrowData",value:function(t,e,i,n,o,r){var s,a,h,l,d,c,u,f=r.width;"from"===e?(h=this.from,l=this.to,d=r.fromArrowScale<0,c=Math.abs(r.fromArrowScale),u=r.fromArrowType):"to"===e?(h=this.to,l=this.from,d=r.toArrowScale<0,c=Math.abs(r.toArrowScale),u=r.toArrowType):(h=this.to,l=this.from,d=r.middleArrowScale<0,c=Math.abs(r.middleArrowScale),u=r.middleArrowType);var p=15*c+3*f;if(h!=l){var v=p/IO(h.x-l.x,h.y-l.y);if("middle"!==e)if(!0===this.options.smooth.enabled){var g=this._findBorderPosition(h,t,{via:i}),y=this.getPoint(g.t+v*("from"===e?1:-1),i);s=Math.atan2(g.y-y.y,g.x-y.x),a=g}else s=Math.atan2(h.y-l.y,h.x-l.x),a=this._findBorderPosition(h,t);else{var m=(d?-v:v)/2,b=this.getPoint(.5+m,i),w=this.getPoint(.5-m,i);s=Math.atan2(b.y-w.y,b.x-w.x),a=this.getPoint(.5,i)}}else{var k=Kc(this._getCircleData(t),3),_=k[0],x=k[1],E=k[2];if("from"===e){var O=this.options.selfReference.angle,C=this.options.selfReference.angle+Math.PI,S=this._findBorderPositionCircle(this.from,t,{x:_,y:x,low:O,high:C,direction:-1});s=-2*S.t*Math.PI+1.5*Math.PI+.1*Math.PI,a=S}else if("to"===e){var T=this.options.selfReference.angle,M=this.options.selfReference.angle+Math.PI,P=this._findBorderPositionCircle(this.from,t,{x:_,y:x,low:T,high:M,direction:1});s=-2*P.t*Math.PI+1.5*Math.PI-1.1*Math.PI,a=P}else{var D=this.options.selfReference.angle/(2*Math.PI);a=this._pointOnCircle(_,x,E,D),s=-2*D*Math.PI+1.5*Math.PI+.1*Math.PI}}return{point:a,core:{x:a.x-.9*p*Math.cos(s),y:a.y-.9*p*Math.sin(s)},angle:s,length:p,type:u}}},{key:"drawArrowHead",value:function(t,e,i,n,o){t.strokeStyle=this.getColor(t,e),t.fillStyle=t.strokeStyle,t.lineWidth=e.width,XO.draw(t,o)&&(this.enableShadow(t,e),jv(t).call(t),this.disableShadow(t,e))}},{key:"enableShadow",value:function(t,e){!0===e.shadow&&(t.shadowColor=e.shadowColor,t.shadowBlur=e.shadowSize,t.shadowOffsetX=e.shadowX,t.shadowOffsetY=e.shadowY)}},{key:"disableShadow",value:function(t,e){!0===e.shadow&&(t.shadowColor="rgba(0,0,0,0)",t.shadowBlur=0,t.shadowOffsetX=0,t.shadowOffsetY=0)}},{key:"drawBackground",value:function(t,e){if(!1!==e.background){var i={strokeStyle:t.strokeStyle,lineWidth:t.lineWidth,dashes:t.dashes};t.strokeStyle=e.backgroundColor,t.lineWidth=e.backgroundSize,this.setStrokeDashed(t,e.backgroundDashes),t.stroke(),t.strokeStyle=i.strokeStyle,t.lineWidth=i.lineWidth,t.dashes=i.dashes,this.setStrokeDashed(t,e.dashes)}}},{key:"setStrokeDashed",value:function(t,e){if(!1!==e)if(void 0!==t.setLineDash){var i=lu(e)?e:[5,5];t.setLineDash(i)}else console.warn("setLineDash is not supported in this browser. The dashed stroke cannot be used.");else void 0!==t.setLineDash?t.setLineDash([]):console.warn("setLineDash is not supported in this browser. The dashed stroke cannot be used.")}}]),t}();function ZO(t,e){var i=bu(t);if(hd){var n=hd(t);e&&(n=Xf(n).call(n,(function(e){return bd(t,e).enumerable}))),i.push.apply(i,n)}return i}function QO(t){for(var e=1;e<arguments.length;e++){var i,n,o=null!=arguments[e]?arguments[e]:{};e%2?Fu(i=ZO(Object(o),!0)).call(i,(function(e){$d(t,e,o[e])})):Pd?Ad(t,Pd(o)):Fu(n=ZO(Object(o))).call(n,(function(e){Ud(t,e,bd(o,e))}))}return t}function JO(t){var e=function(){if("undefined"==typeof Reflect||!Mk)return!1;if(Mk.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Mk(Boolean,[],(function(){}))),!0}catch(t){return!1}}();return function(){var i,n=Ak(t);if(e){var o=Ak(this).constructor;i=Mk(n,arguments,o)}else i=n.apply(this,arguments);return Nk(this,i)}}var tC=function(t){zk(i,t);var e=JO(i);function i(t,n,o){return Yd(this,i),e.call(this,t,n,o)}return Kd(i,[{key:"_findBorderPositionBezier",value:function(t,e){var i,n,o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:this._getViaCoordinates(),r=10,s=.2,a=!1,h=1,l=0,d=this.to,c=this.options.endPointOffset?this.options.endPointOffset.to:0;t.id===this.from.id&&(d=this.from,a=!0,c=this.options.endPointOffset?this.options.endPointOffset.from:0),!1===this.options.arrowStrikethrough&&(c=0);var u=0;do{n=.5*(l+h),i=this.getPoint(n,o);var f=Math.atan2(d.y-i.y,d.x-i.x),p=d.distanceToBorder(e,f)+c,v=Math.sqrt(Math.pow(i.x-d.x,2)+Math.pow(i.y-d.y,2)),g=p-v;if(Math.abs(g)<s)break;g<0?!1===a?l=n:h=n:!1===a?h=n:l=n,++u}while(l<=h&&u<r);return QO(QO({},i),{},{t:n})}},{key:"_getDistanceToBezierEdge",value:function(t,e,i,n,o,r,s){var a,h,l,d,c,u=1e9,f=t,p=e;for(h=1;h<10;h++)l=.1*h,d=Math.pow(1-l,2)*t+2*l*(1-l)*s.x+Math.pow(l,2)*i,c=Math.pow(1-l,2)*e+2*l*(1-l)*s.y+Math.pow(l,2)*n,h>0&&(u=(a=this._getDistanceToLine(f,p,d,c,o,r))<u?a:u),f=d,p=c;return u}},{key:"_bezierCurve",value:function(t,e,i,n){t.beginPath(),t.moveTo(this.fromPoint.x,this.fromPoint.y),null!=i&&null!=i.x?null!=n&&null!=n.x?t.bezierCurveTo(i.x,i.y,n.x,n.y,this.toPoint.x,this.toPoint.y):t.quadraticCurveTo(i.x,i.y,this.toPoint.x,this.toPoint.y):t.lineTo(this.toPoint.x,this.toPoint.y),this.drawBackground(t,e),this.enableShadow(t,e),t.stroke(),this.disableShadow(t,e)}},{key:"getViaNode",value:function(){return this._getViaCoordinates()}}]),i}($O);function eC(t){var e=function(){if("undefined"==typeof Reflect||!Mk)return!1;if(Mk.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Mk(Boolean,[],(function(){}))),!0}catch(t){return!1}}();return function(){var i,n=Ak(t);if(e){var o=Ak(this).constructor;i=Mk(n,arguments,o)}else i=n.apply(this,arguments);return Nk(this,i)}}var iC=function(t){zk(i,t);var e=eC(i);function i(t,n,o){var r;return Yd(this,i),(r=e.call(this,t,n,o)).via=r.via,r._boundFunction=function(){r.positionBezierNode()},r._body.emitter.on("_repositionBezierNodes",r._boundFunction),r}return Kd(i,[{key:"setOptions",value:function(t){SO(Ak(i.prototype),"setOptions",this).call(this,t);var e=!1;this.options.physics!==t.physics&&(e=!0),this.options=t,this.id=this.options.id,this.from=this._body.nodes[this.options.from],this.to=this._body.nodes[this.options.to],this.setupSupportNode(),this.connect(),!0===e&&(this.via.setOptions({physics:this.options.physics}),this.positionBezierNode())}},{key:"connect",value:function(){this.from=this._body.nodes[this.options.from],this.to=this._body.nodes[this.options.to],void 0===this.from||void 0===this.to||!1===this.options.physics||this.from.id===this.to.id?this.via.setOptions({physics:!1}):this.via.setOptions({physics:!0})}},{key:"cleanup",value:function(){return this._body.emitter.off("_repositionBezierNodes",this._boundFunction),void 0!==this.via&&(delete this._body.nodes[this.via.id],this.via=void 0,!0)}},{key:"setupSupportNode",value:function(){if(void 0===this.via){var t="edgeId:"+this.id,e=this._body.functions.createNode({id:t,shape:"circle",physics:!0,hidden:!0});this._body.nodes[t]=e,this.via=e,this.via.parentEdgeId=this.id,this.positionBezierNode()}}},{key:"positionBezierNode",value:function(){void 0!==this.via&&void 0!==this.from&&void 0!==this.to?(this.via.x=.5*(this.from.x+this.to.x),this.via.y=.5*(this.from.y+this.to.y)):void 0!==this.via&&(this.via.x=0,this.via.y=0)}},{key:"_line",value:function(t,e,i){this._bezierCurve(t,e,i)}},{key:"_getViaCoordinates",value:function(){return this.via}},{key:"getViaNode",value:function(){return this.via}},{key:"getPoint",value:function(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.via;if(this.from===this.to){var i=this._getCircleData(),n=Kc(i,3),o=n[0],r=n[1],s=n[2],a=2*Math.PI*(1-t);return{x:o+s*Math.sin(a),y:r+s-s*(1-Math.cos(a))}}return{x:Math.pow(1-t,2)*this.fromPoint.x+2*t*(1-t)*e.x+Math.pow(t,2)*this.toPoint.x,y:Math.pow(1-t,2)*this.fromPoint.y+2*t*(1-t)*e.y+Math.pow(t,2)*this.toPoint.y}}},{key:"_findBorderPosition",value:function(t,e){return this._findBorderPositionBezier(t,e,this.via)}},{key:"_getDistanceToEdge",value:function(t,e,i,n,o,r){return this._getDistanceToBezierEdge(t,e,i,n,o,r,this.via)}}]),i}(tC);function nC(t){var e=function(){if("undefined"==typeof Reflect||!Mk)return!1;if(Mk.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Mk(Boolean,[],(function(){}))),!0}catch(t){return!1}}();return function(){var i,n=Ak(t);if(e){var o=Ak(this).constructor;i=Mk(n,arguments,o)}else i=n.apply(this,arguments);return Nk(this,i)}}var oC=function(t){zk(i,t);var e=nC(i);function i(t,n,o){return Yd(this,i),e.call(this,t,n,o)}return Kd(i,[{key:"_line",value:function(t,e,i){this._bezierCurve(t,e,i)}},{key:"getViaNode",value:function(){return this._getViaCoordinates()}},{key:"_getViaCoordinates",value:function(){var t,e,i=this.options.smooth.roundness,n=this.options.smooth.type,o=Math.abs(this.from.x-this.to.x),r=Math.abs(this.from.y-this.to.y);if("discrete"===n||"diagonalCross"===n){var s,a;s=a=o<=r?i*r:i*o,this.from.x>this.to.x&&(s=-s),this.from.y>=this.to.y&&(a=-a);var h=this.from.x+s,l=this.from.y+a;return"discrete"===n&&(o<=r?h=o<i*r?this.from.x:h:l=r<i*o?this.from.y:l),{x:h,y:l}}if("straightCross"===n){var d=(1-i)*o,c=(1-i)*r;return o<=r?(d=0,this.from.y<this.to.y&&(c=-c)):(this.from.x<this.to.x&&(d=-d),c=0),{x:this.to.x+d,y:this.to.y+c}}if("horizontal"===n){var u=(1-i)*o;return this.from.x<this.to.x&&(u=-u),{x:this.to.x+u,y:this.from.y}}if("vertical"===n){var f=(1-i)*r;return this.from.y<this.to.y&&(f=-f),{x:this.from.x,y:this.to.y+f}}if("curvedCW"===n){o=this.to.x-this.from.x,r=this.from.y-this.to.y;var p=Math.sqrt(o*o+r*r),v=Math.PI,g=(Math.atan2(r,o)+(.5*i+.5)*v)%(2*v);return{x:this.from.x+(.5*i+.5)*p*Math.sin(g),y:this.from.y+(.5*i+.5)*p*Math.cos(g)}}if("curvedCCW"===n){o=this.to.x-this.from.x,r=this.from.y-this.to.y;var y=Math.sqrt(o*o+r*r),m=Math.PI,b=(Math.atan2(r,o)+(.5*-i+.5)*m)%(2*m);return{x:this.from.x+(.5*i+.5)*y*Math.sin(b),y:this.from.y+(.5*i+.5)*y*Math.cos(b)}}t=e=o<=r?i*r:i*o,this.from.x>this.to.x&&(t=-t),this.from.y>=this.to.y&&(e=-e);var w=this.from.x+t,k=this.from.y+e;return o<=r?w=this.from.x<=this.to.x?this.to.x<w?this.to.x:w:this.to.x>w?this.to.x:w:k=this.from.y>=this.to.y?this.to.y>k?this.to.y:k:this.to.y<k?this.to.y:k,{x:w,y:k}}},{key:"_findBorderPosition",value:function(t,e){var i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};return this._findBorderPositionBezier(t,e,i.via)}},{key:"_getDistanceToEdge",value:function(t,e,i,n,o,r){var s=arguments.length>6&&void 0!==arguments[6]?arguments[6]:this._getViaCoordinates();return this._getDistanceToBezierEdge(t,e,i,n,o,r,s)}},{key:"getPoint",value:function(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this._getViaCoordinates(),i=t,n=Math.pow(1-i,2)*this.fromPoint.x+2*i*(1-i)*e.x+Math.pow(i,2)*this.toPoint.x,o=Math.pow(1-i,2)*this.fromPoint.y+2*i*(1-i)*e.y+Math.pow(i,2)*this.toPoint.y;return{x:n,y:o}}}]),i}(tC);function rC(t){var e=function(){if("undefined"==typeof Reflect||!Mk)return!1;if(Mk.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Mk(Boolean,[],(function(){}))),!0}catch(t){return!1}}();return function(){var i,n=Ak(t);if(e){var o=Ak(this).constructor;i=Mk(n,arguments,o)}else i=n.apply(this,arguments);return Nk(this,i)}}var sC=function(t){zk(i,t);var e=rC(i);function i(t,n,o){return Yd(this,i),e.call(this,t,n,o)}return Kd(i,[{key:"_getDistanceToBezierEdge2",value:function(t,e,i,n,o,r,s,a){for(var h=1e9,l=t,d=e,c=[0,0,0,0],u=1;u<10;u++){var f=.1*u;c[0]=Math.pow(1-f,3),c[1]=3*f*Math.pow(1-f,2),c[2]=3*Math.pow(f,2)*(1-f),c[3]=Math.pow(f,3);var p=c[0]*t+c[1]*s.x+c[2]*a.x+c[3]*i,v=c[0]*e+c[1]*s.y+c[2]*a.y+c[3]*n;if(u>0){var g=this._getDistanceToLine(l,d,p,v,o,r);h=g<h?g:h}l=p,d=v}return h}}]),i}(tC);function aC(t){var e=function(){if("undefined"==typeof Reflect||!Mk)return!1;if(Mk.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Mk(Boolean,[],(function(){}))),!0}catch(t){return!1}}();return function(){var i,n=Ak(t);if(e){var o=Ak(this).constructor;i=Mk(n,arguments,o)}else i=n.apply(this,arguments);return Nk(this,i)}}var hC=function(t){zk(i,t);var e=aC(i);function i(t,n,o){return Yd(this,i),e.call(this,t,n,o)}return Kd(i,[{key:"_line",value:function(t,e,i){var n=i[0],o=i[1];this._bezierCurve(t,e,n,o)}},{key:"_getViaCoordinates",value:function(){var t,e,i,n,o=this.from.x-this.to.x,r=this.from.y-this.to.y,s=this.options.smooth.roundness;return(Math.abs(o)>Math.abs(r)||!0===this.options.smooth.forceDirection||"horizontal"===this.options.smooth.forceDirection)&&"vertical"!==this.options.smooth.forceDirection?(e=this.from.y,n=this.to.y,t=this.from.x-s*o,i=this.to.x+s*o):(e=this.from.y-s*r,n=this.to.y+s*r,t=this.from.x,i=this.to.x),[{x:t,y:e},{x:i,y:n}]}},{key:"getViaNode",value:function(){return this._getViaCoordinates()}},{key:"_findBorderPosition",value:function(t,e){return this._findBorderPositionBezier(t,e)}},{key:"_getDistanceToEdge",value:function(t,e,i,n,o,r){var s=arguments.length>6&&void 0!==arguments[6]?arguments[6]:this._getViaCoordinates(),a=Kc(s,2),h=a[0],l=a[1];return this._getDistanceToBezierEdge2(t,e,i,n,o,r,h,l)}},{key:"getPoint",value:function(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this._getViaCoordinates(),i=Kc(e,2),n=i[0],o=i[1],r=t,s=[Math.pow(1-r,3),3*r*Math.pow(1-r,2),3*Math.pow(r,2)*(1-r),Math.pow(r,3)],a=s[0]*this.fromPoint.x+s[1]*n.x+s[2]*o.x+s[3]*this.toPoint.x,h=s[0]*this.fromPoint.y+s[1]*n.y+s[2]*o.y+s[3]*this.toPoint.y;return{x:a,y:h}}}]),i}(sC);function lC(t){var e=function(){if("undefined"==typeof Reflect||!Mk)return!1;if(Mk.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Mk(Boolean,[],(function(){}))),!0}catch(t){return!1}}();return function(){var i,n=Ak(t);if(e){var o=Ak(this).constructor;i=Mk(n,arguments,o)}else i=n.apply(this,arguments);return Nk(this,i)}}var dC=function(t){zk(i,t);var e=lC(i);function i(t,n,o){return Yd(this,i),e.call(this,t,n,o)}return Kd(i,[{key:"_line",value:function(t,e){t.beginPath(),t.moveTo(this.fromPoint.x,this.fromPoint.y),t.lineTo(this.toPoint.x,this.toPoint.y),this.enableShadow(t,e),t.stroke(),this.disableShadow(t,e)}},{key:"getViaNode",value:function(){}},{key:"getPoint",value:function(t){return{x:(1-t)*this.fromPoint.x+t*this.toPoint.x,y:(1-t)*this.fromPoint.y+t*this.toPoint.y}}},{key:"_findBorderPosition",value:function(t,e){var i=this.to,n=this.from;t.id===this.from.id&&(i=this.from,n=this.to);var o=Math.atan2(i.y-n.y,i.x-n.x),r=i.x-n.x,s=i.y-n.y,a=Math.sqrt(r*r+s*s),h=(a-t.distanceToBorder(e,o))/a;return{x:(1-h)*n.x+h*i.x,y:(1-h)*n.y+h*i.y,t:0}}},{key:"_getDistanceToEdge",value:function(t,e,i,n,o,r){return this._getDistanceToLine(t,e,i,n,o,r)}}]),i}($O),cC=function(){function t(e,i,n,o,r){if(Yd(this,t),void 0===i)throw new Error("No body provided");this.options=Cm(o),this.globalOptions=o,this.defaultOptions=r,this.body=i,this.imagelist=n,this.id=void 0,this.fromId=void 0,this.toId=void 0,this.selected=!1,this.hover=!1,this.labelDirty=!0,this.baseWidth=this.options.width,this.baseFontSize=this.options.font.size,this.from=void 0,this.to=void 0,this.edgeType=void 0,this.connected=!1,this.labelModule=new OE(this.body,this.options,!0),this.setOptions(e)}return Kd(t,[{key:"setOptions",value:function(e){if(e){var i=void 0!==e.physics&&this.options.physics!==e.physics||void 0!==e.hidden&&(this.options.hidden||!1)!==(e.hidden||!1)||void 0!==e.from&&this.options.from!==e.from||void 0!==e.to&&this.options.to!==e.to;t.parseOptions(this.options,e,!0,this.globalOptions),void 0!==e.id&&(this.id=e.id),void 0!==e.from&&(this.fromId=e.from),void 0!==e.to&&(this.toId=e.to),void 0!==e.title&&(this.title=e.title),void 0!==e.value&&(e.value=lE(e.value));var n=[e,this.options,this.defaultOptions];return this.chooser=gE("edge",n),this.updateLabelModule(e),i=this.updateEdgeType()||i,this._setInteractionWidths(),this.connect(),i}}},{key:"getFormattingValues",value:function(){var t=!0===this.options.arrows.to||!0===this.options.arrows.to.enabled,e=!0===this.options.arrows.from||!0===this.options.arrows.from.enabled,i=!0===this.options.arrows.middle||!0===this.options.arrows.middle.enabled,n=this.options.color.inherit,o={toArrow:t,toArrowScale:this.options.arrows.to.scaleFactor,toArrowType:this.options.arrows.to.type,toArrowSrc:this.options.arrows.to.src,toArrowImageWidth:this.options.arrows.to.imageWidth,toArrowImageHeight:this.options.arrows.to.imageHeight,middleArrow:i,middleArrowScale:this.options.arrows.middle.scaleFactor,middleArrowType:this.options.arrows.middle.type,middleArrowSrc:this.options.arrows.middle.src,middleArrowImageWidth:this.options.arrows.middle.imageWidth,middleArrowImageHeight:this.options.arrows.middle.imageHeight,fromArrow:e,fromArrowScale:this.options.arrows.from.scaleFactor,fromArrowType:this.options.arrows.from.type,fromArrowSrc:this.options.arrows.from.src,fromArrowImageWidth:this.options.arrows.from.imageWidth,fromArrowImageHeight:this.options.arrows.from.imageHeight,arrowStrikethrough:this.options.arrowStrikethrough,color:n?void 0:this.options.color.color,inheritsColor:n,opacity:this.options.color.opacity,hidden:this.options.hidden,length:this.options.length,shadow:this.options.shadow.enabled,shadowColor:this.options.shadow.color,shadowSize:this.options.shadow.size,shadowX:this.options.shadow.x,shadowY:this.options.shadow.y,dashes:this.options.dashes,width:this.options.width,background:this.options.background.enabled,backgroundColor:this.options.background.color,backgroundSize:this.options.background.size,backgroundDashes:this.options.background.dashes};if(this.selected||this.hover)if(!0===this.chooser){if(this.selected){var r=this.options.selectionWidth;"function"==typeof r?o.width=r(o.width):"number"==typeof r&&(o.width+=r),o.width=Math.max(o.width,.3/this.body.view.scale),o.color=this.options.color.highlight,o.shadow=this.options.shadow.enabled}else if(this.hover){var s=this.options.hoverWidth;"function"==typeof s?o.width=s(o.width):"number"==typeof s&&(o.width+=s),o.width=Math.max(o.width,.3/this.body.view.scale),o.color=this.options.color.hover,o.shadow=this.options.shadow.enabled}}else"function"==typeof this.chooser&&(this.chooser(o,this.options.id,this.selected,this.hover),void 0!==o.color&&(o.inheritsColor=!1),!1===o.shadow&&(o.shadowColor===this.options.shadow.color&&o.shadowSize===this.options.shadow.size&&o.shadowX===this.options.shadow.x&&o.shadowY===this.options.shadow.y||(o.shadow=!0)));else o.shadow=this.options.shadow.enabled,o.width=Math.max(o.width,.3/this.body.view.scale);return o}},{key:"updateLabelModule",value:function(t){var e=[t,this.options,this.globalOptions,this.defaultOptions];this.labelModule.update(this.options,e),void 0!==this.labelModule.baseSize&&(this.baseFontSize=this.labelModule.baseSize)}},{key:"updateEdgeType",value:function(){var t=this.options.smooth,e=!1,i=!0;return void 0!==this.edgeType&&((this.edgeType instanceof iC&&!0===t.enabled&&"dynamic"===t.type||this.edgeType instanceof hC&&!0===t.enabled&&"cubicBezier"===t.type||this.edgeType instanceof oC&&!0===t.enabled&&"dynamic"!==t.type&&"cubicBezier"!==t.type||this.edgeType instanceof dC&&!1===t.type.enabled)&&(i=!1),!0===i&&(e=this.cleanup())),!0===i?!0===t.enabled?"dynamic"===t.type?(e=!0,this.edgeType=new iC(this.options,this.body,this.labelModule)):"cubicBezier"===t.type?this.edgeType=new hC(this.options,this.body,this.labelModule):this.edgeType=new oC(this.options,this.body,this.labelModule):this.edgeType=new dC(this.options,this.body,this.labelModule):this.edgeType.setOptions(this.options),e}},{key:"connect",value:function(){this.disconnect(),this.from=this.body.nodes[this.fromId]||void 0,this.to=this.body.nodes[this.toId]||void 0,this.connected=void 0!==this.from&&void 0!==this.to,!0===this.connected?(this.from.attachEdge(this),this.to.attachEdge(this)):(this.from&&this.from.detachEdge(this),this.to&&this.to.detachEdge(this)),this.edgeType.connect()}},{key:"disconnect",value:function(){this.from&&(this.from.detachEdge(this),this.from=void 0),this.to&&(this.to.detachEdge(this),this.to=void 0),this.connected=!1}},{key:"getTitle",value:function(){return this.title}},{key:"isSelected",value:function(){return this.selected}},{key:"getValue",value:function(){return this.options.value}},{key:"setValueRange",value:function(t,e,i){if(void 0!==this.options.value){var n=this.options.scaling.customScalingFunction(t,e,i,this.options.value),o=this.options.scaling.max-this.options.scaling.min;if(!0===this.options.scaling.label.enabled){var r=this.options.scaling.label.max-this.options.scaling.label.min;this.options.font.size=this.options.scaling.label.min+n*r}this.options.width=this.options.scaling.min+n*o}else this.options.width=this.baseWidth,this.options.font.size=this.baseFontSize;this._setInteractionWidths(),this.updateLabelModule()}},{key:"_setInteractionWidths",value:function(){"function"==typeof this.options.hoverWidth?this.edgeType.hoverWidth=this.options.hoverWidth(this.options.width):this.edgeType.hoverWidth=this.options.hoverWidth+this.options.width,"function"==typeof this.options.selectionWidth?this.edgeType.selectionWidth=this.options.selectionWidth(this.options.width):this.edgeType.selectionWidth=this.options.selectionWidth+this.options.width}},{key:"draw",value:function(t){var e=this.getFormattingValues();if(!e.hidden){var i=this.edgeType.getViaNode();this.edgeType.drawLine(t,e,this.selected,this.hover,i),this.drawLabel(t,i)}}},{key:"drawArrows",value:function(t){var e=this.getFormattingValues();if(!e.hidden){var i=this.edgeType.getViaNode(),n={};this.edgeType.fromPoint=this.edgeType.from,this.edgeType.toPoint=this.edgeType.to,e.fromArrow&&(n.from=this.edgeType.getArrowData(t,"from",i,this.selected,this.hover,e),!1===e.arrowStrikethrough&&(this.edgeType.fromPoint=n.from.core),e.fromArrowSrc&&(n.from.image=this.imagelist.load(e.fromArrowSrc)),e.fromArrowImageWidth&&(n.from.imageWidth=e.fromArrowImageWidth),e.fromArrowImageHeight&&(n.from.imageHeight=e.fromArrowImageHeight)),e.toArrow&&(n.to=this.edgeType.getArrowData(t,"to",i,this.selected,this.hover,e),!1===e.arrowStrikethrough&&(this.edgeType.toPoint=n.to.core),e.toArrowSrc&&(n.to.image=this.imagelist.load(e.toArrowSrc)),e.toArrowImageWidth&&(n.to.imageWidth=e.toArrowImageWidth),e.toArrowImageHeight&&(n.to.imageHeight=e.toArrowImageHeight)),e.middleArrow&&(n.middle=this.edgeType.getArrowData(t,"middle",i,this.selected,this.hover,e),e.middleArrowSrc&&(n.middle.image=this.imagelist.load(e.middleArrowSrc)),e.middleArrowImageWidth&&(n.middle.imageWidth=e.middleArrowImageWidth),e.middleArrowImageHeight&&(n.middle.imageHeight=e.middleArrowImageHeight)),e.fromArrow&&this.edgeType.drawArrowHead(t,e,this.selected,this.hover,n.from),e.middleArrow&&this.edgeType.drawArrowHead(t,e,this.selected,this.hover,n.middle),e.toArrow&&this.edgeType.drawArrowHead(t,e,this.selected,this.hover,n.to)}}},{key:"drawLabel",value:function(t,e){if(void 0!==this.options.label){var i,n=this.from,o=this.to;if(this.labelModule.differentState(this.selected,this.hover)&&this.labelModule.getTextSize(t,this.selected,this.hover),n.id!=o.id){this.labelModule.pointToSelf=!1,i=this.edgeType.getPoint(.5,e),t.save();var r=this._getRotation(t);0!=r.angle&&(t.translate(r.x,r.y),t.rotate(r.angle)),this.labelModule.draw(t,i.x,i.y,this.selected,this.hover),t.restore()}else{this.labelModule.pointToSelf=!0;var s=bE(t,this.options.selfReference.angle,this.options.selfReference.size,n);i=this._pointOnCircle(s.x,s.y,this.options.selfReference.size,this.options.selfReference.angle),this.labelModule.draw(t,i.x,i.y,this.selected,this.hover)}}}},{key:"getItemsOnPoint",value:function(t){var e=[];if(this.labelModule.visible()){var i=this._getRotation();yE(this.labelModule.getSize(),t,i)&&e.push({edgeId:this.id,labelId:0})}var n={left:t.x,top:t.y};return this.isOverlappingWith(n)&&e.push({edgeId:this.id}),e}},{key:"isOverlappingWith",value:function(t){if(this.connected){var e=this.from.x,i=this.from.y,n=this.to.x,o=this.to.y,r=t.left,s=t.top;return this.edgeType.getDistanceToEdge(e,i,n,o,r,s)<10}return!1}},{key:"_getRotation",value:function(t){var e=this.edgeType.getViaNode(),i=this.edgeType.getPoint(.5,e);void 0!==t&&this.labelModule.calculateLabelSize(t,this.selected,this.hover,i.x,i.y);var n={x:i.x,y:this.labelModule.size.yLine,angle:0};if(!this.labelModule.visible())return n;if("horizontal"===this.options.font.align)return n;var o=this.from.y-this.to.y,r=this.from.x-this.to.x,s=Math.atan2(o,r);return(s<-1&&r<0||s>0&&r<0)&&(s+=Math.PI),n.angle=s,n}},{key:"_pointOnCircle",value:function(t,e,i,n){return{x:t+i*Math.cos(n),y:e-i*Math.sin(n)}}},{key:"select",value:function(){this.selected=!0}},{key:"unselect",value:function(){this.selected=!1}},{key:"cleanup",value:function(){return this.edgeType.cleanup()}},{key:"remove",value:function(){this.cleanup(),this.disconnect(),delete this.body.edges[this.id]}},{key:"endPointsValid",value:function(){return void 0!==this.body.nodes[this.fromId]&&void 0!==this.body.nodes[this.toId]}}],[{key:"parseOptions",value:function(t,e){var i=arguments.length>2&&void 0!==arguments[2]&&arguments[2],n=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{},o=arguments.length>4&&void 0!==arguments[4]&&arguments[4],r=["endPointOffset","arrowStrikethrough","id","from","hidden","hoverWidth","labelHighlightBold","length","line","opacity","physics","scaling","selectionWidth","selfReferenceSize","selfReference","to","title","value","width","font","chosen","widthConstraint"];if(em(r,t,e,i),void 0!==e.endPointOffset&&void 0!==e.endPointOffset.from&&(ok(e.endPointOffset.from)?t.endPointOffset.from=e.endPointOffset.from:(t.endPointOffset.from=void 0!==n.endPointOffset.from?n.endPointOffset.from:0,console.error("endPointOffset.from is not a valid number"))),void 0!==e.endPointOffset&&void 0!==e.endPointOffset.to&&(ok(e.endPointOffset.to)?t.endPointOffset.to=e.endPointOffset.to:(t.endPointOffset.to=void 0!==n.endPointOffset.to?n.endPointOffset.to:0,console.error("endPointOffset.to is not a valid number"))),mE(e.label)?t.label=e.label:mE(t.label)||(t.label=void 0),Sm(t,e,"smooth",n),Sm(t,e,"shadow",n),Sm(t,e,"background",n),void 0!==e.dashes&&null!==e.dashes?t.dashes=e.dashes:!0===i&&null===e.dashes&&(t.dashes=Kp(n.dashes)),void 0!==e.scaling&&null!==e.scaling?(void 0!==e.scaling.min&&(t.scaling.min=e.scaling.min),void 0!==e.scaling.max&&(t.scaling.max=e.scaling.max),Sm(t.scaling,e.scaling,"label",n.scaling)):!0===i&&null===e.scaling&&(t.scaling=Kp(n.scaling)),void 0!==e.arrows&&null!==e.arrows)if("string"==typeof e.arrows){var s=e.arrows.toLowerCase();t.arrows.to.enabled=-1!=Fp(s).call(s,"to"),t.arrows.middle.enabled=-1!=Fp(s).call(s,"middle"),t.arrows.from.enabled=-1!=Fp(s).call(s,"from")}else{if("object"!==Qc(e.arrows))throw new Error("The arrow newOptions can only be an object or a string. Refer to the documentation. You used:"+gv(e.arrows));Sm(t.arrows,e.arrows,"to",n.arrows),Sm(t.arrows,e.arrows,"middle",n.arrows),Sm(t.arrows,e.arrows,"from",n.arrows)}else!0===i&&null===e.arrows&&(t.arrows=Kp(n.arrows));if(void 0!==e.color&&null!==e.color){var a=$y(e.color)?{color:e.color,highlight:e.color,hover:e.color,inherit:!1,opacity:1}:e.color,h=t.color;if(o)nm(h,n.color,!1,i);else for(var l in h)Object.prototype.hasOwnProperty.call(h,l)&&delete h[l];if($y(h))h.color=h,h.highlight=h,h.hover=h,h.inherit=!1,void 0===a.opacity&&(h.opacity=1);else{var d=!1;void 0!==a.color&&(h.color=a.color,d=!0),void 0!==a.highlight&&(h.highlight=a.highlight,d=!0),void 0!==a.hover&&(h.hover=a.hover,d=!0),void 0!==a.inherit&&(h.inherit=a.inherit),void 0!==a.opacity&&(h.opacity=Math.min(1,Math.max(0,a.opacity))),!0===d?h.inherit=!1:void 0===h.inherit&&(h.inherit="from")}}else!0===i&&null===e.color&&(t.color=Cm(n.color));!0===i&&null===e.font&&(t.font=Cm(n.font)),Object.prototype.hasOwnProperty.call(e,"selfReferenceSize")&&(console.warn("The selfReferenceSize property has been deprecated. Please use selfReference property instead. The selfReference can be set like thise selfReference:{size:30, angle:Math.PI / 4}"),t.selfReference.size=e.selfReferenceSize)}}]),t}(),uC=function(){function t(e,i,n){var o,r=this;Yd(this,t),this.body=e,this.images=i,this.groups=n,this.body.functions.createEdge=zn(o=this.create).call(o,this),this.edgesListeners={add:function(t,e){r.add(e.items)},update:function(t,e){r.update(e.items)},remove:function(t,e){r.remove(e.items)}},this.options={},this.defaultOptions={arrows:{to:{enabled:!1,scaleFactor:1,type:"arrow"},middle:{enabled:!1,scaleFactor:1,type:"arrow"},from:{enabled:!1,scaleFactor:1,type:"arrow"}},endPointOffset:{from:0,to:0},arrowStrikethrough:!0,color:{color:"#848484",highlight:"#848484",hover:"#848484",inherit:"from",opacity:1},dashes:!1,font:{color:"#343434",size:14,face:"arial",background:"none",strokeWidth:2,strokeColor:"#ffffff",align:"horizontal",multi:!1,vadjust:0,bold:{mod:"bold"},boldital:{mod:"bold italic"},ital:{mod:"italic"},mono:{mod:"",size:15,face:"courier new",vadjust:2}},hidden:!1,hoverWidth:1.5,label:void 0,labelHighlightBold:!0,length:void 0,physics:!0,scaling:{min:1,max:15,label:{enabled:!0,min:14,max:30,maxVisible:30,drawThreshold:5},customScalingFunction:function(t,e,i,n){if(e===t)return.5;var o=1/(e-t);return Math.max(0,(n-t)*o)}},selectionWidth:1.5,selfReference:{size:20,angle:Math.PI/4,renderBehindTheNode:!0},shadow:{enabled:!1,color:"rgba(0,0,0,0.5)",size:10,x:5,y:5},background:{enabled:!1,color:"rgba(111,111,111,1)",size:10,dashes:!1},smooth:{enabled:!0,type:"dynamic",forceDirection:"none",roundness:.5},title:void 0,width:1,value:void 0},nm(this.options,this.defaultOptions),this.bindEventListeners()}return Kd(t,[{key:"bindEventListeners",value:function(){var t,e,i=this;this.body.emitter.on("_forceDisableDynamicCurves",(function(t){var e=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];"dynamic"===t&&(t="continuous");var n=!1;for(var o in i.body.edges)if(Object.prototype.hasOwnProperty.call(i.body.edges,o)){var r=i.body.edges[o],s=i.body.data.edges.get(o);if(null!=s){var a=s.smooth;void 0!==a&&!0===a.enabled&&"dynamic"===a.type&&(void 0===t?r.setOptions({smooth:!1}):r.setOptions({smooth:{type:t}}),n=!0)}}!0===e&&!0===n&&i.body.emitter.emit("_dataChanged")})),this.body.emitter.on("_dataUpdated",(function(){i.reconnectEdges()})),this.body.emitter.on("refreshEdges",zn(t=this.refresh).call(t,this)),this.body.emitter.on("refresh",zn(e=this.refresh).call(e,this)),this.body.emitter.on("destroy",(function(){hm(i.edgesListeners,(function(t,e){i.body.data.edges&&i.body.data.edges.off(e,t)})),delete i.body.functions.createEdge,delete i.edgesListeners.add,delete i.edgesListeners.update,delete i.edgesListeners.remove,delete i.edgesListeners}))}},{key:"setOptions",value:function(t){if(void 0!==t){cC.parseOptions(this.options,t,!0,this.defaultOptions,!0);var e=!1;if(void 0!==t.smooth)for(var i in this.body.edges)Object.prototype.hasOwnProperty.call(this.body.edges,i)&&(e=this.body.edges[i].updateEdgeType()||e);if(void 0!==t.font)for(var n in this.body.edges)Object.prototype.hasOwnProperty.call(this.body.edges,n)&&this.body.edges[n].updateLabelModule();void 0===t.hidden&&void 0===t.physics&&!0!==e||this.body.emitter.emit("_dataChanged")}}},{key:"setData",value:function(t){var e=this,i=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=this.body.data.edges;if(Qx("id",t))this.body.data.edges=t;else if(lu(t))this.body.data.edges=new Kx,this.body.data.edges.add(t);else{if(t)throw new TypeError("Array or DataSet expected");this.body.data.edges=new Kx}if(n&&hm(this.edgesListeners,(function(t,e){n.off(e,t)})),this.body.edges={},this.body.data.edges){hm(this.edgesListeners,(function(t,i){e.body.data.edges.on(i,t)}));var o=this.body.data.edges.getIds();this.add(o,!0)}this.body.emitter.emit("_adjustEdgesForHierarchicalLayout"),!1===i&&this.body.emitter.emit("_dataChanged")}},{key:"add",value:function(t){for(var e=arguments.length>1&&void 0!==arguments[1]&&arguments[1],i=this.body.edges,n=this.body.data.edges,o=0;o<t.length;o++){var r=t[o],s=i[r];s&&s.disconnect();var a=n.get(r,{showInternalIds:!0});i[r]=this.create(a)}this.body.emitter.emit("_adjustEdgesForHierarchicalLayout"),!1===e&&this.body.emitter.emit("_dataChanged")}},{key:"update",value:function(t){for(var e=this.body.edges,i=this.body.data.edges,n=!1,o=0;o<t.length;o++){var r=t[o],s=i.get(r),a=e[r];void 0!==a?(a.disconnect(),n=a.setOptions(s)||n,a.connect()):(this.body.edges[r]=this.create(s),n=!0)}!0===n?(this.body.emitter.emit("_adjustEdgesForHierarchicalLayout"),this.body.emitter.emit("_dataChanged")):this.body.emitter.emit("_dataUpdated")}},{key:"remove",value:function(t){var e=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];if(0!==t.length){var i=this.body.edges;hm(t,(function(t){var e=i[t];void 0!==e&&e.remove()})),e&&this.body.emitter.emit("_dataChanged")}}},{key:"refresh",value:function(){var t=this;hm(this.body.edges,(function(e,i){var n=t.body.data.edges.get(i);void 0!==n&&e.setOptions(n)}))}},{key:"create",value:function(t){return new cC(t,this.body,this.images,this.options,this.defaultOptions)}},{key:"reconnectEdges",value:function(){var t,e=this.body.nodes,i=this.body.edges;for(t in e)Object.prototype.hasOwnProperty.call(e,t)&&(e[t].edges=[]);for(t in i)if(Object.prototype.hasOwnProperty.call(i,t)){var n=i[t];n.from=null,n.to=null,n.connect()}}},{key:"getConnectedNodes",value:function(t){var e=[];if(void 0!==this.body.edges[t]){var i=this.body.edges[t];void 0!==i.fromId&&e.push(i.fromId),void 0!==i.toId&&e.push(i.toId)}return e}},{key:"_updateState",value:function(){this._addMissingEdges(),this._removeInvalidEdges()}},{key:"_removeInvalidEdges",value:function(){var t=this,e=[];hm(this.body.edges,(function(i,n){var o=t.body.nodes[i.toId],r=t.body.nodes[i.fromId];void 0!==o&&!0===o.isCluster||void 0!==r&&!0===r.isCluster||void 0!==o&&void 0!==r||e.push(n)})),this.remove(e,!1)}},{key:"_addMissingEdges",value:function(){var t=this.body.data.edges;if(null!=t){var e=this.body.edges,i=[];Fu(t).call(t,(function(t,n){void 0===e[n]&&i.push(n)})),this.add(i,!0)}}}]),t}(),fC=function(){function t(e,i,n){Yd(this,t),this.body=e,this.physicsBody=i,this.barnesHutTree,this.setOptions(n),this._rng=jy("BARNES HUT SOLVER")}return Kd(t,[{key:"setOptions",value:function(t){this.options=t,this.thetaInversed=1/this.options.theta,this.overlapAvoidanceFactor=1-Math.max(0,Math.min(1,this.options.avoidOverlap))}},{key:"solve",value:function(){if(0!==this.options.gravitationalConstant&&this.physicsBody.physicsNodeIndices.length>0){var t,e=this.body.nodes,i=this.physicsBody.physicsNodeIndices,n=i.length,o=this._formBarnesHutTree(e,i);this.barnesHutTree=o;for(var r=0;r<n;r++)(t=e[i[r]]).options.mass>0&&this._getForceContributions(o.root,t)}}},{key:"_getForceContributions",value:function(t,e){this._getForceContribution(t.children.NW,e),this._getForceContribution(t.children.NE,e),this._getForceContribution(t.children.SW,e),this._getForceContribution(t.children.SE,e)}},{key:"_getForceContribution",value:function(t,e){if(t.childrenCount>0){var i=t.centerOfMass.x-e.x,n=t.centerOfMass.y-e.y,o=Math.sqrt(i*i+n*n);o*t.calcSize>this.thetaInversed?this._calculateForces(o,i,n,e,t):4===t.childrenCount?this._getForceContributions(t,e):t.children.data.id!=e.id&&this._calculateForces(o,i,n,e,t)}}},{key:"_calculateForces",value:function(t,e,i,n,o){0===t&&(e=t=.1),this.overlapAvoidanceFactor<1&&n.shape.radius&&(t=Math.max(.1+this.overlapAvoidanceFactor*n.shape.radius,t-n.shape.radius));var r=this.options.gravitationalConstant*o.mass*n.options.mass/Math.pow(t,3),s=e*r,a=i*r;this.physicsBody.forces[n.id].x+=s,this.physicsBody.forces[n.id].y+=a}},{key:"_formBarnesHutTree",value:function(t,e){for(var i,n=e.length,o=t[e[0]].x,r=t[e[0]].y,s=t[e[0]].x,a=t[e[0]].y,h=1;h<n;h++){var l=t[e[h]],d=l.x,c=l.y;l.options.mass>0&&(d<o&&(o=d),d>s&&(s=d),c<r&&(r=c),c>a&&(a=c))}var u=Math.abs(s-o)-Math.abs(a-r);u>0?(r-=.5*u,a+=.5*u):(o+=.5*u,s-=.5*u);var f=Math.max(1e-5,Math.abs(s-o)),p=.5*f,v=.5*(o+s),g=.5*(r+a),y={root:{centerOfMass:{x:0,y:0},mass:0,range:{minX:v-p,maxX:v+p,minY:g-p,maxY:g+p},size:f,calcSize:1/f,children:{data:null},maxWidth:0,level:0,childrenCount:4}};this._splitBranch(y.root);for(var m=0;m<n;m++)(i=t[e[m]]).options.mass>0&&this._placeInTree(y.root,i);return y}},{key:"_updateBranchMass",value:function(t,e){var i=t.centerOfMass,n=t.mass+e.options.mass,o=1/n;i.x=i.x*t.mass+e.x*e.options.mass,i.x*=o,i.y=i.y*t.mass+e.y*e.options.mass,i.y*=o,t.mass=n;var r=Math.max(Math.max(e.height,e.radius),e.width);t.maxWidth=t.maxWidth<r?r:t.maxWidth}},{key:"_placeInTree",value:function(t,e,i){1==i&&void 0!==i||this._updateBranchMass(t,e);var n,o=t.children.NW.range;n=o.maxX>e.x?o.maxY>e.y?"NW":"SW":o.maxY>e.y?"NE":"SE",this._placeInRegion(t,e,n)}},{key:"_placeInRegion",value:function(t,e,i){var n=t.children[i];switch(n.childrenCount){case 0:n.children.data=e,n.childrenCount=1,this._updateBranchMass(n,e);break;case 1:n.children.data.x===e.x&&n.children.data.y===e.y?(e.x+=this._rng(),e.y+=this._rng()):(this._splitBranch(n),this._placeInTree(n,e));break;case 4:this._placeInTree(n,e)}}},{key:"_splitBranch",value:function(t){var e=null;1===t.childrenCount&&(e=t.children.data,t.mass=0,t.centerOfMass.x=0,t.centerOfMass.y=0),t.childrenCount=4,t.children.data=null,this._insertRegion(t,"NW"),this._insertRegion(t,"NE"),this._insertRegion(t,"SW"),this._insertRegion(t,"SE"),null!=e&&this._placeInTree(t,e)}},{key:"_insertRegion",value:function(t,e){var i,n,o,r,s=.5*t.size;switch(e){case"NW":i=t.range.minX,n=t.range.minX+s,o=t.range.minY,r=t.range.minY+s;break;case"NE":i=t.range.minX+s,n=t.range.maxX,o=t.range.minY,r=t.range.minY+s;break;case"SW":i=t.range.minX,n=t.range.minX+s,o=t.range.minY+s,r=t.range.maxY;break;case"SE":i=t.range.minX+s,n=t.range.maxX,o=t.range.minY+s,r=t.range.maxY}t.children[e]={centerOfMass:{x:0,y:0},mass:0,range:{minX:i,maxX:n,minY:o,maxY:r},size:.5*t.size,calcSize:2*t.calcSize,children:{data:null},maxWidth:0,level:t.level+1,childrenCount:0}}},{key:"_debug",value:function(t,e){void 0!==this.barnesHutTree&&(t.lineWidth=1,this._drawBranch(this.barnesHutTree.root,t,e))}},{key:"_drawBranch",value:function(t,e,i){void 0===i&&(i="#FF0000"),4===t.childrenCount&&(this._drawBranch(t.children.NW,e),this._drawBranch(t.children.NE,e),this._drawBranch(t.children.SE,e),this._drawBranch(t.children.SW,e)),e.strokeStyle=i,e.beginPath(),e.moveTo(t.range.minX,t.range.minY),e.lineTo(t.range.maxX,t.range.minY),e.stroke(),e.beginPath(),e.moveTo(t.range.maxX,t.range.minY),e.lineTo(t.range.maxX,t.range.maxY),e.stroke(),e.beginPath(),e.moveTo(t.range.maxX,t.range.maxY),e.lineTo(t.range.minX,t.range.maxY),e.stroke(),e.beginPath(),e.moveTo(t.range.minX,t.range.maxY),e.lineTo(t.range.minX,t.range.minY),e.stroke()}}]),t}(),pC=function(){function t(e,i,n){Yd(this,t),this._rng=jy("REPULSION SOLVER"),this.body=e,this.physicsBody=i,this.setOptions(n)}return Kd(t,[{key:"setOptions",value:function(t){this.options=t}},{key:"solve",value:function(){for(var t,e,i,n,o,r,s,a,h=this.body.nodes,l=this.physicsBody.physicsNodeIndices,d=this.physicsBody.forces,c=this.options.nodeDistance,u=-2/3/c,f=0;f<l.length-1;f++){s=h[l[f]];for(var p=f+1;p<l.length;p++)t=(a=h[l[p]]).x-s.x,e=a.y-s.y,0===(i=Math.sqrt(t*t+e*e))&&(t=i=.1*this._rng()),i<2*c&&(r=i<.5*c?1:u*i+1.3333333333333333,n=t*(r/=i),o=e*r,d[s.id].x-=n,d[s.id].y-=o,d[a.id].x+=n,d[a.id].y+=o)}}}]),t}(),vC=function(){function t(e,i,n){Yd(this,t),this.body=e,this.physicsBody=i,this.setOptions(n)}return Kd(t,[{key:"setOptions",value:function(t){this.options=t,this.overlapAvoidanceFactor=Math.max(0,Math.min(1,this.options.avoidOverlap||0))}},{key:"solve",value:function(){for(var t=this.body.nodes,e=this.physicsBody.physicsNodeIndices,i=this.physicsBody.forces,n=this.options.nodeDistance,o=0;o<e.length-1;o++)for(var r=t[e[o]],s=o+1;s<e.length;s++){var a=t[e[s]];if(r.level===a.level){var h=n+this.overlapAvoidanceFactor*((r.shape.radius||0)/2+(a.shape.radius||0)/2),l=a.x-r.x,d=a.y-r.y,c=Math.sqrt(l*l+d*d),u=void 0;u=c<h?-Math.pow(.05*c,2)+Math.pow(.05*h,2):0,0!==c&&(u/=c);var f=l*u,p=d*u;i[r.id].x-=f,i[r.id].y-=p,i[a.id].x+=f,i[a.id].y+=p}}}}]),t}(),gC=function(){function t(e,i,n){Yd(this,t),this.body=e,this.physicsBody=i,this.setOptions(n)}return Kd(t,[{key:"setOptions",value:function(t){this.options=t}},{key:"solve",value:function(){for(var t,e,i,n,o,r=this.physicsBody.physicsEdgeIndices,s=this.body.edges,a=0;a<r.length;a++)!0===(e=s[r[a]]).connected&&e.toId!==e.fromId&&void 0!==this.body.nodes[e.toId]&&void 0!==this.body.nodes[e.fromId]&&(void 0!==e.edgeType.via?(t=void 0===e.options.length?this.options.springLength:e.options.length,i=e.to,n=e.edgeType.via,o=e.from,this._calculateSpringForce(i,n,.5*t),this._calculateSpringForce(n,o,.5*t)):(t=void 0===e.options.length?1.5*this.options.springLength:e.options.length,this._calculateSpringForce(e.from,e.to,t)))}},{key:"_calculateSpringForce",value:function(t,e,i){var n=t.x-e.x,o=t.y-e.y,r=Math.max(Math.sqrt(n*n+o*o),.01),s=this.options.springConstant*(i-r)/r,a=n*s,h=o*s;void 0!==this.physicsBody.forces[t.id]&&(this.physicsBody.forces[t.id].x+=a,this.physicsBody.forces[t.id].y+=h),void 0!==this.physicsBody.forces[e.id]&&(this.physicsBody.forces[e.id].x-=a,this.physicsBody.forces[e.id].y-=h)}}]),t}(),yC=function(){function t(e,i,n){Yd(this,t),this.body=e,this.physicsBody=i,this.setOptions(n)}return Kd(t,[{key:"setOptions",value:function(t){this.options=t}},{key:"solve",value:function(){for(var t,e,i,n,o,r,s,a,h,l,d=this.body.edges,c=.5,u=this.physicsBody.physicsEdgeIndices,f=this.physicsBody.physicsNodeIndices,p=this.physicsBody.forces,v=0;v<f.length;v++){var g=f[v];p[g].springFx=0,p[g].springFy=0}for(var y=0;y<u.length;y++)!0===(e=d[u[y]]).connected&&(t=void 0===e.options.length?this.options.springLength:e.options.length,i=e.from.x-e.to.x,n=e.from.y-e.to.y,a=0===(a=Math.sqrt(i*i+n*n))?.01:a,o=i*(s=this.options.springConstant*(t-a)/a),r=n*s,e.to.level!=e.from.level?(void 0!==p[e.toId]&&(p[e.toId].springFx-=o,p[e.toId].springFy-=r),void 0!==p[e.fromId]&&(p[e.fromId].springFx+=o,p[e.fromId].springFy+=r)):(void 0!==p[e.toId]&&(p[e.toId].x-=c*o,p[e.toId].y-=c*r),void 0!==p[e.fromId]&&(p[e.fromId].x+=c*o,p[e.fromId].y+=c*r)));s=1;for(var m=0;m<f.length;m++){var b=f[m];h=Math.min(s,Math.max(-s,p[b].springFx)),l=Math.min(s,Math.max(-s,p[b].springFy)),p[b].x+=h,p[b].y+=l}for(var w=0,k=0,_=0;_<f.length;_++){var x=f[_];w+=p[x].x,k+=p[x].y}for(var E=w/f.length,O=k/f.length,C=0;C<f.length;C++){var S=f[C];p[S].x-=E,p[S].y-=O}}}]),t}(),mC=function(){function t(e,i,n){Yd(this,t),this.body=e,this.physicsBody=i,this.setOptions(n)}return Kd(t,[{key:"setOptions",value:function(t){this.options=t}},{key:"solve",value:function(){for(var t,e,i,n,o=this.body.nodes,r=this.physicsBody.physicsNodeIndices,s=this.physicsBody.forces,a=0;a<r.length;a++){t=-(n=o[r[a]]).x,e=-n.y,i=Math.sqrt(t*t+e*e),this._calculateForces(i,t,e,s,n)}}},{key:"_calculateForces",value:function(t,e,i,n,o){var r=0===t?0:this.options.centralGravity/t;n[o.id].x=e*r,n[o.id].y=i*r}}]),t}();function bC(t){var e=function(){if("undefined"==typeof Reflect||!Mk)return!1;if(Mk.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Mk(Boolean,[],(function(){}))),!0}catch(t){return!1}}();return function(){var i,n=Ak(t);if(e){var o=Ak(this).constructor;i=Mk(n,arguments,o)}else i=n.apply(this,arguments);return Nk(this,i)}}var wC=function(t){zk(i,t);var e=bC(i);function i(t,n,o){var r;return Yd(this,i),(r=e.call(this,t,n,o))._rng=jy("FORCE ATLAS 2 BASED REPULSION SOLVER"),r}return Kd(i,[{key:"_calculateForces",value:function(t,e,i,n,o){0===t&&(e=t=.1*this._rng()),this.overlapAvoidanceFactor<1&&n.shape.radius&&(t=Math.max(.1+this.overlapAvoidanceFactor*n.shape.radius,t-n.shape.radius));var r=n.edges.length+1,s=this.options.gravitationalConstant*o.mass*n.options.mass*r/Math.pow(t,2),a=e*s,h=i*s;this.physicsBody.forces[n.id].x+=a,this.physicsBody.forces[n.id].y+=h}}]),i}(fC);function kC(t){var e=function(){if("undefined"==typeof Reflect||!Mk)return!1;if(Mk.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Mk(Boolean,[],(function(){}))),!0}catch(t){return!1}}();return function(){var i,n=Ak(t);if(e){var o=Ak(this).constructor;i=Mk(n,arguments,o)}else i=n.apply(this,arguments);return Nk(this,i)}}var _C=function(t){zk(i,t);var e=kC(i);function i(t,n,o){return Yd(this,i),e.call(this,t,n,o)}return Kd(i,[{key:"_calculateForces",value:function(t,e,i,n,o){if(t>0){var r=o.edges.length+1,s=this.options.centralGravity*r*o.options.mass;n[o.id].x=e*s,n[o.id].y=i*s}}}]),i}(mC),xC=function(){function t(e){Yd(this,t),this.body=e,this.physicsBody={physicsNodeIndices:[],physicsEdgeIndices:[],forces:{},velocities:{}},this.physicsEnabled=!0,this.simulationInterval=1e3/60,this.requiresTimeout=!0,this.previousStates={},this.referenceState={},this.freezeCache={},this.renderTimer=void 0,this.adaptiveTimestep=!1,this.adaptiveTimestepEnabled=!1,this.adaptiveCounter=0,this.adaptiveInterval=3,this.stabilized=!1,this.startedStabilization=!1,this.stabilizationIterations=0,this.ready=!1,this.options={},this.defaultOptions={enabled:!0,barnesHut:{theta:.5,gravitationalConstant:-2e3,centralGravity:.3,springLength:95,springConstant:.04,damping:.09,avoidOverlap:0},forceAtlas2Based:{theta:.5,gravitationalConstant:-50,centralGravity:.01,springConstant:.08,springLength:100,damping:.4,avoidOverlap:0},repulsion:{centralGravity:.2,springLength:200,springConstant:.05,nodeDistance:100,damping:.09,avoidOverlap:0},hierarchicalRepulsion:{centralGravity:0,springLength:100,springConstant:.01,nodeDistance:120,damping:.09},maxVelocity:50,minVelocity:.75,solver:"barnesHut",stabilization:{enabled:!0,iterations:1e3,updateInterval:50,onlyDynamicEdges:!1,fit:!0},timestep:.5,adaptiveTimestep:!0,wind:{x:0,y:0}},un(this.options,this.defaultOptions),this.timestep=.5,this.layoutFailed=!1,this.bindEventListeners()}return Kd(t,[{key:"bindEventListeners",value:function(){var t=this;this.body.emitter.on("initPhysics",(function(){t.initPhysics()})),this.body.emitter.on("_layoutFailed",(function(){t.layoutFailed=!0})),this.body.emitter.on("resetPhysics",(function(){t.stopSimulation(),t.ready=!1})),this.body.emitter.on("disablePhysics",(function(){t.physicsEnabled=!1,t.stopSimulation()})),this.body.emitter.on("restorePhysics",(function(){t.setOptions(t.options),!0===t.ready&&t.startSimulation()})),this.body.emitter.on("startSimulation",(function(){!0===t.ready&&t.startSimulation()})),this.body.emitter.on("stopSimulation",(function(){t.stopSimulation()})),this.body.emitter.on("destroy",(function(){t.stopSimulation(!1),t.body.emitter.off()})),this.body.emitter.on("_dataChanged",(function(){t.updatePhysicsData()}))}},{key:"setOptions",value:function(t){if(void 0!==t)if(!1===t)this.options.enabled=!1,this.physicsEnabled=!1,this.stopSimulation();else if(!0===t)this.options.enabled=!0,this.physicsEnabled=!0,this.startSimulation();else{this.physicsEnabled=!0,im(["stabilization"],this.options,t),Sm(this.options,t,"stabilization"),void 0===t.enabled&&(this.options.enabled=!0),!1===this.options.enabled&&(this.physicsEnabled=!1,this.stopSimulation());var e=this.options.wind;e&&(("number"!=typeof e.x||ek(e.x))&&(e.x=0),("number"!=typeof e.y||ek(e.y))&&(e.y=0)),this.timestep=this.options.timestep}this.init()}},{key:"init",value:function(){var t;"forceAtlas2Based"===this.options.solver?(t=this.options.forceAtlas2Based,this.nodesSolver=new wC(this.body,this.physicsBody,t),this.edgesSolver=new gC(this.body,this.physicsBody,t),this.gravitySolver=new _C(this.body,this.physicsBody,t)):"repulsion"===this.options.solver?(t=this.options.repulsion,this.nodesSolver=new pC(this.body,this.physicsBody,t),this.edgesSolver=new gC(this.body,this.physicsBody,t),this.gravitySolver=new mC(this.body,this.physicsBody,t)):"hierarchicalRepulsion"===this.options.solver?(t=this.options.hierarchicalRepulsion,this.nodesSolver=new vC(this.body,this.physicsBody,t),this.edgesSolver=new yC(this.body,this.physicsBody,t),this.gravitySolver=new mC(this.body,this.physicsBody,t)):(t=this.options.barnesHut,this.nodesSolver=new fC(this.body,this.physicsBody,t),this.edgesSolver=new gC(this.body,this.physicsBody,t),this.gravitySolver=new mC(this.body,this.physicsBody,t)),this.modelOptions=t}},{key:"initPhysics",value:function(){!0===this.physicsEnabled&&!0===this.options.enabled?!0===this.options.stabilization.enabled?this.stabilize():(this.stabilized=!1,this.ready=!0,this.body.emitter.emit("fit",{},this.layoutFailed),this.startSimulation()):(this.ready=!0,this.body.emitter.emit("fit"))}},{key:"startSimulation",value:function(){var t;!0===this.physicsEnabled&&!0===this.options.enabled?(this.stabilized=!1,this.adaptiveTimestep=!1,this.body.emitter.emit("_resizeNodes"),void 0===this.viewFunction&&(this.viewFunction=zn(t=this.simulationStep).call(t,this),this.body.emitter.on("initRedraw",this.viewFunction),this.body.emitter.emit("_startRendering"))):this.body.emitter.emit("_redraw")}},{key:"stopSimulation",value:function(){var t=!(arguments.length>0&&void 0!==arguments[0])||arguments[0];this.stabilized=!0,!0===t&&this._emitStabilized(),void 0!==this.viewFunction&&(this.body.emitter.off("initRedraw",this.viewFunction),this.viewFunction=void 0,!0===t&&this.body.emitter.emit("_stopRendering"))}},{key:"simulationStep",value:function(){var t=Eu();this.physicsTick(),(Eu()-t<.4*this.simulationInterval||!0===this.runDoubleSpeed)&&!1===this.stabilized&&(this.physicsTick(),this.runDoubleSpeed=!0),!0===this.stabilized&&this.stopSimulation()}},{key:"_emitStabilized",value:function(){var t=this,e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:this.stabilizationIterations;(this.stabilizationIterations>1||!0===this.startedStabilization)&&Sv((function(){t.body.emitter.emit("stabilized",{iterations:e}),t.startedStabilization=!1,t.stabilizationIterations=0}),0)}},{key:"physicsStep",value:function(){this.gravitySolver.solve(),this.nodesSolver.solve(),this.edgesSolver.solve(),this.moveNodes()}},{key:"adjustTimeStep",value:function(){!0===this._evaluateStepQuality()?this.timestep=1.2*this.timestep:this.timestep/1.2<this.options.timestep?this.timestep=this.options.timestep:(this.adaptiveCounter=-1,this.timestep=Math.max(this.options.timestep,this.timestep/1.2))}},{key:"physicsTick",value:function(){if(this._startStabilizing(),!0!==this.stabilized){if(!0===this.adaptiveTimestep&&!0===this.adaptiveTimestepEnabled)this.adaptiveCounter%this.adaptiveInterval==0?(this.timestep=2*this.timestep,this.physicsStep(),this.revert(),this.timestep=.5*this.timestep,this.physicsStep(),this.physicsStep(),this.adjustTimeStep()):this.physicsStep(),this.adaptiveCounter+=1;else this.timestep=this.options.timestep,this.physicsStep();!0===this.stabilized&&this.revert(),this.stabilizationIterations++}}},{key:"updatePhysicsData",value:function(){this.physicsBody.forces={},this.physicsBody.physicsNodeIndices=[],this.physicsBody.physicsEdgeIndices=[];var t=this.body.nodes,e=this.body.edges;for(var i in t)Object.prototype.hasOwnProperty.call(t,i)&&!0===t[i].options.physics&&this.physicsBody.physicsNodeIndices.push(t[i].id);for(var n in e)Object.prototype.hasOwnProperty.call(e,n)&&!0===e[n].options.physics&&this.physicsBody.physicsEdgeIndices.push(e[n].id);for(var o=0;o<this.physicsBody.physicsNodeIndices.length;o++){var r=this.physicsBody.physicsNodeIndices[o];this.physicsBody.forces[r]={x:0,y:0},void 0===this.physicsBody.velocities[r]&&(this.physicsBody.velocities[r]={x:0,y:0})}for(var s in this.physicsBody.velocities)void 0===t[s]&&delete this.physicsBody.velocities[s]}},{key:"revert",value:function(){var t=bu(this.previousStates),e=this.body.nodes,i=this.physicsBody.velocities;this.referenceState={};for(var n=0;n<t.length;n++){var o=t[n];void 0!==e[o]?!0===e[o].options.physics&&(this.referenceState[o]={positions:{x:e[o].x,y:e[o].y}},i[o].x=this.previousStates[o].vx,i[o].y=this.previousStates[o].vy,e[o].x=this.previousStates[o].x,e[o].y=this.previousStates[o].y):delete this.previousStates[o]}}},{key:"_evaluateStepQuality",value:function(){var t,e,i=this.body.nodes,n=this.referenceState;for(var o in this.referenceState)if(Object.prototype.hasOwnProperty.call(this.referenceState,o)&&void 0!==i[o]&&(t=i[o].x-n[o].positions.x,e=i[o].y-n[o].positions.y,Math.sqrt(Math.pow(t,2)+Math.pow(e,2))>.3))return!1;return!0}},{key:"moveNodes",value:function(){for(var t=this.physicsBody.physicsNodeIndices,e=0,i=0,n=0;n<t.length;n++){var o=t[n],r=this._performStep(o);e=Math.max(e,r),i+=r}this.adaptiveTimestepEnabled=i/t.length<5,this.stabilized=e<this.options.minVelocity}},{key:"calculateComponentVelocity",value:function(t,e,i){t+=(e-this.modelOptions.damping*t)/i*this.timestep;var n=this.options.maxVelocity||1e9;return Math.abs(t)>n&&(t=t>0?n:-n),t}},{key:"_performStep",value:function(t){var e=this.body.nodes[t],i=this.physicsBody.forces[t];this.options.wind&&(i.x+=this.options.wind.x,i.y+=this.options.wind.y);var n=this.physicsBody.velocities[t];return this.previousStates[t]={x:e.x,y:e.y,vx:n.x,vy:n.y},!1===e.options.fixed.x?(n.x=this.calculateComponentVelocity(n.x,i.x,e.options.mass),e.x+=n.x*this.timestep):(i.x=0,n.x=0),!1===e.options.fixed.y?(n.y=this.calculateComponentVelocity(n.y,i.y,e.options.mass),e.y+=n.y*this.timestep):(i.y=0,n.y=0),Math.sqrt(Math.pow(n.x,2)+Math.pow(n.y,2))}},{key:"_freezeNodes",value:function(){var t=this.body.nodes;for(var e in t)if(Object.prototype.hasOwnProperty.call(t,e)&&t[e].x&&t[e].y){var i=t[e].options.fixed;this.freezeCache[e]={x:i.x,y:i.y},i.x=!0,i.y=!0}}},{key:"_restoreFrozenNodes",value:function(){var t=this.body.nodes;for(var e in t)Object.prototype.hasOwnProperty.call(t,e)&&void 0!==this.freezeCache[e]&&(t[e].options.fixed.x=this.freezeCache[e].x,t[e].options.fixed.y=this.freezeCache[e].y);this.freezeCache={}}},{key:"stabilize",value:function(){var t=this,e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:this.options.stabilization.iterations;"number"!=typeof e&&(e=this.options.stabilization.iterations,console.error("The stabilize method needs a numeric amount of iterations. Switching to default: ",e)),0!==this.physicsBody.physicsNodeIndices.length?(this.adaptiveTimestep=this.options.adaptiveTimestep,this.body.emitter.emit("_resizeNodes"),this.stopSimulation(),this.stabilized=!1,this.body.emitter.emit("_blockRedraw"),this.targetIterations=e,!0===this.options.stabilization.onlyDynamicEdges&&this._freezeNodes(),this.stabilizationIterations=0,Sv((function(){return t._stabilizationBatch()}),0)):this.ready=!0}},{key:"_startStabilizing",value:function(){return!0!==this.startedStabilization&&(this.body.emitter.emit("startStabilizing"),this.startedStabilization=!0,!0)}},{key:"_stabilizationBatch",value:function(){var t=this,e=function(){return!1===t.stabilized&&t.stabilizationIterations<t.targetIterations},i=function(){t.body.emitter.emit("stabilizationProgress",{iterations:t.stabilizationIterations,total:t.targetIterations})};this._startStabilizing()&&i();for(var n,o=0;e()&&o<this.options.stabilization.updateInterval;)this.physicsTick(),o++;(i(),e())?Sv(zn(n=this._stabilizationBatch).call(n,this),0):this._finalizeStabilization()}},{key:"_finalizeStabilization",value:function(){this.body.emitter.emit("_allowRedraw"),!0===this.options.stabilization.fit&&this.body.emitter.emit("fit"),!0===this.options.stabilization.onlyDynamicEdges&&this._restoreFrozenNodes(),this.body.emitter.emit("stabilizationIterationsDone"),this.body.emitter.emit("_requestRedraw"),!0===this.stabilized?this._emitStabilized():this.startSimulation(),this.ready=!0}},{key:"_drawForces",value:function(t){for(var e=0;e<this.physicsBody.physicsNodeIndices.length;e++){var i=this.physicsBody.physicsNodeIndices[e],n=this.body.nodes[i],o=this.physicsBody.forces[i],r=Math.sqrt(Math.pow(o.x,2)+Math.pow(o.x,2)),s=Math.min(Math.max(5,r),15),a=3*s,h=km((180-180*Math.min(1,Math.max(0,.03*r)))/360,1,1),l={x:n.x+20*o.x,y:n.y+20*o.y};t.lineWidth=s,t.strokeStyle=h,t.beginPath(),t.moveTo(n.x,n.y),t.lineTo(l.x,l.y),t.stroke();var d=Math.atan2(o.y,o.x);t.fillStyle=h,XO.draw(t,{type:"arrow",point:l,angle:d,length:a}),jv(t).call(t)}}}]),t}(),EC=function(){function t(){Yd(this,t)}return Kd(t,null,[{key:"getRange",value:function(t){var e,i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[],n=1e9,o=-1e9,r=1e9,s=-1e9;if(i.length>0)for(var a=0;a<i.length;a++)r>(e=t[i[a]]).shape.boundingBox.left&&(r=e.shape.boundingBox.left),s<e.shape.boundingBox.right&&(s=e.shape.boundingBox.right),n>e.shape.boundingBox.top&&(n=e.shape.boundingBox.top),o<e.shape.boundingBox.bottom&&(o=e.shape.boundingBox.bottom);return 1e9===r&&-1e9===s&&1e9===n&&-1e9===o&&(n=0,o=0,r=0,s=0),{minX:r,maxX:s,minY:n,maxY:o}}},{key:"getRangeCore",value:function(t){var e,i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[],n=1e9,o=-1e9,r=1e9,s=-1e9;if(i.length>0)for(var a=0;a<i.length;a++)r>(e=t[i[a]]).x&&(r=e.x),s<e.x&&(s=e.x),n>e.y&&(n=e.y),o<e.y&&(o=e.y);return 1e9===r&&-1e9===s&&1e9===n&&-1e9===o&&(n=0,o=0,r=0,s=0),{minX:r,maxX:s,minY:n,maxY:o}}},{key:"findCenter",value:function(t){return{x:.5*(t.maxX+t.minX),y:.5*(t.maxY+t.minY)}}},{key:"cloneOptions",value:function(t,e){var i={};return void 0===e||"node"===e?(nm(i,t.options,!0),i.x=t.x,i.y=t.y,i.amountOfConnections=t.edges.length):nm(i,t.options,!0),i}}]),t}();function OC(t){var e=function(){if("undefined"==typeof Reflect||!Mk)return!1;if(Mk.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Mk(Boolean,[],(function(){}))),!0}catch(t){return!1}}();return function(){var i,n=Ak(t);if(e){var o=Ak(this).constructor;i=Mk(n,arguments,o)}else i=n.apply(this,arguments);return Nk(this,i)}}var CC=function(t){zk(i,t);var e=OC(i);function i(t,n,o,r,s,a){var h;return Yd(this,i),(h=e.call(this,t,n,o,r,s,a)).isCluster=!0,h.containedNodes={},h.containedEdges={},h}return Kd(i,[{key:"_openChildCluster",value:function(t){var e=this,i=this.body.nodes[t];if(void 0===this.containedNodes[t])throw new Error("node with id: "+t+" not in current cluster");if(!i.isCluster)throw new Error("node with id: "+t+" is not a cluster");delete this.containedNodes[t],hm(i.edges,(function(t){delete e.containedEdges[t.id]})),hm(i.containedNodes,(function(t,i){e.containedNodes[i]=t})),i.containedNodes={},hm(i.containedEdges,(function(t,i){e.containedEdges[i]=t})),i.containedEdges={},hm(i.edges,(function(t){hm(e.edges,(function(i){var n,o,r=Fp(n=i.clusteringEdgeReplacingIds).call(n,t.id);-1!==r&&(hm(t.clusteringEdgeReplacingIds,(function(t){i.clusteringEdgeReplacingIds.push(t),e.body.edges[t].edgeReplacedById=i.id})),ff(o=i.clusteringEdgeReplacingIds).call(o,r,1))}))})),i.edges=[]}}]),i}(fO),SC=function(){function t(e){var i=this;Yd(this,t),this.body=e,this.clusteredNodes={},this.clusteredEdges={},this.options={},this.defaultOptions={},un(this.options,this.defaultOptions),this.body.emitter.on("_resetData",(function(){i.clusteredNodes={},i.clusteredEdges={}}))}return Kd(t,[{key:"clusterByHubsize",value:function(t,e){void 0===t?t=this._getHubSize():"object"===Qc(t)&&(e=this._checkOptions(t),t=this._getHubSize());for(var i=[],n=0;n<this.body.nodeIndices.length;n++){var o=this.body.nodes[this.body.nodeIndices[n]];o.edges.length>=t&&i.push(o.id)}for(var r=0;r<i.length;r++)this.clusterByConnection(i[r],e,!0);this.body.emitter.emit("_dataChanged")}},{key:"cluster",value:function(){var t=this,e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},i=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];if(void 0===e.joinCondition)throw new Error("Cannot call clusterByNodeData without a joinCondition function in the options.");e=this._checkOptions(e);var n={},o={};hm(this.body.nodes,(function(i,r){i.options&&!0===e.joinCondition(i.options)&&(n[r]=i,hm(i.edges,(function(e){void 0===t.clusteredEdges[e.id]&&(o[e.id]=e)})))})),this._cluster(n,o,e,i)}},{key:"clusterByEdgeCount",value:function(t,e){var i=this,n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];e=this._checkOptions(e);for(var o,r,s,a=[],h={},l=function(n){var l={},d={},c=i.body.nodeIndices[n],u=i.body.nodes[c];if(void 0===h[c]){s=0,r=[];for(var f=0;f<u.edges.length;f++)o=u.edges[f],void 0===i.clusteredEdges[o.id]&&(o.toId!==o.fromId&&s++,r.push(o));if(s===t){for(var p=function(t){if(void 0===e.joinCondition||null===e.joinCondition)return!0;var i=EC.cloneOptions(t);return e.joinCondition(i)},v=!0,g=0;g<r.length;g++){o=r[g];var y=i._getConnectedId(o,c);if(!p(u)){v=!1;break}d[o.id]=o,l[c]=u,l[y]=i.body.nodes[y],h[c]=!0}if(bu(l).length>0&&bu(d).length>0&&!0===v){var m=function(){for(var t=0;t<a.length;++t)for(var e in l)if(void 0!==a[t].nodes[e])return a[t]}();if(void 0!==m){for(var b in l)void 0===m.nodes[b]&&(m.nodes[b]=l[b]);for(var w in d)void 0===m.edges[w]&&(m.edges[w]=d[w])}else a.push({nodes:l,edges:d})}}}},d=0;d<this.body.nodeIndices.length;d++)l(d);for(var c=0;c<a.length;c++)this._cluster(a[c].nodes,a[c].edges,e,!1);!0===n&&this.body.emitter.emit("_dataChanged")}},{key:"clusterOutliers",value:function(t){var e=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];this.clusterByEdgeCount(1,t,e)}},{key:"clusterBridges",value:function(t){var e=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];this.clusterByEdgeCount(2,t,e)}},{key:"clusterByConnection",value:function(t,e){var i,n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];if(void 0===t)throw new Error("No nodeId supplied to clusterByConnection!");if(void 0===this.body.nodes[t])throw new Error("The nodeId given to clusterByConnection does not exist!");var o=this.body.nodes[t];void 0===(e=this._checkOptions(e,o)).clusterNodeProperties.x&&(e.clusterNodeProperties.x=o.x),void 0===e.clusterNodeProperties.y&&(e.clusterNodeProperties.y=o.y),void 0===e.clusterNodeProperties.fixed&&(e.clusterNodeProperties.fixed={},e.clusterNodeProperties.fixed.x=o.options.fixed.x,e.clusterNodeProperties.fixed.y=o.options.fixed.y);var r={},s={},a=o.id,h=EC.cloneOptions(o);r[a]=o;for(var l=0;l<o.edges.length;l++){var d=o.edges[l];if(void 0===this.clusteredEdges[d.id]){var c=this._getConnectedId(d,a);if(void 0===this.clusteredNodes[c])if(c!==a)if(void 0===e.joinCondition)s[d.id]=d,r[c]=this.body.nodes[c];else{var u=EC.cloneOptions(this.body.nodes[c]);!0===e.joinCondition(h,u)&&(s[d.id]=d,r[c]=this.body.nodes[c])}else s[d.id]=d}}var f=gu(i=bu(r)).call(i,(function(t){return r[t].id}));for(var p in r)if(Object.prototype.hasOwnProperty.call(r,p))for(var v=r[p],g=0;g<v.edges.length;g++){var y=v.edges[g];Fp(f).call(f,this._getConnectedId(y,v.id))>-1&&(s[y.id]=y)}this._cluster(r,s,e,n)}},{key:"_createClusterEdges",value:function(t,e,i,n){for(var o,r,s,a,h,l,d=bu(t),c=[],u=0;u<d.length;u++){s=t[r=d[u]];for(var f=0;f<s.edges.length;f++)o=s.edges[f],void 0===this.clusteredEdges[o.id]&&(o.toId==o.fromId?e[o.id]=o:o.toId==r?(a=i.id,l=h=o.fromId):(a=o.toId,h=i.id,l=a),void 0===t[l]&&c.push({edge:o,fromId:h,toId:a}))}for(var p=[],v=function(t){for(var e=0;e<p.length;e++){var i=p[e],n=t.fromId===i.fromId&&t.toId===i.toId,o=t.fromId===i.toId&&t.toId===i.fromId;if(n||o)return i}return null},g=0;g<c.length;g++){var y=c[g],m=y.edge,b=v(y);null===b?(b=this._createClusteredEdge(y.fromId,y.toId,m,n),p.push(b)):b.clusteringEdgeReplacingIds.push(m.id),this.body.edges[m.id].edgeReplacedById=b.id,this._backupEdgeOptions(m),m.setOptions({physics:!1})}}},{key:"_checkOptions",value:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return void 0===t.clusterEdgeProperties&&(t.clusterEdgeProperties={}),void 0===t.clusterNodeProperties&&(t.clusterNodeProperties={}),t}},{key:"_cluster",value:function(t,e,i){var n=!(arguments.length>3&&void 0!==arguments[3])||arguments[3],o=[];for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&void 0!==this.clusteredNodes[r]&&o.push(r);for(var s=0;s<o.length;++s)delete t[o[s]];if(0!=bu(t).length&&(1!=bu(t).length||1==i.clusterNodeProperties.allowSingleNodeCluster)){var a=nm({},i.clusterNodeProperties);if(void 0!==i.processProperties){var h=[];for(var l in t)if(Object.prototype.hasOwnProperty.call(t,l)){var d=EC.cloneOptions(t[l]);h.push(d)}var c=[];for(var u in e)if(Object.prototype.hasOwnProperty.call(e,u)&&"clusterEdge:"!==u.substr(0,12)){var f=EC.cloneOptions(e[u],"edge");c.push(f)}if(!(a=i.processProperties(a,h,c)))throw new Error("The processProperties function does not return properties!")}void 0===a.id&&(a.id="cluster:"+Ax());var p=a.id;void 0===a.label&&(a.label="cluster");var v=void 0;void 0===a.x&&(v=this._getClusterPosition(t),a.x=v.x),void 0===a.y&&(void 0===v&&(v=this._getClusterPosition(t)),a.y=v.y),a.id=p;var g=this.body.functions.createNode(a,CC);g.containedNodes=t,g.containedEdges=e,g.clusterEdgeProperties=i.clusterEdgeProperties,this.body.nodes[a.id]=g,this._clusterEdges(t,e,a,i.clusterEdgeProperties),a.id=void 0,!0===n&&this.body.emitter.emit("_dataChanged")}}},{key:"_backupEdgeOptions",value:function(t){void 0===this.clusteredEdges[t.id]&&(this.clusteredEdges[t.id]={physics:t.options.physics})}},{key:"_restoreEdge",value:function(t){var e=this.clusteredEdges[t.id];void 0!==e&&(t.setOptions({physics:e.physics}),delete this.clusteredEdges[t.id])}},{key:"isCluster",value:function(t){return void 0!==this.body.nodes[t]?!0===this.body.nodes[t].isCluster:(console.error("Node does not exist."),!1)}},{key:"_getClusterPosition",value:function(t){for(var e,i=bu(t),n=t[i[0]].x,o=t[i[0]].x,r=t[i[0]].y,s=t[i[0]].y,a=1;a<i.length;a++)n=(e=t[i[a]]).x<n?e.x:n,o=e.x>o?e.x:o,r=e.y<r?e.y:r,s=e.y>s?e.y:s;return{x:.5*(n+o),y:.5*(r+s)}}},{key:"openCluster",value:function(t,e){var i=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];if(void 0===t)throw new Error("No clusterNodeId supplied to openCluster.");var n=this.body.nodes[t];if(void 0===n)throw new Error("The clusterNodeId supplied to openCluster does not exist.");if(!0!==n.isCluster||void 0===n.containedNodes||void 0===n.containedEdges)throw new Error("The node:"+t+" is not a valid cluster.");var o=this.findNode(t),r=Fp(o).call(o,t)-1;if(r>=0){var s=o[r],a=this.body.nodes[s];return a._openChildCluster(t),delete this.body.nodes[t],void(!0===i&&this.body.emitter.emit("_dataChanged"))}var h=n.containedNodes,l=n.containedEdges;if(void 0!==e&&void 0!==e.releaseFunction&&"function"==typeof e.releaseFunction){var d={},c={x:n.x,y:n.y};for(var u in h)if(Object.prototype.hasOwnProperty.call(h,u)){var f=this.body.nodes[u];d[u]={x:f.x,y:f.y}}var p=e.releaseFunction(c,d);for(var v in h)if(Object.prototype.hasOwnProperty.call(h,v)){var g=this.body.nodes[v];void 0!==p[v]&&(g.x=void 0===p[v].x?n.x:p[v].x,g.y=void 0===p[v].y?n.y:p[v].y)}}else hm(h,(function(t){!1===t.options.fixed.x&&(t.x=n.x),!1===t.options.fixed.y&&(t.y=n.y)}));for(var y in h)if(Object.prototype.hasOwnProperty.call(h,y)){var m=this.body.nodes[y];m.vx=n.vx,m.vy=n.vy,m.setOptions({physics:!0}),delete this.clusteredNodes[y]}for(var b=[],w=0;w<n.edges.length;w++)b.push(n.edges[w]);for(var k=0;k<b.length;k++){for(var _=b[k],x=this._getConnectedId(_,t),E=this.clusteredNodes[x],O=0;O<_.clusteringEdgeReplacingIds.length;O++){var C=_.clusteringEdgeReplacingIds[O],S=this.body.edges[C];if(void 0!==S)if(void 0!==E){var T=this.body.nodes[E.clusterId];T.containedEdges[S.id]=S,delete l[S.id];var M=S.fromId,P=S.toId;S.toId==x?P=E.clusterId:M=E.clusterId,this._createClusteredEdge(M,P,S,T.clusterEdgeProperties,{hidden:!1,physics:!0})}else this._restoreEdge(S)}_.remove()}for(var D in l)Object.prototype.hasOwnProperty.call(l,D)&&this._restoreEdge(l[D]);delete this.body.nodes[t],!0===i&&this.body.emitter.emit("_dataChanged")}},{key:"getNodesInCluster",value:function(t){var e=[];if(!0===this.isCluster(t)){var i=this.body.nodes[t].containedNodes;for(var n in i)Object.prototype.hasOwnProperty.call(i,n)&&e.push(this.body.nodes[n].id)}return e}},{key:"findNode",value:function(t){for(var e,i=[],n=0;void 0!==this.clusteredNodes[t]&&n<100;){if(void 0===(e=this.body.nodes[t]))return[];i.push(e.id),t=this.clusteredNodes[t].clusterId,n++}return void 0===(e=this.body.nodes[t])?[]:(i.push(e.id),Yu(i).call(i),i)}},{key:"updateClusteredNode",value:function(t,e){if(void 0===t)throw new Error("No clusteredNodeId supplied to updateClusteredNode.");if(void 0===e)throw new Error("No newOptions supplied to updateClusteredNode.");if(void 0===this.body.nodes[t])throw new Error("The clusteredNodeId supplied to updateClusteredNode does not exist.");this.body.nodes[t].setOptions(e),this.body.emitter.emit("_dataChanged")}},{key:"updateEdge",value:function(t,e){if(void 0===t)throw new Error("No startEdgeId supplied to updateEdge.");if(void 0===e)throw new Error("No newOptions supplied to updateEdge.");if(void 0===this.body.edges[t])throw new Error("The startEdgeId supplied to updateEdge does not exist.");for(var i=this.getClusteredEdges(t),n=0;n<i.length;n++){this.body.edges[i[n]].setOptions(e)}this.body.emitter.emit("_dataChanged")}},{key:"getClusteredEdges",value:function(t){for(var e=[],i=0;void 0!==t&&void 0!==this.body.edges[t]&&i<100;)e.push(this.body.edges[t].id),t=this.body.edges[t].edgeReplacedById,i++;return Yu(e).call(e),e}},{key:"getBaseEdge",value:function(t){return this.getBaseEdges(t)[0]}},{key:"getBaseEdges",value:function(t){for(var e=[t],i=[],n=[],o=0;e.length>0&&o<100;){var r=e.pop();if(void 0!==r){var s=this.body.edges[r];if(void 0!==s){o++;var a=s.clusteringEdgeReplacingIds;if(void 0===a)n.push(r);else for(var h=0;h<a.length;++h){var l=a[h];-1===Fp(e).call(e,a)&&-1===Fp(i).call(i,a)&&e.push(l)}i.push(r)}}}return n}},{key:"_getConnectedId",value:function(t,e){return t.toId!=e?t.toId:(t.fromId,t.fromId)}},{key:"_getHubSize",value:function(){for(var t=0,e=0,i=0,n=0,o=0;o<this.body.nodeIndices.length;o++){var r=this.body.nodes[this.body.nodeIndices[o]];r.edges.length>n&&(n=r.edges.length),t+=r.edges.length,e+=Math.pow(r.edges.length,2),i+=1}t/=i;var s=(e/=i)-Math.pow(t,2),a=Math.sqrt(s),h=Math.floor(t+2*a);return h>n&&(h=n),h}},{key:"_createClusteredEdge",value:function(t,e,i,n,o){var r=EC.cloneOptions(i,"edge");nm(r,n),r.from=t,r.to=e,r.id="clusterEdge:"+Ax(),void 0!==o&&nm(r,o);var s=this.body.functions.createEdge(r);return s.clusteringEdgeReplacingIds=[i.id],s.connect(),this.body.edges[s.id]=s,s}},{key:"_clusterEdges",value:function(t,e,i,n){if(e instanceof cC){var o=e,r={};r[o.id]=o,e=r}if(t instanceof fO){var s=t,a={};a[s.id]=s,t=a}if(null==i)throw new Error("_clusterEdges: parameter clusterNode required");for(var h in void 0===n&&(n=i.clusterEdgeProperties),this._createClusterEdges(t,e,i,n),e)if(Object.prototype.hasOwnProperty.call(e,h)&&void 0!==this.body.edges[h]){var l=this.body.edges[h];this._backupEdgeOptions(l),l.setOptions({physics:!1})}for(var d in t)Object.prototype.hasOwnProperty.call(t,d)&&(this.clusteredNodes[d]={clusterId:i.id,node:this.body.nodes[d]},this.body.nodes[d].setOptions({physics:!1}))}},{key:"_getClusterNodeForNode",value:function(t){if(void 0!==t){var e=this.clusteredNodes[t];if(void 0!==e){var i=e.clusterId;if(void 0!==i)return this.body.nodes[i]}}}},{key:"_filter",value:function(t,e){var i=[];return hm(t,(function(t){e(t)&&i.push(t)})),i}},{key:"_updateState",value:function(){var t,e=this,i=[],n={},o=function(t){hm(e.body.nodes,(function(e){!0===e.isCluster&&t(e)}))};for(t in this.clusteredNodes){if(Object.prototype.hasOwnProperty.call(this.clusteredNodes,t))void 0===this.body.nodes[t]&&i.push(t)}o((function(t){for(var e=0;e<i.length;e++)delete t.containedNodes[i[e]]}));for(var r=0;r<i.length;r++)delete this.clusteredNodes[i[r]];hm(this.clusteredEdges,(function(t){var i=e.body.edges[t];void 0!==i&&i.endPointsValid()||(n[t]=t)})),o((function(t){hm(t.containedEdges,(function(t,e){t.endPointsValid()||n[e]||(n[e]=e)}))})),hm(this.body.edges,(function(t,i){var o=!0,r=t.clusteringEdgeReplacingIds;if(void 0!==r){var s=0;hm(r,(function(t){var i=e.body.edges[t];void 0!==i&&i.endPointsValid()&&(s+=1)})),o=s>0}t.endPointsValid()&&o||(n[i]=i)})),o((function(t){hm(n,(function(i){delete t.containedEdges[i],hm(t.edges,(function(o,r){o.id!==i?o.clusteringEdgeReplacingIds=e._filter(o.clusteringEdgeReplacingIds,(function(t){return!n[t]})):t.edges[r]=null})),t.edges=e._filter(t.edges,(function(t){return null!==t}))}))})),hm(n,(function(t){delete e.clusteredEdges[t]})),hm(n,(function(t){delete e.body.edges[t]})),hm(bu(this.body.edges),(function(t){var i=e.body.edges[t],n=e._isClusteredNode(i.fromId)||e._isClusteredNode(i.toId);if(n!==e._isClusteredEdge(i.id))if(n){var o=e._getClusterNodeForNode(i.fromId);void 0!==o&&e._clusterEdges(e.body.nodes[i.fromId],i,o);var r=e._getClusterNodeForNode(i.toId);void 0!==r&&e._clusterEdges(e.body.nodes[i.toId],i,r)}else delete e._clusterEdges[t],e._restoreEdge(i)}));for(var s=!1,a=!0,h=function(){var t=[];o((function(e){var i=bu(e.containedNodes).length,n=!0===e.options.allowSingleNodeCluster;(n&&i<1||!n&&i<2)&&t.push(e.id)}));for(var i=0;i<t.length;++i)e.openCluster(t[i],{},!1);a=t.length>0,s=s||a};a;)h();s&&this._updateState()}},{key:"_isClusteredNode",value:function(t){return void 0!==this.clusteredNodes[t]}},{key:"_isClusteredEdge",value:function(t){return void 0!==this.clusteredEdges[t]}}]),t}();function TC(t,e){var i=void 0!==tu&&ih(t)||t["@@iterator"];if(!i){if(lu(t)||(i=function(t,e){var i;if(!t)return;if("string"==typeof t)return MC(t,e);var n=au(i=Object.prototype.toString.call(t)).call(i,8,-1);"Object"===n&&t.constructor&&(n=t.constructor.name);if("Map"===n||"Set"===n)return ja(t);if("Arguments"===n||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))return MC(t,e)}(t))||e&&t&&"number"==typeof t.length){i&&(t=i);var n=0,o=function(){};return{s:o,n:function(){return n>=t.length?{done:!0}:{done:!1,value:t[n++]}},e:function(t){throw t},f:o}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}var r,s=!0,a=!1;return{s:function(){i=i.call(t)},n:function(){var t=i.next();return s=t.done,t},e:function(t){a=!0,r=t},f:function(){try{s||null==i.return||i.return()}finally{if(a)throw r}}}}function MC(t,e){(null==e||e>t.length)&&(e=t.length);for(var i=0,n=new Array(e);i<e;i++)n[i]=t[i];return n}var PC=function(){function t(e,i){var n;Yd(this,t),void 0!==window&&(n=window.requestAnimationFrame||window.mozRequestAnimationFrame||window.webkitRequestAnimationFrame||window.msRequestAnimationFrame),window.requestAnimationFrame=void 0===n?function(t){t()}:n,this.body=e,this.canvas=i,this.redrawRequested=!1,this.renderTimer=void 0,this.requiresTimeout=!0,this.renderingActive=!1,this.renderRequests=0,this.allowRedraw=!0,this.dragging=!1,this.zooming=!1,this.options={},this.defaultOptions={hideEdgesOnDrag:!1,hideEdgesOnZoom:!1,hideNodesOnDrag:!1},un(this.options,this.defaultOptions),this._determineBrowserMethod(),this.bindEventListeners()}return Kd(t,[{key:"bindEventListeners",value:function(){var t,e=this;this.body.emitter.on("dragStart",(function(){e.dragging=!0})),this.body.emitter.on("dragEnd",(function(){e.dragging=!1})),this.body.emitter.on("zoom",(function(){e.zooming=!0,window.clearTimeout(e.zoomTimeoutId),e.zoomTimeoutId=Sv((function(){var t;e.zooming=!1,zn(t=e._requestRedraw).call(t,e)()}),250)})),this.body.emitter.on("_resizeNodes",(function(){e._resizeNodes()})),this.body.emitter.on("_redraw",(function(){!1===e.renderingActive&&e._redraw()})),this.body.emitter.on("_blockRedraw",(function(){e.allowRedraw=!1})),this.body.emitter.on("_allowRedraw",(function(){e.allowRedraw=!0,e.redrawRequested=!1})),this.body.emitter.on("_requestRedraw",zn(t=this._requestRedraw).call(t,this)),this.body.emitter.on("_startRendering",(function(){e.renderRequests+=1,e.renderingActive=!0,e._startRendering()})),this.body.emitter.on("_stopRendering",(function(){e.renderRequests-=1,e.renderingActive=e.renderRequests>0,e.renderTimer=void 0})),this.body.emitter.on("destroy",(function(){e.renderRequests=0,e.allowRedraw=!1,e.renderingActive=!1,!0===e.requiresTimeout?clearTimeout(e.renderTimer):window.cancelAnimationFrame(e.renderTimer),e.body.emitter.off()}))}},{key:"setOptions",value:function(t){if(void 0!==t){em(["hideEdgesOnDrag","hideEdgesOnZoom","hideNodesOnDrag"],this.options,t)}}},{key:"_requestNextFrame",value:function(t,e){if("undefined"!=typeof window){var i,n=window;return!0===this.requiresTimeout?i=Sv(t,e):n.requestAnimationFrame&&(i=n.requestAnimationFrame(t)),i}}},{key:"_startRendering",value:function(){var t;!0===this.renderingActive&&(void 0===this.renderTimer&&(this.renderTimer=this._requestNextFrame(zn(t=this._renderStep).call(t,this),this.simulationInterval)))}},{key:"_renderStep",value:function(){!0===this.renderingActive&&(this.renderTimer=void 0,!0===this.requiresTimeout&&this._startRendering(),this._redraw(),!1===this.requiresTimeout&&this._startRendering())}},{key:"redraw",value:function(){this.body.emitter.emit("setSize"),this._redraw()}},{key:"_requestRedraw",value:function(){var t=this;!0!==this.redrawRequested&&!1===this.renderingActive&&!0===this.allowRedraw&&(this.redrawRequested=!0,this._requestNextFrame((function(){t._redraw(!1)}),0))}},{key:"_redraw",value:function(){var t=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(!0===this.allowRedraw){this.body.emitter.emit("initRedraw"),this.redrawRequested=!1;var e={drawExternalLabels:null};0!==this.canvas.frame.canvas.width&&0!==this.canvas.frame.canvas.height||this.canvas.setSize(),this.canvas.setTransform();var i=this.canvas.getContext(),n=this.canvas.frame.canvas.clientWidth,o=this.canvas.frame.canvas.clientHeight;if(i.clearRect(0,0,n,o),0===this.canvas.frame.clientWidth)return;if(i.save(),i.translate(this.body.view.translation.x,this.body.view.translation.y),i.scale(this.body.view.scale,this.body.view.scale),i.beginPath(),this.body.emitter.emit("beforeDrawing",i),i.closePath(),!1===t&&(!1===this.dragging||!0===this.dragging&&!1===this.options.hideEdgesOnDrag)&&(!1===this.zooming||!0===this.zooming&&!1===this.options.hideEdgesOnZoom)&&this._drawEdges(i),!1===this.dragging||!0===this.dragging&&!1===this.options.hideNodesOnDrag){var r=this._drawNodes(i,t),s=r.drawExternalLabels;e.drawExternalLabels=s}!1===t&&(!1===this.dragging||!0===this.dragging&&!1===this.options.hideEdgesOnDrag)&&(!1===this.zooming||!0===this.zooming&&!1===this.options.hideEdgesOnZoom)&&this._drawArrows(i),null!=e.drawExternalLabels&&e.drawExternalLabels(),!1===t&&this._drawSelectionBox(i),i.beginPath(),this.body.emitter.emit("afterDrawing",i),i.closePath(),i.restore(),!0===t&&i.clearRect(0,0,n,o)}}},{key:"_resizeNodes",value:function(){this.canvas.setTransform();var t=this.canvas.getContext();t.save(),t.translate(this.body.view.translation.x,this.body.view.translation.y),t.scale(this.body.view.scale,this.body.view.scale);var e,i=this.body.nodes;for(var n in i)Object.prototype.hasOwnProperty.call(i,n)&&((e=i[n]).resize(t),e.updateBoundingBox(t,e.selected));t.restore()}},{key:"_drawNodes",value:function(t){for(var e,i,n=arguments.length>1&&void 0!==arguments[1]&&arguments[1],o=this.body.nodes,r=this.body.nodeIndices,s=[],a=[],h=20,l=this.canvas.DOMtoCanvas({x:-h,y:-h}),d=this.canvas.DOMtoCanvas({x:this.canvas.frame.canvas.clientWidth+h,y:this.canvas.frame.canvas.clientHeight+h}),c={top:l.y,left:l.x,bottom:d.y,right:d.x},u=[],f=0;f<r.length;f++)if((e=o[r[f]]).hover)a.push(r[f]);else if(e.isSelected())s.push(r[f]);else if(!0===n){var p=e.draw(t);null!=p.drawExternalLabel&&u.push(p.drawExternalLabel)}else if(!0===e.isBoundingBoxOverlappingWith(c)){var v=e.draw(t);null!=v.drawExternalLabel&&u.push(v.drawExternalLabel)}else e.updateBoundingBox(t,e.selected);var g=s.length,y=a.length;for(i=0;i<g;i++){var m=(e=o[s[i]]).draw(t);null!=m.drawExternalLabel&&u.push(m.drawExternalLabel)}for(i=0;i<y;i++){var b=(e=o[a[i]]).draw(t);null!=b.drawExternalLabel&&u.push(b.drawExternalLabel)}return{drawExternalLabels:function(){var t,e=TC(u);try{for(e.s();!(t=e.n()).done;){(0,t.value)()}}catch(t){e.e(t)}finally{e.f()}}}}},{key:"_drawEdges",value:function(t){for(var e=this.body.edges,i=this.body.edgeIndices,n=0;n<i.length;n++){var o=e[i[n]];!0===o.connected&&o.draw(t)}}},{key:"_drawArrows",value:function(t){for(var e=this.body.edges,i=this.body.edgeIndices,n=0;n<i.length;n++){var o=e[i[n]];!0===o.connected&&o.drawArrows(t)}}},{key:"_determineBrowserMethod",value:function(){if("undefined"!=typeof window){var t=navigator.userAgent.toLowerCase();this.requiresTimeout=!1,(-1!=Fp(t).call(t,"msie 9.0")||-1!=Fp(t).call(t,"safari")&&Fp(t).call(t,"chrome")<=-1)&&(this.requiresTimeout=!0)}else this.requiresTimeout=!0}},{key:"_drawSelectionBox",value:function(t){if(this.body.selectionBox.show){t.beginPath();var e=this.body.selectionBox.position.end.x-this.body.selectionBox.position.start.x,i=this.body.selectionBox.position.end.y-this.body.selectionBox.position.start.y;t.rect(this.body.selectionBox.position.start.x,this.body.selectionBox.position.start.y,e,i),t.fillStyle="rgba(151, 194, 252, 0.2)",t.fillRect(this.body.selectionBox.position.start.x,this.body.selectionBox.position.start.y,e,i),t.strokeStyle="rgba(151, 194, 252, 1)",t.stroke()}else t.closePath()}}]),t}(),DC=X.setInterval;function IC(t,e){e.inputHandler=function(t){t.isFirst&&e(t)},t.on("hammer.input",e.inputHandler)}function BC(t,e){return e.inputHandler=function(t){t.isFinal&&e(t)},t.on("hammer.input",e.inputHandler)}var zC=function(){function t(e){Yd(this,t),this.body=e,this.pixelRatio=1,this.cameraState={},this.initialized=!1,this.canvasViewCenter={},this._cleanupCallbacks=[],this.options={},this.defaultOptions={autoResize:!0,height:"100%",width:"100%"},un(this.options,this.defaultOptions),this.bindEventListeners()}return Kd(t,[{key:"bindEventListeners",value:function(){var t,e=this;this.body.emitter.once("resize",(function(t){0!==t.width&&(e.body.view.translation.x=.5*t.width),0!==t.height&&(e.body.view.translation.y=.5*t.height)})),this.body.emitter.on("setSize",zn(t=this.setSize).call(t,this)),this.body.emitter.on("destroy",(function(){e.hammerFrame.destroy(),e.hammer.destroy(),e._cleanUp()}))}},{key:"setOptions",value:function(t){var e=this;if(void 0!==t){em(["width","height","autoResize"],this.options,t)}if(this._cleanUp(),!0===this.options.autoResize){var i;if(window.ResizeObserver){var n=new ResizeObserver((function(){!0===e.setSize()&&e.body.emitter.emit("_requestRedraw")})),o=this.frame;n.observe(o),this._cleanupCallbacks.push((function(){n.unobserve(o)}))}else{var r=DC((function(){!0===e.setSize()&&e.body.emitter.emit("_requestRedraw")}),1e3);this._cleanupCallbacks.push((function(){clearInterval(r)}))}var s=zn(i=this._onResize).call(i,this);dm(window,"resize",s),this._cleanupCallbacks.push((function(){cm(window,"resize",s)}))}}},{key:"_cleanUp",value:function(){var t,e,i;Fu(t=Yu(e=ff(i=this._cleanupCallbacks).call(i,0)).call(e)).call(t,(function(t){try{t()}catch(t){console.error(t)}}))}},{key:"_onResize",value:function(){this.setSize(),this.body.emitter.emit("_redraw")}},{key:"_getCameraState",value:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:this.pixelRatio;!0===this.initialized&&(this.cameraState.previousWidth=this.frame.canvas.width/t,this.cameraState.previousHeight=this.frame.canvas.height/t,this.cameraState.scale=this.body.view.scale,this.cameraState.position=this.DOMtoCanvas({x:.5*this.frame.canvas.width/t,y:.5*this.frame.canvas.height/t}))}},{key:"_setCameraState",value:function(){if(void 0!==this.cameraState.scale&&0!==this.frame.canvas.clientWidth&&0!==this.frame.canvas.clientHeight&&0!==this.pixelRatio&&this.cameraState.previousWidth>0&&this.cameraState.previousHeight>0){var t=this.frame.canvas.width/this.pixelRatio/this.cameraState.previousWidth,e=this.frame.canvas.height/this.pixelRatio/this.cameraState.previousHeight,i=this.cameraState.scale;1!=t&&1!=e?i=.5*this.cameraState.scale*(t+e):1!=t?i=this.cameraState.scale*t:1!=e&&(i=this.cameraState.scale*e),this.body.view.scale=i;var n=this.DOMtoCanvas({x:.5*this.frame.canvas.clientWidth,y:.5*this.frame.canvas.clientHeight}),o={x:n.x-this.cameraState.position.x,y:n.y-this.cameraState.position.y};this.body.view.translation.x+=o.x*this.body.view.scale,this.body.view.translation.y+=o.y*this.body.view.scale}}},{key:"_prepareValue",value:function(t){if("number"==typeof t)return t+"px";if("string"==typeof t){if(-1!==Fp(t).call(t,"%")||-1!==Fp(t).call(t,"px"))return t;if(-1===Fp(t).call(t,"%"))return t+"px"}throw new Error("Could not use the value supplied for width or height:"+t)}},{key:"_create",value:function(){for(;this.body.container.hasChildNodes();)this.body.container.removeChild(this.body.container.firstChild);if(this.frame=document.createElement("div"),this.frame.className="vis-network",this.frame.style.position="relative",this.frame.style.overflow="hidden",this.frame.tabIndex=0,this.frame.canvas=document.createElement("canvas"),this.frame.canvas.style.position="relative",this.frame.appendChild(this.frame.canvas),this.frame.canvas.getContext)this._setPixelRatio(),this.setTransform();else{var t=document.createElement("DIV");t.style.color="red",t.style.fontWeight="bold",t.style.padding="10px",t.innerText="Error: your browser does not support HTML canvas",this.frame.canvas.appendChild(t)}this.body.container.appendChild(this.frame),this.body.view.scale=1,this.body.view.translation={x:.5*this.frame.canvas.clientWidth,y:.5*this.frame.canvas.clientHeight},this._bindHammer()}},{key:"_bindHammer",value:function(){var t=this;void 0!==this.hammer&&this.hammer.destroy(),this.drag={},this.pinch={},this.hammer=new Wm(this.frame.canvas),this.hammer.get("pinch").set({enable:!0}),this.hammer.get("pan").set({threshold:5,direction:Wm.DIRECTION_ALL}),IC(this.hammer,(function(e){t.body.eventListeners.onTouch(e)})),this.hammer.on("tap",(function(e){t.body.eventListeners.onTap(e)})),this.hammer.on("doubletap",(function(e){t.body.eventListeners.onDoubleTap(e)})),this.hammer.on("press",(function(e){t.body.eventListeners.onHold(e)})),this.hammer.on("panstart",(function(e){t.body.eventListeners.onDragStart(e)})),this.hammer.on("panmove",(function(e){t.body.eventListeners.onDrag(e)})),this.hammer.on("panend",(function(e){t.body.eventListeners.onDragEnd(e)})),this.hammer.on("pinch",(function(e){t.body.eventListeners.onPinch(e)})),this.frame.canvas.addEventListener("wheel",(function(e){t.body.eventListeners.onMouseWheel(e)})),this.frame.canvas.addEventListener("mousemove",(function(e){t.body.eventListeners.onMouseMove(e)})),this.frame.canvas.addEventListener("contextmenu",(function(e){t.body.eventListeners.onContext(e)})),this.hammerFrame=new Wm(this.frame),BC(this.hammerFrame,(function(e){t.body.eventListeners.onRelease(e)}))}},{key:"setSize",value:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:this.options.width,e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.options.height;t=this._prepareValue(t),e=this._prepareValue(e);var i=!1,n=this.frame.canvas.width,o=this.frame.canvas.height,r=this.pixelRatio;if(this._setPixelRatio(),t!=this.options.width||e!=this.options.height||this.frame.style.width!=t||this.frame.style.height!=e)this._getCameraState(r),this.frame.style.width=t,this.frame.style.height=e,this.frame.canvas.style.width="100%",this.frame.canvas.style.height="100%",this.frame.canvas.width=Math.round(this.frame.canvas.clientWidth*this.pixelRatio),this.frame.canvas.height=Math.round(this.frame.canvas.clientHeight*this.pixelRatio),this.options.width=t,this.options.height=e,this.canvasViewCenter={x:.5*this.frame.clientWidth,y:.5*this.frame.clientHeight},i=!0;else{var s=Math.round(this.frame.canvas.clientWidth*this.pixelRatio),a=Math.round(this.frame.canvas.clientHeight*this.pixelRatio);this.frame.canvas.width===s&&this.frame.canvas.height===a||this._getCameraState(r),this.frame.canvas.width!==s&&(this.frame.canvas.width=s,i=!0),this.frame.canvas.height!==a&&(this.frame.canvas.height=a,i=!0)}return!0===i&&(this.body.emitter.emit("resize",{width:Math.round(this.frame.canvas.width/this.pixelRatio),height:Math.round(this.frame.canvas.height/this.pixelRatio),oldWidth:Math.round(n/this.pixelRatio),oldHeight:Math.round(o/this.pixelRatio)}),this._setCameraState()),this.initialized=!0,i}},{key:"getContext",value:function(){return this.frame.canvas.getContext("2d")}},{key:"_determinePixelRatio",value:function(){var t=this.getContext();if(void 0===t)throw new Error("Could not get canvax context");var e=1;return"undefined"!=typeof window&&(e=window.devicePixelRatio||1),e/(t.webkitBackingStorePixelRatio||t.mozBackingStorePixelRatio||t.msBackingStorePixelRatio||t.oBackingStorePixelRatio||t.backingStorePixelRatio||1)}},{key:"_setPixelRatio",value:function(){this.pixelRatio=this._determinePixelRatio()}},{key:"setTransform",value:function(){var t=this.getContext();if(void 0===t)throw new Error("Could not get canvax context");t.setTransform(this.pixelRatio,0,0,this.pixelRatio,0,0)}},{key:"_XconvertDOMtoCanvas",value:function(t){return(t-this.body.view.translation.x)/this.body.view.scale}},{key:"_XconvertCanvasToDOM",value:function(t){return t*this.body.view.scale+this.body.view.translation.x}},{key:"_YconvertDOMtoCanvas",value:function(t){return(t-this.body.view.translation.y)/this.body.view.scale}},{key:"_YconvertCanvasToDOM",value:function(t){return t*this.body.view.scale+this.body.view.translation.y}},{key:"canvasToDOM",value:function(t){return{x:this._XconvertCanvasToDOM(t.x),y:this._YconvertCanvasToDOM(t.y)}}},{key:"DOMtoCanvas",value:function(t){return{x:this._XconvertDOMtoCanvas(t.x),y:this._YconvertDOMtoCanvas(t.y)}}}]),t}();function NC(t,e){var i=un({nodes:e,minZoomLevel:Number.MIN_VALUE,maxZoomLevel:1},null!=t?t:{});if(!lu(i.nodes))throw new TypeError("Nodes has to be an array of ids.");if(0===i.nodes.length&&(i.nodes=e),!("number"==typeof i.minZoomLevel&&i.minZoomLevel>0))throw new TypeError("Min zoom level has to be a number higher than zero.");if(!("number"==typeof i.maxZoomLevel&&i.minZoomLevel<=i.maxZoomLevel))throw new TypeError("Max zoom level has to be a number higher than min zoom level.");return i}var FC=function(){function t(e,i){var n,o,r=this;Yd(this,t),this.body=e,this.canvas=i,this.animationSpeed=1/this.renderRefreshRate,this.animationEasingFunction="easeInOutQuint",this.easingTime=0,this.sourceScale=0,this.targetScale=0,this.sourceTranslation=0,this.targetTranslation=0,this.lockedOnNodeId=void 0,this.lockedOnNodeOffset=void 0,this.touchTime=0,this.viewFunction=void 0,this.body.emitter.on("fit",zn(n=this.fit).call(n,this)),this.body.emitter.on("animationFinished",(function(){r.body.emitter.emit("_stopRendering")})),this.body.emitter.on("unlockNode",zn(o=this.releaseNode).call(o,this))}return Kd(t,[{key:"setOptions",value:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};this.options=t}},{key:"fit",value:function(t){var e=arguments.length>1&&void 0!==arguments[1]&&arguments[1];t=NC(t,this.body.nodeIndices);var i,n,o=this.canvas.frame.canvas.clientWidth,r=this.canvas.frame.canvas.clientHeight;if(0===o||0===r)n=1,i=EC.getRange(this.body.nodes,t.nodes);else if(!0===e){var s=0;for(var a in this.body.nodes)if(Object.prototype.hasOwnProperty.call(this.body.nodes,a)){var h=this.body.nodes[a];!0===h.predefinedPosition&&(s+=1)}if(s>.5*this.body.nodeIndices.length)return void this.fit(t,!1);i=EC.getRange(this.body.nodes,t.nodes);var l=this.body.nodeIndices.length;n=12.662/(l+7.4147)+.0964822;var d=Math.min(o/600,r/600);n*=d}else{this.body.emitter.emit("_resizeNodes"),i=EC.getRange(this.body.nodes,t.nodes);var c=1.1*Math.abs(i.maxX-i.minX),u=1.1*Math.abs(i.maxY-i.minY),f=o/c,p=r/u;n=f<=p?f:p}n>t.maxZoomLevel?n=t.maxZoomLevel:n<t.minZoomLevel&&(n=t.minZoomLevel);var v=EC.findCenter(i),g={position:v,scale:n,animation:t.animation};this.moveTo(g)}},{key:"focus",value:function(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(void 0!==this.body.nodes[t]){var i={x:this.body.nodes[t].x,y:this.body.nodes[t].y};e.position=i,e.lockedOnNode=t,this.moveTo(e)}else console.error("Node: "+t+" cannot be found.")}},{key:"moveTo",value:function(t){if(void 0!==t){if(null!=t.offset){if(null!=t.offset.x){if(t.offset.x=+t.offset.x,!ok(t.offset.x))throw new TypeError('The option "offset.x" has to be a finite number.')}else t.offset.x=0;if(null!=t.offset.y){if(t.offset.y=+t.offset.y,!ok(t.offset.y))throw new TypeError('The option "offset.y" has to be a finite number.')}else t.offset.x=0}else t.offset={x:0,y:0};if(null!=t.position){if(null!=t.position.x){if(t.position.x=+t.position.x,!ok(t.position.x))throw new TypeError('The option "position.x" has to be a finite number.')}else t.position.x=0;if(null!=t.position.y){if(t.position.y=+t.position.y,!ok(t.position.y))throw new TypeError('The option "position.y" has to be a finite number.')}else t.position.x=0}else t.position=this.getViewPosition();if(null!=t.scale){if(t.scale=+t.scale,!(t.scale>0))throw new TypeError('The option "scale" has to be a number greater than zero.')}else t.scale=this.body.view.scale;void 0===t.animation&&(t.animation={duration:0}),!1===t.animation&&(t.animation={duration:0}),!0===t.animation&&(t.animation={}),void 0===t.animation.duration&&(t.animation.duration=1e3),void 0===t.animation.easingFunction&&(t.animation.easingFunction="easeInOutQuad"),this.animateView(t)}else t={}}},{key:"animateView",value:function(t){if(void 0!==t){this.animationEasingFunction=t.animation.easingFunction,this.releaseNode(),!0===t.locked&&(this.lockedOnNodeId=t.lockedOnNode,this.lockedOnNodeOffset=t.offset),0!=this.easingTime&&this._transitionRedraw(!0),this.sourceScale=this.body.view.scale,this.sourceTranslation=this.body.view.translation,this.targetScale=t.scale,this.body.view.scale=this.targetScale;var e,i,n=this.canvas.DOMtoCanvas({x:.5*this.canvas.frame.canvas.clientWidth,y:.5*this.canvas.frame.canvas.clientHeight}),o=n.x-t.position.x,r=n.y-t.position.y;if(this.targetTranslation={x:this.sourceTranslation.x+o*this.targetScale+t.offset.x,y:this.sourceTranslation.y+r*this.targetScale+t.offset.y},0===t.animation.duration)if(null!=this.lockedOnNodeId)this.viewFunction=zn(e=this._lockedRedraw).call(e,this),this.body.emitter.on("initRedraw",this.viewFunction);else this.body.view.scale=this.targetScale,this.body.view.translation=this.targetTranslation,this.body.emitter.emit("_requestRedraw");else this.animationSpeed=1/(60*t.animation.duration*.001)||1/60,this.animationEasingFunction=t.animation.easingFunction,this.viewFunction=zn(i=this._transitionRedraw).call(i,this),this.body.emitter.on("initRedraw",this.viewFunction),this.body.emitter.emit("_startRendering")}}},{key:"_lockedRedraw",value:function(){var t=this.body.nodes[this.lockedOnNodeId].x,e=this.body.nodes[this.lockedOnNodeId].y,i=this.canvas.DOMtoCanvas({x:.5*this.canvas.frame.canvas.clientWidth,y:.5*this.canvas.frame.canvas.clientHeight}),n=i.x-t,o=i.y-e,r=this.body.view.translation,s={x:r.x+n*this.body.view.scale+this.lockedOnNodeOffset.x,y:r.y+o*this.body.view.scale+this.lockedOnNodeOffset.y};this.body.view.translation=s}},{key:"releaseNode",value:function(){void 0!==this.lockedOnNodeId&&void 0!==this.viewFunction&&(this.body.emitter.off("initRedraw",this.viewFunction),this.lockedOnNodeId=void 0,this.lockedOnNodeOffset=void 0)}},{key:"_transitionRedraw",value:function(){var t=arguments.length>0&&void 0!==arguments[0]&&arguments[0];this.easingTime+=this.animationSpeed,this.easingTime=!0===t?1:this.easingTime;var e=Tm[this.animationEasingFunction](this.easingTime);if(this.body.view.scale=this.sourceScale+(this.targetScale-this.sourceScale)*e,this.body.view.translation={x:this.sourceTranslation.x+(this.targetTranslation.x-this.sourceTranslation.x)*e,y:this.sourceTranslation.y+(this.targetTranslation.y-this.sourceTranslation.y)*e},this.easingTime>=1){var i;if(this.body.emitter.off("initRedraw",this.viewFunction),this.easingTime=0,null!=this.lockedOnNodeId)this.viewFunction=zn(i=this._lockedRedraw).call(i,this),this.body.emitter.on("initRedraw",this.viewFunction);this.body.emitter.emit("animationFinished")}}},{key:"getScale",value:function(){return this.body.view.scale}},{key:"getViewPosition",value:function(){return this.canvas.DOMtoCanvas({x:.5*this.canvas.frame.canvas.clientWidth,y:.5*this.canvas.frame.canvas.clientHeight})}}]),t}();function AC(t){var e,i=t&&t.preventDefault||!1,n=t&&t.container||window,o={},r={keydown:{},keyup:{}},s={};for(e=97;e<=122;e++)s[String.fromCharCode(e)]={code:e-97+65,shift:!1};for(e=65;e<=90;e++)s[String.fromCharCode(e)]={code:e,shift:!0};for(e=0;e<=9;e++)s[""+e]={code:48+e,shift:!1};for(e=1;e<=12;e++)s["F"+e]={code:111+e,shift:!1};for(e=0;e<=9;e++)s["num"+e]={code:96+e,shift:!1};s["num*"]={code:106,shift:!1},s["num+"]={code:107,shift:!1},s["num-"]={code:109,shift:!1},s["num/"]={code:111,shift:!1},s["num."]={code:110,shift:!1},s.left={code:37,shift:!1},s.up={code:38,shift:!1},s.right={code:39,shift:!1},s.down={code:40,shift:!1},s.space={code:32,shift:!1},s.enter={code:13,shift:!1},s.shift={code:16,shift:void 0},s.esc={code:27,shift:!1},s.backspace={code:8,shift:!1},s.tab={code:9,shift:!1},s.ctrl={code:17,shift:!1},s.alt={code:18,shift:!1},s.delete={code:46,shift:!1},s.pageup={code:33,shift:!1},s.pagedown={code:34,shift:!1},s["="]={code:187,shift:!1},s["-"]={code:189,shift:!1},s["]"]={code:221,shift:!1},s["["]={code:219,shift:!1};var a=function(t){l(t,"keydown")},h=function(t){l(t,"keyup")},l=function(t,e){if(void 0!==r[e][t.keyCode]){for(var n=r[e][t.keyCode],o=0;o<n.length;o++)(void 0===n[o].shift||1==n[o].shift&&1==t.shiftKey||0==n[o].shift&&0==t.shiftKey)&&n[o].fn(t);1==i&&t.preventDefault()}};return o.bind=function(t,e,i){if(void 0===i&&(i="keydown"),void 0===s[t])throw new Error("unsupported key: "+t);void 0===r[i][s[t].code]&&(r[i][s[t].code]=[]),r[i][s[t].code].push({fn:e,shift:s[t].shift})},o.bindAll=function(t,e){for(var i in void 0===e&&(e="keydown"),s)s.hasOwnProperty(i)&&o.bind(i,t,e)},o.getKey=function(t){for(var e in s)if(s.hasOwnProperty(e)){if(1==t.shiftKey&&1==s[e].shift&&t.keyCode==s[e].code)return e;if(0==t.shiftKey&&0==s[e].shift&&t.keyCode==s[e].code)return e;if(t.keyCode==s[e].code&&"shift"==e)return e}return"unknown key, currently not supported"},o.unbind=function(t,e,i){if(void 0===i&&(i="keydown"),void 0===s[t])throw new Error("unsupported key: "+t);if(void 0!==e){var n=[],o=r[i][s[t].code];if(void 0!==o)for(var a=0;a<o.length;a++)o[a].fn==e&&o[a].shift==s[t].shift||n.push(r[i][s[t].code][a]);r[i][s[t].code]=n}else r[i][s[t].code]=[]},o.reset=function(){r={keydown:{},keyup:{}}},o.destroy=function(){r={keydown:{},keyup:{}},n.removeEventListener("keydown",a,!0),n.removeEventListener("keyup",h,!0)},n.addEventListener("keydown",a,!0),n.addEventListener("keyup",h,!0),o}var jC=Object.freeze({__proto__:null,default:AC}),RC=function(){function t(e,i){var n=this;Yd(this,t),this.body=e,this.canvas=i,this.iconsCreated=!1,this.navigationHammers=[],this.boundFunctions={},this.touchTime=0,this.activated=!1,this.body.emitter.on("activate",(function(){n.activated=!0,n.configureKeyboardBindings()})),this.body.emitter.on("deactivate",(function(){n.activated=!1,n.configureKeyboardBindings()})),this.body.emitter.on("destroy",(function(){void 0!==n.keycharm&&n.keycharm.destroy()})),this.options={}}return Kd(t,[{key:"setOptions",value:function(t){void 0!==t&&(this.options=t,this.create())}},{key:"create",value:function(){!0===this.options.navigationButtons?!1===this.iconsCreated&&this.loadNavigationElements():!0===this.iconsCreated&&this.cleanNavigation(),this.configureKeyboardBindings()}},{key:"cleanNavigation",value:function(){if(0!=this.navigationHammers.length){for(var t=0;t<this.navigationHammers.length;t++)this.navigationHammers[t].destroy();this.navigationHammers=[]}this.navigationDOM&&this.navigationDOM.wrapper&&this.navigationDOM.wrapper.parentNode&&this.navigationDOM.wrapper.parentNode.removeChild(this.navigationDOM.wrapper),this.iconsCreated=!1}},{key:"loadNavigationElements",value:function(){var t=this;this.cleanNavigation(),this.navigationDOM={};var e=["up","down","left","right","zoomIn","zoomOut","zoomExtends"],i=["_moveUp","_moveDown","_moveLeft","_moveRight","_zoomIn","_zoomOut","_fit"];this.navigationDOM.wrapper=document.createElement("div"),this.navigationDOM.wrapper.className="vis-navigation",this.canvas.frame.appendChild(this.navigationDOM.wrapper);for(var n=0;n<e.length;n++){this.navigationDOM[e[n]]=document.createElement("div"),this.navigationDOM[e[n]].className="vis-button vis-"+e[n],this.navigationDOM.wrapper.appendChild(this.navigationDOM[e[n]]);var o,r,s=new Wm(this.navigationDOM[e[n]]);if("_fit"===i[n])IC(s,zn(o=this._fit).call(o,this));else IC(s,zn(r=this.bindToRedraw).call(r,this,i[n]));this.navigationHammers.push(s)}var a=new Wm(this.canvas.frame);BC(a,(function(){t._stopMovement()})),this.navigationHammers.push(a),this.iconsCreated=!0}},{key:"bindToRedraw",value:function(t){var e;void 0===this.boundFunctions[t]&&(this.boundFunctions[t]=zn(e=this[t]).call(e,this),this.body.emitter.on("initRedraw",this.boundFunctions[t]),this.body.emitter.emit("_startRendering"))}},{key:"unbindFromRedraw",value:function(t){void 0!==this.boundFunctions[t]&&(this.body.emitter.off("initRedraw",this.boundFunctions[t]),this.body.emitter.emit("_stopRendering"),delete this.boundFunctions[t])}},{key:"_fit",value:function(){(new Date).valueOf()-this.touchTime>700&&(this.body.emitter.emit("fit",{duration:700}),this.touchTime=(new Date).valueOf())}},{key:"_stopMovement",value:function(){for(var t in this.boundFunctions)Object.prototype.hasOwnProperty.call(this.boundFunctions,t)&&(this.body.emitter.off("initRedraw",this.boundFunctions[t]),this.body.emitter.emit("_stopRendering"));this.boundFunctions={}}},{key:"_moveUp",value:function(){this.body.view.translation.y+=this.options.keyboard.speed.y}},{key:"_moveDown",value:function(){this.body.view.translation.y-=this.options.keyboard.speed.y}},{key:"_moveLeft",value:function(){this.body.view.translation.x+=this.options.keyboard.speed.x}},{key:"_moveRight",value:function(){this.body.view.translation.x-=this.options.keyboard.speed.x}},{key:"_zoomIn",value:function(){var t=this.body.view.scale,e=this.body.view.scale*(1+this.options.keyboard.speed.zoom),i=this.body.view.translation,n=e/t,o=(1-n)*this.canvas.canvasViewCenter.x+i.x*n,r=(1-n)*this.canvas.canvasViewCenter.y+i.y*n;this.body.view.scale=e,this.body.view.translation={x:o,y:r},this.body.emitter.emit("zoom",{direction:"+",scale:this.body.view.scale,pointer:null})}},{key:"_zoomOut",value:function(){var t=this.body.view.scale,e=this.body.view.scale/(1+this.options.keyboard.speed.zoom),i=this.body.view.translation,n=e/t,o=(1-n)*this.canvas.canvasViewCenter.x+i.x*n,r=(1-n)*this.canvas.canvasViewCenter.y+i.y*n;this.body.view.scale=e,this.body.view.translation={x:o,y:r},this.body.emitter.emit("zoom",{direction:"-",scale:this.body.view.scale,pointer:null})}},{key:"configureKeyboardBindings",value:function(){var t,e,i,n,o,r,s,a,h,l,d,c,u,f,p,v,g,y,m,b,w,k,_,x,E=this;(void 0!==this.keycharm&&this.keycharm.destroy(),!0===this.options.keyboard.enabled)&&(!0===this.options.keyboard.bindToWindow?this.keycharm=AC({container:window,preventDefault:!0}):this.keycharm=AC({container:this.canvas.frame,preventDefault:!0}),this.keycharm.reset(),!0===this.activated&&(zn(t=this.keycharm).call(t,"up",(function(){E.bindToRedraw("_moveUp")}),"keydown"),zn(e=this.keycharm).call(e,"down",(function(){E.bindToRedraw("_moveDown")}),"keydown"),zn(i=this.keycharm).call(i,"left",(function(){E.bindToRedraw("_moveLeft")}),"keydown"),zn(n=this.keycharm).call(n,"right",(function(){E.bindToRedraw("_moveRight")}),"keydown"),zn(o=this.keycharm).call(o,"=",(function(){E.bindToRedraw("_zoomIn")}),"keydown"),zn(r=this.keycharm).call(r,"num+",(function(){E.bindToRedraw("_zoomIn")}),"keydown"),zn(s=this.keycharm).call(s,"num-",(function(){E.bindToRedraw("_zoomOut")}),"keydown"),zn(a=this.keycharm).call(a,"-",(function(){E.bindToRedraw("_zoomOut")}),"keydown"),zn(h=this.keycharm).call(h,"[",(function(){E.bindToRedraw("_zoomOut")}),"keydown"),zn(l=this.keycharm).call(l,"]",(function(){E.bindToRedraw("_zoomIn")}),"keydown"),zn(d=this.keycharm).call(d,"pageup",(function(){E.bindToRedraw("_zoomIn")}),"keydown"),zn(c=this.keycharm).call(c,"pagedown",(function(){E.bindToRedraw("_zoomOut")}),"keydown"),zn(u=this.keycharm).call(u,"up",(function(){E.unbindFromRedraw("_moveUp")}),"keyup"),zn(f=this.keycharm).call(f,"down",(function(){E.unbindFromRedraw("_moveDown")}),"keyup"),zn(p=this.keycharm).call(p,"left",(function(){E.unbindFromRedraw("_moveLeft")}),"keyup"),zn(v=this.keycharm).call(v,"right",(function(){E.unbindFromRedraw("_moveRight")}),"keyup"),zn(g=this.keycharm).call(g,"=",(function(){E.unbindFromRedraw("_zoomIn")}),"keyup"),zn(y=this.keycharm).call(y,"num+",(function(){E.unbindFromRedraw("_zoomIn")}),"keyup"),zn(m=this.keycharm).call(m,"num-",(function(){E.unbindFromRedraw("_zoomOut")}),"keyup"),zn(b=this.keycharm).call(b,"-",(function(){E.unbindFromRedraw("_zoomOut")}),"keyup"),zn(w=this.keycharm).call(w,"[",(function(){E.unbindFromRedraw("_zoomOut")}),"keyup"),zn(k=this.keycharm).call(k,"]",(function(){E.unbindFromRedraw("_zoomIn")}),"keyup"),zn(_=this.keycharm).call(_,"pageup",(function(){E.unbindFromRedraw("_zoomIn")}),"keyup"),zn(x=this.keycharm).call(x,"pagedown",(function(){E.unbindFromRedraw("_zoomOut")}),"keyup")))}}]),t}();function LC(t,e){var i=void 0!==tu&&ih(t)||t["@@iterator"];if(!i){if(lu(t)||(i=function(t,e){var i;if(!t)return;if("string"==typeof t)return HC(t,e);var n=au(i=Object.prototype.toString.call(t)).call(i,8,-1);"Object"===n&&t.constructor&&(n=t.constructor.name);if("Map"===n||"Set"===n)return ja(t);if("Arguments"===n||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))return HC(t,e)}(t))||e&&t&&"number"==typeof t.length){i&&(t=i);var n=0,o=function(){};return{s:o,n:function(){return n>=t.length?{done:!0}:{done:!1,value:t[n++]}},e:function(t){throw t},f:o}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}var r,s=!0,a=!1;return{s:function(){i=i.call(t)},n:function(){var t=i.next();return s=t.done,t},e:function(t){a=!0,r=t},f:function(){try{s||null==i.return||i.return()}finally{if(a)throw r}}}}function HC(t,e){(null==e||e>t.length)&&(e=t.length);for(var i=0,n=new Array(e);i<e;i++)n[i]=t[i];return n}var WC=function(){function t(e,i,n){var o,r,s,a,h,l,d,c,u,f,p,v,g;Yd(this,t),this.body=e,this.canvas=i,this.selectionHandler=n,this.navigationHandler=new RC(e,i),this.body.eventListeners.onTap=zn(o=this.onTap).call(o,this),this.body.eventListeners.onTouch=zn(r=this.onTouch).call(r,this),this.body.eventListeners.onDoubleTap=zn(s=this.onDoubleTap).call(s,this),this.body.eventListeners.onHold=zn(a=this.onHold).call(a,this),this.body.eventListeners.onDragStart=zn(h=this.onDragStart).call(h,this),this.body.eventListeners.onDrag=zn(l=this.onDrag).call(l,this),this.body.eventListeners.onDragEnd=zn(d=this.onDragEnd).call(d,this),this.body.eventListeners.onMouseWheel=zn(c=this.onMouseWheel).call(c,this),this.body.eventListeners.onPinch=zn(u=this.onPinch).call(u,this),this.body.eventListeners.onMouseMove=zn(f=this.onMouseMove).call(f,this),this.body.eventListeners.onRelease=zn(p=this.onRelease).call(p,this),this.body.eventListeners.onContext=zn(v=this.onContext).call(v,this),this.touchTime=0,this.drag={},this.pinch={},this.popup=void 0,this.popupObj=void 0,this.popupTimer=void 0,this.body.functions.getPointer=zn(g=this.getPointer).call(g,this),this.options={},this.defaultOptions={dragNodes:!0,dragView:!0,hover:!1,keyboard:{enabled:!1,speed:{x:10,y:10,zoom:.02},bindToWindow:!0,autoFocus:!0},navigationButtons:!1,tooltipDelay:300,zoomView:!0,zoomSpeed:1},un(this.options,this.defaultOptions),this.bindEventListeners()}return Kd(t,[{key:"bindEventListeners",value:function(){var t=this;this.body.emitter.on("destroy",(function(){clearTimeout(t.popupTimer),delete t.body.functions.getPointer}))}},{key:"setOptions",value:function(t){if(void 0!==t){im(["hideEdgesOnDrag","hideEdgesOnZoom","hideNodesOnDrag","keyboard","multiselect","selectable","selectConnectedEdges"],this.options,t),Sm(this.options,t,"keyboard"),t.tooltip&&(un(this.options.tooltip,t.tooltip),t.tooltip.color&&(this.options.tooltip.color=gm(t.tooltip.color)))}this.navigationHandler.setOptions(this.options)}},{key:"getPointer",value:function(t){return{x:t.x-sm(this.canvas.frame.canvas),y:t.y-am(this.canvas.frame.canvas)}}},{key:"onTouch",value:function(t){(new Date).valueOf()-this.touchTime>50&&(this.drag.pointer=this.getPointer(t.center),this.drag.pinched=!1,this.pinch.scale=this.body.view.scale,this.touchTime=(new Date).valueOf())}},{key:"onTap",value:function(t){var e=this.getPointer(t.center),i=this.selectionHandler.options.multiselect&&(t.changedPointers[0].ctrlKey||t.changedPointers[0].metaKey);this.checkSelectionChanges(e,i),this.selectionHandler.commitAndEmit(e,t),this.selectionHandler.generateClickEvent("click",t,e)}},{key:"onDoubleTap",value:function(t){var e=this.getPointer(t.center);this.selectionHandler.generateClickEvent("doubleClick",t,e)}},{key:"onHold",value:function(t){var e=this.getPointer(t.center),i=this.selectionHandler.options.multiselect;this.checkSelectionChanges(e,i),this.selectionHandler.commitAndEmit(e,t),this.selectionHandler.generateClickEvent("click",t,e),this.selectionHandler.generateClickEvent("hold",t,e)}},{key:"onRelease",value:function(t){if((new Date).valueOf()-this.touchTime>10){var e=this.getPointer(t.center);this.selectionHandler.generateClickEvent("release",t,e),this.touchTime=(new Date).valueOf()}}},{key:"onContext",value:function(t){var e=this.getPointer({x:t.clientX,y:t.clientY});this.selectionHandler.generateClickEvent("oncontext",t,e)}},{key:"checkSelectionChanges",value:function(t){var e=arguments.length>1&&void 0!==arguments[1]&&arguments[1];!0===e?this.selectionHandler.selectAdditionalOnPoint(t):this.selectionHandler.selectOnPoint(t)}},{key:"_determineDifference",value:function(t,e){var i=function(t,e){for(var i=[],n=0;n<t.length;n++){var o=t[n];-1===Fp(e).call(e,o)&&i.push(o)}return i};return{nodes:i(t.nodes,e.nodes),edges:i(t.edges,e.edges)}}},{key:"onDragStart",value:function(t){if(!this.drag.dragging){void 0===this.drag.pointer&&this.onTouch(t);var e=this.selectionHandler.getNodeAt(this.drag.pointer);if(this.drag.dragging=!0,this.drag.selection=[],this.drag.translation=un({},this.body.view.translation),this.drag.nodeId=void 0,t.srcEvent.shiftKey){this.body.selectionBox.show=!0;var i=this.getPointer(t.center);this.body.selectionBox.position.start={x:this.canvas._XconvertDOMtoCanvas(i.x),y:this.canvas._YconvertDOMtoCanvas(i.y)},this.body.selectionBox.position.end={x:this.canvas._XconvertDOMtoCanvas(i.x),y:this.canvas._YconvertDOMtoCanvas(i.y)}}if(void 0!==e&&!0===this.options.dragNodes){this.drag.nodeId=e.id,!1===e.isSelected()&&this.selectionHandler.setSelection({nodes:[e.id]}),this.selectionHandler.generateClickEvent("dragStart",t,this.drag.pointer);var n,o=LC(this.selectionHandler.getSelectedNodes());try{for(o.s();!(n=o.n()).done;){var r=n.value,s={id:r.id,node:r,x:r.x,y:r.y,xFixed:r.options.fixed.x,yFixed:r.options.fixed.y};r.options.fixed.x=!0,r.options.fixed.y=!0,this.drag.selection.push(s)}}catch(t){o.e(t)}finally{o.f()}}else this.selectionHandler.generateClickEvent("dragStart",t,this.drag.pointer,void 0,!0)}}},{key:"onDrag",value:function(t){var e=this;if(!0!==this.drag.pinched){this.body.emitter.emit("unlockNode");var i=this.getPointer(t.center),n=this.drag.selection;if(n&&n.length&&!0===this.options.dragNodes){this.selectionHandler.generateClickEvent("dragging",t,i);var o=i.x-this.drag.pointer.x,r=i.y-this.drag.pointer.y;Fu(n).call(n,(function(t){var i=t.node;!1===t.xFixed&&(i.x=e.canvas._XconvertDOMtoCanvas(e.canvas._XconvertCanvasToDOM(t.x)+o)),!1===t.yFixed&&(i.y=e.canvas._YconvertDOMtoCanvas(e.canvas._YconvertCanvasToDOM(t.y)+r))})),this.body.emitter.emit("startSimulation")}else{if(t.srcEvent.shiftKey){if(this.selectionHandler.generateClickEvent("dragging",t,i,void 0,!0),void 0===this.drag.pointer)return void this.onDragStart(t);this.body.selectionBox.position.end={x:this.canvas._XconvertDOMtoCanvas(i.x),y:this.canvas._YconvertDOMtoCanvas(i.y)},this.body.emitter.emit("_requestRedraw")}if(!0===this.options.dragView&&!t.srcEvent.shiftKey){if(this.selectionHandler.generateClickEvent("dragging",t,i,void 0,!0),void 0===this.drag.pointer)return void this.onDragStart(t);var s=i.x-this.drag.pointer.x,a=i.y-this.drag.pointer.y;this.body.view.translation={x:this.drag.translation.x+s,y:this.drag.translation.y+a},this.body.emitter.emit("_requestRedraw")}}}}},{key:"onDragEnd",value:function(t){var e=this;if(this.drag.dragging=!1,this.body.selectionBox.show){var i;this.body.selectionBox.show=!1;var n=this.body.selectionBox.position,o={minX:Math.min(n.start.x,n.end.x),minY:Math.min(n.start.y,n.end.y),maxX:Math.max(n.start.x,n.end.x),maxY:Math.max(n.start.y,n.end.y)},r=Xf(i=this.body.nodeIndices).call(i,(function(t){var i=e.body.nodes[t];return i.x>=o.minX&&i.x<=o.maxX&&i.y>=o.minY&&i.y<=o.maxY}));Fu(r).call(r,(function(t){return e.selectionHandler.selectObject(e.body.nodes[t])}));var s=this.getPointer(t.center);this.selectionHandler.commitAndEmit(s,t),this.selectionHandler.generateClickEvent("dragEnd",t,this.getPointer(t.center),void 0,!0),this.body.emitter.emit("_requestRedraw")}else{var a=this.drag.selection;a&&a.length?(Fu(a).call(a,(function(t){t.node.options.fixed.x=t.xFixed,t.node.options.fixed.y=t.yFixed})),this.selectionHandler.generateClickEvent("dragEnd",t,this.getPointer(t.center)),this.body.emitter.emit("startSimulation")):(this.selectionHandler.generateClickEvent("dragEnd",t,this.getPointer(t.center),void 0,!0),this.body.emitter.emit("_requestRedraw"))}}},{key:"onPinch",value:function(t){var e=this.getPointer(t.center);this.drag.pinched=!0,void 0===this.pinch.scale&&(this.pinch.scale=1);var i=this.pinch.scale*t.scale;this.zoom(i,e)}},{key:"zoom",value:function(t,e){if(!0===this.options.zoomView){var i=this.body.view.scale;t<1e-5&&(t=1e-5),t>10&&(t=10);var n=void 0;void 0!==this.drag&&!0===this.drag.dragging&&(n=this.canvas.DOMtoCanvas(this.drag.pointer));var o=this.body.view.translation,r=t/i,s=(1-r)*e.x+o.x*r,a=(1-r)*e.y+o.y*r;if(this.body.view.scale=t,this.body.view.translation={x:s,y:a},null!=n){var h=this.canvas.canvasToDOM(n);this.drag.pointer.x=h.x,this.drag.pointer.y=h.y}this.body.emitter.emit("_requestRedraw"),i<t?this.body.emitter.emit("zoom",{direction:"+",scale:this.body.view.scale,pointer:e}):this.body.emitter.emit("zoom",{direction:"-",scale:this.body.view.scale,pointer:e})}}},{key:"onMouseWheel",value:function(t){if(!0===this.options.zoomView){if(0!==t.deltaY){var e=this.body.view.scale;e*=1+(t.deltaY<0?1:-1)*(.1*this.options.zoomSpeed);var i=this.getPointer({x:t.clientX,y:t.clientY});this.zoom(e,i)}t.preventDefault()}}},{key:"onMouseMove",value:function(t){var e=this,i=this.getPointer({x:t.clientX,y:t.clientY}),n=!1;void 0!==this.popup&&(!1===this.popup.hidden&&this._checkHidePopup(i),!1===this.popup.hidden&&(n=!0,this.popup.setPosition(i.x+3,i.y-5),this.popup.show())),this.options.keyboard.autoFocus&&!1===this.options.keyboard.bindToWindow&&!0===this.options.keyboard.enabled&&this.canvas.frame.focus(),!1===n&&(void 0!==this.popupTimer&&(clearInterval(this.popupTimer),this.popupTimer=void 0),this.drag.dragging||(this.popupTimer=Sv((function(){return e._checkShowPopup(i)}),this.options.tooltipDelay))),!0===this.options.hover&&this.selectionHandler.hoverObject(t,i)}},{key:"_checkShowPopup",value:function(t){var e=this.canvas._XconvertDOMtoCanvas(t.x),i=this.canvas._YconvertDOMtoCanvas(t.y),n={left:e,top:i,right:e,bottom:i},o=void 0===this.popupObj?void 0:this.popupObj.id,r=!1,s="node";if(void 0===this.popupObj){for(var a,h=this.body.nodeIndices,l=this.body.nodes,d=[],c=0;c<h.length;c++)!0===(a=l[h[c]]).isOverlappingWith(n)&&(r=!0,void 0!==a.getTitle()&&d.push(h[c]));d.length>0&&(this.popupObj=l[d[d.length-1]],r=!0)}if(void 0===this.popupObj&&!1===r){for(var u,f=this.body.edgeIndices,p=this.body.edges,v=[],g=0;g<f.length;g++)!0===(u=p[f[g]]).isOverlappingWith(n)&&!0===u.connected&&void 0!==u.getTitle()&&v.push(f[g]);v.length>0&&(this.popupObj=p[v[v.length-1]],s="edge")}void 0!==this.popupObj?this.popupObj.id!==o&&(void 0===this.popup&&(this.popup=new qm(this.canvas.frame)),this.popup.popupTargetType=s,this.popup.popupTargetId=this.popupObj.id,this.popup.setPosition(t.x+3,t.y-5),this.popup.setText(this.popupObj.getTitle()),this.popup.show(),this.body.emitter.emit("showPopup",this.popupObj.id)):void 0!==this.popup&&(this.popup.hide(),this.body.emitter.emit("hidePopup"))}},{key:"_checkHidePopup",value:function(t){var e=this.selectionHandler._pointerToPositionObject(t),i=!1;if("node"===this.popup.popupTargetType){if(void 0!==this.body.nodes[this.popup.popupTargetId]&&!0===(i=this.body.nodes[this.popup.popupTargetId].isOverlappingWith(e))){var n=this.selectionHandler.getNodeAt(t);i=void 0!==n&&n.id===this.popup.popupTargetId}}else void 0===this.selectionHandler.getNodeAt(t)&&void 0!==this.body.edges[this.popup.popupTargetId]&&(i=this.body.edges[this.popup.popupTargetId].isOverlappingWith(e));!1===i&&(this.popupObj=void 0,this.popup.hide(),this.body.emitter.emit("hidePopup"))}}]),t}(),qC=g,VC=Nw,UC=Db.exports.getWeakData,YC=$e,XC=Y,GC=yw,KC=pw,$C=Wt,ZC=Vo.set,QC=Vo.getterFor,JC=Wh.find,tS=Wh.findIndex,eS=qC([].splice),iS=0,nS=function(t){return t.frozen||(t.frozen=new oS)},oS=function(){this.entries=[]},rS=function(t,e){return JC(t.entries,(function(t){return t[0]===e}))};oS.prototype={get:function(t){var e=rS(this,t);if(e)return e[1]},has:function(t){return!!rS(this,t)},set:function(t,e){var i=rS(this,t);i?i[1]=e:this.entries.push([t,e])},delete:function(t){var e=tS(this.entries,(function(e){return e[0]===t}));return~e&&eS(this.entries,e,1),!!~e}};var sS,aS={getConstructor:function(t,e,i,n){var o=t((function(t,o){GC(t,r),ZC(t,{type:e,id:iS++,frozen:void 0}),null!=o&&KC(o,t[n],{that:t,AS_ENTRIES:i})})),r=o.prototype,s=QC(e),a=function(t,e,i){var n=s(t),o=UC(YC(e),!0);return!0===o?nS(n).set(e,i):o[n.id]=i,t};return VC(r,{delete:function(t){var e=s(this);if(!XC(t))return!1;var i=UC(t);return!0===i?nS(e).delete(t):i&&$C(i,e.id)&&delete i[e.id]},has:function(t){var e=s(this);if(!XC(t))return!1;var i=UC(t);return!0===i?nS(e).has(t):i&&$C(i,e.id)}}),VC(r,i?{get:function(t){var e=s(this);if(XC(t)){var i=UC(t);return!0===i?nS(e).get(t):i?i[e.id]:void 0}},set:function(t,e){return a(this,t,e)}}:{add:function(t){return a(this,t,!0)}}),o}},hS=n,lS=g,dS=Nw,cS=Db.exports,uS=Bw,fS=aS,pS=Y,vS=jb,gS=Vo.enforce,yS=_o,mS=!hS.ActiveXObject&&"ActiveXObject"in hS,bS=function(t){return function(){return t(this,arguments.length?arguments[0]:void 0)}},wS=uS("WeakMap",bS,fS);if(yS&&mS){sS=fS.getConstructor(bS,"WeakMap",!0),cS.enable();var kS=wS.prototype,_S=lS(kS.delete),xS=lS(kS.has),ES=lS(kS.get),OS=lS(kS.set);dS(kS,{delete:function(t){if(pS(t)&&!vS(t)){var e=gS(this);return e.frozen||(e.frozen=new sS),_S(this,t)||e.frozen.delete(t)}return _S(this,t)},has:function(t){if(pS(t)&&!vS(t)){var e=gS(this);return e.frozen||(e.frozen=new sS),xS(this,t)||e.frozen.has(t)}return xS(this,t)},get:function(t){if(pS(t)&&!vS(t)){var e=gS(this);return e.frozen||(e.frozen=new sS),xS(this,t)?ES(this,t):e.frozen.get(t)}return ES(this,t)},set:function(t,e){if(pS(t)&&!vS(t)){var i=gS(this);i.frozen||(i.frozen=new sS),xS(this,t)?OS(this,t,e):i.frozen.set(t,e)}else OS(this,t,e);return this}})}var CS,SS,TS,MS,PS,DS=X.WeakMap;function IS(t,e,i,n){if("a"===i&&!n)throw new TypeError("Private accessor was defined without a getter");if("function"==typeof e?t!==e||!n:!e.has(t))throw new TypeError("Cannot read private member from an object whose class did not declare it");return"m"===i?n:"a"===i?n.call(t):n?n.value:e.get(t)}function BS(t,e,i,n,o){if("m"===n)throw new TypeError("Private method is not writable");if("a"===n&&!o)throw new TypeError("Private accessor was defined without a setter");if("function"==typeof e?t!==e||!o:!e.has(t))throw new TypeError("Cannot write private member to an object whose class did not declare it");return"a"===n?o.call(t,i):o?o.value=i:e.set(t,i),i}function zS(t,e){var i=void 0!==tu&&ih(t)||t["@@iterator"];if(!i){if(lu(t)||(i=function(t,e){var i;if(!t)return;if("string"==typeof t)return NS(t,e);var n=au(i=Object.prototype.toString.call(t)).call(i,8,-1);"Object"===n&&t.constructor&&(n=t.constructor.name);if("Map"===n||"Set"===n)return ja(t);if("Arguments"===n||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))return NS(t,e)}(t))||e&&t&&"number"==typeof t.length){i&&(t=i);var n=0,o=function(){};return{s:o,n:function(){return n>=t.length?{done:!0}:{done:!1,value:t[n++]}},e:function(t){throw t},f:o}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}var r,s=!0,a=!1;return{s:function(){i=i.call(t)},n:function(){var t=i.next();return s=t.done,t},e:function(t){a=!0,r=t},f:function(){try{s||null==i.return||i.return()}finally{if(a)throw r}}}}function NS(t,e){(null==e||e>t.length)&&(e=t.length);for(var i=0,n=new Array(e);i<e;i++)n[i]=t[i];return n}function FS(t,e){var i,n=new b_,o=zS(e);try{for(o.s();!(i=o.n()).done;){var r=i.value;t.has(r)||n.add(r)}}catch(t){o.e(t)}finally{o.f()}return n}var AS=function(){function t(){Yd(this,t),CS.set(this,new b_),SS.set(this,new b_)}return Kd(t,[{key:"size",get:function(){return IS(this,SS,"f").size}},{key:"add",value:function(){for(var t=arguments.length,e=new Array(t),i=0;i<t;i++)e[i]=arguments[i];for(var n=0,o=e;n<o.length;n++){var r=o[n];IS(this,SS,"f").add(r)}}},{key:"delete",value:function(){for(var t=arguments.length,e=new Array(t),i=0;i<t;i++)e[i]=arguments[i];for(var n=0,o=e;n<o.length;n++){var r=o[n];IS(this,SS,"f").delete(r)}}},{key:"clear",value:function(){IS(this,SS,"f").clear()}},{key:"getSelection",value:function(){return Jc(IS(this,SS,"f"))}},{key:"getChanges",value:function(){return{added:Jc(FS(IS(this,CS,"f"),IS(this,SS,"f"))),deleted:Jc(FS(IS(this,SS,"f"),IS(this,CS,"f"))),previous:Jc(new b_(IS(this,CS,"f"))),current:Jc(new b_(IS(this,SS,"f")))}}},{key:"commit",value:function(){var t=this.getChanges();BS(this,CS,IS(this,SS,"f"),"f"),BS(this,SS,new b_(IS(this,CS,"f")),"f");var e,i=zS(t.added);try{for(i.s();!(e=i.n()).done;){e.value.select()}}catch(t){i.e(t)}finally{i.f()}var n,o=zS(t.deleted);try{for(o.s();!(n=o.n()).done;){n.value.unselect()}}catch(t){o.e(t)}finally{o.f()}return t}}]),t}();CS=new DS,SS=new DS;var jS=function(){function t(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:function(){};Yd(this,t),TS.set(this,new AS),MS.set(this,new AS),PS.set(this,void 0),BS(this,PS,e,"f")}return Kd(t,[{key:"sizeNodes",get:function(){return IS(this,TS,"f").size}},{key:"sizeEdges",get:function(){return IS(this,MS,"f").size}},{key:"getNodes",value:function(){return IS(this,TS,"f").getSelection()}},{key:"getEdges",value:function(){return IS(this,MS,"f").getSelection()}},{key:"addNodes",value:function(){var t;(t=IS(this,TS,"f")).add.apply(t,arguments)}},{key:"addEdges",value:function(){var t;(t=IS(this,MS,"f")).add.apply(t,arguments)}},{key:"deleteNodes",value:function(t){IS(this,TS,"f").delete(t)}},{key:"deleteEdges",value:function(t){IS(this,MS,"f").delete(t)}},{key:"clear",value:function(){IS(this,TS,"f").clear(),IS(this,MS,"f").clear()}},{key:"commit",value:function(){for(var t,e,i={nodes:IS(this,TS,"f").commit(),edges:IS(this,MS,"f").commit()},n=arguments.length,o=new Array(n),r=0;r<n;r++)o[r]=arguments[r];return(t=IS(this,PS,"f")).call.apply(t,su(e=[this,i]).call(e,o)),i}}]),t}();function RS(t,e){var i=void 0!==tu&&ih(t)||t["@@iterator"];if(!i){if(lu(t)||(i=function(t,e){var i;if(!t)return;if("string"==typeof t)return LS(t,e);var n=au(i=Object.prototype.toString.call(t)).call(i,8,-1);"Object"===n&&t.constructor&&(n=t.constructor.name);if("Map"===n||"Set"===n)return ja(t);if("Arguments"===n||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))return LS(t,e)}(t))||e&&t&&"number"==typeof t.length){i&&(t=i);var n=0,o=function(){};return{s:o,n:function(){return n>=t.length?{done:!0}:{done:!1,value:t[n++]}},e:function(t){throw t},f:o}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}var r,s=!0,a=!1;return{s:function(){i=i.call(t)},n:function(){var t=i.next();return s=t.done,t},e:function(t){a=!0,r=t},f:function(){try{s||null==i.return||i.return()}finally{if(a)throw r}}}}function LS(t,e){(null==e||e>t.length)&&(e=t.length);for(var i=0,n=new Array(e);i<e;i++)n[i]=t[i];return n}TS=new DS,MS=new DS,PS=new DS;var HS=function(){function t(e,i){var n=this;Yd(this,t),this.body=e,this.canvas=i,this._selectionAccumulator=new jS,this.hoverObj={nodes:{},edges:{}},this.options={},this.defaultOptions={multiselect:!1,selectable:!0,selectConnectedEdges:!0,hoverConnectedEdges:!0},un(this.options,this.defaultOptions),this.body.emitter.on("_dataChanged",(function(){n.updateSelection()}))}return Kd(t,[{key:"setOptions",value:function(t){if(void 0!==t){em(["multiselect","hoverConnectedEdges","selectable","selectConnectedEdges"],this.options,t)}}},{key:"selectOnPoint",value:function(t){var e=!1;if(!0===this.options.selectable){var i=this.getNodeAt(t)||this.getEdgeAt(t);this.unselectAll(),void 0!==i&&(e=this.selectObject(i)),this.body.emitter.emit("_requestRedraw")}return e}},{key:"selectAdditionalOnPoint",value:function(t){var e=!1;if(!0===this.options.selectable){var i=this.getNodeAt(t)||this.getEdgeAt(t);void 0!==i&&(e=!0,!0===i.isSelected()?this.deselectObject(i):this.selectObject(i),this.body.emitter.emit("_requestRedraw"))}return e}},{key:"_initBaseEvent",value:function(t,e){var i={};return i.pointer={DOM:{x:e.x,y:e.y},canvas:this.canvas.DOMtoCanvas(e)},i.event=t,i}},{key:"generateClickEvent",value:function(t,e,i,n){var o=arguments.length>4&&void 0!==arguments[4]&&arguments[4],r=this._initBaseEvent(e,i);if(!0===o)r.nodes=[],r.edges=[];else{var s=this.getSelection();r.nodes=s.nodes,r.edges=s.edges}void 0!==n&&(r.previousSelection=n),"click"==t&&(r.items=this.getClickedItems(i)),void 0!==e.controlEdge&&(r.controlEdge=e.controlEdge),this.body.emitter.emit(t,r)}},{key:"selectObject",value:function(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.options.selectConnectedEdges;if(void 0!==t){if(t instanceof fO){var i;if(!0===e)(i=this._selectionAccumulator).addEdges.apply(i,Jc(t.edges));this._selectionAccumulator.addNodes(t)}else this._selectionAccumulator.addEdges(t);return!0}return!1}},{key:"deselectObject",value:function(t){!0===t.isSelected()&&(t.selected=!1,this._removeFromSelection(t))}},{key:"_getAllNodesOverlappingWith",value:function(t){for(var e=[],i=this.body.nodes,n=0;n<this.body.nodeIndices.length;n++){var o=this.body.nodeIndices[n];i[o].isOverlappingWith(t)&&e.push(o)}return e}},{key:"_pointerToPositionObject",value:function(t){var e=this.canvas.DOMtoCanvas(t);return{left:e.x-1,top:e.y+1,right:e.x+1,bottom:e.y-1}}},{key:"getNodeAt",value:function(t){var e=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],i=this._pointerToPositionObject(t),n=this._getAllNodesOverlappingWith(i);return n.length>0?!0===e?this.body.nodes[n[n.length-1]]:n[n.length-1]:void 0}},{key:"_getEdgesOverlappingWith",value:function(t,e){for(var i=this.body.edges,n=0;n<this.body.edgeIndices.length;n++){var o=this.body.edgeIndices[n];i[o].isOverlappingWith(t)&&e.push(o)}}},{key:"_getAllEdgesOverlappingWith",value:function(t){var e=[];return this._getEdgesOverlappingWith(t,e),e}},{key:"getEdgeAt",value:function(t){for(var e=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],i=this.canvas.DOMtoCanvas(t),n=10,o=null,r=this.body.edges,s=0;s<this.body.edgeIndices.length;s++){var a=this.body.edgeIndices[s],h=r[a];if(h.connected){var l=h.from.x,d=h.from.y,c=h.to.x,u=h.to.y,f=h.edgeType.getDistanceToEdge(l,d,c,u,i.x,i.y);f<n&&(o=a,n=f)}}return null!==o?!0===e?this.body.edges[o]:o:void 0}},{key:"_addToHover",value:function(t){t instanceof fO?this.hoverObj.nodes[t.id]=t:this.hoverObj.edges[t.id]=t}},{key:"_removeFromSelection",value:function(t){var e;t instanceof fO?(this._selectionAccumulator.deleteNodes(t),(e=this._selectionAccumulator).deleteEdges.apply(e,Jc(t.edges))):this._selectionAccumulator.deleteEdges(t)}},{key:"unselectAll",value:function(){this._selectionAccumulator.clear()}},{key:"getSelectedNodeCount",value:function(){return this._selectionAccumulator.sizeNodes}},{key:"getSelectedEdgeCount",value:function(){return this._selectionAccumulator.sizeEdges}},{key:"_hoverConnectedEdges",value:function(t){for(var e=0;e<t.edges.length;e++){var i=t.edges[e];i.hover=!0,this._addToHover(i)}}},{key:"emitBlurEvent",value:function(t,e,i){var n=this._initBaseEvent(t,e);!0===i.hover&&(i.hover=!1,i instanceof fO?(n.node=i.id,this.body.emitter.emit("blurNode",n)):(n.edge=i.id,this.body.emitter.emit("blurEdge",n)))}},{key:"emitHoverEvent",value:function(t,e,i){var n=this._initBaseEvent(t,e),o=!1;return!1===i.hover&&(i.hover=!0,this._addToHover(i),o=!0,i instanceof fO?(n.node=i.id,this.body.emitter.emit("hoverNode",n)):(n.edge=i.id,this.body.emitter.emit("hoverEdge",n))),o}},{key:"hoverObject",value:function(t,e){var i=this.getNodeAt(e);void 0===i&&(i=this.getEdgeAt(e));var n=!1;for(var o in this.hoverObj.nodes)Object.prototype.hasOwnProperty.call(this.hoverObj.nodes,o)&&(void 0===i||i instanceof fO&&i.id!=o||i instanceof cC)&&(this.emitBlurEvent(t,e,this.hoverObj.nodes[o]),delete this.hoverObj.nodes[o],n=!0);for(var r in this.hoverObj.edges)Object.prototype.hasOwnProperty.call(this.hoverObj.edges,r)&&(!0===n?(this.hoverObj.edges[r].hover=!1,delete this.hoverObj.edges[r]):(void 0===i||i instanceof cC&&i.id!=r||i instanceof fO&&!i.hover)&&(this.emitBlurEvent(t,e,this.hoverObj.edges[r]),delete this.hoverObj.edges[r],n=!0));if(void 0!==i){var s=bu(this.hoverObj.edges).length,a=bu(this.hoverObj.nodes).length;(n||i instanceof cC&&0===s&&0===a||i instanceof fO&&0===s&&0===a)&&(n=this.emitHoverEvent(t,e,i)),i instanceof fO&&!0===this.options.hoverConnectedEdges&&this._hoverConnectedEdges(i)}!0===n&&this.body.emitter.emit("_requestRedraw")}},{key:"commitWithoutEmitting",value:function(){this._selectionAccumulator.commit()}},{key:"commitAndEmit",value:function(t,e){var i=!1,n=this._selectionAccumulator.commit(),o={nodes:n.nodes.previous,edges:n.edges.previous};n.edges.deleted.length>0&&(this.generateClickEvent("deselectEdge",e,t,o),i=!0),n.nodes.deleted.length>0&&(this.generateClickEvent("deselectNode",e,t,o),i=!0),n.nodes.added.length>0&&(this.generateClickEvent("selectNode",e,t),i=!0),n.edges.added.length>0&&(this.generateClickEvent("selectEdge",e,t),i=!0),!0===i&&this.generateClickEvent("select",e,t)}},{key:"getSelection",value:function(){return{nodes:this.getSelectedNodeIds(),edges:this.getSelectedEdgeIds()}}},{key:"getSelectedNodes",value:function(){return this._selectionAccumulator.getNodes()}},{key:"getSelectedEdges",value:function(){return this._selectionAccumulator.getEdges()}},{key:"getSelectedNodeIds",value:function(){var t;return gu(t=this._selectionAccumulator.getNodes()).call(t,(function(t){return t.id}))}},{key:"getSelectedEdgeIds",value:function(){var t;return gu(t=this._selectionAccumulator.getEdges()).call(t,(function(t){return t.id}))}},{key:"setSelection",value:function(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(!t||!t.nodes&&!t.edges)throw new TypeError("Selection must be an object with nodes and/or edges properties");if((e.unselectAll||void 0===e.unselectAll)&&this.unselectAll(),t.nodes){var i,n=RS(t.nodes);try{for(n.s();!(i=n.n()).done;){var o=i.value,r=this.body.nodes[o];if(!r)throw new RangeError('Node with id "'+o+'" not found');this.selectObject(r,e.highlightEdges)}}catch(t){n.e(t)}finally{n.f()}}if(t.edges){var s,a=RS(t.edges);try{for(a.s();!(s=a.n()).done;){var h=s.value,l=this.body.edges[h];if(!l)throw new RangeError('Edge with id "'+h+'" not found');this.selectObject(l)}}catch(t){a.e(t)}finally{a.f()}}this.body.emitter.emit("_requestRedraw"),this._selectionAccumulator.commit()}},{key:"selectNodes",value:function(t){var e=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];if(!t||void 0===t.length)throw"Selection must be an array with ids";this.setSelection({nodes:t},{highlightEdges:e})}},{key:"selectEdges",value:function(t){if(!t||void 0===t.length)throw"Selection must be an array with ids";this.setSelection({edges:t})}},{key:"updateSelection",value:function(){for(var t in this._selectionAccumulator.getNodes())Object.prototype.hasOwnProperty.call(this.body.nodes,t.id)||this._selectionAccumulator.deleteNodes(t);for(var e in this._selectionAccumulator.getEdges())Object.prototype.hasOwnProperty.call(this.body.edges,e.id)||this._selectionAccumulator.deleteEdges(e)}},{key:"getClickedItems",value:function(t){for(var e=this.canvas.DOMtoCanvas(t),i=[],n=this.body.nodeIndices,o=this.body.nodes,r=n.length-1;r>=0;r--){var s=o[n[r]].getItemsOnPoint(e);i.push.apply(i,s)}for(var a=this.body.edgeIndices,h=this.body.edges,l=a.length-1;l>=0;l--){var d=h[a[l]].getItemsOnPoint(e);i.push.apply(i,d)}return i}}]),t}(),WS={};!function(t){!function(t){function e(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}t.__esModule=!0,t.sort=v;var i=32,n=7,o=256,r=[1,10,100,1e3,1e4,1e5,1e6,1e7,1e8,1e9];function s(t){return t<1e5?t<100?t<10?0:1:t<1e4?t<1e3?2:3:4:t<1e7?t<1e6?5:6:t<1e9?t<1e8?7:8:9}function a(t,e){if(t===e)return 0;if(~~t===t&&~~e===e){if(0===t||0===e)return t<e?-1:1;if(t<0||e<0){if(e>=0)return-1;if(t>=0)return 1;t=-t,e=-e}var i=s(t),n=s(e),o=0;return i<n?(t*=r[n-i-1],e/=10,o=-1):i>n&&(e*=r[i-n-1],t/=10,o=1),t===e?o:t<e?-1:1}var a=String(t),h=String(e);return a===h?0:a<h?-1:1}function h(t){for(var e=0;t>=i;)e|=1&t,t>>=1;return t+e}function l(t,e,i,n){var o=e+1;if(o===i)return 1;if(n(t[o++],t[e])<0){for(;o<i&&n(t[o],t[o-1])<0;)o++;d(t,e,o)}else for(;o<i&&n(t[o],t[o-1])>=0;)o++;return o-e}function d(t,e,i){for(i--;e<i;){var n=t[e];t[e++]=t[i],t[i--]=n}}function c(t,e,i,n,o){for(n===e&&n++;n<i;n++){for(var r=t[n],s=e,a=n;s<a;){var h=s+a>>>1;o(r,t[h])<0?a=h:s=h+1}var l=n-s;switch(l){case 3:t[s+3]=t[s+2];case 2:t[s+2]=t[s+1];case 1:t[s+1]=t[s];break;default:for(;l>0;)t[s+l]=t[s+l-1],l--}t[s]=r}}function u(t,e,i,n,o,r){var s=0,a=0,h=1;if(r(t,e[i+o])>0){for(a=n-o;h<a&&r(t,e[i+o+h])>0;)s=h,(h=1+(h<<1))<=0&&(h=a);h>a&&(h=a),s+=o,h+=o}else{for(a=o+1;h<a&&r(t,e[i+o-h])<=0;)s=h,(h=1+(h<<1))<=0&&(h=a);h>a&&(h=a);var l=s;s=o-h,h=o-l}for(s++;s<h;){var d=s+(h-s>>>1);r(t,e[i+d])>0?s=d+1:h=d}return h}function f(t,e,i,n,o,r){var s=0,a=0,h=1;if(r(t,e[i+o])<0){for(a=o+1;h<a&&r(t,e[i+o-h])<0;)s=h,(h=1+(h<<1))<=0&&(h=a);h>a&&(h=a);var l=s;s=o-h,h=o-l}else{for(a=n-o;h<a&&r(t,e[i+o+h])>=0;)s=h,(h=1+(h<<1))<=0&&(h=a);h>a&&(h=a),s+=o,h+=o}for(s++;s<h;){var d=s+(h-s>>>1);r(t,e[i+d])<0?h=d:s=d+1}return h}var p=function(){function t(i,r){e(this,t),this.array=null,this.compare=null,this.minGallop=n,this.length=0,this.tmpStorageLength=o,this.stackLength=0,this.runStart=null,this.runLength=null,this.stackSize=0,this.array=i,this.compare=r,this.length=i.length,this.length<2*o&&(this.tmpStorageLength=this.length>>>1),this.tmp=new Array(this.tmpStorageLength),this.stackLength=this.length<120?5:this.length<1542?10:this.length<119151?19:40,this.runStart=new Array(this.stackLength),this.runLength=new Array(this.stackLength)}return t.prototype.pushRun=function(t,e){this.runStart[this.stackSize]=t,this.runLength[this.stackSize]=e,this.stackSize+=1},t.prototype.mergeRuns=function(){for(;this.stackSize>1;){var t=this.stackSize-2;if(t>=1&&this.runLength[t-1]<=this.runLength[t]+this.runLength[t+1]||t>=2&&this.runLength[t-2]<=this.runLength[t]+this.runLength[t-1])this.runLength[t-1]<this.runLength[t+1]&&t--;else if(this.runLength[t]>this.runLength[t+1])break;this.mergeAt(t)}},t.prototype.forceMergeRuns=function(){for(;this.stackSize>1;){var t=this.stackSize-2;t>0&&this.runLength[t-1]<this.runLength[t+1]&&t--,this.mergeAt(t)}},t.prototype.mergeAt=function(t){var e=this.compare,i=this.array,n=this.runStart[t],o=this.runLength[t],r=this.runStart[t+1],s=this.runLength[t+1];this.runLength[t]=o+s,t===this.stackSize-3&&(this.runStart[t+1]=this.runStart[t+2],this.runLength[t+1]=this.runLength[t+2]),this.stackSize--;var a=f(i[r],i,n,o,0,e);n+=a,0!=(o-=a)&&0!==(s=u(i[n+o-1],i,r,s,s-1,e))&&(o<=s?this.mergeLow(n,o,r,s):this.mergeHigh(n,o,r,s))},t.prototype.mergeLow=function(t,e,i,o){var r=this.compare,s=this.array,a=this.tmp,h=0;for(h=0;h<e;h++)a[h]=s[t+h];var l=0,d=i,c=t;if(s[c++]=s[d++],0!=--o)if(1!==e){for(var p=this.minGallop;;){var v=0,g=0,y=!1;do{if(r(s[d],a[l])<0){if(s[c++]=s[d++],g++,v=0,0==--o){y=!0;break}}else if(s[c++]=a[l++],v++,g=0,1==--e){y=!0;break}}while((v|g)<p);if(y)break;do{if(0!==(v=f(s[d],a,l,e,0,r))){for(h=0;h<v;h++)s[c+h]=a[l+h];if(c+=v,l+=v,(e-=v)<=1){y=!0;break}}if(s[c++]=s[d++],0==--o){y=!0;break}if(0!==(g=u(a[l],s,d,o,0,r))){for(h=0;h<g;h++)s[c+h]=s[d+h];if(c+=g,d+=g,0==(o-=g)){y=!0;break}}if(s[c++]=a[l++],1==--e){y=!0;break}p--}while(v>=n||g>=n);if(y)break;p<0&&(p=0),p+=2}if(this.minGallop=p,p<1&&(this.minGallop=1),1===e){for(h=0;h<o;h++)s[c+h]=s[d+h];s[c+o]=a[l]}else{if(0===e)throw new Error("mergeLow preconditions were not respected");for(h=0;h<e;h++)s[c+h]=a[l+h]}}else{for(h=0;h<o;h++)s[c+h]=s[d+h];s[c+o]=a[l]}else for(h=0;h<e;h++)s[c+h]=a[l+h]},t.prototype.mergeHigh=function(t,e,i,o){var r=this.compare,s=this.array,a=this.tmp,h=0;for(h=0;h<o;h++)a[h]=s[i+h];var l=t+e-1,d=o-1,c=i+o-1,p=0,v=0;if(s[c--]=s[l--],0!=--e)if(1!==o){for(var g=this.minGallop;;){var y=0,m=0,b=!1;do{if(r(a[d],s[l])<0){if(s[c--]=s[l--],y++,m=0,0==--e){b=!0;break}}else if(s[c--]=a[d--],m++,y=0,1==--o){b=!0;break}}while((y|m)<g);if(b)break;do{if(0!=(y=e-f(a[d],s,t,e,e-1,r))){for(e-=y,v=1+(c-=y),p=1+(l-=y),h=y-1;h>=0;h--)s[v+h]=s[p+h];if(0===e){b=!0;break}}if(s[c--]=a[d--],1==--o){b=!0;break}if(0!=(m=o-u(s[l],a,0,o,o-1,r))){for(o-=m,v=1+(c-=m),p=1+(d-=m),h=0;h<m;h++)s[v+h]=a[p+h];if(o<=1){b=!0;break}}if(s[c--]=s[l--],0==--e){b=!0;break}g--}while(y>=n||m>=n);if(b)break;g<0&&(g=0),g+=2}if(this.minGallop=g,g<1&&(this.minGallop=1),1===o){for(v=1+(c-=e),p=1+(l-=e),h=e-1;h>=0;h--)s[v+h]=s[p+h];s[c]=a[d]}else{if(0===o)throw new Error("mergeHigh preconditions were not respected");for(p=c-(o-1),h=0;h<o;h++)s[p+h]=a[h]}}else{for(v=1+(c-=e),p=1+(l-=e),h=e-1;h>=0;h--)s[v+h]=s[p+h];s[c]=a[d]}else for(p=c-(o-1),h=0;h<o;h++)s[p+h]=a[h]},t}();function v(t,e,n,o){if(!Array.isArray(t))throw new TypeError("Can only sort arrays");e?"function"!=typeof e&&(o=n,n=e,e=a):e=a,n||(n=0),o||(o=t.length);var r=o-n;if(!(r<2)){var s=0;if(r<i)c(t,n,o,n+(s=l(t,n,o,e)),e);else{var d=new p(t,e),u=h(r);do{if((s=l(t,n,o,e))<u){var f=r;f>u&&(f=u),c(t,n,n+f,n+s,e),s=f}d.pushRun(n,s),d.mergeRuns(),r-=s,n+=s}while(0!==r);d.forceMergeRuns()}}}}(t)}(WS);var qS=WS;function VS(t){var e=function(){if("undefined"==typeof Reflect||!Mk)return!1;if(Mk.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Mk(Boolean,[],(function(){}))),!0}catch(t){return!1}}();return function(){var i,n=Ak(t);if(e){var o=Ak(this).constructor;i=Mk(n,arguments,o)}else i=n.apply(this,arguments);return Nk(this,i)}}var US=function(){function t(){Yd(this,t)}return Kd(t,[{key:"abstract",value:function(){throw new Error("Can't instantiate abstract class!")}},{key:"fake_use",value:function(){}},{key:"curveType",value:function(){return this.abstract()}},{key:"getPosition",value:function(t){return this.fake_use(t),this.abstract()}},{key:"setPosition",value:function(t,e){var i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:void 0;this.fake_use(t,e,i),this.abstract()}},{key:"getTreeSize",value:function(t){return this.fake_use(t),this.abstract()}},{key:"sort",value:function(t){this.fake_use(t),this.abstract()}},{key:"fix",value:function(t,e){this.fake_use(t,e),this.abstract()}},{key:"shift",value:function(t,e){this.fake_use(t,e),this.abstract()}}]),t}(),YS=function(t){zk(i,t);var e=VS(i);function i(t){var n;return Yd(this,i),(n=e.call(this)).layout=t,n}return Kd(i,[{key:"curveType",value:function(){return"horizontal"}},{key:"getPosition",value:function(t){return t.x}},{key:"setPosition",value:function(t,e){var i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:void 0;void 0!==i&&this.layout.hierarchical.addToOrdering(t,i),t.x=e}},{key:"getTreeSize",value:function(t){var e=this.layout.hierarchical.getTreeSize(this.layout.body.nodes,t);return{min:e.min_x,max:e.max_x}}},{key:"sort",value:function(t){qS.sort(t,(function(t,e){return t.x-e.x}))}},{key:"fix",value:function(t,e){t.y=this.layout.options.hierarchical.levelSeparation*e,t.options.fixed.y=!0}},{key:"shift",value:function(t,e){this.layout.body.nodes[t].x+=e}}]),i}(US),XS=function(t){zk(i,t);var e=VS(i);function i(t){var n;return Yd(this,i),(n=e.call(this)).layout=t,n}return Kd(i,[{key:"curveType",value:function(){return"vertical"}},{key:"getPosition",value:function(t){return t.y}},{key:"setPosition",value:function(t,e){var i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:void 0;void 0!==i&&this.layout.hierarchical.addToOrdering(t,i),t.y=e}},{key:"getTreeSize",value:function(t){var e=this.layout.hierarchical.getTreeSize(this.layout.body.nodes,t);return{min:e.min_y,max:e.max_y}}},{key:"sort",value:function(t){qS.sort(t,(function(t,e){return t.y-e.y}))}},{key:"fix",value:function(t,e){t.x=this.layout.options.hierarchical.levelSeparation*e,t.options.fixed.x=!0}},{key:"shift",value:function(t,e){this.layout.body.nodes[t].y+=e}}]),i}(US),GS=Wh.every;_i({target:"Array",proto:!0,forced:!Cu("every")},{every:function(t){return GS(this,t,arguments.length>1?arguments[1]:void 0)}});var KS=Tn("Array").every,$S=J,ZS=KS,QS=Array.prototype,JS=function(t){var e=t.every;return t===QS||$S(QS,t)&&e===QS.every?ZS:e},tT=JS;function eT(t,e){var i=void 0!==tu&&ih(t)||t["@@iterator"];if(!i){if(lu(t)||(i=function(t,e){var i;if(!t)return;if("string"==typeof t)return iT(t,e);var n=au(i=Object.prototype.toString.call(t)).call(i,8,-1);"Object"===n&&t.constructor&&(n=t.constructor.name);if("Map"===n||"Set"===n)return ja(t);if("Arguments"===n||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))return iT(t,e)}(t))||e&&t&&"number"==typeof t.length){i&&(t=i);var n=0,o=function(){};return{s:o,n:function(){return n>=t.length?{done:!0}:{done:!1,value:t[n++]}},e:function(t){throw t},f:o}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}var r,s=!0,a=!1;return{s:function(){i=i.call(t)},n:function(){var t=i.next();return s=t.done,t},e:function(t){a=!0,r=t},f:function(){try{s||null==i.return||i.return()}finally{if(a)throw r}}}}function iT(t,e){(null==e||e>t.length)&&(e=t.length);for(var i=0,n=new Array(e);i<e;i++)n[i]=t[i];return n}function nT(t,e){var i=new b_;return Fu(t).call(t,(function(t){var e;Fu(e=t.edges).call(e,(function(t){t.connected&&i.add(t)}))})),Fu(i).call(i,(function(t){var i=t.from.id,n=t.to.id;null==e[i]&&(e[i]=0),(null==e[n]||e[i]>=e[n])&&(e[n]=e[i]+1)})),e}function oT(t,e,i,n){var o,r,s=Kp(null),a=i_(o=Jc(kx(n).call(n))).call(o,(function(t,e){return t+1+e.edges.length}),0),h=i+"Id",l="to"===i?1:-1,d=eT(n);try{var c=function(){var o=Kc(r.value,2),d=o[0],c=o[1];if(!n.has(d)||!t(c))return"continue";s[d]=0;for(var u=[c],f=0,p=void 0,v=function(){var t,o;if(!n.has(d))return"continue";var r=s[p.id]+l;if(Fu(t=Xf(o=p.edges).call(o,(function(t){return t.connected&&t.to!==t.from&&t[i]!==p&&n.has(t.toId)&&n.has(t.fromId)}))).call(t,(function(t){var n=t[h],o=s[n];(null==o||e(r,o))&&(s[n]=r,u.push(t[i]))})),f>a)return{v:{v:nT(n,s)}};++f};p=u.pop();){var g=v();if("continue"!==g&&"object"===Qc(g))return g.v}};for(d.s();!(r=d.n()).done;){var u=c();if("continue"!==u&&"object"===Qc(u))return u.v}}catch(t){d.e(t)}finally{d.f()}return s}var rT=function(){function t(){Yd(this,t),this.childrenReference={},this.parentReference={},this.trees={},this.distributionOrdering={},this.levels={},this.distributionIndex={},this.isTree=!1,this.treeIndex=-1}return Kd(t,[{key:"addRelation",value:function(t,e){void 0===this.childrenReference[t]&&(this.childrenReference[t]=[]),this.childrenReference[t].push(e),void 0===this.parentReference[e]&&(this.parentReference[e]=[]),this.parentReference[e].push(t)}},{key:"checkIfTree",value:function(){for(var t in this.parentReference)if(this.parentReference[t].length>1)return void(this.isTree=!1);this.isTree=!0}},{key:"numTrees",value:function(){return this.treeIndex+1}},{key:"setTreeIndex",value:function(t,e){void 0!==e&&void 0===this.trees[t.id]&&(this.trees[t.id]=e,this.treeIndex=Math.max(e,this.treeIndex))}},{key:"ensureLevel",value:function(t){void 0===this.levels[t]&&(this.levels[t]=0)}},{key:"getMaxLevel",value:function(t){var e=this,i={};return function t(n){if(void 0!==i[n])return i[n];var o=e.levels[n];if(e.childrenReference[n]){var r=e.childrenReference[n];if(r.length>0)for(var s=0;s<r.length;s++)o=Math.max(o,t(r[s]))}return i[n]=o,o}(t)}},{key:"levelDownstream",value:function(t,e){void 0===this.levels[e.id]&&(void 0===this.levels[t.id]&&(this.levels[t.id]=0),this.levels[e.id]=this.levels[t.id]+1)}},{key:"setMinLevelToZero",value:function(t){var e=1e9;for(var i in t)Object.prototype.hasOwnProperty.call(t,i)&&void 0!==this.levels[i]&&(e=Math.min(this.levels[i],e));for(var n in t)Object.prototype.hasOwnProperty.call(t,n)&&void 0!==this.levels[n]&&(this.levels[n]-=e)}},{key:"getTreeSize",value:function(t,e){var i=1e9,n=-1e9,o=1e9,r=-1e9;for(var s in this.trees)if(Object.prototype.hasOwnProperty.call(this.trees,s)&&this.trees[s]===e){var a=t[s];i=Math.min(a.x,i),n=Math.max(a.x,n),o=Math.min(a.y,o),r=Math.max(a.y,r)}return{min_x:i,max_x:n,min_y:o,max_y:r}}},{key:"hasSameParent",value:function(t,e){var i=this.parentReference[t.id],n=this.parentReference[e.id];if(void 0===i||void 0===n)return!1;for(var o=0;o<i.length;o++)for(var r=0;r<n.length;r++)if(i[o]==n[r])return!0;return!1}},{key:"inSameSubNetwork",value:function(t,e){return this.trees[t.id]===this.trees[e.id]}},{key:"getLevels",value:function(){return bu(this.distributionOrdering)}},{key:"addToOrdering",value:function(t,e){void 0===this.distributionOrdering[e]&&(this.distributionOrdering[e]=[]);var i=!1,n=this.distributionOrdering[e];for(var o in n)if(n[o]===t){i=!0;break}i||(this.distributionOrdering[e].push(t),this.distributionIndex[t.id]=this.distributionOrdering[e].length-1)}}]),t}(),sT=function(){function t(e){Yd(this,t),this.body=e,this._resetRNG(Math.random()+":"+Eu()),this.setPhysics=!1,this.options={},this.optionsBackup={physics:{}},this.defaultOptions={randomSeed:void 0,improvedLayout:!0,clusterThreshold:150,hierarchical:{enabled:!1,levelSeparation:150,nodeSpacing:100,treeSpacing:200,blockShifting:!0,edgeMinimization:!0,parentCentralization:!0,direction:"UD",sortMethod:"hubsize"}},un(this.options,this.defaultOptions),this.bindEventListeners()}return Kd(t,[{key:"bindEventListeners",value:function(){var t=this;this.body.emitter.on("_dataChanged",(function(){t.setupHierarchicalLayout()})),this.body.emitter.on("_dataLoaded",(function(){t.layoutNetwork()})),this.body.emitter.on("_resetHierarchicalLayout",(function(){t.setupHierarchicalLayout()})),this.body.emitter.on("_adjustEdgesForHierarchicalLayout",(function(){if(!0===t.options.hierarchical.enabled){var e=t.direction.curveType();t.body.emitter.emit("_forceDisableDynamicCurves",e,!1)}}))}},{key:"setOptions",value:function(t,e){if(void 0!==t){var i=this.options.hierarchical,n=i.enabled;if(em(["randomSeed","improvedLayout","clusterThreshold"],this.options,t),Sm(this.options,t,"hierarchical"),void 0!==t.randomSeed&&this._resetRNG(t.randomSeed),!0===i.enabled)return!0===n&&this.body.emitter.emit("refresh",!0),"RL"===i.direction||"DU"===i.direction?i.levelSeparation>0&&(i.levelSeparation*=-1):i.levelSeparation<0&&(i.levelSeparation*=-1),this.setDirectionStrategy(),this.body.emitter.emit("_resetHierarchicalLayout"),this.adaptAllOptionsForHierarchicalLayout(e);if(!0===n)return this.body.emitter.emit("refresh"),nm(e,this.optionsBackup)}return e}},{key:"_resetRNG",value:function(t){this.initialRandomSeed=t,this._rng=jy(this.initialRandomSeed)}},{key:"adaptAllOptionsForHierarchicalLayout",value:function(t){if(!0===this.options.hierarchical.enabled){var e=this.optionsBackup.physics;void 0===t.physics||!0===t.physics?(t.physics={enabled:void 0===e.enabled||e.enabled,solver:"hierarchicalRepulsion"},e.enabled=void 0===e.enabled||e.enabled,e.solver=e.solver||"barnesHut"):"object"===Qc(t.physics)?(e.enabled=void 0===t.physics.enabled||t.physics.enabled,e.solver=t.physics.solver||"barnesHut",t.physics.solver="hierarchicalRepulsion"):!1!==t.physics&&(e.solver="barnesHut",t.physics={solver:"hierarchicalRepulsion"});var i=this.direction.curveType();if(void 0===t.edges)this.optionsBackup.edges={smooth:{enabled:!0,type:"dynamic"}},t.edges={smooth:!1};else if(void 0===t.edges.smooth)this.optionsBackup.edges={smooth:{enabled:!0,type:"dynamic"}},t.edges.smooth=!1;else if("boolean"==typeof t.edges.smooth)this.optionsBackup.edges={smooth:t.edges.smooth},t.edges.smooth={enabled:t.edges.smooth,type:i};else{var n=t.edges.smooth;void 0!==n.type&&"dynamic"!==n.type&&(i=n.type),this.optionsBackup.edges={smooth:{enabled:void 0===n.enabled||n.enabled,type:void 0===n.type?"dynamic":n.type,roundness:void 0===n.roundness?.5:n.roundness,forceDirection:void 0!==n.forceDirection&&n.forceDirection}},t.edges.smooth={enabled:void 0===n.enabled||n.enabled,type:i,roundness:void 0===n.roundness?.5:n.roundness,forceDirection:void 0!==n.forceDirection&&n.forceDirection}}this.body.emitter.emit("_forceDisableDynamicCurves",i)}return t}},{key:"positionInitially",value:function(t){if(!0!==this.options.hierarchical.enabled){this._resetRNG(this.initialRandomSeed);for(var e=t.length+50,i=0;i<t.length;i++){var n=t[i],o=2*Math.PI*this._rng();void 0===n.x&&(n.x=e*Math.cos(o)),void 0===n.y&&(n.y=e*Math.sin(o))}}}},{key:"layoutNetwork",value:function(){if(!0!==this.options.hierarchical.enabled&&!0===this.options.improvedLayout){for(var t=this.body.nodeIndices,e=0,i=0;i<t.length;i++){!0===this.body.nodes[t[i]].predefinedPosition&&(e+=1)}if(e<.5*t.length){var n=0,o=this.options.clusterThreshold,r={clusterNodeProperties:{shape:"ellipse",label:"",group:"",font:{multi:!1}},clusterEdgeProperties:{label:"",font:{multi:!1},smooth:{enabled:!1}}};if(t.length>o){for(var s=t.length;t.length>o&&n<=10;){n+=1;var a=t.length;if(n%3==0?this.body.modules.clustering.clusterBridges(r):this.body.modules.clustering.clusterOutliers(r),a==t.length&&n%3!=0)return this._declusterAll(),this.body.emitter.emit("_layoutFailed"),void console.info("This network could not be positioned by this version of the improved layout algorithm. Please disable improvedLayout for better performance.")}this.body.modules.kamadaKawai.setOptions({springLength:Math.max(150,2*s)})}n>10&&console.info("The clustering didn't succeed within the amount of interations allowed, progressing with partial result."),this.body.modules.kamadaKawai.solve(t,this.body.edgeIndices,!0),this._shiftToCenter();for(var h=0;h<t.length;h++){var l=this.body.nodes[t[h]];!1===l.predefinedPosition&&(l.x+=70*(.5-this._rng()),l.y+=70*(.5-this._rng()))}this._declusterAll(),this.body.emitter.emit("_repositionBezierNodes")}}}},{key:"_shiftToCenter",value:function(){for(var t=EC.getRangeCore(this.body.nodes,this.body.nodeIndices),e=EC.findCenter(t),i=0;i<this.body.nodeIndices.length;i++){var n=this.body.nodes[this.body.nodeIndices[i]];n.x-=e.x,n.y-=e.y}}},{key:"_declusterAll",value:function(){for(var t=!0;!0===t;){t=!1;for(var e=0;e<this.body.nodeIndices.length;e++)!0===this.body.nodes[this.body.nodeIndices[e]].isCluster&&(t=!0,this.body.modules.clustering.openCluster(this.body.nodeIndices[e],{},!1));!0===t&&this.body.emitter.emit("_dataChanged")}}},{key:"getSeed",value:function(){return this.initialRandomSeed}},{key:"setupHierarchicalLayout",value:function(){if(!0===this.options.hierarchical.enabled&&this.body.nodeIndices.length>0){var t,e,i=!1,n=!1;for(e in this.lastNodeOnLevel={},this.hierarchical=new rT,this.body.nodes)Object.prototype.hasOwnProperty.call(this.body.nodes,e)&&(void 0!==(t=this.body.nodes[e]).options.level?(i=!0,this.hierarchical.levels[e]=t.options.level):n=!0);if(!0===n&&!0===i)throw new Error("To use the hierarchical layout, nodes require either no predefined levels or levels have to be defined for all nodes.");if(!0===n){var o=this.options.hierarchical.sortMethod;"hubsize"===o?this._determineLevelsByHubsize():"directed"===o?this._determineLevelsDirected():"custom"===o&&this._determineLevelsCustomCallback()}for(var r in this.body.nodes)Object.prototype.hasOwnProperty.call(this.body.nodes,r)&&this.hierarchical.ensureLevel(r);var s=this._getDistribution();this._generateMap(),this._placeNodesByHierarchy(s),this._condenseHierarchy(),this._shiftToCenter()}}},{key:"_condenseHierarchy",value:function(){var t=this,e=!1,i={},n=function(e,i){var n=t.hierarchical.trees;for(var o in n)Object.prototype.hasOwnProperty.call(n,o)&&n[o]===e&&t.direction.shift(o,i)},o=function(){for(var e=[],i=0;i<t.hierarchical.numTrees();i++)e.push(t.direction.getTreeSize(i));return e},r=function e(i,n){if(!n[i.id]&&(n[i.id]=!0,t.hierarchical.childrenReference[i.id])){var o=t.hierarchical.childrenReference[i.id];if(o.length>0)for(var r=0;r<o.length;r++)e(t.body.nodes[o[r]],n)}},s=function(e){var i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1e9,n=1e9,o=1e9,r=1e9,s=-1e9;for(var a in e)if(Object.prototype.hasOwnProperty.call(e,a)){var h=t.body.nodes[a],l=t.hierarchical.levels[h.id],d=t.direction.getPosition(h),c=t._getSpaceAroundNode(h,e),u=Kc(c,2),f=u[0],p=u[1];n=Math.min(f,n),o=Math.min(p,o),l<=i&&(r=Math.min(d,r),s=Math.max(d,s))}return[r,s,n,o]},a=function(e,i){var n=t.hierarchical.getMaxLevel(e.id),o=t.hierarchical.getMaxLevel(i.id);return Math.min(n,o)},h=function(e,i,n){for(var o=t.hierarchical,r=0;r<i.length;r++){var s=i[r],a=o.distributionOrdering[s];if(a.length>1)for(var h=0;h<a.length-1;h++){var l=a[h],d=a[h+1];o.hasSameParent(l,d)&&o.inSameSubNetwork(l,d)&&e(l,d,n)}}},l=function(i,n){var o=arguments.length>2&&void 0!==arguments[2]&&arguments[2],h=t.direction.getPosition(i),l=t.direction.getPosition(n),d=Math.abs(l-h),c=t.options.hierarchical.nodeSpacing;if(d>c){var u={},f={};r(i,u),r(n,f);var p=a(i,n),v=s(u,p),g=s(f,p),y=v[1],m=g[0],b=g[2],w=Math.abs(y-m);if(w>c){var k=y-m+c;k<-b+c&&(k=-b+c),k<0&&(t._shiftBlock(n.id,k),e=!0,!0===o&&t._centerParent(n))}}},d=function(n,o){for(var a=o.id,h=o.edges,l=t.hierarchical.levels[o.id],d=t.options.hierarchical.levelSeparation*t.options.hierarchical.levelSeparation,c={},u=[],f=0;f<h.length;f++){var p=h[f];if(p.toId!=p.fromId){var v=p.toId==a?p.from:p.to;c[h[f].id]=v,t.hierarchical.levels[v.id]<l&&u.push(p)}}var g=function(e,i){for(var n=0,o=0;o<i.length;o++)if(void 0!==c[i[o].id]){var r=t.direction.getPosition(c[i[o].id])-e;n+=r/Math.sqrt(r*r+d)}return n},y=function(e,i){for(var n=0,o=0;o<i.length;o++)if(void 0!==c[i[o].id]){var r=t.direction.getPosition(c[i[o].id])-e;n-=d*Math.pow(r*r+d,-1.5)}return n},m=function(e,i){for(var n=t.direction.getPosition(o),r={},s=0;s<e;s++){var a=g(n,i),h=y(n,i);if(void 0!==r[n-=Math.max(-40,Math.min(40,Math.round(a/h)))])break;r[n]=s}return n},b=m(n,u);!function(n){var a=t.direction.getPosition(o);if(void 0===i[o.id]){var h={};r(o,h),i[o.id]=h}var l=s(i[o.id]),d=l[2],c=l[3],u=n-a,f=0;u>0?f=Math.min(u,c-t.options.hierarchical.nodeSpacing):u<0&&(f=-Math.min(-u,d-t.options.hierarchical.nodeSpacing)),0!=f&&(t._shiftBlock(o.id,f),e=!0)}(b),function(i){var n=t.direction.getPosition(o),r=Kc(t._getSpaceAroundNode(o),2),s=r[0],a=r[1],h=i-n,l=n;h>0?l=Math.min(n+(a-t.options.hierarchical.nodeSpacing),i):h<0&&(l=Math.max(n-(s-t.options.hierarchical.nodeSpacing),i)),l!==n&&(t.direction.setPosition(o,l),e=!0)}(b=m(n,h))};!0===this.options.hierarchical.blockShifting&&(function(i){var n=t.hierarchical.getLevels();n=Yu(n).call(n);for(var o=0;o<i&&(e=!1,h(l,n,!0),!0===e);o++);}(5),function(){for(var e in t.body.nodes)Object.prototype.hasOwnProperty.call(t.body.nodes,e)&&t._centerParent(t.body.nodes[e])}()),!0===this.options.hierarchical.edgeMinimization&&function(i){var n=t.hierarchical.getLevels();n=Yu(n).call(n);for(var o=0;o<i;o++){e=!1;for(var r=0;r<n.length;r++)for(var s=n[r],a=t.hierarchical.distributionOrdering[s],h=0;h<a.length;h++)d(1e3,a[h]);if(!0!==e)break}}(20),!0===this.options.hierarchical.parentCentralization&&function(){var e=t.hierarchical.getLevels();e=Yu(e).call(e);for(var i=0;i<e.length;i++)for(var n=e[i],o=t.hierarchical.distributionOrdering[n],r=0;r<o.length;r++)t._centerParent(o[r])}(),function(){for(var e=o(),i=0,r=0;r<e.length-1;r++){i+=e[r].max-e[r+1].min+t.options.hierarchical.treeSpacing,n(r+1,i)}}()}},{key:"_getSpaceAroundNode",value:function(t,e){var i=!0;void 0===e&&(i=!1);var n=this.hierarchical.levels[t.id];if(void 0!==n){var o=this.hierarchical.distributionIndex[t.id],r=this.direction.getPosition(t),s=this.hierarchical.distributionOrdering[n],a=1e9,h=1e9;if(0!==o){var l=s[o-1];if(!0===i&&void 0===e[l.id]||!1===i)a=r-this.direction.getPosition(l)}if(o!=s.length-1){var d=s[o+1];if(!0===i&&void 0===e[d.id]||!1===i){var c=this.direction.getPosition(d);h=Math.min(h,c-r)}}return[a,h]}return[0,0]}},{key:"_centerParent",value:function(t){if(this.hierarchical.parentReference[t.id])for(var e=this.hierarchical.parentReference[t.id],i=0;i<e.length;i++){var n=e[i],o=this.body.nodes[n],r=this.hierarchical.childrenReference[n];if(void 0!==r){var s=this._getCenterPosition(r),a=this.direction.getPosition(o),h=Kc(this._getSpaceAroundNode(o),2),l=h[0],d=h[1],c=a-s;(c<0&&Math.abs(c)<d-this.options.hierarchical.nodeSpacing||c>0&&Math.abs(c)<l-this.options.hierarchical.nodeSpacing)&&this.direction.setPosition(o,s)}}}},{key:"_placeNodesByHierarchy",value:function(t){for(var e in this.positionedNodes={},t)if(Object.prototype.hasOwnProperty.call(t,e)){var i,n=bu(t[e]);n=this._indexArrayToNodes(n),rx(i=this.direction).call(i,n);for(var o=0,r=0;r<n.length;r++){var s=n[r];if(void 0===this.positionedNodes[s.id]){var a=this.options.hierarchical.nodeSpacing,h=a*o;o>0&&(h=this.direction.getPosition(n[r-1])+a),this.direction.setPosition(s,h,e),this._validatePositionAndContinue(s,e,h),o++}}}}},{key:"_placeBranchNodes",value:function(t,e){var i,n=this.hierarchical.childrenReference[t];if(void 0!==n){for(var o=[],r=0;r<n.length;r++)o.push(this.body.nodes[n[r]]);rx(i=this.direction).call(i,o);for(var s=0;s<o.length;s++){var a=o[s],h=this.hierarchical.levels[a.id];if(!(h>e&&void 0===this.positionedNodes[a.id]))return;var l=this.options.hierarchical.nodeSpacing,d=void 0;d=0===s?this.direction.getPosition(this.body.nodes[t]):this.direction.getPosition(o[s-1])+l,this.direction.setPosition(a,d,h),this._validatePositionAndContinue(a,h,d)}var c=this._getCenterPosition(o);this.direction.setPosition(this.body.nodes[t],c,e)}}},{key:"_validatePositionAndContinue",value:function(t,e,i){if(this.hierarchical.isTree){if(void 0!==this.lastNodeOnLevel[e]){var n=this.direction.getPosition(this.body.nodes[this.lastNodeOnLevel[e]]);if(i-n<this.options.hierarchical.nodeSpacing){var o=n+this.options.hierarchical.nodeSpacing-i,r=this._findCommonParent(this.lastNodeOnLevel[e],t.id);this._shiftBlock(r.withChild,o)}}this.lastNodeOnLevel[e]=t.id,this.positionedNodes[t.id]=!0,this._placeBranchNodes(t.id,e)}}},{key:"_indexArrayToNodes",value:function(t){for(var e=[],i=0;i<t.length;i++)e.push(this.body.nodes[t[i]]);return e}},{key:"_getDistribution",value:function(){var t,e,i={};for(t in this.body.nodes)if(Object.prototype.hasOwnProperty.call(this.body.nodes,t)){e=this.body.nodes[t];var n=void 0===this.hierarchical.levels[t]?0:this.hierarchical.levels[t];this.direction.fix(e,n),void 0===i[n]&&(i[n]={}),i[n][t]=e}return i}},{key:"_getActiveEdges",value:function(t){var e=this,i=[];return hm(t.edges,(function(t){var n;-1!==Fp(n=e.body.edgeIndices).call(n,t.id)&&i.push(t)})),i}},{key:"_getHubSizes",value:function(){var t=this,e={};hm(this.body.nodeIndices,(function(i){var n=t.body.nodes[i],o=t._getActiveEdges(n).length;e[o]=!0}));var i=[];return hm(e,(function(t){i.push(Number(t))})),rx(qS).call(qS,i,(function(t,e){return e-t})),i}},{key:"_determineLevelsByHubsize",value:function(){for(var t=this,e=function(e,i){t.hierarchical.levelDownstream(e,i)},i=this._getHubSizes(),n=function(n){var o=i[n];if(0===o)return"break";hm(t.body.nodeIndices,(function(i){var n=t.body.nodes[i];o===t._getActiveEdges(n).length&&t._crawlNetwork(e,i)}))},o=0;o<i.length;++o){if("break"===n(o))break}}},{key:"_determineLevelsCustomCallback",value:function(){var t=this;this._crawlNetwork((function(e,i,n){var o=t.hierarchical.levels[e.id];void 0===o&&(o=t.hierarchical.levels[e.id]=1e5);var r=(EC.cloneOptions(e,"node"),EC.cloneOptions(i,"node"),void EC.cloneOptions(n,"edge"));t.hierarchical.levels[i.id]=o+r})),this.hierarchical.setMinLevelToZero(this.body.nodes)}},{key:"_determineLevelsDirected",value:function(){var t,e=this,i=i_(t=this.body.nodeIndices).call(t,(function(t,i){return t.set(i,e.body.nodes[i]),t}),new Jw);"roots"===this.options.hierarchical.shakeTowards?this.hierarchical.levels=function(t){return oT((function(e){var i,n;return tT(i=Xf(n=e.edges).call(n,(function(e){return t.has(e.toId)}))).call(i,(function(t){return t.from===e}))}),(function(t,e){return e<t}),"to",t)}(i):this.hierarchical.levels=function(t){return oT((function(e){var i,n;return tT(i=Xf(n=e.edges).call(n,(function(e){return t.has(e.toId)}))).call(i,(function(t){return t.to===e}))}),(function(t,e){return e>t}),"from",t)}(i),this.hierarchical.setMinLevelToZero(this.body.nodes)}},{key:"_generateMap",value:function(){var t=this;this._crawlNetwork((function(e,i){t.hierarchical.levels[i.id]>t.hierarchical.levels[e.id]&&t.hierarchical.addRelation(e.id,i.id)})),this.hierarchical.checkIfTree()}},{key:"_crawlNetwork",value:function(){var t=this,e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:function(){},i=arguments.length>1?arguments[1]:void 0,n={},o=function i(o,r){if(void 0===n[o.id]){var s;t.hierarchical.setTreeIndex(o,r),n[o.id]=!0;for(var a=t._getActiveEdges(o),h=0;h<a.length;h++){var l=a[h];!0===l.connected&&(s=l.toId==o.id?l.from:l.to,o.id!=s.id&&(e(o,s,l),i(s,r)))}}};if(void 0===i)for(var r=0,s=0;s<this.body.nodeIndices.length;s++){var a=this.body.nodeIndices[s];if(void 0===n[a]){var h=this.body.nodes[a];o(h,r),r+=1}}else{var l=this.body.nodes[i];if(void 0===l)return void console.error("Node not found:",i);o(l)}}},{key:"_shiftBlock",value:function(t,e){var i=this,n={};!function t(o){if(!n[o]){n[o]=!0,i.direction.shift(o,e);var r=i.hierarchical.childrenReference[o];if(void 0!==r)for(var s=0;s<r.length;s++)t(r[s])}}(t)}},{key:"_findCommonParent",value:function(t,e){var i=this,n={};return function t(e,n){var o=i.hierarchical.parentReference[n];if(void 0!==o)for(var r=0;r<o.length;r++){var s=o[r];e[s]=!0,t(e,s)}}(n,t),function t(e,n){var o=i.hierarchical.parentReference[n];if(void 0!==o)for(var r=0;r<o.length;r++){var s=o[r];if(void 0!==e[s])return{foundParent:s,withChild:n};var a=t(e,s);if(null!==a.foundParent)return a}return{foundParent:null,withChild:n}}(n,e)}},{key:"setDirectionStrategy",value:function(){var t="UD"===this.options.hierarchical.direction||"DU"===this.options.hierarchical.direction;this.direction=t?new YS(this):new XS(this)}},{key:"_getCenterPosition",value:function(t){for(var e=1e9,i=-1e9,n=0;n<t.length;n++){var o=void 0;if(void 0!==t[n].id)o=t[n];else{var r=t[n];o=this.body.nodes[r]}var s=this.direction.getPosition(o);e=Math.min(e,s),i=Math.max(i,s)}return.5*(e+i)}}]),t}();function aT(t,e){var i=void 0!==tu&&ih(t)||t["@@iterator"];if(!i){if(lu(t)||(i=function(t,e){var i;if(!t)return;if("string"==typeof t)return hT(t,e);var n=au(i=Object.prototype.toString.call(t)).call(i,8,-1);"Object"===n&&t.constructor&&(n=t.constructor.name);if("Map"===n||"Set"===n)return ja(t);if("Arguments"===n||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))return hT(t,e)}(t))||e&&t&&"number"==typeof t.length){i&&(t=i);var n=0,o=function(){};return{s:o,n:function(){return n>=t.length?{done:!0}:{done:!1,value:t[n++]}},e:function(t){throw t},f:o}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}var r,s=!0,a=!1;return{s:function(){i=i.call(t)},n:function(){var t=i.next();return s=t.done,t},e:function(t){a=!0,r=t},f:function(){try{s||null==i.return||i.return()}finally{if(a)throw r}}}}function hT(t,e){(null==e||e>t.length)&&(e=t.length);for(var i=0,n=new Array(e);i<e;i++)n[i]=t[i];return n}var lT=function(){function t(e,i,n,o){var r,s,a=this;Yd(this,t),this.body=e,this.canvas=i,this.selectionHandler=n,this.interactionHandler=o,this.editMode=!1,this.manipulationDiv=void 0,this.editModeDiv=void 0,this.closeDiv=void 0,this._domEventListenerCleanupQueue=[],this.temporaryUIFunctions={},this.temporaryEventFunctions=[],this.touchTime=0,this.temporaryIds={nodes:[],edges:[]},this.guiEnabled=!1,this.inMode=!1,this.selectedControlNode=void 0,this.options={},this.defaultOptions={enabled:!1,initiallyActive:!1,addNode:!0,addEdge:!0,editNode:void 0,editEdge:!0,deleteNode:!0,deleteEdge:!0,controlNodeStyle:{shape:"dot",size:6,color:{background:"#ff0000",border:"#3c3c3c",highlight:{background:"#07f968",border:"#3c3c3c"}},borderWidth:2,borderWidthSelected:2}},un(this.options,this.defaultOptions),this.body.emitter.on("destroy",(function(){a._clean()})),this.body.emitter.on("_dataChanged",zn(r=this._restore).call(r,this)),this.body.emitter.on("_resetData",zn(s=this._restore).call(s,this))}return Kd(t,[{key:"_restore",value:function(){!1!==this.inMode&&(!0===this.options.initiallyActive?this.enableEditMode():this.disableEditMode())}},{key:"setOptions",value:function(t,e,i){void 0!==e&&(void 0!==e.locale?this.options.locale=e.locale:this.options.locale=i.locale,void 0!==e.locales?this.options.locales=e.locales:this.options.locales=i.locales),void 0!==t&&("boolean"==typeof t?this.options.enabled=t:(this.options.enabled=!0,nm(this.options,t)),!0===this.options.initiallyActive&&(this.editMode=!0),this._setup())}},{key:"toggleEditMode",value:function(){!0===this.editMode?this.disableEditMode():this.enableEditMode()}},{key:"enableEditMode",value:function(){this.editMode=!0,this._clean(),!0===this.guiEnabled&&(this.manipulationDiv.style.display="block",this.closeDiv.style.display="block",this.editModeDiv.style.display="none",this.showManipulatorToolbar())}},{key:"disableEditMode",value:function(){this.editMode=!1,this._clean(),!0===this.guiEnabled&&(this.manipulationDiv.style.display="none",this.closeDiv.style.display="none",this.editModeDiv.style.display="block",this._createEditButton())}},{key:"showManipulatorToolbar",value:function(){if(this._clean(),this.manipulationDOM={},!0===this.guiEnabled){var t,e;this.editMode=!0,this.manipulationDiv.style.display="block",this.closeDiv.style.display="block";var i=this.selectionHandler.getSelectedNodeCount(),n=this.selectionHandler.getSelectedEdgeCount(),o=i+n,r=this.options.locales[this.options.locale],s=!1;!1!==this.options.addNode&&(this._createAddNodeButton(r),s=!0),!1!==this.options.addEdge&&(!0===s?this._createSeperator(1):s=!0,this._createAddEdgeButton(r)),1===i&&"function"==typeof this.options.editNode?(!0===s?this._createSeperator(2):s=!0,this._createEditNodeButton(r)):1===n&&0===i&&!1!==this.options.editEdge&&(!0===s?this._createSeperator(3):s=!0,this._createEditEdgeButton(r)),0!==o&&(i>0&&!1!==this.options.deleteNode||0===i&&!1!==this.options.deleteEdge)&&(!0===s&&this._createSeperator(4),this._createDeleteButton(r)),this._bindElementEvents(this.closeDiv,zn(t=this.toggleEditMode).call(t,this)),this._temporaryBindEvent("select",zn(e=this.showManipulatorToolbar).call(e,this))}this.body.emitter.emit("_redraw")}},{key:"addNodeMode",value:function(){var t;if(!0!==this.editMode&&this.enableEditMode(),this._clean(),this.inMode="addNode",!0===this.guiEnabled){var e,i=this.options.locales[this.options.locale];this.manipulationDOM={},this._createBackButton(i),this._createSeperator(),this._createDescription(i.addDescription||this.options.locales.en.addDescription),this._bindElementEvents(this.closeDiv,zn(e=this.toggleEditMode).call(e,this))}this._temporaryBindEvent("click",zn(t=this._performAddNode).call(t,this))}},{key:"editNode",value:function(){var t=this;!0!==this.editMode&&this.enableEditMode(),this._clean();var e=this.selectionHandler.getSelectedNodes()[0];if(void 0!==e){if(this.inMode="editNode","function"!=typeof this.options.editNode)throw new Error("No function has been configured to handle the editing of nodes.");if(!0!==e.isCluster){var i=nm({},e.options,!1);if(i.x=e.x,i.y=e.y,2!==this.options.editNode.length)throw new Error("The function for edit does not support two arguments (data, callback)");this.options.editNode(i,(function(e){null!=e&&"editNode"===t.inMode&&t.body.data.nodes.getDataSet().update(e),t.showManipulatorToolbar()}))}else alert(this.options.locales[this.options.locale].editClusterError||this.options.locales.en.editClusterError)}else this.showManipulatorToolbar()}},{key:"addEdgeMode",value:function(){var t,e,i,n,o;if(!0!==this.editMode&&this.enableEditMode(),this._clean(),this.inMode="addEdge",!0===this.guiEnabled){var r,s=this.options.locales[this.options.locale];this.manipulationDOM={},this._createBackButton(s),this._createSeperator(),this._createDescription(s.edgeDescription||this.options.locales.en.edgeDescription),this._bindElementEvents(this.closeDiv,zn(r=this.toggleEditMode).call(r,this))}this._temporaryBindUI("onTouch",zn(t=this._handleConnect).call(t,this)),this._temporaryBindUI("onDragEnd",zn(e=this._finishConnect).call(e,this)),this._temporaryBindUI("onDrag",zn(i=this._dragControlNode).call(i,this)),this._temporaryBindUI("onRelease",zn(n=this._finishConnect).call(n,this)),this._temporaryBindUI("onDragStart",zn(o=this._dragStartEdge).call(o,this)),this._temporaryBindUI("onHold",(function(){}))}},{key:"editEdgeMode",value:function(){if(!0!==this.editMode&&this.enableEditMode(),this._clean(),this.inMode="editEdge","object"!==Qc(this.options.editEdge)||"function"!=typeof this.options.editEdge.editWithoutDrag||(this.edgeBeingEditedId=this.selectionHandler.getSelectedEdgeIds()[0],void 0===this.edgeBeingEditedId)){if(!0===this.guiEnabled){var t,e=this.options.locales[this.options.locale];this.manipulationDOM={},this._createBackButton(e),this._createSeperator(),this._createDescription(e.editEdgeDescription||this.options.locales.en.editEdgeDescription),this._bindElementEvents(this.closeDiv,zn(t=this.toggleEditMode).call(t,this))}if(this.edgeBeingEditedId=this.selectionHandler.getSelectedEdgeIds()[0],void 0!==this.edgeBeingEditedId){var i,n,o,r,s=this.body.edges[this.edgeBeingEditedId],a=this._getNewTargetNode(s.from.x,s.from.y),h=this._getNewTargetNode(s.to.x,s.to.y);this.temporaryIds.nodes.push(a.id),this.temporaryIds.nodes.push(h.id),this.body.nodes[a.id]=a,this.body.nodeIndices.push(a.id),this.body.nodes[h.id]=h,this.body.nodeIndices.push(h.id),this._temporaryBindUI("onTouch",zn(i=this._controlNodeTouch).call(i,this)),this._temporaryBindUI("onTap",(function(){})),this._temporaryBindUI("onHold",(function(){})),this._temporaryBindUI("onDragStart",zn(n=this._controlNodeDragStart).call(n,this)),this._temporaryBindUI("onDrag",zn(o=this._controlNodeDrag).call(o,this)),this._temporaryBindUI("onDragEnd",zn(r=this._controlNodeDragEnd).call(r,this)),this._temporaryBindUI("onMouseMove",(function(){})),this._temporaryBindEvent("beforeDrawing",(function(t){var e=s.edgeType.findBorderPositions(t);!1===a.selected&&(a.x=e.from.x,a.y=e.from.y),!1===h.selected&&(h.x=e.to.x,h.y=e.to.y)})),this.body.emitter.emit("_redraw")}else this.showManipulatorToolbar()}else{var l=this.body.edges[this.edgeBeingEditedId];this._performEditEdge(l.from.id,l.to.id)}}},{key:"deleteSelected",value:function(){var t=this;!0!==this.editMode&&this.enableEditMode(),this._clean(),this.inMode="delete";var e=this.selectionHandler.getSelectedNodeIds(),i=this.selectionHandler.getSelectedEdgeIds(),n=void 0;if(e.length>0){for(var o=0;o<e.length;o++)if(!0===this.body.nodes[e[o]].isCluster)return void alert(this.options.locales[this.options.locale].deleteClusterError||this.options.locales.en.deleteClusterError);"function"==typeof this.options.deleteNode&&(n=this.options.deleteNode)}else i.length>0&&"function"==typeof this.options.deleteEdge&&(n=this.options.deleteEdge);if("function"==typeof n){var r={nodes:e,edges:i};if(2!==n.length)throw new Error("The function for delete does not support two arguments (data, callback)");n(r,(function(e){null!=e&&"delete"===t.inMode?(t.body.data.edges.getDataSet().remove(e.edges),t.body.data.nodes.getDataSet().remove(e.nodes),t.body.emitter.emit("startSimulation"),t.showManipulatorToolbar()):(t.body.emitter.emit("startSimulation"),t.showManipulatorToolbar())}))}else this.body.data.edges.getDataSet().remove(i),this.body.data.nodes.getDataSet().remove(e),this.body.emitter.emit("startSimulation"),this.showManipulatorToolbar()}},{key:"_setup",value:function(){!0===this.options.enabled?(this.guiEnabled=!0,this._createWrappers(),!1===this.editMode?this._createEditButton():this.showManipulatorToolbar()):(this._removeManipulationDOM(),this.guiEnabled=!1)}},{key:"_createWrappers",value:function(){var t,e;(void 0===this.manipulationDiv&&(this.manipulationDiv=document.createElement("div"),this.manipulationDiv.className="vis-manipulation",!0===this.editMode?this.manipulationDiv.style.display="block":this.manipulationDiv.style.display="none",this.canvas.frame.appendChild(this.manipulationDiv)),void 0===this.editModeDiv&&(this.editModeDiv=document.createElement("div"),this.editModeDiv.className="vis-edit-mode",!0===this.editMode?this.editModeDiv.style.display="none":this.editModeDiv.style.display="block",this.canvas.frame.appendChild(this.editModeDiv)),void 0===this.closeDiv)&&(this.closeDiv=document.createElement("button"),this.closeDiv.className="vis-close",this.closeDiv.setAttribute("aria-label",null!==(t=null===(e=this.options.locales[this.options.locale])||void 0===e?void 0:e.close)&&void 0!==t?t:this.options.locales.en.close),this.closeDiv.style.display=this.manipulationDiv.style.display,this.canvas.frame.appendChild(this.closeDiv))}},{key:"_getNewTargetNode",value:function(t,e){var i=nm({},this.options.controlNodeStyle);i.id="targetNode"+Ax(),i.hidden=!1,i.physics=!1,i.x=t,i.y=e;var n=this.body.functions.createNode(i);return n.shape.boundingBox={left:t,right:t,top:e,bottom:e},n}},{key:"_createEditButton",value:function(){var t;this._clean(),this.manipulationDOM={},Ky(this.editModeDiv);var e=this.options.locales[this.options.locale],i=this._createButton("editMode","vis-edit vis-edit-mode",e.edit||this.options.locales.en.edit);this.editModeDiv.appendChild(i),this._bindElementEvents(i,zn(t=this.toggleEditMode).call(t,this))}},{key:"_clean",value:function(){this.inMode=!1,!0===this.guiEnabled&&(Ky(this.editModeDiv),Ky(this.manipulationDiv),this._cleanupDOMEventListeners()),this._cleanupTemporaryNodesAndEdges(),this._unbindTemporaryUIs(),this._unbindTemporaryEvents(),this.body.emitter.emit("restorePhysics")}},{key:"_cleanupDOMEventListeners",value:function(){var t,e,i=aT(ff(t=this._domEventListenerCleanupQueue).call(t,0));try{for(i.s();!(e=i.n()).done;){(0,e.value)()}}catch(t){i.e(t)}finally{i.f()}}},{key:"_removeManipulationDOM",value:function(){this._clean(),Ky(this.manipulationDiv),Ky(this.editModeDiv),Ky(this.closeDiv),this.manipulationDiv&&this.canvas.frame.removeChild(this.manipulationDiv),this.editModeDiv&&this.canvas.frame.removeChild(this.editModeDiv),this.closeDiv&&this.canvas.frame.removeChild(this.closeDiv),this.manipulationDiv=void 0,this.editModeDiv=void 0,this.closeDiv=void 0}},{key:"_createSeperator",value:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1;this.manipulationDOM["seperatorLineDiv"+t]=document.createElement("div"),this.manipulationDOM["seperatorLineDiv"+t].className="vis-separator-line",this.manipulationDiv.appendChild(this.manipulationDOM["seperatorLineDiv"+t])}},{key:"_createAddNodeButton",value:function(t){var e,i=this._createButton("addNode","vis-add",t.addNode||this.options.locales.en.addNode);this.manipulationDiv.appendChild(i),this._bindElementEvents(i,zn(e=this.addNodeMode).call(e,this))}},{key:"_createAddEdgeButton",value:function(t){var e,i=this._createButton("addEdge","vis-connect",t.addEdge||this.options.locales.en.addEdge);this.manipulationDiv.appendChild(i),this._bindElementEvents(i,zn(e=this.addEdgeMode).call(e,this))}},{key:"_createEditNodeButton",value:function(t){var e,i=this._createButton("editNode","vis-edit",t.editNode||this.options.locales.en.editNode);this.manipulationDiv.appendChild(i),this._bindElementEvents(i,zn(e=this.editNode).call(e,this))}},{key:"_createEditEdgeButton",value:function(t){var e,i=this._createButton("editEdge","vis-edit",t.editEdge||this.options.locales.en.editEdge);this.manipulationDiv.appendChild(i),this._bindElementEvents(i,zn(e=this.editEdgeMode).call(e,this))}},{key:"_createDeleteButton",value:function(t){var e,i;i=this.options.rtl?"vis-delete-rtl":"vis-delete";var n=this._createButton("delete",i,t.del||this.options.locales.en.del);this.manipulationDiv.appendChild(n),this._bindElementEvents(n,zn(e=this.deleteSelected).call(e,this))}},{key:"_createBackButton",value:function(t){var e,i=this._createButton("back","vis-back",t.back||this.options.locales.en.back);this.manipulationDiv.appendChild(i),this._bindElementEvents(i,zn(e=this.showManipulatorToolbar).call(e,this))}},{key:"_createButton",value:function(t,e,i){var n=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"vis-label";return this.manipulationDOM[t+"Div"]=document.createElement("button"),this.manipulationDOM[t+"Div"].className="vis-button "+e,this.manipulationDOM[t+"Label"]=document.createElement("div"),this.manipulationDOM[t+"Label"].className=n,this.manipulationDOM[t+"Label"].innerText=i,this.manipulationDOM[t+"Div"].appendChild(this.manipulationDOM[t+"Label"]),this.manipulationDOM[t+"Div"]}},{key:"_createDescription",value:function(t){this.manipulationDOM.descriptionLabel=document.createElement("div"),this.manipulationDOM.descriptionLabel.className="vis-none",this.manipulationDOM.descriptionLabel.innerText=t,this.manipulationDiv.appendChild(this.manipulationDOM.descriptionLabel)}},{key:"_temporaryBindEvent",value:function(t,e){this.temporaryEventFunctions.push({event:t,boundFunction:e}),this.body.emitter.on(t,e)}},{key:"_temporaryBindUI",value:function(t,e){if(void 0===this.body.eventListeners[t])throw new Error("This UI function does not exist. Typo? You tried: "+t+" possible are: "+gv(bu(this.body.eventListeners)));this.temporaryUIFunctions[t]=this.body.eventListeners[t],this.body.eventListeners[t]=e}},{key:"_unbindTemporaryUIs",value:function(){for(var t in this.temporaryUIFunctions)Object.prototype.hasOwnProperty.call(this.temporaryUIFunctions,t)&&(this.body.eventListeners[t]=this.temporaryUIFunctions[t],delete this.temporaryUIFunctions[t]);this.temporaryUIFunctions={}}},{key:"_unbindTemporaryEvents",value:function(){for(var t=0;t<this.temporaryEventFunctions.length;t++){var e=this.temporaryEventFunctions[t].event,i=this.temporaryEventFunctions[t].boundFunction;this.body.emitter.off(e,i)}this.temporaryEventFunctions=[]}},{key:"_bindElementEvents",value:function(t,e){var i=new Wm(t,{});IC(i,e),this._domEventListenerCleanupQueue.push((function(){i.destroy()}));var n=function(t){var i=t.keyCode,n=t.key;"Enter"!==n&&" "!==n&&13!==i&&32!==i||e()};t.addEventListener("keyup",n,!1),this._domEventListenerCleanupQueue.push((function(){t.removeEventListener("keyup",n,!1)}))}},{key:"_cleanupTemporaryNodesAndEdges",value:function(){for(var t=0;t<this.temporaryIds.edges.length;t++){var e;this.body.edges[this.temporaryIds.edges[t]].disconnect(),delete this.body.edges[this.temporaryIds.edges[t]];var i,n=Fp(e=this.body.edgeIndices).call(e,this.temporaryIds.edges[t]);if(-1!==n)ff(i=this.body.edgeIndices).call(i,n,1)}for(var o=0;o<this.temporaryIds.nodes.length;o++){var r;delete this.body.nodes[this.temporaryIds.nodes[o]];var s,a=Fp(r=this.body.nodeIndices).call(r,this.temporaryIds.nodes[o]);if(-1!==a)ff(s=this.body.nodeIndices).call(s,a,1)}this.temporaryIds={nodes:[],edges:[]}}},{key:"_controlNodeTouch",value:function(t){this.selectionHandler.unselectAll(),this.lastTouch=this.body.functions.getPointer(t.center),this.lastTouch.translation=un({},this.body.view.translation)}},{key:"_controlNodeDragStart",value:function(){var t=this.lastTouch,e=this.selectionHandler._pointerToPositionObject(t),i=this.body.nodes[this.temporaryIds.nodes[0]],n=this.body.nodes[this.temporaryIds.nodes[1]],o=this.body.edges[this.edgeBeingEditedId];this.selectedControlNode=void 0;var r=i.isOverlappingWith(e),s=n.isOverlappingWith(e);!0===r?(this.selectedControlNode=i,o.edgeType.from=i):!0===s&&(this.selectedControlNode=n,o.edgeType.to=n),void 0!==this.selectedControlNode&&this.selectionHandler.selectObject(this.selectedControlNode),this.body.emitter.emit("_redraw")}},{key:"_controlNodeDrag",value:function(t){this.body.emitter.emit("disablePhysics");var e=this.body.functions.getPointer(t.center),i=this.canvas.DOMtoCanvas(e);void 0!==this.selectedControlNode?(this.selectedControlNode.x=i.x,this.selectedControlNode.y=i.y):this.interactionHandler.onDrag(t),this.body.emitter.emit("_redraw")}},{key:"_controlNodeDragEnd",value:function(t){var e=this.body.functions.getPointer(t.center),i=this.selectionHandler._pointerToPositionObject(e),n=this.body.edges[this.edgeBeingEditedId];if(void 0!==this.selectedControlNode){this.selectionHandler.unselectAll();for(var o=this.selectionHandler._getAllNodesOverlappingWith(i),r=void 0,s=o.length-1;s>=0;s--)if(o[s]!==this.selectedControlNode.id){r=this.body.nodes[o[s]];break}if(void 0!==r&&void 0!==this.selectedControlNode)if(!0===r.isCluster)alert(this.options.locales[this.options.locale].createEdgeError||this.options.locales.en.createEdgeError);else{var a=this.body.nodes[this.temporaryIds.nodes[0]];this.selectedControlNode.id===a.id?this._performEditEdge(r.id,n.to.id):this._performEditEdge(n.from.id,r.id)}else n.updateEdgeType(),this.body.emitter.emit("restorePhysics");this.body.emitter.emit("_redraw")}}},{key:"_handleConnect",value:function(t){if((new Date).valueOf()-this.touchTime>100){this.lastTouch=this.body.functions.getPointer(t.center),this.lastTouch.translation=un({},this.body.view.translation),this.interactionHandler.drag.pointer=this.lastTouch,this.interactionHandler.drag.translation=this.lastTouch.translation;var e=this.lastTouch,i=this.selectionHandler.getNodeAt(e);if(void 0!==i)if(!0===i.isCluster)alert(this.options.locales[this.options.locale].createEdgeError||this.options.locales.en.createEdgeError);else{var n=this._getNewTargetNode(i.x,i.y);this.body.nodes[n.id]=n,this.body.nodeIndices.push(n.id);var o=this.body.functions.createEdge({id:"connectionEdge"+Ax(),from:i.id,to:n.id,physics:!1,smooth:{enabled:!0,type:"continuous",roundness:.5}});this.body.edges[o.id]=o,this.body.edgeIndices.push(o.id),this.temporaryIds.nodes.push(n.id),this.temporaryIds.edges.push(o.id)}this.touchTime=(new Date).valueOf()}}},{key:"_dragControlNode",value:function(t){var e=this.body.functions.getPointer(t.center),i=this.selectionHandler._pointerToPositionObject(e),n=void 0;void 0!==this.temporaryIds.edges[0]&&(n=this.body.edges[this.temporaryIds.edges[0]].fromId);for(var o=this.selectionHandler._getAllNodesOverlappingWith(i),r=void 0,s=o.length-1;s>=0;s--){var a;if(-1===Fp(a=this.temporaryIds.nodes).call(a,o[s])){r=this.body.nodes[o[s]];break}}if(t.controlEdge={from:n,to:r?r.id:void 0},this.selectionHandler.generateClickEvent("controlNodeDragging",t,e),void 0!==this.temporaryIds.nodes[0]){var h=this.body.nodes[this.temporaryIds.nodes[0]];h.x=this.canvas._XconvertDOMtoCanvas(e.x),h.y=this.canvas._YconvertDOMtoCanvas(e.y),this.body.emitter.emit("_redraw")}else this.interactionHandler.onDrag(t)}},{key:"_finishConnect",value:function(t){var e=this.body.functions.getPointer(t.center),i=this.selectionHandler._pointerToPositionObject(e),n=void 0;void 0!==this.temporaryIds.edges[0]&&(n=this.body.edges[this.temporaryIds.edges[0]].fromId);for(var o=this.selectionHandler._getAllNodesOverlappingWith(i),r=void 0,s=o.length-1;s>=0;s--){var a;if(-1===Fp(a=this.temporaryIds.nodes).call(a,o[s])){r=this.body.nodes[o[s]];break}}this._cleanupTemporaryNodesAndEdges(),void 0!==r&&(!0===r.isCluster?alert(this.options.locales[this.options.locale].createEdgeError||this.options.locales.en.createEdgeError):void 0!==this.body.nodes[n]&&void 0!==this.body.nodes[r.id]&&this._performAddEdge(n,r.id)),t.controlEdge={from:n,to:r?r.id:void 0},this.selectionHandler.generateClickEvent("controlNodeDragEnd",t,e),this.body.emitter.emit("_redraw")}},{key:"_dragStartEdge",value:function(t){var e=this.lastTouch;this.selectionHandler.generateClickEvent("dragStart",t,e,void 0,!0)}},{key:"_performAddNode",value:function(t){var e=this,i={id:Ax(),x:t.pointer.canvas.x,y:t.pointer.canvas.y,label:"new"};if("function"==typeof this.options.addNode){if(2!==this.options.addNode.length)throw this.showManipulatorToolbar(),new Error("The function for add does not support two arguments (data,callback)");this.options.addNode(i,(function(t){null!=t&&"addNode"===e.inMode&&e.body.data.nodes.getDataSet().add(t),e.showManipulatorToolbar()}))}else this.body.data.nodes.getDataSet().add(i),this.showManipulatorToolbar()}},{key:"_performAddEdge",value:function(t,e){var i=this,n={from:t,to:e};if("function"==typeof this.options.addEdge){if(2!==this.options.addEdge.length)throw new Error("The function for connect does not support two arguments (data,callback)");this.options.addEdge(n,(function(t){null!=t&&"addEdge"===i.inMode&&(i.body.data.edges.getDataSet().add(t),i.selectionHandler.unselectAll(),i.showManipulatorToolbar())}))}else this.body.data.edges.getDataSet().add(n),this.selectionHandler.unselectAll(),this.showManipulatorToolbar()}},{key:"_performEditEdge",value:function(t,e){var i=this,n={id:this.edgeBeingEditedId,from:t,to:e,label:this.body.data.edges.get(this.edgeBeingEditedId).label},o=this.options.editEdge;if("object"===Qc(o)&&(o=o.editWithoutDrag),"function"==typeof o){if(2!==o.length)throw new Error("The function for edit does not support two arguments (data, callback)");o(n,(function(t){null==t||"editEdge"!==i.inMode?(i.body.edges[n.id].updateEdgeType(),i.body.emitter.emit("_redraw"),i.showManipulatorToolbar()):(i.body.data.edges.getDataSet().update(t),i.selectionHandler.unselectAll(),i.showManipulatorToolbar())}))}else this.body.data.edges.getDataSet().update(n),this.selectionHandler.unselectAll(),this.showManipulatorToolbar()}}]),t}(),dT="string",cT="boolean",uT="number",fT="array",pT="object",vT=["arrow","bar","box","circle","crow","curve","diamond","image","inv_curve","inv_triangle","triangle","vee"],gT={borderWidth:{number:uT},borderWidthSelected:{number:uT,undefined:"undefined"},brokenImage:{string:dT,undefined:"undefined"},chosen:{label:{boolean:cT,function:"function"},node:{boolean:cT,function:"function"},__type__:{object:pT,boolean:cT}},color:{border:{string:dT},background:{string:dT},highlight:{border:{string:dT},background:{string:dT},__type__:{object:pT,string:dT}},hover:{border:{string:dT},background:{string:dT},__type__:{object:pT,string:dT}},__type__:{object:pT,string:dT}},opacity:{number:uT,undefined:"undefined"},fixed:{x:{boolean:cT},y:{boolean:cT},__type__:{object:pT,boolean:cT}},font:{align:{string:dT},color:{string:dT},size:{number:uT},face:{string:dT},background:{string:dT},strokeWidth:{number:uT},strokeColor:{string:dT},vadjust:{number:uT},multi:{boolean:cT,string:dT},bold:{color:{string:dT},size:{number:uT},face:{string:dT},mod:{string:dT},vadjust:{number:uT},__type__:{object:pT,string:dT}},boldital:{color:{string:dT},size:{number:uT},face:{string:dT},mod:{string:dT},vadjust:{number:uT},__type__:{object:pT,string:dT}},ital:{color:{string:dT},size:{number:uT},face:{string:dT},mod:{string:dT},vadjust:{number:uT},__type__:{object:pT,string:dT}},mono:{color:{string:dT},size:{number:uT},face:{string:dT},mod:{string:dT},vadjust:{number:uT},__type__:{object:pT,string:dT}},__type__:{object:pT,string:dT}},group:{string:dT,number:uT,undefined:"undefined"},heightConstraint:{minimum:{number:uT},valign:{string:dT},__type__:{object:pT,boolean:cT,number:uT}},hidden:{boolean:cT},icon:{face:{string:dT},code:{string:dT},size:{number:uT},color:{string:dT},weight:{string:dT,number:uT},__type__:{object:pT}},id:{string:dT,number:uT},image:{selected:{string:dT,undefined:"undefined"},unselected:{string:dT,undefined:"undefined"},__type__:{object:pT,string:dT}},imagePadding:{top:{number:uT},right:{number:uT},bottom:{number:uT},left:{number:uT},__type__:{object:pT,number:uT}},label:{string:dT,undefined:"undefined"},labelHighlightBold:{boolean:cT},level:{number:uT,undefined:"undefined"},margin:{top:{number:uT},right:{number:uT},bottom:{number:uT},left:{number:uT},__type__:{object:pT,number:uT}},mass:{number:uT},physics:{boolean:cT},scaling:{min:{number:uT},max:{number:uT},label:{enabled:{boolean:cT},min:{number:uT},max:{number:uT},maxVisible:{number:uT},drawThreshold:{number:uT},__type__:{object:pT,boolean:cT}},customScalingFunction:{function:"function"},__type__:{object:pT}},shadow:{enabled:{boolean:cT},color:{string:dT},size:{number:uT},x:{number:uT},y:{number:uT},__type__:{object:pT,boolean:cT}},shape:{string:["custom","ellipse","circle","database","box","text","image","circularImage","diamond","dot","star","triangle","triangleDown","square","icon","hexagon"]},ctxRenderer:{function:"function"},shapeProperties:{borderDashes:{boolean:cT,array:fT},borderRadius:{number:uT},interpolation:{boolean:cT},useImageSize:{boolean:cT},useBorderWithImage:{boolean:cT},coordinateOrigin:{string:["center","top-left"]},__type__:{object:pT}},size:{number:uT},title:{string:dT,dom:"dom",undefined:"undefined"},value:{number:uT,undefined:"undefined"},widthConstraint:{minimum:{number:uT},maximum:{number:uT},__type__:{object:pT,boolean:cT,number:uT}},x:{number:uT},y:{number:uT},__type__:{object:pT}},yT={configure:{enabled:{boolean:cT},filter:{boolean:cT,string:dT,array:fT,function:"function"},container:{dom:"dom"},showButton:{boolean:cT},__type__:{object:pT,boolean:cT,string:dT,array:fT,function:"function"}},edges:{arrows:{to:{enabled:{boolean:cT},scaleFactor:{number:uT},type:{string:vT},imageHeight:{number:uT},imageWidth:{number:uT},src:{string:dT},__type__:{object:pT,boolean:cT}},middle:{enabled:{boolean:cT},scaleFactor:{number:uT},type:{string:vT},imageWidth:{number:uT},imageHeight:{number:uT},src:{string:dT},__type__:{object:pT,boolean:cT}},from:{enabled:{boolean:cT},scaleFactor:{number:uT},type:{string:vT},imageWidth:{number:uT},imageHeight:{number:uT},src:{string:dT},__type__:{object:pT,boolean:cT}},__type__:{string:["from","to","middle"],object:pT}},endPointOffset:{from:{number:uT},to:{number:uT},__type__:{object:pT,number:uT}},arrowStrikethrough:{boolean:cT},background:{enabled:{boolean:cT},color:{string:dT},size:{number:uT},dashes:{boolean:cT,array:fT},__type__:{object:pT,boolean:cT}},chosen:{label:{boolean:cT,function:"function"},edge:{boolean:cT,function:"function"},__type__:{object:pT,boolean:cT}},color:{color:{string:dT},highlight:{string:dT},hover:{string:dT},inherit:{string:["from","to","both"],boolean:cT},opacity:{number:uT},__type__:{object:pT,string:dT}},dashes:{boolean:cT,array:fT},font:{color:{string:dT},size:{number:uT},face:{string:dT},background:{string:dT},strokeWidth:{number:uT},strokeColor:{string:dT},align:{string:["horizontal","top","middle","bottom"]},vadjust:{number:uT},multi:{boolean:cT,string:dT},bold:{color:{string:dT},size:{number:uT},face:{string:dT},mod:{string:dT},vadjust:{number:uT},__type__:{object:pT,string:dT}},boldital:{color:{string:dT},size:{number:uT},face:{string:dT},mod:{string:dT},vadjust:{number:uT},__type__:{object:pT,string:dT}},ital:{color:{string:dT},size:{number:uT},face:{string:dT},mod:{string:dT},vadjust:{number:uT},__type__:{object:pT,string:dT}},mono:{color:{string:dT},size:{number:uT},face:{string:dT},mod:{string:dT},vadjust:{number:uT},__type__:{object:pT,string:dT}},__type__:{object:pT,string:dT}},hidden:{boolean:cT},hoverWidth:{function:"function",number:uT},label:{string:dT,undefined:"undefined"},labelHighlightBold:{boolean:cT},length:{number:uT,undefined:"undefined"},physics:{boolean:cT},scaling:{min:{number:uT},max:{number:uT},label:{enabled:{boolean:cT},min:{number:uT},max:{number:uT},maxVisible:{number:uT},drawThreshold:{number:uT},__type__:{object:pT,boolean:cT}},customScalingFunction:{function:"function"},__type__:{object:pT}},selectionWidth:{function:"function",number:uT},selfReferenceSize:{number:uT},selfReference:{size:{number:uT},angle:{number:uT},renderBehindTheNode:{boolean:cT},__type__:{object:pT}},shadow:{enabled:{boolean:cT},color:{string:dT},size:{number:uT},x:{number:uT},y:{number:uT},__type__:{object:pT,boolean:cT}},smooth:{enabled:{boolean:cT},type:{string:["dynamic","continuous","discrete","diagonalCross","straightCross","horizontal","vertical","curvedCW","curvedCCW","cubicBezier"]},roundness:{number:uT},forceDirection:{string:["horizontal","vertical","none"],boolean:cT},__type__:{object:pT,boolean:cT}},title:{string:dT,undefined:"undefined"},width:{number:uT},widthConstraint:{maximum:{number:uT},__type__:{object:pT,boolean:cT,number:uT}},value:{number:uT,undefined:"undefined"},__type__:{object:pT}},groups:{useDefaultGroups:{boolean:cT},__any__:gT,__type__:{object:pT}},interaction:{dragNodes:{boolean:cT},dragView:{boolean:cT},hideEdgesOnDrag:{boolean:cT},hideEdgesOnZoom:{boolean:cT},hideNodesOnDrag:{boolean:cT},hover:{boolean:cT},keyboard:{enabled:{boolean:cT},speed:{x:{number:uT},y:{number:uT},zoom:{number:uT},__type__:{object:pT}},bindToWindow:{boolean:cT},autoFocus:{boolean:cT},__type__:{object:pT,boolean:cT}},multiselect:{boolean:cT},navigationButtons:{boolean:cT},selectable:{boolean:cT},selectConnectedEdges:{boolean:cT},hoverConnectedEdges:{boolean:cT},tooltipDelay:{number:uT},zoomView:{boolean:cT},zoomSpeed:{number:uT},__type__:{object:pT}},layout:{randomSeed:{undefined:"undefined",number:uT,string:dT},improvedLayout:{boolean:cT},clusterThreshold:{number:uT},hierarchical:{enabled:{boolean:cT},levelSeparation:{number:uT},nodeSpacing:{number:uT},treeSpacing:{number:uT},blockShifting:{boolean:cT},edgeMinimization:{boolean:cT},parentCentralization:{boolean:cT},direction:{string:["UD","DU","LR","RL"]},sortMethod:{string:["hubsize","directed"]},shakeTowards:{string:["leaves","roots"]},__type__:{object:pT,boolean:cT}},__type__:{object:pT}},manipulation:{enabled:{boolean:cT},initiallyActive:{boolean:cT},addNode:{boolean:cT,function:"function"},addEdge:{boolean:cT,function:"function"},editNode:{function:"function"},editEdge:{editWithoutDrag:{function:"function"},__type__:{object:pT,boolean:cT,function:"function"}},deleteNode:{boolean:cT,function:"function"},deleteEdge:{boolean:cT,function:"function"},controlNodeStyle:gT,__type__:{object:pT,boolean:cT}},nodes:gT,physics:{enabled:{boolean:cT},barnesHut:{theta:{number:uT},gravitationalConstant:{number:uT},centralGravity:{number:uT},springLength:{number:uT},springConstant:{number:uT},damping:{number:uT},avoidOverlap:{number:uT},__type__:{object:pT}},forceAtlas2Based:{theta:{number:uT},gravitationalConstant:{number:uT},centralGravity:{number:uT},springLength:{number:uT},springConstant:{number:uT},damping:{number:uT},avoidOverlap:{number:uT},__type__:{object:pT}},repulsion:{centralGravity:{number:uT},springLength:{number:uT},springConstant:{number:uT},nodeDistance:{number:uT},damping:{number:uT},__type__:{object:pT}},hierarchicalRepulsion:{centralGravity:{number:uT},springLength:{number:uT},springConstant:{number:uT},nodeDistance:{number:uT},damping:{number:uT},avoidOverlap:{number:uT},__type__:{object:pT}},maxVelocity:{number:uT},minVelocity:{number:uT},solver:{string:["barnesHut","repulsion","hierarchicalRepulsion","forceAtlas2Based"]},stabilization:{enabled:{boolean:cT},iterations:{number:uT},updateInterval:{number:uT},onlyDynamicEdges:{boolean:cT},fit:{boolean:cT},__type__:{object:pT,boolean:cT}},timestep:{number:uT},adaptiveTimestep:{boolean:cT},wind:{x:{number:uT},y:{number:uT},__type__:{object:pT}},__type__:{object:pT,boolean:cT}},autoResize:{boolean:cT},clickToUse:{boolean:cT},locale:{string:dT},locales:{__any__:{any:"any"},__type__:{object:pT}},height:{string:dT},width:{string:dT},__type__:{object:pT}},mT={nodes:{borderWidth:[1,0,10,1],borderWidthSelected:[2,0,10,1],color:{border:["color","#2B7CE9"],background:["color","#97C2FC"],highlight:{border:["color","#2B7CE9"],background:["color","#D2E5FF"]},hover:{border:["color","#2B7CE9"],background:["color","#D2E5FF"]}},opacity:[0,0,1,.1],fixed:{x:!1,y:!1},font:{color:["color","#343434"],size:[14,0,100,1],face:["arial","verdana","tahoma"],background:["color","none"],strokeWidth:[0,0,50,1],strokeColor:["color","#ffffff"]},hidden:!1,labelHighlightBold:!0,physics:!0,scaling:{min:[10,0,200,1],max:[30,0,200,1],label:{enabled:!1,min:[14,0,200,1],max:[30,0,200,1],maxVisible:[30,0,200,1],drawThreshold:[5,0,20,1]}},shadow:{enabled:!1,color:"rgba(0,0,0,0.5)",size:[10,0,20,1],x:[5,-30,30,1],y:[5,-30,30,1]},shape:["ellipse","box","circle","database","diamond","dot","square","star","text","triangle","triangleDown","hexagon"],shapeProperties:{borderDashes:!1,borderRadius:[6,0,20,1],interpolation:!0,useImageSize:!1},size:[25,0,200,1]},edges:{arrows:{to:{enabled:!1,scaleFactor:[1,0,3,.05],type:"arrow"},middle:{enabled:!1,scaleFactor:[1,0,3,.05],type:"arrow"},from:{enabled:!1,scaleFactor:[1,0,3,.05],type:"arrow"}},endPointOffset:{from:[0,-10,10,1],to:[0,-10,10,1]},arrowStrikethrough:!0,color:{color:["color","#848484"],highlight:["color","#848484"],hover:["color","#848484"],inherit:["from","to","both",!0,!1],opacity:[1,0,1,.05]},dashes:!1,font:{color:["color","#343434"],size:[14,0,100,1],face:["arial","verdana","tahoma"],background:["color","none"],strokeWidth:[2,0,50,1],strokeColor:["color","#ffffff"],align:["horizontal","top","middle","bottom"]},hidden:!1,hoverWidth:[1.5,0,5,.1],labelHighlightBold:!0,physics:!0,scaling:{min:[1,0,100,1],max:[15,0,100,1],label:{enabled:!0,min:[14,0,200,1],max:[30,0,200,1],maxVisible:[30,0,200,1],drawThreshold:[5,0,20,1]}},selectionWidth:[1.5,0,5,.1],selfReferenceSize:[20,0,200,1],selfReference:{size:[20,0,200,1],angle:[Math.PI/2,-6*Math.PI,6*Math.PI,Math.PI/8],renderBehindTheNode:!0},shadow:{enabled:!1,color:"rgba(0,0,0,0.5)",size:[10,0,20,1],x:[5,-30,30,1],y:[5,-30,30,1]},smooth:{enabled:!0,type:["dynamic","continuous","discrete","diagonalCross","straightCross","horizontal","vertical","curvedCW","curvedCCW","cubicBezier"],forceDirection:["horizontal","vertical","none"],roundness:[.5,0,1,.05]},width:[1,0,30,1]},layout:{hierarchical:{enabled:!1,levelSeparation:[150,20,500,5],nodeSpacing:[100,20,500,5],treeSpacing:[200,20,500,5],blockShifting:!0,edgeMinimization:!0,parentCentralization:!0,direction:["UD","DU","LR","RL"],sortMethod:["hubsize","directed"],shakeTowards:["leaves","roots"]}},interaction:{dragNodes:!0,dragView:!0,hideEdgesOnDrag:!1,hideEdgesOnZoom:!1,hideNodesOnDrag:!1,hover:!1,keyboard:{enabled:!1,speed:{x:[10,0,40,1],y:[10,0,40,1],zoom:[.02,0,.1,.005]},bindToWindow:!0,autoFocus:!0},multiselect:!1,navigationButtons:!1,selectable:!0,selectConnectedEdges:!0,hoverConnectedEdges:!0,tooltipDelay:[300,0,1e3,25],zoomView:!0,zoomSpeed:[1,.1,2,.1]},manipulation:{enabled:!1,initiallyActive:!1},physics:{enabled:!0,barnesHut:{theta:[.5,.1,1,.05],gravitationalConstant:[-2e3,-3e4,0,50],centralGravity:[.3,0,10,.05],springLength:[95,0,500,5],springConstant:[.04,0,1.2,.005],damping:[.09,0,1,.01],avoidOverlap:[0,0,1,.01]},forceAtlas2Based:{theta:[.5,.1,1,.05],gravitationalConstant:[-50,-500,0,1],centralGravity:[.01,0,1,.005],springLength:[95,0,500,5],springConstant:[.08,0,1.2,.005],damping:[.4,0,1,.01],avoidOverlap:[0,0,1,.01]},repulsion:{centralGravity:[.2,0,10,.05],springLength:[200,0,500,5],springConstant:[.05,0,1.2,.005],nodeDistance:[100,0,500,5],damping:[.09,0,1,.01]},hierarchicalRepulsion:{centralGravity:[.2,0,10,.05],springLength:[100,0,500,5],springConstant:[.01,0,1.2,.005],nodeDistance:[120,0,500,5],damping:[.09,0,1,.01],avoidOverlap:[0,0,1,.01]},maxVelocity:[50,0,150,1],minVelocity:[.1,.01,.5,.01],solver:["barnesHut","forceAtlas2Based","repulsion","hierarchicalRepulsion"],timestep:[.5,.01,1,.01],wind:{x:[0,-10,10,.1],y:[0,-10,10,.1]}}},bT=function(t,e,i){var n;return!(!Nf(t).call(t,"physics")||!Nf(n=mT.physics.solver).call(n,e)||i.physics.solver===e||"wind"===e)},wT=Object.freeze({__proto__:null,configuratorHideOption:bT,allOptions:yT,configureOptions:mT}),kT=function(){function t(){Yd(this,t)}return Kd(t,[{key:"getDistances",value:function(t,e,i){for(var n={},o=t.edges,r=0;r<e.length;r++){var s={};n[e[r]]=s;for(var a=0;a<e.length;a++)s[e[a]]=r==a?0:1e9}for(var h=0;h<i.length;h++){var l=o[i[h]];!0===l.connected&&void 0!==n[l.fromId]&&void 0!==n[l.toId]&&(n[l.fromId][l.toId]=1,n[l.toId][l.fromId]=1)}for(var d=e.length,c=0;c<d;c++)for(var u=e[c],f=n[u],p=0;p<d-1;p++)for(var v=e[p],g=n[v],y=p+1;y<d;y++){var m=e[y],b=n[m],w=Math.min(g[m],g[u]+f[m]);g[m]=w,b[v]=w}return n}}]),t}(),_T=function(){function t(e,i,n){Yd(this,t),this.body=e,this.springLength=i,this.springConstant=n,this.distanceSolver=new kT}return Kd(t,[{key:"setOptions",value:function(t){t&&(t.springLength&&(this.springLength=t.springLength),t.springConstant&&(this.springConstant=t.springConstant))}},{key:"solve",value:function(t,e){var i=arguments.length>2&&void 0!==arguments[2]&&arguments[2],n=this.distanceSolver.getDistances(this.body,t,e);this._createL_matrix(n),this._createK_matrix(n),this._createE_matrix();for(var o=.01,r=1,s=0,a=Math.max(1e3,Math.min(10*this.body.nodeIndices.length,6e3)),h=5,l=1e9,d=0,c=0,u=0,f=0,p=0;l>o&&s<a;){s+=1;var v=this._getHighestEnergyNode(i),g=Kc(v,4);for(d=g[0],l=g[1],c=g[2],u=g[3],f=l,p=0;f>r&&p<h;){p+=1,this._moveNode(d,c,u);var y=this._getEnergy(d),m=Kc(y,3);f=m[0],c=m[1],u=m[2]}}}},{key:"_getHighestEnergyNode",value:function(t){for(var e=this.body.nodeIndices,i=this.body.nodes,n=0,o=e[0],r=0,s=0,a=0;a<e.length;a++){var h=e[a];if(!0!==i[h].predefinedPosition||!0===i[h].isCluster&&!0===t||!0!==i[h].options.fixed.x||!0!==i[h].options.fixed.y){var l=Kc(this._getEnergy(h),3),d=l[0],c=l[1],u=l[2];n<d&&(n=d,o=h,r=c,s=u)}}return[o,n,r,s]}},{key:"_getEnergy",value:function(t){var e=Kc(this.E_sums[t],2),i=e[0],n=e[1];return[Math.sqrt(Math.pow(i,2)+Math.pow(n,2)),i,n]}},{key:"_moveNode",value:function(t,e,i){for(var n=this.body.nodeIndices,o=this.body.nodes,r=0,s=0,a=0,h=o[t].x,l=o[t].y,d=this.K_matrix[t],c=this.L_matrix[t],u=0;u<n.length;u++){var f=n[u];if(f!==t){var p=o[f].x,v=o[f].y,g=d[f],y=c[f],m=1/Math.pow(Math.pow(h-p,2)+Math.pow(l-v,2),1.5);r+=g*(1-y*Math.pow(l-v,2)*m),s+=g*(y*(h-p)*(l-v)*m),a+=g*(1-y*Math.pow(h-p,2)*m)}}var b=(e/r+i/s)/(s/r-a/s),w=-(s*b+e)/r;o[t].x+=w,o[t].y+=b,this._updateE_matrix(t)}},{key:"_createL_matrix",value:function(t){var e=this.body.nodeIndices,i=this.springLength;this.L_matrix=[];for(var n=0;n<e.length;n++){this.L_matrix[e[n]]={};for(var o=0;o<e.length;o++)this.L_matrix[e[n]][e[o]]=i*t[e[n]][e[o]]}}},{key:"_createK_matrix",value:function(t){var e=this.body.nodeIndices,i=this.springConstant;this.K_matrix=[];for(var n=0;n<e.length;n++){this.K_matrix[e[n]]={};for(var o=0;o<e.length;o++)this.K_matrix[e[n]][e[o]]=i*Math.pow(t[e[n]][e[o]],-2)}}},{key:"_createE_matrix",value:function(){var t=this.body.nodeIndices,e=this.body.nodes;this.E_matrix={},this.E_sums={};for(var i=0;i<t.length;i++)this.E_matrix[t[i]]=[];for(var n=0;n<t.length;n++){for(var o=t[n],r=e[o].x,s=e[o].y,a=0,h=0,l=n;l<t.length;l++){var d=t[l];if(d!==o){var c=e[d].x,u=e[d].y,f=1/Math.sqrt(Math.pow(r-c,2)+Math.pow(s-u,2));this.E_matrix[o][l]=[this.K_matrix[o][d]*(r-c-this.L_matrix[o][d]*(r-c)*f),this.K_matrix[o][d]*(s-u-this.L_matrix[o][d]*(s-u)*f)],this.E_matrix[d][n]=this.E_matrix[o][l],a+=this.E_matrix[o][l][0],h+=this.E_matrix[o][l][1]}}this.E_sums[o]=[a,h]}}},{key:"_updateE_matrix",value:function(t){for(var e=this.body.nodeIndices,i=this.body.nodes,n=this.E_matrix[t],o=this.K_matrix[t],r=this.L_matrix[t],s=i[t].x,a=i[t].y,h=0,l=0,d=0;d<e.length;d++){var c=e[d];if(c!==t){var u=n[d],f=u[0],p=u[1],v=i[c].x,g=i[c].y,y=1/Math.sqrt(Math.pow(s-v,2)+Math.pow(a-g,2)),m=o[c]*(s-v-r[c]*(s-v)*y),b=o[c]*(a-g-r[c]*(a-g)*y);n[d]=[m,b],h+=m,l+=b;var w=this.E_sums[c];w[0]+=m-f,w[1]+=b-p}}this.E_sums[t]=[h,l]}}]),t}();function xT(t,e,i){var n,o,r,s,a=this;if(!(this instanceof xT))throw new SyntaxError("Constructor must be called with the new operator");this.options={},this.defaultOptions={locale:"en",locales:Tb,clickToUse:!1},un(this.options,this.defaultOptions),this.body={container:t,nodes:{},nodeIndices:[],edges:{},edgeIndices:[],emitter:{on:zn(n=this.on).call(n,this),off:zn(o=this.off).call(o,this),emit:zn(r=this.emit).call(r,this),once:zn(s=this.once).call(s,this)},eventListeners:{onTap:function(){},onTouch:function(){},onDoubleTap:function(){},onHold:function(){},onDragStart:function(){},onDrag:function(){},onDragEnd:function(){},onMouseWheel:function(){},onPinch:function(){},onMouseMove:function(){},onRelease:function(){},onContext:function(){}},data:{nodes:null,edges:null},functions:{createNode:function(){},createEdge:function(){},getPointer:function(){}},modules:{},view:{scale:1,translation:{x:0,y:0}},selectionBox:{show:!1,position:{start:{x:0,y:0},end:{x:0,y:0}}}},this.bindEventListeners(),this.images=new Pb((function(){return a.body.emitter.emit("_requestRedraw")})),this.groups=new tk,this.canvas=new zC(this.body),this.selectionHandler=new HS(this.body,this.canvas),this.interactionHandler=new WC(this.body,this.canvas,this.selectionHandler),this.view=new FC(this.body,this.canvas),this.renderer=new PC(this.body,this.canvas),this.physics=new xC(this.body),this.layoutEngine=new sT(this.body),this.clustering=new SC(this.body),this.manipulation=new lT(this.body,this.canvas,this.selectionHandler,this.interactionHandler),this.nodesHandler=new gO(this.body,this.images,this.groups,this.layoutEngine),this.edgesHandler=new uC(this.body,this.images,this.groups),this.body.modules.kamadaKawai=new _T(this.body,150,.05),this.body.modules.clustering=this.clustering,this.canvas._create(),this.setOptions(i),this.setData(e)}function ET(t){for(var e in t)Object.prototype.hasOwnProperty.call(t,e)&&(t[e].redundant=t[e].used,t[e].used=[])}function OT(t){for(var e in t)if(Object.prototype.hasOwnProperty.call(t,e)&&t[e].redundant){for(var i=0;i<t[e].redundant.length;i++)t[e].redundant[i].parentNode.removeChild(t[e].redundant[i]);t[e].redundant=[]}}function CT(t,e,i){var n;return Object.prototype.hasOwnProperty.call(e,t)?e[t].redundant.length>0?(n=e[t].redundant[0],e[t].redundant.shift()):(n=document.createElementNS("http://www.w3.org/2000/svg",t),i.appendChild(n)):(n=document.createElementNS("http://www.w3.org/2000/svg",t),e[t]={used:[],redundant:[]},i.appendChild(n)),e[t].used.push(n),n}Wn(xT.prototype),xT.prototype.setOptions=function(t){var e=this;if(null===t&&(t=void 0),void 0!==t){!0===Um.validate(t,yT)&&console.error("%cErrors have been found in the supplied options object.",Vm);if(em(["locale","locales","clickToUse"],this.options,t),void 0!==t.locale&&(t.locale=function(t,e){try{var i=Kc(e.split(/[-_ /]/,2),2),n=i[0],o=i[1],r=null!=n?n.toLowerCase():null,s=null!=o?o.toUpperCase():null;if(r&&s){var a,h=r+"-"+s;if(Object.prototype.hasOwnProperty.call(t,h))return h;console.warn(su(a="Unknown variant ".concat(s," of language ")).call(a,r,"."))}if(r){var l=r;if(Object.prototype.hasOwnProperty.call(t,l))return l;console.warn("Unknown language ".concat(r))}return console.warn("Unknown locale ".concat(e,", falling back to English.")),"en"}catch(t){return console.error(t),console.warn("Unexpected error while normalizing locale ".concat(e,", falling back to English.")),"en"}}(t.locales||this.options.locales,t.locale)),t=this.layoutEngine.setOptions(t.layout,t),this.canvas.setOptions(t),this.groups.setOptions(t.groups),this.nodesHandler.setOptions(t.nodes),this.edgesHandler.setOptions(t.edges),this.physics.setOptions(t.physics),this.manipulation.setOptions(t.manipulation,t,this.options),this.interactionHandler.setOptions(t.interaction),this.renderer.setOptions(t.interaction),this.selectionHandler.setOptions(t.interaction),void 0!==t.groups&&this.body.emitter.emit("refreshNodes"),"configure"in t&&(this.configurator||(this.configurator=new Hm(this,this.body.container,mT,this.canvas.pixelRatio,bT)),this.configurator.setOptions(t.configure)),this.configurator&&!0===this.configurator.options.enabled){var i={nodes:{},edges:{},layout:{},interaction:{},manipulation:{},physics:{},global:{}};nm(i.nodes,this.nodesHandler.options),nm(i.edges,this.edgesHandler.options),nm(i.layout,this.layoutEngine.options),nm(i.interaction,this.selectionHandler.options),nm(i.interaction,this.renderer.options),nm(i.interaction,this.interactionHandler.options),nm(i.manipulation,this.manipulation.options),nm(i.physics,this.physics.options),nm(i.global,this.canvas.options),nm(i.global,this.options),this.configurator.setModuleOptions(i)}void 0!==t.clickToUse?!0===t.clickToUse?void 0===this.activator&&(this.activator=new Rm(this.canvas.frame),this.activator.on("change",(function(){e.body.emitter.emit("activate")}))):(void 0!==this.activator&&(this.activator.destroy(),delete this.activator),this.body.emitter.emit("activate")):this.body.emitter.emit("activate"),this.canvas.setSize(),this.body.emitter.emit("startSimulation")}},xT.prototype._updateVisibleIndices=function(){var t=this.body.nodes,e=this.body.edges;for(var i in this.body.nodeIndices=[],this.body.edgeIndices=[],t)Object.prototype.hasOwnProperty.call(t,i)&&(this.clustering._isClusteredNode(i)||!1!==t[i].options.hidden||this.body.nodeIndices.push(t[i].id));for(var n in e)if(Object.prototype.hasOwnProperty.call(e,n)){var o=e[n],r=t[o.fromId],s=t[o.toId],a=void 0!==r&&void 0!==s;!this.clustering._isClusteredEdge(n)&&!1===o.options.hidden&&a&&!1===r.options.hidden&&!1===s.options.hidden&&this.body.edgeIndices.push(o.id)}},xT.prototype.bindEventListeners=function(){var t=this;this.body.emitter.on("_dataChanged",(function(){t.edgesHandler._updateState(),t.body.emitter.emit("_dataUpdated")})),this.body.emitter.on("_dataUpdated",(function(){t.clustering._updateState(),t._updateVisibleIndices(),t._updateValueRange(t.body.nodes),t._updateValueRange(t.body.edges),t.body.emitter.emit("startSimulation"),t.body.emitter.emit("_requestRedraw")}))},xT.prototype.setData=function(t){if(this.body.emitter.emit("resetPhysics"),this.body.emitter.emit("_resetData"),this.selectionHandler.unselectAll(),t&&t.dot&&(t.nodes||t.edges))throw new SyntaxError('Data must contain either parameter "dot" or  parameter pair "nodes" and "edges", but not both.');if(this.setOptions(t&&t.options),t&&t.dot){console.warn("The dot property has been deprecated. Please use the static convertDot method to convert DOT into vis.network format and use the normal data format with nodes and edges. This converter is used like this: var data = vis.network.convertDot(dotString);");var e=Eb(t.dot);this.setData(e)}else if(t&&t.gephi){console.warn("The gephi property has been deprecated. Please use the static convertGephi method to convert gephi into vis.network format and use the normal data format with nodes and edges. This converter is used like this: var data = vis.network.convertGephi(gephiJson);");var i=Cb(t.gephi);this.setData(i)}else this.nodesHandler.setData(t&&t.nodes,!0),this.edgesHandler.setData(t&&t.edges,!0),this.body.emitter.emit("_dataChanged"),this.body.emitter.emit("_dataLoaded"),this.body.emitter.emit("initPhysics")},xT.prototype.destroy=function(){for(var t in this.body.emitter.emit("destroy"),this.body.emitter.off(),this.off(),delete this.groups,delete this.canvas,delete this.selectionHandler,delete this.interactionHandler,delete this.view,delete this.renderer,delete this.physics,delete this.layoutEngine,delete this.clustering,delete this.manipulation,delete this.nodesHandler,delete this.edgesHandler,delete this.configurator,delete this.images,this.body.nodes)Object.prototype.hasOwnProperty.call(this.body.nodes,t)&&delete this.body.nodes[t];for(var e in this.body.edges)Object.prototype.hasOwnProperty.call(this.body.edges,e)&&delete this.body.edges[e];Ky(this.body.container)},xT.prototype._updateValueRange=function(t){var e,i=void 0,n=void 0,o=0;for(e in t)if(Object.prototype.hasOwnProperty.call(t,e)){var r=t[e].getValue();void 0!==r&&(i=void 0===i?r:Math.min(r,i),n=void 0===n?r:Math.max(r,n),o+=r)}if(void 0!==i&&void 0!==n)for(e in t)Object.prototype.hasOwnProperty.call(t,e)&&t[e].setValueRange(i,n,o)},xT.prototype.isActive=function(){return!this.activator||this.activator.active},xT.prototype.setSize=function(){return this.canvas.setSize.apply(this.canvas,arguments)},xT.prototype.canvasToDOM=function(){return this.canvas.canvasToDOM.apply(this.canvas,arguments)},xT.prototype.DOMtoCanvas=function(){return this.canvas.DOMtoCanvas.apply(this.canvas,arguments)},xT.prototype.findNode=function(){return this.clustering.findNode.apply(this.clustering,arguments)},xT.prototype.isCluster=function(){return this.clustering.isCluster.apply(this.clustering,arguments)},xT.prototype.openCluster=function(){return this.clustering.openCluster.apply(this.clustering,arguments)},xT.prototype.cluster=function(){return this.clustering.cluster.apply(this.clustering,arguments)},xT.prototype.getNodesInCluster=function(){return this.clustering.getNodesInCluster.apply(this.clustering,arguments)},xT.prototype.clusterByConnection=function(){return this.clustering.clusterByConnection.apply(this.clustering,arguments)},xT.prototype.clusterByHubsize=function(){return this.clustering.clusterByHubsize.apply(this.clustering,arguments)},xT.prototype.updateClusteredNode=function(){return this.clustering.updateClusteredNode.apply(this.clustering,arguments)},xT.prototype.getClusteredEdges=function(){return this.clustering.getClusteredEdges.apply(this.clustering,arguments)},xT.prototype.getBaseEdge=function(){return this.clustering.getBaseEdge.apply(this.clustering,arguments)},xT.prototype.getBaseEdges=function(){return this.clustering.getBaseEdges.apply(this.clustering,arguments)},xT.prototype.updateEdge=function(){return this.clustering.updateEdge.apply(this.clustering,arguments)},xT.prototype.clusterOutliers=function(){return this.clustering.clusterOutliers.apply(this.clustering,arguments)},xT.prototype.getSeed=function(){return this.layoutEngine.getSeed.apply(this.layoutEngine,arguments)},xT.prototype.enableEditMode=function(){return this.manipulation.enableEditMode.apply(this.manipulation,arguments)},xT.prototype.disableEditMode=function(){return this.manipulation.disableEditMode.apply(this.manipulation,arguments)},xT.prototype.addNodeMode=function(){return this.manipulation.addNodeMode.apply(this.manipulation,arguments)},xT.prototype.editNode=function(){return this.manipulation.editNode.apply(this.manipulation,arguments)},xT.prototype.editNodeMode=function(){return console.warn("Deprecated: Please use editNode instead of editNodeMode."),this.manipulation.editNode.apply(this.manipulation,arguments)},xT.prototype.addEdgeMode=function(){return this.manipulation.addEdgeMode.apply(this.manipulation,arguments)},xT.prototype.editEdgeMode=function(){return this.manipulation.editEdgeMode.apply(this.manipulation,arguments)},xT.prototype.deleteSelected=function(){return this.manipulation.deleteSelected.apply(this.manipulation,arguments)},xT.prototype.getPositions=function(){return this.nodesHandler.getPositions.apply(this.nodesHandler,arguments)},xT.prototype.getPosition=function(){return this.nodesHandler.getPosition.apply(this.nodesHandler,arguments)},xT.prototype.storePositions=function(){return this.nodesHandler.storePositions.apply(this.nodesHandler,arguments)},xT.prototype.moveNode=function(){return this.nodesHandler.moveNode.apply(this.nodesHandler,arguments)},xT.prototype.getBoundingBox=function(){return this.nodesHandler.getBoundingBox.apply(this.nodesHandler,arguments)},xT.prototype.getConnectedNodes=function(t){return void 0!==this.body.nodes[t]?this.nodesHandler.getConnectedNodes.apply(this.nodesHandler,arguments):this.edgesHandler.getConnectedNodes.apply(this.edgesHandler,arguments)},xT.prototype.getConnectedEdges=function(){return this.nodesHandler.getConnectedEdges.apply(this.nodesHandler,arguments)},xT.prototype.startSimulation=function(){return this.physics.startSimulation.apply(this.physics,arguments)},xT.prototype.stopSimulation=function(){return this.physics.stopSimulation.apply(this.physics,arguments)},xT.prototype.stabilize=function(){return this.physics.stabilize.apply(this.physics,arguments)},xT.prototype.getSelection=function(){return this.selectionHandler.getSelection.apply(this.selectionHandler,arguments)},xT.prototype.setSelection=function(){return this.selectionHandler.setSelection.apply(this.selectionHandler,arguments)},xT.prototype.getSelectedNodes=function(){return this.selectionHandler.getSelectedNodeIds.apply(this.selectionHandler,arguments)},xT.prototype.getSelectedEdges=function(){return this.selectionHandler.getSelectedEdgeIds.apply(this.selectionHandler,arguments)},xT.prototype.getNodeAt=function(){var t=this.selectionHandler.getNodeAt.apply(this.selectionHandler,arguments);return void 0!==t&&void 0!==t.id?t.id:t},xT.prototype.getEdgeAt=function(){var t=this.selectionHandler.getEdgeAt.apply(this.selectionHandler,arguments);return void 0!==t&&void 0!==t.id?t.id:t},xT.prototype.selectNodes=function(){return this.selectionHandler.selectNodes.apply(this.selectionHandler,arguments)},xT.prototype.selectEdges=function(){return this.selectionHandler.selectEdges.apply(this.selectionHandler,arguments)},xT.prototype.unselectAll=function(){this.selectionHandler.unselectAll.apply(this.selectionHandler,arguments),this.selectionHandler.commitWithoutEmitting.apply(this.selectionHandler),this.redraw()},xT.prototype.redraw=function(){return this.renderer.redraw.apply(this.renderer,arguments)},xT.prototype.getScale=function(){return this.view.getScale.apply(this.view,arguments)},xT.prototype.getViewPosition=function(){return this.view.getViewPosition.apply(this.view,arguments)},xT.prototype.fit=function(){return this.view.fit.apply(this.view,arguments)},xT.prototype.moveTo=function(){return this.view.moveTo.apply(this.view,arguments)},xT.prototype.focus=function(){return this.view.focus.apply(this.view,arguments)},xT.prototype.releaseNode=function(){return this.view.releaseNode.apply(this.view,arguments)},xT.prototype.getOptionsFromConfigurator=function(){var t={};return this.configurator&&(t=this.configurator.getOptions.apply(this.configurator)),t};var ST=Object.freeze({__proto__:null,prepareElements:ET,cleanupElements:OT,resetElements:function(t){ET(t),OT(t),ET(t)},getSVGElement:CT,getDOMElement:function(t,e,i,n){var o;return Object.prototype.hasOwnProperty.call(e,t)?e[t].redundant.length>0?(o=e[t].redundant[0],e[t].redundant.shift()):(o=document.createElement(t),void 0!==n?i.insertBefore(o,n):i.appendChild(o)):(o=document.createElement(t),e[t]={used:[],redundant:[]},void 0!==n?i.insertBefore(o,n):i.appendChild(o)),e[t].used.push(o),o},drawPoint:function(t,e,i,n,o,r){var s;if("circle"==i.style?((s=CT("circle",n,o)).setAttributeNS(null,"cx",t),s.setAttributeNS(null,"cy",e),s.setAttributeNS(null,"r",.5*i.size)):((s=CT("rect",n,o)).setAttributeNS(null,"x",t-.5*i.size),s.setAttributeNS(null,"y",e-.5*i.size),s.setAttributeNS(null,"width",i.size),s.setAttributeNS(null,"height",i.size)),void 0!==i.styles&&s.setAttributeNS(null,"style",i.styles),s.setAttributeNS(null,"class",i.className+" vis-point"),r){var a=CT("text",n,o);r.xOffset&&(t+=r.xOffset),r.yOffset&&(e+=r.yOffset),r.content&&(a.textContent=r.content),r.className&&a.setAttributeNS(null,"class",r.className+" vis-label"),a.setAttributeNS(null,"x",t),a.setAttributeNS(null,"y",e)}return s},drawBar:function(t,e,i,n,o,r,s,a){if(0!=n){n<0&&(e-=n*=-1);var h=CT("rect",r,s);h.setAttributeNS(null,"x",t-.5*i),h.setAttributeNS(null,"y",e),h.setAttributeNS(null,"width",i),h.setAttributeNS(null,"height",n),h.setAttributeNS(null,"class",o),a&&h.setAttributeNS(null,"style",a)}}}),TT={Images:Pb,dotparser:Ob,gephiParser:Sb,allOptions:wT,convertDot:Eb,convertGephi:Cb},MT=Object.freeze({__proto__:null,network:TT,DOMutil:ST,util:Ym,data:Jx,Hammer:Wm,keycharm:jC,DataSet:Kx,DataView:$x,Queue:Yx,Network:xT});t.DOMutil=ST,t.DataSet=Kx,t.DataView=$x,t.Hammer=Wm,t.Network=xT,t.Queue=Yx,t.data=Jx,t.default=MT,t.keycharm=jC,t.network=TT,t.util=Ym,Object.defineProperty(t,"__esModule",{value:!0})}));
//# sourceMappingURL=vis-network.min.js.map</script>
            
        
<center>
<h1></h1>
</center>

<!-- <link rel="stylesheet" href="../node_modules/vis/dist/vis.min.css" type="text/css" />
<script type="text/javascript" src="../node_modules/vis/dist/vis.js"> </script>-->
        <link
          href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.0-beta3/dist/css/bootstrap.min.css"
          rel="stylesheet"
          integrity="sha384-eOJMYsd53ii+scO/bJGFsiCZc+5NDVN2yr8+0RDqr0Ql0h+rP48ckxlpbzKgwra6"
          crossorigin="anonymous"
        />
        <script
          src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.0-beta3/dist/js/bootstrap.bundle.min.js"
          integrity="sha384-JEW9xMcG8R+pH31jmWH6WWP0WintQrMb4s7ZOdauHnUtxwoG2vI5DkLtS3qm9Ekf"
          crossorigin="anonymous"
        ></script>


        <center>
          <h1></h1>
        </center>
        <style type="text/css">

             #mynetwork {
                 width: 2000px;
                 height: 800px;
                 background-color: #ffffff;
                 border: 1px solid lightgray;
                 position: relative;
                 float: left;
             }

             
             #loadingBar {
                 position:absolute;
                 top:0px;
                 left:0px;
                 width: 2000px;
                 height: 800px;
                 background-color:rgba(200,200,200,0.8);
                 -webkit-transition: all 0.5s ease;
                 -moz-transition: all 0.5s ease;
                 -ms-transition: all 0.5s ease;
                 -o-transition: all 0.5s ease;
                 transition: all 0.5s ease;
                 opacity:1;
             }

             #bar {
                 position:absolute;
                 top:0px;
                 left:0px;
                 width:20px;
                 height:20px;
                 margin:auto auto auto auto;
                 border-radius:11px;
                 border:2px solid rgba(30,30,30,0.05);
                 background: rgb(0, 173, 246); /* Old browsers */
                 box-shadow: 2px 0px 4px rgba(0,0,0,0.4);
             }

             #border {
                 position:absolute;
                 top:10px;
                 left:10px;
                 width:500px;
                 height:23px;
                 margin:auto auto auto auto;
                 box-shadow: 0px 0px 4px rgba(0,0,0,0.2);
                 border-radius:10px;
             }

             #text {
                 position:absolute;
                 top:8px;
                 left:530px;
                 width:30px;
                 height:50px;
                 margin:auto auto auto auto;
                 font-size:22px;
                 color: #000000;
             }

             div.outerBorder {
                 position:relative;
                 top:400px;
                 width:600px;
                 height:44px;
                 margin:auto auto auto auto;
                 border:8px solid rgba(0,0,0,0.1);
                 background: rgb(252,252,252); /* Old browsers */
                 background: -moz-linear-gradient(top,  rgba(252,252,252,1) 0%, rgba(237,237,237,1) 100%); /* FF3.6+ */
                 background: -webkit-gradient(linear, left top, left bottom, color-stop(0%,rgba(252,252,252,1)), color-stop(100%,rgba(237,237,237,1))); /* Chrome,Safari4+ */
                 background: -webkit-linear-gradient(top,  rgba(252,252,252,1) 0%,rgba(237,237,237,1) 100%); /* Chrome10+,Safari5.1+ */
                 background: -o-linear-gradient(top,  rgba(252,252,252,1) 0%,rgba(237,237,237,1) 100%); /* Opera 11.10+ */
                 background: -ms-linear-gradient(top,  rgba(252,252,252,1) 0%,rgba(237,237,237,1) 100%); /* IE10+ */
                 background: linear-gradient(to bottom,  rgba(252,252,252,1) 0%,rgba(237,237,237,1) 100%); /* W3C */
                 filter: progid:DXImageTransform.Microsoft.gradient( startColorstr='#fcfcfc', endColorstr='#ededed',GradientType=0 ); /* IE6-9 */
                 border-radius:72px;
                 box-shadow: 0px 0px 10px rgba(0,0,0,0.2);
             }
             

             

             
        </style>
    </head>


    <body>
        <div class="card" style="width: 100%">
            
            
            <div id="mynetwork" class="card-body"></div>
        </div>

        
            <div id="loadingBar">
              <div class="outerBorder">
                <div id="text">0%</div>
                <div id="border">
                  <div id="bar"></div>
                </div>
              </div>
            </div>
        
        

        <script type="text/javascript">

              // initialize global variables.
              var edges;
              var nodes;
              var allNodes;
              var allEdges;
              var nodeColors;
              var originalNodes;
              var network;
              var container;
              var options, data;
              var filter = {
                  item : '',
                  property : '',
                  value : []
              };

              

              

              // This method is responsible for drawing the graph, returns the drawn network
              function drawGraph() {
                  var container = document.getElementById('mynetwork');

                  

                  // parsing and collecting nodes and edges from the python
                  nodes = new vis.DataSet([{"color": "blue", "id": 89, "label": "Page_89", "shape": "dot", "size": 10, "title": "Page_89"}, {"color": "green", "id": "text_0", "label": "57\nIntroducing pods\n Therefore, you need to run each process in its own container. That\u2019s how Docker\nand Kubernetes are meant to be used. \n3.1.2\nUnderstanding pods\nBecause you\u2019re not supposed to group multiple processes into a single container, it\u2019s\nobvious you need another higher-level construct that will allow you to bind containers\ntogether and manage them as a single unit. This is the reasoning behind pods. \n A pod of containers allows you to run closely related processes together and pro-\nvide them with (almost) the same environment as if they were all running in a single\ncontainer, while keeping them somewhat isolated. This way, you get the best of both\nworlds. You can take advantage of all the features containers provide, while at the\nsame time giving the processes the illusion of running together. \nUNDERSTANDING THE PARTIAL ISOLATION BETWEEN CONTAINERS OF THE SAME POD\nIn the previous chapter, you learned that containers are completely isolated from\neach other, but now you see that you want to isolate groups of containers instead of\nindividual ones. You want containers inside each group to share certain resources,\nalthough not all, so that they\u2019re not fully isolated. Kubernetes achieves this by config-\nuring Docker to have all containers of a pod share the same set of Linux namespaces\ninstead of each container having its own set. \n Because all containers of a pod run under the same Network and UTS namespaces\n(we\u2019re talking about Linux namespaces here), they all share the same hostname and\nnetwork interfaces. Similarly, all containers of a pod run under the same IPC namespace\nand can communicate through IPC. In the latest Kubernetes and Docker versions, they\ncan also share the same PID namespace, but that feature isn\u2019t enabled by default. \nNOTE\nWhen containers of the same pod use separate PID namespaces, you\nonly see the container\u2019s own processes when running ps aux in the container.\nBut when it comes to the filesystem, things are a little different. Because most of the\ncontainer\u2019s filesystem comes from the container image, by default, the filesystem of\neach container is fully isolated from other containers. However, it\u2019s possible to have\nthem share file directories using a Kubernetes concept called a Volume, which we\u2019ll\ntalk about in chapter 6.\nUNDERSTANDING HOW CONTAINERS SHARE THE SAME IP AND PORT SPACE\nOne thing to stress here is that because containers in a pod run in the same Network\nnamespace, they share the same IP address and port space. This means processes run-\nning in containers of the same pod need to take care not to bind to the same port\nnumbers or they\u2019ll run into port conflicts. But this only concerns containers in the\nsame pod. Containers of different pods can never run into port conflicts, because\neach pod has a separate port space. All the containers in a pod also have the same\nloopback network interface, so a container can communicate with other containers in\nthe same pod through localhost.\n \n", "shape": "dot", "size": 10, "title": "57\nIntroducing pods\n Therefore, you need to run each process in its own container. That\u2019s how Docker\nand Kubernetes are meant to be used. \n3.1.2\nUnderstanding pods\nBecause you\u2019re not supposed to group multiple processes into a single container, it\u2019s\nobvious you need another higher-level construct that will allow you to bind containers\ntogether and manage them as a single unit. This is the reasoning behind pods. \n A pod of containers allows you to run closely related processes together and pro-\nvide them with (almost) the same environment as if they were all running in a single\ncontainer, while keeping them somewhat isolated. This way, you get the best of both\nworlds. You can take advantage of all the features containers provide, while at the\nsame time giving the processes the illusion of running together. \nUNDERSTANDING THE PARTIAL ISOLATION BETWEEN CONTAINERS OF THE SAME POD\nIn the previous chapter, you learned that containers are completely isolated from\neach other, but now you see that you want to isolate groups of containers instead of\nindividual ones. You want containers inside each group to share certain resources,\nalthough not all, so that they\u2019re not fully isolated. Kubernetes achieves this by config-\nuring Docker to have all containers of a pod share the same set of Linux namespaces\ninstead of each container having its own set. \n Because all containers of a pod run under the same Network and UTS namespaces\n(we\u2019re talking about Linux namespaces here), they all share the same hostname and\nnetwork interfaces. Similarly, all containers of a pod run under the same IPC namespace\nand can communicate through IPC. In the latest Kubernetes and Docker versions, they\ncan also share the same PID namespace, but that feature isn\u2019t enabled by default. \nNOTE\nWhen containers of the same pod use separate PID namespaces, you\nonly see the container\u2019s own processes when running ps aux in the container.\nBut when it comes to the filesystem, things are a little different. Because most of the\ncontainer\u2019s filesystem comes from the container image, by default, the filesystem of\neach container is fully isolated from other containers. However, it\u2019s possible to have\nthem share file directories using a Kubernetes concept called a Volume, which we\u2019ll\ntalk about in chapter 6.\nUNDERSTANDING HOW CONTAINERS SHARE THE SAME IP AND PORT SPACE\nOne thing to stress here is that because containers in a pod run in the same Network\nnamespace, they share the same IP address and port space. This means processes run-\nning in containers of the same pod need to take care not to bind to the same port\nnumbers or they\u2019ll run into port conflicts. But this only concerns containers in the\nsame pod. Containers of different pods can never run into port conflicts, because\neach pod has a separate port space. All the containers in a pod also have the same\nloopback network interface, so a container can communicate with other containers in\nthe same pod through localhost.\n \n"}, {"color": "#97c2fc", "id": 1, "label": 1, "shape": "dot", "size": 10}, {"color": "blue", "id": 90, "label": "Page_90", "shape": "dot", "size": 10, "title": "Page_90"}, {"color": "blue", "id": 91, "label": "Page_91", "shape": "dot", "size": 10, "title": "Page_91"}, {"color": "blue", "id": 92, "label": "Page_92", "shape": "dot", "size": 10, "title": "Page_92"}, {"color": "blue", "id": 93, "label": "Page_93", "shape": "dot", "size": 10, "title": "Page_93"}, {"color": "blue", "id": 94, "label": "Page_94", "shape": "dot", "size": 10, "title": "Page_94"}, {"color": "blue", "id": 95, "label": "Page_95", "shape": "dot", "size": 10, "title": "Page_95"}, {"color": "blue", "id": 96, "label": "Page_96", "shape": "dot", "size": 10, "title": "Page_96"}, {"color": "blue", "id": 97, "label": "Page_97", "shape": "dot", "size": 10, "title": "Page_97"}, {"color": "blue", "id": 98, "label": "Page_98", "shape": "dot", "size": 10, "title": "Page_98"}, {"color": "blue", "id": 99, "label": "Page_99", "shape": "dot", "size": 10, "title": "Page_99"}, {"color": "blue", "id": 100, "label": "Page_100", "shape": "dot", "size": 10, "title": "Page_100"}, {"color": "blue", "id": 101, "label": "Page_101", "shape": "dot", "size": 10, "title": "Page_101"}, {"color": "blue", "id": 102, "label": "Page_102", "shape": "dot", "size": 10, "title": "Page_102"}, {"color": "blue", "id": 103, "label": "Page_103", "shape": "dot", "size": 10, "title": "Page_103"}, {"color": "blue", "id": 104, "label": "Page_104", "shape": "dot", "size": 10, "title": "Page_104"}, {"color": "blue", "id": 105, "label": "Page_105", "shape": "dot", "size": 10, "title": "Page_105"}, {"color": "blue", "id": 106, "label": "Page_106", "shape": "dot", "size": 10, "title": "Page_106"}, {"color": "blue", "id": 107, "label": "Page_107", "shape": "dot", "size": 10, "title": "Page_107"}, {"color": "blue", "id": 108, "label": "Page_108", "shape": "dot", "size": 10, "title": "Page_108"}, {"color": "blue", "id": 109, "label": "Page_109", "shape": "dot", "size": 10, "title": "Page_109"}, {"color": "blue", "id": 110, "label": "Page_110", "shape": "dot", "size": 10, "title": "Page_110"}, {"color": "blue", "id": 111, "label": "Page_111", "shape": "dot", "size": 10, "title": "Page_111"}, {"color": "blue", "id": 112, "label": "Page_112", "shape": "dot", "size": 10, "title": "Page_112"}, {"color": "blue", "id": 113, "label": "Page_113", "shape": "dot", "size": 10, "title": "Page_113"}, {"color": "blue", "id": 114, "label": "Page_114", "shape": "dot", "size": 10, "title": "Page_114"}, {"color": "blue", "id": 115, "label": "Page_115", "shape": "dot", "size": 10, "title": "Page_115"}, {"color": "blue", "id": 116, "label": "Page_116", "shape": "dot", "size": 10, "title": "Page_116"}, {"color": "blue", "id": 117, "label": "Page_117", "shape": "dot", "size": 10, "title": "Page_117"}, {"color": "blue", "id": 118, "label": "Page_118", "shape": "dot", "size": 10, "title": "Page_118"}, {"color": "blue", "id": 119, "label": "Page_119", "shape": "dot", "size": 10, "title": "Page_119"}, {"color": "blue", "id": 120, "label": "Page_120", "shape": "dot", "size": 10, "title": "Page_120"}, {"color": "blue", "id": 121, "label": "Page_121", "shape": "dot", "size": 10, "title": "Page_121"}, {"color": "blue", "id": 122, "label": "Page_122", "shape": "dot", "size": 10, "title": "Page_122"}, {"color": "blue", "id": 123, "label": "Page_123", "shape": "dot", "size": 10, "title": "Page_123"}, {"color": "blue", "id": 124, "label": "Page_124", "shape": "dot", "size": 10, "title": "Page_124"}, {"color": "blue", "id": 125, "label": "Page_125", "shape": "dot", "size": 10, "title": "Page_125"}, {"color": "blue", "id": 126, "label": "Page_126", "shape": "dot", "size": 10, "title": "Page_126"}, {"color": "blue", "id": 127, "label": "Page_127", "shape": "dot", "size": 10, "title": "Page_127"}, {"color": "blue", "id": 128, "label": "Page_128", "shape": "dot", "size": 10, "title": "Page_128"}, {"color": "blue", "id": 129, "label": "Page_129", "shape": "dot", "size": 10, "title": "Page_129"}, {"color": "blue", "id": 130, "label": "Page_130", "shape": "dot", "size": 10, "title": "Page_130"}, {"color": "blue", "id": 131, "label": "Page_131", "shape": "dot", "size": 10, "title": "Page_131"}, {"color": "blue", "id": 132, "label": "Page_132", "shape": "dot", "size": 10, "title": "Page_132"}, {"color": "blue", "id": 133, "label": "Page_133", "shape": "dot", "size": 10, "title": "Page_133"}, {"color": "blue", "id": 134, "label": "Page_134", "shape": "dot", "size": 10, "title": "Page_134"}, {"color": "blue", "id": 135, "label": "Page_135", "shape": "dot", "size": 10, "title": "Page_135"}, {"color": "blue", "id": 136, "label": "Page_136", "shape": "dot", "size": 10, "title": "Page_136"}, {"color": "blue", "id": 137, "label": "Page_137", "shape": "dot", "size": 10, "title": "Page_137"}, {"color": "blue", "id": 138, "label": "Page_138", "shape": "dot", "size": 10, "title": "Page_138"}, {"color": "blue", "id": 139, "label": "Page_139", "shape": "dot", "size": 10, "title": "Page_139"}, {"color": "blue", "id": 140, "label": "Page_140", "shape": "dot", "size": 10, "title": "Page_140"}, {"color": "blue", "id": 141, "label": "Page_141", "shape": "dot", "size": 10, "title": "Page_141"}, {"color": "blue", "id": 142, "label": "Page_142", "shape": "dot", "size": 10, "title": "Page_142"}, {"color": "blue", "id": 143, "label": "Page_143", "shape": "dot", "size": 10, "title": "Page_143"}, {"color": "blue", "id": 144, "label": "Page_144", "shape": "dot", "size": 10, "title": "Page_144"}, {"color": "blue", "id": 145, "label": "Page_145", "shape": "dot", "size": 10, "title": "Page_145"}, {"color": "blue", "id": 146, "label": "Page_146", "shape": "dot", "size": 10, "title": "Page_146"}, {"color": "blue", "id": 147, "label": "Page_147", "shape": "dot", "size": 10, "title": "Page_147"}, {"color": "blue", "id": 148, "label": "Page_148", "shape": "dot", "size": 10, "title": "Page_148"}, {"color": "blue", "id": 149, "label": "Page_149", "shape": "dot", "size": 10, "title": "Page_149"}, {"color": "blue", "id": 150, "label": "Page_150", "shape": "dot", "size": 10, "title": "Page_150"}, {"color": "blue", "id": 151, "label": "Page_151", "shape": "dot", "size": 10, "title": "Page_151"}, {"color": "blue", "id": 152, "label": "Page_152", "shape": "dot", "size": 10, "title": "Page_152"}, {"color": "blue", "id": 153, "label": "Page_153", "shape": "dot", "size": 10, "title": "Page_153"}, {"color": "blue", "id": 154, "label": "Page_154", "shape": "dot", "size": 10, "title": "Page_154"}, {"color": "blue", "id": 155, "label": "Page_155", "shape": "dot", "size": 10, "title": "Page_155"}, {"color": "blue", "id": 156, "label": "Page_156", "shape": "dot", "size": 10, "title": "Page_156"}, {"color": "blue", "id": 157, "label": "Page_157", "shape": "dot", "size": 10, "title": "Page_157"}, {"color": "blue", "id": 158, "label": "Page_158", "shape": "dot", "size": 10, "title": "Page_158"}, {"color": "blue", "id": 159, "label": "Page_159", "shape": "dot", "size": 10, "title": "Page_159"}, {"color": "blue", "id": 160, "label": "Page_160", "shape": "dot", "size": 10, "title": "Page_160"}, {"color": "blue", "id": 161, "label": "Page_161", "shape": "dot", "size": 10, "title": "Page_161"}, {"color": "blue", "id": 162, "label": "Page_162", "shape": "dot", "size": 10, "title": "Page_162"}, {"color": "blue", "id": 163, "label": "Page_163", "shape": "dot", "size": 10, "title": "Page_163"}, {"color": "blue", "id": 164, "label": "Page_164", "shape": "dot", "size": 10, "title": "Page_164"}, {"color": "blue", "id": 165, "label": "Page_165", "shape": "dot", "size": 10, "title": "Page_165"}, {"color": "blue", "id": 166, "label": "Page_166", "shape": "dot", "size": 10, "title": "Page_166"}, {"color": "blue", "id": 167, "label": "Page_167", "shape": "dot", "size": 10, "title": "Page_167"}, {"color": "blue", "id": 168, "label": "Page_168", "shape": "dot", "size": 10, "title": "Page_168"}, {"color": "blue", "id": 169, "label": "Page_169", "shape": "dot", "size": 10, "title": "Page_169"}, {"color": "blue", "id": 170, "label": "Page_170", "shape": "dot", "size": 10, "title": "Page_170"}, {"color": "blue", "id": 171, "label": "Page_171", "shape": "dot", "size": 10, "title": "Page_171"}, {"color": "blue", "id": 172, "label": "Page_172", "shape": "dot", "size": 10, "title": "Page_172"}, {"color": "blue", "id": 173, "label": "Page_173", "shape": "dot", "size": 10, "title": "Page_173"}, {"color": "blue", "id": 174, "label": "Page_174", "shape": "dot", "size": 10, "title": "Page_174"}, {"color": "blue", "id": 175, "label": "Page_175", "shape": "dot", "size": 10, "title": "Page_175"}, {"color": "blue", "id": 176, "label": "Page_176", "shape": "dot", "size": 10, "title": "Page_176"}, {"color": "blue", "id": 177, "label": "Page_177", "shape": "dot", "size": 10, "title": "Page_177"}, {"color": "blue", "id": 178, "label": "Page_178", "shape": "dot", "size": 10, "title": "Page_178"}, {"color": "blue", "id": 179, "label": "Page_179", "shape": "dot", "size": 10, "title": "Page_179"}, {"color": "blue", "id": 180, "label": "Page_180", "shape": "dot", "size": 10, "title": "Page_180"}, {"color": "blue", "id": 181, "label": "Page_181", "shape": "dot", "size": 10, "title": "Page_181"}, {"color": "blue", "id": 182, "label": "Page_182", "shape": "dot", "size": 10, "title": "Page_182"}, {"color": "blue", "id": 183, "label": "Page_183", "shape": "dot", "size": 10, "title": "Page_183"}, {"color": "blue", "id": 184, "label": "Page_184", "shape": "dot", "size": 10, "title": "Page_184"}, {"color": "blue", "id": 185, "label": "Page_185", "shape": "dot", "size": 10, "title": "Page_185"}, {"color": "blue", "id": 186, "label": "Page_186", "shape": "dot", "size": 10, "title": "Page_186"}, {"color": "blue", "id": 187, "label": "Page_187", "shape": "dot", "size": 10, "title": "Page_187"}, {"color": "blue", "id": 188, "label": "Page_188", "shape": "dot", "size": 10, "title": "Page_188"}, {"color": "blue", "id": 189, "label": "Page_189", "shape": "dot", "size": 10, "title": "Page_189"}, {"color": "blue", "id": 190, "label": "Page_190", "shape": "dot", "size": 10, "title": "Page_190"}, {"color": "blue", "id": 191, "label": "Page_191", "shape": "dot", "size": 10, "title": "Page_191"}, {"color": "blue", "id": 192, "label": "Page_192", "shape": "dot", "size": 10, "title": "Page_192"}, {"color": "blue", "id": 193, "label": "Page_193", "shape": "dot", "size": 10, "title": "Page_193"}, {"color": "blue", "id": 194, "label": "Page_194", "shape": "dot", "size": 10, "title": "Page_194"}, {"color": "blue", "id": 195, "label": "Page_195", "shape": "dot", "size": 10, "title": "Page_195"}, {"color": "blue", "id": 196, "label": "Page_196", "shape": "dot", "size": 10, "title": "Page_196"}, {"color": "blue", "id": 197, "label": "Page_197", "shape": "dot", "size": 10, "title": "Page_197"}, {"color": "blue", "id": 198, "label": "Page_198", "shape": "dot", "size": 10, "title": "Page_198"}, {"color": "blue", "id": 199, "label": "Page_199", "shape": "dot", "size": 10, "title": "Page_199"}, {"color": "blue", "id": 200, "label": "Page_200", "shape": "dot", "size": 10, "title": "Page_200"}, {"color": "blue", "id": 201, "label": "Page_201", "shape": "dot", "size": 10, "title": "Page_201"}, {"color": "blue", "id": 202, "label": "Page_202", "shape": "dot", "size": 10, "title": "Page_202"}, {"color": "blue", "id": 203, "label": "Page_203", "shape": "dot", "size": 10, "title": "Page_203"}, {"color": "blue", "id": 204, "label": "Page_204", "shape": "dot", "size": 10, "title": "Page_204"}, {"color": "blue", "id": 205, "label": "Page_205", "shape": "dot", "size": 10, "title": "Page_205"}, {"color": "blue", "id": 206, "label": "Page_206", "shape": "dot", "size": 10, "title": "Page_206"}, {"color": "blue", "id": 207, "label": "Page_207", "shape": "dot", "size": 10, "title": "Page_207"}, {"color": "blue", "id": 208, "label": "Page_208", "shape": "dot", "size": 10, "title": "Page_208"}, {"color": "blue", "id": 209, "label": "Page_209", "shape": "dot", "size": 10, "title": "Page_209"}, {"color": "blue", "id": 210, "label": "Page_210", "shape": "dot", "size": 10, "title": "Page_210"}, {"color": "blue", "id": 211, "label": "Page_211", "shape": "dot", "size": 10, "title": "Page_211"}, {"color": "blue", "id": 212, "label": "Page_212", "shape": "dot", "size": 10, "title": "Page_212"}, {"color": "blue", "id": 213, "label": "Page_213", "shape": "dot", "size": 10, "title": "Page_213"}, {"color": "blue", "id": 214, "label": "Page_214", "shape": "dot", "size": 10, "title": "Page_214"}, {"color": "blue", "id": 215, "label": "Page_215", "shape": "dot", "size": 10, "title": "Page_215"}, {"color": "blue", "id": 216, "label": "Page_216", "shape": "dot", "size": 10, "title": "Page_216"}, {"color": "blue", "id": 217, "label": "Page_217", "shape": "dot", "size": 10, "title": "Page_217"}, {"color": "blue", "id": 218, "label": "Page_218", "shape": "dot", "size": 10, "title": "Page_218"}, {"color": "blue", "id": 219, "label": "Page_219", "shape": "dot", "size": 10, "title": "Page_219"}, {"color": "blue", "id": 220, "label": "Page_220", "shape": "dot", "size": 10, "title": "Page_220"}, {"color": "blue", "id": 221, "label": "Page_221", "shape": "dot", "size": 10, "title": "Page_221"}, {"color": "blue", "id": 222, "label": "Page_222", "shape": "dot", "size": 10, "title": "Page_222"}, {"color": "blue", "id": 223, "label": "Page_223", "shape": "dot", "size": 10, "title": "Page_223"}, {"color": "blue", "id": 224, "label": "Page_224", "shape": "dot", "size": 10, "title": "Page_224"}, {"color": "blue", "id": 225, "label": "Page_225", "shape": "dot", "size": 10, "title": "Page_225"}, {"color": "blue", "id": 226, "label": "Page_226", "shape": "dot", "size": 10, "title": "Page_226"}, {"color": "blue", "id": 227, "label": "Page_227", "shape": "dot", "size": 10, "title": "Page_227"}, {"color": "blue", "id": 228, "label": "Page_228", "shape": "dot", "size": 10, "title": "Page_228"}, {"color": "blue", "id": 229, "label": "Page_229", "shape": "dot", "size": 10, "title": "Page_229"}, {"color": "blue", "id": 230, "label": "Page_230", "shape": "dot", "size": 10, "title": "Page_230"}, {"color": "blue", "id": 231, "label": "Page_231", "shape": "dot", "size": 10, "title": "Page_231"}, {"color": "blue", "id": 232, "label": "Page_232", "shape": "dot", "size": 10, "title": "Page_232"}, {"color": "blue", "id": 233, "label": "Page_233", "shape": "dot", "size": 10, "title": "Page_233"}, {"color": "blue", "id": 234, "label": "Page_234", "shape": "dot", "size": 10, "title": "Page_234"}, {"color": "blue", "id": 235, "label": "Page_235", "shape": "dot", "size": 10, "title": "Page_235"}, {"color": "blue", "id": 236, "label": "Page_236", "shape": "dot", "size": 10, "title": "Page_236"}, {"color": "blue", "id": 237, "label": "Page_237", "shape": "dot", "size": 10, "title": "Page_237"}, {"color": "blue", "id": 238, "label": "Page_238", "shape": "dot", "size": 10, "title": "Page_238"}, {"color": "blue", "id": 239, "label": "Page_239", "shape": "dot", "size": 10, "title": "Page_239"}, {"color": "blue", "id": 240, "label": "Page_240", "shape": "dot", "size": 10, "title": "Page_240"}, {"color": "blue", "id": 241, "label": "Page_241", "shape": "dot", "size": 10, "title": "Page_241"}, {"color": "blue", "id": 242, "label": "Page_242", "shape": "dot", "size": 10, "title": "Page_242"}, {"color": "blue", "id": 243, "label": "Page_243", "shape": "dot", "size": 10, "title": "Page_243"}, {"color": "blue", "id": 244, "label": "Page_244", "shape": "dot", "size": 10, "title": "Page_244"}, {"color": "blue", "id": 245, "label": "Page_245", "shape": "dot", "size": 10, "title": "Page_245"}, {"color": "blue", "id": 246, "label": "Page_246", "shape": "dot", "size": 10, "title": "Page_246"}, {"color": "blue", "id": 247, "label": "Page_247", "shape": "dot", "size": 10, "title": "Page_247"}, {"color": "blue", "id": 248, "label": "Page_248", "shape": "dot", "size": 10, "title": "Page_248"}, {"color": "blue", "id": 249, "label": "Page_249", "shape": "dot", "size": 10, "title": "Page_249"}, {"color": "blue", "id": 250, "label": "Page_250", "shape": "dot", "size": 10, "title": "Page_250"}, {"color": "blue", "id": 251, "label": "Page_251", "shape": "dot", "size": 10, "title": "Page_251"}, {"color": "blue", "id": 252, "label": "Page_252", "shape": "dot", "size": 10, "title": "Page_252"}, {"color": "blue", "id": 253, "label": "Page_253", "shape": "dot", "size": 10, "title": "Page_253"}, {"color": "blue", "id": 254, "label": "Page_254", "shape": "dot", "size": 10, "title": "Page_254"}, {"color": "blue", "id": 255, "label": "Page_255", "shape": "dot", "size": 10, "title": "Page_255"}, {"color": "blue", "id": 256, "label": "Page_256", "shape": "dot", "size": 10, "title": "Page_256"}, {"color": "blue", "id": 257, "label": "Page_257", "shape": "dot", "size": 10, "title": "Page_257"}, {"color": "blue", "id": 258, "label": "Page_258", "shape": "dot", "size": 10, "title": "Page_258"}, {"color": "blue", "id": 259, "label": "Page_259", "shape": "dot", "size": 10, "title": "Page_259"}, {"color": "blue", "id": 260, "label": "Page_260", "shape": "dot", "size": 10, "title": "Page_260"}, {"color": "blue", "id": 261, "label": "Page_261", "shape": "dot", "size": 10, "title": "Page_261"}, {"color": "blue", "id": 262, "label": "Page_262", "shape": "dot", "size": 10, "title": "Page_262"}, {"color": "blue", "id": 263, "label": "Page_263", "shape": "dot", "size": 10, "title": "Page_263"}, {"color": "blue", "id": 264, "label": "Page_264", "shape": "dot", "size": 10, "title": "Page_264"}, {"color": "blue", "id": 265, "label": "Page_265", "shape": "dot", "size": 10, "title": "Page_265"}, {"color": "blue", "id": 266, "label": "Page_266", "shape": "dot", "size": 10, "title": "Page_266"}, {"color": "blue", "id": 267, "label": "Page_267", "shape": "dot", "size": 10, "title": "Page_267"}, {"color": "blue", "id": 268, "label": "Page_268", "shape": "dot", "size": 10, "title": "Page_268"}, {"color": "blue", "id": 269, "label": "Page_269", "shape": "dot", "size": 10, "title": "Page_269"}, {"color": "blue", "id": 270, "label": "Page_270", "shape": "dot", "size": 10, "title": "Page_270"}, {"color": "blue", "id": 271, "label": "Page_271", "shape": "dot", "size": 10, "title": "Page_271"}, {"color": "blue", "id": 272, "label": "Page_272", "shape": "dot", "size": 10, "title": "Page_272"}, {"color": "blue", "id": 273, "label": "Page_273", "shape": "dot", "size": 10, "title": "Page_273"}, {"color": "blue", "id": 274, "label": "Page_274", "shape": "dot", "size": 10, "title": "Page_274"}, {"color": "blue", "id": 275, "label": "Page_275", "shape": "dot", "size": 10, "title": "Page_275"}, {"color": "blue", "id": 276, "label": "Page_276", "shape": "dot", "size": 10, "title": "Page_276"}, {"color": "blue", "id": 277, "label": "Page_277", "shape": "dot", "size": 10, "title": "Page_277"}, {"color": "blue", "id": 278, "label": "Page_278", "shape": "dot", "size": 10, "title": "Page_278"}, {"color": "blue", "id": 279, "label": "Page_279", "shape": "dot", "size": 10, "title": "Page_279"}, {"color": "blue", "id": 280, "label": "Page_280", "shape": "dot", "size": 10, "title": "Page_280"}, {"color": "blue", "id": 281, "label": "Page_281", "shape": "dot", "size": 10, "title": "Page_281"}, {"color": "blue", "id": 282, "label": "Page_282", "shape": "dot", "size": 10, "title": "Page_282"}, {"color": "blue", "id": 283, "label": "Page_283", "shape": "dot", "size": 10, "title": "Page_283"}, {"color": "blue", "id": 284, "label": "Page_284", "shape": "dot", "size": 10, "title": "Page_284"}, {"color": "blue", "id": 285, "label": "Page_285", "shape": "dot", "size": 10, "title": "Page_285"}, {"color": "blue", "id": 286, "label": "Page_286", "shape": "dot", "size": 10, "title": "Page_286"}, {"color": "blue", "id": 287, "label": "Page_287", "shape": "dot", "size": 10, "title": "Page_287"}, {"color": "blue", "id": 288, "label": "Page_288", "shape": "dot", "size": 10, "title": "Page_288"}, {"color": "blue", "id": 289, "label": "Page_289", "shape": "dot", "size": 10, "title": "Page_289"}, {"color": "blue", "id": 290, "label": "Page_290", "shape": "dot", "size": 10, "title": "Page_290"}, {"color": "blue", "id": 291, "label": "Page_291", "shape": "dot", "size": 10, "title": "Page_291"}, {"color": "blue", "id": 292, "label": "Page_292", "shape": "dot", "size": 10, "title": "Page_292"}, {"color": "blue", "id": 293, "label": "Page_293", "shape": "dot", "size": 10, "title": "Page_293"}, {"color": "blue", "id": 294, "label": "Page_294", "shape": "dot", "size": 10, "title": "Page_294"}, {"color": "blue", "id": 295, "label": "Page_295", "shape": "dot", "size": 10, "title": "Page_295"}, {"color": "blue", "id": 296, "label": "Page_296", "shape": "dot", "size": 10, "title": "Page_296"}, {"color": "blue", "id": 297, "label": "Page_297", "shape": "dot", "size": 10, "title": "Page_297"}, {"color": "blue", "id": 298, "label": "Page_298", "shape": "dot", "size": 10, "title": "Page_298"}, {"color": "blue", "id": 299, "label": "Page_299", "shape": "dot", "size": 10, "title": "Page_299"}, {"color": "blue", "id": 300, "label": "Page_300", "shape": "dot", "size": 10, "title": "Page_300"}, {"color": "blue", "id": 301, "label": "Page_301", "shape": "dot", "size": 10, "title": "Page_301"}, {"color": "blue", "id": 302, "label": "Page_302", "shape": "dot", "size": 10, "title": "Page_302"}, {"color": "blue", "id": 303, "label": "Page_303", "shape": "dot", "size": 10, "title": "Page_303"}, {"color": "blue", "id": 304, "label": "Page_304", "shape": "dot", "size": 10, "title": "Page_304"}, {"color": "blue", "id": 305, "label": "Page_305", "shape": "dot", "size": 10, "title": "Page_305"}, {"color": "blue", "id": 306, "label": "Page_306", "shape": "dot", "size": 10, "title": "Page_306"}, {"color": "blue", "id": 307, "label": "Page_307", "shape": "dot", "size": 10, "title": "Page_307"}, {"color": "blue", "id": 308, "label": "Page_308", "shape": "dot", "size": 10, "title": "Page_308"}, {"color": "blue", "id": 309, "label": "Page_309", "shape": "dot", "size": 10, "title": "Page_309"}, {"color": "blue", "id": 310, "label": "Page_310", "shape": "dot", "size": 10, "title": "Page_310"}, {"color": "blue", "id": 311, "label": "Page_311", "shape": "dot", "size": 10, "title": "Page_311"}, {"color": "blue", "id": 312, "label": "Page_312", "shape": "dot", "size": 10, "title": "Page_312"}, {"color": "blue", "id": 313, "label": "Page_313", "shape": "dot", "size": 10, "title": "Page_313"}, {"color": "blue", "id": 314, "label": "Page_314", "shape": "dot", "size": 10, "title": "Page_314"}, {"color": "blue", "id": 315, "label": "Page_315", "shape": "dot", "size": 10, "title": "Page_315"}, {"color": "blue", "id": 316, "label": "Page_316", "shape": "dot", "size": 10, "title": "Page_316"}, {"color": "blue", "id": 317, "label": "Page_317", "shape": "dot", "size": 10, "title": "Page_317"}, {"color": "blue", "id": 318, "label": "Page_318", "shape": "dot", "size": 10, "title": "Page_318"}, {"color": "blue", "id": 319, "label": "Page_319", "shape": "dot", "size": 10, "title": "Page_319"}, {"color": "blue", "id": 320, "label": "Page_320", "shape": "dot", "size": 10, "title": "Page_320"}, {"color": "blue", "id": 321, "label": "Page_321", "shape": "dot", "size": 10, "title": "Page_321"}, {"color": "blue", "id": 322, "label": "Page_322", "shape": "dot", "size": 10, "title": "Page_322"}, {"color": "blue", "id": 323, "label": "Page_323", "shape": "dot", "size": 10, "title": "Page_323"}, {"color": "blue", "id": 324, "label": "Page_324", "shape": "dot", "size": 10, "title": "Page_324"}, {"color": "blue", "id": 325, "label": "Page_325", "shape": "dot", "size": 10, "title": "Page_325"}, {"color": "blue", "id": 326, "label": "Page_326", "shape": "dot", "size": 10, "title": "Page_326"}, {"color": "blue", "id": 327, "label": "Page_327", "shape": "dot", "size": 10, "title": "Page_327"}, {"color": "blue", "id": 328, "label": "Page_328", "shape": "dot", "size": 10, "title": "Page_328"}, {"color": "blue", "id": 329, "label": "Page_329", "shape": "dot", "size": 10, "title": "Page_329"}, {"color": "blue", "id": 330, "label": "Page_330", "shape": "dot", "size": 10, "title": "Page_330"}, {"color": "blue", "id": 331, "label": "Page_331", "shape": "dot", "size": 10, "title": "Page_331"}, {"color": "blue", "id": 332, "label": "Page_332", "shape": "dot", "size": 10, "title": "Page_332"}, {"color": "blue", "id": 333, "label": "Page_333", "shape": "dot", "size": 10, "title": "Page_333"}, {"color": "blue", "id": 334, "label": "Page_334", "shape": "dot", "size": 10, "title": "Page_334"}, {"color": "blue", "id": 335, "label": "Page_335", "shape": "dot", "size": 10, "title": "Page_335"}, {"color": "blue", "id": 336, "label": "Page_336", "shape": "dot", "size": 10, "title": "Page_336"}, {"color": "blue", "id": 337, "label": "Page_337", "shape": "dot", "size": 10, "title": "Page_337"}, {"color": "blue", "id": 338, "label": "Page_338", "shape": "dot", "size": 10, "title": "Page_338"}, {"color": "blue", "id": 339, "label": "Page_339", "shape": "dot", "size": 10, "title": "Page_339"}, {"color": "blue", "id": 340, "label": "Page_340", "shape": "dot", "size": 10, "title": "Page_340"}, {"color": "blue", "id": 341, "label": "Page_341", "shape": "dot", "size": 10, "title": "Page_341"}, {"color": "blue", "id": 342, "label": "Page_342", "shape": "dot", "size": 10, "title": "Page_342"}, {"color": "blue", "id": 343, "label": "Page_343", "shape": "dot", "size": 10, "title": "Page_343"}, {"color": "blue", "id": 344, "label": "Page_344", "shape": "dot", "size": 10, "title": "Page_344"}, {"color": "blue", "id": 345, "label": "Page_345", "shape": "dot", "size": 10, "title": "Page_345"}, {"color": "blue", "id": 346, "label": "Page_346", "shape": "dot", "size": 10, "title": "Page_346"}, {"color": "blue", "id": 347, "label": "Page_347", "shape": "dot", "size": 10, "title": "Page_347"}, {"color": "blue", "id": 348, "label": "Page_348", "shape": "dot", "size": 10, "title": "Page_348"}, {"color": "blue", "id": 349, "label": "Page_349", "shape": "dot", "size": 10, "title": "Page_349"}, {"color": "blue", "id": 350, "label": "Page_350", "shape": "dot", "size": 10, "title": "Page_350"}, {"color": "blue", "id": 351, "label": "Page_351", "shape": "dot", "size": 10, "title": "Page_351"}, {"color": "blue", "id": 352, "label": "Page_352", "shape": "dot", "size": 10, "title": "Page_352"}, {"color": "blue", "id": 353, "label": "Page_353", "shape": "dot", "size": 10, "title": "Page_353"}, {"color": "blue", "id": 354, "label": "Page_354", "shape": "dot", "size": 10, "title": "Page_354"}, {"color": "blue", "id": 355, "label": "Page_355", "shape": "dot", "size": 10, "title": "Page_355"}, {"color": "blue", "id": 356, "label": "Page_356", "shape": "dot", "size": 10, "title": "Page_356"}, {"color": "blue", "id": 357, "label": "Page_357", "shape": "dot", "size": 10, "title": "Page_357"}, {"color": "blue", "id": 358, "label": "Page_358", "shape": "dot", "size": 10, "title": "Page_358"}, {"color": "blue", "id": 359, "label": "Page_359", "shape": "dot", "size": 10, "title": "Page_359"}, {"color": "blue", "id": 360, "label": "Page_360", "shape": "dot", "size": 10, "title": "Page_360"}, {"color": "blue", "id": 361, "label": "Page_361", "shape": "dot", "size": 10, "title": "Page_361"}, {"color": "blue", "id": 362, "label": "Page_362", "shape": "dot", "size": 10, "title": "Page_362"}, {"color": "blue", "id": 363, "label": "Page_363", "shape": "dot", "size": 10, "title": "Page_363"}, {"color": "blue", "id": 364, "label": "Page_364", "shape": "dot", "size": 10, "title": "Page_364"}, {"color": "blue", "id": 365, "label": "Page_365", "shape": "dot", "size": 10, "title": "Page_365"}, {"color": "blue", "id": 366, "label": "Page_366", "shape": "dot", "size": 10, "title": "Page_366"}, {"color": "blue", "id": 367, "label": "Page_367", "shape": "dot", "size": 10, "title": "Page_367"}, {"color": "blue", "id": 368, "label": "Page_368", "shape": "dot", "size": 10, "title": "Page_368"}, {"color": "blue", "id": 369, "label": "Page_369", "shape": "dot", "size": 10, "title": "Page_369"}, {"color": "blue", "id": 370, "label": "Page_370", "shape": "dot", "size": 10, "title": "Page_370"}, {"color": "blue", "id": 371, "label": "Page_371", "shape": "dot", "size": 10, "title": "Page_371"}, {"color": "blue", "id": 372, "label": "Page_372", "shape": "dot", "size": 10, "title": "Page_372"}, {"color": "blue", "id": 373, "label": "Page_373", "shape": "dot", "size": 10, "title": "Page_373"}, {"color": "blue", "id": 374, "label": "Page_374", "shape": "dot", "size": 10, "title": "Page_374"}, {"color": "blue", "id": 375, "label": "Page_375", "shape": "dot", "size": 10, "title": "Page_375"}, {"color": "blue", "id": 376, "label": "Page_376", "shape": "dot", "size": 10, "title": "Page_376"}, {"color": "blue", "id": 377, "label": "Page_377", "shape": "dot", "size": 10, "title": "Page_377"}, {"color": "blue", "id": 378, "label": "Page_378", "shape": "dot", "size": 10, "title": "Page_378"}, {"color": "blue", "id": 379, "label": "Page_379", "shape": "dot", "size": 10, "title": "Page_379"}, {"color": "blue", "id": 380, "label": "Page_380", "shape": "dot", "size": 10, "title": "Page_380"}, {"color": "blue", "id": 381, "label": "Page_381", "shape": "dot", "size": 10, "title": "Page_381"}, {"color": "blue", "id": 382, "label": "Page_382", "shape": "dot", "size": 10, "title": "Page_382"}, {"color": "blue", "id": 383, "label": "Page_383", "shape": "dot", "size": 10, "title": "Page_383"}, {"color": "blue", "id": 384, "label": "Page_384", "shape": "dot", "size": 10, "title": "Page_384"}, {"color": "blue", "id": 385, "label": "Page_385", "shape": "dot", "size": 10, "title": "Page_385"}, {"color": "blue", "id": 386, "label": "Page_386", "shape": "dot", "size": 10, "title": "Page_386"}, {"color": "blue", "id": 387, "label": "Page_387", "shape": "dot", "size": 10, "title": "Page_387"}, {"color": "blue", "id": 388, "label": "Page_388", "shape": "dot", "size": 10, "title": "Page_388"}, {"color": "blue", "id": 389, "label": "Page_389", "shape": "dot", "size": 10, "title": "Page_389"}, {"color": "blue", "id": 390, "label": "Page_390", "shape": "dot", "size": 10, "title": "Page_390"}, {"color": "blue", "id": 391, "label": "Page_391", "shape": "dot", "size": 10, "title": "Page_391"}, {"color": "blue", "id": 392, "label": "Page_392", "shape": "dot", "size": 10, "title": "Page_392"}, {"color": "blue", "id": 393, "label": "Page_393", "shape": "dot", "size": 10, "title": "Page_393"}, {"color": "blue", "id": 394, "label": "Page_394", "shape": "dot", "size": 10, "title": "Page_394"}, {"color": "blue", "id": 395, "label": "Page_395", "shape": "dot", "size": 10, "title": "Page_395"}, {"color": "blue", "id": 396, "label": "Page_396", "shape": "dot", "size": 10, "title": "Page_396"}, {"color": "blue", "id": 397, "label": "Page_397", "shape": "dot", "size": 10, "title": "Page_397"}, {"color": "blue", "id": 398, "label": "Page_398", "shape": "dot", "size": 10, "title": "Page_398"}, {"color": "blue", "id": 399, "label": "Page_399", "shape": "dot", "size": 10, "title": "Page_399"}, {"color": "blue", "id": 400, "label": "Page_400", "shape": "dot", "size": 10, "title": "Page_400"}, {"color": "blue", "id": 401, "label": "Page_401", "shape": "dot", "size": 10, "title": "Page_401"}, {"color": "blue", "id": 402, "label": "Page_402", "shape": "dot", "size": 10, "title": "Page_402"}, {"color": "blue", "id": 403, "label": "Page_403", "shape": "dot", "size": 10, "title": "Page_403"}, {"color": "blue", "id": 404, "label": "Page_404", "shape": "dot", "size": 10, "title": "Page_404"}, {"color": "blue", "id": 405, "label": "Page_405", "shape": "dot", "size": 10, "title": "Page_405"}, {"color": "blue", "id": 406, "label": "Page_406", "shape": "dot", "size": 10, "title": "Page_406"}, {"color": "blue", "id": 407, "label": "Page_407", "shape": "dot", "size": 10, "title": "Page_407"}, {"color": "blue", "id": 408, "label": "Page_408", "shape": "dot", "size": 10, "title": "Page_408"}, {"color": "blue", "id": 409, "label": "Page_409", "shape": "dot", "size": 10, "title": "Page_409"}, {"color": "blue", "id": 410, "label": "Page_410", "shape": "dot", "size": 10, "title": "Page_410"}, {"color": "blue", "id": 411, "label": "Page_411", "shape": "dot", "size": 10, "title": "Page_411"}, {"color": "blue", "id": 412, "label": "Page_412", "shape": "dot", "size": 10, "title": "Page_412"}, {"color": "blue", "id": 413, "label": "Page_413", "shape": "dot", "size": 10, "title": "Page_413"}, {"color": "blue", "id": 414, "label": "Page_414", "shape": "dot", "size": 10, "title": "Page_414"}, {"color": "blue", "id": 415, "label": "Page_415", "shape": "dot", "size": 10, "title": "Page_415"}, {"color": "blue", "id": 416, "label": "Page_416", "shape": "dot", "size": 10, "title": "Page_416"}, {"color": "blue", "id": 417, "label": "Page_417", "shape": "dot", "size": 10, "title": "Page_417"}, {"color": "blue", "id": 418, "label": "Page_418", "shape": "dot", "size": 10, "title": "Page_418"}, {"color": "blue", "id": 419, "label": "Page_419", "shape": "dot", "size": 10, "title": "Page_419"}, {"color": "blue", "id": 420, "label": "Page_420", "shape": "dot", "size": 10, "title": "Page_420"}, {"color": "blue", "id": 421, "label": "Page_421", "shape": "dot", "size": 10, "title": "Page_421"}, {"color": "blue", "id": 422, "label": "Page_422", "shape": "dot", "size": 10, "title": "Page_422"}, {"color": "blue", "id": 423, "label": "Page_423", "shape": "dot", "size": 10, "title": "Page_423"}, {"color": "blue", "id": 424, "label": "Page_424", "shape": "dot", "size": 10, "title": "Page_424"}, {"color": "blue", "id": 425, "label": "Page_425", "shape": "dot", "size": 10, "title": "Page_425"}, {"color": "blue", "id": 426, "label": "Page_426", "shape": "dot", "size": 10, "title": "Page_426"}, {"color": "blue", "id": 427, "label": "Page_427", "shape": "dot", "size": 10, "title": "Page_427"}, {"color": "blue", "id": 428, "label": "Page_428", "shape": "dot", "size": 10, "title": "Page_428"}, {"color": "blue", "id": 429, "label": "Page_429", "shape": "dot", "size": 10, "title": "Page_429"}, {"color": "blue", "id": 430, "label": "Page_430", "shape": "dot", "size": 10, "title": "Page_430"}, {"color": "blue", "id": 431, "label": "Page_431", "shape": "dot", "size": 10, "title": "Page_431"}, {"color": "blue", "id": 432, "label": "Page_432", "shape": "dot", "size": 10, "title": "Page_432"}, {"color": "blue", "id": 433, "label": "Page_433", "shape": "dot", "size": 10, "title": "Page_433"}, {"color": "blue", "id": 434, "label": "Page_434", "shape": "dot", "size": 10, "title": "Page_434"}, {"color": "blue", "id": 435, "label": "Page_435", "shape": "dot", "size": 10, "title": "Page_435"}, {"color": "blue", "id": 436, "label": "Page_436", "shape": "dot", "size": 10, "title": "Page_436"}, {"color": "blue", "id": 437, "label": "Page_437", "shape": "dot", "size": 10, "title": "Page_437"}, {"color": "blue", "id": 438, "label": "Page_438", "shape": "dot", "size": 10, "title": "Page_438"}, {"color": "blue", "id": 439, "label": "Page_439", "shape": "dot", "size": 10, "title": "Page_439"}, {"color": "blue", "id": 440, "label": "Page_440", "shape": "dot", "size": 10, "title": "Page_440"}, {"color": "blue", "id": 441, "label": "Page_441", "shape": "dot", "size": 10, "title": "Page_441"}, {"color": "blue", "id": 442, "label": "Page_442", "shape": "dot", "size": 10, "title": "Page_442"}, {"color": "blue", "id": 443, "label": "Page_443", "shape": "dot", "size": 10, "title": "Page_443"}, {"color": "blue", "id": 444, "label": "Page_444", "shape": "dot", "size": 10, "title": "Page_444"}, {"color": "blue", "id": 445, "label": "Page_445", "shape": "dot", "size": 10, "title": "Page_445"}, {"color": "blue", "id": 446, "label": "Page_446", "shape": "dot", "size": 10, "title": "Page_446"}, {"color": "blue", "id": 447, "label": "Page_447", "shape": "dot", "size": 10, "title": "Page_447"}, {"color": "blue", "id": 448, "label": "Page_448", "shape": "dot", "size": 10, "title": "Page_448"}, {"color": "blue", "id": 449, "label": "Page_449", "shape": "dot", "size": 10, "title": "Page_449"}, {"color": "blue", "id": 450, "label": "Page_450", "shape": "dot", "size": 10, "title": "Page_450"}, {"color": "blue", "id": 451, "label": "Page_451", "shape": "dot", "size": 10, "title": "Page_451"}, {"color": "blue", "id": 452, "label": "Page_452", "shape": "dot", "size": 10, "title": "Page_452"}, {"color": "blue", "id": 453, "label": "Page_453", "shape": "dot", "size": 10, "title": "Page_453"}, {"color": "blue", "id": 454, "label": "Page_454", "shape": "dot", "size": 10, "title": "Page_454"}, {"color": "blue", "id": 455, "label": "Page_455", "shape": "dot", "size": 10, "title": "Page_455"}, {"color": "blue", "id": 456, "label": "Page_456", "shape": "dot", "size": 10, "title": "Page_456"}, {"color": "blue", "id": 457, "label": "Page_457", "shape": "dot", "size": 10, "title": "Page_457"}, {"color": "blue", "id": 458, "label": "Page_458", "shape": "dot", "size": 10, "title": "Page_458"}, {"color": "blue", "id": 459, "label": "Page_459", "shape": "dot", "size": 10, "title": "Page_459"}, {"color": "blue", "id": 460, "label": "Page_460", "shape": "dot", "size": 10, "title": "Page_460"}, {"color": "blue", "id": 461, "label": "Page_461", "shape": "dot", "size": 10, "title": "Page_461"}, {"color": "blue", "id": 462, "label": "Page_462", "shape": "dot", "size": 10, "title": "Page_462"}, {"color": "blue", "id": 463, "label": "Page_463", "shape": "dot", "size": 10, "title": "Page_463"}, {"color": "blue", "id": 464, "label": "Page_464", "shape": "dot", "size": 10, "title": "Page_464"}, {"color": "blue", "id": 465, "label": "Page_465", "shape": "dot", "size": 10, "title": "Page_465"}, {"color": "blue", "id": 466, "label": "Page_466", "shape": "dot", "size": 10, "title": "Page_466"}, {"color": "blue", "id": 467, "label": "Page_467", "shape": "dot", "size": 10, "title": "Page_467"}, {"color": "blue", "id": 468, "label": "Page_468", "shape": "dot", "size": 10, "title": "Page_468"}, {"color": "blue", "id": 469, "label": "Page_469", "shape": "dot", "size": 10, "title": "Page_469"}, {"color": "blue", "id": 470, "label": "Page_470", "shape": "dot", "size": 10, "title": "Page_470"}, {"color": "blue", "id": 471, "label": "Page_471", "shape": "dot", "size": 10, "title": "Page_471"}, {"color": "blue", "id": 472, "label": "Page_472", "shape": "dot", "size": 10, "title": "Page_472"}, {"color": "blue", "id": 473, "label": "Page_473", "shape": "dot", "size": 10, "title": "Page_473"}, {"color": "blue", "id": 474, "label": "Page_474", "shape": "dot", "size": 10, "title": "Page_474"}, {"color": "blue", "id": 475, "label": "Page_475", "shape": "dot", "size": 10, "title": "Page_475"}, {"color": "blue", "id": 476, "label": "Page_476", "shape": "dot", "size": 10, "title": "Page_476"}, {"color": "blue", "id": 477, "label": "Page_477", "shape": "dot", "size": 10, "title": "Page_477"}, {"color": "blue", "id": 478, "label": "Page_478", "shape": "dot", "size": 10, "title": "Page_478"}, {"color": "blue", "id": 479, "label": "Page_479", "shape": "dot", "size": 10, "title": "Page_479"}, {"color": "blue", "id": 480, "label": "Page_480", "shape": "dot", "size": 10, "title": "Page_480"}, {"color": "blue", "id": 481, "label": "Page_481", "shape": "dot", "size": 10, "title": "Page_481"}, {"color": "blue", "id": 482, "label": "Page_482", "shape": "dot", "size": 10, "title": "Page_482"}, {"color": "blue", "id": 483, "label": "Page_483", "shape": "dot", "size": 10, "title": "Page_483"}, {"color": "blue", "id": 484, "label": "Page_484", "shape": "dot", "size": 10, "title": "Page_484"}, {"color": "blue", "id": 485, "label": "Page_485", "shape": "dot", "size": 10, "title": "Page_485"}, {"color": "blue", "id": 486, "label": "Page_486", "shape": "dot", "size": 10, "title": "Page_486"}, {"color": "blue", "id": 487, "label": "Page_487", "shape": "dot", "size": 10, "title": "Page_487"}, {"color": "blue", "id": 488, "label": "Page_488", "shape": "dot", "size": 10, "title": "Page_488"}, {"color": "blue", "id": 489, "label": "Page_489", "shape": "dot", "size": 10, "title": "Page_489"}, {"color": "blue", "id": 490, "label": "Page_490", "shape": "dot", "size": 10, "title": "Page_490"}, {"color": "blue", "id": 491, "label": "Page_491", "shape": "dot", "size": 10, "title": "Page_491"}, {"color": "blue", "id": 492, "label": "Page_492", "shape": "dot", "size": 10, "title": "Page_492"}, {"color": "blue", "id": 493, "label": "Page_493", "shape": "dot", "size": 10, "title": "Page_493"}, {"color": "blue", "id": 494, "label": "Page_494", "shape": "dot", "size": 10, "title": "Page_494"}, {"color": "blue", "id": 495, "label": "Page_495", "shape": "dot", "size": 10, "title": "Page_495"}, {"color": "blue", "id": 496, "label": "Page_496", "shape": "dot", "size": 10, "title": "Page_496"}, {"color": "blue", "id": 497, "label": "Page_497", "shape": "dot", "size": 10, "title": "Page_497"}, {"color": "blue", "id": 498, "label": "Page_498", "shape": "dot", "size": 10, "title": "Page_498"}, {"color": "blue", "id": 499, "label": "Page_499", "shape": "dot", "size": 10, "title": "Page_499"}, {"color": "blue", "id": 500, "label": "Page_500", "shape": "dot", "size": 10, "title": "Page_500"}, {"color": "blue", "id": 501, "label": "Page_501", "shape": "dot", "size": 10, "title": "Page_501"}, {"color": "blue", "id": 502, "label": "Page_502", "shape": "dot", "size": 10, "title": "Page_502"}, {"color": "blue", "id": 503, "label": "Page_503", "shape": "dot", "size": 10, "title": "Page_503"}, {"color": "blue", "id": 504, "label": "Page_504", "shape": "dot", "size": 10, "title": "Page_504"}, {"color": "blue", "id": 505, "label": "Page_505", "shape": "dot", "size": 10, "title": "Page_505"}, {"color": "blue", "id": 506, "label": "Page_506", "shape": "dot", "size": 10, "title": "Page_506"}, {"color": "blue", "id": 507, "label": "Page_507", "shape": "dot", "size": 10, "title": "Page_507"}, {"color": "blue", "id": 508, "label": "Page_508", "shape": "dot", "size": 10, "title": "Page_508"}, {"color": "blue", "id": 509, "label": "Page_509", "shape": "dot", "size": 10, "title": "Page_509"}, {"color": "blue", "id": 510, "label": "Page_510", "shape": "dot", "size": 10, "title": "Page_510"}, {"color": "blue", "id": 511, "label": "Page_511", "shape": "dot", "size": 10, "title": "Page_511"}, {"color": "blue", "id": 512, "label": "Page_512", "shape": "dot", "size": 10, "title": "Page_512"}, {"color": "blue", "id": 513, "label": "Page_513", "shape": "dot", "size": 10, "title": "Page_513"}, {"color": "blue", "id": 514, "label": "Page_514", "shape": "dot", "size": 10, "title": "Page_514"}, {"color": "blue", "id": 515, "label": "Page_515", "shape": "dot", "size": 10, "title": "Page_515"}, {"color": "blue", "id": 516, "label": "Page_516", "shape": "dot", "size": 10, "title": "Page_516"}, {"color": "blue", "id": 517, "label": "Page_517", "shape": "dot", "size": 10, "title": "Page_517"}, {"color": "blue", "id": 518, "label": "Page_518", "shape": "dot", "size": 10, "title": "Page_518"}, {"color": "blue", "id": 519, "label": "Page_519", "shape": "dot", "size": 10, "title": "Page_519"}, {"color": "blue", "id": 520, "label": "Page_520", "shape": "dot", "size": 10, "title": "Page_520"}, {"color": "blue", "id": 521, "label": "Page_521", "shape": "dot", "size": 10, "title": "Page_521"}, {"color": "blue", "id": 522, "label": "Page_522", "shape": "dot", "size": 10, "title": "Page_522"}, {"color": "blue", "id": 523, "label": "Page_523", "shape": "dot", "size": 10, "title": "Page_523"}, {"color": "blue", "id": 524, "label": "Page_524", "shape": "dot", "size": 10, "title": "Page_524"}, {"color": "blue", "id": 525, "label": "Page_525", "shape": "dot", "size": 10, "title": "Page_525"}, {"color": "blue", "id": 526, "label": "Page_526", "shape": "dot", "size": 10, "title": "Page_526"}, {"color": "blue", "id": 527, "label": "Page_527", "shape": "dot", "size": 10, "title": "Page_527"}, {"color": "blue", "id": 528, "label": "Page_528", "shape": "dot", "size": 10, "title": "Page_528"}, {"color": "blue", "id": 529, "label": "Page_529", "shape": "dot", "size": 10, "title": "Page_529"}, {"color": "blue", "id": 530, "label": "Page_530", "shape": "dot", "size": 10, "title": "Page_530"}, {"color": "blue", "id": 531, "label": "Page_531", "shape": "dot", "size": 10, "title": "Page_531"}, {"color": "blue", "id": 532, "label": "Page_532", "shape": "dot", "size": 10, "title": "Page_532"}, {"color": "blue", "id": 533, "label": "Page_533", "shape": "dot", "size": 10, "title": "Page_533"}, {"color": "blue", "id": 534, "label": "Page_534", "shape": "dot", "size": 10, "title": "Page_534"}, {"color": "blue", "id": 535, "label": "Page_535", "shape": "dot", "size": 10, "title": "Page_535"}, {"color": "blue", "id": 536, "label": "Page_536", "shape": "dot", "size": 10, "title": "Page_536"}, {"color": "blue", "id": 537, "label": "Page_537", "shape": "dot", "size": 10, "title": "Page_537"}, {"color": "blue", "id": 538, "label": "Page_538", "shape": "dot", "size": 10, "title": "Page_538"}, {"color": "blue", "id": 539, "label": "Page_539", "shape": "dot", "size": 10, "title": "Page_539"}, {"color": "blue", "id": 540, "label": "Page_540", "shape": "dot", "size": 10, "title": "Page_540"}, {"color": "blue", "id": 541, "label": "Page_541", "shape": "dot", "size": 10, "title": "Page_541"}, {"color": "blue", "id": 542, "label": "Page_542", "shape": "dot", "size": 10, "title": "Page_542"}, {"color": "blue", "id": 543, "label": "Page_543", "shape": "dot", "size": 10, "title": "Page_543"}, {"color": "blue", "id": 544, "label": "Page_544", "shape": "dot", "size": 10, "title": "Page_544"}, {"color": "blue", "id": 545, "label": "Page_545", "shape": "dot", "size": 10, "title": "Page_545"}, {"color": "blue", "id": 546, "label": "Page_546", "shape": "dot", "size": 10, "title": "Page_546"}, {"color": "blue", "id": 547, "label": "Page_547", "shape": "dot", "size": 10, "title": "Page_547"}, {"color": "blue", "id": 548, "label": "Page_548", "shape": "dot", "size": 10, "title": "Page_548"}, {"color": "blue", "id": 549, "label": "Page_549", "shape": "dot", "size": 10, "title": "Page_549"}, {"color": "blue", "id": 550, "label": "Page_550", "shape": "dot", "size": 10, "title": "Page_550"}, {"color": "blue", "id": 551, "label": "Page_551", "shape": "dot", "size": 10, "title": "Page_551"}, {"color": "blue", "id": 552, "label": "Page_552", "shape": "dot", "size": 10, "title": "Page_552"}, {"color": "blue", "id": 553, "label": "Page_553", "shape": "dot", "size": 10, "title": "Page_553"}, {"color": "blue", "id": 554, "label": "Page_554", "shape": "dot", "size": 10, "title": "Page_554"}, {"color": "blue", "id": 555, "label": "Page_555", "shape": "dot", "size": 10, "title": "Page_555"}, {"color": "blue", "id": 556, "label": "Page_556", "shape": "dot", "size": 10, "title": "Page_556"}, {"color": "blue", "id": 557, "label": "Page_557", "shape": "dot", "size": 10, "title": "Page_557"}, {"color": "blue", "id": 558, "label": "Page_558", "shape": "dot", "size": 10, "title": "Page_558"}, {"color": "blue", "id": 559, "label": "Page_559", "shape": "dot", "size": 10, "title": "Page_559"}, {"color": "blue", "id": 560, "label": "Page_560", "shape": "dot", "size": 10, "title": "Page_560"}, {"color": "blue", "id": 561, "label": "Page_561", "shape": "dot", "size": 10, "title": "Page_561"}, {"color": "blue", "id": 562, "label": "Page_562", "shape": "dot", "size": 10, "title": "Page_562"}, {"color": "blue", "id": 563, "label": "Page_563", "shape": "dot", "size": 10, "title": "Page_563"}, {"color": "blue", "id": 564, "label": "Page_564", "shape": "dot", "size": 10, "title": "Page_564"}, {"color": "blue", "id": 565, "label": "Page_565", "shape": "dot", "size": 10, "title": "Page_565"}, {"color": "blue", "id": 566, "label": "Page_566", "shape": "dot", "size": 10, "title": "Page_566"}, {"color": "blue", "id": 567, "label": "Page_567", "shape": "dot", "size": 10, "title": "Page_567"}, {"color": "green", "id": "text_1", "label": "58\nCHAPTER 3\nPods: running containers in Kubernetes\nINTRODUCING THE FLAT INTER-POD NETWORK\nAll pods in a Kubernetes cluster reside in a single flat, shared, network-address space\n(shown in figure 3.2), which means every pod can access every other pod at the other\npod\u2019s IP address. No NAT (Network Address Translation) gateways exist between them.\nWhen two pods send network packets between each other, they\u2019ll each see the actual\nIP address of the other as the source IP in the packet.\nConsequently, communication between pods is always simple. It doesn\u2019t matter if two\npods are scheduled onto a single or onto different worker nodes; in both cases the\ncontainers inside those pods can communicate with each other across the flat NAT-\nless network, much like computers on a local area network (LAN), regardless of the\nactual inter-node network topology. Like a computer on a LAN, each pod gets its own\nIP address and is accessible from all other pods through this network established spe-\ncifically for pods. This is usually achieved through an additional software-defined net-\nwork layered on top of the actual network.\n To sum up what\u2019s been covered in this section: pods are logical hosts and behave\nmuch like physical hosts or VMs in the non-container world. Processes running in the\nsame pod are like processes running on the same physical or virtual machine, except\nthat each process is encapsulated in a container. \n3.1.3\nOrganizing containers across pods properly\nYou should think of pods as separate machines, but where each one hosts only a cer-\ntain app. Unlike the old days, when we used to cram all sorts of apps onto the same\nhost, we don\u2019t do that with pods. Because pods are relatively lightweight, you can have\nas many as you need without incurring almost any overhead. Instead of stuffing every-\nthing into a single pod, you should organize apps into multiple pods, where each one\ncontains only tightly related components or processes.\nNode 1\nPod A\nIP: 10.1.1.6\nContainer 1\nContainer 2\nPod B\nIP: 10.1.1.7\nContainer 1\nContainer 2\nNode 2\nFlat network\nPod C\nIP: 10.1.2.5\nContainer 1\nContainer 2\nPod D\nIP: 10.1.2.7\nContainer 1\nContainer 2\nFigure 3.2\nEach pod gets a routable IP address and all other pods see the pod under \nthat IP address.\n \n", "shape": "dot", "size": 10, "title": "58\nCHAPTER 3\nPods: running containers in Kubernetes\nINTRODUCING THE FLAT INTER-POD NETWORK\nAll pods in a Kubernetes cluster reside in a single flat, shared, network-address space\n(shown in figure 3.2), which means every pod can access every other pod at the other\npod\u2019s IP address. No NAT (Network Address Translation) gateways exist between them.\nWhen two pods send network packets between each other, they\u2019ll each see the actual\nIP address of the other as the source IP in the packet.\nConsequently, communication between pods is always simple. It doesn\u2019t matter if two\npods are scheduled onto a single or onto different worker nodes; in both cases the\ncontainers inside those pods can communicate with each other across the flat NAT-\nless network, much like computers on a local area network (LAN), regardless of the\nactual inter-node network topology. Like a computer on a LAN, each pod gets its own\nIP address and is accessible from all other pods through this network established spe-\ncifically for pods. This is usually achieved through an additional software-defined net-\nwork layered on top of the actual network.\n To sum up what\u2019s been covered in this section: pods are logical hosts and behave\nmuch like physical hosts or VMs in the non-container world. Processes running in the\nsame pod are like processes running on the same physical or virtual machine, except\nthat each process is encapsulated in a container. \n3.1.3\nOrganizing containers across pods properly\nYou should think of pods as separate machines, but where each one hosts only a cer-\ntain app. Unlike the old days, when we used to cram all sorts of apps onto the same\nhost, we don\u2019t do that with pods. Because pods are relatively lightweight, you can have\nas many as you need without incurring almost any overhead. Instead of stuffing every-\nthing into a single pod, you should organize apps into multiple pods, where each one\ncontains only tightly related components or processes.\nNode 1\nPod A\nIP: 10.1.1.6\nContainer 1\nContainer 2\nPod B\nIP: 10.1.1.7\nContainer 1\nContainer 2\nNode 2\nFlat network\nPod C\nIP: 10.1.2.5\nContainer 1\nContainer 2\nPod D\nIP: 10.1.2.7\nContainer 1\nContainer 2\nFigure 3.2\nEach pod gets a routable IP address and all other pods see the pod under \nthat IP address.\n \n"}, {"color": "green", "id": "text_2", "label": "59\nIntroducing pods\n Having said that, do you think a multi-tier application consisting of a frontend\napplication server and a backend database should be configured as a single pod or as\ntwo pods?\nSPLITTING MULTI-TIER APPS INTO MULTIPLE PODS\nAlthough nothing is stopping you from running both the frontend server and the\ndatabase in a single pod with two containers, it isn\u2019t the most appropriate way. We\u2019ve\nsaid that all containers of the same pod always run co-located, but do the web server\nand the database really need to run on the same machine? The answer is obviously no,\nso you don\u2019t want to put them into a single pod. But is it wrong to do so regardless? In\na way, it is.\n If both the frontend and backend are in the same pod, then both will always be\nrun on the same machine. If you have a two-node Kubernetes cluster and only this sin-\ngle pod, you\u2019ll only be using a single worker node and not taking advantage of the\ncomputational resources (CPU and memory) you have at your disposal on the second\nnode. Splitting the pod into two would allow Kubernetes to schedule the frontend to\none node and the backend to the other node, thereby improving the utilization of\nyour infrastructure.\nSPLITTING INTO MULTIPLE PODS TO ENABLE INDIVIDUAL SCALING\nAnother reason why you shouldn\u2019t put them both into a single pod is scaling. A pod is\nalso the basic unit of scaling. Kubernetes can\u2019t horizontally scale individual contain-\ners; instead, it scales whole pods. If your pod consists of a frontend and a backend con-\ntainer, when you scale up the number of instances of the pod to, let\u2019s say, two, you end\nup with two frontend containers and two backend containers. \n Usually, frontend components have completely different scaling requirements\nthan the backends, so we tend to scale them individually. Not to mention the fact that\nbackends such as databases are usually much harder to scale compared to (stateless)\nfrontend web servers. If you need to scale a container individually, this is a clear indi-\ncation that it needs to be deployed in a separate pod. \nUNDERSTANDING WHEN TO USE MULTIPLE CONTAINERS IN A POD\nThe main reason to put multiple containers into a single pod is when the application\nconsists of one main process and one or more complementary processes, as shown in\nfigure 3.3.\nPod\nMain container\nSupporting\ncontainer 1\nSupporting\ncontainer 2\nVolume\nFigure 3.3\nPods should contain tightly coupled \ncontainers, usually a main container and containers \nthat support the main one.\n \n", "shape": "dot", "size": 10, "title": "59\nIntroducing pods\n Having said that, do you think a multi-tier application consisting of a frontend\napplication server and a backend database should be configured as a single pod or as\ntwo pods?\nSPLITTING MULTI-TIER APPS INTO MULTIPLE PODS\nAlthough nothing is stopping you from running both the frontend server and the\ndatabase in a single pod with two containers, it isn\u2019t the most appropriate way. We\u2019ve\nsaid that all containers of the same pod always run co-located, but do the web server\nand the database really need to run on the same machine? The answer is obviously no,\nso you don\u2019t want to put them into a single pod. But is it wrong to do so regardless? In\na way, it is.\n If both the frontend and backend are in the same pod, then both will always be\nrun on the same machine. If you have a two-node Kubernetes cluster and only this sin-\ngle pod, you\u2019ll only be using a single worker node and not taking advantage of the\ncomputational resources (CPU and memory) you have at your disposal on the second\nnode. Splitting the pod into two would allow Kubernetes to schedule the frontend to\none node and the backend to the other node, thereby improving the utilization of\nyour infrastructure.\nSPLITTING INTO MULTIPLE PODS TO ENABLE INDIVIDUAL SCALING\nAnother reason why you shouldn\u2019t put them both into a single pod is scaling. A pod is\nalso the basic unit of scaling. Kubernetes can\u2019t horizontally scale individual contain-\ners; instead, it scales whole pods. If your pod consists of a frontend and a backend con-\ntainer, when you scale up the number of instances of the pod to, let\u2019s say, two, you end\nup with two frontend containers and two backend containers. \n Usually, frontend components have completely different scaling requirements\nthan the backends, so we tend to scale them individually. Not to mention the fact that\nbackends such as databases are usually much harder to scale compared to (stateless)\nfrontend web servers. If you need to scale a container individually, this is a clear indi-\ncation that it needs to be deployed in a separate pod. \nUNDERSTANDING WHEN TO USE MULTIPLE CONTAINERS IN A POD\nThe main reason to put multiple containers into a single pod is when the application\nconsists of one main process and one or more complementary processes, as shown in\nfigure 3.3.\nPod\nMain container\nSupporting\ncontainer 1\nSupporting\ncontainer 2\nVolume\nFigure 3.3\nPods should contain tightly coupled \ncontainers, usually a main container and containers \nthat support the main one.\n \n"}, {"color": "green", "id": "text_3", "label": "60\nCHAPTER 3\nPods: running containers in Kubernetes\nFor example, the main container in a pod could be a web server that serves files from\na certain file directory, while an additional container (a sidecar container) periodi-\ncally downloads content from an external source and stores it in the web server\u2019s\ndirectory. In chapter 6 you\u2019ll see that you need to use a Kubernetes Volume that you\nmount into both containers. \n Other examples of sidecar containers include log rotators and collectors, data pro-\ncessors, communication adapters, and others.\nDECIDING WHEN TO USE MULTIPLE CONTAINERS IN A POD\nTo recap how containers should be grouped into pods\u2014when deciding whether to\nput two containers into a single pod or into two separate pods, you always need to ask\nyourself the following questions:\n\uf0a1Do they need to be run together or can they run on different hosts?\n\uf0a1Do they represent a single whole or are they independent components?\n\uf0a1Must they be scaled together or individually? \nBasically, you should always gravitate toward running containers in separate pods,\nunless a specific reason requires them to be part of the same pod. Figure 3.4 will help\nyou memorize this.\nAlthough pods can contain multiple containers, to keep things simple for now, you\u2019ll\nonly be dealing with single-container pods in this chapter. You\u2019ll see how multiple\ncontainers are used in the same pod later, in chapter 6. \nPod\nFrontend\nprocess\nBackend\nprocess\nContainer\nPod\nFrontend\nprocess\nFrontend\ncontainer\nFrontend pod\nFrontend\nprocess\nFrontend\ncontainer\nBackend pod\nBackend\nprocess\nBackend\ncontainer\nBackend\nprocess\nBackend\ncontainer\nFigure 3.4\nA container shouldn\u2019t run multiple processes. A pod shouldn\u2019t contain multiple \ncontainers if they don\u2019t need to run on the same machine.\n \n", "shape": "dot", "size": 10, "title": "60\nCHAPTER 3\nPods: running containers in Kubernetes\nFor example, the main container in a pod could be a web server that serves files from\na certain file directory, while an additional container (a sidecar container) periodi-\ncally downloads content from an external source and stores it in the web server\u2019s\ndirectory. In chapter 6 you\u2019ll see that you need to use a Kubernetes Volume that you\nmount into both containers. \n Other examples of sidecar containers include log rotators and collectors, data pro-\ncessors, communication adapters, and others.\nDECIDING WHEN TO USE MULTIPLE CONTAINERS IN A POD\nTo recap how containers should be grouped into pods\u2014when deciding whether to\nput two containers into a single pod or into two separate pods, you always need to ask\nyourself the following questions:\n\uf0a1Do they need to be run together or can they run on different hosts?\n\uf0a1Do they represent a single whole or are they independent components?\n\uf0a1Must they be scaled together or individually? \nBasically, you should always gravitate toward running containers in separate pods,\nunless a specific reason requires them to be part of the same pod. Figure 3.4 will help\nyou memorize this.\nAlthough pods can contain multiple containers, to keep things simple for now, you\u2019ll\nonly be dealing with single-container pods in this chapter. You\u2019ll see how multiple\ncontainers are used in the same pod later, in chapter 6. \nPod\nFrontend\nprocess\nBackend\nprocess\nContainer\nPod\nFrontend\nprocess\nFrontend\ncontainer\nFrontend pod\nFrontend\nprocess\nFrontend\ncontainer\nBackend pod\nBackend\nprocess\nBackend\ncontainer\nBackend\nprocess\nBackend\ncontainer\nFigure 3.4\nA container shouldn\u2019t run multiple processes. A pod shouldn\u2019t contain multiple \ncontainers if they don\u2019t need to run on the same machine.\n \n"}, {"color": "green", "id": "text_4", "label": "61\nCreating pods from YAML or JSON descriptors\n3.2\nCreating pods from YAML or JSON descriptors\nPods and other Kubernetes resources are usually created by posting a JSON or YAML\nmanifest to the Kubernetes REST API endpoint. Also, you can use other, simpler ways\nof creating resources, such as the kubectl run command you used in the previous\nchapter, but they usually only allow you to configure a limited set of properties, not\nall. Additionally, defining all your Kubernetes objects from YAML files makes it possi-\nble to store them in a version control system, with all the benefits it brings.\n To configure all aspects of each type of resource, you\u2019ll need to know and under-\nstand the Kubernetes API object definitions. You\u2019ll get to know most of them as you\nlearn about each resource type throughout this book. We won\u2019t explain every single\nproperty, so you should also refer to the Kubernetes API reference documentation at\nhttp:/\n/kubernetes.io/docs/reference/ when creating objects.\n3.2.1\nExamining a YAML descriptor of an existing pod\nYou already have some existing pods you created in the previous chapter, so let\u2019s look\nat what a YAML definition for one of those pods looks like. You\u2019ll use the kubectl get\ncommand with the -o yaml option to get the whole YAML definition of the pod, as\nshown in the following listing.\n$ kubectl get po kubia-zxzij -o yaml\napiVersion: v1                         \nkind: Pod                                       \nmetadata:                                                 \n  annotations:                                            \n    kubernetes.io/created-by: ...                         \n  creationTimestamp: 2016-03-18T12:37:50Z                 \n  generateName: kubia-                                    \n  labels:                                                 \n    run: kubia                                            \n  name: kubia-zxzij                                       \n  namespace: default                                      \n  resourceVersion: \"294\"                                  \n  selfLink: /api/v1/namespaces/default/pods/kubia-zxzij   \n  uid: 3a564dc0-ed06-11e5-ba3b-42010af00004               \nspec:                                                   \n  containers:                                           \n  - image: luksa/kubia                                  \n    imagePullPolicy: IfNotPresent                       \n    name: kubia                                         \n    ports:                                              \n    - containerPort: 8080                               \n      protocol: TCP                                     \n    resources:                                          \n      requests:                                         \n        cpu: 100m                                       \nListing 3.1\nFull YAML of a deployed pod\nKubernetes API version used \nin this YAML descriptor\nType of Kubernetes \nobject/resource\nPod metadata (name, \nlabels, annotations, \nand so on)\nPod specification/\ncontents (list of \npod\u2019s containers, \nvolumes, and so on)\n \n", "shape": "dot", "size": 10, "title": "61\nCreating pods from YAML or JSON descriptors\n3.2\nCreating pods from YAML or JSON descriptors\nPods and other Kubernetes resources are usually created by posting a JSON or YAML\nmanifest to the Kubernetes REST API endpoint. Also, you can use other, simpler ways\nof creating resources, such as the kubectl run command you used in the previous\nchapter, but they usually only allow you to configure a limited set of properties, not\nall. Additionally, defining all your Kubernetes objects from YAML files makes it possi-\nble to store them in a version control system, with all the benefits it brings.\n To configure all aspects of each type of resource, you\u2019ll need to know and under-\nstand the Kubernetes API object definitions. You\u2019ll get to know most of them as you\nlearn about each resource type throughout this book. We won\u2019t explain every single\nproperty, so you should also refer to the Kubernetes API reference documentation at\nhttp:/\n/kubernetes.io/docs/reference/ when creating objects.\n3.2.1\nExamining a YAML descriptor of an existing pod\nYou already have some existing pods you created in the previous chapter, so let\u2019s look\nat what a YAML definition for one of those pods looks like. You\u2019ll use the kubectl get\ncommand with the -o yaml option to get the whole YAML definition of the pod, as\nshown in the following listing.\n$ kubectl get po kubia-zxzij -o yaml\napiVersion: v1                         \nkind: Pod                                       \nmetadata:                                                 \n  annotations:                                            \n    kubernetes.io/created-by: ...                         \n  creationTimestamp: 2016-03-18T12:37:50Z                 \n  generateName: kubia-                                    \n  labels:                                                 \n    run: kubia                                            \n  name: kubia-zxzij                                       \n  namespace: default                                      \n  resourceVersion: \"294\"                                  \n  selfLink: /api/v1/namespaces/default/pods/kubia-zxzij   \n  uid: 3a564dc0-ed06-11e5-ba3b-42010af00004               \nspec:                                                   \n  containers:                                           \n  - image: luksa/kubia                                  \n    imagePullPolicy: IfNotPresent                       \n    name: kubia                                         \n    ports:                                              \n    - containerPort: 8080                               \n      protocol: TCP                                     \n    resources:                                          \n      requests:                                         \n        cpu: 100m                                       \nListing 3.1\nFull YAML of a deployed pod\nKubernetes API version used \nin this YAML descriptor\nType of Kubernetes \nobject/resource\nPod metadata (name, \nlabels, annotations, \nand so on)\nPod specification/\ncontents (list of \npod\u2019s containers, \nvolumes, and so on)\n \n"}, {"color": "green", "id": "text_5", "label": "62\nCHAPTER 3\nPods: running containers in Kubernetes\n    terminationMessagePath: /dev/termination-log      \n    volumeMounts:                                     \n    - mountPath: /var/run/secrets/k8s.io/servacc      \n      name: default-token-kvcqa                       \n      readOnly: true                                  \n  dnsPolicy: ClusterFirst                             \n  nodeName: gke-kubia-e8fe08b8-node-txje              \n  restartPolicy: Always                               \n  serviceAccount: default                             \n  serviceAccountName: default                         \n  terminationGracePeriodSeconds: 30                   \n  volumes:                                            \n  - name: default-token-kvcqa                         \n    secret:                                           \n      secretName: default-token-kvcqa                 \nstatus:                                                   \n  conditions:                                             \n  - lastProbeTime: null                                   \n    lastTransitionTime: null                              \n    status: \"True\"                                        \n    type: Ready                                           \n  containerStatuses:                                      \n  - containerID: docker://f0276994322d247ba...            \n    image: luksa/kubia                                    \n    imageID: docker://4c325bcc6b40c110226b89fe...         \n    lastState: {}                                         \n    name: kubia                                           \n    ready: true                                           \n    restartCount: 0                                       \n    state:                                                \n      running:                                            \n        startedAt: 2016-03-18T12:46:05Z                   \n  hostIP: 10.132.0.4                                      \n  phase: Running                                          \n  podIP: 10.0.2.3                                         \n  startTime: 2016-03-18T12:44:32Z                         \nI know this looks complicated, but it becomes simple once you understand the basics\nand know how to distinguish between the important parts and the minor details. Also,\nyou can take comfort in the fact that when creating a new pod, the YAML you need to\nwrite is much shorter, as you\u2019ll see later.\nINTRODUCING THE MAIN PARTS OF A POD DEFINITION\nThe pod definition consists of a few parts. First, there\u2019s the Kubernetes API version\nused in the YAML and the type of resource the YAML is describing. Then, three\nimportant sections are found in almost all Kubernetes resources:\n\uf0a1Metadata includes the name, namespace, labels, and other information about\nthe pod.\n\uf0a1Spec contains the actual description of the pod\u2019s contents, such as the pod\u2019s con-\ntainers, volumes, and other data.\nPod specification/\ncontents (list of \npod\u2019s containers, \nvolumes, and so on)\nDetailed status \nof the pod and \nits containers\n \n", "shape": "dot", "size": 10, "title": "62\nCHAPTER 3\nPods: running containers in Kubernetes\n    terminationMessagePath: /dev/termination-log      \n    volumeMounts:                                     \n    - mountPath: /var/run/secrets/k8s.io/servacc      \n      name: default-token-kvcqa                       \n      readOnly: true                                  \n  dnsPolicy: ClusterFirst                             \n  nodeName: gke-kubia-e8fe08b8-node-txje              \n  restartPolicy: Always                               \n  serviceAccount: default                             \n  serviceAccountName: default                         \n  terminationGracePeriodSeconds: 30                   \n  volumes:                                            \n  - name: default-token-kvcqa                         \n    secret:                                           \n      secretName: default-token-kvcqa                 \nstatus:                                                   \n  conditions:                                             \n  - lastProbeTime: null                                   \n    lastTransitionTime: null                              \n    status: \"True\"                                        \n    type: Ready                                           \n  containerStatuses:                                      \n  - containerID: docker://f0276994322d247ba...            \n    image: luksa/kubia                                    \n    imageID: docker://4c325bcc6b40c110226b89fe...         \n    lastState: {}                                         \n    name: kubia                                           \n    ready: true                                           \n    restartCount: 0                                       \n    state:                                                \n      running:                                            \n        startedAt: 2016-03-18T12:46:05Z                   \n  hostIP: 10.132.0.4                                      \n  phase: Running                                          \n  podIP: 10.0.2.3                                         \n  startTime: 2016-03-18T12:44:32Z                         \nI know this looks complicated, but it becomes simple once you understand the basics\nand know how to distinguish between the important parts and the minor details. Also,\nyou can take comfort in the fact that when creating a new pod, the YAML you need to\nwrite is much shorter, as you\u2019ll see later.\nINTRODUCING THE MAIN PARTS OF A POD DEFINITION\nThe pod definition consists of a few parts. First, there\u2019s the Kubernetes API version\nused in the YAML and the type of resource the YAML is describing. Then, three\nimportant sections are found in almost all Kubernetes resources:\n\uf0a1Metadata includes the name, namespace, labels, and other information about\nthe pod.\n\uf0a1Spec contains the actual description of the pod\u2019s contents, such as the pod\u2019s con-\ntainers, volumes, and other data.\nPod specification/\ncontents (list of \npod\u2019s containers, \nvolumes, and so on)\nDetailed status \nof the pod and \nits containers\n \n"}, {"color": "green", "id": "text_6", "label": "63\nCreating pods from YAML or JSON descriptors\n\uf0a1Status contains the current information about the running pod, such as what\ncondition the pod is in, the description and status of each container, and the\npod\u2019s internal IP and other basic info.\nListing 3.1 showed a full description of a running pod, including its status. The status\npart contains read-only runtime data that shows the state of the resource at a given\nmoment. When creating a new pod, you never need to provide the status part. \n The three parts described previously show the typical structure of a Kubernetes\nAPI object. As you\u2019ll see throughout the book, all other objects have the same anat-\nomy. This makes understanding new objects relatively easy.\n Going through all the individual properties in the previous YAML doesn\u2019t make\nmuch sense, so, instead, let\u2019s see what the most basic YAML for creating a pod looks\nlike. \n3.2.2\nCreating a simple YAML descriptor for a pod\nYou\u2019re going to create a file called kubia-manual.yaml (you can create it in any\ndirectory you want), or download the book\u2019s code archive, where you\u2019ll find the\nfile inside the Chapter03 directory. The following listing shows the entire contents\nof the file.\napiVersion: v1         \nkind: Pod                             \nmetadata:     \n  name: kubia-manual         \nspec: \n  containers: \n  - image: luksa/kubia          \n    name: kubia         \n    ports: \n    - containerPort: 8080     \n      protocol: TCP\nI\u2019m sure you\u2019ll agree this is much simpler than the definition in listing 3.1. Let\u2019s exam-\nine this descriptor in detail. It conforms to the v1 version of the Kubernetes API. The\ntype of resource you\u2019re describing is a pod, with the name kubia-manual. The pod\nconsists of a single container based on the luksa/kubia image. You\u2019ve also given a\nname to the container and indicated that it\u2019s listening on port 8080. \nSPECIFYING CONTAINER PORTS\nSpecifying ports in the pod definition is purely informational. Omitting them has no\neffect on whether clients can connect to the pod through the port or not. If the con-\nListing 3.2\nA basic pod manifest: kubia-manual.yaml\nDescriptor conforms\nto version v1 of\nKubernetes API\nYou\u2019re \ndescribing a pod.\nThe name \nof the pod\nContainer image to create \nthe container from\nName of the container\nThe port the app \nis listening on\n \n", "shape": "dot", "size": 10, "title": "63\nCreating pods from YAML or JSON descriptors\n\uf0a1Status contains the current information about the running pod, such as what\ncondition the pod is in, the description and status of each container, and the\npod\u2019s internal IP and other basic info.\nListing 3.1 showed a full description of a running pod, including its status. The status\npart contains read-only runtime data that shows the state of the resource at a given\nmoment. When creating a new pod, you never need to provide the status part. \n The three parts described previously show the typical structure of a Kubernetes\nAPI object. As you\u2019ll see throughout the book, all other objects have the same anat-\nomy. This makes understanding new objects relatively easy.\n Going through all the individual properties in the previous YAML doesn\u2019t make\nmuch sense, so, instead, let\u2019s see what the most basic YAML for creating a pod looks\nlike. \n3.2.2\nCreating a simple YAML descriptor for a pod\nYou\u2019re going to create a file called kubia-manual.yaml (you can create it in any\ndirectory you want), or download the book\u2019s code archive, where you\u2019ll find the\nfile inside the Chapter03 directory. The following listing shows the entire contents\nof the file.\napiVersion: v1         \nkind: Pod                             \nmetadata:     \n  name: kubia-manual         \nspec: \n  containers: \n  - image: luksa/kubia          \n    name: kubia         \n    ports: \n    - containerPort: 8080     \n      protocol: TCP\nI\u2019m sure you\u2019ll agree this is much simpler than the definition in listing 3.1. Let\u2019s exam-\nine this descriptor in detail. It conforms to the v1 version of the Kubernetes API. The\ntype of resource you\u2019re describing is a pod, with the name kubia-manual. The pod\nconsists of a single container based on the luksa/kubia image. You\u2019ve also given a\nname to the container and indicated that it\u2019s listening on port 8080. \nSPECIFYING CONTAINER PORTS\nSpecifying ports in the pod definition is purely informational. Omitting them has no\neffect on whether clients can connect to the pod through the port or not. If the con-\nListing 3.2\nA basic pod manifest: kubia-manual.yaml\nDescriptor conforms\nto version v1 of\nKubernetes API\nYou\u2019re \ndescribing a pod.\nThe name \nof the pod\nContainer image to create \nthe container from\nName of the container\nThe port the app \nis listening on\n \n"}, {"color": "green", "id": "text_7", "label": "64\nCHAPTER 3\nPods: running containers in Kubernetes\ntainer is accepting connections through a port bound to the 0.0.0.0 address, other\npods can always connect to it, even if the port isn\u2019t listed in the pod spec explicitly. But\nit makes sense to define the ports explicitly so that everyone using your cluster can\nquickly see what ports each pod exposes. Explicitly defining ports also allows you to\nassign a name to each port, which can come in handy, as you\u2019ll see later in the book.\nUsing kubectl explain to discover possible API object fields\nWhen preparing a manifest, you can either turn to the Kubernetes reference\ndocumentation at http:/\n/kubernetes.io/docs/api to see which attributes are\nsupported by each API object, or you can use the kubectl explain command.\nFor example, when creating a pod manifest from scratch, you can start by asking\nkubectl to explain pods:\n$ kubectl explain pods\nDESCRIPTION:\nPod is a collection of containers that can run on a host. This resource \nis created by clients and scheduled onto hosts.\nFIELDS:\n   kind      \u003cstring\u003e\n     Kind is a string value representing the REST resource this object\n     represents...\n   metadata  \u003cObject\u003e\n     Standard object\u0027s metadata...\n   spec      \u003cObject\u003e\n     Specification of the desired behavior of the pod...\n   status    \u003cObject\u003e\n     Most recently observed status of the pod. This data may not be up to\n     date...\nKubectl prints out the explanation of the object and lists the attributes the object\ncan contain. You can then drill deeper to find out more about each attribute. For\nexample, you can examine the spec attribute like this:\n$ kubectl explain pod.spec\nRESOURCE: spec \u003cObject\u003e\nDESCRIPTION:\n    Specification of the desired behavior of the pod...\n    podSpec is a description of a pod.\nFIELDS:\n   hostPID   \u003cboolean\u003e\n     Use the host\u0027s pid namespace. Optional: Default to false.\n   ...\n   volumes   \u003c[]Object\u003e\n     List of volumes that can be mounted by containers belonging to the\n     pod.\n \n", "shape": "dot", "size": 10, "title": "64\nCHAPTER 3\nPods: running containers in Kubernetes\ntainer is accepting connections through a port bound to the 0.0.0.0 address, other\npods can always connect to it, even if the port isn\u2019t listed in the pod spec explicitly. But\nit makes sense to define the ports explicitly so that everyone using your cluster can\nquickly see what ports each pod exposes. Explicitly defining ports also allows you to\nassign a name to each port, which can come in handy, as you\u2019ll see later in the book.\nUsing kubectl explain to discover possible API object fields\nWhen preparing a manifest, you can either turn to the Kubernetes reference\ndocumentation at http:/\n/kubernetes.io/docs/api to see which attributes are\nsupported by each API object, or you can use the kubectl explain command.\nFor example, when creating a pod manifest from scratch, you can start by asking\nkubectl to explain pods:\n$ kubectl explain pods\nDESCRIPTION:\nPod is a collection of containers that can run on a host. This resource \nis created by clients and scheduled onto hosts.\nFIELDS:\n   kind      \u003cstring\u003e\n     Kind is a string value representing the REST resource this object\n     represents...\n   metadata  \u003cObject\u003e\n     Standard object\u0027s metadata...\n   spec      \u003cObject\u003e\n     Specification of the desired behavior of the pod...\n   status    \u003cObject\u003e\n     Most recently observed status of the pod. This data may not be up to\n     date...\nKubectl prints out the explanation of the object and lists the attributes the object\ncan contain. You can then drill deeper to find out more about each attribute. For\nexample, you can examine the spec attribute like this:\n$ kubectl explain pod.spec\nRESOURCE: spec \u003cObject\u003e\nDESCRIPTION:\n    Specification of the desired behavior of the pod...\n    podSpec is a description of a pod.\nFIELDS:\n   hostPID   \u003cboolean\u003e\n     Use the host\u0027s pid namespace. Optional: Default to false.\n   ...\n   volumes   \u003c[]Object\u003e\n     List of volumes that can be mounted by containers belonging to the\n     pod.\n \n"}, {"color": "green", "id": "text_8", "label": "65\nCreating pods from YAML or JSON descriptors\n3.2.3\nUsing kubectl create to create the pod\nTo create the pod from your YAML file, use the kubectl create command:\n$ kubectl create -f kubia-manual.yaml\npod \"kubia-manual\" created\nThe kubectl create -f command is used for creating any resource (not only pods)\nfrom a YAML or JSON file. \nRETRIEVING THE WHOLE DEFINITION OF A RUNNING POD\nAfter creating the pod, you can ask Kubernetes for the full YAML of the pod. You\u2019ll\nsee it\u2019s similar to the YAML you saw earlier. You\u2019ll learn about the additional fields\nappearing in the returned definition in the next sections. Go ahead and use the fol-\nlowing command to see the full descriptor of the pod:\n$ kubectl get po kubia-manual -o yaml\nIf you\u2019re more into JSON, you can also tell kubectl to return JSON instead of YAML\nlike this (this works even if you used YAML to create the pod):\n$ kubectl get po kubia-manual -o json\nSEEING YOUR NEWLY CREATED POD IN THE LIST OF PODS\nYour pod has been created, but how do you know if it\u2019s running? Let\u2019s list pods to see\ntheir statuses:\n$ kubectl get pods\nNAME            READY   STATUS    RESTARTS   AGE\nkubia-manual    1/1     Running   0          32s\nkubia-zxzij     1/1     Running   0          1d    \nThere\u2019s your kubia-manual pod. Its status shows that it\u2019s running. If you\u2019re like me,\nyou\u2019ll probably want to confirm that\u2019s true by talking to the pod. You\u2019ll do that in a\nminute. First, you\u2019ll look at the app\u2019s log to check for any errors.\n3.2.4\nViewing application logs\nYour little Node.js application logs to the process\u2019s standard output. Containerized\napplications usually log to the standard output and standard error stream instead of\n   Containers  \u003c[]Object\u003e -required-\n     List of containers belonging to the pod. Containers cannot currently\n     Be added or removed. There must be at least one container in a pod.\n     Cannot be updated. More info:\n     http://releases.k8s.io/release-1.4/docs/user-guide/containers.md\n \n", "shape": "dot", "size": 10, "title": "65\nCreating pods from YAML or JSON descriptors\n3.2.3\nUsing kubectl create to create the pod\nTo create the pod from your YAML file, use the kubectl create command:\n$ kubectl create -f kubia-manual.yaml\npod \"kubia-manual\" created\nThe kubectl create -f command is used for creating any resource (not only pods)\nfrom a YAML or JSON file. \nRETRIEVING THE WHOLE DEFINITION OF A RUNNING POD\nAfter creating the pod, you can ask Kubernetes for the full YAML of the pod. You\u2019ll\nsee it\u2019s similar to the YAML you saw earlier. You\u2019ll learn about the additional fields\nappearing in the returned definition in the next sections. Go ahead and use the fol-\nlowing command to see the full descriptor of the pod:\n$ kubectl get po kubia-manual -o yaml\nIf you\u2019re more into JSON, you can also tell kubectl to return JSON instead of YAML\nlike this (this works even if you used YAML to create the pod):\n$ kubectl get po kubia-manual -o json\nSEEING YOUR NEWLY CREATED POD IN THE LIST OF PODS\nYour pod has been created, but how do you know if it\u2019s running? Let\u2019s list pods to see\ntheir statuses:\n$ kubectl get pods\nNAME            READY   STATUS    RESTARTS   AGE\nkubia-manual    1/1     Running   0          32s\nkubia-zxzij     1/1     Running   0          1d    \nThere\u2019s your kubia-manual pod. Its status shows that it\u2019s running. If you\u2019re like me,\nyou\u2019ll probably want to confirm that\u2019s true by talking to the pod. You\u2019ll do that in a\nminute. First, you\u2019ll look at the app\u2019s log to check for any errors.\n3.2.4\nViewing application logs\nYour little Node.js application logs to the process\u2019s standard output. Containerized\napplications usually log to the standard output and standard error stream instead of\n   Containers  \u003c[]Object\u003e -required-\n     List of containers belonging to the pod. Containers cannot currently\n     Be added or removed. There must be at least one container in a pod.\n     Cannot be updated. More info:\n     http://releases.k8s.io/release-1.4/docs/user-guide/containers.md\n \n"}, {"color": "green", "id": "text_9", "label": "66\nCHAPTER 3\nPods: running containers in Kubernetes\nwriting their logs to files. This is to allow users to view logs of different applications in\na simple, standard way. \n The container runtime (Docker in your case) redirects those streams to files and\nallows you to get the container\u2019s log by running\n$ docker logs \u003ccontainer id\u003e\nYou could use ssh to log into the node where your pod is running and retrieve its logs\nwith docker logs, but Kubernetes provides an easier way. \nRETRIEVING A POD\u2019S LOG WITH KUBECTL LOGS\nTo see your pod\u2019s log (more precisely, the container\u2019s log) you run the following com-\nmand on your local machine (no need to ssh anywhere):\n$ kubectl logs kubia-manual\nKubia server starting...\nYou haven\u2019t sent any web requests to your Node.js app, so the log only shows a single\nlog statement about the server starting up. As you can see, retrieving logs of an appli-\ncation running in Kubernetes is incredibly simple if the pod only contains a single\ncontainer. \nNOTE\nContainer logs are automatically rotated daily and every time the log file\nreaches 10MB in size. The kubectl logs command only shows the log entries\nfrom the last rotation.\nSPECIFYING THE CONTAINER NAME WHEN GETTING LOGS OF A MULTI-CONTAINER POD\nIf your pod includes multiple containers, you have to explicitly specify the container\nname by including the -c \u003ccontainer name\u003e option when running kubectl logs. In\nyour kubia-manual pod, you set the container\u2019s name to kubia, so if additional con-\ntainers exist in the pod, you\u2019d have to get its logs like this:\n$ kubectl logs kubia-manual -c kubia\nKubia server starting...\nNote that you can only retrieve container logs of pods that are still in existence. When\na pod is deleted, its logs are also deleted. To make a pod\u2019s logs available even after the\npod is deleted, you need to set up centralized, cluster-wide logging, which stores all\nthe logs into a central store. Chapter 17 explains how centralized logging works.\n3.2.5\nSending requests to the pod\nThe pod is now running\u2014at least that\u2019s what kubectl get and your app\u2019s log say. But\nhow do you see it in action? In the previous chapter, you used the kubectl expose\ncommand to create a service to gain access to the pod externally. You\u2019re not going to\ndo that now, because a whole chapter is dedicated to services, and you have other ways\nof connecting to a pod for testing and debugging purposes. One of them is through\nport forwarding.\n \n", "shape": "dot", "size": 10, "title": "66\nCHAPTER 3\nPods: running containers in Kubernetes\nwriting their logs to files. This is to allow users to view logs of different applications in\na simple, standard way. \n The container runtime (Docker in your case) redirects those streams to files and\nallows you to get the container\u2019s log by running\n$ docker logs \u003ccontainer id\u003e\nYou could use ssh to log into the node where your pod is running and retrieve its logs\nwith docker logs, but Kubernetes provides an easier way. \nRETRIEVING A POD\u2019S LOG WITH KUBECTL LOGS\nTo see your pod\u2019s log (more precisely, the container\u2019s log) you run the following com-\nmand on your local machine (no need to ssh anywhere):\n$ kubectl logs kubia-manual\nKubia server starting...\nYou haven\u2019t sent any web requests to your Node.js app, so the log only shows a single\nlog statement about the server starting up. As you can see, retrieving logs of an appli-\ncation running in Kubernetes is incredibly simple if the pod only contains a single\ncontainer. \nNOTE\nContainer logs are automatically rotated daily and every time the log file\nreaches 10MB in size. The kubectl logs command only shows the log entries\nfrom the last rotation.\nSPECIFYING THE CONTAINER NAME WHEN GETTING LOGS OF A MULTI-CONTAINER POD\nIf your pod includes multiple containers, you have to explicitly specify the container\nname by including the -c \u003ccontainer name\u003e option when running kubectl logs. In\nyour kubia-manual pod, you set the container\u2019s name to kubia, so if additional con-\ntainers exist in the pod, you\u2019d have to get its logs like this:\n$ kubectl logs kubia-manual -c kubia\nKubia server starting...\nNote that you can only retrieve container logs of pods that are still in existence. When\na pod is deleted, its logs are also deleted. To make a pod\u2019s logs available even after the\npod is deleted, you need to set up centralized, cluster-wide logging, which stores all\nthe logs into a central store. Chapter 17 explains how centralized logging works.\n3.2.5\nSending requests to the pod\nThe pod is now running\u2014at least that\u2019s what kubectl get and your app\u2019s log say. But\nhow do you see it in action? In the previous chapter, you used the kubectl expose\ncommand to create a service to gain access to the pod externally. You\u2019re not going to\ndo that now, because a whole chapter is dedicated to services, and you have other ways\nof connecting to a pod for testing and debugging purposes. One of them is through\nport forwarding.\n \n"}, {"color": "green", "id": "text_10", "label": "67\nOrganizing pods with labels\nFORWARDING A LOCAL NETWORK PORT TO A PORT IN THE POD\nWhen you want to talk to a specific pod without going through a service (for debug-\nging or other reasons), Kubernetes allows you to configure port forwarding to the\npod. This is done through the kubectl port-forward command. The following\ncommand will forward your machine\u2019s local port 8888 to port 8080 of your kubia-\nmanual pod:\n$ kubectl port-forward kubia-manual 8888:8080\n... Forwarding from 127.0.0.1:8888 -\u003e 8080\n... Forwarding from [::1]:8888 -\u003e 8080\nThe port forwarder is running and you can now connect to your pod through the\nlocal port. \nCONNECTING TO THE POD THROUGH THE PORT FORWARDER\nIn a different terminal, you can now use curl to send an HTTP request to your pod\nthrough the kubectl port-forward proxy running on localhost:8888:\n$ curl localhost:8888\nYou\u2019ve hit kubia-manual\nFigure 3.5 shows an overly simplified view of what happens when you send the request.\nIn reality, a couple of additional components sit between the kubectl process and the\npod, but they aren\u2019t relevant right now.\nUsing port forwarding like this is an effective way to test an individual pod. You\u2019ll\nlearn about other similar methods throughout the book. \n3.3\nOrganizing pods with labels\nAt this point, you have two pods running in your cluster. When deploying actual\napplications, most users will end up running many more pods. As the number of\npods increases, the need for categorizing them into subsets becomes more and\nmore evident.\n For example, with microservices architectures, the number of deployed microser-\nvices can easily exceed 20 or more. Those components will probably be replicated\nKubernetes cluster\nPort\n8080\nLocal machine\nkubectl\nport-forward\nprocess\ncurl\nPort\n8888\nPod:\nkubia-manual\nFigure 3.5\nA simplified view of what happens when you use curl with kubectl port-forward\n \n", "shape": "dot", "size": 10, "title": "67\nOrganizing pods with labels\nFORWARDING A LOCAL NETWORK PORT TO A PORT IN THE POD\nWhen you want to talk to a specific pod without going through a service (for debug-\nging or other reasons), Kubernetes allows you to configure port forwarding to the\npod. This is done through the kubectl port-forward command. The following\ncommand will forward your machine\u2019s local port 8888 to port 8080 of your kubia-\nmanual pod:\n$ kubectl port-forward kubia-manual 8888:8080\n... Forwarding from 127.0.0.1:8888 -\u003e 8080\n... Forwarding from [::1]:8888 -\u003e 8080\nThe port forwarder is running and you can now connect to your pod through the\nlocal port. \nCONNECTING TO THE POD THROUGH THE PORT FORWARDER\nIn a different terminal, you can now use curl to send an HTTP request to your pod\nthrough the kubectl port-forward proxy running on localhost:8888:\n$ curl localhost:8888\nYou\u2019ve hit kubia-manual\nFigure 3.5 shows an overly simplified view of what happens when you send the request.\nIn reality, a couple of additional components sit between the kubectl process and the\npod, but they aren\u2019t relevant right now.\nUsing port forwarding like this is an effective way to test an individual pod. You\u2019ll\nlearn about other similar methods throughout the book. \n3.3\nOrganizing pods with labels\nAt this point, you have two pods running in your cluster. When deploying actual\napplications, most users will end up running many more pods. As the number of\npods increases, the need for categorizing them into subsets becomes more and\nmore evident.\n For example, with microservices architectures, the number of deployed microser-\nvices can easily exceed 20 or more. Those components will probably be replicated\nKubernetes cluster\nPort\n8080\nLocal machine\nkubectl\nport-forward\nprocess\ncurl\nPort\n8888\nPod:\nkubia-manual\nFigure 3.5\nA simplified view of what happens when you use curl with kubectl port-forward\n \n"}, {"color": "green", "id": "text_11", "label": "68\nCHAPTER 3\nPods: running containers in Kubernetes\n(multiple copies of the same component will be deployed) and multiple versions or\nreleases (stable, beta, canary, and so on) will run concurrently. This can lead to hun-\ndreds of pods in the system. Without a mechanism for organizing them, you end up\nwith a big, incomprehensible mess, such as the one shown in figure 3.6. The figure\nshows pods of multiple microservices, with several running multiple replicas, and others\nrunning different releases of the same microservice.\nIt\u2019s evident you need a way of organizing them into smaller groups based on arbitrary\ncriteria, so every developer and system administrator dealing with your system can eas-\nily see which pod is which. And you\u2019ll want to operate on every pod belonging to a cer-\ntain group with a single action instead of having to perform the action for each pod\nindividually. \n Organizing pods and all other Kubernetes objects is done through labels.\n3.3.1\nIntroducing labels\nLabels are a simple, yet incredibly powerful, Kubernetes feature for organizing not\nonly pods, but all other Kubernetes resources. A label is an arbitrary key-value pair you\nattach to a resource, which is then utilized when selecting resources using label selectors\n(resources are filtered based on whether they include the label specified in the selec-\ntor). A resource can have more than one label, as long as the keys of those labels are\nunique within that resource. You usually attach labels to resources when you create\nthem, but you can also add additional labels or even modify the values of existing\nlabels later without having to recreate the resource. \nUI pod\nUI pod\nUI pod\nAccount\nService\npod\nProduct\nCatalog\npod\nProduct\nCatalog\npod\nProduct\nCatalog\npod\nShopping\nCart\npod\nShopping\nCart\npod\nOrder\nService\npod\nUI pod\nUI pod\nProduct\nCatalog\npod\nProduct\nCatalog\npod\nOrder\nService\npod\nAccount\nService\npod\nProduct\nCatalog\npod\nProduct\nCatalog\npod\nOrder\nService\npod\nFigure 3.6\nUncategorized pods in a microservices architecture\n \n", "shape": "dot", "size": 10, "title": "68\nCHAPTER 3\nPods: running containers in Kubernetes\n(multiple copies of the same component will be deployed) and multiple versions or\nreleases (stable, beta, canary, and so on) will run concurrently. This can lead to hun-\ndreds of pods in the system. Without a mechanism for organizing them, you end up\nwith a big, incomprehensible mess, such as the one shown in figure 3.6. The figure\nshows pods of multiple microservices, with several running multiple replicas, and others\nrunning different releases of the same microservice.\nIt\u2019s evident you need a way of organizing them into smaller groups based on arbitrary\ncriteria, so every developer and system administrator dealing with your system can eas-\nily see which pod is which. And you\u2019ll want to operate on every pod belonging to a cer-\ntain group with a single action instead of having to perform the action for each pod\nindividually. \n Organizing pods and all other Kubernetes objects is done through labels.\n3.3.1\nIntroducing labels\nLabels are a simple, yet incredibly powerful, Kubernetes feature for organizing not\nonly pods, but all other Kubernetes resources. A label is an arbitrary key-value pair you\nattach to a resource, which is then utilized when selecting resources using label selectors\n(resources are filtered based on whether they include the label specified in the selec-\ntor). A resource can have more than one label, as long as the keys of those labels are\nunique within that resource. You usually attach labels to resources when you create\nthem, but you can also add additional labels or even modify the values of existing\nlabels later without having to recreate the resource. \nUI pod\nUI pod\nUI pod\nAccount\nService\npod\nProduct\nCatalog\npod\nProduct\nCatalog\npod\nProduct\nCatalog\npod\nShopping\nCart\npod\nShopping\nCart\npod\nOrder\nService\npod\nUI pod\nUI pod\nProduct\nCatalog\npod\nProduct\nCatalog\npod\nOrder\nService\npod\nAccount\nService\npod\nProduct\nCatalog\npod\nProduct\nCatalog\npod\nOrder\nService\npod\nFigure 3.6\nUncategorized pods in a microservices architecture\n \n"}, {"color": "green", "id": "text_12", "label": "69\nOrganizing pods with labels\n Let\u2019s turn back to the microservices example from figure 3.6. By adding labels to\nthose pods, you get a much-better-organized system that everyone can easily make\nsense of. Each pod is labeled with two labels:\n\uf0a1\napp, which specifies which app, component, or microservice the pod belongs to. \n\uf0a1\nrel, which shows whether the application running in the pod is a stable, beta,\nor a canary release.\nDEFINITION\nA canary release is when you deploy a new version of an applica-\ntion next to the stable version, and only let a small fraction of users hit the\nnew version to see how it behaves before rolling it out to all users. This pre-\nvents bad releases from being exposed to too many users.\nBy adding these two labels, you\u2019ve essentially organized your pods into two dimen-\nsions (horizontally by app and vertically by release), as shown in figure 3.7.\nEvery developer or ops person with access to your cluster can now easily see the sys-\ntem\u2019s structure and where each pod fits in by looking at the pod\u2019s labels.\n3.3.2\nSpecifying labels when creating a pod\nNow, you\u2019ll see labels in action by creating a new pod with two labels. Create a new file\ncalled kubia-manual-with-labels.yaml with the contents of the following listing.\napiVersion: v1                                         \nkind: Pod                                              \nmetadata:                                              \n  name: kubia-manual-v2\nListing 3.3\nA pod with labels: kubia-manual-with-labels.yaml\nUI pod\napp: ui\nrel: stable\nrel=stable\napp=ui\nAccount\nService\npod\napp: as\nrel: stable\napp=as\napp: pc\nrel: stable\napp=pc\napp: sc\nrel: stable\napp=sc\napp: os\nrel: stable\napp=os\nProduct\nCatalog\npod\nShopping\nCart\npod\nOrder\nService\npod\nUI pod\napp: ui\nrel: beta\nrel=beta\napp: pc\nrel: beta\napp: os\nrel: beta\nProduct\nCatalog\npod\nOrder\nService\npod\nrel=canary\nAccount\nService\npod\napp: as\nrel: canary\napp: pc\nrel: canary\napp: os\nrel: canary\nProduct\nCatalog\npod\nOrder\nService\npod\nFigure 3.7\nOrganizing pods in a microservices architecture with pod labels\n \n", "shape": "dot", "size": 10, "title": "69\nOrganizing pods with labels\n Let\u2019s turn back to the microservices example from figure 3.6. By adding labels to\nthose pods, you get a much-better-organized system that everyone can easily make\nsense of. Each pod is labeled with two labels:\n\uf0a1\napp, which specifies which app, component, or microservice the pod belongs to. \n\uf0a1\nrel, which shows whether the application running in the pod is a stable, beta,\nor a canary release.\nDEFINITION\nA canary release is when you deploy a new version of an applica-\ntion next to the stable version, and only let a small fraction of users hit the\nnew version to see how it behaves before rolling it out to all users. This pre-\nvents bad releases from being exposed to too many users.\nBy adding these two labels, you\u2019ve essentially organized your pods into two dimen-\nsions (horizontally by app and vertically by release), as shown in figure 3.7.\nEvery developer or ops person with access to your cluster can now easily see the sys-\ntem\u2019s structure and where each pod fits in by looking at the pod\u2019s labels.\n3.3.2\nSpecifying labels when creating a pod\nNow, you\u2019ll see labels in action by creating a new pod with two labels. Create a new file\ncalled kubia-manual-with-labels.yaml with the contents of the following listing.\napiVersion: v1                                         \nkind: Pod                                              \nmetadata:                                              \n  name: kubia-manual-v2\nListing 3.3\nA pod with labels: kubia-manual-with-labels.yaml\nUI pod\napp: ui\nrel: stable\nrel=stable\napp=ui\nAccount\nService\npod\napp: as\nrel: stable\napp=as\napp: pc\nrel: stable\napp=pc\napp: sc\nrel: stable\napp=sc\napp: os\nrel: stable\napp=os\nProduct\nCatalog\npod\nShopping\nCart\npod\nOrder\nService\npod\nUI pod\napp: ui\nrel: beta\nrel=beta\napp: pc\nrel: beta\napp: os\nrel: beta\nProduct\nCatalog\npod\nOrder\nService\npod\nrel=canary\nAccount\nService\npod\napp: as\nrel: canary\napp: pc\nrel: canary\napp: os\nrel: canary\nProduct\nCatalog\npod\nOrder\nService\npod\nFigure 3.7\nOrganizing pods in a microservices architecture with pod labels\n \n"}, {"color": "green", "id": "text_13", "label": "70\nCHAPTER 3\nPods: running containers in Kubernetes\n  labels:    \n    creation_method: manual          \n    env: prod                        \nspec: \n  containers: \n  - image: luksa/kubia\n    name: kubia\n    ports: \n    - containerPort: 8080\n      protocol: TCP\nYou\u2019ve included the labels creation_method=manual and env=data.labels section.\nYou\u2019ll create this pod now:\n$ kubectl create -f kubia-manual-with-labels.yaml\npod \"kubia-manual-v2\" created\nThe kubectl get pods command doesn\u2019t list any labels by default, but you can see\nthem by using the --show-labels switch:\n$ kubectl get po --show-labels\nNAME            READY  STATUS   RESTARTS  AGE LABELS\nkubia-manual    1/1    Running  0         16m \u003cnone\u003e\nkubia-manual-v2 1/1    Running  0         2m  creat_method=manual,env=prod\nkubia-zxzij     1/1    Running  0         1d  run=kubia\nInstead of listing all labels, if you\u2019re only interested in certain labels, you can specify\nthem with the -L switch and have each displayed in its own column. List pods again\nand show the columns for the two labels you\u2019ve attached to your kubia-manual-v2 pod:\n$ kubectl get po -L creation_method,env\nNAME            READY   STATUS    RESTARTS   AGE   CREATION_METHOD   ENV\nkubia-manual    1/1     Running   0          16m   \u003cnone\u003e            \u003cnone\u003e\nkubia-manual-v2 1/1     Running   0          2m    manual            prod\nkubia-zxzij     1/1     Running   0          1d    \u003cnone\u003e            \u003cnone\u003e\n3.3.3\nModifying labels of existing pods\nLabels can also be added to and modified on existing pods. Because the kubia-man-\nual pod was also created manually, let\u2019s add the creation_method=manual label to it: \n$ kubectl label po kubia-manual creation_method=manual\npod \"kubia-manual\" labeled\nNow, let\u2019s also change the env=prod label to env=debug on the kubia-manual-v2 pod,\nto see how existing labels can be changed.\nNOTE\nYou need to use the --overwrite option when changing existing labels.\n$ kubectl label po kubia-manual-v2 env=debug --overwrite\npod \"kubia-manual-v2\" labeled\nTwo labels are \nattached to the pod.\n \n", "shape": "dot", "size": 10, "title": "70\nCHAPTER 3\nPods: running containers in Kubernetes\n  labels:    \n    creation_method: manual          \n    env: prod                        \nspec: \n  containers: \n  - image: luksa/kubia\n    name: kubia\n    ports: \n    - containerPort: 8080\n      protocol: TCP\nYou\u2019ve included the labels creation_method=manual and env=data.labels section.\nYou\u2019ll create this pod now:\n$ kubectl create -f kubia-manual-with-labels.yaml\npod \"kubia-manual-v2\" created\nThe kubectl get pods command doesn\u2019t list any labels by default, but you can see\nthem by using the --show-labels switch:\n$ kubectl get po --show-labels\nNAME            READY  STATUS   RESTARTS  AGE LABELS\nkubia-manual    1/1    Running  0         16m \u003cnone\u003e\nkubia-manual-v2 1/1    Running  0         2m  creat_method=manual,env=prod\nkubia-zxzij     1/1    Running  0         1d  run=kubia\nInstead of listing all labels, if you\u2019re only interested in certain labels, you can specify\nthem with the -L switch and have each displayed in its own column. List pods again\nand show the columns for the two labels you\u2019ve attached to your kubia-manual-v2 pod:\n$ kubectl get po -L creation_method,env\nNAME            READY   STATUS    RESTARTS   AGE   CREATION_METHOD   ENV\nkubia-manual    1/1     Running   0          16m   \u003cnone\u003e            \u003cnone\u003e\nkubia-manual-v2 1/1     Running   0          2m    manual            prod\nkubia-zxzij     1/1     Running   0          1d    \u003cnone\u003e            \u003cnone\u003e\n3.3.3\nModifying labels of existing pods\nLabels can also be added to and modified on existing pods. Because the kubia-man-\nual pod was also created manually, let\u2019s add the creation_method=manual label to it: \n$ kubectl label po kubia-manual creation_method=manual\npod \"kubia-manual\" labeled\nNow, let\u2019s also change the env=prod label to env=debug on the kubia-manual-v2 pod,\nto see how existing labels can be changed.\nNOTE\nYou need to use the --overwrite option when changing existing labels.\n$ kubectl label po kubia-manual-v2 env=debug --overwrite\npod \"kubia-manual-v2\" labeled\nTwo labels are \nattached to the pod.\n \n"}, {"color": "green", "id": "text_14", "label": "71\nListing subsets of pods through label selectors\nList the pods again to see the updated labels:\n$ kubectl get po -L creation_method,env\nNAME            READY   STATUS    RESTARTS   AGE   CREATION_METHOD   ENV\nkubia-manual    1/1     Running   0          16m   manual            \u003cnone\u003e\nkubia-manual-v2 1/1     Running   0          2m    manual            debug\nkubia-zxzij     1/1     Running   0          1d    \u003cnone\u003e            \u003cnone\u003e\nAs you can see, attaching labels to resources is trivial, and so is changing them on\nexisting resources. It may not be evident right now, but this is an incredibly powerful\nfeature, as you\u2019ll see in the next chapter. But first, let\u2019s see what you can do with these\nlabels, in addition to displaying them when listing pods.\n3.4\nListing subsets of pods through label selectors\nAttaching labels to resources so you can see the labels next to each resource when list-\ning them isn\u2019t that interesting. But labels go hand in hand with label selectors. Label\nselectors allow you to select a subset of pods tagged with certain labels and perform an\noperation on those pods. A label selector is a criterion, which filters resources based\non whether they include a certain label with a certain value. \n A label selector can select resources based on whether the resource\n\uf0a1Contains (or doesn\u2019t contain) a label with a certain key\n\uf0a1Contains a label with a certain key and value\n\uf0a1Contains a label with a certain key, but with a value not equal to the one you\nspecify\n3.4.1\nListing pods using a label selector\nLet\u2019s use label selectors on the pods you\u2019ve created so far. To see all pods you created\nmanually (you labeled them with creation_method=manual), do the following:\n$ kubectl get po -l creation_method=manual\nNAME              READY     STATUS    RESTARTS   AGE\nkubia-manual      1/1       Running   0          51m\nkubia-manual-v2   1/1       Running   0          37m\nTo list all pods that include the env label, whatever its value is:\n$ kubectl get po -l env\nNAME              READY     STATUS    RESTARTS   AGE\nkubia-manual-v2   1/1       Running   0          37m\nAnd those that don\u2019t have the env label:\n$ kubectl get po -l \u0027!env\u0027\nNAME           READY     STATUS    RESTARTS   AGE\nkubia-manual   1/1       Running   0          51m\nkubia-zxzij    1/1       Running   0          10d\n \n", "shape": "dot", "size": 10, "title": "71\nListing subsets of pods through label selectors\nList the pods again to see the updated labels:\n$ kubectl get po -L creation_method,env\nNAME            READY   STATUS    RESTARTS   AGE   CREATION_METHOD   ENV\nkubia-manual    1/1     Running   0          16m   manual            \u003cnone\u003e\nkubia-manual-v2 1/1     Running   0          2m    manual            debug\nkubia-zxzij     1/1     Running   0          1d    \u003cnone\u003e            \u003cnone\u003e\nAs you can see, attaching labels to resources is trivial, and so is changing them on\nexisting resources. It may not be evident right now, but this is an incredibly powerful\nfeature, as you\u2019ll see in the next chapter. But first, let\u2019s see what you can do with these\nlabels, in addition to displaying them when listing pods.\n3.4\nListing subsets of pods through label selectors\nAttaching labels to resources so you can see the labels next to each resource when list-\ning them isn\u2019t that interesting. But labels go hand in hand with label selectors. Label\nselectors allow you to select a subset of pods tagged with certain labels and perform an\noperation on those pods. A label selector is a criterion, which filters resources based\non whether they include a certain label with a certain value. \n A label selector can select resources based on whether the resource\n\uf0a1Contains (or doesn\u2019t contain) a label with a certain key\n\uf0a1Contains a label with a certain key and value\n\uf0a1Contains a label with a certain key, but with a value not equal to the one you\nspecify\n3.4.1\nListing pods using a label selector\nLet\u2019s use label selectors on the pods you\u2019ve created so far. To see all pods you created\nmanually (you labeled them with creation_method=manual), do the following:\n$ kubectl get po -l creation_method=manual\nNAME              READY     STATUS    RESTARTS   AGE\nkubia-manual      1/1       Running   0          51m\nkubia-manual-v2   1/1       Running   0          37m\nTo list all pods that include the env label, whatever its value is:\n$ kubectl get po -l env\nNAME              READY     STATUS    RESTARTS   AGE\nkubia-manual-v2   1/1       Running   0          37m\nAnd those that don\u2019t have the env label:\n$ kubectl get po -l \u0027!env\u0027\nNAME           READY     STATUS    RESTARTS   AGE\nkubia-manual   1/1       Running   0          51m\nkubia-zxzij    1/1       Running   0          10d\n \n"}, {"color": "green", "id": "text_15", "label": "72\nCHAPTER 3\nPods: running containers in Kubernetes\nNOTE\nMake sure to use single quotes around !env, so the bash shell doesn\u2019t\nevaluate the exclamation mark.\nSimilarly, you could also match pods with the following label selectors:\n\uf0a1\ncreation_method!=manual to select pods with the creation_method label with\nany value other than manual\n\uf0a1\nenv in (prod,devel) to select pods with the env label set to either prod or\ndevel\n\uf0a1\nenv notin (prod,devel) to select pods with the env label set to any value other\nthan prod or devel\nTurning back to the pods in the microservices-oriented architecture example, you\ncould select all pods that are part of the product catalog microservice by using the\napp=pc label selector (shown in the following figure).\n3.4.2\nUsing multiple conditions in a label selector\nA selector can also include multiple comma-separated criteria. Resources need to\nmatch all of them to match the selector. If, for example, you want to select only pods\nrunning the beta release of the product catalog microservice, you\u2019d use the following\nselector: app=pc,rel=beta (visualized in figure 3.9).\n Label selectors aren\u2019t useful only for listing pods, but also for performing actions\non a subset of all pods. For example, later in the chapter, you\u2019ll see how to use label\nselectors to delete multiple pods at once. But label selectors aren\u2019t used only by\nkubectl. They\u2019re also used internally, as you\u2019ll see next.\nUI pod\napp: ui\nrel: stable\nrel=stable\napp=ui\nAccount\nService\npod\napp: as\nrel: stable\napp=as\napp: pc\nrel: stable\napp=pc\napp: sc\nrel: stable\napp=sc\napp: os\nrel: stable\napp=os\nProduct\nCatalog\npod\nShopping\nCart\npod\nOrder\nService\npod\nUI pod\napp: ui\nrel: beta\nrel=beta\napp: pc\nrel: beta\napp: os\nrel: beta\nProduct\nCatalog\npod\nOrder\nService\npod\nrel=canary\nAccount\nService\npod\napp: as\nrel: canary\napp: pc\nrel: canary\napp: os\nrel: canary\nProduct\nCatalog\npod\nOrder\nService\npod\nFigure 3.8\nSelecting the product catalog microservice pods using the \u201capp=pc\u201d label selector\n \n", "shape": "dot", "size": 10, "title": "72\nCHAPTER 3\nPods: running containers in Kubernetes\nNOTE\nMake sure to use single quotes around !env, so the bash shell doesn\u2019t\nevaluate the exclamation mark.\nSimilarly, you could also match pods with the following label selectors:\n\uf0a1\ncreation_method!=manual to select pods with the creation_method label with\nany value other than manual\n\uf0a1\nenv in (prod,devel) to select pods with the env label set to either prod or\ndevel\n\uf0a1\nenv notin (prod,devel) to select pods with the env label set to any value other\nthan prod or devel\nTurning back to the pods in the microservices-oriented architecture example, you\ncould select all pods that are part of the product catalog microservice by using the\napp=pc label selector (shown in the following figure).\n3.4.2\nUsing multiple conditions in a label selector\nA selector can also include multiple comma-separated criteria. Resources need to\nmatch all of them to match the selector. If, for example, you want to select only pods\nrunning the beta release of the product catalog microservice, you\u2019d use the following\nselector: app=pc,rel=beta (visualized in figure 3.9).\n Label selectors aren\u2019t useful only for listing pods, but also for performing actions\non a subset of all pods. For example, later in the chapter, you\u2019ll see how to use label\nselectors to delete multiple pods at once. But label selectors aren\u2019t used only by\nkubectl. They\u2019re also used internally, as you\u2019ll see next.\nUI pod\napp: ui\nrel: stable\nrel=stable\napp=ui\nAccount\nService\npod\napp: as\nrel: stable\napp=as\napp: pc\nrel: stable\napp=pc\napp: sc\nrel: stable\napp=sc\napp: os\nrel: stable\napp=os\nProduct\nCatalog\npod\nShopping\nCart\npod\nOrder\nService\npod\nUI pod\napp: ui\nrel: beta\nrel=beta\napp: pc\nrel: beta\napp: os\nrel: beta\nProduct\nCatalog\npod\nOrder\nService\npod\nrel=canary\nAccount\nService\npod\napp: as\nrel: canary\napp: pc\nrel: canary\napp: os\nrel: canary\nProduct\nCatalog\npod\nOrder\nService\npod\nFigure 3.8\nSelecting the product catalog microservice pods using the \u201capp=pc\u201d label selector\n \n"}, {"color": "green", "id": "text_16", "label": "73\nUsing labels and selectors to constrain pod scheduling\n3.5\nUsing labels and selectors to constrain pod scheduling\nAll the pods you\u2019ve created so far have been scheduled pretty much randomly across\nyour worker nodes. As I\u2019ve mentioned in the previous chapter, this is the proper way\nof working in a Kubernetes cluster. Because Kubernetes exposes all the nodes in the\ncluster as a single, large deployment platform, it shouldn\u2019t matter to you what node a\npod is scheduled to. Because each pod gets the exact amount of computational\nresources it requests (CPU, memory, and so on) and its accessibility from other pods\nisn\u2019t at all affected by the node the pod is scheduled to, usually there shouldn\u2019t be any\nneed for you to tell Kubernetes exactly where to schedule your pods. \n Certain cases exist, however, where you\u2019ll want to have at least a little say in where\na pod should be scheduled. A good example is when your hardware infrastructure\nisn\u2019t homogenous. If part of your worker nodes have spinning hard drives, whereas\nothers have SSDs, you may want to schedule certain pods to one group of nodes and\nthe rest to the other. Another example is when you need to schedule pods perform-\ning intensive GPU-based computation only to nodes that provide the required GPU\nacceleration. \n You never want to say specifically what node a pod should be scheduled to, because\nthat would couple the application to the infrastructure, whereas the whole idea of\nKubernetes is hiding the actual infrastructure from the apps that run on it. But if you\nwant to have a say in where a pod should be scheduled, instead of specifying an exact\nnode, you should describe the node requirements and then let Kubernetes select a\nnode that matches those requirements. This can be done through node labels and\nnode label selectors. \nUI pod\napp: ui\nrel: stable\nrel=stable\napp=ui\nAccount\nService\npod\napp: as\nrel: stable\napp=as\napp: pc\nrel: stable\napp=pc\napp: sc\nrel: stable\napp=sc\napp: os\nrel: stable\napp=os\nProduct\nCatalog\npod\nShopping\nCart\npod\nOrder\nService\npod\nUI pod\napp: ui\nrel: beta\nrel=beta\napp: pc\nrel: beta\napp: os\nrel: beta\nProduct\nCatalog\npod\nOrder\nService\npod\nrel=canary\nAccount\nService\npod\napp: as\nrel: canary\napp: pc\nrel: canary\napp: os\nrel: canary\nProduct\nCatalog\npod\nOrder\nService\npod\nFigure 3.9\nSelecting pods with multiple label selectors\n \n", "shape": "dot", "size": 10, "title": "73\nUsing labels and selectors to constrain pod scheduling\n3.5\nUsing labels and selectors to constrain pod scheduling\nAll the pods you\u2019ve created so far have been scheduled pretty much randomly across\nyour worker nodes. As I\u2019ve mentioned in the previous chapter, this is the proper way\nof working in a Kubernetes cluster. Because Kubernetes exposes all the nodes in the\ncluster as a single, large deployment platform, it shouldn\u2019t matter to you what node a\npod is scheduled to. Because each pod gets the exact amount of computational\nresources it requests (CPU, memory, and so on) and its accessibility from other pods\nisn\u2019t at all affected by the node the pod is scheduled to, usually there shouldn\u2019t be any\nneed for you to tell Kubernetes exactly where to schedule your pods. \n Certain cases exist, however, where you\u2019ll want to have at least a little say in where\na pod should be scheduled. A good example is when your hardware infrastructure\nisn\u2019t homogenous. If part of your worker nodes have spinning hard drives, whereas\nothers have SSDs, you may want to schedule certain pods to one group of nodes and\nthe rest to the other. Another example is when you need to schedule pods perform-\ning intensive GPU-based computation only to nodes that provide the required GPU\nacceleration. \n You never want to say specifically what node a pod should be scheduled to, because\nthat would couple the application to the infrastructure, whereas the whole idea of\nKubernetes is hiding the actual infrastructure from the apps that run on it. But if you\nwant to have a say in where a pod should be scheduled, instead of specifying an exact\nnode, you should describe the node requirements and then let Kubernetes select a\nnode that matches those requirements. This can be done through node labels and\nnode label selectors. \nUI pod\napp: ui\nrel: stable\nrel=stable\napp=ui\nAccount\nService\npod\napp: as\nrel: stable\napp=as\napp: pc\nrel: stable\napp=pc\napp: sc\nrel: stable\napp=sc\napp: os\nrel: stable\napp=os\nProduct\nCatalog\npod\nShopping\nCart\npod\nOrder\nService\npod\nUI pod\napp: ui\nrel: beta\nrel=beta\napp: pc\nrel: beta\napp: os\nrel: beta\nProduct\nCatalog\npod\nOrder\nService\npod\nrel=canary\nAccount\nService\npod\napp: as\nrel: canary\napp: pc\nrel: canary\napp: os\nrel: canary\nProduct\nCatalog\npod\nOrder\nService\npod\nFigure 3.9\nSelecting pods with multiple label selectors\n \n"}, {"color": "green", "id": "text_17", "label": "74\nCHAPTER 3\nPods: running containers in Kubernetes\n3.5.1\nUsing labels for categorizing worker nodes\nAs you learned earlier, pods aren\u2019t the only Kubernetes resource type that you can\nattach a label to. Labels can be attached to any Kubernetes object, including nodes.\nUsually, when the ops team adds a new node to the cluster, they\u2019ll categorize the node\nby attaching labels specifying the type of hardware the node provides or anything else\nthat may come in handy when scheduling pods. \n Let\u2019s imagine one of the nodes in your cluster contains a GPU meant to be used\nfor general-purpose GPU computing. You want to add a label to the node showing this\nfeature. You\u2019re going to add the label gpu=true to one of your nodes (pick one out of\nthe list returned by kubectl get nodes):\n$ kubectl label node gke-kubia-85f6-node-0rrx gpu=true\nnode \"gke-kubia-85f6-node-0rrx\" labeled\nNow you can use a label selector when listing the nodes, like you did before with pods.\nList only nodes that include the label gpu=true:\n$ kubectl get nodes -l gpu=true\nNAME                      STATUS AGE\ngke-kubia-85f6-node-0rrx  Ready  1d\nAs expected, only one node has this label. You can also try listing all the nodes and tell\nkubectl to display an additional column showing the values of each node\u2019s gpu label\n(kubectl get nodes -L gpu).\n3.5.2\nScheduling pods to specific nodes\nNow imagine you want to deploy a new pod that needs a GPU to perform its work.\nTo ask the scheduler to only choose among the nodes that provide a GPU, you\u2019ll\nadd a node selector to the pod\u2019s YAML. Create a file called kubia-gpu.yaml with the\nfollowing listing\u2019s contents and then use kubectl create -f kubia-gpu.yaml to cre-\nate the pod.\napiVersion: v1                                         \nkind: Pod                                              \nmetadata:                                              \n  name: kubia-gpu\nspec: \n  nodeSelector:               \n    gpu: \"true\"               \n  containers: \n  - image: luksa/kubia\n    name: kubia\nListing 3.4\nUsing a label selector to schedule a pod to a specific node: kubia-gpu.yaml\nnodeSelector tells Kubernetes \nto deploy this pod only to \nnodes containing the \ngpu=true label.\n \n", "shape": "dot", "size": 10, "title": "74\nCHAPTER 3\nPods: running containers in Kubernetes\n3.5.1\nUsing labels for categorizing worker nodes\nAs you learned earlier, pods aren\u2019t the only Kubernetes resource type that you can\nattach a label to. Labels can be attached to any Kubernetes object, including nodes.\nUsually, when the ops team adds a new node to the cluster, they\u2019ll categorize the node\nby attaching labels specifying the type of hardware the node provides or anything else\nthat may come in handy when scheduling pods. \n Let\u2019s imagine one of the nodes in your cluster contains a GPU meant to be used\nfor general-purpose GPU computing. You want to add a label to the node showing this\nfeature. You\u2019re going to add the label gpu=true to one of your nodes (pick one out of\nthe list returned by kubectl get nodes):\n$ kubectl label node gke-kubia-85f6-node-0rrx gpu=true\nnode \"gke-kubia-85f6-node-0rrx\" labeled\nNow you can use a label selector when listing the nodes, like you did before with pods.\nList only nodes that include the label gpu=true:\n$ kubectl get nodes -l gpu=true\nNAME                      STATUS AGE\ngke-kubia-85f6-node-0rrx  Ready  1d\nAs expected, only one node has this label. You can also try listing all the nodes and tell\nkubectl to display an additional column showing the values of each node\u2019s gpu label\n(kubectl get nodes -L gpu).\n3.5.2\nScheduling pods to specific nodes\nNow imagine you want to deploy a new pod that needs a GPU to perform its work.\nTo ask the scheduler to only choose among the nodes that provide a GPU, you\u2019ll\nadd a node selector to the pod\u2019s YAML. Create a file called kubia-gpu.yaml with the\nfollowing listing\u2019s contents and then use kubectl create -f kubia-gpu.yaml to cre-\nate the pod.\napiVersion: v1                                         \nkind: Pod                                              \nmetadata:                                              \n  name: kubia-gpu\nspec: \n  nodeSelector:               \n    gpu: \"true\"               \n  containers: \n  - image: luksa/kubia\n    name: kubia\nListing 3.4\nUsing a label selector to schedule a pod to a specific node: kubia-gpu.yaml\nnodeSelector tells Kubernetes \nto deploy this pod only to \nnodes containing the \ngpu=true label.\n \n"}, {"color": "green", "id": "text_18", "label": "75\nAnnotating pods\nYou\u2019ve added a nodeSelector field under the spec section. When you create the pod,\nthe scheduler will only choose among the nodes that contain the gpu=true label\n(which is only a single node in your case). \n3.5.3\nScheduling to one specific node\nSimilarly, you could also schedule a pod to an exact node, because each node also has\na unique label with the key kubernetes.io/hostname and value set to the actual host-\nname of the node. But setting the nodeSelector to a specific node by the hostname\nlabel may lead to the pod being unschedulable if the node is offline. You shouldn\u2019t\nthink in terms of individual nodes. Always think about logical groups of nodes that sat-\nisfy certain criteria specified through label selectors.\n This was a quick demonstration of how labels and label selectors work and how\nthey can be used to influence the operation of Kubernetes. The importance and use-\nfulness of label selectors will become even more evident when we talk about Replication-\nControllers and Services in the next two chapters. \nNOTE\nAdditional ways of influencing which node a pod is scheduled to are\ncovered in chapter 16.\n3.6\nAnnotating pods\nIn addition to labels, pods and other objects can also contain annotations. Annotations\nare also key-value pairs, so in essence, they\u2019re similar to labels, but they aren\u2019t meant to\nhold identifying information. They can\u2019t be used to group objects the way labels can.\nWhile objects can be selected through label selectors, there\u2019s no such thing as an\nannotation selector. \n On the other hand, annotations can hold much larger pieces of information and\nare primarily meant to be used by tools. Certain annotations are automatically added\nto objects by Kubernetes, but others are added by users manually.\n Annotations are also commonly used when introducing new features to Kuberne-\ntes. Usually, alpha and beta versions of new features don\u2019t introduce any new fields to\nAPI objects. Annotations are used instead of fields, and then once the required API\nchanges have become clear and been agreed upon by the Kubernetes developers, new\nfields are introduced and the related annotations deprecated.\n A great use of annotations is adding descriptions for each pod or other API object,\nso that everyone using the cluster can quickly look up information about each individ-\nual object. For example, an annotation used to specify the name of the person who\ncreated the object can make collaboration between everyone working on the cluster\nmuch easier.\n3.6.1\nLooking up an object\u2019s annotations\nLet\u2019s see an example of an annotation that Kubernetes added automatically to the\npod you created in the previous chapter. To see the annotations, you\u2019ll need to\n \n", "shape": "dot", "size": 10, "title": "75\nAnnotating pods\nYou\u2019ve added a nodeSelector field under the spec section. When you create the pod,\nthe scheduler will only choose among the nodes that contain the gpu=true label\n(which is only a single node in your case). \n3.5.3\nScheduling to one specific node\nSimilarly, you could also schedule a pod to an exact node, because each node also has\na unique label with the key kubernetes.io/hostname and value set to the actual host-\nname of the node. But setting the nodeSelector to a specific node by the hostname\nlabel may lead to the pod being unschedulable if the node is offline. You shouldn\u2019t\nthink in terms of individual nodes. Always think about logical groups of nodes that sat-\nisfy certain criteria specified through label selectors.\n This was a quick demonstration of how labels and label selectors work and how\nthey can be used to influence the operation of Kubernetes. The importance and use-\nfulness of label selectors will become even more evident when we talk about Replication-\nControllers and Services in the next two chapters. \nNOTE\nAdditional ways of influencing which node a pod is scheduled to are\ncovered in chapter 16.\n3.6\nAnnotating pods\nIn addition to labels, pods and other objects can also contain annotations. Annotations\nare also key-value pairs, so in essence, they\u2019re similar to labels, but they aren\u2019t meant to\nhold identifying information. They can\u2019t be used to group objects the way labels can.\nWhile objects can be selected through label selectors, there\u2019s no such thing as an\nannotation selector. \n On the other hand, annotations can hold much larger pieces of information and\nare primarily meant to be used by tools. Certain annotations are automatically added\nto objects by Kubernetes, but others are added by users manually.\n Annotations are also commonly used when introducing new features to Kuberne-\ntes. Usually, alpha and beta versions of new features don\u2019t introduce any new fields to\nAPI objects. Annotations are used instead of fields, and then once the required API\nchanges have become clear and been agreed upon by the Kubernetes developers, new\nfields are introduced and the related annotations deprecated.\n A great use of annotations is adding descriptions for each pod or other API object,\nso that everyone using the cluster can quickly look up information about each individ-\nual object. For example, an annotation used to specify the name of the person who\ncreated the object can make collaboration between everyone working on the cluster\nmuch easier.\n3.6.1\nLooking up an object\u2019s annotations\nLet\u2019s see an example of an annotation that Kubernetes added automatically to the\npod you created in the previous chapter. To see the annotations, you\u2019ll need to\n \n"}, {"color": "green", "id": "text_19", "label": "76\nCHAPTER 3\nPods: running containers in Kubernetes\nrequest the full YAML of the pod or use the kubectl describe command. You\u2019ll use the\nfirst option in the following listing.\n$ kubectl get po kubia-zxzij -o yaml\napiVersion: v1\nkind: pod\nmetadata:\n  annotations:\n    kubernetes.io/created-by: |\n      {\"kind\":\"SerializedReference\", \"apiVersion\":\"v1\", \n      \"reference\":{\"kind\":\"ReplicationController\", \"namespace\":\"default\", ...\nWithout going into too many details, as you can see, the kubernetes.io/created-by\nannotation holds JSON data about the object that created the pod. That\u2019s not some-\nthing you\u2019d want to put into a label. Labels should be short, whereas annotations can\ncontain relatively large blobs of data (up to 256 KB in total).\nNOTE\nThe kubernetes.io/created-by annotations was deprecated in ver-\nsion 1.8 and will be removed in 1.9, so you will no longer see it in the YAML.\n3.6.2\nAdding and modifying annotations\nAnnotations can obviously be added to pods at creation time, the same way labels can.\nThey can also be added to or modified on existing pods later. The simplest way to add\nan annotation to an existing object is through the kubectl annotate command. \n You\u2019ll try adding an annotation to your kubia-manual pod now:\n$ kubectl annotate pod kubia-manual mycompany.com/someannotation=\"foo bar\"\npod \"kubia-manual\" annotated\nYou added the annotation mycompany.com/someannotation with the value foo bar.\nIt\u2019s a good idea to use this format for annotation keys to prevent key collisions. When\ndifferent tools or libraries add annotations to objects, they may accidentally override\neach other\u2019s annotations if they don\u2019t use unique prefixes like you did here.\n You can use kubectl describe to see the annotation you added:\n$ kubectl describe pod kubia-manual\n...\nAnnotations:    mycompany.com/someannotation=foo bar\n...\n3.7\nUsing namespaces to group resources\nLet\u2019s turn back to labels for a moment. We\u2019ve seen how they organize pods and other\nobjects into groups. Because each object can have multiple labels, those groups of\nobjects can overlap. Plus, when working with the cluster (through kubectl for example),\nif you don\u2019t explicitly specify a label selector, you\u2019ll always see all objects. \nListing 3.5\nA pod\u2019s annotations\n \n", "shape": "dot", "size": 10, "title": "76\nCHAPTER 3\nPods: running containers in Kubernetes\nrequest the full YAML of the pod or use the kubectl describe command. You\u2019ll use the\nfirst option in the following listing.\n$ kubectl get po kubia-zxzij -o yaml\napiVersion: v1\nkind: pod\nmetadata:\n  annotations:\n    kubernetes.io/created-by: |\n      {\"kind\":\"SerializedReference\", \"apiVersion\":\"v1\", \n      \"reference\":{\"kind\":\"ReplicationController\", \"namespace\":\"default\", ...\nWithout going into too many details, as you can see, the kubernetes.io/created-by\nannotation holds JSON data about the object that created the pod. That\u2019s not some-\nthing you\u2019d want to put into a label. Labels should be short, whereas annotations can\ncontain relatively large blobs of data (up to 256 KB in total).\nNOTE\nThe kubernetes.io/created-by annotations was deprecated in ver-\nsion 1.8 and will be removed in 1.9, so you will no longer see it in the YAML.\n3.6.2\nAdding and modifying annotations\nAnnotations can obviously be added to pods at creation time, the same way labels can.\nThey can also be added to or modified on existing pods later. The simplest way to add\nan annotation to an existing object is through the kubectl annotate command. \n You\u2019ll try adding an annotation to your kubia-manual pod now:\n$ kubectl annotate pod kubia-manual mycompany.com/someannotation=\"foo bar\"\npod \"kubia-manual\" annotated\nYou added the annotation mycompany.com/someannotation with the value foo bar.\nIt\u2019s a good idea to use this format for annotation keys to prevent key collisions. When\ndifferent tools or libraries add annotations to objects, they may accidentally override\neach other\u2019s annotations if they don\u2019t use unique prefixes like you did here.\n You can use kubectl describe to see the annotation you added:\n$ kubectl describe pod kubia-manual\n...\nAnnotations:    mycompany.com/someannotation=foo bar\n...\n3.7\nUsing namespaces to group resources\nLet\u2019s turn back to labels for a moment. We\u2019ve seen how they organize pods and other\nobjects into groups. Because each object can have multiple labels, those groups of\nobjects can overlap. Plus, when working with the cluster (through kubectl for example),\nif you don\u2019t explicitly specify a label selector, you\u2019ll always see all objects. \nListing 3.5\nA pod\u2019s annotations\n \n"}, {"color": "green", "id": "text_20", "label": "77\nUsing namespaces to group resources\n But what about times when you want to split objects into separate, non-overlapping\ngroups? You may want to only operate inside one group at a time. For this and other\nreasons, Kubernetes also groups objects into namespaces. These aren\u2019t the Linux\nnamespaces we talked about in chapter 2, which are used to isolate processes from\neach other. Kubernetes namespaces provide a scope for objects names. Instead of hav-\ning all your resources in one single namespace, you can split them into multiple name-\nspaces, which also allows you to use the same resource names multiple times (across\ndifferent namespaces).\n3.7.1\nUnderstanding the need for namespaces\nUsing multiple namespaces allows you to split complex systems with numerous com-\nponents into smaller distinct groups. They can also be used for separating resources\nin a multi-tenant environment, splitting up resources into production, development,\nand QA environments, or in any other way you may need. Resource names only need\nto be unique within a namespace. Two different namespaces can contain resources of\nthe same name. But, while most types of resources are namespaced, a few aren\u2019t. One\nof them is the Node resource, which is global and not tied to a single namespace.\nYou\u2019ll learn about other cluster-level resources in later chapters.\n Let\u2019s see how to use namespaces now.\n3.7.2\nDiscovering other namespaces and their pods\nFirst, let\u2019s list all namespaces in your cluster:\n$ kubectl get ns\nNAME          LABELS    STATUS    AGE\ndefault       \u003cnone\u003e    Active    1h\nkube-public   \u003cnone\u003e    Active    1h\nkube-system   \u003cnone\u003e    Active    1h\nUp to this point, you\u2019ve operated only in the default namespace. When listing resources\nwith the kubectl get command, you\u2019ve never specified the namespace explicitly, so\nkubectl always defaulted to the default namespace, showing you only the objects in\nthat namespace. But as you can see from the list, the kube-public and the kube-system\nnamespaces also exist. Let\u2019s look at the pods that belong to the kube-system name-\nspace, by telling kubectl to list pods in that namespace only:\n$ kubectl get po --namespace kube-system\nNAME                                 READY     STATUS    RESTARTS   AGE\nfluentd-cloud-kubia-e8fe-node-txje   1/1       Running   0          1h\nheapster-v11-fz1ge                   1/1       Running   0          1h\nkube-dns-v9-p8a4t                    0/4       Pending   0          1h\nkube-ui-v4-kdlai                     1/1       Running   0          1h\nl7-lb-controller-v0.5.2-bue96        2/2       Running   92         1h\nTIP\nYou can also use -n instead of --namespace.\n \n", "shape": "dot", "size": 10, "title": "77\nUsing namespaces to group resources\n But what about times when you want to split objects into separate, non-overlapping\ngroups? You may want to only operate inside one group at a time. For this and other\nreasons, Kubernetes also groups objects into namespaces. These aren\u2019t the Linux\nnamespaces we talked about in chapter 2, which are used to isolate processes from\neach other. Kubernetes namespaces provide a scope for objects names. Instead of hav-\ning all your resources in one single namespace, you can split them into multiple name-\nspaces, which also allows you to use the same resource names multiple times (across\ndifferent namespaces).\n3.7.1\nUnderstanding the need for namespaces\nUsing multiple namespaces allows you to split complex systems with numerous com-\nponents into smaller distinct groups. They can also be used for separating resources\nin a multi-tenant environment, splitting up resources into production, development,\nand QA environments, or in any other way you may need. Resource names only need\nto be unique within a namespace. Two different namespaces can contain resources of\nthe same name. But, while most types of resources are namespaced, a few aren\u2019t. One\nof them is the Node resource, which is global and not tied to a single namespace.\nYou\u2019ll learn about other cluster-level resources in later chapters.\n Let\u2019s see how to use namespaces now.\n3.7.2\nDiscovering other namespaces and their pods\nFirst, let\u2019s list all namespaces in your cluster:\n$ kubectl get ns\nNAME          LABELS    STATUS    AGE\ndefault       \u003cnone\u003e    Active    1h\nkube-public   \u003cnone\u003e    Active    1h\nkube-system   \u003cnone\u003e    Active    1h\nUp to this point, you\u2019ve operated only in the default namespace. When listing resources\nwith the kubectl get command, you\u2019ve never specified the namespace explicitly, so\nkubectl always defaulted to the default namespace, showing you only the objects in\nthat namespace. But as you can see from the list, the kube-public and the kube-system\nnamespaces also exist. Let\u2019s look at the pods that belong to the kube-system name-\nspace, by telling kubectl to list pods in that namespace only:\n$ kubectl get po --namespace kube-system\nNAME                                 READY     STATUS    RESTARTS   AGE\nfluentd-cloud-kubia-e8fe-node-txje   1/1       Running   0          1h\nheapster-v11-fz1ge                   1/1       Running   0          1h\nkube-dns-v9-p8a4t                    0/4       Pending   0          1h\nkube-ui-v4-kdlai                     1/1       Running   0          1h\nl7-lb-controller-v0.5.2-bue96        2/2       Running   92         1h\nTIP\nYou can also use -n instead of --namespace.\n \n"}, {"color": "green", "id": "text_21", "label": "78\nCHAPTER 3\nPods: running containers in Kubernetes\nYou\u2019ll learn about these pods later in the book (don\u2019t worry if the pods shown here\ndon\u2019t match the ones on your system exactly). It\u2019s clear from the name of the name-\nspace that these are resources related to the Kubernetes system itself. By having\nthem in this separate namespace, it keeps everything nicely organized. If they were\nall in the default namespace, mixed in with the resources you create yourself, you\u2019d\nhave a hard time seeing what belongs where, and you might inadvertently delete sys-\ntem resources. \n Namespaces enable you to separate resources that don\u2019t belong together into non-\noverlapping groups. If several users or groups of users are using the same Kubernetes\ncluster, and they each manage their own distinct set of resources, they should each use\ntheir own namespace. This way, they don\u2019t need to take any special care not to inad-\nvertently modify or delete the other users\u2019 resources and don\u2019t need to concern them-\nselves with name conflicts, because namespaces provide a scope for resource names,\nas has already been mentioned.\n  Besides isolating resources, namespaces are also used for allowing only certain users\naccess to particular resources and even for limiting the amount of computational\nresources available to individual users. You\u2019ll learn about this in chapters 12 through 14.\n3.7.3\nCreating a namespace\nA namespace is a Kubernetes resource like any other, so you can create it by posting a\nYAML file to the Kubernetes API server. Let\u2019s see how to do this now. \nCREATING A NAMESPACE FROM A YAML FILE\nFirst, create a custom-namespace.yaml file with the following listing\u2019s contents (you\u2019ll\nfind the file in the book\u2019s code archive).\napiVersion: v1\nkind: Namespace         \nmetadata:\n  name: custom-namespace  \nNow, use kubectl to post the file to the Kubernetes API server:\n$ kubectl create -f custom-namespace.yaml\nnamespace \"custom-namespace\" created\nCREATING A NAMESPACE WITH KUBECTL CREATE NAMESPACE\nAlthough writing a file like the previous one isn\u2019t a big deal, it\u2019s still a hassle. Luckily,\nyou can also create namespaces with the dedicated kubectl create namespace com-\nmand, which is quicker than writing a YAML file. By having you create a YAML mani-\nfest for the namespace, I wanted to reinforce the idea that everything in Kubernetes\nListing 3.6\nA YAML definition of a namespace: custom-namespace.yaml\nThis says you\u2019re \ndefining a namespace.\nThis is the name \nof the namespace.\n \n", "shape": "dot", "size": 10, "title": "78\nCHAPTER 3\nPods: running containers in Kubernetes\nYou\u2019ll learn about these pods later in the book (don\u2019t worry if the pods shown here\ndon\u2019t match the ones on your system exactly). It\u2019s clear from the name of the name-\nspace that these are resources related to the Kubernetes system itself. By having\nthem in this separate namespace, it keeps everything nicely organized. If they were\nall in the default namespace, mixed in with the resources you create yourself, you\u2019d\nhave a hard time seeing what belongs where, and you might inadvertently delete sys-\ntem resources. \n Namespaces enable you to separate resources that don\u2019t belong together into non-\noverlapping groups. If several users or groups of users are using the same Kubernetes\ncluster, and they each manage their own distinct set of resources, they should each use\ntheir own namespace. This way, they don\u2019t need to take any special care not to inad-\nvertently modify or delete the other users\u2019 resources and don\u2019t need to concern them-\nselves with name conflicts, because namespaces provide a scope for resource names,\nas has already been mentioned.\n  Besides isolating resources, namespaces are also used for allowing only certain users\naccess to particular resources and even for limiting the amount of computational\nresources available to individual users. You\u2019ll learn about this in chapters 12 through 14.\n3.7.3\nCreating a namespace\nA namespace is a Kubernetes resource like any other, so you can create it by posting a\nYAML file to the Kubernetes API server. Let\u2019s see how to do this now. \nCREATING A NAMESPACE FROM A YAML FILE\nFirst, create a custom-namespace.yaml file with the following listing\u2019s contents (you\u2019ll\nfind the file in the book\u2019s code archive).\napiVersion: v1\nkind: Namespace         \nmetadata:\n  name: custom-namespace  \nNow, use kubectl to post the file to the Kubernetes API server:\n$ kubectl create -f custom-namespace.yaml\nnamespace \"custom-namespace\" created\nCREATING A NAMESPACE WITH KUBECTL CREATE NAMESPACE\nAlthough writing a file like the previous one isn\u2019t a big deal, it\u2019s still a hassle. Luckily,\nyou can also create namespaces with the dedicated kubectl create namespace com-\nmand, which is quicker than writing a YAML file. By having you create a YAML mani-\nfest for the namespace, I wanted to reinforce the idea that everything in Kubernetes\nListing 3.6\nA YAML definition of a namespace: custom-namespace.yaml\nThis says you\u2019re \ndefining a namespace.\nThis is the name \nof the namespace.\n \n"}, {"color": "green", "id": "text_22", "label": "79\nUsing namespaces to group resources\nhas a corresponding API object that you can create, read, update, and delete by post-\ning a YAML manifest to the API server.\n You could have created the namespace like this:\n$ kubectl create namespace custom-namespace\nnamespace \"custom-namespace\" created\nNOTE\nAlthough most objects\u2019 names must conform to the naming conven-\ntions specified in RFC 1035 (Domain names), which means they may contain\nonly letters, digits, dashes, and dots, namespaces (and a few others) aren\u2019t\nallowed to contain dots. \n3.7.4\nManaging objects in other namespaces\nTo create resources in the namespace you\u2019ve created, either add a namespace: custom-\nnamespace entry to the metadata section, or specify the namespace when creating the\nresource with the kubectl create command:\n$ kubectl create -f kubia-manual.yaml -n custom-namespace\npod \"kubia-manual\" created\nYou now have two pods with the same name (kubia-manual). One is in the default\nnamespace, and the other is in your custom-namespace.\n When listing, describing, modifying, or deleting objects in other namespaces, you\nneed to pass the --namespace (or -n) flag to kubectl. If you don\u2019t specify the name-\nspace, kubectl performs the action in the default namespace configured in the cur-\nrent kubectl context. The current context\u2019s namespace and the current context itself\ncan be changed through kubectl config commands. To learn more about managing\nkubectl contexts, refer to appendix A. \nTIP\nTo quickly switch to a different namespace, you can set up the following\nalias: alias kcd=\u0027kubectl config set-context $(kubectl config current-\ncontext) --namespace \u0027. You can then switch between namespaces using kcd\nsome-namespace.\n3.7.5\nUnderstanding the isolation provided by namespaces\nTo wrap up this section about namespaces, let me explain what namespaces don\u2019t pro-\nvide\u2014at least not out of the box. Although namespaces allow you to isolate objects\ninto distinct groups, which allows you to operate only on those belonging to the speci-\nfied namespace, they don\u2019t provide any kind of isolation of running objects. \n For example, you may think that when different users deploy pods across different\nnamespaces, those pods are isolated from each other and can\u2019t communicate, but that\u2019s\nnot necessarily the case. Whether namespaces provide network isolation depends on\nwhich networking solution is deployed with Kubernetes. When the solution doesn\u2019t\nprovide inter-namespace network isolation, if a pod in namespace foo knows the IP\n \n", "shape": "dot", "size": 10, "title": "79\nUsing namespaces to group resources\nhas a corresponding API object that you can create, read, update, and delete by post-\ning a YAML manifest to the API server.\n You could have created the namespace like this:\n$ kubectl create namespace custom-namespace\nnamespace \"custom-namespace\" created\nNOTE\nAlthough most objects\u2019 names must conform to the naming conven-\ntions specified in RFC 1035 (Domain names), which means they may contain\nonly letters, digits, dashes, and dots, namespaces (and a few others) aren\u2019t\nallowed to contain dots. \n3.7.4\nManaging objects in other namespaces\nTo create resources in the namespace you\u2019ve created, either add a namespace: custom-\nnamespace entry to the metadata section, or specify the namespace when creating the\nresource with the kubectl create command:\n$ kubectl create -f kubia-manual.yaml -n custom-namespace\npod \"kubia-manual\" created\nYou now have two pods with the same name (kubia-manual). One is in the default\nnamespace, and the other is in your custom-namespace.\n When listing, describing, modifying, or deleting objects in other namespaces, you\nneed to pass the --namespace (or -n) flag to kubectl. If you don\u2019t specify the name-\nspace, kubectl performs the action in the default namespace configured in the cur-\nrent kubectl context. The current context\u2019s namespace and the current context itself\ncan be changed through kubectl config commands. To learn more about managing\nkubectl contexts, refer to appendix A. \nTIP\nTo quickly switch to a different namespace, you can set up the following\nalias: alias kcd=\u0027kubectl config set-context $(kubectl config current-\ncontext) --namespace \u0027. You can then switch between namespaces using kcd\nsome-namespace.\n3.7.5\nUnderstanding the isolation provided by namespaces\nTo wrap up this section about namespaces, let me explain what namespaces don\u2019t pro-\nvide\u2014at least not out of the box. Although namespaces allow you to isolate objects\ninto distinct groups, which allows you to operate only on those belonging to the speci-\nfied namespace, they don\u2019t provide any kind of isolation of running objects. \n For example, you may think that when different users deploy pods across different\nnamespaces, those pods are isolated from each other and can\u2019t communicate, but that\u2019s\nnot necessarily the case. Whether namespaces provide network isolation depends on\nwhich networking solution is deployed with Kubernetes. When the solution doesn\u2019t\nprovide inter-namespace network isolation, if a pod in namespace foo knows the IP\n \n"}, {"color": "green", "id": "text_23", "label": "80\nCHAPTER 3\nPods: running containers in Kubernetes\naddress of a pod in namespace bar, there is nothing preventing it from sending traffic,\nsuch as HTTP requests, to the other pod. \n3.8\nStopping and removing pods\nYou\u2019ve created a number of pods, which should all still be running. You have four\npods running in the default namespace and one pod in custom-namespace. You\u2019re\ngoing to stop all of them now, because you don\u2019t need them anymore.\n3.8.1\nDeleting a pod by name\nFirst, delete the kubia-gpu pod by name:\n$ kubectl delete po kubia-gpu\npod \"kubia-gpu\" deleted\nBy deleting a pod, you\u2019re instructing Kubernetes to terminate all the containers that are\npart of that pod. Kubernetes sends a SIGTERM signal to the process and waits a certain\nnumber of seconds (30 by default) for it to shut down gracefully. If it doesn\u2019t shut down\nin time, the process is then killed through SIGKILL. To make sure your processes are\nalways shut down gracefully, they need to handle the SIGTERM signal properly. \nTIP\nYou can also delete more than one pod by specifying multiple, space-sep-\narated names (for example, kubectl delete po pod1 pod2).\n3.8.2\nDeleting pods using label selectors\nInstead of specifying each pod to delete by name, you\u2019ll now use what you\u2019ve learned\nabout label selectors to stop both the kubia-manual and the kubia-manual-v2 pod.\nBoth pods include the creation_method=manual label, so you can delete them by\nusing a label selector:\n$ kubectl delete po -l creation_method=manual\npod \"kubia-manual\" deleted\npod \"kubia-manual-v2\" deleted \nIn the earlier microservices example, where you had tens (or possibly hundreds) of\npods, you could, for instance, delete all canary pods at once by specifying the\nrel=canary label selector (visualized in figure 3.10):\n$ kubectl delete po -l rel=canary\n3.8.3\nDeleting pods by deleting the whole namespace\nOkay, back to your real pods. What about the pod in the custom-namespace? You no\nlonger need either the pods in that namespace, or the namespace itself. You can\n \n", "shape": "dot", "size": 10, "title": "80\nCHAPTER 3\nPods: running containers in Kubernetes\naddress of a pod in namespace bar, there is nothing preventing it from sending traffic,\nsuch as HTTP requests, to the other pod. \n3.8\nStopping and removing pods\nYou\u2019ve created a number of pods, which should all still be running. You have four\npods running in the default namespace and one pod in custom-namespace. You\u2019re\ngoing to stop all of them now, because you don\u2019t need them anymore.\n3.8.1\nDeleting a pod by name\nFirst, delete the kubia-gpu pod by name:\n$ kubectl delete po kubia-gpu\npod \"kubia-gpu\" deleted\nBy deleting a pod, you\u2019re instructing Kubernetes to terminate all the containers that are\npart of that pod. Kubernetes sends a SIGTERM signal to the process and waits a certain\nnumber of seconds (30 by default) for it to shut down gracefully. If it doesn\u2019t shut down\nin time, the process is then killed through SIGKILL. To make sure your processes are\nalways shut down gracefully, they need to handle the SIGTERM signal properly. \nTIP\nYou can also delete more than one pod by specifying multiple, space-sep-\narated names (for example, kubectl delete po pod1 pod2).\n3.8.2\nDeleting pods using label selectors\nInstead of specifying each pod to delete by name, you\u2019ll now use what you\u2019ve learned\nabout label selectors to stop both the kubia-manual and the kubia-manual-v2 pod.\nBoth pods include the creation_method=manual label, so you can delete them by\nusing a label selector:\n$ kubectl delete po -l creation_method=manual\npod \"kubia-manual\" deleted\npod \"kubia-manual-v2\" deleted \nIn the earlier microservices example, where you had tens (or possibly hundreds) of\npods, you could, for instance, delete all canary pods at once by specifying the\nrel=canary label selector (visualized in figure 3.10):\n$ kubectl delete po -l rel=canary\n3.8.3\nDeleting pods by deleting the whole namespace\nOkay, back to your real pods. What about the pod in the custom-namespace? You no\nlonger need either the pods in that namespace, or the namespace itself. You can\n \n"}, {"color": "green", "id": "text_24", "label": "81\nStopping and removing pods\ndelete the whole namespace (the pods will be deleted along with the namespace auto-\nmatically), using the following command:\n$ kubectl delete ns custom-namespace\nnamespace \"custom-namespace\" deleted\n3.8.4\nDeleting all pods in a namespace, while keeping the namespace\nYou\u2019ve now cleaned up almost everything. But what about the pod you created with\nthe kubectl run command in chapter 2? That one is still running:\n$ kubectl get pods\nNAME            READY   STATUS    RESTARTS   AGE\nkubia-zxzij     1/1     Running   0          1d    \nThis time, instead of deleting the specific pod, tell Kubernetes to delete all pods in the\ncurrent namespace by using the --all option:\n$ kubectl delete po --all\npod \"kubia-zxzij\" deleted\nNow, double check that no pods were left running:\n$ kubectl get pods\nNAME            READY   STATUS        RESTARTS   AGE\nkubia-09as0     1/1     Running       0          1d    \nkubia-zxzij     1/1     Terminating   0          1d    \nUI pod\napp: ui\nrel: stable\nrel=stable\napp=ui\nAccount\nService\npod\napp: as\nrel: stable\napp=as\napp: pc\nrel: stable\napp=pc\napp: sc\nrel: stable\napp=sc\napp: os\nrel: stable\napp=os\nProduct\nCatalog\npod\nShopping\nCart\npod\nOrder\nService\npod\nUI pod\napp: ui\nrel: beta\nrel=beta\napp: pc\nrel: beta\napp: os\nrel: beta\nProduct\nCatalog\npod\nOrder\nService\npod\nrel=canary\nAccount\nService\npod\napp: as\nrel: canary\napp: pc\nrel: canary\napp: os\nrel: canary\nProduct\nCatalog\npod\nOrder\nService\npod\nFigure 3.10\nSelecting and deleting all canary pods through the rel=canary label selector\n \n", "shape": "dot", "size": 10, "title": "81\nStopping and removing pods\ndelete the whole namespace (the pods will be deleted along with the namespace auto-\nmatically), using the following command:\n$ kubectl delete ns custom-namespace\nnamespace \"custom-namespace\" deleted\n3.8.4\nDeleting all pods in a namespace, while keeping the namespace\nYou\u2019ve now cleaned up almost everything. But what about the pod you created with\nthe kubectl run command in chapter 2? That one is still running:\n$ kubectl get pods\nNAME            READY   STATUS    RESTARTS   AGE\nkubia-zxzij     1/1     Running   0          1d    \nThis time, instead of deleting the specific pod, tell Kubernetes to delete all pods in the\ncurrent namespace by using the --all option:\n$ kubectl delete po --all\npod \"kubia-zxzij\" deleted\nNow, double check that no pods were left running:\n$ kubectl get pods\nNAME            READY   STATUS        RESTARTS   AGE\nkubia-09as0     1/1     Running       0          1d    \nkubia-zxzij     1/1     Terminating   0          1d    \nUI pod\napp: ui\nrel: stable\nrel=stable\napp=ui\nAccount\nService\npod\napp: as\nrel: stable\napp=as\napp: pc\nrel: stable\napp=pc\napp: sc\nrel: stable\napp=sc\napp: os\nrel: stable\napp=os\nProduct\nCatalog\npod\nShopping\nCart\npod\nOrder\nService\npod\nUI pod\napp: ui\nrel: beta\nrel=beta\napp: pc\nrel: beta\napp: os\nrel: beta\nProduct\nCatalog\npod\nOrder\nService\npod\nrel=canary\nAccount\nService\npod\napp: as\nrel: canary\napp: pc\nrel: canary\napp: os\nrel: canary\nProduct\nCatalog\npod\nOrder\nService\npod\nFigure 3.10\nSelecting and deleting all canary pods through the rel=canary label selector\n \n"}, {"color": "green", "id": "text_25", "label": "82\nCHAPTER 3\nPods: running containers in Kubernetes\nWait, what!?! The kubia-zxzij pod is terminating, but a new pod called kubia-09as0,\nwhich wasn\u2019t there before, has appeared. No matter how many times you delete all\npods, a new pod called kubia-something will emerge. \n You may remember you created your first pod with the kubectl run command. In\nchapter 2, I mentioned that this doesn\u2019t create a pod directly, but instead creates a\nReplicationController, which then creates the pod. As soon as you delete a pod cre-\nated by the ReplicationController, it immediately creates a new one. To delete the\npod, you also need to delete the ReplicationController. \n3.8.5\nDeleting (almost) all resources in a namespace\nYou can delete the ReplicationController and the pods, as well as all the Services\nyou\u2019ve created, by deleting all resources in the current namespace with a single\ncommand:\n$ kubectl delete all --all\npod \"kubia-09as0\" deleted\nreplicationcontroller \"kubia\" deleted\nservice \"kubernetes\" deleted\nservice \"kubia-http\" deleted\nThe first all in the command specifies that you\u2019re deleting resources of all types, and\nthe --all option specifies that you\u2019re deleting all resource instances instead of speci-\nfying them by name (you already used this option when you ran the previous delete\ncommand).\nNOTE\nDeleting everything with the all keyword doesn\u2019t delete absolutely\neverything. Certain resources (like Secrets, which we\u2019ll introduce in chapter 7)\nare preserved and need to be deleted explicitly.\nAs it deletes resources, kubectl will print the name of every resource it deletes. In the\nlist, you should see the kubia ReplicationController and the kubia-http Service you\ncreated in chapter 2. \nNOTE\nThe kubectl delete all --all command also deletes the kubernetes\nService, but it should be recreated automatically in a few moments.\n3.9\nSummary\nAfter reading this chapter, you should now have a decent knowledge of the central\nbuilding block in Kubernetes. Every other concept you\u2019ll learn about in the next few\nchapters is directly related to pods. \n In this chapter, you\u2019ve learned\n\uf0a1How to decide whether certain containers should be grouped together in a pod\nor not.\n \n", "shape": "dot", "size": 10, "title": "82\nCHAPTER 3\nPods: running containers in Kubernetes\nWait, what!?! The kubia-zxzij pod is terminating, but a new pod called kubia-09as0,\nwhich wasn\u2019t there before, has appeared. No matter how many times you delete all\npods, a new pod called kubia-something will emerge. \n You may remember you created your first pod with the kubectl run command. In\nchapter 2, I mentioned that this doesn\u2019t create a pod directly, but instead creates a\nReplicationController, which then creates the pod. As soon as you delete a pod cre-\nated by the ReplicationController, it immediately creates a new one. To delete the\npod, you also need to delete the ReplicationController. \n3.8.5\nDeleting (almost) all resources in a namespace\nYou can delete the ReplicationController and the pods, as well as all the Services\nyou\u2019ve created, by deleting all resources in the current namespace with a single\ncommand:\n$ kubectl delete all --all\npod \"kubia-09as0\" deleted\nreplicationcontroller \"kubia\" deleted\nservice \"kubernetes\" deleted\nservice \"kubia-http\" deleted\nThe first all in the command specifies that you\u2019re deleting resources of all types, and\nthe --all option specifies that you\u2019re deleting all resource instances instead of speci-\nfying them by name (you already used this option when you ran the previous delete\ncommand).\nNOTE\nDeleting everything with the all keyword doesn\u2019t delete absolutely\neverything. Certain resources (like Secrets, which we\u2019ll introduce in chapter 7)\nare preserved and need to be deleted explicitly.\nAs it deletes resources, kubectl will print the name of every resource it deletes. In the\nlist, you should see the kubia ReplicationController and the kubia-http Service you\ncreated in chapter 2. \nNOTE\nThe kubectl delete all --all command also deletes the kubernetes\nService, but it should be recreated automatically in a few moments.\n3.9\nSummary\nAfter reading this chapter, you should now have a decent knowledge of the central\nbuilding block in Kubernetes. Every other concept you\u2019ll learn about in the next few\nchapters is directly related to pods. \n In this chapter, you\u2019ve learned\n\uf0a1How to decide whether certain containers should be grouped together in a pod\nor not.\n \n"}, {"color": "green", "id": "text_26", "label": "83\nSummary\n\uf0a1Pods can run multiple processes and are similar to physical hosts in the non-\ncontainer world.\n\uf0a1YAML or JSON descriptors can be written and used to create pods and then\nexamined to see the specification of a pod and its current state.\n\uf0a1Labels and label selectors should be used to organize pods and easily perform\noperations on multiple pods at once.\n\uf0a1You can use node labels and selectors to schedule pods only to nodes that have\ncertain features.\n\uf0a1Annotations allow attaching larger blobs of data to pods either by people or\ntools and libraries.\n\uf0a1Namespaces can be used to allow different teams to use the same cluster as\nthough they were using separate Kubernetes clusters.\n\uf0a1How to use the kubectl explain command to quickly look up the information\non any Kubernetes resource. \nIn the next chapter, you\u2019ll learn about ReplicationControllers and other resources\nthat manage pods.\n \n", "shape": "dot", "size": 10, "title": "83\nSummary\n\uf0a1Pods can run multiple processes and are similar to physical hosts in the non-\ncontainer world.\n\uf0a1YAML or JSON descriptors can be written and used to create pods and then\nexamined to see the specification of a pod and its current state.\n\uf0a1Labels and label selectors should be used to organize pods and easily perform\noperations on multiple pods at once.\n\uf0a1You can use node labels and selectors to schedule pods only to nodes that have\ncertain features.\n\uf0a1Annotations allow attaching larger blobs of data to pods either by people or\ntools and libraries.\n\uf0a1Namespaces can be used to allow different teams to use the same cluster as\nthough they were using separate Kubernetes clusters.\n\uf0a1How to use the kubectl explain command to quickly look up the information\non any Kubernetes resource. \nIn the next chapter, you\u2019ll learn about ReplicationControllers and other resources\nthat manage pods.\n \n"}, {"color": "green", "id": "text_27", "label": "84\nReplication and other\ncontrollers: deploying\nmanaged pods\nAs you\u2019ve learned so far, pods represent the basic deployable unit in Kubernetes.\nYou know how to create, supervise, and manage them manually. But in real-world\nuse cases, you want your deployments to stay up and running automatically and\nremain healthy without any manual intervention. To do this, you almost never cre-\nate pods directly. Instead, you create other types of resources, such as Replication-\nControllers or Deployments, which then create and manage the actual pods.\n When you create unmanaged pods (such as the ones you created in the previ-\nous chapter), a cluster node is selected to run the pod and then its containers are\nrun on that node. In this chapter, you\u2019ll learn that Kubernetes then monitors\nThis chapter covers\n\uf0a1Keeping pods healthy\n\uf0a1Running multiple instances of the same pod\n\uf0a1Automatically rescheduling pods after a node fails\n\uf0a1Scaling pods horizontally\n\uf0a1Running system-level pods on each cluster node\n\uf0a1Running batch jobs\n\uf0a1Scheduling jobs to run periodically or once in \nthe future\n \n", "shape": "dot", "size": 10, "title": "84\nReplication and other\ncontrollers: deploying\nmanaged pods\nAs you\u2019ve learned so far, pods represent the basic deployable unit in Kubernetes.\nYou know how to create, supervise, and manage them manually. But in real-world\nuse cases, you want your deployments to stay up and running automatically and\nremain healthy without any manual intervention. To do this, you almost never cre-\nate pods directly. Instead, you create other types of resources, such as Replication-\nControllers or Deployments, which then create and manage the actual pods.\n When you create unmanaged pods (such as the ones you created in the previ-\nous chapter), a cluster node is selected to run the pod and then its containers are\nrun on that node. In this chapter, you\u2019ll learn that Kubernetes then monitors\nThis chapter covers\n\uf0a1Keeping pods healthy\n\uf0a1Running multiple instances of the same pod\n\uf0a1Automatically rescheduling pods after a node fails\n\uf0a1Scaling pods horizontally\n\uf0a1Running system-level pods on each cluster node\n\uf0a1Running batch jobs\n\uf0a1Scheduling jobs to run periodically or once in \nthe future\n \n"}, {"color": "green", "id": "text_28", "label": "85\nKeeping pods healthy\nthose containers and automatically restarts them if they fail. But if the whole node\nfails, the pods on the node are lost and will not be replaced with new ones, unless\nthose pods are managed by the previously mentioned ReplicationControllers or simi-\nlar. In this chapter, you\u2019ll learn how Kubernetes checks if a container is still alive and\nrestarts it if it isn\u2019t. You\u2019ll also learn how to run managed pods\u2014both those that run\nindefinitely and those that perform a single task and then stop. \n4.1\nKeeping pods healthy\nOne of the main benefits of using Kubernetes is the ability to give it a list of contain-\ners and let it keep those containers running somewhere in the cluster. You do this by\ncreating a Pod resource and letting Kubernetes pick a worker node for it and run\nthe pod\u2019s containers on that node. But what if one of those containers dies? What if\nall containers of a pod die? \n As soon as a pod is scheduled to a node, the Kubelet on that node will run its con-\ntainers and, from then on, keep them running as long as the pod exists. If the con-\ntainer\u2019s main process crashes, the Kubelet will restart the container. If your\napplication has a bug that causes it to crash every once in a while, Kubernetes will\nrestart it automatically, so even without doing anything special in the app itself, run-\nning the app in Kubernetes automatically gives it the ability to heal itself. \n But sometimes apps stop working without their process crashing. For example, a\nJava app with a memory leak will start throwing OutOfMemoryErrors, but the JVM\nprocess will keep running. It would be great to have a way for an app to signal to\nKubernetes that it\u2019s no longer functioning properly and have Kubernetes restart it. \n We\u2019ve said that a container that crashes is restarted automatically, so maybe you\u2019re\nthinking you could catch these types of errors in the app and exit the process when\nthey occur. You can certainly do that, but it still doesn\u2019t solve all your problems. \n For example, what about those situations when your app stops responding because\nit falls into an infinite loop or a deadlock? To make sure applications are restarted in\nsuch cases, you must check an application\u2019s health from the outside and not depend\non the app doing it internally. \n4.1.1\nIntroducing liveness probes\nKubernetes can check if a container is still alive through liveness probes. You can specify\na liveness probe for each container in the pod\u2019s specification. Kubernetes will periodi-\ncally execute the probe and restart the container if the probe fails. \nNOTE\nKubernetes also supports readiness probes, which we\u2019ll learn about in the\nnext chapter. Be sure not to confuse the two. They\u2019re used for two different\nthings.\nKubernetes can probe a container using one of the three mechanisms:\n\uf0a1An HTTP GET probe performs an HTTP GET request on the container\u2019s IP\naddress, a port and path you specify. If the probe receives a response, and the\n \n", "shape": "dot", "size": 10, "title": "85\nKeeping pods healthy\nthose containers and automatically restarts them if they fail. But if the whole node\nfails, the pods on the node are lost and will not be replaced with new ones, unless\nthose pods are managed by the previously mentioned ReplicationControllers or simi-\nlar. In this chapter, you\u2019ll learn how Kubernetes checks if a container is still alive and\nrestarts it if it isn\u2019t. You\u2019ll also learn how to run managed pods\u2014both those that run\nindefinitely and those that perform a single task and then stop. \n4.1\nKeeping pods healthy\nOne of the main benefits of using Kubernetes is the ability to give it a list of contain-\ners and let it keep those containers running somewhere in the cluster. You do this by\ncreating a Pod resource and letting Kubernetes pick a worker node for it and run\nthe pod\u2019s containers on that node. But what if one of those containers dies? What if\nall containers of a pod die? \n As soon as a pod is scheduled to a node, the Kubelet on that node will run its con-\ntainers and, from then on, keep them running as long as the pod exists. If the con-\ntainer\u2019s main process crashes, the Kubelet will restart the container. If your\napplication has a bug that causes it to crash every once in a while, Kubernetes will\nrestart it automatically, so even without doing anything special in the app itself, run-\nning the app in Kubernetes automatically gives it the ability to heal itself. \n But sometimes apps stop working without their process crashing. For example, a\nJava app with a memory leak will start throwing OutOfMemoryErrors, but the JVM\nprocess will keep running. It would be great to have a way for an app to signal to\nKubernetes that it\u2019s no longer functioning properly and have Kubernetes restart it. \n We\u2019ve said that a container that crashes is restarted automatically, so maybe you\u2019re\nthinking you could catch these types of errors in the app and exit the process when\nthey occur. You can certainly do that, but it still doesn\u2019t solve all your problems. \n For example, what about those situations when your app stops responding because\nit falls into an infinite loop or a deadlock? To make sure applications are restarted in\nsuch cases, you must check an application\u2019s health from the outside and not depend\non the app doing it internally. \n4.1.1\nIntroducing liveness probes\nKubernetes can check if a container is still alive through liveness probes. You can specify\na liveness probe for each container in the pod\u2019s specification. Kubernetes will periodi-\ncally execute the probe and restart the container if the probe fails. \nNOTE\nKubernetes also supports readiness probes, which we\u2019ll learn about in the\nnext chapter. Be sure not to confuse the two. They\u2019re used for two different\nthings.\nKubernetes can probe a container using one of the three mechanisms:\n\uf0a1An HTTP GET probe performs an HTTP GET request on the container\u2019s IP\naddress, a port and path you specify. If the probe receives a response, and the\n \n"}, {"color": "green", "id": "text_29", "label": "86\nCHAPTER 4\nReplication and other controllers: deploying managed pods\nresponse code doesn\u2019t represent an error (in other words, if the HTTP response\ncode is 2xx or 3xx), the probe is considered successful. If the server returns an\nerror response code or if it doesn\u2019t respond at all, the probe is considered a fail-\nure and the container will be restarted as a result.\n\uf0a1A TCP Socket probe tries to open a TCP connection to the specified port of the\ncontainer. If the connection is established successfully, the probe is successful.\nOtherwise, the container is restarted.\n\uf0a1An Exec probe executes an arbitrary command inside the container and checks\nthe command\u2019s exit status code. If the status code is 0, the probe is successful.\nAll other codes are considered failures. \n4.1.2\nCreating an HTTP-based liveness probe\nLet\u2019s see how to add a liveness probe to your Node.js app. Because it\u2019s a web app, it\nmakes sense to add a liveness probe that will check whether its web server is serving\nrequests. But because this particular Node.js app is too simple to ever fail, you\u2019ll need\nto make the app fail artificially. \n To properly demo liveness probes, you\u2019ll modify the app slightly and make it\nreturn a 500 Internal Server Error HTTP status code for each request after the fifth\none\u2014your app will handle the first five client requests properly and then return an\nerror on every subsequent request. Thanks to the liveness probe, it should be restarted\nwhen that happens, allowing it to properly handle client requests again.\n You can find the code of the new app in the book\u2019s code archive (in the folder\nChapter04/kubia-unhealthy). I\u2019ve pushed the container image to Docker Hub, so you\ndon\u2019t need to build it yourself. \n You\u2019ll create a new pod that includes an HTTP GET liveness probe. The following\nlisting shows the YAML for the pod.\napiVersion: v1\nkind: pod\nmetadata:\n  name: kubia-liveness\nspec:\n  containers:\n  - image: luksa/kubia-unhealthy   \n    name: kubia\n    livenessProbe:                 \n      httpGet:                     \n        path: /                     \n        port: 8080       \nListing 4.1\nAdding a liveness probe to a pod: kubia-liveness-probe.yaml\nThis is the image \ncontaining the \n(somewhat) \nbroken app.\nA liveness probe that will \nperform an HTTP GET\nThe path to \nrequest in the \nHTTP request\nThe network port\nthe probe should\nconnect to\n \n", "shape": "dot", "size": 10, "title": "86\nCHAPTER 4\nReplication and other controllers: deploying managed pods\nresponse code doesn\u2019t represent an error (in other words, if the HTTP response\ncode is 2xx or 3xx), the probe is considered successful. If the server returns an\nerror response code or if it doesn\u2019t respond at all, the probe is considered a fail-\nure and the container will be restarted as a result.\n\uf0a1A TCP Socket probe tries to open a TCP connection to the specified port of the\ncontainer. If the connection is established successfully, the probe is successful.\nOtherwise, the container is restarted.\n\uf0a1An Exec probe executes an arbitrary command inside the container and checks\nthe command\u2019s exit status code. If the status code is 0, the probe is successful.\nAll other codes are considered failures. \n4.1.2\nCreating an HTTP-based liveness probe\nLet\u2019s see how to add a liveness probe to your Node.js app. Because it\u2019s a web app, it\nmakes sense to add a liveness probe that will check whether its web server is serving\nrequests. But because this particular Node.js app is too simple to ever fail, you\u2019ll need\nto make the app fail artificially. \n To properly demo liveness probes, you\u2019ll modify the app slightly and make it\nreturn a 500 Internal Server Error HTTP status code for each request after the fifth\none\u2014your app will handle the first five client requests properly and then return an\nerror on every subsequent request. Thanks to the liveness probe, it should be restarted\nwhen that happens, allowing it to properly handle client requests again.\n You can find the code of the new app in the book\u2019s code archive (in the folder\nChapter04/kubia-unhealthy). I\u2019ve pushed the container image to Docker Hub, so you\ndon\u2019t need to build it yourself. \n You\u2019ll create a new pod that includes an HTTP GET liveness probe. The following\nlisting shows the YAML for the pod.\napiVersion: v1\nkind: pod\nmetadata:\n  name: kubia-liveness\nspec:\n  containers:\n  - image: luksa/kubia-unhealthy   \n    name: kubia\n    livenessProbe:                 \n      httpGet:                     \n        path: /                     \n        port: 8080       \nListing 4.1\nAdding a liveness probe to a pod: kubia-liveness-probe.yaml\nThis is the image \ncontaining the \n(somewhat) \nbroken app.\nA liveness probe that will \nperform an HTTP GET\nThe path to \nrequest in the \nHTTP request\nThe network port\nthe probe should\nconnect to\n \n"}, {"color": "green", "id": "text_30", "label": "87\nKeeping pods healthy\nThe pod descriptor defines an httpGet liveness probe, which tells Kubernetes to peri-\nodically perform HTTP GET requests on path / on port 8080 to determine if the con-\ntainer is still healthy. These requests start as soon as the container is run.\n After five such requests (or actual client requests), your app starts returning\nHTTP status code 500, which Kubernetes will treat as a probe failure, and will thus\nrestart the container. \n4.1.3\nSeeing a liveness probe in action\nTo see what the liveness probe does, try creating the pod now. After about a minute and\na half, the container will be restarted. You can see that by running kubectl get:\n$ kubectl get po kubia-liveness\nNAME             READY     STATUS    RESTARTS   AGE\nkubia-liveness   1/1       Running   1          2m\nThe RESTARTS column shows that the pod\u2019s container has been restarted once (if you\nwait another minute and a half, it gets restarted again, and then the cycle continues\nindefinitely).\nYou can see why the container had to be restarted by looking at what kubectl describe\nprints out, as shown in the following listing.\n$ kubectl describe po kubia-liveness\nName:           kubia-liveness\n...\nContainers:\n  kubia:\n    Container ID:       docker://480986f8\n    Image:              luksa/kubia-unhealthy\n    Image ID:           docker://sha256:2b208508\n    Port:\n    State:              Running                            \n      Started:          Sun, 14 May 2017 11:41:40 +0200    \nObtaining the application log of a crashed container\nIn the previous chapter, you learned how to print the application\u2019s log with kubectl\nlogs. If your container is restarted, the kubectl logs command will show the log of\nthe current container. \nWhen you want to figure out why the previous container terminated, you\u2019ll want to\nsee those logs instead of the current container\u2019s logs. This can be done by using\nthe --previous option:\n$ kubectl logs mypod --previous\nListing 4.2\nA pod\u2019s description after its container is restarted\nThe container is \ncurrently running.\n \n", "shape": "dot", "size": 10, "title": "87\nKeeping pods healthy\nThe pod descriptor defines an httpGet liveness probe, which tells Kubernetes to peri-\nodically perform HTTP GET requests on path / on port 8080 to determine if the con-\ntainer is still healthy. These requests start as soon as the container is run.\n After five such requests (or actual client requests), your app starts returning\nHTTP status code 500, which Kubernetes will treat as a probe failure, and will thus\nrestart the container. \n4.1.3\nSeeing a liveness probe in action\nTo see what the liveness probe does, try creating the pod now. After about a minute and\na half, the container will be restarted. You can see that by running kubectl get:\n$ kubectl get po kubia-liveness\nNAME             READY     STATUS    RESTARTS   AGE\nkubia-liveness   1/1       Running   1          2m\nThe RESTARTS column shows that the pod\u2019s container has been restarted once (if you\nwait another minute and a half, it gets restarted again, and then the cycle continues\nindefinitely).\nYou can see why the container had to be restarted by looking at what kubectl describe\nprints out, as shown in the following listing.\n$ kubectl describe po kubia-liveness\nName:           kubia-liveness\n...\nContainers:\n  kubia:\n    Container ID:       docker://480986f8\n    Image:              luksa/kubia-unhealthy\n    Image ID:           docker://sha256:2b208508\n    Port:\n    State:              Running                            \n      Started:          Sun, 14 May 2017 11:41:40 +0200    \nObtaining the application log of a crashed container\nIn the previous chapter, you learned how to print the application\u2019s log with kubectl\nlogs. If your container is restarted, the kubectl logs command will show the log of\nthe current container. \nWhen you want to figure out why the previous container terminated, you\u2019ll want to\nsee those logs instead of the current container\u2019s logs. This can be done by using\nthe --previous option:\n$ kubectl logs mypod --previous\nListing 4.2\nA pod\u2019s description after its container is restarted\nThe container is \ncurrently running.\n \n"}, {"color": "green", "id": "text_31", "label": "88\nCHAPTER 4\nReplication and other controllers: deploying managed pods\n    Last State:         Terminated                         \n      Reason:           Error                              \n      Exit Code:        137                                \n      Started:          Mon, 01 Jan 0001 00:00:00 +0000    \n      Finished:         Sun, 14 May 2017 11:41:38 +0200    \n    Ready:              True\n    Restart Count:      1                                 \n    Liveness:           http-get http://:8080/ delay=0s timeout=1s\n                        period=10s #success=1 #failure=3\n    ...\nEvents:\n... Killing container with id docker://95246981:pod \"kubia-liveness ...\"\n    container \"kubia\" is unhealthy, it will be killed and re-created.\nYou can see that the container is currently running, but it previously terminated\nbecause of an error. The exit code was 137, which has a special meaning\u2014it denotes\nthat the process was terminated by an external signal. The number 137 is a sum of two\nnumbers: 128+x, where x is the signal number sent to the process that caused it to ter-\nminate. In the example, x equals 9, which is the number of the SIGKILL signal, mean-\ning the process was killed forcibly.\n The events listed at the bottom show why the container was killed\u2014Kubernetes\ndetected the container was unhealthy, so it killed and re-created it. \nNOTE\nWhen a container is killed, a completely new container is created\u2014it\u2019s\nnot the same container being restarted again.\n4.1.4\nConfiguring additional properties of the liveness probe\nYou may have noticed that kubectl describe also displays additional information\nabout the liveness probe:\nLiveness: http-get http://:8080/ delay=0s timeout=1s period=10s #success=1 \n          \u27a5 #failure=3\nBeside the liveness probe options you specified explicitly, you can also see additional\nproperties, such as delay, timeout, period, and so on. The delay=0s part shows that\nthe probing begins immediately after the container is started. The timeout is set to\nonly 1 second, so the container must return a response in 1 second or the probe is\ncounted as failed. The container is probed every 10 seconds (period=10s) and the\ncontainer is restarted after the probe fails three consecutive times (#failure=3). \n These additional parameters can be customized when defining the probe. For\nexample, to set the initial delay, add the initialDelaySeconds property to the live-\nness probe as shown in the following listing.\n   livenessProbe:          \n     httpGet:              \n       path: /             \nListing 4.3\nA liveness probe with an initial delay: kubia-liveness-probe-initial-delay.yaml\nThe previous \ncontainer terminated \nwith an error and \nexited with code 137.\nThe container \nhas been \nrestarted once.\n \n", "shape": "dot", "size": 10, "title": "88\nCHAPTER 4\nReplication and other controllers: deploying managed pods\n    Last State:         Terminated                         \n      Reason:           Error                              \n      Exit Code:        137                                \n      Started:          Mon, 01 Jan 0001 00:00:00 +0000    \n      Finished:         Sun, 14 May 2017 11:41:38 +0200    \n    Ready:              True\n    Restart Count:      1                                 \n    Liveness:           http-get http://:8080/ delay=0s timeout=1s\n                        period=10s #success=1 #failure=3\n    ...\nEvents:\n... Killing container with id docker://95246981:pod \"kubia-liveness ...\"\n    container \"kubia\" is unhealthy, it will be killed and re-created.\nYou can see that the container is currently running, but it previously terminated\nbecause of an error. The exit code was 137, which has a special meaning\u2014it denotes\nthat the process was terminated by an external signal. The number 137 is a sum of two\nnumbers: 128+x, where x is the signal number sent to the process that caused it to ter-\nminate. In the example, x equals 9, which is the number of the SIGKILL signal, mean-\ning the process was killed forcibly.\n The events listed at the bottom show why the container was killed\u2014Kubernetes\ndetected the container was unhealthy, so it killed and re-created it. \nNOTE\nWhen a container is killed, a completely new container is created\u2014it\u2019s\nnot the same container being restarted again.\n4.1.4\nConfiguring additional properties of the liveness probe\nYou may have noticed that kubectl describe also displays additional information\nabout the liveness probe:\nLiveness: http-get http://:8080/ delay=0s timeout=1s period=10s #success=1 \n          \u27a5 #failure=3\nBeside the liveness probe options you specified explicitly, you can also see additional\nproperties, such as delay, timeout, period, and so on. The delay=0s part shows that\nthe probing begins immediately after the container is started. The timeout is set to\nonly 1 second, so the container must return a response in 1 second or the probe is\ncounted as failed. The container is probed every 10 seconds (period=10s) and the\ncontainer is restarted after the probe fails three consecutive times (#failure=3). \n These additional parameters can be customized when defining the probe. For\nexample, to set the initial delay, add the initialDelaySeconds property to the live-\nness probe as shown in the following listing.\n   livenessProbe:          \n     httpGet:              \n       path: /             \nListing 4.3\nA liveness probe with an initial delay: kubia-liveness-probe-initial-delay.yaml\nThe previous \ncontainer terminated \nwith an error and \nexited with code 137.\nThe container \nhas been \nrestarted once.\n \n"}, {"color": "green", "id": "text_32", "label": "89\nKeeping pods healthy\n       port: 8080          \n     initialDelaySeconds: 15   \nIf you don\u2019t set the initial delay, the prober will start probing the container as soon as\nit starts, which usually leads to the probe failing, because the app isn\u2019t ready to start\nreceiving requests. If the number of failures exceeds the failure threshold, the con-\ntainer is restarted before it\u2019s even able to start responding to requests properly. \nTIP\nAlways remember to set an initial delay to account for your app\u2019s startup\ntime.\nI\u2019ve seen this on many occasions and users were confused why their container was\nbeing restarted. But if they\u2019d used kubectl describe, they\u2019d have seen that the con-\ntainer terminated with exit code 137 or 143, telling them that the pod was terminated\nexternally. Additionally, the listing of the pod\u2019s events would show that the container\nwas killed because of a failed liveness probe. If you see this happening at pod startup,\nit\u2019s because you failed to set initialDelaySeconds appropriately.\nNOTE\nExit code 137 signals that the process was killed by an external signal\n(exit code is 128 + 9 (SIGKILL). Likewise, exit code 143 corresponds to 128 +\n15 (SIGTERM).\n4.1.5\nCreating effective liveness probes\nFor pods running in production, you should always define a liveness probe. Without\none, Kubernetes has no way of knowing whether your app is still alive or not. As long\nas the process is still running, Kubernetes will consider the container to be healthy. \nWHAT A LIVENESS PROBE SHOULD CHECK\nYour simplistic liveness probe simply checks if the server is responding. While this may\nseem overly simple, even a liveness probe like this does wonders, because it causes the\ncontainer to be restarted if the web server running within the container stops\nresponding to HTTP requests. Compared to having no liveness probe, this is a major\nimprovement, and may be sufficient in most cases.\n But for a better liveness check, you\u2019d configure the probe to perform requests on a\nspecific URL path (/health, for example) and have the app perform an internal sta-\ntus check of all the vital components running inside the app to ensure none of them\nhas died or is unresponsive. \nTIP\nMake sure the /health HTTP endpoint doesn\u2019t require authentication;\notherwise the probe will always fail, causing your container to be restarted\nindefinitely.\nBe sure to check only the internals of the app and nothing influenced by an external\nfactor. For example, a frontend web server\u2019s liveness probe shouldn\u2019t return a failure\nwhen the server can\u2019t connect to the backend database. If the underlying cause is in\nthe database itself, restarting the web server container will not fix the problem.\nKubernetes will wait 15 seconds \nbefore executing the first probe.\n \n", "shape": "dot", "size": 10, "title": "89\nKeeping pods healthy\n       port: 8080          \n     initialDelaySeconds: 15   \nIf you don\u2019t set the initial delay, the prober will start probing the container as soon as\nit starts, which usually leads to the probe failing, because the app isn\u2019t ready to start\nreceiving requests. If the number of failures exceeds the failure threshold, the con-\ntainer is restarted before it\u2019s even able to start responding to requests properly. \nTIP\nAlways remember to set an initial delay to account for your app\u2019s startup\ntime.\nI\u2019ve seen this on many occasions and users were confused why their container was\nbeing restarted. But if they\u2019d used kubectl describe, they\u2019d have seen that the con-\ntainer terminated with exit code 137 or 143, telling them that the pod was terminated\nexternally. Additionally, the listing of the pod\u2019s events would show that the container\nwas killed because of a failed liveness probe. If you see this happening at pod startup,\nit\u2019s because you failed to set initialDelaySeconds appropriately.\nNOTE\nExit code 137 signals that the process was killed by an external signal\n(exit code is 128 + 9 (SIGKILL). Likewise, exit code 143 corresponds to 128 +\n15 (SIGTERM).\n4.1.5\nCreating effective liveness probes\nFor pods running in production, you should always define a liveness probe. Without\none, Kubernetes has no way of knowing whether your app is still alive or not. As long\nas the process is still running, Kubernetes will consider the container to be healthy. \nWHAT A LIVENESS PROBE SHOULD CHECK\nYour simplistic liveness probe simply checks if the server is responding. While this may\nseem overly simple, even a liveness probe like this does wonders, because it causes the\ncontainer to be restarted if the web server running within the container stops\nresponding to HTTP requests. Compared to having no liveness probe, this is a major\nimprovement, and may be sufficient in most cases.\n But for a better liveness check, you\u2019d configure the probe to perform requests on a\nspecific URL path (/health, for example) and have the app perform an internal sta-\ntus check of all the vital components running inside the app to ensure none of them\nhas died or is unresponsive. \nTIP\nMake sure the /health HTTP endpoint doesn\u2019t require authentication;\notherwise the probe will always fail, causing your container to be restarted\nindefinitely.\nBe sure to check only the internals of the app and nothing influenced by an external\nfactor. For example, a frontend web server\u2019s liveness probe shouldn\u2019t return a failure\nwhen the server can\u2019t connect to the backend database. If the underlying cause is in\nthe database itself, restarting the web server container will not fix the problem.\nKubernetes will wait 15 seconds \nbefore executing the first probe.\n \n"}, {"color": "green", "id": "text_33", "label": "90\nCHAPTER 4\nReplication and other controllers: deploying managed pods\nBecause the liveness probe will fail again, you\u2019ll end up with the container restarting\nrepeatedly until the database becomes accessible again. \nKEEPING PROBES LIGHT\nLiveness probes shouldn\u2019t use too many computational resources and shouldn\u2019t take\ntoo long to complete. By default, the probes are executed relatively often and are\nonly allowed one second to complete. Having a probe that does heavy lifting can slow\ndown your container considerably. Later in the book, you\u2019ll also learn about how to\nlimit CPU time available to a container. The probe\u2019s CPU time is counted in the con-\ntainer\u2019s CPU time quota, so having a heavyweight liveness probe will reduce the CPU\ntime available to the main application processes.\nTIP\nIf you\u2019re running a Java app in your container, be sure to use an HTTP\nGET liveness probe instead of an Exec probe, where you spin up a whole new\nJVM to get the liveness information. The same goes for any JVM-based or sim-\nilar applications, whose start-up procedure requires considerable computa-\ntional resources.\nDON\u2019T BOTHER IMPLEMENTING RETRY LOOPS IN YOUR PROBES\nYou\u2019ve already seen that the failure threshold for the probe is configurable and usu-\nally the probe must fail multiple times before the container is killed. But even if you\nset the failure threshold to 1, Kubernetes will retry the probe several times before con-\nsidering it a single failed attempt. Therefore, implementing your own retry loop into\nthe probe is wasted effort.\nLIVENESS PROBE WRAP-UP\nYou now understand that Kubernetes keeps your containers running by restarting\nthem if they crash or if their liveness probes fail. This job is performed by the Kubelet\non the node hosting the pod\u2014the Kubernetes Control Plane components running on\nthe master(s) have no part in this process. \n But if the node itself crashes, it\u2019s the Control Plane that must create replacements for\nall the pods that went down with the node. It doesn\u2019t do that for pods that you create\ndirectly. Those pods aren\u2019t managed by anything except by the Kubelet, but because the\nKubelet runs on the node itself, it can\u2019t do anything if the node fails. \n To make sure your app is restarted on another node, you need to have the pod\nmanaged by a ReplicationController or similar mechanism, which we\u2019ll discuss in the\nrest of this chapter. \n4.2\nIntroducing ReplicationControllers\nA ReplicationController is a Kubernetes resource that ensures its pods are always\nkept running. If the pod disappears for any reason, such as in the event of a node\ndisappearing from the cluster or because the pod was evicted from the node, the\nReplicationController notices the missing pod and creates a replacement pod. \n Figure 4.1 shows what happens when a node goes down and takes two pods with it.\nPod A was created directly and is therefore an unmanaged pod, while pod B is managed\n \n", "shape": "dot", "size": 10, "title": "90\nCHAPTER 4\nReplication and other controllers: deploying managed pods\nBecause the liveness probe will fail again, you\u2019ll end up with the container restarting\nrepeatedly until the database becomes accessible again. \nKEEPING PROBES LIGHT\nLiveness probes shouldn\u2019t use too many computational resources and shouldn\u2019t take\ntoo long to complete. By default, the probes are executed relatively often and are\nonly allowed one second to complete. Having a probe that does heavy lifting can slow\ndown your container considerably. Later in the book, you\u2019ll also learn about how to\nlimit CPU time available to a container. The probe\u2019s CPU time is counted in the con-\ntainer\u2019s CPU time quota, so having a heavyweight liveness probe will reduce the CPU\ntime available to the main application processes.\nTIP\nIf you\u2019re running a Java app in your container, be sure to use an HTTP\nGET liveness probe instead of an Exec probe, where you spin up a whole new\nJVM to get the liveness information. The same goes for any JVM-based or sim-\nilar applications, whose start-up procedure requires considerable computa-\ntional resources.\nDON\u2019T BOTHER IMPLEMENTING RETRY LOOPS IN YOUR PROBES\nYou\u2019ve already seen that the failure threshold for the probe is configurable and usu-\nally the probe must fail multiple times before the container is killed. But even if you\nset the failure threshold to 1, Kubernetes will retry the probe several times before con-\nsidering it a single failed attempt. Therefore, implementing your own retry loop into\nthe probe is wasted effort.\nLIVENESS PROBE WRAP-UP\nYou now understand that Kubernetes keeps your containers running by restarting\nthem if they crash or if their liveness probes fail. This job is performed by the Kubelet\non the node hosting the pod\u2014the Kubernetes Control Plane components running on\nthe master(s) have no part in this process. \n But if the node itself crashes, it\u2019s the Control Plane that must create replacements for\nall the pods that went down with the node. It doesn\u2019t do that for pods that you create\ndirectly. Those pods aren\u2019t managed by anything except by the Kubelet, but because the\nKubelet runs on the node itself, it can\u2019t do anything if the node fails. \n To make sure your app is restarted on another node, you need to have the pod\nmanaged by a ReplicationController or similar mechanism, which we\u2019ll discuss in the\nrest of this chapter. \n4.2\nIntroducing ReplicationControllers\nA ReplicationController is a Kubernetes resource that ensures its pods are always\nkept running. If the pod disappears for any reason, such as in the event of a node\ndisappearing from the cluster or because the pod was evicted from the node, the\nReplicationController notices the missing pod and creates a replacement pod. \n Figure 4.1 shows what happens when a node goes down and takes two pods with it.\nPod A was created directly and is therefore an unmanaged pod, while pod B is managed\n \n"}, {"color": "green", "id": "text_34", "label": "91\nIntroducing ReplicationControllers\nby a ReplicationController. After the node fails, the ReplicationController creates a\nnew pod (pod B2) to replace the missing pod B, whereas pod A is lost completely\u2014\nnothing will ever recreate it.\n The ReplicationController in the figure manages only a single pod, but Replication-\nControllers, in general, are meant to create and manage multiple copies (replicas) of a\npod. That\u2019s where ReplicationControllers got their name from. \n4.2.1\nThe operation of a ReplicationController\nA ReplicationController constantly monitors the list of running pods and makes sure\nthe actual number of pods of a \u201ctype\u201d always matches the desired number. If too few\nsuch pods are running, it creates new replicas from a pod template. If too many such\npods are running, it removes the excess replicas. \n You might be wondering how there can be more than the desired number of repli-\ncas. This can happen for a few reasons: \n\uf0a1Someone creates a pod of the same type manually.\n\uf0a1Someone changes an existing pod\u2019s \u201ctype.\u201d\n\uf0a1Someone decreases the desired number of pods, and so on.\nNode 1\nNode 1 fails\nPod A\nPod B\nNode 2\nVarious\nother pods\nCreates and\nmanages\nNode 1\nPod A\nPod B\nNode 2\nVarious\nother pods\nReplicationController\nReplicationController\nPod A goes down with Node 1 and is\nnot recreated, because there is no\nReplicationController overseeing it.\nRC notices pod B is\nmissing and creates\na new pod instance.\nPod B2\nFigure 4.1\nWhen a node fails, only pods backed by a ReplicationController are recreated.\n \n", "shape": "dot", "size": 10, "title": "91\nIntroducing ReplicationControllers\nby a ReplicationController. After the node fails, the ReplicationController creates a\nnew pod (pod B2) to replace the missing pod B, whereas pod A is lost completely\u2014\nnothing will ever recreate it.\n The ReplicationController in the figure manages only a single pod, but Replication-\nControllers, in general, are meant to create and manage multiple copies (replicas) of a\npod. That\u2019s where ReplicationControllers got their name from. \n4.2.1\nThe operation of a ReplicationController\nA ReplicationController constantly monitors the list of running pods and makes sure\nthe actual number of pods of a \u201ctype\u201d always matches the desired number. If too few\nsuch pods are running, it creates new replicas from a pod template. If too many such\npods are running, it removes the excess replicas. \n You might be wondering how there can be more than the desired number of repli-\ncas. This can happen for a few reasons: \n\uf0a1Someone creates a pod of the same type manually.\n\uf0a1Someone changes an existing pod\u2019s \u201ctype.\u201d\n\uf0a1Someone decreases the desired number of pods, and so on.\nNode 1\nNode 1 fails\nPod A\nPod B\nNode 2\nVarious\nother pods\nCreates and\nmanages\nNode 1\nPod A\nPod B\nNode 2\nVarious\nother pods\nReplicationController\nReplicationController\nPod A goes down with Node 1 and is\nnot recreated, because there is no\nReplicationController overseeing it.\nRC notices pod B is\nmissing and creates\na new pod instance.\nPod B2\nFigure 4.1\nWhen a node fails, only pods backed by a ReplicationController are recreated.\n \n"}, {"color": "green", "id": "text_35", "label": "92\nCHAPTER 4\nReplication and other controllers: deploying managed pods\nI\u2019ve used the term pod \u201ctype\u201d a few times. But no such thing exists. Replication-\nControllers don\u2019t operate on pod types, but on sets of pods that match a certain label\nselector (you learned about them in the previous chapter). \nINTRODUCING THE CONTROLLER\u2019S RECONCILIATION LOOP\nA ReplicationController\u2019s job is to make sure that an exact number of pods always\nmatches its label selector. If it doesn\u2019t, the ReplicationController takes the appropriate\naction to reconcile the actual with the desired number. The operation of a Replication-\nController is shown in figure 4.2.\nUNDERSTANDING THE THREE PARTS OF A REPLICATIONCONTROLLER\nA ReplicationController has three essential parts (also shown in figure 4.3):\n\uf0a1A label selector, which determines what pods are in the ReplicationController\u2019s scope\n\uf0a1A replica count, which specifies the desired number of pods that should be running\n\uf0a1A pod template, which is used when creating new pod replicas\nStart\nCompare\nmatched vs.\ndesired pod\ncount\nFind pods\nmatching the\nlabel selector\nCreate additional\npod(s) from\ncurrent template\nDelete the\nexcess pod(s)\nToo many\nJust enough\nToo few\nFigure 4.2\nA ReplicationController\u2019s reconciliation loop\napp: kubia\nPod\nPod template\nReplicationController: kubia\nPod selector:\napp=kubia\nReplicas: 3\nFigure 4.3\nThe three key parts of a \nReplicationController (pod selector, \nreplica count, and pod template)\n \n", "shape": "dot", "size": 10, "title": "92\nCHAPTER 4\nReplication and other controllers: deploying managed pods\nI\u2019ve used the term pod \u201ctype\u201d a few times. But no such thing exists. Replication-\nControllers don\u2019t operate on pod types, but on sets of pods that match a certain label\nselector (you learned about them in the previous chapter). \nINTRODUCING THE CONTROLLER\u2019S RECONCILIATION LOOP\nA ReplicationController\u2019s job is to make sure that an exact number of pods always\nmatches its label selector. If it doesn\u2019t, the ReplicationController takes the appropriate\naction to reconcile the actual with the desired number. The operation of a Replication-\nController is shown in figure 4.2.\nUNDERSTANDING THE THREE PARTS OF A REPLICATIONCONTROLLER\nA ReplicationController has three essential parts (also shown in figure 4.3):\n\uf0a1A label selector, which determines what pods are in the ReplicationController\u2019s scope\n\uf0a1A replica count, which specifies the desired number of pods that should be running\n\uf0a1A pod template, which is used when creating new pod replicas\nStart\nCompare\nmatched vs.\ndesired pod\ncount\nFind pods\nmatching the\nlabel selector\nCreate additional\npod(s) from\ncurrent template\nDelete the\nexcess pod(s)\nToo many\nJust enough\nToo few\nFigure 4.2\nA ReplicationController\u2019s reconciliation loop\napp: kubia\nPod\nPod template\nReplicationController: kubia\nPod selector:\napp=kubia\nReplicas: 3\nFigure 4.3\nThe three key parts of a \nReplicationController (pod selector, \nreplica count, and pod template)\n \n"}, {"color": "green", "id": "text_36", "label": "93\nIntroducing ReplicationControllers\nA ReplicationController\u2019s replica count, the label selector, and even the pod tem-\nplate can all be modified at any time, but only changes to the replica count affect\nexisting pods. \nUNDERSTANDING THE EFFECT OF CHANGING THE CONTROLLER\u2019S LABEL SELECTOR OR POD TEMPLATE\nChanges to the label selector and the pod template have no effect on existing pods.\nChanging the label selector makes the existing pods fall out of the scope of the\nReplicationController, so the controller stops caring about them. ReplicationCon-\ntrollers also don\u2019t care about the actual \u201ccontents\u201d of its pods (the container images,\nenvironment variables, and other things) after they create the pod. The template\ntherefore only affects new pods created by this ReplicationController. You can think\nof it as a cookie cutter for cutting out new pods.\nUNDERSTANDING THE BENEFITS OF USING A REPLICATIONCONTROLLER\nLike many things in Kubernetes, a ReplicationController, although an incredibly sim-\nple concept, provides or enables the following powerful features:\n\uf0a1It makes sure a pod (or multiple pod replicas) is always running by starting a\nnew pod when an existing one goes missing.\n\uf0a1When a cluster node fails, it creates replacement replicas for all the pods that\nwere running on the failed node (those that were under the Replication-\nController\u2019s control).\n\uf0a1It enables easy horizontal scaling of pods\u2014both manual and automatic (see\nhorizontal pod auto-scaling in chapter 15).\nNOTE\nA pod instance is never relocated to another node. Instead, the\nReplicationController creates a completely new pod instance that has no rela-\ntion to the instance it\u2019s replacing. \n4.2.2\nCreating a ReplicationController\nLet\u2019s look at how to create a ReplicationController and then see how it keeps your\npods running. Like pods and other Kubernetes resources, you create a Replication-\nController by posting a JSON or YAML descriptor to the Kubernetes API server.\n You\u2019re going to create a YAML file called kubia-rc.yaml for your Replication-\nController, as shown in the following listing.\napiVersion: v1\nkind: ReplicationController     \nmetadata:\n  name: kubia                      \nspec:\n  replicas: 3                     \n  selector:              \n    app: kubia           \nListing 4.4\nA YAML definition of a ReplicationController: kubia-rc.yaml\nThis manifest defines a \nReplicationController (RC)\nThe name of this \nReplicationController\nThe desired number \nof pod instances\nThe pod selector determining \nwhat pods the RC is operating on\n \n", "shape": "dot", "size": 10, "title": "93\nIntroducing ReplicationControllers\nA ReplicationController\u2019s replica count, the label selector, and even the pod tem-\nplate can all be modified at any time, but only changes to the replica count affect\nexisting pods. \nUNDERSTANDING THE EFFECT OF CHANGING THE CONTROLLER\u2019S LABEL SELECTOR OR POD TEMPLATE\nChanges to the label selector and the pod template have no effect on existing pods.\nChanging the label selector makes the existing pods fall out of the scope of the\nReplicationController, so the controller stops caring about them. ReplicationCon-\ntrollers also don\u2019t care about the actual \u201ccontents\u201d of its pods (the container images,\nenvironment variables, and other things) after they create the pod. The template\ntherefore only affects new pods created by this ReplicationController. You can think\nof it as a cookie cutter for cutting out new pods.\nUNDERSTANDING THE BENEFITS OF USING A REPLICATIONCONTROLLER\nLike many things in Kubernetes, a ReplicationController, although an incredibly sim-\nple concept, provides or enables the following powerful features:\n\uf0a1It makes sure a pod (or multiple pod replicas) is always running by starting a\nnew pod when an existing one goes missing.\n\uf0a1When a cluster node fails, it creates replacement replicas for all the pods that\nwere running on the failed node (those that were under the Replication-\nController\u2019s control).\n\uf0a1It enables easy horizontal scaling of pods\u2014both manual and automatic (see\nhorizontal pod auto-scaling in chapter 15).\nNOTE\nA pod instance is never relocated to another node. Instead, the\nReplicationController creates a completely new pod instance that has no rela-\ntion to the instance it\u2019s replacing. \n4.2.2\nCreating a ReplicationController\nLet\u2019s look at how to create a ReplicationController and then see how it keeps your\npods running. Like pods and other Kubernetes resources, you create a Replication-\nController by posting a JSON or YAML descriptor to the Kubernetes API server.\n You\u2019re going to create a YAML file called kubia-rc.yaml for your Replication-\nController, as shown in the following listing.\napiVersion: v1\nkind: ReplicationController     \nmetadata:\n  name: kubia                      \nspec:\n  replicas: 3                     \n  selector:              \n    app: kubia           \nListing 4.4\nA YAML definition of a ReplicationController: kubia-rc.yaml\nThis manifest defines a \nReplicationController (RC)\nThe name of this \nReplicationController\nThe desired number \nof pod instances\nThe pod selector determining \nwhat pods the RC is operating on\n \n"}, {"color": "green", "id": "text_37", "label": "94\nCHAPTER 4\nReplication and other controllers: deploying managed pods\n  template:                        \n    metadata:                      \n      labels:                      \n        app: kubia                 \n    spec:                          \n      containers:                  \n      - name: kubia                \n        image: luksa/kubia         \n        ports:                     \n        - containerPort: 8080      \nWhen you post the file to the API server, Kubernetes creates a new Replication-\nController named kubia, which makes sure three pod instances always match the\nlabel selector app=kubia. When there aren\u2019t enough pods, new pods will be created\nfrom the provided pod template. The contents of the template are almost identical to\nthe pod definition you created in the previous chapter. \n The pod labels in the template must obviously match the label selector of the\nReplicationController; otherwise the controller would create new pods indefinitely,\nbecause spinning up a new pod wouldn\u2019t bring the actual replica count any closer to\nthe desired number of replicas. To prevent such scenarios, the API server verifies the\nReplicationController definition and will not accept it if it\u2019s misconfigured.\n Not specifying the selector at all is also an option. In that case, it will be configured\nautomatically from the labels in the pod template. \nTIP\nDon\u2019t specify a pod selector when defining a ReplicationController. Let\nKubernetes extract it from the pod template. This will keep your YAML\nshorter and simpler.\nTo create the ReplicationController, use the kubectl create command, which you\nalready know:\n$ kubectl create -f kubia-rc.yaml\nreplicationcontroller \"kubia\" created\nAs soon as the ReplicationController is created, it goes to work. Let\u2019s see what\nit does.\n4.2.3\nSeeing the ReplicationController in action\nBecause no pods exist with the app=kubia label, the ReplicationController should\nspin up three new pods from the pod template. List the pods to see if the Replication-\nController has done what it\u2019s supposed to:\n$ kubectl get pods\nNAME          READY     STATUS              RESTARTS   AGE\nkubia-53thy   0/1       ContainerCreating   0          2s\nkubia-k0xz6   0/1       ContainerCreating   0          2s\nkubia-q3vkg   0/1       ContainerCreating   0          2s\nThe pod template \nfor creating new \npods\n \n", "shape": "dot", "size": 10, "title": "94\nCHAPTER 4\nReplication and other controllers: deploying managed pods\n  template:                        \n    metadata:                      \n      labels:                      \n        app: kubia                 \n    spec:                          \n      containers:                  \n      - name: kubia                \n        image: luksa/kubia         \n        ports:                     \n        - containerPort: 8080      \nWhen you post the file to the API server, Kubernetes creates a new Replication-\nController named kubia, which makes sure three pod instances always match the\nlabel selector app=kubia. When there aren\u2019t enough pods, new pods will be created\nfrom the provided pod template. The contents of the template are almost identical to\nthe pod definition you created in the previous chapter. \n The pod labels in the template must obviously match the label selector of the\nReplicationController; otherwise the controller would create new pods indefinitely,\nbecause spinning up a new pod wouldn\u2019t bring the actual replica count any closer to\nthe desired number of replicas. To prevent such scenarios, the API server verifies the\nReplicationController definition and will not accept it if it\u2019s misconfigured.\n Not specifying the selector at all is also an option. In that case, it will be configured\nautomatically from the labels in the pod template. \nTIP\nDon\u2019t specify a pod selector when defining a ReplicationController. Let\nKubernetes extract it from the pod template. This will keep your YAML\nshorter and simpler.\nTo create the ReplicationController, use the kubectl create command, which you\nalready know:\n$ kubectl create -f kubia-rc.yaml\nreplicationcontroller \"kubia\" created\nAs soon as the ReplicationController is created, it goes to work. Let\u2019s see what\nit does.\n4.2.3\nSeeing the ReplicationController in action\nBecause no pods exist with the app=kubia label, the ReplicationController should\nspin up three new pods from the pod template. List the pods to see if the Replication-\nController has done what it\u2019s supposed to:\n$ kubectl get pods\nNAME          READY     STATUS              RESTARTS   AGE\nkubia-53thy   0/1       ContainerCreating   0          2s\nkubia-k0xz6   0/1       ContainerCreating   0          2s\nkubia-q3vkg   0/1       ContainerCreating   0          2s\nThe pod template \nfor creating new \npods\n \n"}, {"color": "green", "id": "text_38", "label": "95\nIntroducing ReplicationControllers\nIndeed, it has! You wanted three pods, and it created three pods. It\u2019s now managing\nthose three pods. Next you\u2019ll mess with them a little to see how the Replication-\nController responds. \nSEEING THE REPLICATIONCONTROLLER RESPOND TO A DELETED POD\nFirst, you\u2019ll delete one of the pods manually to see how the ReplicationController spins\nup a new one immediately, bringing the number of matching pods back to three:\n$ kubectl delete pod kubia-53thy\npod \"kubia-53thy\" deleted\nListing the pods again shows four of them, because the one you deleted is terminat-\ning, and a new pod has already been created:\n$ kubectl get pods\nNAME          READY     STATUS              RESTARTS   AGE\nkubia-53thy   1/1       Terminating         0          3m\nkubia-oini2   0/1       ContainerCreating   0          2s\nkubia-k0xz6   1/1       Running             0          3m\nkubia-q3vkg   1/1       Running             0          3m\nThe ReplicationController has done its job again. It\u2019s a nice little helper, isn\u2019t it?\nGETTING INFORMATION ABOUT A REPLICATIONCONTROLLER\nNow, let\u2019s see what information the kubectl get command shows for Replication-\nControllers:\n$ kubectl get rc\nNAME      DESIRED   CURRENT   READY     AGE\nkubia     3         3         2         3m\nNOTE\nWe\u2019re using rc as a shorthand for replicationcontroller.\nYou see three columns showing the desired number of pods, the actual number of\npods, and how many of them are ready (you\u2019ll learn what that means in the next chap-\nter, when we talk about readiness probes).\n You can see additional information about your ReplicationController with the\nkubectl describe command, as shown in the following listing.\n$ kubectl describe rc kubia\nName:           kubia\nNamespace:      default\nSelector:       app=kubia\nLabels:         app=kubia\nAnnotations:    \u003cnone\u003e\nReplicas:       3 current / 3 desired               \nPods Status:    4 Running / 0 Waiting / 0 Succeeded / 0 Failed  \nPod Template:\n  Labels:       app=kubia\n  Containers:   ...\nListing 4.5\nDisplaying details of a ReplicationController with kubectl describe\nThe actual vs. the \ndesired number of \npod instances\nNumber of \npod instances \nper pod \nstatus\n \n", "shape": "dot", "size": 10, "title": "95\nIntroducing ReplicationControllers\nIndeed, it has! You wanted three pods, and it created three pods. It\u2019s now managing\nthose three pods. Next you\u2019ll mess with them a little to see how the Replication-\nController responds. \nSEEING THE REPLICATIONCONTROLLER RESPOND TO A DELETED POD\nFirst, you\u2019ll delete one of the pods manually to see how the ReplicationController spins\nup a new one immediately, bringing the number of matching pods back to three:\n$ kubectl delete pod kubia-53thy\npod \"kubia-53thy\" deleted\nListing the pods again shows four of them, because the one you deleted is terminat-\ning, and a new pod has already been created:\n$ kubectl get pods\nNAME          READY     STATUS              RESTARTS   AGE\nkubia-53thy   1/1       Terminating         0          3m\nkubia-oini2   0/1       ContainerCreating   0          2s\nkubia-k0xz6   1/1       Running             0          3m\nkubia-q3vkg   1/1       Running             0          3m\nThe ReplicationController has done its job again. It\u2019s a nice little helper, isn\u2019t it?\nGETTING INFORMATION ABOUT A REPLICATIONCONTROLLER\nNow, let\u2019s see what information the kubectl get command shows for Replication-\nControllers:\n$ kubectl get rc\nNAME      DESIRED   CURRENT   READY     AGE\nkubia     3         3         2         3m\nNOTE\nWe\u2019re using rc as a shorthand for replicationcontroller.\nYou see three columns showing the desired number of pods, the actual number of\npods, and how many of them are ready (you\u2019ll learn what that means in the next chap-\nter, when we talk about readiness probes).\n You can see additional information about your ReplicationController with the\nkubectl describe command, as shown in the following listing.\n$ kubectl describe rc kubia\nName:           kubia\nNamespace:      default\nSelector:       app=kubia\nLabels:         app=kubia\nAnnotations:    \u003cnone\u003e\nReplicas:       3 current / 3 desired               \nPods Status:    4 Running / 0 Waiting / 0 Succeeded / 0 Failed  \nPod Template:\n  Labels:       app=kubia\n  Containers:   ...\nListing 4.5\nDisplaying details of a ReplicationController with kubectl describe\nThe actual vs. the \ndesired number of \npod instances\nNumber of \npod instances \nper pod \nstatus\n \n"}, {"color": "green", "id": "text_39", "label": "96\nCHAPTER 4\nReplication and other controllers: deploying managed pods\n  Volumes:      \u003cnone\u003e\nEvents:                                                   \nFrom                    Type      Reason           Message\n----                    -------  ------            -------\nreplication-controller  Normal   SuccessfulCreate  Created pod: kubia-53thy\nreplication-controller  Normal   SuccessfulCreate  Created pod: kubia-k0xz6\nreplication-controller  Normal   SuccessfulCreate  Created pod: kubia-q3vkg\nreplication-controller  Normal   SuccessfulCreate  Created pod: kubia-oini2\nThe current number of replicas matches the desired number, because the controller\nhas already created a new pod. It shows four running pods because a pod that\u2019s termi-\nnating is still considered running, although it isn\u2019t counted in the current replica count. \n The list of events at the bottom shows the actions taken by the Replication-\nController\u2014it has created four pods so far.\nUNDERSTANDING EXACTLY WHAT CAUSED THE CONTROLLER TO CREATE A NEW POD\nThe controller is responding to the deletion of a pod by creating a new replacement\npod (see figure 4.4). Well, technically, it isn\u2019t responding to the deletion itself, but the\nresulting state\u2014the inadequate number of pods.\n While a ReplicationController is immediately notified about a pod being deleted\n(the API server allows clients to watch for changes to resources and resource lists), that\u2019s\nnot what causes it to create a replacement pod. The notification triggers the controller\nto check the actual number of pods and take appropriate action.\nThe events \nrelated to this \nReplicationController\nBefore deletion\nAfter deletion\nReplicationController: kubia\nReplicas: 3\nSelector: app=kubia\napp: kubia\nPod:\nkubia-q3vkg\napp: kubia\nPod:\nkubia-oini2\n[ContainerCreating]\n[Terminating]\napp: kubia\nPod:\nkubia-k0xz6\napp: kubia\nPod:\nkubia-53thy\nReplicationController: kubia\nReplicas: 3\nSelector: app=kubia\napp: kubia\nPod:\nkubia-q3vkg\napp: kubia\nPod:\nkubia-k0xz6\napp: kubia\nPod:\nkubia-53thy\nDelete kubia-53thy\nFigure 4.4\nIf a pod disappears, the ReplicationController sees too few pods and creates a new replacement pod.\n \n", "shape": "dot", "size": 10, "title": "96\nCHAPTER 4\nReplication and other controllers: deploying managed pods\n  Volumes:      \u003cnone\u003e\nEvents:                                                   \nFrom                    Type      Reason           Message\n----                    -------  ------            -------\nreplication-controller  Normal   SuccessfulCreate  Created pod: kubia-53thy\nreplication-controller  Normal   SuccessfulCreate  Created pod: kubia-k0xz6\nreplication-controller  Normal   SuccessfulCreate  Created pod: kubia-q3vkg\nreplication-controller  Normal   SuccessfulCreate  Created pod: kubia-oini2\nThe current number of replicas matches the desired number, because the controller\nhas already created a new pod. It shows four running pods because a pod that\u2019s termi-\nnating is still considered running, although it isn\u2019t counted in the current replica count. \n The list of events at the bottom shows the actions taken by the Replication-\nController\u2014it has created four pods so far.\nUNDERSTANDING EXACTLY WHAT CAUSED THE CONTROLLER TO CREATE A NEW POD\nThe controller is responding to the deletion of a pod by creating a new replacement\npod (see figure 4.4). Well, technically, it isn\u2019t responding to the deletion itself, but the\nresulting state\u2014the inadequate number of pods.\n While a ReplicationController is immediately notified about a pod being deleted\n(the API server allows clients to watch for changes to resources and resource lists), that\u2019s\nnot what causes it to create a replacement pod. The notification triggers the controller\nto check the actual number of pods and take appropriate action.\nThe events \nrelated to this \nReplicationController\nBefore deletion\nAfter deletion\nReplicationController: kubia\nReplicas: 3\nSelector: app=kubia\napp: kubia\nPod:\nkubia-q3vkg\napp: kubia\nPod:\nkubia-oini2\n[ContainerCreating]\n[Terminating]\napp: kubia\nPod:\nkubia-k0xz6\napp: kubia\nPod:\nkubia-53thy\nReplicationController: kubia\nReplicas: 3\nSelector: app=kubia\napp: kubia\nPod:\nkubia-q3vkg\napp: kubia\nPod:\nkubia-k0xz6\napp: kubia\nPod:\nkubia-53thy\nDelete kubia-53thy\nFigure 4.4\nIf a pod disappears, the ReplicationController sees too few pods and creates a new replacement pod.\n \n"}, {"color": "green", "id": "text_40", "label": "97\nIntroducing ReplicationControllers\nRESPONDING TO A NODE FAILURE\nSeeing the ReplicationController respond to the manual deletion of a pod isn\u2019t too\ninteresting, so let\u2019s look at a better example. If you\u2019re using Google Kubernetes Engine\nto run these examples, you have a three-node Kubernetes cluster. You\u2019re going to dis-\nconnect one of the nodes from the network to simulate a node failure.\nNOTE\nIf you\u2019re using Minikube, you can\u2019t do this exercise, because you only\nhave one node that acts both as a master and a worker node.\nIf a node fails in the non-Kubernetes world, the ops team would need to migrate the\napplications running on that node to other machines manually. Kubernetes, on the\nother hand, does that automatically. Soon after the ReplicationController detects that\nits pods are down, it will spin up new pods to replace them. \n Let\u2019s see this in action. You need to ssh into one of the nodes with the gcloud\ncompute ssh command and then shut down its network interface with sudo ifconfig\neth0 down, as shown in the following listing.\nNOTE\nChoose a node that runs at least one of your pods by listing pods with\nthe -o wide option.\n$ gcloud compute ssh gke-kubia-default-pool-b46381f1-zwko\nEnter passphrase for key \u0027/home/luksa/.ssh/google_compute_engine\u0027:\nWelcome to Kubernetes v1.6.4!\n...\nluksa@gke-kubia-default-pool-b46381f1-zwko ~ $ sudo ifconfig eth0 down\nWhen you shut down the network interface, the ssh session will stop responding, so\nyou need to open up another terminal or hard-exit from the ssh session. In the new\nterminal you can list the nodes to see if Kubernetes has detected that the node is\ndown. This takes a minute or so. Then, the node\u2019s status is shown as NotReady:\n$ kubectl get node\nNAME                                   STATUS     AGE\ngke-kubia-default-pool-b46381f1-opc5   Ready      5h\ngke-kubia-default-pool-b46381f1-s8gj   Ready      5h\ngke-kubia-default-pool-b46381f1-zwko   NotReady   5h    \nIf you list the pods now, you\u2019ll still see the same three pods as before, because Kuber-\nnetes waits a while before rescheduling pods (in case the node is unreachable because\nof a temporary network glitch or because the Kubelet is restarting). If the node stays\nunreachable for several minutes, the status of the pods that were scheduled to that\nnode changes to Unknown. At that point, the ReplicationController will immediately\nspin up a new pod. You can see this by listing the pods again:\nListing 4.6\nSimulating a node failure by shutting down its network interface\nNode isn\u2019t ready, \nbecause it\u2019s \ndisconnected from \nthe network\n \n", "shape": "dot", "size": 10, "title": "97\nIntroducing ReplicationControllers\nRESPONDING TO A NODE FAILURE\nSeeing the ReplicationController respond to the manual deletion of a pod isn\u2019t too\ninteresting, so let\u2019s look at a better example. If you\u2019re using Google Kubernetes Engine\nto run these examples, you have a three-node Kubernetes cluster. You\u2019re going to dis-\nconnect one of the nodes from the network to simulate a node failure.\nNOTE\nIf you\u2019re using Minikube, you can\u2019t do this exercise, because you only\nhave one node that acts both as a master and a worker node.\nIf a node fails in the non-Kubernetes world, the ops team would need to migrate the\napplications running on that node to other machines manually. Kubernetes, on the\nother hand, does that automatically. Soon after the ReplicationController detects that\nits pods are down, it will spin up new pods to replace them. \n Let\u2019s see this in action. You need to ssh into one of the nodes with the gcloud\ncompute ssh command and then shut down its network interface with sudo ifconfig\neth0 down, as shown in the following listing.\nNOTE\nChoose a node that runs at least one of your pods by listing pods with\nthe -o wide option.\n$ gcloud compute ssh gke-kubia-default-pool-b46381f1-zwko\nEnter passphrase for key \u0027/home/luksa/.ssh/google_compute_engine\u0027:\nWelcome to Kubernetes v1.6.4!\n...\nluksa@gke-kubia-default-pool-b46381f1-zwko ~ $ sudo ifconfig eth0 down\nWhen you shut down the network interface, the ssh session will stop responding, so\nyou need to open up another terminal or hard-exit from the ssh session. In the new\nterminal you can list the nodes to see if Kubernetes has detected that the node is\ndown. This takes a minute or so. Then, the node\u2019s status is shown as NotReady:\n$ kubectl get node\nNAME                                   STATUS     AGE\ngke-kubia-default-pool-b46381f1-opc5   Ready      5h\ngke-kubia-default-pool-b46381f1-s8gj   Ready      5h\ngke-kubia-default-pool-b46381f1-zwko   NotReady   5h    \nIf you list the pods now, you\u2019ll still see the same three pods as before, because Kuber-\nnetes waits a while before rescheduling pods (in case the node is unreachable because\nof a temporary network glitch or because the Kubelet is restarting). If the node stays\nunreachable for several minutes, the status of the pods that were scheduled to that\nnode changes to Unknown. At that point, the ReplicationController will immediately\nspin up a new pod. You can see this by listing the pods again:\nListing 4.6\nSimulating a node failure by shutting down its network interface\nNode isn\u2019t ready, \nbecause it\u2019s \ndisconnected from \nthe network\n \n"}, {"color": "green", "id": "text_41", "label": "98\nCHAPTER 4\nReplication and other controllers: deploying managed pods\n$ kubectl get pods\nNAME          READY   STATUS    RESTARTS   AGE\nkubia-oini2   1/1     Running   0          10m\nkubia-k0xz6   1/1     Running   0          10m\nkubia-q3vkg   1/1     Unknown   0          10m    \nkubia-dmdck   1/1     Running   0          5s    \nLooking at the age of the pods, you see that the kubia-dmdck pod is new. You again\nhave three pod instances running, which means the ReplicationController has again\ndone its job of bringing the actual state of the system to the desired state. \n The same thing happens if a node fails (either breaks down or becomes unreach-\nable). No immediate human intervention is necessary. The system heals itself\nautomatically. \n To bring the node back, you need to reset it with the following command:\n$ gcloud compute instances reset gke-kubia-default-pool-b46381f1-zwko\nWhen the node boots up again, its status should return to Ready, and the pod whose\nstatus was Unknown will be deleted.\n4.2.4\nMoving pods in and out of the scope of a ReplicationController\nPods created by a ReplicationController aren\u2019t tied to the ReplicationController in\nany way. At any moment, a ReplicationController manages pods that match its label\nselector. By changing a pod\u2019s labels, it can be removed from or added to the scope\nof a ReplicationController. It can even be moved from one ReplicationController to\nanother.\nTIP\nAlthough a pod isn\u2019t tied to a ReplicationController, the pod does refer-\nence it in the metadata.ownerReferences field, which you can use to easily\nfind which ReplicationController a pod belongs to.\nIf you change a pod\u2019s labels so they no longer match a ReplicationController\u2019s label\nselector, the pod becomes like any other manually created pod. It\u2019s no longer man-\naged by anything. If the node running the pod fails, the pod is obviously not resched-\nuled. But keep in mind that when you changed the pod\u2019s labels, the replication\ncontroller noticed one pod was missing and spun up a new pod to replace it.\n Let\u2019s try this with your pods. Because your ReplicationController manages pods\nthat have the app=kubia label, you need to either remove this label or change its value\nto move the pod out of the ReplicationController\u2019s scope. Adding another label will\nhave no effect, because the ReplicationController doesn\u2019t care if the pod has any addi-\ntional labels. It only cares whether the pod has all the labels referenced in the label\nselector. \nThis pod\u2019s status is \nunknown, because its \nnode is unreachable.\nThis pod was created \nfive seconds ago.\n \n", "shape": "dot", "size": 10, "title": "98\nCHAPTER 4\nReplication and other controllers: deploying managed pods\n$ kubectl get pods\nNAME          READY   STATUS    RESTARTS   AGE\nkubia-oini2   1/1     Running   0          10m\nkubia-k0xz6   1/1     Running   0          10m\nkubia-q3vkg   1/1     Unknown   0          10m    \nkubia-dmdck   1/1     Running   0          5s    \nLooking at the age of the pods, you see that the kubia-dmdck pod is new. You again\nhave three pod instances running, which means the ReplicationController has again\ndone its job of bringing the actual state of the system to the desired state. \n The same thing happens if a node fails (either breaks down or becomes unreach-\nable). No immediate human intervention is necessary. The system heals itself\nautomatically. \n To bring the node back, you need to reset it with the following command:\n$ gcloud compute instances reset gke-kubia-default-pool-b46381f1-zwko\nWhen the node boots up again, its status should return to Ready, and the pod whose\nstatus was Unknown will be deleted.\n4.2.4\nMoving pods in and out of the scope of a ReplicationController\nPods created by a ReplicationController aren\u2019t tied to the ReplicationController in\nany way. At any moment, a ReplicationController manages pods that match its label\nselector. By changing a pod\u2019s labels, it can be removed from or added to the scope\nof a ReplicationController. It can even be moved from one ReplicationController to\nanother.\nTIP\nAlthough a pod isn\u2019t tied to a ReplicationController, the pod does refer-\nence it in the metadata.ownerReferences field, which you can use to easily\nfind which ReplicationController a pod belongs to.\nIf you change a pod\u2019s labels so they no longer match a ReplicationController\u2019s label\nselector, the pod becomes like any other manually created pod. It\u2019s no longer man-\naged by anything. If the node running the pod fails, the pod is obviously not resched-\nuled. But keep in mind that when you changed the pod\u2019s labels, the replication\ncontroller noticed one pod was missing and spun up a new pod to replace it.\n Let\u2019s try this with your pods. Because your ReplicationController manages pods\nthat have the app=kubia label, you need to either remove this label or change its value\nto move the pod out of the ReplicationController\u2019s scope. Adding another label will\nhave no effect, because the ReplicationController doesn\u2019t care if the pod has any addi-\ntional labels. It only cares whether the pod has all the labels referenced in the label\nselector. \nThis pod\u2019s status is \nunknown, because its \nnode is unreachable.\nThis pod was created \nfive seconds ago.\n \n"}, {"color": "green", "id": "text_42", "label": "99\nIntroducing ReplicationControllers\nADDING LABELS TO PODS MANAGED BY A REPLICATIONCONTROLLER\nLet\u2019s confirm that a ReplicationController doesn\u2019t care if you add additional labels to\nits managed pods:\n$ kubectl label pod kubia-dmdck type=special\npod \"kubia-dmdck\" labeled\n$ kubectl get pods --show-labels\nNAME          READY   STATUS    RESTARTS   AGE   LABELS\nkubia-oini2   1/1     Running   0          11m   app=kubia\nkubia-k0xz6   1/1     Running   0          11m   app=kubia\nkubia-dmdck   1/1     Running   0          1m    app=kubia,type=special\nYou\u2019ve added the type=special label to one of the pods. Listing all pods again shows\nthe same three pods as before, because no change occurred as far as the Replication-\nController is concerned.\nCHANGING THE LABELS OF A MANAGED POD\nNow, you\u2019ll change the app=kubia label to something else. This will make the pod no\nlonger match the ReplicationController\u2019s label selector, leaving it to only match two\npods. The ReplicationController should therefore start a new pod to bring the num-\nber back to three:\n$ kubectl label pod kubia-dmdck app=foo --overwrite\npod \"kubia-dmdck\" labeled\nThe --overwrite argument is necessary; otherwise kubectl will only print out a warn-\ning and won\u2019t change the label, to prevent you from inadvertently changing an exist-\ning label\u2019s value when your intent is to add a new one. \n Listing all the pods again should now show four pods: \n$ kubectl get pods -L app\nNAME         READY  STATUS             RESTARTS  AGE  APP\nkubia-2qneh  0/1    ContainerCreating  0         2s   kubia   \nkubia-oini2  1/1    Running            0         20m  kubia\nkubia-k0xz6  1/1    Running            0         20m  kubia\nkubia-dmdck  1/1    Running            0         10m  foo    \nNOTE\nYou\u2019re using the -L app option to display the app label in a column.\nThere, you now have four pods altogether: one that isn\u2019t managed by your Replication-\nController and three that are. Among them is the newly created pod.\n Figure 4.5 illustrates what happened when you changed the pod\u2019s labels so they no\nlonger matched the ReplicationController\u2019s pod selector. You can see your three pods\nand your ReplicationController. After you change the pod\u2019s label from app=kubia to\napp=foo, the ReplicationController no longer cares about the pod. Because the con-\ntroller\u2019s replica count is set to 3 and only two pods match the label selector, the\nNewly created pod that replaces\nthe pod you removed from the\nscope of the ReplicationController\nPod no longer \nmanaged by the \nReplicationController\n \n", "shape": "dot", "size": 10, "title": "99\nIntroducing ReplicationControllers\nADDING LABELS TO PODS MANAGED BY A REPLICATIONCONTROLLER\nLet\u2019s confirm that a ReplicationController doesn\u2019t care if you add additional labels to\nits managed pods:\n$ kubectl label pod kubia-dmdck type=special\npod \"kubia-dmdck\" labeled\n$ kubectl get pods --show-labels\nNAME          READY   STATUS    RESTARTS   AGE   LABELS\nkubia-oini2   1/1     Running   0          11m   app=kubia\nkubia-k0xz6   1/1     Running   0          11m   app=kubia\nkubia-dmdck   1/1     Running   0          1m    app=kubia,type=special\nYou\u2019ve added the type=special label to one of the pods. Listing all pods again shows\nthe same three pods as before, because no change occurred as far as the Replication-\nController is concerned.\nCHANGING THE LABELS OF A MANAGED POD\nNow, you\u2019ll change the app=kubia label to something else. This will make the pod no\nlonger match the ReplicationController\u2019s label selector, leaving it to only match two\npods. The ReplicationController should therefore start a new pod to bring the num-\nber back to three:\n$ kubectl label pod kubia-dmdck app=foo --overwrite\npod \"kubia-dmdck\" labeled\nThe --overwrite argument is necessary; otherwise kubectl will only print out a warn-\ning and won\u2019t change the label, to prevent you from inadvertently changing an exist-\ning label\u2019s value when your intent is to add a new one. \n Listing all the pods again should now show four pods: \n$ kubectl get pods -L app\nNAME         READY  STATUS             RESTARTS  AGE  APP\nkubia-2qneh  0/1    ContainerCreating  0         2s   kubia   \nkubia-oini2  1/1    Running            0         20m  kubia\nkubia-k0xz6  1/1    Running            0         20m  kubia\nkubia-dmdck  1/1    Running            0         10m  foo    \nNOTE\nYou\u2019re using the -L app option to display the app label in a column.\nThere, you now have four pods altogether: one that isn\u2019t managed by your Replication-\nController and three that are. Among them is the newly created pod.\n Figure 4.5 illustrates what happened when you changed the pod\u2019s labels so they no\nlonger matched the ReplicationController\u2019s pod selector. You can see your three pods\nand your ReplicationController. After you change the pod\u2019s label from app=kubia to\napp=foo, the ReplicationController no longer cares about the pod. Because the con-\ntroller\u2019s replica count is set to 3 and only two pods match the label selector, the\nNewly created pod that replaces\nthe pod you removed from the\nscope of the ReplicationController\nPod no longer \nmanaged by the \nReplicationController\n \n"}, {"color": "green", "id": "text_43", "label": "100\nCHAPTER 4\nReplication and other controllers: deploying managed pods\nReplicationController spins up pod kubia-2qneh to bring the number back up to\nthree. Pod kubia-dmdck is now completely independent and will keep running until\nyou delete it manually (you can do that now, because you don\u2019t need it anymore).\nREMOVING PODS FROM CONTROLLERS IN PRACTICE\nRemoving a pod from the scope of the ReplicationController comes in handy when\nyou want to perform actions on a specific pod. For example, you might have a bug\nthat causes your pod to start behaving badly after a specific amount of time or a spe-\ncific event. If you know a pod is malfunctioning, you can take it out of the Replication-\nController\u2019s scope, let the controller replace it with a new one, and then debug or\nplay with the pod in any way you want. Once you\u2019re done, you delete the pod. \nCHANGING THE REPLICATIONCONTROLLER\u2019S LABEL SELECTOR\nAs an exercise to see if you fully understand ReplicationControllers, what do you\nthink would happen if instead of changing the labels of a pod, you modified the\nReplicationController\u2019s label selector? \n If your answer is that it would make all the pods fall out of the scope of the\nReplicationController, which would result in it creating three new pods, you\u2019re abso-\nlutely right. And it shows that you understand how ReplicationControllers work. \n Kubernetes does allow you to change a ReplicationController\u2019s label selector, but\nthat\u2019s not the case for the other resources that are covered in the second half of this\nInitial state\nAfter re-labelling\nRe-label kubia-dmdck\napp: kubia\nPod:\nkubia-oini2\napp: kubia\nPod:\nkubia-2qneh\n[ContainerCreating]\nPod:\nkubia-dmdck\napp: kubia\nPod:\nkubia-k0xz6\napp: kubia\ntype: special\ntype: special\napp: foo\napp: kubia\nPod:\nkubia-dmdck\napp: kubia\nPod:\nkubia-k0xz6\nReplicationController: kubia\nReplicas: 3\nSelector: app=kubia\nReplicationController: kubia\nReplicas: 3\nSelector: app=kubia\nPod:\nkubia-oini2\nFigure 4.5\nRemoving a pod from the scope of a ReplicationController by changing its labels \n \n", "shape": "dot", "size": 10, "title": "100\nCHAPTER 4\nReplication and other controllers: deploying managed pods\nReplicationController spins up pod kubia-2qneh to bring the number back up to\nthree. Pod kubia-dmdck is now completely independent and will keep running until\nyou delete it manually (you can do that now, because you don\u2019t need it anymore).\nREMOVING PODS FROM CONTROLLERS IN PRACTICE\nRemoving a pod from the scope of the ReplicationController comes in handy when\nyou want to perform actions on a specific pod. For example, you might have a bug\nthat causes your pod to start behaving badly after a specific amount of time or a spe-\ncific event. If you know a pod is malfunctioning, you can take it out of the Replication-\nController\u2019s scope, let the controller replace it with a new one, and then debug or\nplay with the pod in any way you want. Once you\u2019re done, you delete the pod. \nCHANGING THE REPLICATIONCONTROLLER\u2019S LABEL SELECTOR\nAs an exercise to see if you fully understand ReplicationControllers, what do you\nthink would happen if instead of changing the labels of a pod, you modified the\nReplicationController\u2019s label selector? \n If your answer is that it would make all the pods fall out of the scope of the\nReplicationController, which would result in it creating three new pods, you\u2019re abso-\nlutely right. And it shows that you understand how ReplicationControllers work. \n Kubernetes does allow you to change a ReplicationController\u2019s label selector, but\nthat\u2019s not the case for the other resources that are covered in the second half of this\nInitial state\nAfter re-labelling\nRe-label kubia-dmdck\napp: kubia\nPod:\nkubia-oini2\napp: kubia\nPod:\nkubia-2qneh\n[ContainerCreating]\nPod:\nkubia-dmdck\napp: kubia\nPod:\nkubia-k0xz6\napp: kubia\ntype: special\ntype: special\napp: foo\napp: kubia\nPod:\nkubia-dmdck\napp: kubia\nPod:\nkubia-k0xz6\nReplicationController: kubia\nReplicas: 3\nSelector: app=kubia\nReplicationController: kubia\nReplicas: 3\nSelector: app=kubia\nPod:\nkubia-oini2\nFigure 4.5\nRemoving a pod from the scope of a ReplicationController by changing its labels \n \n"}, {"color": "green", "id": "text_44", "label": "101\nIntroducing ReplicationControllers\nchapter and which are also used for managing pods. You\u2019ll never change a controller\u2019s\nlabel selector, but you\u2019ll regularly change its pod template. Let\u2019s take a look at that.\n4.2.5\nChanging the pod template\nA ReplicationController\u2019s pod template can be modified at any time. Changing the pod\ntemplate is like replacing a cookie cutter with another one. It will only affect the cookies\nyou cut out afterward and will have no effect on the ones you\u2019ve already cut (see figure\n4.6). To modify the old pods, you\u2019d need to delete them and let the Replication-\nController replace them with new ones based on the new template.\nAs an exercise, you can try editing the ReplicationController and adding a label to the\npod template. You can edit the ReplicationController with the following command:\n$ kubectl edit rc kubia\nThis will open the ReplicationController\u2019s YAML definition in your default text editor.\nFind the pod template section and add an additional label to the metadata. After you\nsave your changes and exit the editor, kubectl will update the ReplicationController\nand print the following message:\nreplicationcontroller \"kubia\" edited\nYou can now list pods and their labels again and confirm that they haven\u2019t changed.\nBut if you delete the pods and wait for their replacements to be created, you\u2019ll see the\nnew label.\n Editing a ReplicationController like this to change the container image in the pod\ntemplate, deleting the existing pods, and letting them be replaced with new ones from\nthe new template could be used for upgrading pods, but you\u2019ll learn a better way of\ndoing that in chapter 9. \nReplication\nController\nReplicas: 3\nTemplate:\nA\nB\nC\nReplication\nController\nReplicas: 3\nTemplate:\nA\nReplication\nController\nReplicas: 3\nTemplate:\nA\nReplication\nController\nReplicas: 3\nTemplate:\nD\nA\nB\nC\nA\nB\nC\nA\nB\nChange\ntemplate\nDelete\na pod\nRC creates\nnew pod\nFigure 4.6\nChanging a ReplicationController\u2019s pod template only affects pods created afterward and has no \neffect on existing pods.\n \n", "shape": "dot", "size": 10, "title": "101\nIntroducing ReplicationControllers\nchapter and which are also used for managing pods. You\u2019ll never change a controller\u2019s\nlabel selector, but you\u2019ll regularly change its pod template. Let\u2019s take a look at that.\n4.2.5\nChanging the pod template\nA ReplicationController\u2019s pod template can be modified at any time. Changing the pod\ntemplate is like replacing a cookie cutter with another one. It will only affect the cookies\nyou cut out afterward and will have no effect on the ones you\u2019ve already cut (see figure\n4.6). To modify the old pods, you\u2019d need to delete them and let the Replication-\nController replace them with new ones based on the new template.\nAs an exercise, you can try editing the ReplicationController and adding a label to the\npod template. You can edit the ReplicationController with the following command:\n$ kubectl edit rc kubia\nThis will open the ReplicationController\u2019s YAML definition in your default text editor.\nFind the pod template section and add an additional label to the metadata. After you\nsave your changes and exit the editor, kubectl will update the ReplicationController\nand print the following message:\nreplicationcontroller \"kubia\" edited\nYou can now list pods and their labels again and confirm that they haven\u2019t changed.\nBut if you delete the pods and wait for their replacements to be created, you\u2019ll see the\nnew label.\n Editing a ReplicationController like this to change the container image in the pod\ntemplate, deleting the existing pods, and letting them be replaced with new ones from\nthe new template could be used for upgrading pods, but you\u2019ll learn a better way of\ndoing that in chapter 9. \nReplication\nController\nReplicas: 3\nTemplate:\nA\nB\nC\nReplication\nController\nReplicas: 3\nTemplate:\nA\nReplication\nController\nReplicas: 3\nTemplate:\nA\nReplication\nController\nReplicas: 3\nTemplate:\nD\nA\nB\nC\nA\nB\nC\nA\nB\nChange\ntemplate\nDelete\na pod\nRC creates\nnew pod\nFigure 4.6\nChanging a ReplicationController\u2019s pod template only affects pods created afterward and has no \neffect on existing pods.\n \n"}, {"color": "green", "id": "text_45", "label": "102\nCHAPTER 4\nReplication and other controllers: deploying managed pods\n4.2.6\nHorizontally scaling pods\nYou\u2019ve seen how ReplicationControllers make sure a specific number of pod instances\nis always running. Because it\u2019s incredibly simple to change the desired number of rep-\nlicas, this also means scaling pods horizontally is trivial. \n Scaling the number of pods up or down is as easy as changing the value of the rep-\nlicas field in the ReplicationController resource. After the change, the Replication-\nController will either see too many pods exist (when scaling down) and delete part of\nthem, or see too few of them (when scaling up) and create additional pods. \nSCALING UP A REPLICATIONCONTROLLER\nYour ReplicationController has been keeping three instances of your pod running.\nYou\u2019re going to scale that number up to 10 now. As you may remember, you\u2019ve\nalready scaled a ReplicationController in chapter 2. You could use the same com-\nmand as before:\n$ kubectl scale rc kubia --replicas=10\nBut you\u2019ll do it differently this time. \nSCALING A REPLICATIONCONTROLLER BY EDITING ITS DEFINITION\nInstead of using the kubectl scale command, you\u2019re going to scale it in a declarative\nway by editing the ReplicationController\u2019s definition:\n$ kubectl edit rc kubia\nWhen the text editor opens, find the spec.replicas field and change its value to 10,\nas shown in the following listing.\n# Please edit the object below. Lines beginning with a \u0027#\u0027 will be ignored,\n# and an empty file will abort the edit. If an error occurs while saving \n# this file will be reopened with the relevant failures.\napiVersion: v1\nkind: ReplicationController\nConfiguring kubectl edit to use a different text editor\nYou can tell kubectl to use a text editor of your choice by setting the KUBE_EDITOR\nenvironment variable. For example, if you\u2019d like to use nano for editing Kubernetes\nresources, execute the following command (or put it into your ~/.bashrc or an\nequivalent file):\nexport KUBE_EDITOR=\"/usr/bin/nano\"\nIf the KUBE_EDITOR environment variable isn\u2019t set, kubectl edit falls back to using\nthe default editor, usually configured through the EDITOR environment variable.\nListing 4.7\nEditing the RC in a text editor by running kubectl edit\n \n", "shape": "dot", "size": 10, "title": "102\nCHAPTER 4\nReplication and other controllers: deploying managed pods\n4.2.6\nHorizontally scaling pods\nYou\u2019ve seen how ReplicationControllers make sure a specific number of pod instances\nis always running. Because it\u2019s incredibly simple to change the desired number of rep-\nlicas, this also means scaling pods horizontally is trivial. \n Scaling the number of pods up or down is as easy as changing the value of the rep-\nlicas field in the ReplicationController resource. After the change, the Replication-\nController will either see too many pods exist (when scaling down) and delete part of\nthem, or see too few of them (when scaling up) and create additional pods. \nSCALING UP A REPLICATIONCONTROLLER\nYour ReplicationController has been keeping three instances of your pod running.\nYou\u2019re going to scale that number up to 10 now. As you may remember, you\u2019ve\nalready scaled a ReplicationController in chapter 2. You could use the same com-\nmand as before:\n$ kubectl scale rc kubia --replicas=10\nBut you\u2019ll do it differently this time. \nSCALING A REPLICATIONCONTROLLER BY EDITING ITS DEFINITION\nInstead of using the kubectl scale command, you\u2019re going to scale it in a declarative\nway by editing the ReplicationController\u2019s definition:\n$ kubectl edit rc kubia\nWhen the text editor opens, find the spec.replicas field and change its value to 10,\nas shown in the following listing.\n# Please edit the object below. Lines beginning with a \u0027#\u0027 will be ignored,\n# and an empty file will abort the edit. If an error occurs while saving \n# this file will be reopened with the relevant failures.\napiVersion: v1\nkind: ReplicationController\nConfiguring kubectl edit to use a different text editor\nYou can tell kubectl to use a text editor of your choice by setting the KUBE_EDITOR\nenvironment variable. For example, if you\u2019d like to use nano for editing Kubernetes\nresources, execute the following command (or put it into your ~/.bashrc or an\nequivalent file):\nexport KUBE_EDITOR=\"/usr/bin/nano\"\nIf the KUBE_EDITOR environment variable isn\u2019t set, kubectl edit falls back to using\nthe default editor, usually configured through the EDITOR environment variable.\nListing 4.7\nEditing the RC in a text editor by running kubectl edit\n \n"}, {"color": "green", "id": "text_46", "label": "103\nIntroducing ReplicationControllers\nmetadata:\n  ...\nspec:\n  replicas: 3        \n  selector:\n    app: kubia\n  ...\nWhen you save the file and close the editor, the ReplicationController is updated and\nit immediately scales the number of pods to 10:\n$ kubectl get rc\nNAME      DESIRED   CURRENT   READY     AGE\nkubia     10        10        4         21m\nThere you go. If the kubectl scale command makes it look as though you\u2019re telling\nKubernetes exactly what to do, it\u2019s now much clearer that you\u2019re making a declarative\nchange to the desired state of the ReplicationController and not telling Kubernetes to\ndo something.\nSCALING DOWN WITH THE KUBECTL SCALE COMMAND\nNow scale back down to 3. You can use the kubectl scale command:\n$ kubectl scale rc kubia --replicas=3\nAll this command does is modify the spec.replicas field of the ReplicationController\u2019s\ndefinition\u2014like when you changed it through kubectl edit. \nUNDERSTANDING THE DECLARATIVE APPROACH TO SCALING\nHorizontally scaling pods in Kubernetes is a matter of stating your desire: \u201cI want to\nhave x number of instances running.\u201d You\u2019re not telling Kubernetes what or how to do\nit. You\u2019re just specifying the desired state. \n This declarative approach makes interacting with a Kubernetes cluster easy. Imag-\nine if you had to manually determine the current number of running instances and\nthen explicitly tell Kubernetes how many additional instances to run. That\u2019s more\nwork and is much more error-prone. Changing a simple number is much easier, and\nin chapter 15, you\u2019ll learn that even that can be done by Kubernetes itself if you\nenable horizontal pod auto-scaling. \n4.2.7\nDeleting a ReplicationController\nWhen you delete a ReplicationController through kubectl delete, the pods are also\ndeleted. But because pods created by a ReplicationController aren\u2019t an integral part\nof the ReplicationController, and are only managed by it, you can delete only the\nReplicationController and leave the pods running, as shown in figure 4.7.\n This may be useful when you initially have a set of pods managed by a Replication-\nController, and then decide to replace the ReplicationController with a ReplicaSet,\nfor example (you\u2019ll learn about them next.). You can do this without affecting the\nChange the number 3 \nto number 10 in \nthis line.\n \n", "shape": "dot", "size": 10, "title": "103\nIntroducing ReplicationControllers\nmetadata:\n  ...\nspec:\n  replicas: 3        \n  selector:\n    app: kubia\n  ...\nWhen you save the file and close the editor, the ReplicationController is updated and\nit immediately scales the number of pods to 10:\n$ kubectl get rc\nNAME      DESIRED   CURRENT   READY     AGE\nkubia     10        10        4         21m\nThere you go. If the kubectl scale command makes it look as though you\u2019re telling\nKubernetes exactly what to do, it\u2019s now much clearer that you\u2019re making a declarative\nchange to the desired state of the ReplicationController and not telling Kubernetes to\ndo something.\nSCALING DOWN WITH THE KUBECTL SCALE COMMAND\nNow scale back down to 3. You can use the kubectl scale command:\n$ kubectl scale rc kubia --replicas=3\nAll this command does is modify the spec.replicas field of the ReplicationController\u2019s\ndefinition\u2014like when you changed it through kubectl edit. \nUNDERSTANDING THE DECLARATIVE APPROACH TO SCALING\nHorizontally scaling pods in Kubernetes is a matter of stating your desire: \u201cI want to\nhave x number of instances running.\u201d You\u2019re not telling Kubernetes what or how to do\nit. You\u2019re just specifying the desired state. \n This declarative approach makes interacting with a Kubernetes cluster easy. Imag-\nine if you had to manually determine the current number of running instances and\nthen explicitly tell Kubernetes how many additional instances to run. That\u2019s more\nwork and is much more error-prone. Changing a simple number is much easier, and\nin chapter 15, you\u2019ll learn that even that can be done by Kubernetes itself if you\nenable horizontal pod auto-scaling. \n4.2.7\nDeleting a ReplicationController\nWhen you delete a ReplicationController through kubectl delete, the pods are also\ndeleted. But because pods created by a ReplicationController aren\u2019t an integral part\nof the ReplicationController, and are only managed by it, you can delete only the\nReplicationController and leave the pods running, as shown in figure 4.7.\n This may be useful when you initially have a set of pods managed by a Replication-\nController, and then decide to replace the ReplicationController with a ReplicaSet,\nfor example (you\u2019ll learn about them next.). You can do this without affecting the\nChange the number 3 \nto number 10 in \nthis line.\n \n"}, {"color": "green", "id": "text_47", "label": "104\nCHAPTER 4\nReplication and other controllers: deploying managed pods\npods and keep them running without interruption while you replace the Replication-\nController that manages them. \n When deleting a ReplicationController with kubectl delete, you can keep its\npods running by passing the --cascade=false option to the command. Try that now:\n$ kubectl delete rc kubia --cascade=false\nreplicationcontroller \"kubia\" deleted\nYou\u2019ve deleted the ReplicationController so the pods are on their own. They are no\nlonger managed. But you can always create a new ReplicationController with the\nproper label selector and make them managed again.\n4.3\nUsing ReplicaSets instead of ReplicationControllers\nInitially, ReplicationControllers were the only Kubernetes component for replicating\npods and rescheduling them when nodes failed. Later, a similar resource called a\nReplicaSet was introduced. It\u2019s a new generation of ReplicationController and\nreplaces it completely (ReplicationControllers will eventually be deprecated). \n You could have started this chapter by creating a ReplicaSet instead of a Replication-\nController, but I felt it would be a good idea to start with what was initially available in\nKubernetes. Plus, you\u2019ll still see ReplicationControllers used in the wild, so it\u2019s good\nfor you to know about them. That said, you should always create ReplicaSets instead\nof ReplicationControllers from now on. They\u2019re almost identical, so you shouldn\u2019t\nhave any trouble using them instead. \nBefore the RC deletion\nAfter the RC deletion\nDelete RC\nPod:\nkubia-q3vkg\nPod:\nkubia-53thy\nPod:\nkubia-k0xz6\nPod:\nkubia-q3vkg\nPod:\nkubia-53thy\nPod:\nkubia-k0xz6\nReplicationController: kubia\nReplicas: 3\nSelector: app=kubia\napp: kubia\napp: kubia\napp: kubia\napp: kubia\napp: kubia\napp: kubia\nFigure 4.7\nDeleting a replication controller with --cascade=false leaves pods unmanaged.\n \n", "shape": "dot", "size": 10, "title": "104\nCHAPTER 4\nReplication and other controllers: deploying managed pods\npods and keep them running without interruption while you replace the Replication-\nController that manages them. \n When deleting a ReplicationController with kubectl delete, you can keep its\npods running by passing the --cascade=false option to the command. Try that now:\n$ kubectl delete rc kubia --cascade=false\nreplicationcontroller \"kubia\" deleted\nYou\u2019ve deleted the ReplicationController so the pods are on their own. They are no\nlonger managed. But you can always create a new ReplicationController with the\nproper label selector and make them managed again.\n4.3\nUsing ReplicaSets instead of ReplicationControllers\nInitially, ReplicationControllers were the only Kubernetes component for replicating\npods and rescheduling them when nodes failed. Later, a similar resource called a\nReplicaSet was introduced. It\u2019s a new generation of ReplicationController and\nreplaces it completely (ReplicationControllers will eventually be deprecated). \n You could have started this chapter by creating a ReplicaSet instead of a Replication-\nController, but I felt it would be a good idea to start with what was initially available in\nKubernetes. Plus, you\u2019ll still see ReplicationControllers used in the wild, so it\u2019s good\nfor you to know about them. That said, you should always create ReplicaSets instead\nof ReplicationControllers from now on. They\u2019re almost identical, so you shouldn\u2019t\nhave any trouble using them instead. \nBefore the RC deletion\nAfter the RC deletion\nDelete RC\nPod:\nkubia-q3vkg\nPod:\nkubia-53thy\nPod:\nkubia-k0xz6\nPod:\nkubia-q3vkg\nPod:\nkubia-53thy\nPod:\nkubia-k0xz6\nReplicationController: kubia\nReplicas: 3\nSelector: app=kubia\napp: kubia\napp: kubia\napp: kubia\napp: kubia\napp: kubia\napp: kubia\nFigure 4.7\nDeleting a replication controller with --cascade=false leaves pods unmanaged.\n \n"}, {"color": "green", "id": "text_48", "label": "105\nUsing ReplicaSets instead of ReplicationControllers\n You usually won\u2019t create them directly, but instead have them created automati-\ncally when you create the higher-level Deployment resource, which you\u2019ll learn about\nin chapter 9. In any case, you should understand ReplicaSets, so let\u2019s see how they dif-\nfer from ReplicationControllers.\n4.3.1\nComparing a ReplicaSet to a ReplicationController\nA ReplicaSet behaves exactly like a ReplicationController, but it has more expressive\npod selectors. Whereas a ReplicationController\u2019s label selector only allows matching\npods that include a certain label, a ReplicaSet\u2019s selector also allows matching pods\nthat lack a certain label or pods that include a certain label key, regardless of\nits value.\n Also, for example, a single ReplicationController can\u2019t match pods with the label\nenv=production and those with the label env=devel at the same time. It can only match\neither pods with the env=production label or pods with the env=devel label. But a sin-\ngle ReplicaSet can match both sets of pods and treat them as a single group. \n Similarly, a ReplicationController can\u2019t match pods based merely on the presence\nof a label key, regardless of its value, whereas a ReplicaSet can. For example, a Replica-\nSet can match all pods that include a label with the key env, whatever its actual value is\n(you can think of it as env=*).\n4.3.2\nDefining a ReplicaSet\nYou\u2019re going to create a ReplicaSet now to see how the orphaned pods that were cre-\nated by your ReplicationController and then abandoned earlier can now be adopted\nby a ReplicaSet. First, you\u2019ll rewrite your ReplicationController into a ReplicaSet by\ncreating a new file called kubia-replicaset.yaml with the contents in the following\nlisting.\napiVersion: apps/v1beta2      \nkind: ReplicaSet                    \nmetadata:\n  name: kubia\nspec:\n  replicas: 3\n  selector:\n    matchLabels:                 \n      app: kubia                 \n  template:                        \n    metadata:                      \n      labels:                      \n        app: kubia                 \n    spec:                          \n      containers:                  \n      - name: kubia                \n        image: luksa/kubia         \nListing 4.8\nA YAML definition of a ReplicaSet: kubia-replicaset.yaml\nReplicaSets aren\u2019t part of the v1 \nAPI, but belong to the apps API \ngroup and version v1beta2.\nYou\u2019re using the simpler matchLabels \nselector here, which is much like a \nReplicationController\u2019s selector.\nThe template is \nthe same as in the \nReplicationController.\n \n", "shape": "dot", "size": 10, "title": "105\nUsing ReplicaSets instead of ReplicationControllers\n You usually won\u2019t create them directly, but instead have them created automati-\ncally when you create the higher-level Deployment resource, which you\u2019ll learn about\nin chapter 9. In any case, you should understand ReplicaSets, so let\u2019s see how they dif-\nfer from ReplicationControllers.\n4.3.1\nComparing a ReplicaSet to a ReplicationController\nA ReplicaSet behaves exactly like a ReplicationController, but it has more expressive\npod selectors. Whereas a ReplicationController\u2019s label selector only allows matching\npods that include a certain label, a ReplicaSet\u2019s selector also allows matching pods\nthat lack a certain label or pods that include a certain label key, regardless of\nits value.\n Also, for example, a single ReplicationController can\u2019t match pods with the label\nenv=production and those with the label env=devel at the same time. It can only match\neither pods with the env=production label or pods with the env=devel label. But a sin-\ngle ReplicaSet can match both sets of pods and treat them as a single group. \n Similarly, a ReplicationController can\u2019t match pods based merely on the presence\nof a label key, regardless of its value, whereas a ReplicaSet can. For example, a Replica-\nSet can match all pods that include a label with the key env, whatever its actual value is\n(you can think of it as env=*).\n4.3.2\nDefining a ReplicaSet\nYou\u2019re going to create a ReplicaSet now to see how the orphaned pods that were cre-\nated by your ReplicationController and then abandoned earlier can now be adopted\nby a ReplicaSet. First, you\u2019ll rewrite your ReplicationController into a ReplicaSet by\ncreating a new file called kubia-replicaset.yaml with the contents in the following\nlisting.\napiVersion: apps/v1beta2      \nkind: ReplicaSet                    \nmetadata:\n  name: kubia\nspec:\n  replicas: 3\n  selector:\n    matchLabels:                 \n      app: kubia                 \n  template:                        \n    metadata:                      \n      labels:                      \n        app: kubia                 \n    spec:                          \n      containers:                  \n      - name: kubia                \n        image: luksa/kubia         \nListing 4.8\nA YAML definition of a ReplicaSet: kubia-replicaset.yaml\nReplicaSets aren\u2019t part of the v1 \nAPI, but belong to the apps API \ngroup and version v1beta2.\nYou\u2019re using the simpler matchLabels \nselector here, which is much like a \nReplicationController\u2019s selector.\nThe template is \nthe same as in the \nReplicationController.\n \n"}, {"color": "green", "id": "text_49", "label": "106\nCHAPTER 4\nReplication and other controllers: deploying managed pods\nThe first thing to note is that ReplicaSets aren\u2019t part of the v1 API, so you need to\nensure you specify the proper apiVersion when creating the resource. You\u2019re creating a\nresource of type ReplicaSet which has much the same contents as the Replication-\nController you created earlier. \n The only difference is in the selector. Instead of listing labels the pods need to\nhave directly under the selector property, you\u2019re specifying them under selector\n.matchLabels. This is the simpler (and less expressive) way of defining label selectors\nin a ReplicaSet. Later, you\u2019ll look at the more expressive option, as well.\nBecause you still have three pods matching the app=kubia selector running from ear-\nlier, creating this ReplicaSet will not cause any new pods to be created. The ReplicaSet\nwill take those existing three pods under its wing. \n4.3.3\nCreating and examining a ReplicaSet\nCreate the ReplicaSet from the YAML file with the kubectl create command. After\nthat, you can examine the ReplicaSet with kubectl get and kubectl describe:\n$ kubectl get rs\nNAME      DESIRED   CURRENT   READY     AGE\nkubia     3         3         3         3s\nTIP\nUse rs shorthand, which stands for replicaset.\n$ kubectl describe rs\nName:           kubia\nNamespace:      default\nSelector:       app=kubia\nLabels:         app=kubia\nAnnotations:    \u003cnone\u003e\nReplicas:       3 current / 3 desired\nPods Status:    3 Running / 0 Waiting / 0 Succeeded / 0 Failed\nPod Template:\n  Labels:       app=kubia\nAbout the API version attribute\nThis is your first opportunity to see that the apiVersion property specifies two things:\n\uf0a1The API group (which is apps in this case)\n\uf0a1The actual API version (v1beta2)\nYou\u2019ll see throughout the book that certain Kubernetes resources are in what\u2019s called\nthe core API group, which doesn\u2019t need to be specified in the apiVersion field (you\njust specify the version\u2014for example, you\u2019ve been using apiVersion: v1 when\ndefining Pod resources). Other resources, which were introduced in later Kubernetes\nversions, are categorized into several API groups. Look at the inside of the book\u2019s\ncovers to see all resources and their respective API groups.\n \n", "shape": "dot", "size": 10, "title": "106\nCHAPTER 4\nReplication and other controllers: deploying managed pods\nThe first thing to note is that ReplicaSets aren\u2019t part of the v1 API, so you need to\nensure you specify the proper apiVersion when creating the resource. You\u2019re creating a\nresource of type ReplicaSet which has much the same contents as the Replication-\nController you created earlier. \n The only difference is in the selector. Instead of listing labels the pods need to\nhave directly under the selector property, you\u2019re specifying them under selector\n.matchLabels. This is the simpler (and less expressive) way of defining label selectors\nin a ReplicaSet. Later, you\u2019ll look at the more expressive option, as well.\nBecause you still have three pods matching the app=kubia selector running from ear-\nlier, creating this ReplicaSet will not cause any new pods to be created. The ReplicaSet\nwill take those existing three pods under its wing. \n4.3.3\nCreating and examining a ReplicaSet\nCreate the ReplicaSet from the YAML file with the kubectl create command. After\nthat, you can examine the ReplicaSet with kubectl get and kubectl describe:\n$ kubectl get rs\nNAME      DESIRED   CURRENT   READY     AGE\nkubia     3         3         3         3s\nTIP\nUse rs shorthand, which stands for replicaset.\n$ kubectl describe rs\nName:           kubia\nNamespace:      default\nSelector:       app=kubia\nLabels:         app=kubia\nAnnotations:    \u003cnone\u003e\nReplicas:       3 current / 3 desired\nPods Status:    3 Running / 0 Waiting / 0 Succeeded / 0 Failed\nPod Template:\n  Labels:       app=kubia\nAbout the API version attribute\nThis is your first opportunity to see that the apiVersion property specifies two things:\n\uf0a1The API group (which is apps in this case)\n\uf0a1The actual API version (v1beta2)\nYou\u2019ll see throughout the book that certain Kubernetes resources are in what\u2019s called\nthe core API group, which doesn\u2019t need to be specified in the apiVersion field (you\njust specify the version\u2014for example, you\u2019ve been using apiVersion: v1 when\ndefining Pod resources). Other resources, which were introduced in later Kubernetes\nversions, are categorized into several API groups. Look at the inside of the book\u2019s\ncovers to see all resources and their respective API groups.\n \n"}, {"color": "green", "id": "text_50", "label": "107\nUsing ReplicaSets instead of ReplicationControllers\n  Containers:   ...\n  Volumes:      \u003cnone\u003e\nEvents:         \u003cnone\u003e\nAs you can see, the ReplicaSet isn\u2019t any different from a ReplicationController. It\u2019s\nshowing it has three replicas matching the selector. If you list all the pods, you\u2019ll see\nthey\u2019re still the same three pods you had before. The ReplicaSet didn\u2019t create any new\nones. \n4.3.4\nUsing the ReplicaSet\u2019s more expressive label selectors\nThe main improvements of ReplicaSets over ReplicationControllers are their more\nexpressive label selectors. You intentionally used the simpler matchLabels selector in\nthe first ReplicaSet example to see that ReplicaSets are no different from Replication-\nControllers. Now, you\u2019ll rewrite the selector to use the more powerful matchExpressions\nproperty, as shown in the following listing.\n selector:\n   matchExpressions:                 \n     - key: app           \n       operator: In                  \n       values:                       \n         - kubia                     \nNOTE\nOnly the selector is shown. You\u2019ll find the whole ReplicaSet definition\nin the book\u2019s code archive.\nYou can add additional expressions to the selector. As in the example, each expression\nmust contain a key, an operator, and possibly (depending on the operator) a list of\nvalues. You\u2019ll see four valid operators:\n\uf0a1\nIn\u2014Label\u2019s value must match one of the specified values.\n\uf0a1\nNotIn\u2014Label\u2019s value must not match any of the specified values.\n\uf0a1\nExists\u2014Pod must include a label with the specified key (the value isn\u2019t import-\nant). When using this operator, you shouldn\u2019t specify the values field.\n\uf0a1\nDoesNotExist\u2014Pod must not include a label with the specified key. The values\nproperty must not be specified.\nIf you specify multiple expressions, all those expressions must evaluate to true for the\nselector to match a pod. If you specify both matchLabels and matchExpressions, all\nthe labels must match and all the expressions must evaluate to true for the pod to\nmatch the selector.\nListing 4.9\nA matchExpressions selector: kubia-replicaset-matchexpressions.yaml\nThis selector requires the pod to \ncontain a label with the \u201capp\u201d key.\nThe label\u2019s value \nmust be \u201ckubia\u201d.\n \n", "shape": "dot", "size": 10, "title": "107\nUsing ReplicaSets instead of ReplicationControllers\n  Containers:   ...\n  Volumes:      \u003cnone\u003e\nEvents:         \u003cnone\u003e\nAs you can see, the ReplicaSet isn\u2019t any different from a ReplicationController. It\u2019s\nshowing it has three replicas matching the selector. If you list all the pods, you\u2019ll see\nthey\u2019re still the same three pods you had before. The ReplicaSet didn\u2019t create any new\nones. \n4.3.4\nUsing the ReplicaSet\u2019s more expressive label selectors\nThe main improvements of ReplicaSets over ReplicationControllers are their more\nexpressive label selectors. You intentionally used the simpler matchLabels selector in\nthe first ReplicaSet example to see that ReplicaSets are no different from Replication-\nControllers. Now, you\u2019ll rewrite the selector to use the more powerful matchExpressions\nproperty, as shown in the following listing.\n selector:\n   matchExpressions:                 \n     - key: app           \n       operator: In                  \n       values:                       \n         - kubia                     \nNOTE\nOnly the selector is shown. You\u2019ll find the whole ReplicaSet definition\nin the book\u2019s code archive.\nYou can add additional expressions to the selector. As in the example, each expression\nmust contain a key, an operator, and possibly (depending on the operator) a list of\nvalues. You\u2019ll see four valid operators:\n\uf0a1\nIn\u2014Label\u2019s value must match one of the specified values.\n\uf0a1\nNotIn\u2014Label\u2019s value must not match any of the specified values.\n\uf0a1\nExists\u2014Pod must include a label with the specified key (the value isn\u2019t import-\nant). When using this operator, you shouldn\u2019t specify the values field.\n\uf0a1\nDoesNotExist\u2014Pod must not include a label with the specified key. The values\nproperty must not be specified.\nIf you specify multiple expressions, all those expressions must evaluate to true for the\nselector to match a pod. If you specify both matchLabels and matchExpressions, all\nthe labels must match and all the expressions must evaluate to true for the pod to\nmatch the selector.\nListing 4.9\nA matchExpressions selector: kubia-replicaset-matchexpressions.yaml\nThis selector requires the pod to \ncontain a label with the \u201capp\u201d key.\nThe label\u2019s value \nmust be \u201ckubia\u201d.\n \n"}, {"color": "green", "id": "text_51", "label": "108\nCHAPTER 4\nReplication and other controllers: deploying managed pods\n4.3.5\nWrapping up ReplicaSets\nThis was a quick introduction to ReplicaSets as an alternative to ReplicationControllers.\nRemember, always use them instead of ReplicationControllers, but you may still find\nReplicationControllers in other people\u2019s deployments.\n Now, delete the ReplicaSet to clean up your cluster a little. You can delete the\nReplicaSet the same way you\u2019d delete a ReplicationController:\n$ kubectl delete rs kubia\nreplicaset \"kubia\" deleted\nDeleting the ReplicaSet should delete all the pods. List the pods to confirm that\u2019s\nthe case. \n4.4\nRunning exactly one pod on each node with \nDaemonSets\nBoth ReplicationControllers and ReplicaSets are used for running a specific number\nof pods deployed anywhere in the Kubernetes cluster. But certain cases exist when you\nwant a pod to run on each and every node in the cluster (and each node needs to run\nexactly one instance of the pod, as shown in figure 4.8).\n Those cases include infrastructure-related pods that perform system-level opera-\ntions. For example, you\u2019ll want to run a log collector and a resource monitor on every\nnode. Another good example is Kubernetes\u2019 own kube-proxy process, which needs to\nrun on all nodes to make services work.\nNode 1\nPod\nPod\nPod\nReplicaSet\nReplicas: 5\nNode 2\nPod\nPod\nNode 3\nPod\nDaemonSet\nExactly one replica\non each node\nNode 4\nPod\nPod\nPod\nFigure 4.8\nDaemonSets run only a single pod replica on each node, whereas ReplicaSets \nscatter them around the whole cluster randomly. \n \n", "shape": "dot", "size": 10, "title": "108\nCHAPTER 4\nReplication and other controllers: deploying managed pods\n4.3.5\nWrapping up ReplicaSets\nThis was a quick introduction to ReplicaSets as an alternative to ReplicationControllers.\nRemember, always use them instead of ReplicationControllers, but you may still find\nReplicationControllers in other people\u2019s deployments.\n Now, delete the ReplicaSet to clean up your cluster a little. You can delete the\nReplicaSet the same way you\u2019d delete a ReplicationController:\n$ kubectl delete rs kubia\nreplicaset \"kubia\" deleted\nDeleting the ReplicaSet should delete all the pods. List the pods to confirm that\u2019s\nthe case. \n4.4\nRunning exactly one pod on each node with \nDaemonSets\nBoth ReplicationControllers and ReplicaSets are used for running a specific number\nof pods deployed anywhere in the Kubernetes cluster. But certain cases exist when you\nwant a pod to run on each and every node in the cluster (and each node needs to run\nexactly one instance of the pod, as shown in figure 4.8).\n Those cases include infrastructure-related pods that perform system-level opera-\ntions. For example, you\u2019ll want to run a log collector and a resource monitor on every\nnode. Another good example is Kubernetes\u2019 own kube-proxy process, which needs to\nrun on all nodes to make services work.\nNode 1\nPod\nPod\nPod\nReplicaSet\nReplicas: 5\nNode 2\nPod\nPod\nNode 3\nPod\nDaemonSet\nExactly one replica\non each node\nNode 4\nPod\nPod\nPod\nFigure 4.8\nDaemonSets run only a single pod replica on each node, whereas ReplicaSets \nscatter them around the whole cluster randomly. \n \n"}, {"color": "green", "id": "text_52", "label": "109\nRunning exactly one pod on each node with DaemonSets\nOutside of Kubernetes, such processes would usually be started through system init\nscripts or the systemd daemon during node boot up. On Kubernetes nodes, you can\nstill use systemd to run your system processes, but then you can\u2019t take advantage of all\nthe features Kubernetes provides. \n4.4.1\nUsing a DaemonSet to run a pod on every node\nTo run a pod on all cluster nodes, you create a DaemonSet object, which is much\nlike a ReplicationController or a ReplicaSet, except that pods created by a Daemon-\nSet already have a target node specified and skip the Kubernetes Scheduler. They\naren\u2019t scattered around the cluster randomly. \n A DaemonSet makes sure it creates as many pods as there are nodes and deploys\neach one on its own node, as shown in figure 4.8.\n Whereas a ReplicaSet (or ReplicationController) makes sure that a desired num-\nber of pod replicas exist in the cluster, a DaemonSet doesn\u2019t have any notion of a\ndesired replica count. It doesn\u2019t need it because its job is to ensure that a pod match-\ning its pod selector is running on each node. \n If a node goes down, the DaemonSet doesn\u2019t cause the pod to be created else-\nwhere. But when a new node is added to the cluster, the DaemonSet immediately\ndeploys a new pod instance to it. It also does the same if someone inadvertently\ndeletes one of the pods, leaving the node without the DaemonSet\u2019s pod. Like a Replica-\nSet, a DaemonSet creates the pod from the pod template configured in it.\n4.4.2\nUsing a DaemonSet to run pods only on certain nodes\nA DaemonSet deploys pods to all nodes in the cluster, unless you specify that the pods\nshould only run on a subset of all the nodes. This is done by specifying the node-\nSelector property in the pod template, which is part of the DaemonSet definition\n(similar to the pod template in a ReplicaSet or ReplicationController). \n You\u2019ve already used node selectors to deploy a pod onto specific nodes in chapter 3.\nA node selector in a DaemonSet is similar\u2014it defines the nodes the DaemonSet must\ndeploy its pods to. \nNOTE\nLater in the book, you\u2019ll learn that nodes can be made unschedulable,\npreventing pods from being deployed to them. A DaemonSet will deploy pods\neven to such nodes, because the unschedulable attribute is only used by the\nScheduler, whereas pods managed by a DaemonSet bypass the Scheduler\ncompletely. This is usually desirable, because DaemonSets are meant to run\nsystem services, which usually need to run even on unschedulable nodes.\nEXPLAINING DAEMONSETS WITH AN EXAMPLE\nLet\u2019s imagine having a daemon called ssd-monitor that needs to run on all nodes\nthat contain a solid-state drive (SSD). You\u2019ll create a DaemonSet that runs this dae-\nmon on all nodes that are marked as having an SSD. The cluster administrators have\nadded the disk=ssd label to all such nodes, so you\u2019ll create the DaemonSet with a\nnode selector that only selects nodes with that label, as shown in figure 4.9.\n \n", "shape": "dot", "size": 10, "title": "109\nRunning exactly one pod on each node with DaemonSets\nOutside of Kubernetes, such processes would usually be started through system init\nscripts or the systemd daemon during node boot up. On Kubernetes nodes, you can\nstill use systemd to run your system processes, but then you can\u2019t take advantage of all\nthe features Kubernetes provides. \n4.4.1\nUsing a DaemonSet to run a pod on every node\nTo run a pod on all cluster nodes, you create a DaemonSet object, which is much\nlike a ReplicationController or a ReplicaSet, except that pods created by a Daemon-\nSet already have a target node specified and skip the Kubernetes Scheduler. They\naren\u2019t scattered around the cluster randomly. \n A DaemonSet makes sure it creates as many pods as there are nodes and deploys\neach one on its own node, as shown in figure 4.8.\n Whereas a ReplicaSet (or ReplicationController) makes sure that a desired num-\nber of pod replicas exist in the cluster, a DaemonSet doesn\u2019t have any notion of a\ndesired replica count. It doesn\u2019t need it because its job is to ensure that a pod match-\ning its pod selector is running on each node. \n If a node goes down, the DaemonSet doesn\u2019t cause the pod to be created else-\nwhere. But when a new node is added to the cluster, the DaemonSet immediately\ndeploys a new pod instance to it. It also does the same if someone inadvertently\ndeletes one of the pods, leaving the node without the DaemonSet\u2019s pod. Like a Replica-\nSet, a DaemonSet creates the pod from the pod template configured in it.\n4.4.2\nUsing a DaemonSet to run pods only on certain nodes\nA DaemonSet deploys pods to all nodes in the cluster, unless you specify that the pods\nshould only run on a subset of all the nodes. This is done by specifying the node-\nSelector property in the pod template, which is part of the DaemonSet definition\n(similar to the pod template in a ReplicaSet or ReplicationController). \n You\u2019ve already used node selectors to deploy a pod onto specific nodes in chapter 3.\nA node selector in a DaemonSet is similar\u2014it defines the nodes the DaemonSet must\ndeploy its pods to. \nNOTE\nLater in the book, you\u2019ll learn that nodes can be made unschedulable,\npreventing pods from being deployed to them. A DaemonSet will deploy pods\neven to such nodes, because the unschedulable attribute is only used by the\nScheduler, whereas pods managed by a DaemonSet bypass the Scheduler\ncompletely. This is usually desirable, because DaemonSets are meant to run\nsystem services, which usually need to run even on unschedulable nodes.\nEXPLAINING DAEMONSETS WITH AN EXAMPLE\nLet\u2019s imagine having a daemon called ssd-monitor that needs to run on all nodes\nthat contain a solid-state drive (SSD). You\u2019ll create a DaemonSet that runs this dae-\nmon on all nodes that are marked as having an SSD. The cluster administrators have\nadded the disk=ssd label to all such nodes, so you\u2019ll create the DaemonSet with a\nnode selector that only selects nodes with that label, as shown in figure 4.9.\n \n"}, {"color": "green", "id": "text_53", "label": "110\nCHAPTER 4\nReplication and other controllers: deploying managed pods\nCREATING A DAEMONSET YAML DEFINITION\nYou\u2019ll create a DaemonSet that runs a mock ssd-monitor process, which prints\n\u201cSSD OK\u201d to the standard output every five seconds. I\u2019ve already prepared the mock\ncontainer image and pushed it to Docker Hub, so you can use it instead of building\nyour own. Create the YAML for the DaemonSet, as shown in the following listing.\napiVersion: apps/v1beta2      \nkind: DaemonSet                     \nmetadata:\n  name: ssd-monitor\nspec:                            \n  selector:\n    matchLabels:\n      app: ssd-monitor\n  template:\n    metadata:\n      labels:\n        app: ssd-monitor\n    spec:\n      nodeSelector:                \n        disk: ssd                  \n      containers:\n      - name: main\n        image: luksa/ssd-monitor\nYou\u2019re defining a DaemonSet that will run a pod with a single container based on the\nluksa/ssd-monitor container image. An instance of this pod will be created for each\nnode that has the disk=ssd label.\nListing 4.10\nA YAML for a DaemonSet: ssd-monitor-daemonset.yaml\nNode 1\nPod:\nssd-monitor\nNode 2\nNode 3\nDaemonSet:\nsssd-monitor\nNode selector:\ndisk=ssd\nNode 4\ndisk: ssd\ndisk: ssd\ndisk: ssd\nUnschedulable\nPod:\nssd-monitor\nPod:\nssd-monitor\nFigure 4.9\nUsing a DaemonSet with a node selector to deploy system pods only on certain \nnodes\nDaemonSets are in the \napps API group, \nversion v1beta2.\nThe pod template includes a \nnode selector, which selects \nnodes with the disk=ssd label.\n \n", "shape": "dot", "size": 10, "title": "110\nCHAPTER 4\nReplication and other controllers: deploying managed pods\nCREATING A DAEMONSET YAML DEFINITION\nYou\u2019ll create a DaemonSet that runs a mock ssd-monitor process, which prints\n\u201cSSD OK\u201d to the standard output every five seconds. I\u2019ve already prepared the mock\ncontainer image and pushed it to Docker Hub, so you can use it instead of building\nyour own. Create the YAML for the DaemonSet, as shown in the following listing.\napiVersion: apps/v1beta2      \nkind: DaemonSet                     \nmetadata:\n  name: ssd-monitor\nspec:                            \n  selector:\n    matchLabels:\n      app: ssd-monitor\n  template:\n    metadata:\n      labels:\n        app: ssd-monitor\n    spec:\n      nodeSelector:                \n        disk: ssd                  \n      containers:\n      - name: main\n        image: luksa/ssd-monitor\nYou\u2019re defining a DaemonSet that will run a pod with a single container based on the\nluksa/ssd-monitor container image. An instance of this pod will be created for each\nnode that has the disk=ssd label.\nListing 4.10\nA YAML for a DaemonSet: ssd-monitor-daemonset.yaml\nNode 1\nPod:\nssd-monitor\nNode 2\nNode 3\nDaemonSet:\nsssd-monitor\nNode selector:\ndisk=ssd\nNode 4\ndisk: ssd\ndisk: ssd\ndisk: ssd\nUnschedulable\nPod:\nssd-monitor\nPod:\nssd-monitor\nFigure 4.9\nUsing a DaemonSet with a node selector to deploy system pods only on certain \nnodes\nDaemonSets are in the \napps API group, \nversion v1beta2.\nThe pod template includes a \nnode selector, which selects \nnodes with the disk=ssd label.\n \n"}, {"color": "green", "id": "text_54", "label": "111\nRunning exactly one pod on each node with DaemonSets\nCREATING THE DAEMONSET\nYou\u2019ll create the DaemonSet like you always create resources from a YAML file:\n$ kubectl create -f ssd-monitor-daemonset.yaml\ndaemonset \"ssd-monitor\" created\nLet\u2019s see the created DaemonSet:\n$ kubectl get ds\nNAME          DESIRED  CURRENT  READY  UP-TO-DATE  AVAILABLE  NODE-SELECTOR  \nssd-monitor   0        0        0      0           0          disk=ssd\nThose zeroes look strange. Didn\u2019t the DaemonSet deploy any pods? List the pods:\n$ kubectl get po\nNo resources found.\nWhere are the pods? Do you know what\u2019s going on? Yes, you forgot to label your nodes\nwith the disk=ssd label. No problem\u2014you can do that now. The DaemonSet should\ndetect that the nodes\u2019 labels have changed and deploy the pod to all nodes with a\nmatching label. Let\u2019s see if that\u2019s true. \nADDING THE REQUIRED LABEL TO YOUR NODE(S)\nRegardless if you\u2019re using Minikube, GKE, or another multi-node cluster, you\u2019ll need\nto list the nodes first, because you\u2019ll need to know the node\u2019s name when labeling it:\n$ kubectl get node\nNAME       STATUS    AGE       VERSION\nminikube   Ready     4d        v1.6.0\nNow, add the disk=ssd label to one of your nodes like this:\n$ kubectl label node minikube disk=ssd\nnode \"minikube\" labeled\nNOTE\nReplace minikube with the name of one of your nodes if you\u2019re not\nusing Minikube.\nThe DaemonSet should have created one pod now. Let\u2019s see:\n$ kubectl get po\nNAME                READY     STATUS    RESTARTS   AGE\nssd-monitor-hgxwq   1/1       Running   0          35s\nOkay; so far so good. If you have multiple nodes and you add the same label to further\nnodes, you\u2019ll see the DaemonSet spin up pods for each of them. \nREMOVING THE REQUIRED LABEL FROM THE NODE\nNow, imagine you\u2019ve made a mistake and have mislabeled one of the nodes. It has a\nspinning disk drive, not an SSD. What happens if you change the node\u2019s label?\n$ kubectl label node minikube disk=hdd --overwrite\nnode \"minikube\" labeled\n \n", "shape": "dot", "size": 10, "title": "111\nRunning exactly one pod on each node with DaemonSets\nCREATING THE DAEMONSET\nYou\u2019ll create the DaemonSet like you always create resources from a YAML file:\n$ kubectl create -f ssd-monitor-daemonset.yaml\ndaemonset \"ssd-monitor\" created\nLet\u2019s see the created DaemonSet:\n$ kubectl get ds\nNAME          DESIRED  CURRENT  READY  UP-TO-DATE  AVAILABLE  NODE-SELECTOR  \nssd-monitor   0        0        0      0           0          disk=ssd\nThose zeroes look strange. Didn\u2019t the DaemonSet deploy any pods? List the pods:\n$ kubectl get po\nNo resources found.\nWhere are the pods? Do you know what\u2019s going on? Yes, you forgot to label your nodes\nwith the disk=ssd label. No problem\u2014you can do that now. The DaemonSet should\ndetect that the nodes\u2019 labels have changed and deploy the pod to all nodes with a\nmatching label. Let\u2019s see if that\u2019s true. \nADDING THE REQUIRED LABEL TO YOUR NODE(S)\nRegardless if you\u2019re using Minikube, GKE, or another multi-node cluster, you\u2019ll need\nto list the nodes first, because you\u2019ll need to know the node\u2019s name when labeling it:\n$ kubectl get node\nNAME       STATUS    AGE       VERSION\nminikube   Ready     4d        v1.6.0\nNow, add the disk=ssd label to one of your nodes like this:\n$ kubectl label node minikube disk=ssd\nnode \"minikube\" labeled\nNOTE\nReplace minikube with the name of one of your nodes if you\u2019re not\nusing Minikube.\nThe DaemonSet should have created one pod now. Let\u2019s see:\n$ kubectl get po\nNAME                READY     STATUS    RESTARTS   AGE\nssd-monitor-hgxwq   1/1       Running   0          35s\nOkay; so far so good. If you have multiple nodes and you add the same label to further\nnodes, you\u2019ll see the DaemonSet spin up pods for each of them. \nREMOVING THE REQUIRED LABEL FROM THE NODE\nNow, imagine you\u2019ve made a mistake and have mislabeled one of the nodes. It has a\nspinning disk drive, not an SSD. What happens if you change the node\u2019s label?\n$ kubectl label node minikube disk=hdd --overwrite\nnode \"minikube\" labeled\n \n"}, {"color": "green", "id": "text_55", "label": "112\nCHAPTER 4\nReplication and other controllers: deploying managed pods\nLet\u2019s see if the change has any effect on the pod that was running on that node:\n$ kubectl get po\nNAME                READY     STATUS        RESTARTS   AGE\nssd-monitor-hgxwq   1/1       Terminating   0          4m\nThe pod is being terminated. But you knew that was going to happen, right? This\nwraps up your exploration of DaemonSets, so you may want to delete your ssd-monitor\nDaemonSet. If you still have any other daemon pods running, you\u2019ll see that deleting\nthe DaemonSet deletes those pods as well. \n4.5\nRunning pods that perform a single completable task \nUp to now, we\u2019ve only talked about pods than need to run continuously. You\u2019ll have\ncases where you only want to run a task that terminates after completing its work.\nReplicationControllers, ReplicaSets, and DaemonSets run continuous tasks that are\nnever considered completed. Processes in such pods are restarted when they exit. But\nin a completable task, after its process terminates, it should not be restarted again. \n4.5.1\nIntroducing the Job resource\nKubernetes includes support for this through the Job resource, which is similar to the\nother resources we\u2019ve discussed in this chapter, but it allows you to run a pod whose\ncontainer isn\u2019t restarted when the process running inside finishes successfully. Once it\ndoes, the pod is considered complete. \n In the event of a node failure, the pods on that node that are managed by a Job will\nbe rescheduled to other nodes the way ReplicaSet pods are. In the event of a failure of\nthe process itself (when the process returns an error exit code), the Job can be config-\nured to either restart the container or not.\n Figure 4.10 shows how a pod created by a Job is rescheduled to a new node if the\nnode it was initially scheduled to fails. The figure also shows both a managed pod,\nwhich isn\u2019t rescheduled, and a pod backed by a ReplicaSet, which is.\n For example, Jobs are useful for ad hoc tasks, where it\u2019s crucial that the task fin-\nishes properly. You could run the task in an unmanaged pod and wait for it to finish,\nbut in the event of a node failing or the pod being evicted from the node while it is\nperforming its task, you\u2019d need to manually recreate it. Doing this manually doesn\u2019t\nmake sense\u2014especially if the job takes hours to complete. \n An example of such a job would be if you had data stored somewhere and you\nneeded to transform and export it somewhere. You\u2019re going to emulate this by run-\nning a container image built on top of the busybox image, which invokes the sleep\ncommand for two minutes. I\u2019ve already built the image and pushed it to Docker Hub,\nbut you can peek into its Dockerfile in the book\u2019s code archive.\n \n", "shape": "dot", "size": 10, "title": "112\nCHAPTER 4\nReplication and other controllers: deploying managed pods\nLet\u2019s see if the change has any effect on the pod that was running on that node:\n$ kubectl get po\nNAME                READY     STATUS        RESTARTS   AGE\nssd-monitor-hgxwq   1/1       Terminating   0          4m\nThe pod is being terminated. But you knew that was going to happen, right? This\nwraps up your exploration of DaemonSets, so you may want to delete your ssd-monitor\nDaemonSet. If you still have any other daemon pods running, you\u2019ll see that deleting\nthe DaemonSet deletes those pods as well. \n4.5\nRunning pods that perform a single completable task \nUp to now, we\u2019ve only talked about pods than need to run continuously. You\u2019ll have\ncases where you only want to run a task that terminates after completing its work.\nReplicationControllers, ReplicaSets, and DaemonSets run continuous tasks that are\nnever considered completed. Processes in such pods are restarted when they exit. But\nin a completable task, after its process terminates, it should not be restarted again. \n4.5.1\nIntroducing the Job resource\nKubernetes includes support for this through the Job resource, which is similar to the\nother resources we\u2019ve discussed in this chapter, but it allows you to run a pod whose\ncontainer isn\u2019t restarted when the process running inside finishes successfully. Once it\ndoes, the pod is considered complete. \n In the event of a node failure, the pods on that node that are managed by a Job will\nbe rescheduled to other nodes the way ReplicaSet pods are. In the event of a failure of\nthe process itself (when the process returns an error exit code), the Job can be config-\nured to either restart the container or not.\n Figure 4.10 shows how a pod created by a Job is rescheduled to a new node if the\nnode it was initially scheduled to fails. The figure also shows both a managed pod,\nwhich isn\u2019t rescheduled, and a pod backed by a ReplicaSet, which is.\n For example, Jobs are useful for ad hoc tasks, where it\u2019s crucial that the task fin-\nishes properly. You could run the task in an unmanaged pod and wait for it to finish,\nbut in the event of a node failing or the pod being evicted from the node while it is\nperforming its task, you\u2019d need to manually recreate it. Doing this manually doesn\u2019t\nmake sense\u2014especially if the job takes hours to complete. \n An example of such a job would be if you had data stored somewhere and you\nneeded to transform and export it somewhere. You\u2019re going to emulate this by run-\nning a container image built on top of the busybox image, which invokes the sleep\ncommand for two minutes. I\u2019ve already built the image and pushed it to Docker Hub,\nbut you can peek into its Dockerfile in the book\u2019s code archive.\n \n"}, {"color": "green", "id": "text_56", "label": "113\nRunning pods that perform a single completable task\n4.5.2\nDefining a Job resource\nCreate the Job manifest as in the following listing.\napiVersion: batch/v1        \nkind: Job                   \nmetadata:\n  name: batch-job\nspec:                                \n  template: \n    metadata:\n      labels:                        \n        app: batch-job               \n    spec:\n      restartPolicy: OnFailure         \n      containers:\n      - name: main\n        image: luksa/batch-job\nJobs are part of the batch API group and v1 API version. The YAML defines a\nresource of type Job that will run the luksa/batch-job image, which invokes a pro-\ncess that runs for exactly 120 seconds and then exits. \n In a pod\u2019s specification, you can specify what Kubernetes should do when the\nprocesses running in the container finish. This is done through the restartPolicy\nListing 4.11\nA YAML definition of a Job: exporter.yaml\nNode 1\nPod A (unmanaged)\nPod B (managed by a ReplicaSet)\nPod C (managed by a Job)\nNode 2\nNode 1 fails\nJob C2 \ufb01nishes\nTime\nPod B2 (managed by a ReplicaSet)\nPod C2 (managed by a Job)\nPod A isn\u2019t rescheduled,\nbecause there is nothing\nmanaging it.\nFigure 4.10\nPods managed by Jobs are rescheduled until they finish successfully.\nJobs are in the batch \nAPI group, version v1.\nYou\u2019re not specifying a pod \nselector (it will be created \nbased on the labels in the \npod template).\nJobs can\u2019t use the \ndefault restart policy, \nwhich is Always.\n \n", "shape": "dot", "size": 10, "title": "113\nRunning pods that perform a single completable task\n4.5.2\nDefining a Job resource\nCreate the Job manifest as in the following listing.\napiVersion: batch/v1        \nkind: Job                   \nmetadata:\n  name: batch-job\nspec:                                \n  template: \n    metadata:\n      labels:                        \n        app: batch-job               \n    spec:\n      restartPolicy: OnFailure         \n      containers:\n      - name: main\n        image: luksa/batch-job\nJobs are part of the batch API group and v1 API version. The YAML defines a\nresource of type Job that will run the luksa/batch-job image, which invokes a pro-\ncess that runs for exactly 120 seconds and then exits. \n In a pod\u2019s specification, you can specify what Kubernetes should do when the\nprocesses running in the container finish. This is done through the restartPolicy\nListing 4.11\nA YAML definition of a Job: exporter.yaml\nNode 1\nPod A (unmanaged)\nPod B (managed by a ReplicaSet)\nPod C (managed by a Job)\nNode 2\nNode 1 fails\nJob C2 \ufb01nishes\nTime\nPod B2 (managed by a ReplicaSet)\nPod C2 (managed by a Job)\nPod A isn\u2019t rescheduled,\nbecause there is nothing\nmanaging it.\nFigure 4.10\nPods managed by Jobs are rescheduled until they finish successfully.\nJobs are in the batch \nAPI group, version v1.\nYou\u2019re not specifying a pod \nselector (it will be created \nbased on the labels in the \npod template).\nJobs can\u2019t use the \ndefault restart policy, \nwhich is Always.\n \n"}, {"color": "green", "id": "text_57", "label": "114\nCHAPTER 4\nReplication and other controllers: deploying managed pods\npod spec property, which defaults to Always. Job pods can\u2019t use the default policy,\nbecause they\u2019re not meant to run indefinitely. Therefore, you need to explicitly set\nthe restart policy to either OnFailure or Never. This setting is what prevents the con-\ntainer from being restarted when it finishes (not the fact that the pod is being man-\naged by a Job resource).\n4.5.3\nSeeing a Job run a pod\nAfter you create this Job with the kubectl create command, you should see it start up\na pod immediately:\n$ kubectl get jobs\nNAME        DESIRED   SUCCESSFUL   AGE\nbatch-job   1         0            2s\n$ kubectl get po\nNAME              READY     STATUS    RESTARTS   AGE\nbatch-job-28qf4   1/1       Running   0          4s\nAfter the two minutes have passed, the pod will no longer show up in the pod list and\nthe Job will be marked as completed. By default, completed pods aren\u2019t shown when\nyou list pods, unless you use the --show-all (or -a) switch:\n$ kubectl get po -a\nNAME              READY     STATUS      RESTARTS   AGE\nbatch-job-28qf4   0/1       Completed   0          2m\nThe reason the pod isn\u2019t deleted when it completes is to allow you to examine its logs;\nfor example:\n$ kubectl logs batch-job-28qf4\nFri Apr 29 09:58:22 UTC 2016 Batch job starting\nFri Apr 29 10:00:22 UTC 2016 Finished succesfully\nThe pod will be deleted when you delete it or the Job that created it. Before you do\nthat, let\u2019s look at the Job resource again:\n$ kubectl get job\nNAME        DESIRED   SUCCESSFUL   AGE\nbatch-job   1         1            9m\nThe Job is shown as having completed successfully. But why is that piece of informa-\ntion shown as a number instead of as yes or true? And what does the DESIRED column\nindicate? \n4.5.4\nRunning multiple pod instances in a Job\nJobs may be configured to create more than one pod instance and run them in paral-\nlel or sequentially. This is done by setting the completions and the parallelism prop-\nerties in the Job spec.\n \n", "shape": "dot", "size": 10, "title": "114\nCHAPTER 4\nReplication and other controllers: deploying managed pods\npod spec property, which defaults to Always. Job pods can\u2019t use the default policy,\nbecause they\u2019re not meant to run indefinitely. Therefore, you need to explicitly set\nthe restart policy to either OnFailure or Never. This setting is what prevents the con-\ntainer from being restarted when it finishes (not the fact that the pod is being man-\naged by a Job resource).\n4.5.3\nSeeing a Job run a pod\nAfter you create this Job with the kubectl create command, you should see it start up\na pod immediately:\n$ kubectl get jobs\nNAME        DESIRED   SUCCESSFUL   AGE\nbatch-job   1         0            2s\n$ kubectl get po\nNAME              READY     STATUS    RESTARTS   AGE\nbatch-job-28qf4   1/1       Running   0          4s\nAfter the two minutes have passed, the pod will no longer show up in the pod list and\nthe Job will be marked as completed. By default, completed pods aren\u2019t shown when\nyou list pods, unless you use the --show-all (or -a) switch:\n$ kubectl get po -a\nNAME              READY     STATUS      RESTARTS   AGE\nbatch-job-28qf4   0/1       Completed   0          2m\nThe reason the pod isn\u2019t deleted when it completes is to allow you to examine its logs;\nfor example:\n$ kubectl logs batch-job-28qf4\nFri Apr 29 09:58:22 UTC 2016 Batch job starting\nFri Apr 29 10:00:22 UTC 2016 Finished succesfully\nThe pod will be deleted when you delete it or the Job that created it. Before you do\nthat, let\u2019s look at the Job resource again:\n$ kubectl get job\nNAME        DESIRED   SUCCESSFUL   AGE\nbatch-job   1         1            9m\nThe Job is shown as having completed successfully. But why is that piece of informa-\ntion shown as a number instead of as yes or true? And what does the DESIRED column\nindicate? \n4.5.4\nRunning multiple pod instances in a Job\nJobs may be configured to create more than one pod instance and run them in paral-\nlel or sequentially. This is done by setting the completions and the parallelism prop-\nerties in the Job spec.\n \n"}, {"color": "green", "id": "text_58", "label": "115\nRunning pods that perform a single completable task\nRUNNING JOB PODS SEQUENTIALLY\nIf you need a Job to run more than once, you set completions to how many times you\nwant the Job\u2019s pod to run. The following listing shows an example.\napiVersion: batch/v1\nkind: Job\nmetadata:\n  name: multi-completion-batch-job\nspec:\n  completions: 5                  \n  template:\n    \u003ctemplate is the same as in listing 4.11\u003e\nThis Job will run five pods one after the other. It initially creates one pod, and when\nthe pod\u2019s container finishes, it creates the second pod, and so on, until five pods com-\nplete successfully. If one of the pods fails, the Job creates a new pod, so the Job may\ncreate more than five pods overall.\nRUNNING JOB PODS IN PARALLEL\nInstead of running single Job pods one after the other, you can also make the Job run\nmultiple pods in parallel. You specify how many pods are allowed to run in parallel\nwith the parallelism  Job spec property, as shown in the following listing.\napiVersion: batch/v1\nkind: Job\nmetadata:\n  name: multi-completion-batch-job\nspec:\n  completions: 5                    \n  parallelism: 2                    \n  template:\n    \u003csame as in listing 4.11\u003e\nBy setting parallelism to 2, the Job creates two pods and runs them in parallel:\n$ kubectl get po\nNAME                               READY   STATUS     RESTARTS   AGE\nmulti-completion-batch-job-lmmnk   1/1     Running    0          21s\nmulti-completion-batch-job-qx4nq   1/1     Running    0          21s\nAs soon as one of them finishes, the Job will run the next pod, until five pods finish\nsuccessfully.\nListing 4.12\nA Job requiring multiple completions: multi-completion-batch-job.yaml\nListing 4.13\nRunning Job pods in parallel: multi-completion-parallel-batch-job.yaml\nSetting completions to \n5 makes this Job run \nfive pods sequentially.\nThis job must ensure \nfive pods complete \nsuccessfully.\nUp to two pods \ncan run in parallel.\n \n", "shape": "dot", "size": 10, "title": "115\nRunning pods that perform a single completable task\nRUNNING JOB PODS SEQUENTIALLY\nIf you need a Job to run more than once, you set completions to how many times you\nwant the Job\u2019s pod to run. The following listing shows an example.\napiVersion: batch/v1\nkind: Job\nmetadata:\n  name: multi-completion-batch-job\nspec:\n  completions: 5                  \n  template:\n    \u003ctemplate is the same as in listing 4.11\u003e\nThis Job will run five pods one after the other. It initially creates one pod, and when\nthe pod\u2019s container finishes, it creates the second pod, and so on, until five pods com-\nplete successfully. If one of the pods fails, the Job creates a new pod, so the Job may\ncreate more than five pods overall.\nRUNNING JOB PODS IN PARALLEL\nInstead of running single Job pods one after the other, you can also make the Job run\nmultiple pods in parallel. You specify how many pods are allowed to run in parallel\nwith the parallelism  Job spec property, as shown in the following listing.\napiVersion: batch/v1\nkind: Job\nmetadata:\n  name: multi-completion-batch-job\nspec:\n  completions: 5                    \n  parallelism: 2                    \n  template:\n    \u003csame as in listing 4.11\u003e\nBy setting parallelism to 2, the Job creates two pods and runs them in parallel:\n$ kubectl get po\nNAME                               READY   STATUS     RESTARTS   AGE\nmulti-completion-batch-job-lmmnk   1/1     Running    0          21s\nmulti-completion-batch-job-qx4nq   1/1     Running    0          21s\nAs soon as one of them finishes, the Job will run the next pod, until five pods finish\nsuccessfully.\nListing 4.12\nA Job requiring multiple completions: multi-completion-batch-job.yaml\nListing 4.13\nRunning Job pods in parallel: multi-completion-parallel-batch-job.yaml\nSetting completions to \n5 makes this Job run \nfive pods sequentially.\nThis job must ensure \nfive pods complete \nsuccessfully.\nUp to two pods \ncan run in parallel.\n \n"}, {"color": "green", "id": "text_59", "label": "116\nCHAPTER 4\nReplication and other controllers: deploying managed pods\nSCALING A JOB\nYou can even change a Job\u2019s parallelism property while the Job is running. This is\nsimilar to scaling a ReplicaSet or ReplicationController, and can be done with the\nkubectl scale command:\n$ kubectl scale job multi-completion-batch-job --replicas 3\njob \"multi-completion-batch-job\" scaled\nBecause you\u2019ve increased parallelism from 2 to 3, another pod is immediately spun\nup, so three pods are now running.\n4.5.5\nLimiting the time allowed for a Job pod to complete\nWe need to discuss one final thing about Jobs. How long should the Job wait for a pod\nto finish? What if the pod gets stuck and can\u2019t finish at all (or it can\u2019t finish fast\nenough)?\n A pod\u2019s time can be limited by setting the activeDeadlineSeconds property in the\npod spec. If the pod runs longer than that, the system will try to terminate it and will\nmark the Job as failed. \nNOTE\nYou can configure how many times a Job can be retried before it is\nmarked as failed by specifying the spec.backoffLimit field in the Job mani-\nfest. If you don\u0027t explicitly specify it, it defaults to 6.\n4.6\nScheduling Jobs to run periodically or once \nin the future\nJob resources run their pods immediately when you create the Job resource. But many\nbatch jobs need to be run at a specific time in the future or repeatedly in the specified\ninterval. In Linux- and UNIX-like operating systems, these jobs are better known as\ncron jobs. Kubernetes supports them, too.\n A cron job in Kubernetes is configured by creating a CronJob resource. The\nschedule for running the job is specified in the well-known cron format, so if you\u2019re\nfamiliar with regular cron jobs, you\u2019ll understand Kubernetes\u2019 CronJobs in a matter\nof seconds.\n At the configured time, Kubernetes will create a Job resource according to the Job\ntemplate configured in the CronJob object. When the Job resource is created, one or\nmore pod replicas will be created and started according to the Job\u2019s pod template, as\nyou learned in the previous section. There\u2019s nothing more to it.\n Let\u2019s look at how to create CronJobs. \n4.6.1\nCreating a CronJob\nImagine you need to run the batch job from your previous example every 15 minutes.\nTo do that, create a CronJob resource with the following specification.\n \n \n", "shape": "dot", "size": 10, "title": "116\nCHAPTER 4\nReplication and other controllers: deploying managed pods\nSCALING A JOB\nYou can even change a Job\u2019s parallelism property while the Job is running. This is\nsimilar to scaling a ReplicaSet or ReplicationController, and can be done with the\nkubectl scale command:\n$ kubectl scale job multi-completion-batch-job --replicas 3\njob \"multi-completion-batch-job\" scaled\nBecause you\u2019ve increased parallelism from 2 to 3, another pod is immediately spun\nup, so three pods are now running.\n4.5.5\nLimiting the time allowed for a Job pod to complete\nWe need to discuss one final thing about Jobs. How long should the Job wait for a pod\nto finish? What if the pod gets stuck and can\u2019t finish at all (or it can\u2019t finish fast\nenough)?\n A pod\u2019s time can be limited by setting the activeDeadlineSeconds property in the\npod spec. If the pod runs longer than that, the system will try to terminate it and will\nmark the Job as failed. \nNOTE\nYou can configure how many times a Job can be retried before it is\nmarked as failed by specifying the spec.backoffLimit field in the Job mani-\nfest. If you don\u0027t explicitly specify it, it defaults to 6.\n4.6\nScheduling Jobs to run periodically or once \nin the future\nJob resources run their pods immediately when you create the Job resource. But many\nbatch jobs need to be run at a specific time in the future or repeatedly in the specified\ninterval. In Linux- and UNIX-like operating systems, these jobs are better known as\ncron jobs. Kubernetes supports them, too.\n A cron job in Kubernetes is configured by creating a CronJob resource. The\nschedule for running the job is specified in the well-known cron format, so if you\u2019re\nfamiliar with regular cron jobs, you\u2019ll understand Kubernetes\u2019 CronJobs in a matter\nof seconds.\n At the configured time, Kubernetes will create a Job resource according to the Job\ntemplate configured in the CronJob object. When the Job resource is created, one or\nmore pod replicas will be created and started according to the Job\u2019s pod template, as\nyou learned in the previous section. There\u2019s nothing more to it.\n Let\u2019s look at how to create CronJobs. \n4.6.1\nCreating a CronJob\nImagine you need to run the batch job from your previous example every 15 minutes.\nTo do that, create a CronJob resource with the following specification.\n \n \n"}, {"color": "green", "id": "text_60", "label": "117\nScheduling Jobs to run periodically or once in the future\napiVersion: batch/v1beta1               \nkind: CronJob\nmetadata:\n  name: batch-job-every-fifteen-minutes\nspec:\n  schedule: \"0,15,30,45 * * * *\"           \n  jobTemplate:\n    spec:\n      template:                            \n        metadata:                          \n          labels:                          \n            app: periodic-batch-job        \n        spec:                              \n          restartPolicy: OnFailure         \n          containers:                      \n          - name: main                     \n            image: luksa/batch-job         \nAs you can see, it\u2019s not too complicated. You\u2019ve specified a schedule and a template\nfrom which the Job objects will be created. \nCONFIGURING THE SCHEDULE\nIf you\u2019re unfamiliar with the cron schedule format, you\u2019ll find great tutorials and\nexplanations online, but as a quick introduction, from left to right, the schedule con-\ntains the following five entries:\n\uf0a1Minute\n\uf0a1Hour\n\uf0a1Day of month\n\uf0a1Month\n\uf0a1Day of week.\nIn the example, you want to run the job every 15 minutes, so the schedule needs to be\n\"0,15,30,45 * * * *\", which means at the 0, 15, 30 and 45 minutes mark of every hour\n(first asterisk), of every day of the month (second asterisk), of every month (third\nasterisk) and on every day of the week (fourth asterisk). \n If, instead, you wanted it to run every 30 minutes, but only on the first day of the\nmonth, you\u2019d set the schedule to \"0,30 * 1 * *\", and if you want it to run at 3AM every\nSunday, you\u2019d set it to \"0 3 * * 0\" (the last zero stands for Sunday).\nCONFIGURING THE JOB TEMPLATE\nA CronJob creates Job resources from the jobTemplate property configured in the\nCronJob spec, so refer to section 4.5 for more information on how to configure it.\n4.6.2\nUnderstanding how scheduled jobs are run\nJob resources will be created from the CronJob resource at approximately the sched-\nuled time. The Job then creates the pods. \nListing 4.14\nYAML for a CronJob resource: cronjob.yaml\nAPI group is batch, \nversion is v1beta1\nThis job should run at the \n0, 15, 30 and 45 minutes of \nevery hour, every day.\nThe template for the \nJob resources that \nwill be created by \nthis CronJob\n \n", "shape": "dot", "size": 10, "title": "117\nScheduling Jobs to run periodically or once in the future\napiVersion: batch/v1beta1               \nkind: CronJob\nmetadata:\n  name: batch-job-every-fifteen-minutes\nspec:\n  schedule: \"0,15,30,45 * * * *\"           \n  jobTemplate:\n    spec:\n      template:                            \n        metadata:                          \n          labels:                          \n            app: periodic-batch-job        \n        spec:                              \n          restartPolicy: OnFailure         \n          containers:                      \n          - name: main                     \n            image: luksa/batch-job         \nAs you can see, it\u2019s not too complicated. You\u2019ve specified a schedule and a template\nfrom which the Job objects will be created. \nCONFIGURING THE SCHEDULE\nIf you\u2019re unfamiliar with the cron schedule format, you\u2019ll find great tutorials and\nexplanations online, but as a quick introduction, from left to right, the schedule con-\ntains the following five entries:\n\uf0a1Minute\n\uf0a1Hour\n\uf0a1Day of month\n\uf0a1Month\n\uf0a1Day of week.\nIn the example, you want to run the job every 15 minutes, so the schedule needs to be\n\"0,15,30,45 * * * *\", which means at the 0, 15, 30 and 45 minutes mark of every hour\n(first asterisk), of every day of the month (second asterisk), of every month (third\nasterisk) and on every day of the week (fourth asterisk). \n If, instead, you wanted it to run every 30 minutes, but only on the first day of the\nmonth, you\u2019d set the schedule to \"0,30 * 1 * *\", and if you want it to run at 3AM every\nSunday, you\u2019d set it to \"0 3 * * 0\" (the last zero stands for Sunday).\nCONFIGURING THE JOB TEMPLATE\nA CronJob creates Job resources from the jobTemplate property configured in the\nCronJob spec, so refer to section 4.5 for more information on how to configure it.\n4.6.2\nUnderstanding how scheduled jobs are run\nJob resources will be created from the CronJob resource at approximately the sched-\nuled time. The Job then creates the pods. \nListing 4.14\nYAML for a CronJob resource: cronjob.yaml\nAPI group is batch, \nversion is v1beta1\nThis job should run at the \n0, 15, 30 and 45 minutes of \nevery hour, every day.\nThe template for the \nJob resources that \nwill be created by \nthis CronJob\n \n"}, {"color": "green", "id": "text_61", "label": "118\nCHAPTER 4\nReplication and other controllers: deploying managed pods\n It may happen that the Job or pod is created and run relatively late. You may have\na hard requirement for the job to not be started too far over the scheduled time. In\nthat case, you can specify a deadline by specifying the startingDeadlineSeconds field\nin the CronJob specification as shown in the following listing.\napiVersion: batch/v1beta1\nkind: CronJob\nspec:\n  schedule: \"0,15,30,45 * * * *\"\n  startingDeadlineSeconds: 15    \n  ...\nIn the example in listing 4.15, one of the times the job is supposed to run is 10:30:00.\nIf it doesn\u2019t start by 10:30:15 for whatever reason, the job will not run and will be\nshown as Failed. \n In normal circumstances, a CronJob always creates only a single Job for each exe-\ncution configured in the schedule, but it may happen that two Jobs are created at the\nsame time, or none at all. To combat the first problem, your jobs should be idempo-\ntent (running them multiple times instead of once shouldn\u2019t lead to unwanted\nresults). For the second problem, make sure that the next job run performs any work\nthat should have been done by the previous (missed) run.\n4.7\nSummary\nYou\u2019ve now learned how to keep pods running and have them rescheduled in the\nevent of node failures. You should now know that\n\uf0a1You can specify a liveness probe to have Kubernetes restart your container as\nsoon as it\u2019s no longer healthy (where the app defines what\u2019s considered\nhealthy).\n\uf0a1Pods shouldn\u2019t be created directly, because they will not be re-created if they\u2019re\ndeleted by mistake, if the node they\u2019re running on fails, or if they\u2019re evicted\nfrom the node.\n\uf0a1ReplicationControllers always keep the desired number of pod replicas\nrunning.\n\uf0a1Scaling pods horizontally is as easy as changing the desired replica count on a\nReplicationController.\n\uf0a1Pods aren\u2019t owned by the ReplicationControllers and can be moved between\nthem if necessary.\n\uf0a1A ReplicationController creates new pods from a pod template. Changing the\ntemplate has no effect on existing pods.\nListing 4.15\nSpecifying a startingDeadlineSeconds for a CronJob\nAt the latest, the pod must \nstart running at 15 seconds \npast the scheduled time.\n \n", "shape": "dot", "size": 10, "title": "118\nCHAPTER 4\nReplication and other controllers: deploying managed pods\n It may happen that the Job or pod is created and run relatively late. You may have\na hard requirement for the job to not be started too far over the scheduled time. In\nthat case, you can specify a deadline by specifying the startingDeadlineSeconds field\nin the CronJob specification as shown in the following listing.\napiVersion: batch/v1beta1\nkind: CronJob\nspec:\n  schedule: \"0,15,30,45 * * * *\"\n  startingDeadlineSeconds: 15    \n  ...\nIn the example in listing 4.15, one of the times the job is supposed to run is 10:30:00.\nIf it doesn\u2019t start by 10:30:15 for whatever reason, the job will not run and will be\nshown as Failed. \n In normal circumstances, a CronJob always creates only a single Job for each exe-\ncution configured in the schedule, but it may happen that two Jobs are created at the\nsame time, or none at all. To combat the first problem, your jobs should be idempo-\ntent (running them multiple times instead of once shouldn\u2019t lead to unwanted\nresults). For the second problem, make sure that the next job run performs any work\nthat should have been done by the previous (missed) run.\n4.7\nSummary\nYou\u2019ve now learned how to keep pods running and have them rescheduled in the\nevent of node failures. You should now know that\n\uf0a1You can specify a liveness probe to have Kubernetes restart your container as\nsoon as it\u2019s no longer healthy (where the app defines what\u2019s considered\nhealthy).\n\uf0a1Pods shouldn\u2019t be created directly, because they will not be re-created if they\u2019re\ndeleted by mistake, if the node they\u2019re running on fails, or if they\u2019re evicted\nfrom the node.\n\uf0a1ReplicationControllers always keep the desired number of pod replicas\nrunning.\n\uf0a1Scaling pods horizontally is as easy as changing the desired replica count on a\nReplicationController.\n\uf0a1Pods aren\u2019t owned by the ReplicationControllers and can be moved between\nthem if necessary.\n\uf0a1A ReplicationController creates new pods from a pod template. Changing the\ntemplate has no effect on existing pods.\nListing 4.15\nSpecifying a startingDeadlineSeconds for a CronJob\nAt the latest, the pod must \nstart running at 15 seconds \npast the scheduled time.\n \n"}, {"color": "green", "id": "text_62", "label": "119\nSummary\n\uf0a1ReplicationControllers should be replaced with ReplicaSets and Deployments,\nwhich provide the same functionality, but with additional powerful features.\n\uf0a1ReplicationControllers and ReplicaSets schedule pods to random cluster nodes,\nwhereas DaemonSets make sure every node runs a single instance of a pod\ndefined in the DaemonSet.\n\uf0a1Pods that perform a batch task should be created through a Kubernetes Job\nresource, not directly or through a ReplicationController or similar object.\n\uf0a1Jobs that need to run sometime in the future can be created through CronJob\nresources. \n \n", "shape": "dot", "size": 10, "title": "119\nSummary\n\uf0a1ReplicationControllers should be replaced with ReplicaSets and Deployments,\nwhich provide the same functionality, but with additional powerful features.\n\uf0a1ReplicationControllers and ReplicaSets schedule pods to random cluster nodes,\nwhereas DaemonSets make sure every node runs a single instance of a pod\ndefined in the DaemonSet.\n\uf0a1Pods that perform a batch task should be created through a Kubernetes Job\nresource, not directly or through a ReplicationController or similar object.\n\uf0a1Jobs that need to run sometime in the future can be created through CronJob\nresources. \n \n"}, {"color": "green", "id": "text_63", "label": "120\nServices: enabling\nclients to discover\nand talk to pods\nYou\u2019ve learned about pods and how to deploy them through ReplicaSets and similar\nresources to ensure they keep running. Although certain pods can do their work\nindependently of an external stimulus, many applications these days are meant to\nrespond to external requests. For example, in the case of microservices, pods will\nusually respond to HTTP requests coming either from other pods inside the cluster\nor from clients outside the cluster. \n Pods need a way of finding other pods if they want to consume the services they\nprovide. Unlike in the non-Kubernetes world, where a sysadmin would configure\nThis chapter covers\n\uf0a1Creating Service resources to expose a group of \npods at a single address\n\uf0a1Discovering services in the cluster\n\uf0a1Exposing services to external clients\n\uf0a1Connecting to external services from inside the \ncluster\n\uf0a1Controlling whether a pod is ready to be part of \nthe service or not\n\uf0a1Troubleshooting services\n \n", "shape": "dot", "size": 10, "title": "120\nServices: enabling\nclients to discover\nand talk to pods\nYou\u2019ve learned about pods and how to deploy them through ReplicaSets and similar\nresources to ensure they keep running. Although certain pods can do their work\nindependently of an external stimulus, many applications these days are meant to\nrespond to external requests. For example, in the case of microservices, pods will\nusually respond to HTTP requests coming either from other pods inside the cluster\nor from clients outside the cluster. \n Pods need a way of finding other pods if they want to consume the services they\nprovide. Unlike in the non-Kubernetes world, where a sysadmin would configure\nThis chapter covers\n\uf0a1Creating Service resources to expose a group of \npods at a single address\n\uf0a1Discovering services in the cluster\n\uf0a1Exposing services to external clients\n\uf0a1Connecting to external services from inside the \ncluster\n\uf0a1Controlling whether a pod is ready to be part of \nthe service or not\n\uf0a1Troubleshooting services\n \n"}, {"color": "green", "id": "text_64", "label": "121\nIntroducing services\neach client app by specifying the exact IP address or hostname of the server providing\nthe service in the client\u2019s configuration files, doing the same in Kubernetes wouldn\u2019t\nwork, because\n\uf0a1Pods are ephemeral\u2014They may come and go at any time, whether it\u2019s because a\npod is removed from a node to make room for other pods, because someone\nscaled down the number of pods, or because a cluster node has failed.\n\uf0a1Kubernetes assigns an IP address to a pod after the pod has been scheduled to a node\nand before it\u2019s started\u2014Clients thus can\u2019t know the IP address of the server pod\nup front.\n\uf0a1Horizontal scaling means multiple pods may provide the same service\u2014Each of those\npods has its own IP address. Clients shouldn\u2019t care how many pods are backing\nthe service and what their IPs are. They shouldn\u2019t have to keep a list of all the\nindividual IPs of pods. Instead, all those pods should be accessible through a\nsingle IP address.\nTo solve these problems, Kubernetes also provides another resource type\u2014Services\u2014\nthat we\u2019ll discuss in this chapter.\n5.1\nIntroducing services\nA Kubernetes Service is a resource you create to make a single, constant point of\nentry to a group of pods providing the same service. Each service has an IP address\nand port that never change while the service exists. Clients can open connections to\nthat IP and port, and those connections are then routed to one of the pods backing\nthat service. This way, clients of a service don\u2019t need to know the location of individ-\nual pods providing the service, allowing those pods to be moved around the cluster\nat any time. \nEXPLAINING SERVICES WITH AN EXAMPLE\nLet\u2019s revisit the example where you have a frontend web server and a backend data-\nbase server. There may be multiple pods that all act as the frontend, but there may\nonly be a single backend database pod. You need to solve two problems to make the\nsystem function:\n\uf0a1External clients need to connect to the frontend pods without caring if there\u2019s\nonly a single web server or hundreds.\n\uf0a1The frontend pods need to connect to the backend database. Because the data-\nbase runs inside a pod, it may be moved around the cluster over time, causing\nits IP address to change. You don\u2019t want to reconfigure the frontend pods every\ntime the backend database is moved.\nBy creating a service for the frontend pods and configuring it to be accessible from\noutside the cluster, you expose a single, constant IP address through which external\nclients can connect to the pods. Similarly, by also creating a service for the backend\npod, you create a stable address for the backend pod. The service address doesn\u2019t\n \n", "shape": "dot", "size": 10, "title": "121\nIntroducing services\neach client app by specifying the exact IP address or hostname of the server providing\nthe service in the client\u2019s configuration files, doing the same in Kubernetes wouldn\u2019t\nwork, because\n\uf0a1Pods are ephemeral\u2014They may come and go at any time, whether it\u2019s because a\npod is removed from a node to make room for other pods, because someone\nscaled down the number of pods, or because a cluster node has failed.\n\uf0a1Kubernetes assigns an IP address to a pod after the pod has been scheduled to a node\nand before it\u2019s started\u2014Clients thus can\u2019t know the IP address of the server pod\nup front.\n\uf0a1Horizontal scaling means multiple pods may provide the same service\u2014Each of those\npods has its own IP address. Clients shouldn\u2019t care how many pods are backing\nthe service and what their IPs are. They shouldn\u2019t have to keep a list of all the\nindividual IPs of pods. Instead, all those pods should be accessible through a\nsingle IP address.\nTo solve these problems, Kubernetes also provides another resource type\u2014Services\u2014\nthat we\u2019ll discuss in this chapter.\n5.1\nIntroducing services\nA Kubernetes Service is a resource you create to make a single, constant point of\nentry to a group of pods providing the same service. Each service has an IP address\nand port that never change while the service exists. Clients can open connections to\nthat IP and port, and those connections are then routed to one of the pods backing\nthat service. This way, clients of a service don\u2019t need to know the location of individ-\nual pods providing the service, allowing those pods to be moved around the cluster\nat any time. \nEXPLAINING SERVICES WITH AN EXAMPLE\nLet\u2019s revisit the example where you have a frontend web server and a backend data-\nbase server. There may be multiple pods that all act as the frontend, but there may\nonly be a single backend database pod. You need to solve two problems to make the\nsystem function:\n\uf0a1External clients need to connect to the frontend pods without caring if there\u2019s\nonly a single web server or hundreds.\n\uf0a1The frontend pods need to connect to the backend database. Because the data-\nbase runs inside a pod, it may be moved around the cluster over time, causing\nits IP address to change. You don\u2019t want to reconfigure the frontend pods every\ntime the backend database is moved.\nBy creating a service for the frontend pods and configuring it to be accessible from\noutside the cluster, you expose a single, constant IP address through which external\nclients can connect to the pods. Similarly, by also creating a service for the backend\npod, you create a stable address for the backend pod. The service address doesn\u2019t\n \n"}, {"color": "green", "id": "text_65", "label": "122\nCHAPTER 5\nServices: enabling clients to discover and talk to pods\nchange even if the pod\u2019s IP address changes. Additionally, by creating the service, you\nalso enable the frontend pods to easily find the backend service by its name through\neither environment variables or DNS. All the components of your system (the two ser-\nvices, the two sets of pods backing those services, and the interdependencies between\nthem) are shown in figure 5.1.\nYou now understand the basic idea behind services. Now, let\u2019s dig deeper by first see-\ning how they can be created.\n5.1.1\nCreating services\nAs you\u2019ve seen, a service can be backed by more than one pod. Connections to the ser-\nvice are load-balanced across all the backing pods. But how exactly do you define\nwhich pods are part of the service and which aren\u2019t? \n You probably remember label selectors and how they\u2019re used in Replication-\nControllers and other pod controllers to specify which pods belong to the same set.\nThe same mechanism is used by services in the same way, as you can see in figure 5.2.\n In the previous chapter, you created a ReplicationController which then ran three\ninstances of the pod containing the Node.js app. Create the ReplicationController\nagain and verify three pod instances are up and running. After that, you\u2019ll create a\nService for those three pods. \nFrontend pod 1\nIP: 2.1.1.1\nExternal client\nFrontend pod 2\nIP: 2.1.1.2\nFrontend pod 3\nIP: 2.1.1.3\nBackend pod\nIP: 2.1.1.4\nFrontend service\nIP: 1.1.1.1\nBackend service\nIP: 1.1.1.2\nFrontend components\nBackend components\nFigure 5.1\nBoth internal and external clients usually connect to pods through services.\n \n", "shape": "dot", "size": 10, "title": "122\nCHAPTER 5\nServices: enabling clients to discover and talk to pods\nchange even if the pod\u2019s IP address changes. Additionally, by creating the service, you\nalso enable the frontend pods to easily find the backend service by its name through\neither environment variables or DNS. All the components of your system (the two ser-\nvices, the two sets of pods backing those services, and the interdependencies between\nthem) are shown in figure 5.1.\nYou now understand the basic idea behind services. Now, let\u2019s dig deeper by first see-\ning how they can be created.\n5.1.1\nCreating services\nAs you\u2019ve seen, a service can be backed by more than one pod. Connections to the ser-\nvice are load-balanced across all the backing pods. But how exactly do you define\nwhich pods are part of the service and which aren\u2019t? \n You probably remember label selectors and how they\u2019re used in Replication-\nControllers and other pod controllers to specify which pods belong to the same set.\nThe same mechanism is used by services in the same way, as you can see in figure 5.2.\n In the previous chapter, you created a ReplicationController which then ran three\ninstances of the pod containing the Node.js app. Create the ReplicationController\nagain and verify three pod instances are up and running. After that, you\u2019ll create a\nService for those three pods. \nFrontend pod 1\nIP: 2.1.1.1\nExternal client\nFrontend pod 2\nIP: 2.1.1.2\nFrontend pod 3\nIP: 2.1.1.3\nBackend pod\nIP: 2.1.1.4\nFrontend service\nIP: 1.1.1.1\nBackend service\nIP: 1.1.1.2\nFrontend components\nBackend components\nFigure 5.1\nBoth internal and external clients usually connect to pods through services.\n \n"}, {"color": "green", "id": "text_66", "label": "123\nIntroducing services\nCREATING A SERVICE THROUGH KUBECTL EXPOSE\nThe easiest way to create a service is through kubectl expose, which you\u2019ve already\nused in chapter 2 to expose the ReplicationController you created earlier. The\nexpose command created a Service resource with the same pod selector as the one\nused by the ReplicationController, thereby exposing all its pods through a single IP\naddress and port. \n Now, instead of using the expose command, you\u2019ll create a service manually by\nposting a YAML to the Kubernetes API server. \nCREATING A SERVICE THROUGH A YAML DESCRIPTOR\nCreate a file called kubia-svc.yaml with the following listing\u2019s contents.\napiVersion: v1\nkind: Service             \nmetadata:\n  name: kubia              \nspec:\n  ports:\n  - port: 80              \n    targetPort: 8080       \n  selector:                 \n    app: kubia              \nYou\u2019re defining a service called kubia, which will accept connections on port 80 and\nroute each connection to port 8080 of one of the pods matching the app=kubia\nlabel selector. \n Go ahead and create the service by posting the file using kubectl create.\nListing 5.1\nA definition of a service: kubia-svc.yaml\napp: kubia\nPod: kubia-q3vkg\nPod: kubia-k0xz6\nPod: kubia-53thy\nClient\nService: kubia\nSelector: app=kubia\napp: kubia\napp: kubia\nFigure 5.2\nLabel selectors \ndetermine which pods belong \nto the Service.\nThe port this service \nwill be available on\nThe container port the \nservice will forward to\nAll pods with the app=kubia \nlabel will be part of this service.\n \n", "shape": "dot", "size": 10, "title": "123\nIntroducing services\nCREATING A SERVICE THROUGH KUBECTL EXPOSE\nThe easiest way to create a service is through kubectl expose, which you\u2019ve already\nused in chapter 2 to expose the ReplicationController you created earlier. The\nexpose command created a Service resource with the same pod selector as the one\nused by the ReplicationController, thereby exposing all its pods through a single IP\naddress and port. \n Now, instead of using the expose command, you\u2019ll create a service manually by\nposting a YAML to the Kubernetes API server. \nCREATING A SERVICE THROUGH A YAML DESCRIPTOR\nCreate a file called kubia-svc.yaml with the following listing\u2019s contents.\napiVersion: v1\nkind: Service             \nmetadata:\n  name: kubia              \nspec:\n  ports:\n  - port: 80              \n    targetPort: 8080       \n  selector:                 \n    app: kubia              \nYou\u2019re defining a service called kubia, which will accept connections on port 80 and\nroute each connection to port 8080 of one of the pods matching the app=kubia\nlabel selector. \n Go ahead and create the service by posting the file using kubectl create.\nListing 5.1\nA definition of a service: kubia-svc.yaml\napp: kubia\nPod: kubia-q3vkg\nPod: kubia-k0xz6\nPod: kubia-53thy\nClient\nService: kubia\nSelector: app=kubia\napp: kubia\napp: kubia\nFigure 5.2\nLabel selectors \ndetermine which pods belong \nto the Service.\nThe port this service \nwill be available on\nThe container port the \nservice will forward to\nAll pods with the app=kubia \nlabel will be part of this service.\n \n"}, {"color": "green", "id": "text_67", "label": "124\nCHAPTER 5\nServices: enabling clients to discover and talk to pods\nEXAMINING YOUR NEW SERVICE\nAfter posting the YAML, you can list all Service resources in your namespace and see\nthat an internal cluster IP has been assigned to your service:\n$ kubectl get svc\nNAME         CLUSTER-IP       EXTERNAL-IP   PORT(S)   AGE\nkubernetes   10.111.240.1     \u003cnone\u003e        443/TCP   30d\nkubia        10.111.249.153   \u003cnone\u003e        80/TCP    6m     \nThe list shows that the IP address assigned to the service is 10.111.249.153. Because\nthis is the cluster IP, it\u2019s only accessible from inside the cluster. The primary purpose\nof services is exposing groups of pods to other pods in the cluster, but you\u2019ll usually\nalso want to expose services externally. You\u2019ll see how to do that later. For now, let\u2019s\nuse your service from inside the cluster and see what it does.\nTESTING YOUR SERVICE FROM WITHIN THE CLUSTER\nYou can send requests to your service from within the cluster in a few ways:\n\uf0a1The obvious way is to create a pod that will send the request to the service\u2019s\ncluster IP and log the response. You can then examine the pod\u2019s log to see\nwhat the service\u2019s response was.\n\uf0a1You can ssh into one of the Kubernetes nodes and use the curl command.\n\uf0a1You can execute the curl command inside one of your existing pods through\nthe kubectl exec command.\nLet\u2019s go for the last option, so you also learn how to run commands in existing pods. \nREMOTELY EXECUTING COMMANDS IN RUNNING CONTAINERS\nThe kubectl exec command allows you to remotely run arbitrary commands inside\nan existing container of a pod. This comes in handy when you want to examine the\ncontents, state, and/or environment of a container. List the pods with the kubectl\nget pods command and choose one as your target for the exec command (in the fol-\nlowing example, I\u2019ve chosen the kubia-7nog1 pod as the target). You\u2019ll also need to\nobtain the cluster IP of your service (using kubectl get svc, for example). When run-\nning the following commands yourself, be sure to replace the pod name and the ser-\nvice IP with your own: \n$ kubectl exec kubia-7nog1 -- curl -s http://10.111.249.153\nYou\u2019ve hit kubia-gzwli\nIf you\u2019ve used ssh to execute commands on a remote system before, you\u2019ll recognize\nthat kubectl exec isn\u2019t much different.\n \n \n \n \nHere\u2019s your \nservice.\n \n", "shape": "dot", "size": 10, "title": "124\nCHAPTER 5\nServices: enabling clients to discover and talk to pods\nEXAMINING YOUR NEW SERVICE\nAfter posting the YAML, you can list all Service resources in your namespace and see\nthat an internal cluster IP has been assigned to your service:\n$ kubectl get svc\nNAME         CLUSTER-IP       EXTERNAL-IP   PORT(S)   AGE\nkubernetes   10.111.240.1     \u003cnone\u003e        443/TCP   30d\nkubia        10.111.249.153   \u003cnone\u003e        80/TCP    6m     \nThe list shows that the IP address assigned to the service is 10.111.249.153. Because\nthis is the cluster IP, it\u2019s only accessible from inside the cluster. The primary purpose\nof services is exposing groups of pods to other pods in the cluster, but you\u2019ll usually\nalso want to expose services externally. You\u2019ll see how to do that later. For now, let\u2019s\nuse your service from inside the cluster and see what it does.\nTESTING YOUR SERVICE FROM WITHIN THE CLUSTER\nYou can send requests to your service from within the cluster in a few ways:\n\uf0a1The obvious way is to create a pod that will send the request to the service\u2019s\ncluster IP and log the response. You can then examine the pod\u2019s log to see\nwhat the service\u2019s response was.\n\uf0a1You can ssh into one of the Kubernetes nodes and use the curl command.\n\uf0a1You can execute the curl command inside one of your existing pods through\nthe kubectl exec command.\nLet\u2019s go for the last option, so you also learn how to run commands in existing pods. \nREMOTELY EXECUTING COMMANDS IN RUNNING CONTAINERS\nThe kubectl exec command allows you to remotely run arbitrary commands inside\nan existing container of a pod. This comes in handy when you want to examine the\ncontents, state, and/or environment of a container. List the pods with the kubectl\nget pods command and choose one as your target for the exec command (in the fol-\nlowing example, I\u2019ve chosen the kubia-7nog1 pod as the target). You\u2019ll also need to\nobtain the cluster IP of your service (using kubectl get svc, for example). When run-\nning the following commands yourself, be sure to replace the pod name and the ser-\nvice IP with your own: \n$ kubectl exec kubia-7nog1 -- curl -s http://10.111.249.153\nYou\u2019ve hit kubia-gzwli\nIf you\u2019ve used ssh to execute commands on a remote system before, you\u2019ll recognize\nthat kubectl exec isn\u2019t much different.\n \n \n \n \nHere\u2019s your \nservice.\n \n"}, {"color": "green", "id": "text_68", "label": "125\nIntroducing services\nLet\u2019s go over what transpired when you ran the command. Figure 5.3 shows the\nsequence of events. You instructed Kubernetes to execute the curl command inside the\ncontainer of one of your pods. Curl sent an HTTP request to the service IP, which is\nbacked by three pods. The Kubernetes service proxy intercepted the connection,\nselected a random pod among the three pods, and forwarded the request to it. Node.js\nrunning inside that pod then handled the request and returned an HTTP response con-\ntaining the pod\u2019s name. Curl then printed the response to the standard output, which\nwas intercepted and printed to its standard output on your local machine by kubectl.\nWhy the double dash?\nThe double dash (--) in the command signals the end of command options for\nkubectl. Everything after the double dash is the command that should be executed\ninside the pod. Using the double dash isn\u2019t necessary if the command has no\narguments that start with a dash. But in your case, if you don\u2019t use the double dash\nthere, the -s option would be interpreted as an option for kubectl exec and would\nresult in the following strange and highly misleading error:\n$ kubectl exec kubia-7nog1 curl -s http://10.111.249.153\nThe connection to the server 10.111.249.153 was refused \u2013 did you \nspecify the right host or port?\nThis has nothing to do with your service refusing the connection. It\u2019s because\nkubectl is not able to connect to an API server at 10.111.249.153 (the -s option\nis used to tell kubectl to connect to a different API server than the default).\n3. Curl sends HTTP\nGET request\n4. Service redirects HTTP\nconnection to a randomly\nselected pod\n2. Curl is executed\ninside the container\nrunning node.js\n6. The output of the\ncommand is sent\ncurl\nback to kubectl and\nprinted by it\n5. HTTP response is\nsent back to curl\nPod: kubia-7nog1\nContainer\nnode.js\ncurl http://\n10.111.249.153\nPod: kubia-gzwli\nContainer\nnode.js\nPod: kubia-5fje3\nContainer\nnode.js\n1. kubectl exec\nService: kubia\n10.111.249.153:80\nFigure 5.3\nUsing kubectl exec to test out a connection to the service by running curl in one of the pods\n \n", "shape": "dot", "size": 10, "title": "125\nIntroducing services\nLet\u2019s go over what transpired when you ran the command. Figure 5.3 shows the\nsequence of events. You instructed Kubernetes to execute the curl command inside the\ncontainer of one of your pods. Curl sent an HTTP request to the service IP, which is\nbacked by three pods. The Kubernetes service proxy intercepted the connection,\nselected a random pod among the three pods, and forwarded the request to it. Node.js\nrunning inside that pod then handled the request and returned an HTTP response con-\ntaining the pod\u2019s name. Curl then printed the response to the standard output, which\nwas intercepted and printed to its standard output on your local machine by kubectl.\nWhy the double dash?\nThe double dash (--) in the command signals the end of command options for\nkubectl. Everything after the double dash is the command that should be executed\ninside the pod. Using the double dash isn\u2019t necessary if the command has no\narguments that start with a dash. But in your case, if you don\u2019t use the double dash\nthere, the -s option would be interpreted as an option for kubectl exec and would\nresult in the following strange and highly misleading error:\n$ kubectl exec kubia-7nog1 curl -s http://10.111.249.153\nThe connection to the server 10.111.249.153 was refused \u2013 did you \nspecify the right host or port?\nThis has nothing to do with your service refusing the connection. It\u2019s because\nkubectl is not able to connect to an API server at 10.111.249.153 (the -s option\nis used to tell kubectl to connect to a different API server than the default).\n3. Curl sends HTTP\nGET request\n4. Service redirects HTTP\nconnection to a randomly\nselected pod\n2. Curl is executed\ninside the container\nrunning node.js\n6. The output of the\ncommand is sent\ncurl\nback to kubectl and\nprinted by it\n5. HTTP response is\nsent back to curl\nPod: kubia-7nog1\nContainer\nnode.js\ncurl http://\n10.111.249.153\nPod: kubia-gzwli\nContainer\nnode.js\nPod: kubia-5fje3\nContainer\nnode.js\n1. kubectl exec\nService: kubia\n10.111.249.153:80\nFigure 5.3\nUsing kubectl exec to test out a connection to the service by running curl in one of the pods\n \n"}, {"color": "green", "id": "text_69", "label": "126\nCHAPTER 5\nServices: enabling clients to discover and talk to pods\nIn the previous example, you executed the curl command as a separate process, but\ninside the pod\u2019s main container. This isn\u2019t much different from the actual main pro-\ncess in the container talking to the service.\nCONFIGURING SESSION AFFINITY ON THE SERVICE\nIf you execute the same command a few more times, you should hit a different pod\nwith every invocation, because the service proxy normally forwards each connection\nto a randomly selected backing pod, even if the connections are coming from the\nsame client. \n If, on the other hand, you want all requests made by a certain client to be redi-\nrected to the same pod every time, you can set the service\u2019s sessionAffinity property\nto ClientIP (instead of None, which is the default), as shown in the following listing.\napiVersion: v1\nkind: Service             \nspec:\n  sessionAffinity: ClientIP\n  ...\nThis makes the service proxy redirect all requests originating from the same client IP\nto the same pod. As an exercise, you can create an additional service with session affin-\nity set to ClientIP and try sending requests to it.\n Kubernetes supports only two types of service session affinity: None and ClientIP.\nYou may be surprised it doesn\u2019t have a cookie-based session affinity option, but you\nneed to understand that Kubernetes services don\u2019t operate at the HTTP level. Services\ndeal with TCP and UDP packets and don\u2019t care about the payload they carry. Because\ncookies are a construct of the HTTP protocol, services don\u2019t know about them, which\nexplains why session affinity cannot be based on cookies. \nEXPOSING MULTIPLE PORTS IN THE SAME SERVICE\nYour service exposes only a single port, but services can also support multiple ports. For\nexample, if your pods listened on two ports\u2014let\u2019s say 8080 for HTTP and 8443 for\nHTTPS\u2014you could use a single service to forward both port 80 and 443 to the pod\u2019s\nports 8080 and 8443. You don\u2019t need to create two different services in such cases. Using\na single, multi-port service exposes all the service\u2019s ports through a single cluster IP.\nNOTE\nWhen creating a service with multiple ports, you must specify a name\nfor each port.\nThe spec for a multi-port service is shown in the following listing.\napiVersion: v1\nkind: Service             \nmetadata:\n  name: kubia              \nListing 5.2\nA example of a service with ClientIP session affinity configured\nListing 5.3\nSpecifying multiple ports in a service definition\n \n", "shape": "dot", "size": 10, "title": "126\nCHAPTER 5\nServices: enabling clients to discover and talk to pods\nIn the previous example, you executed the curl command as a separate process, but\ninside the pod\u2019s main container. This isn\u2019t much different from the actual main pro-\ncess in the container talking to the service.\nCONFIGURING SESSION AFFINITY ON THE SERVICE\nIf you execute the same command a few more times, you should hit a different pod\nwith every invocation, because the service proxy normally forwards each connection\nto a randomly selected backing pod, even if the connections are coming from the\nsame client. \n If, on the other hand, you want all requests made by a certain client to be redi-\nrected to the same pod every time, you can set the service\u2019s sessionAffinity property\nto ClientIP (instead of None, which is the default), as shown in the following listing.\napiVersion: v1\nkind: Service             \nspec:\n  sessionAffinity: ClientIP\n  ...\nThis makes the service proxy redirect all requests originating from the same client IP\nto the same pod. As an exercise, you can create an additional service with session affin-\nity set to ClientIP and try sending requests to it.\n Kubernetes supports only two types of service session affinity: None and ClientIP.\nYou may be surprised it doesn\u2019t have a cookie-based session affinity option, but you\nneed to understand that Kubernetes services don\u2019t operate at the HTTP level. Services\ndeal with TCP and UDP packets and don\u2019t care about the payload they carry. Because\ncookies are a construct of the HTTP protocol, services don\u2019t know about them, which\nexplains why session affinity cannot be based on cookies. \nEXPOSING MULTIPLE PORTS IN THE SAME SERVICE\nYour service exposes only a single port, but services can also support multiple ports. For\nexample, if your pods listened on two ports\u2014let\u2019s say 8080 for HTTP and 8443 for\nHTTPS\u2014you could use a single service to forward both port 80 and 443 to the pod\u2019s\nports 8080 and 8443. You don\u2019t need to create two different services in such cases. Using\na single, multi-port service exposes all the service\u2019s ports through a single cluster IP.\nNOTE\nWhen creating a service with multiple ports, you must specify a name\nfor each port.\nThe spec for a multi-port service is shown in the following listing.\napiVersion: v1\nkind: Service             \nmetadata:\n  name: kubia              \nListing 5.2\nA example of a service with ClientIP session affinity configured\nListing 5.3\nSpecifying multiple ports in a service definition\n \n"}, {"color": "green", "id": "text_70", "label": "127\nIntroducing services\nspec:\n  ports:\n  - name: http              \n    port: 80                \n    targetPort: 8080        \n  - name: https             \n    port: 443               \n    targetPort: 8443        \n  selector:                 \n    app: kubia              \nNOTE\nThe label selector applies to the service as a whole\u2014it can\u2019t be config-\nured for each port individually. If you want different ports to map to different\nsubsets of pods, you need to create two services.\nBecause your kubia pods don\u2019t listen on multiple ports, creating a multi-port service\nand a multi-port pod is left as an exercise to you.\nUSING NAMED PORTS\nIn all these examples, you\u2019ve referred to the target port by its number, but you can also\ngive a name to each pod\u2019s port and refer to it by name in the service spec. This makes\nthe service spec slightly clearer, especially if the port numbers aren\u2019t well-known.\n For example, suppose your pod defines names for its ports as shown in the follow-\ning listing.\nkind: Pod\nspec:\n  containers:\n  - name: kubia\n    ports:\n    - name: http               \n      containerPort: 8080      \n    - name: https              \n      containerPort: 8443      \nYou can then refer to those ports by name in the service spec, as shown in the follow-\ning listing.\napiVersion: v1\nkind: Service             \nspec:\n  ports:\n  - name: http              \n    port: 80                \n    targetPort: http        \n  - name: https             \n    port: 443               \n    targetPort: https       \nListing 5.4\nSpecifying port names in a pod definition\nListing 5.5\nReferring to named ports in a service\nPort 80 is mapped to \nthe pods\u2019 port 8080.\nPort 443 is mapped to \npods\u2019 port 8443.\nThe label selector always \napplies to the whole service.\nContainer\u2019s port \n8080 is called http\nPort 8443 is called https.\nPort 80 is mapped to the \ncontainer\u2019s port called http.\nPort 443 is mapped to the container\u2019s \nport, whose name is https.\n \n", "shape": "dot", "size": 10, "title": "127\nIntroducing services\nspec:\n  ports:\n  - name: http              \n    port: 80                \n    targetPort: 8080        \n  - name: https             \n    port: 443               \n    targetPort: 8443        \n  selector:                 \n    app: kubia              \nNOTE\nThe label selector applies to the service as a whole\u2014it can\u2019t be config-\nured for each port individually. If you want different ports to map to different\nsubsets of pods, you need to create two services.\nBecause your kubia pods don\u2019t listen on multiple ports, creating a multi-port service\nand a multi-port pod is left as an exercise to you.\nUSING NAMED PORTS\nIn all these examples, you\u2019ve referred to the target port by its number, but you can also\ngive a name to each pod\u2019s port and refer to it by name in the service spec. This makes\nthe service spec slightly clearer, especially if the port numbers aren\u2019t well-known.\n For example, suppose your pod defines names for its ports as shown in the follow-\ning listing.\nkind: Pod\nspec:\n  containers:\n  - name: kubia\n    ports:\n    - name: http               \n      containerPort: 8080      \n    - name: https              \n      containerPort: 8443      \nYou can then refer to those ports by name in the service spec, as shown in the follow-\ning listing.\napiVersion: v1\nkind: Service             \nspec:\n  ports:\n  - name: http              \n    port: 80                \n    targetPort: http        \n  - name: https             \n    port: 443               \n    targetPort: https       \nListing 5.4\nSpecifying port names in a pod definition\nListing 5.5\nReferring to named ports in a service\nPort 80 is mapped to \nthe pods\u2019 port 8080.\nPort 443 is mapped to \npods\u2019 port 8443.\nThe label selector always \napplies to the whole service.\nContainer\u2019s port \n8080 is called http\nPort 8443 is called https.\nPort 80 is mapped to the \ncontainer\u2019s port called http.\nPort 443 is mapped to the container\u2019s \nport, whose name is https.\n \n"}, {"color": "green", "id": "text_71", "label": "128\nCHAPTER 5\nServices: enabling clients to discover and talk to pods\nBut why should you even bother with naming ports? The biggest benefit of doing so is\nthat it enables you to change port numbers later without having to change the service\nspec. Your pod currently uses port 8080 for http, but what if you later decide you\u2019d\nlike to move that to port 80? \n If you\u2019re using named ports, all you need to do is change the port number in the\npod spec (while keeping the port\u2019s name unchanged). As you spin up pods with the\nnew ports, client connections will be forwarded to the appropriate port numbers,\ndepending on the pod receiving the connection (port 8080 on old pods and port 80\non the new ones).\n5.1.2\nDiscovering services\nBy creating a service, you now have a single and stable IP address and port that you\ncan hit to access your pods. This address will remain unchanged throughout the\nwhole lifetime of the service. Pods behind this service may come and go, their IPs may\nchange, their number can go up or down, but they\u2019ll always be accessible through the\nservice\u2019s single and constant IP address. \n But how do the client pods know the IP and port of a service? Do you need to cre-\nate the service first, then manually look up its IP address and pass the IP to the config-\nuration options of the client pod? Not really. Kubernetes also provides ways for client\npods to discover a service\u2019s IP and port.\nDISCOVERING SERVICES THROUGH ENVIRONMENT VARIABLES\nWhen a pod is started, Kubernetes initializes a set of environment variables pointing\nto each service that exists at that moment. If you create the service before creating the\nclient pods, processes in those pods can get the IP address and port of the service by\ninspecting their environment variables. \n Let\u2019s see what those environment variables look like by examining the environment\nof one of your running pods. You\u2019ve already learned that you can use the kubectl exec\ncommand to run a command in the pod, but because you created the service only\nafter your pods had been created, the environment variables for the service couldn\u2019t\nhave been set yet. You\u2019ll need to address that first.\n Before you can see environment variables for your service, you first need to delete\nall the pods and let the ReplicationController create new ones. You may remember\nyou can delete all pods without specifying their names like this:\n$ kubectl delete po --all\npod \"kubia-7nog1\" deleted\npod \"kubia-bf50t\" deleted\npod \"kubia-gzwli\" deleted\nNow you can list the new pods (I\u2019m sure you know how to do that) and pick one as\nyour target for the kubectl exec command. Once you\u2019ve selected your target pod,\nyou can list environment variables by running the env command inside the container,\nas shown in the following listing.\n \n", "shape": "dot", "size": 10, "title": "128\nCHAPTER 5\nServices: enabling clients to discover and talk to pods\nBut why should you even bother with naming ports? The biggest benefit of doing so is\nthat it enables you to change port numbers later without having to change the service\nspec. Your pod currently uses port 8080 for http, but what if you later decide you\u2019d\nlike to move that to port 80? \n If you\u2019re using named ports, all you need to do is change the port number in the\npod spec (while keeping the port\u2019s name unchanged). As you spin up pods with the\nnew ports, client connections will be forwarded to the appropriate port numbers,\ndepending on the pod receiving the connection (port 8080 on old pods and port 80\non the new ones).\n5.1.2\nDiscovering services\nBy creating a service, you now have a single and stable IP address and port that you\ncan hit to access your pods. This address will remain unchanged throughout the\nwhole lifetime of the service. Pods behind this service may come and go, their IPs may\nchange, their number can go up or down, but they\u2019ll always be accessible through the\nservice\u2019s single and constant IP address. \n But how do the client pods know the IP and port of a service? Do you need to cre-\nate the service first, then manually look up its IP address and pass the IP to the config-\nuration options of the client pod? Not really. Kubernetes also provides ways for client\npods to discover a service\u2019s IP and port.\nDISCOVERING SERVICES THROUGH ENVIRONMENT VARIABLES\nWhen a pod is started, Kubernetes initializes a set of environment variables pointing\nto each service that exists at that moment. If you create the service before creating the\nclient pods, processes in those pods can get the IP address and port of the service by\ninspecting their environment variables. \n Let\u2019s see what those environment variables look like by examining the environment\nof one of your running pods. You\u2019ve already learned that you can use the kubectl exec\ncommand to run a command in the pod, but because you created the service only\nafter your pods had been created, the environment variables for the service couldn\u2019t\nhave been set yet. You\u2019ll need to address that first.\n Before you can see environment variables for your service, you first need to delete\nall the pods and let the ReplicationController create new ones. You may remember\nyou can delete all pods without specifying their names like this:\n$ kubectl delete po --all\npod \"kubia-7nog1\" deleted\npod \"kubia-bf50t\" deleted\npod \"kubia-gzwli\" deleted\nNow you can list the new pods (I\u2019m sure you know how to do that) and pick one as\nyour target for the kubectl exec command. Once you\u2019ve selected your target pod,\nyou can list environment variables by running the env command inside the container,\nas shown in the following listing.\n \n"}, {"color": "green", "id": "text_72", "label": "129\nIntroducing services\n$ kubectl exec kubia-3inly env\nPATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin\nHOSTNAME=kubia-3inly\nKUBERNETES_SERVICE_HOST=10.111.240.1\nKUBERNETES_SERVICE_PORT=443\n...\nKUBIA_SERVICE_HOST=10.111.249.153             \nKUBIA_SERVICE_PORT=80                            \n...\nTwo services are defined in your cluster: the kubernetes and the kubia service (you\nsaw this earlier with the kubectl get svc command); consequently, two sets of service-\nrelated environment variables are in the list. Among the variables that pertain to the\nkubia service you created at the beginning of the chapter, you\u2019ll see the KUBIA_SERVICE\n_HOST and the KUBIA_SERVICE_PORT environment variables, which hold the IP address\nand port of the kubia service, respectively. \n Turning back to the frontend-backend example we started this chapter with, when\nyou have a frontend pod that requires the use of a backend database server pod, you\ncan expose the backend pod through a service called backend-database and then\nhave the frontend pod look up its IP address and port through the environment vari-\nables BACKEND_DATABASE_SERVICE_HOST and BACKEND_DATABASE_SERVICE_PORT.\nNOTE\nDashes in the service name are converted to underscores and all let-\nters are uppercased when the service name is used as the prefix in the envi-\nronment variable\u2019s name. \nEnvironment variables are one way of looking up the IP and port of a service, but isn\u2019t\nthis usually the domain of DNS? Why doesn\u2019t Kubernetes include a DNS server and\nallow you to look up service IPs through DNS instead? As it turns out, it does!\nDISCOVERING SERVICES THROUGH DNS\nRemember in chapter 3 when you listed pods in the kube-system namespace? One of\nthe pods was called kube-dns. The kube-system namespace also includes a corre-\nsponding service with the same name.\n As the name suggests, the pod runs a DNS server, which all other pods running in\nthe cluster are automatically configured to use (Kubernetes does that by modifying\neach container\u2019s /etc/resolv.conf file). Any DNS query performed by a process run-\nning in a pod will be handled by Kubernetes\u2019 own DNS server, which knows all the ser-\nvices running in your system. \nNOTE\nWhether a pod uses the internal DNS server or not is configurable\nthrough the dnsPolicy property in each pod\u2019s spec.\nEach service gets a DNS entry in the internal DNS server, and client pods that know\nthe name of the service can access it through its fully qualified domain name (FQDN)\ninstead of resorting to environment variables. \nListing 5.6\nService-related environment variables in a container\nHere\u2019s the cluster \nIP of the service.\nAnd here\u2019s the port the \nservice is available on.\n \n", "shape": "dot", "size": 10, "title": "129\nIntroducing services\n$ kubectl exec kubia-3inly env\nPATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin\nHOSTNAME=kubia-3inly\nKUBERNETES_SERVICE_HOST=10.111.240.1\nKUBERNETES_SERVICE_PORT=443\n...\nKUBIA_SERVICE_HOST=10.111.249.153             \nKUBIA_SERVICE_PORT=80                            \n...\nTwo services are defined in your cluster: the kubernetes and the kubia service (you\nsaw this earlier with the kubectl get svc command); consequently, two sets of service-\nrelated environment variables are in the list. Among the variables that pertain to the\nkubia service you created at the beginning of the chapter, you\u2019ll see the KUBIA_SERVICE\n_HOST and the KUBIA_SERVICE_PORT environment variables, which hold the IP address\nand port of the kubia service, respectively. \n Turning back to the frontend-backend example we started this chapter with, when\nyou have a frontend pod that requires the use of a backend database server pod, you\ncan expose the backend pod through a service called backend-database and then\nhave the frontend pod look up its IP address and port through the environment vari-\nables BACKEND_DATABASE_SERVICE_HOST and BACKEND_DATABASE_SERVICE_PORT.\nNOTE\nDashes in the service name are converted to underscores and all let-\nters are uppercased when the service name is used as the prefix in the envi-\nronment variable\u2019s name. \nEnvironment variables are one way of looking up the IP and port of a service, but isn\u2019t\nthis usually the domain of DNS? Why doesn\u2019t Kubernetes include a DNS server and\nallow you to look up service IPs through DNS instead? As it turns out, it does!\nDISCOVERING SERVICES THROUGH DNS\nRemember in chapter 3 when you listed pods in the kube-system namespace? One of\nthe pods was called kube-dns. The kube-system namespace also includes a corre-\nsponding service with the same name.\n As the name suggests, the pod runs a DNS server, which all other pods running in\nthe cluster are automatically configured to use (Kubernetes does that by modifying\neach container\u2019s /etc/resolv.conf file). Any DNS query performed by a process run-\nning in a pod will be handled by Kubernetes\u2019 own DNS server, which knows all the ser-\nvices running in your system. \nNOTE\nWhether a pod uses the internal DNS server or not is configurable\nthrough the dnsPolicy property in each pod\u2019s spec.\nEach service gets a DNS entry in the internal DNS server, and client pods that know\nthe name of the service can access it through its fully qualified domain name (FQDN)\ninstead of resorting to environment variables. \nListing 5.6\nService-related environment variables in a container\nHere\u2019s the cluster \nIP of the service.\nAnd here\u2019s the port the \nservice is available on.\n \n"}, {"color": "green", "id": "text_73", "label": "130\nCHAPTER 5\nServices: enabling clients to discover and talk to pods\nCONNECTING TO THE SERVICE THROUGH ITS FQDN\nTo revisit the frontend-backend example, a frontend pod can connect to the backend-\ndatabase service by opening a connection to the following FQDN:\nbackend-database.default.svc.cluster.local\nbackend-database corresponds to the service name, default stands for the name-\nspace the service is defined in, and svc.cluster.local is a configurable cluster\ndomain suffix used in all cluster local service names. \nNOTE\nThe client must still know the service\u2019s port number. If the service is\nusing a standard port (for example, 80 for HTTP or 5432 for Postgres), that\nshouldn\u2019t be a problem. If not, the client can get the port number from the\nenvironment variable.\nConnecting to a service can be even simpler than that. You can omit the svc.cluster\n.local suffix and even the namespace, when the frontend pod is in the same name-\nspace as the database pod. You can thus refer to the service simply as backend-\ndatabase. That\u2019s incredibly simple, right?\n Let\u2019s try this. You\u2019ll try to access the kubia service through its FQDN instead of its\nIP. Again, you\u2019ll need to do that inside an existing pod. You already know how to use\nkubectl exec to run a single command in a pod\u2019s container, but this time, instead of\nrunning the curl command directly, you\u2019ll run the bash shell instead, so you can then\nrun multiple commands in the container. This is similar to what you did in chapter 2\nwhen you entered the container you ran with Docker by using the docker exec -it\nbash command. \nRUNNING A SHELL IN A POD\u2019S CONTAINER\nYou can use the kubectl exec command to run bash (or any other shell) inside a\npod\u2019s container. This way you\u2019re free to explore the container as long as you want,\nwithout having to perform a kubectl exec for every command you want to run.\nNOTE\nThe shell\u2019s binary executable must be available in the container image\nfor this to work.\nTo use the shell properly, you need to pass the -it option to kubectl exec:\n$ kubectl exec -it kubia-3inly bash\nroot@kubia-3inly:/# \nYou\u2019re now inside the container. You can use the curl command to access the kubia\nservice in any of the following ways:\nroot@kubia-3inly:/# curl http://kubia.default.svc.cluster.local\nYou\u2019ve hit kubia-5asi2\nroot@kubia-3inly:/# curl http://kubia.default\nYou\u2019ve hit kubia-3inly\n \n", "shape": "dot", "size": 10, "title": "130\nCHAPTER 5\nServices: enabling clients to discover and talk to pods\nCONNECTING TO THE SERVICE THROUGH ITS FQDN\nTo revisit the frontend-backend example, a frontend pod can connect to the backend-\ndatabase service by opening a connection to the following FQDN:\nbackend-database.default.svc.cluster.local\nbackend-database corresponds to the service name, default stands for the name-\nspace the service is defined in, and svc.cluster.local is a configurable cluster\ndomain suffix used in all cluster local service names. \nNOTE\nThe client must still know the service\u2019s port number. If the service is\nusing a standard port (for example, 80 for HTTP or 5432 for Postgres), that\nshouldn\u2019t be a problem. If not, the client can get the port number from the\nenvironment variable.\nConnecting to a service can be even simpler than that. You can omit the svc.cluster\n.local suffix and even the namespace, when the frontend pod is in the same name-\nspace as the database pod. You can thus refer to the service simply as backend-\ndatabase. That\u2019s incredibly simple, right?\n Let\u2019s try this. You\u2019ll try to access the kubia service through its FQDN instead of its\nIP. Again, you\u2019ll need to do that inside an existing pod. You already know how to use\nkubectl exec to run a single command in a pod\u2019s container, but this time, instead of\nrunning the curl command directly, you\u2019ll run the bash shell instead, so you can then\nrun multiple commands in the container. This is similar to what you did in chapter 2\nwhen you entered the container you ran with Docker by using the docker exec -it\nbash command. \nRUNNING A SHELL IN A POD\u2019S CONTAINER\nYou can use the kubectl exec command to run bash (or any other shell) inside a\npod\u2019s container. This way you\u2019re free to explore the container as long as you want,\nwithout having to perform a kubectl exec for every command you want to run.\nNOTE\nThe shell\u2019s binary executable must be available in the container image\nfor this to work.\nTo use the shell properly, you need to pass the -it option to kubectl exec:\n$ kubectl exec -it kubia-3inly bash\nroot@kubia-3inly:/# \nYou\u2019re now inside the container. You can use the curl command to access the kubia\nservice in any of the following ways:\nroot@kubia-3inly:/# curl http://kubia.default.svc.cluster.local\nYou\u2019ve hit kubia-5asi2\nroot@kubia-3inly:/# curl http://kubia.default\nYou\u2019ve hit kubia-3inly\n \n"}, {"color": "green", "id": "text_74", "label": "131\nConnecting to services living outside the cluster\nroot@kubia-3inly:/# curl http://kubia\nYou\u2019ve hit kubia-8awf3\nYou can hit your service by using the service\u2019s name as the hostname in the requested\nURL. You can omit the namespace and the svc.cluster.local suffix because of how\nthe DNS resolver inside each pod\u2019s container is configured. Look at the /etc/resolv.conf\nfile in the container and you\u2019ll understand:\nroot@kubia-3inly:/# cat /etc/resolv.conf\nsearch default.svc.cluster.local svc.cluster.local cluster.local ...\nUNDERSTANDING WHY YOU CAN\u2019T PING A SERVICE IP\nOne last thing before we move on. You know how to create services now, so you\u2019ll soon\ncreate your own. But what if, for whatever reason, you can\u2019t access your service?\n You\u2019ll probably try to figure out what\u2019s wrong by entering an existing pod and try-\ning to access the service like you did in the last example. Then, if you still can\u2019t access\nthe service with a simple curl command, maybe you\u2019ll try to ping the service IP to see\nif it\u2019s up. Let\u2019s try that now:\nroot@kubia-3inly:/# ping kubia\nPING kubia.default.svc.cluster.local (10.111.249.153): 56 data bytes\n^C--- kubia.default.svc.cluster.local ping statistics ---\n54 packets transmitted, 0 packets received, 100% packet loss\nHmm. curl-ing the service works, but pinging it doesn\u2019t. That\u2019s because the service\u2019s\ncluster IP is a virtual IP, and only has meaning when combined with the service port.\nWe\u2019ll explain what that means and how services work in chapter 11. I wanted to men-\ntion that here because it\u2019s the first thing users do when they try to debug a broken\nservice and it catches most of them off guard.\n5.2\nConnecting to services living outside the cluster\nUp to now, we\u2019ve talked about services backed by one or more pods running inside\nthe cluster. But cases exist when you\u2019d like to expose external services through the\nKubernetes services feature. Instead of having the service redirect connections to\npods in the cluster, you want it to redirect to external IP(s) and port(s). \n This allows you to take advantage of both service load balancing and service discov-\nery. Client pods running in the cluster can connect to the external service like they\nconnect to internal services.\n5.2.1\nIntroducing service endpoints\nBefore going into how to do this, let me first shed more light on services. Services\ndon\u2019t link to pods directly. Instead, a resource sits in between\u2014the Endpoints\nresource. You may have already noticed endpoints if you used the kubectl describe\ncommand on your service, as shown in the following listing.\n \n", "shape": "dot", "size": 10, "title": "131\nConnecting to services living outside the cluster\nroot@kubia-3inly:/# curl http://kubia\nYou\u2019ve hit kubia-8awf3\nYou can hit your service by using the service\u2019s name as the hostname in the requested\nURL. You can omit the namespace and the svc.cluster.local suffix because of how\nthe DNS resolver inside each pod\u2019s container is configured. Look at the /etc/resolv.conf\nfile in the container and you\u2019ll understand:\nroot@kubia-3inly:/# cat /etc/resolv.conf\nsearch default.svc.cluster.local svc.cluster.local cluster.local ...\nUNDERSTANDING WHY YOU CAN\u2019T PING A SERVICE IP\nOne last thing before we move on. You know how to create services now, so you\u2019ll soon\ncreate your own. But what if, for whatever reason, you can\u2019t access your service?\n You\u2019ll probably try to figure out what\u2019s wrong by entering an existing pod and try-\ning to access the service like you did in the last example. Then, if you still can\u2019t access\nthe service with a simple curl command, maybe you\u2019ll try to ping the service IP to see\nif it\u2019s up. Let\u2019s try that now:\nroot@kubia-3inly:/# ping kubia\nPING kubia.default.svc.cluster.local (10.111.249.153): 56 data bytes\n^C--- kubia.default.svc.cluster.local ping statistics ---\n54 packets transmitted, 0 packets received, 100% packet loss\nHmm. curl-ing the service works, but pinging it doesn\u2019t. That\u2019s because the service\u2019s\ncluster IP is a virtual IP, and only has meaning when combined with the service port.\nWe\u2019ll explain what that means and how services work in chapter 11. I wanted to men-\ntion that here because it\u2019s the first thing users do when they try to debug a broken\nservice and it catches most of them off guard.\n5.2\nConnecting to services living outside the cluster\nUp to now, we\u2019ve talked about services backed by one or more pods running inside\nthe cluster. But cases exist when you\u2019d like to expose external services through the\nKubernetes services feature. Instead of having the service redirect connections to\npods in the cluster, you want it to redirect to external IP(s) and port(s). \n This allows you to take advantage of both service load balancing and service discov-\nery. Client pods running in the cluster can connect to the external service like they\nconnect to internal services.\n5.2.1\nIntroducing service endpoints\nBefore going into how to do this, let me first shed more light on services. Services\ndon\u2019t link to pods directly. Instead, a resource sits in between\u2014the Endpoints\nresource. You may have already noticed endpoints if you used the kubectl describe\ncommand on your service, as shown in the following listing.\n \n"}, {"color": "green", "id": "text_75", "label": "132\nCHAPTER 5\nServices: enabling clients to discover and talk to pods\n$ kubectl describe svc kubia\nName:                kubia\nNamespace:           default\nLabels:              \u003cnone\u003e\nSelector:            app=kubia         \nType:                ClusterIP\nIP:                  10.111.249.153\nPort:                \u003cunset\u003e 80/TCP\nEndpoints:           10.108.1.4:8080,10.108.2.5:8080,10.108.2.6:8080   \nSession Affinity:    None\nNo events.\nAn Endpoints resource (yes, plural) is a list of IP addresses and ports exposing a ser-\nvice. The Endpoints resource is like any other Kubernetes resource, so you can display\nits basic info with kubectl get:\n$ kubectl get endpoints kubia\nNAME    ENDPOINTS                                         AGE\nkubia   10.108.1.4:8080,10.108.2.5:8080,10.108.2.6:8080   1h\nAlthough the pod selector is defined in the service spec, it\u2019s not used directly when\nredirecting incoming connections. Instead, the selector is used to build a list of IPs\nand ports, which is then stored in the Endpoints resource. When a client connects to a\nservice, the service proxy selects one of those IP and port pairs and redirects the\nincoming connection to the server listening at that location.\n5.2.2\nManually configuring service endpoints\nYou may have probably realized this already, but having the service\u2019s endpoints decou-\npled from the service allows them to be configured and updated manually. \n If you create a service without a pod selector, Kubernetes won\u2019t even create the\nEndpoints resource (after all, without a selector, it can\u2019t know which pods to include\nin the service). It\u2019s up to you to create the Endpoints resource to specify the list of\nendpoints for the service.\n To create a service with manually managed endpoints, you need to create both a\nService and an Endpoints resource. \nCREATING A SERVICE WITHOUT A SELECTOR\nYou\u2019ll first create the YAML for the service itself, as shown in the following listing.\napiVersion: v1\nkind: Service\nmetadata:\n  name: external-service     \nspec:                       \n  ports:\n  - port: 80                  \nListing 5.7\nFull details of a service displayed with kubectl describe\nListing 5.8\nA service without a pod selector: external-service.yaml\nThe service\u2019s pod \nselector is used to \ncreate the list of \nendpoints.\nThe list of pod\nIPs and ports\nthat represent\nthe endpoints of\nthis service\nThe name of the service must \nmatch the name of the Endpoints \nobject (see next listing).\nThis service has no \nselector defined.\n \n", "shape": "dot", "size": 10, "title": "132\nCHAPTER 5\nServices: enabling clients to discover and talk to pods\n$ kubectl describe svc kubia\nName:                kubia\nNamespace:           default\nLabels:              \u003cnone\u003e\nSelector:            app=kubia         \nType:                ClusterIP\nIP:                  10.111.249.153\nPort:                \u003cunset\u003e 80/TCP\nEndpoints:           10.108.1.4:8080,10.108.2.5:8080,10.108.2.6:8080   \nSession Affinity:    None\nNo events.\nAn Endpoints resource (yes, plural) is a list of IP addresses and ports exposing a ser-\nvice. The Endpoints resource is like any other Kubernetes resource, so you can display\nits basic info with kubectl get:\n$ kubectl get endpoints kubia\nNAME    ENDPOINTS                                         AGE\nkubia   10.108.1.4:8080,10.108.2.5:8080,10.108.2.6:8080   1h\nAlthough the pod selector is defined in the service spec, it\u2019s not used directly when\nredirecting incoming connections. Instead, the selector is used to build a list of IPs\nand ports, which is then stored in the Endpoints resource. When a client connects to a\nservice, the service proxy selects one of those IP and port pairs and redirects the\nincoming connection to the server listening at that location.\n5.2.2\nManually configuring service endpoints\nYou may have probably realized this already, but having the service\u2019s endpoints decou-\npled from the service allows them to be configured and updated manually. \n If you create a service without a pod selector, Kubernetes won\u2019t even create the\nEndpoints resource (after all, without a selector, it can\u2019t know which pods to include\nin the service). It\u2019s up to you to create the Endpoints resource to specify the list of\nendpoints for the service.\n To create a service with manually managed endpoints, you need to create both a\nService and an Endpoints resource. \nCREATING A SERVICE WITHOUT A SELECTOR\nYou\u2019ll first create the YAML for the service itself, as shown in the following listing.\napiVersion: v1\nkind: Service\nmetadata:\n  name: external-service     \nspec:                       \n  ports:\n  - port: 80                  \nListing 5.7\nFull details of a service displayed with kubectl describe\nListing 5.8\nA service without a pod selector: external-service.yaml\nThe service\u2019s pod \nselector is used to \ncreate the list of \nendpoints.\nThe list of pod\nIPs and ports\nthat represent\nthe endpoints of\nthis service\nThe name of the service must \nmatch the name of the Endpoints \nobject (see next listing).\nThis service has no \nselector defined.\n \n"}, {"color": "green", "id": "text_76", "label": "133\nConnecting to services living outside the cluster\nYou\u2019re defining a service called external-service that will accept incoming connec-\ntions on port 80. You didn\u2019t define a pod selector for the service.\nCREATING AN ENDPOINTS RESOURCE FOR A SERVICE WITHOUT A SELECTOR\nEndpoints are a separate resource and not an attribute of a service. Because you cre-\nated the service without a selector, the corresponding Endpoints resource hasn\u2019t been\ncreated automatically, so it\u2019s up to you to create it. The following listing shows its\nYAML manifest.\napiVersion: v1\nkind: Endpoints\nmetadata:\n  name: external-service      \nsubsets:\n  - addresses:\n    - ip: 11.11.11.11         \n    - ip: 22.22.22.22         \n    ports:\n    - port: 80      \nThe Endpoints object needs to have the same name as the service and contain the list\nof target IP addresses and ports for the service. After both the Service and the End-\npoints resource are posted to the server, the service is ready to be used like any regular\nservice with a pod selector. Containers created after the service is created will include\nthe environment variables for the service, and all connections to its IP:port pair will be\nload balanced between the service\u2019s endpoints. \n Figure 5.4 shows three pods connecting to the service with external endpoints.\nIf you later decide to migrate the external service to pods running inside Kubernetes,\nyou can add a selector to the service, thereby making its Endpoints managed automat-\nically. The same is also true in reverse\u2014by removing the selector from a Service,\nListing 5.9\nA manually created Endpoints resource: external-service-endpoints.yaml\nThe name of the Endpoints object \nmust match the name of the \nservice (see previous listing).\nThe IPs of the endpoints that the \nservice will forward connections to\nThe target port of the endpoints\nPod\nPod\nPod\nExternal server 1\nIP: 11.11.11.11:80\nExternal server 2\nIP: 22.22.22.22:80\nService\n10.111.249.214:80\nKubernetes cluster\nInternet\nFigure 5.4\nPods consuming a service with two external endpoints.\n \n", "shape": "dot", "size": 10, "title": "133\nConnecting to services living outside the cluster\nYou\u2019re defining a service called external-service that will accept incoming connec-\ntions on port 80. You didn\u2019t define a pod selector for the service.\nCREATING AN ENDPOINTS RESOURCE FOR A SERVICE WITHOUT A SELECTOR\nEndpoints are a separate resource and not an attribute of a service. Because you cre-\nated the service without a selector, the corresponding Endpoints resource hasn\u2019t been\ncreated automatically, so it\u2019s up to you to create it. The following listing shows its\nYAML manifest.\napiVersion: v1\nkind: Endpoints\nmetadata:\n  name: external-service      \nsubsets:\n  - addresses:\n    - ip: 11.11.11.11         \n    - ip: 22.22.22.22         \n    ports:\n    - port: 80      \nThe Endpoints object needs to have the same name as the service and contain the list\nof target IP addresses and ports for the service. After both the Service and the End-\npoints resource are posted to the server, the service is ready to be used like any regular\nservice with a pod selector. Containers created after the service is created will include\nthe environment variables for the service, and all connections to its IP:port pair will be\nload balanced between the service\u2019s endpoints. \n Figure 5.4 shows three pods connecting to the service with external endpoints.\nIf you later decide to migrate the external service to pods running inside Kubernetes,\nyou can add a selector to the service, thereby making its Endpoints managed automat-\nically. The same is also true in reverse\u2014by removing the selector from a Service,\nListing 5.9\nA manually created Endpoints resource: external-service-endpoints.yaml\nThe name of the Endpoints object \nmust match the name of the \nservice (see previous listing).\nThe IPs of the endpoints that the \nservice will forward connections to\nThe target port of the endpoints\nPod\nPod\nPod\nExternal server 1\nIP: 11.11.11.11:80\nExternal server 2\nIP: 22.22.22.22:80\nService\n10.111.249.214:80\nKubernetes cluster\nInternet\nFigure 5.4\nPods consuming a service with two external endpoints.\n \n"}, {"color": "green", "id": "text_77", "label": "134\nCHAPTER 5\nServices: enabling clients to discover and talk to pods\nKubernetes stops updating its Endpoints. This means a service IP address can remain\nconstant while the actual implementation of the service is changed. \n5.2.3\nCreating an alias for an external service\nInstead of exposing an external service by manually configuring the service\u2019s End-\npoints, a simpler method allows you to refer to an external service by its fully qualified\ndomain name (FQDN).\nCREATING AN EXTERNALNAME SERVICE\nTo create a service that serves as an alias for an external service, you create a Service\nresource with the type field set to ExternalName. For example, let\u2019s imagine there\u2019s a\npublic API available at api.somecompany.com. You can define a service that points to\nit as shown in the following listing.\napiVersion: v1\nkind: Service\nmetadata:\n  name: external-service\nspec:\n  type: ExternalName                       \n  externalName: someapi.somecompany.com     \n  ports:\n  - port: 80\nAfter the service is created, pods can connect to the external service through the\nexternal-service.default.svc.cluster.local domain name (or even external-\nservice) instead of using the service\u2019s actual FQDN. This hides the actual service\nname and its location from pods consuming the service, allowing you to modify the\nservice definition and point it to a different service any time later, by only changing\nthe externalName attribute or by changing the type back to ClusterIP and creating\nan Endpoints object for the service\u2014either manually or by specifying a label selector\non the service and having it created automatically.\n ExternalName services are implemented solely at the DNS level\u2014a simple CNAME\nDNS record is created for the service. Therefore, clients connecting to the service will\nconnect to the external service directly, bypassing the service proxy completely. For\nthis reason, these types of services don\u2019t even get a cluster IP. \nNOTE\nA CNAME record points to a fully qualified domain name instead of a\nnumeric IP address.\n5.3\nExposing services to external clients\nUp to now, we\u2019ve only talked about how services can be consumed by pods from inside\nthe cluster. But you\u2019ll also want to expose certain services, such as frontend webserv-\ners, to the outside, so external clients can access them, as depicted in figure 5.5.\nListing 5.10\nAn ExternalName-type service: external-service-externalname.yaml\nService type is set \nto ExternalName\nThe fully qualified domain \nname of the actual service\n \n", "shape": "dot", "size": 10, "title": "134\nCHAPTER 5\nServices: enabling clients to discover and talk to pods\nKubernetes stops updating its Endpoints. This means a service IP address can remain\nconstant while the actual implementation of the service is changed. \n5.2.3\nCreating an alias for an external service\nInstead of exposing an external service by manually configuring the service\u2019s End-\npoints, a simpler method allows you to refer to an external service by its fully qualified\ndomain name (FQDN).\nCREATING AN EXTERNALNAME SERVICE\nTo create a service that serves as an alias for an external service, you create a Service\nresource with the type field set to ExternalName. For example, let\u2019s imagine there\u2019s a\npublic API available at api.somecompany.com. You can define a service that points to\nit as shown in the following listing.\napiVersion: v1\nkind: Service\nmetadata:\n  name: external-service\nspec:\n  type: ExternalName                       \n  externalName: someapi.somecompany.com     \n  ports:\n  - port: 80\nAfter the service is created, pods can connect to the external service through the\nexternal-service.default.svc.cluster.local domain name (or even external-\nservice) instead of using the service\u2019s actual FQDN. This hides the actual service\nname and its location from pods consuming the service, allowing you to modify the\nservice definition and point it to a different service any time later, by only changing\nthe externalName attribute or by changing the type back to ClusterIP and creating\nan Endpoints object for the service\u2014either manually or by specifying a label selector\non the service and having it created automatically.\n ExternalName services are implemented solely at the DNS level\u2014a simple CNAME\nDNS record is created for the service. Therefore, clients connecting to the service will\nconnect to the external service directly, bypassing the service proxy completely. For\nthis reason, these types of services don\u2019t even get a cluster IP. \nNOTE\nA CNAME record points to a fully qualified domain name instead of a\nnumeric IP address.\n5.3\nExposing services to external clients\nUp to now, we\u2019ve only talked about how services can be consumed by pods from inside\nthe cluster. But you\u2019ll also want to expose certain services, such as frontend webserv-\ners, to the outside, so external clients can access them, as depicted in figure 5.5.\nListing 5.10\nAn ExternalName-type service: external-service-externalname.yaml\nService type is set \nto ExternalName\nThe fully qualified domain \nname of the actual service\n \n"}, {"color": "green", "id": "text_78", "label": "135\nExposing services to external clients\nYou have a few ways to make a service accessible externally:\n\uf0a1Setting the service type to NodePort\u2014For a NodePort service, each cluster node\nopens a port on the node itself (hence the name) and redirects traffic received\non that port to the underlying service. The service isn\u2019t accessible only at the\ninternal cluster IP and port, but also through a dedicated port on all nodes. \n\uf0a1Setting the service type to LoadBalancer, an extension of the NodePort type\u2014This\nmakes the service accessible through a dedicated load balancer, provisioned\nfrom the cloud infrastructure Kubernetes is running on. The load balancer redi-\nrects traffic to the node port across all the nodes. Clients connect to the service\nthrough the load balancer\u2019s IP.\n\uf0a1Creating an Ingress resource, a radically different mechanism for exposing multiple ser-\nvices through a single IP address\u2014It operates at the HTTP level (network layer 7)\nand can thus offer more features than layer 4 services can. We\u2019ll explain Ingress\nresources in section 5.4. \n5.3.1\nUsing a NodePort service\nThe first method of exposing a set of pods to external clients is by creating a service\nand setting its type to NodePort. By creating a NodePort service, you make Kubernetes\nreserve a port on all its nodes (the same port number is used across all of them) and\nforward incoming connections to the pods that are part of the service. \n This is similar to a regular service (their actual type is ClusterIP), but a NodePort\nservice can be accessed not only through the service\u2019s internal cluster IP, but also\nthrough any node\u2019s IP and the reserved node port. \n This will make more sense when you try interacting with a NodePort service.\nCREATING A NODEPORT SERVICE\nYou\u2019ll now create a NodePort service to see how you can use it. The following listing\nshows the YAML for the service.\n \nKubernetes cluster\nExternal client\nService\nPod\nPod\nPod\nFigure 5.5\nExposing a service to external clients\n \n", "shape": "dot", "size": 10, "title": "135\nExposing services to external clients\nYou have a few ways to make a service accessible externally:\n\uf0a1Setting the service type to NodePort\u2014For a NodePort service, each cluster node\nopens a port on the node itself (hence the name) and redirects traffic received\non that port to the underlying service. The service isn\u2019t accessible only at the\ninternal cluster IP and port, but also through a dedicated port on all nodes. \n\uf0a1Setting the service type to LoadBalancer, an extension of the NodePort type\u2014This\nmakes the service accessible through a dedicated load balancer, provisioned\nfrom the cloud infrastructure Kubernetes is running on. The load balancer redi-\nrects traffic to the node port across all the nodes. Clients connect to the service\nthrough the load balancer\u2019s IP.\n\uf0a1Creating an Ingress resource, a radically different mechanism for exposing multiple ser-\nvices through a single IP address\u2014It operates at the HTTP level (network layer 7)\nand can thus offer more features than layer 4 services can. We\u2019ll explain Ingress\nresources in section 5.4. \n5.3.1\nUsing a NodePort service\nThe first method of exposing a set of pods to external clients is by creating a service\nand setting its type to NodePort. By creating a NodePort service, you make Kubernetes\nreserve a port on all its nodes (the same port number is used across all of them) and\nforward incoming connections to the pods that are part of the service. \n This is similar to a regular service (their actual type is ClusterIP), but a NodePort\nservice can be accessed not only through the service\u2019s internal cluster IP, but also\nthrough any node\u2019s IP and the reserved node port. \n This will make more sense when you try interacting with a NodePort service.\nCREATING A NODEPORT SERVICE\nYou\u2019ll now create a NodePort service to see how you can use it. The following listing\nshows the YAML for the service.\n \nKubernetes cluster\nExternal client\nService\nPod\nPod\nPod\nFigure 5.5\nExposing a service to external clients\n \n"}, {"color": "green", "id": "text_79", "label": "136\nCHAPTER 5\nServices: enabling clients to discover and talk to pods\napiVersion: v1\nkind: Service\nmetadata:\n  name: kubia-nodeport\nspec:\n  type: NodePort            \n  ports:\n  - port: 80                 \n    targetPort: 8080        \n    nodePort: 30123        \n  selector:\n    app: kubia\nYou set the type to NodePort and specify the node port this service should be bound to\nacross all cluster nodes. Specifying the port isn\u2019t mandatory; Kubernetes will choose a\nrandom port if you omit it. \nNOTE\nWhen you create the service in GKE, kubectl prints out a warning\nabout having to configure firewall rules. We\u2019ll see how to do that soon. \nEXAMINING YOUR NODEPORT SERVICE\nLet\u2019s see the basic information of your service to learn more about it:\n$ kubectl get svc kubia-nodeport\nNAME             CLUSTER-IP       EXTERNAL-IP   PORT(S)        AGE\nkubia-nodeport   10.111.254.223   \u003cnodes\u003e       80:30123/TCP   2m\nLook at the EXTERNAL-IP column. It shows \u003cnodes\u003e, indicating the service is accessible\nthrough the IP address of any cluster node. The PORT(S) column shows both the\ninternal port of the cluster IP (80) and the node port (30123). The service is accessi-\nble at the following addresses:\n\uf0a1\n10.11.254.223:80\n\uf0a1\n\u003c1st node\u2019s IP\u003e:30123\n\uf0a1\n\u003c2nd node\u2019s IP\u003e:30123, and so on.\nFigure 5.6 shows your service exposed on port 30123 of both of your cluster nodes\n(this applies if you\u2019re running this on GKE; Minikube only has a single node, but the\nprinciple is the same). An incoming connection to one of those ports will be redi-\nrected to a randomly selected pod, which may or may not be the one running on the\nnode the connection is being made to. \n \n \n \nListing 5.11\nA NodePort service definition: kubia-svc-nodeport.yaml\nSet the service \ntype to NodePort.\nThis is the port of the \nservice\u2019s internal cluster IP.\nThis is the target port \nof the backing pods.\nThe service will be accessible \nthrough port 30123 of each of \nyour cluster nodes.\n \n", "shape": "dot", "size": 10, "title": "136\nCHAPTER 5\nServices: enabling clients to discover and talk to pods\napiVersion: v1\nkind: Service\nmetadata:\n  name: kubia-nodeport\nspec:\n  type: NodePort            \n  ports:\n  - port: 80                 \n    targetPort: 8080        \n    nodePort: 30123        \n  selector:\n    app: kubia\nYou set the type to NodePort and specify the node port this service should be bound to\nacross all cluster nodes. Specifying the port isn\u2019t mandatory; Kubernetes will choose a\nrandom port if you omit it. \nNOTE\nWhen you create the service in GKE, kubectl prints out a warning\nabout having to configure firewall rules. We\u2019ll see how to do that soon. \nEXAMINING YOUR NODEPORT SERVICE\nLet\u2019s see the basic information of your service to learn more about it:\n$ kubectl get svc kubia-nodeport\nNAME             CLUSTER-IP       EXTERNAL-IP   PORT(S)        AGE\nkubia-nodeport   10.111.254.223   \u003cnodes\u003e       80:30123/TCP   2m\nLook at the EXTERNAL-IP column. It shows \u003cnodes\u003e, indicating the service is accessible\nthrough the IP address of any cluster node. The PORT(S) column shows both the\ninternal port of the cluster IP (80) and the node port (30123). The service is accessi-\nble at the following addresses:\n\uf0a1\n10.11.254.223:80\n\uf0a1\n\u003c1st node\u2019s IP\u003e:30123\n\uf0a1\n\u003c2nd node\u2019s IP\u003e:30123, and so on.\nFigure 5.6 shows your service exposed on port 30123 of both of your cluster nodes\n(this applies if you\u2019re running this on GKE; Minikube only has a single node, but the\nprinciple is the same). An incoming connection to one of those ports will be redi-\nrected to a randomly selected pod, which may or may not be the one running on the\nnode the connection is being made to. \n \n \n \nListing 5.11\nA NodePort service definition: kubia-svc-nodeport.yaml\nSet the service \ntype to NodePort.\nThis is the port of the \nservice\u2019s internal cluster IP.\nThis is the target port \nof the backing pods.\nThe service will be accessible \nthrough port 30123 of each of \nyour cluster nodes.\n \n"}, {"color": "green", "id": "text_80", "label": "137\nExposing services to external clients\nA connection received on port 30123 of the first node might be forwarded either to\nthe pod running on the first node or to one of the pods running on the second node.\nCHANGING FIREWALL RULES TO LET EXTERNAL CLIENTS ACCESS OUR NODEPORT SERVICE\nAs I\u2019ve mentioned previously, before you can access your service through the node\nport, you need to configure the Google Cloud Platform\u2019s firewalls to allow external\nconnections to your nodes on that port. You\u2019ll do this now:\n$ gcloud compute firewall-rules create kubia-svc-rule --allow=tcp:30123\nCreated [https://www.googleapis.com/compute/v1/projects/kubia-\n1295/global/firewalls/kubia-svc-rule].\nNAME            NETWORK  SRC_RANGES  RULES      SRC_TAGS  TARGET_TAGS\nkubia-svc-rule  default  0.0.0.0/0   tcp:30123\nYou can access your service through port 30123 of one of the node\u2019s IPs. But you need\nto figure out the IP of a node first. Refer to the sidebar on how to do that.\n \n \n \nKubernetes cluster\nExternal client\nPod\nNode 2\nIP: 130.211.99.206\nNode 1\nIP: 130.211.97.55\nPort 30123\nPort 8080\nPod\nPort 8080\nPod\nPort 30123\nPort 8080\nService\nFigure 5.6\nAn external client connecting to a NodePort service either through Node 1 or 2\n \n", "shape": "dot", "size": 10, "title": "137\nExposing services to external clients\nA connection received on port 30123 of the first node might be forwarded either to\nthe pod running on the first node or to one of the pods running on the second node.\nCHANGING FIREWALL RULES TO LET EXTERNAL CLIENTS ACCESS OUR NODEPORT SERVICE\nAs I\u2019ve mentioned previously, before you can access your service through the node\nport, you need to configure the Google Cloud Platform\u2019s firewalls to allow external\nconnections to your nodes on that port. You\u2019ll do this now:\n$ gcloud compute firewall-rules create kubia-svc-rule --allow=tcp:30123\nCreated [https://www.googleapis.com/compute/v1/projects/kubia-\n1295/global/firewalls/kubia-svc-rule].\nNAME            NETWORK  SRC_RANGES  RULES      SRC_TAGS  TARGET_TAGS\nkubia-svc-rule  default  0.0.0.0/0   tcp:30123\nYou can access your service through port 30123 of one of the node\u2019s IPs. But you need\nto figure out the IP of a node first. Refer to the sidebar on how to do that.\n \n \n \nKubernetes cluster\nExternal client\nPod\nNode 2\nIP: 130.211.99.206\nNode 1\nIP: 130.211.97.55\nPort 30123\nPort 8080\nPod\nPort 8080\nPod\nPort 30123\nPort 8080\nService\nFigure 5.6\nAn external client connecting to a NodePort service either through Node 1 or 2\n \n"}, {"color": "green", "id": "text_81", "label": "138\nCHAPTER 5\nServices: enabling clients to discover and talk to pods\nOnce you know the IPs of your nodes, you can try accessing your service through them:\n$ curl http://130.211.97.55:30123\nYou\u0027ve hit kubia-ym8or\n$ curl http://130.211.99.206:30123\nYou\u0027ve hit kubia-xueq1\nTIP\nWhen using Minikube, you can easily access your NodePort services\nthrough your browser by running minikube service \u003cservice-name\u003e [-n\n\u003cnamespace\u003e].\nAs you can see, your pods are now accessible to the whole internet through port 30123\non any of your nodes. It doesn\u2019t matter what node a client sends the request to. But if\nyou only point your clients to the first node, when that node fails, your clients can\u2019t\naccess the service anymore. That\u2019s why it makes sense to put a load balancer in front\nof the nodes to make sure you\u2019re spreading requests across all healthy nodes and\nnever sending them to a node that\u2019s offline at that moment. \n If your Kubernetes cluster supports it (which is mostly true when Kubernetes is\ndeployed on cloud infrastructure), the load balancer can be provisioned automati-\ncally by creating a LoadBalancer instead of a NodePort service. We\u2019ll look at this next.\n5.3.2\nExposing a service through an external load balancer\nKubernetes clusters running on cloud providers usually support the automatic provi-\nsion of a load balancer from the cloud infrastructure. All you need to do is set the\nUsing JSONPath to get the IPs of all your nodes \nYou can find the IP in the JSON or YAML descriptors of the nodes. But instead of\nsifting through the relatively large JSON, you can tell kubectl to print out only the\nnode IP instead of the whole service definition: \n$ kubectl get nodes -o jsonpath=\u0027{.items[*].status.\n\u27a5 addresses[?(@.type==\"ExternalIP\")].address}\u0027\n130.211.97.55 130.211.99.206\nYou\u2019re telling kubectl to only output the information you want by specifying a\nJSONPath. You\u2019re probably familiar with XPath and how it\u2019s used with XML. JSONPath\nis basically XPath for JSON. The JSONPath in the previous example instructs kubectl\nto do the following:\n\uf0a1Go through all the elements in the items attribute.\n\uf0a1For each element, enter the status attribute.\n\uf0a1Filter elements of the addresses attribute, taking only those that have the\ntype attribute set to ExternalIP.\n\uf0a1Finally, print the address attribute of the filtered elements.\nTo learn more about how to use JSONPath with kubectl, refer to the documentation\nat http:/\n/kubernetes.io/docs/user-guide/jsonpath. \n \n", "shape": "dot", "size": 10, "title": "138\nCHAPTER 5\nServices: enabling clients to discover and talk to pods\nOnce you know the IPs of your nodes, you can try accessing your service through them:\n$ curl http://130.211.97.55:30123\nYou\u0027ve hit kubia-ym8or\n$ curl http://130.211.99.206:30123\nYou\u0027ve hit kubia-xueq1\nTIP\nWhen using Minikube, you can easily access your NodePort services\nthrough your browser by running minikube service \u003cservice-name\u003e [-n\n\u003cnamespace\u003e].\nAs you can see, your pods are now accessible to the whole internet through port 30123\non any of your nodes. It doesn\u2019t matter what node a client sends the request to. But if\nyou only point your clients to the first node, when that node fails, your clients can\u2019t\naccess the service anymore. That\u2019s why it makes sense to put a load balancer in front\nof the nodes to make sure you\u2019re spreading requests across all healthy nodes and\nnever sending them to a node that\u2019s offline at that moment. \n If your Kubernetes cluster supports it (which is mostly true when Kubernetes is\ndeployed on cloud infrastructure), the load balancer can be provisioned automati-\ncally by creating a LoadBalancer instead of a NodePort service. We\u2019ll look at this next.\n5.3.2\nExposing a service through an external load balancer\nKubernetes clusters running on cloud providers usually support the automatic provi-\nsion of a load balancer from the cloud infrastructure. All you need to do is set the\nUsing JSONPath to get the IPs of all your nodes \nYou can find the IP in the JSON or YAML descriptors of the nodes. But instead of\nsifting through the relatively large JSON, you can tell kubectl to print out only the\nnode IP instead of the whole service definition: \n$ kubectl get nodes -o jsonpath=\u0027{.items[*].status.\n\u27a5 addresses[?(@.type==\"ExternalIP\")].address}\u0027\n130.211.97.55 130.211.99.206\nYou\u2019re telling kubectl to only output the information you want by specifying a\nJSONPath. You\u2019re probably familiar with XPath and how it\u2019s used with XML. JSONPath\nis basically XPath for JSON. The JSONPath in the previous example instructs kubectl\nto do the following:\n\uf0a1Go through all the elements in the items attribute.\n\uf0a1For each element, enter the status attribute.\n\uf0a1Filter elements of the addresses attribute, taking only those that have the\ntype attribute set to ExternalIP.\n\uf0a1Finally, print the address attribute of the filtered elements.\nTo learn more about how to use JSONPath with kubectl, refer to the documentation\nat http:/\n/kubernetes.io/docs/user-guide/jsonpath. \n \n"}, {"color": "green", "id": "text_82", "label": "139\nExposing services to external clients\nservice\u2019s type to LoadBalancer instead of NodePort. The load balancer will have its\nown unique, publicly accessible IP address and will redirect all connections to your\nservice. You can thus access your service through the load balancer\u2019s IP address. \n If Kubernetes is running in an environment that doesn\u2019t support LoadBalancer\nservices, the load balancer will not be provisioned, but the service will still behave like\na NodePort service. That\u2019s because a LoadBalancer service is an extension of a Node-\nPort service. You\u2019ll run this example on Google Kubernetes Engine, which supports\nLoadBalancer services. Minikube doesn\u2019t, at least not as of this writing. \nCREATING A LOADBALANCER SERVICE\nTo create a service with a load balancer in front, create the service from the following\nYAML manifest, as shown in the following listing.\napiVersion: v1\nkind: Service\nmetadata:\n  name: kubia-loadbalancer\nspec:\n  type: LoadBalancer          \n  ports:\n  - port: 80\n    targetPort: 8080\n  selector:\n    app: kubia\nThe service type is set to LoadBalancer instead of NodePort. You\u2019re not specifying a spe-\ncific node port, although you could (you\u2019re letting Kubernetes choose one instead). \nCONNECTING TO THE SERVICE THROUGH THE LOAD BALANCER\nAfter you create the service, it takes time for the cloud infrastructure to create the\nload balancer and write its IP address into the Service object. Once it does that, the IP\naddress will be listed as the external IP address of your service:\n$ kubectl get svc kubia-loadbalancer\nNAME                 CLUSTER-IP       EXTERNAL-IP      PORT(S)         AGE\nkubia-loadbalancer   10.111.241.153   130.211.53.173   80:32143/TCP    1m\nIn this case, the load balancer is available at IP 130.211.53.173, so you can now access\nthe service at that IP address:\n$ curl http://130.211.53.173\nYou\u0027ve hit kubia-xueq1\nSuccess! As you may have noticed, this time you didn\u2019t need to mess with firewalls the\nway you had to before with the NodePort service.\nListing 5.12\nA LoadBalancer-type service: kubia-svc-loadbalancer.yaml\nThis type of service obtains \na load balancer from the \ninfrastructure hosting the \nKubernetes cluster.\n \n", "shape": "dot", "size": 10, "title": "139\nExposing services to external clients\nservice\u2019s type to LoadBalancer instead of NodePort. The load balancer will have its\nown unique, publicly accessible IP address and will redirect all connections to your\nservice. You can thus access your service through the load balancer\u2019s IP address. \n If Kubernetes is running in an environment that doesn\u2019t support LoadBalancer\nservices, the load balancer will not be provisioned, but the service will still behave like\na NodePort service. That\u2019s because a LoadBalancer service is an extension of a Node-\nPort service. You\u2019ll run this example on Google Kubernetes Engine, which supports\nLoadBalancer services. Minikube doesn\u2019t, at least not as of this writing. \nCREATING A LOADBALANCER SERVICE\nTo create a service with a load balancer in front, create the service from the following\nYAML manifest, as shown in the following listing.\napiVersion: v1\nkind: Service\nmetadata:\n  name: kubia-loadbalancer\nspec:\n  type: LoadBalancer          \n  ports:\n  - port: 80\n    targetPort: 8080\n  selector:\n    app: kubia\nThe service type is set to LoadBalancer instead of NodePort. You\u2019re not specifying a spe-\ncific node port, although you could (you\u2019re letting Kubernetes choose one instead). \nCONNECTING TO THE SERVICE THROUGH THE LOAD BALANCER\nAfter you create the service, it takes time for the cloud infrastructure to create the\nload balancer and write its IP address into the Service object. Once it does that, the IP\naddress will be listed as the external IP address of your service:\n$ kubectl get svc kubia-loadbalancer\nNAME                 CLUSTER-IP       EXTERNAL-IP      PORT(S)         AGE\nkubia-loadbalancer   10.111.241.153   130.211.53.173   80:32143/TCP    1m\nIn this case, the load balancer is available at IP 130.211.53.173, so you can now access\nthe service at that IP address:\n$ curl http://130.211.53.173\nYou\u0027ve hit kubia-xueq1\nSuccess! As you may have noticed, this time you didn\u2019t need to mess with firewalls the\nway you had to before with the NodePort service.\nListing 5.12\nA LoadBalancer-type service: kubia-svc-loadbalancer.yaml\nThis type of service obtains \na load balancer from the \ninfrastructure hosting the \nKubernetes cluster.\n \n"}, {"color": "green", "id": "text_83", "label": "140\nCHAPTER 5\nServices: enabling clients to discover and talk to pods\nSee figure 5.7 to see how HTTP requests are delivered to the pod. External clients\n(curl in your case) connect to port 80 of the load balancer and get routed to the\nSession affinity and web browsers\nBecause your service is now exposed externally, you may try accessing it with your\nweb browser. You\u2019ll see something that may strike you as odd\u2014the browser will hit\nthe exact same pod every time. Did the service\u2019s session affinity change in the\nmeantime? With kubectl explain, you can double-check that the service\u2019s session\naffinity is still set to None, so why don\u2019t different browser requests hit different\npods, as is the case when using curl?\nLet me explain what\u2019s happening. The browser is using keep-alive connections and\nsends all its requests through a single connection, whereas curl opens a new\nconnection every time. Services work at the connection level, so when a connection to a\nservice is first opened, a random pod is selected and then all network packets belonging\nto that connection are all sent to that single pod. Even if session affinity is set to None,\nusers will always hit the same pod (until the connection is closed).\nKubernetes cluster\nExternal client\nLoad balancer\nIP: 130.211.53.173:80\nPod\nNode 2\nIP: 130.211.99.206\nNode 1\nIP: 130.211.97.55\nPort 32143\nPort 8080\nPod\nPort 8080\nPod\nPort 32143\nPort 8080\nService\nFigure 5.7\nAn external client connecting to a LoadBalancer service\n \n", "shape": "dot", "size": 10, "title": "140\nCHAPTER 5\nServices: enabling clients to discover and talk to pods\nSee figure 5.7 to see how HTTP requests are delivered to the pod. External clients\n(curl in your case) connect to port 80 of the load balancer and get routed to the\nSession affinity and web browsers\nBecause your service is now exposed externally, you may try accessing it with your\nweb browser. You\u2019ll see something that may strike you as odd\u2014the browser will hit\nthe exact same pod every time. Did the service\u2019s session affinity change in the\nmeantime? With kubectl explain, you can double-check that the service\u2019s session\naffinity is still set to None, so why don\u2019t different browser requests hit different\npods, as is the case when using curl?\nLet me explain what\u2019s happening. The browser is using keep-alive connections and\nsends all its requests through a single connection, whereas curl opens a new\nconnection every time. Services work at the connection level, so when a connection to a\nservice is first opened, a random pod is selected and then all network packets belonging\nto that connection are all sent to that single pod. Even if session affinity is set to None,\nusers will always hit the same pod (until the connection is closed).\nKubernetes cluster\nExternal client\nLoad balancer\nIP: 130.211.53.173:80\nPod\nNode 2\nIP: 130.211.99.206\nNode 1\nIP: 130.211.97.55\nPort 32143\nPort 8080\nPod\nPort 8080\nPod\nPort 32143\nPort 8080\nService\nFigure 5.7\nAn external client connecting to a LoadBalancer service\n \n"}, {"color": "green", "id": "text_84", "label": "141\nExposing services to external clients\nimplicitly assigned node port on one of the nodes. From there, the connection is for-\nwarded to one of the pod instances.\n As already mentioned, a LoadBalancer-type service is a NodePort service with an\nadditional infrastructure-provided load balancer. If you use kubectl describe to dis-\nplay additional info about the service, you\u2019ll see that a node port has been selected for\nthe service. If you were to open the firewall for this port, the way you did in the previ-\nous section about NodePort services, you could access the service through the node\nIPs as well.\nTIP\nIf you\u2019re using Minikube, even though the load balancer will never be\nprovisioned, you can still access the service through the node port (at the\nMinikube VM\u2019s IP address).\n5.3.3\nUnderstanding the peculiarities of external connections\nYou must be aware of several things related to externally originating connections to\nservices. \nUNDERSTANDING AND PREVENTING UNNECESSARY NETWORK HOPS\nWhen an external client connects to a service through the node port (this also\nincludes cases when it goes through the load balancer first), the randomly chosen\npod may or may not be running on the same node that received the connection. An\nadditional network hop is required to reach the pod, but this may not always be\ndesirable. \n You can prevent this additional hop by configuring the service to redirect external\ntraffic only to pods running on the node that received the connection. This is done by\nsetting the externalTrafficPolicy field in the service\u2019s spec section:\nspec:\n  externalTrafficPolicy: Local\n  ...\nIf a service definition includes this setting and an external connection is opened\nthrough the service\u2019s node port, the service proxy will choose a locally running pod. If\nno local pods exist, the connection will hang (it won\u2019t be forwarded to a random\nglobal pod, the way connections are when not using the annotation). You therefore\nneed to ensure the load balancer forwards connections only to nodes that have at\nleast one such pod.\n Using this annotation also has other drawbacks. Normally, connections are spread\nevenly across all the pods, but when using this annotation, that\u2019s no longer the case.\n Imagine having two nodes and three pods. Let\u2019s say node A runs one pod and\nnode B runs the other two. If the load balancer spreads connections evenly across the\ntwo nodes, the pod on node A will receive 50% of all connections, but the two pods on\nnode B will only receive 25% each, as shown in figure 5.8.\n \n", "shape": "dot", "size": 10, "title": "141\nExposing services to external clients\nimplicitly assigned node port on one of the nodes. From there, the connection is for-\nwarded to one of the pod instances.\n As already mentioned, a LoadBalancer-type service is a NodePort service with an\nadditional infrastructure-provided load balancer. If you use kubectl describe to dis-\nplay additional info about the service, you\u2019ll see that a node port has been selected for\nthe service. If you were to open the firewall for this port, the way you did in the previ-\nous section about NodePort services, you could access the service through the node\nIPs as well.\nTIP\nIf you\u2019re using Minikube, even though the load balancer will never be\nprovisioned, you can still access the service through the node port (at the\nMinikube VM\u2019s IP address).\n5.3.3\nUnderstanding the peculiarities of external connections\nYou must be aware of several things related to externally originating connections to\nservices. \nUNDERSTANDING AND PREVENTING UNNECESSARY NETWORK HOPS\nWhen an external client connects to a service through the node port (this also\nincludes cases when it goes through the load balancer first), the randomly chosen\npod may or may not be running on the same node that received the connection. An\nadditional network hop is required to reach the pod, but this may not always be\ndesirable. \n You can prevent this additional hop by configuring the service to redirect external\ntraffic only to pods running on the node that received the connection. This is done by\nsetting the externalTrafficPolicy field in the service\u2019s spec section:\nspec:\n  externalTrafficPolicy: Local\n  ...\nIf a service definition includes this setting and an external connection is opened\nthrough the service\u2019s node port, the service proxy will choose a locally running pod. If\nno local pods exist, the connection will hang (it won\u2019t be forwarded to a random\nglobal pod, the way connections are when not using the annotation). You therefore\nneed to ensure the load balancer forwards connections only to nodes that have at\nleast one such pod.\n Using this annotation also has other drawbacks. Normally, connections are spread\nevenly across all the pods, but when using this annotation, that\u2019s no longer the case.\n Imagine having two nodes and three pods. Let\u2019s say node A runs one pod and\nnode B runs the other two. If the load balancer spreads connections evenly across the\ntwo nodes, the pod on node A will receive 50% of all connections, but the two pods on\nnode B will only receive 25% each, as shown in figure 5.8.\n \n"}, {"color": "green", "id": "text_85", "label": "142\nCHAPTER 5\nServices: enabling clients to discover and talk to pods\nBEING AWARE OF THE NON-PRESERVATION OF THE CLIENT\u2019S IP\nUsually, when clients inside the cluster connect to a service, the pods backing the ser-\nvice can obtain the client\u2019s IP address. But when the connection is received through a\nnode port, the packets\u2019 source IP is changed, because Source Network Address Trans-\nlation (SNAT) is performed on the packets. \n The backing pod can\u2019t see the actual client\u2019s IP, which may be a problem for some\napplications that need to know the client\u2019s IP. In the case of a web server, for example,\nthis means the access log won\u2019t show the browser\u2019s IP.\n The Local external traffic policy described in the previous section affects the pres-\nervation of the client\u2019s IP, because there\u2019s no additional hop between the node receiv-\ning the connection and the node hosting the target pod (SNAT isn\u2019t performed).\n5.4\nExposing services externally through an Ingress \nresource\nYou\u2019ve now seen two ways of exposing a service to clients outside the cluster, but\nanother method exists\u2014creating an Ingress resource.\nDEFINITION\nIngress (noun)\u2014The act of going in or entering; the right to\nenter; a means or place of entering; entryway. \nLet me first explain why you need another way to access Kubernetes services from the\noutside. \nUNDERSTANDING WHY INGRESSES ARE NEEDED\nOne important reason is that each LoadBalancer service requires its own load bal-\nancer with its own public IP address, whereas an Ingress only requires one, even when\nproviding access to dozens of services. When a client sends an HTTP request to the\nIngress, the host and path in the request determine which service the request is for-\nwarded to, as shown in figure 5.9.\n \n50%\n50%\n50%\n25%\n25%\nNode A\nPod\nNode B\nPod\nPod\nLoad balancer\nFigure 5.8\nA Service using \nthe Local external traffic \npolicy may lead to uneven \nload distribution across pods.\n \n", "shape": "dot", "size": 10, "title": "142\nCHAPTER 5\nServices: enabling clients to discover and talk to pods\nBEING AWARE OF THE NON-PRESERVATION OF THE CLIENT\u2019S IP\nUsually, when clients inside the cluster connect to a service, the pods backing the ser-\nvice can obtain the client\u2019s IP address. But when the connection is received through a\nnode port, the packets\u2019 source IP is changed, because Source Network Address Trans-\nlation (SNAT) is performed on the packets. \n The backing pod can\u2019t see the actual client\u2019s IP, which may be a problem for some\napplications that need to know the client\u2019s IP. In the case of a web server, for example,\nthis means the access log won\u2019t show the browser\u2019s IP.\n The Local external traffic policy described in the previous section affects the pres-\nervation of the client\u2019s IP, because there\u2019s no additional hop between the node receiv-\ning the connection and the node hosting the target pod (SNAT isn\u2019t performed).\n5.4\nExposing services externally through an Ingress \nresource\nYou\u2019ve now seen two ways of exposing a service to clients outside the cluster, but\nanother method exists\u2014creating an Ingress resource.\nDEFINITION\nIngress (noun)\u2014The act of going in or entering; the right to\nenter; a means or place of entering; entryway. \nLet me first explain why you need another way to access Kubernetes services from the\noutside. \nUNDERSTANDING WHY INGRESSES ARE NEEDED\nOne important reason is that each LoadBalancer service requires its own load bal-\nancer with its own public IP address, whereas an Ingress only requires one, even when\nproviding access to dozens of services. When a client sends an HTTP request to the\nIngress, the host and path in the request determine which service the request is for-\nwarded to, as shown in figure 5.9.\n \n50%\n50%\n50%\n25%\n25%\nNode A\nPod\nNode B\nPod\nPod\nLoad balancer\nFigure 5.8\nA Service using \nthe Local external traffic \npolicy may lead to uneven \nload distribution across pods.\n \n"}, {"color": "green", "id": "text_86", "label": "143\nExposing services externally through an Ingress resource\nIngresses operate at the application layer of the network stack (HTTP) and can pro-\nvide features such as cookie-based session affinity and the like, which services can\u2019t.\nUNDERSTANDING THAT AN INGRESS CONTROLLER IS REQUIRED\nBefore we go into the features an Ingress object provides, let me emphasize that to\nmake Ingress resources work, an Ingress controller needs to be running in the cluster.\nDifferent Kubernetes environments use different implementations of the controller,\nbut several don\u2019t provide a default controller at all. \n For example, Google Kubernetes Engine uses Google Cloud Platform\u2019s own HTTP\nload-balancing features to provide the Ingress functionality. Initially, Minikube didn\u2019t\nprovide a controller out of the box, but it now includes an add-on that can be enabled\nto let you try out the Ingress functionality. Follow the instructions in the following\nsidebar to ensure it\u2019s enabled.\nEnabling the Ingress add-on in Minikube\nIf you\u2019re using Minikube to run the examples in this book, you\u2019ll need to ensure the\nIngress add-on is enabled. You can check whether it is by listing all the add-ons:\n$ minikube addons list\n- default-storageclass: enabled\n- kube-dns: enabled\n- heapster: disabled\n- ingress: disabled               \n- registry-creds: disabled\n- addon-manager: enabled\n- dashboard: enabled\nYou\u2019ll learn about what these add-ons are throughout the book, but it should be\npretty clear what the dashboard and the kube-dns add-ons do. Enable the Ingress\nadd-on so you can see Ingresses in action:\n$ minikube addons enable ingress\ningress was successfully enabled\nPod\nPod\nPod\nPod\nPod\nPod\nPod\nPod\nPod\nPod\nPod\nPod\nIngress\nClient\nService\nkubia.example.com/kubia\nfoo.example.com\nkubia.example.com/foo\nService\nbar.example.com\nService\nService\nFigure 5.9\nMultiple services can be exposed through a single Ingress.\nThe Ingress add-on \nisn\u2019t enabled.\n \n", "shape": "dot", "size": 10, "title": "143\nExposing services externally through an Ingress resource\nIngresses operate at the application layer of the network stack (HTTP) and can pro-\nvide features such as cookie-based session affinity and the like, which services can\u2019t.\nUNDERSTANDING THAT AN INGRESS CONTROLLER IS REQUIRED\nBefore we go into the features an Ingress object provides, let me emphasize that to\nmake Ingress resources work, an Ingress controller needs to be running in the cluster.\nDifferent Kubernetes environments use different implementations of the controller,\nbut several don\u2019t provide a default controller at all. \n For example, Google Kubernetes Engine uses Google Cloud Platform\u2019s own HTTP\nload-balancing features to provide the Ingress functionality. Initially, Minikube didn\u2019t\nprovide a controller out of the box, but it now includes an add-on that can be enabled\nto let you try out the Ingress functionality. Follow the instructions in the following\nsidebar to ensure it\u2019s enabled.\nEnabling the Ingress add-on in Minikube\nIf you\u2019re using Minikube to run the examples in this book, you\u2019ll need to ensure the\nIngress add-on is enabled. You can check whether it is by listing all the add-ons:\n$ minikube addons list\n- default-storageclass: enabled\n- kube-dns: enabled\n- heapster: disabled\n- ingress: disabled               \n- registry-creds: disabled\n- addon-manager: enabled\n- dashboard: enabled\nYou\u2019ll learn about what these add-ons are throughout the book, but it should be\npretty clear what the dashboard and the kube-dns add-ons do. Enable the Ingress\nadd-on so you can see Ingresses in action:\n$ minikube addons enable ingress\ningress was successfully enabled\nPod\nPod\nPod\nPod\nPod\nPod\nPod\nPod\nPod\nPod\nPod\nPod\nIngress\nClient\nService\nkubia.example.com/kubia\nfoo.example.com\nkubia.example.com/foo\nService\nbar.example.com\nService\nService\nFigure 5.9\nMultiple services can be exposed through a single Ingress.\nThe Ingress add-on \nisn\u2019t enabled.\n \n"}, {"color": "green", "id": "text_87", "label": "144\nCHAPTER 5\nServices: enabling clients to discover and talk to pods\nTIP\nThe --all-namespaces option mentioned in the sidebar is handy when\nyou don\u2019t know what namespace your pod (or other type of resource) is in, or\nif you want to list resources across all namespaces.\n5.4.1\nCreating an Ingress resource\nYou\u2019ve confirmed there\u2019s an Ingress controller running in your cluster, so you can\nnow create an Ingress resource. The following listing shows what the YAML manifest\nfor the Ingress looks like.\napiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  name: kubia\nspec:\n  rules:\n  - host: kubia.example.com             \n    http:\n      paths:\n      - path: /                           \n        backend:\n          serviceName: kubia-nodeport     \n          servicePort: 80                 \nThis defines an Ingress with a single rule, which makes sure all HTTP requests received\nby the Ingress controller, in which the host kubia.example.com is requested, will be\nsent to the kubia-nodeport service on port 80. \n(continued)\nThis should have spun up an Ingress controller as another pod. Most likely, the\ncontroller pod will be in the kube-system namespace, but not necessarily, so list all\nthe running pods across all namespaces by using the --all-namespaces option:\n$ kubectl get po --all-namespaces\nNAMESPACE    NAME                            READY  STATUS    RESTARTS AGE\ndefault      kubia-rsv5m                     1/1    Running   0        13h\ndefault      kubia-fe4ad                     1/1    Running   0        13h\ndefault      kubia-ke823                     1/1    Running   0        13h\nkube-system  default-http-backend-5wb0h      1/1    Running   0        18m\nkube-system  kube-addon-manager-minikube     1/1    Running   3        6d\nkube-system  kube-dns-v20-101vq              3/3    Running   9        6d\nkube-system  kubernetes-dashboard-jxd9l      1/1    Running   3        6d\nkube-system  nginx-ingress-controller-gdts0  1/1    Running   0        18m\nAt the bottom of the output, you see the Ingress controller pod. The name suggests\nthat Nginx (an open-source HTTP server and reverse proxy) is used to provide the\nIngress functionality.\nListing 5.13\nAn Ingress resource definition: kubia-ingress.yaml\nThis Ingress maps the \nkubia.example.com domain \nname to your service.\nAll requests will be sent to \nport 80 of the kubia-\nnodeport service.\n \n", "shape": "dot", "size": 10, "title": "144\nCHAPTER 5\nServices: enabling clients to discover and talk to pods\nTIP\nThe --all-namespaces option mentioned in the sidebar is handy when\nyou don\u2019t know what namespace your pod (or other type of resource) is in, or\nif you want to list resources across all namespaces.\n5.4.1\nCreating an Ingress resource\nYou\u2019ve confirmed there\u2019s an Ingress controller running in your cluster, so you can\nnow create an Ingress resource. The following listing shows what the YAML manifest\nfor the Ingress looks like.\napiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  name: kubia\nspec:\n  rules:\n  - host: kubia.example.com             \n    http:\n      paths:\n      - path: /                           \n        backend:\n          serviceName: kubia-nodeport     \n          servicePort: 80                 \nThis defines an Ingress with a single rule, which makes sure all HTTP requests received\nby the Ingress controller, in which the host kubia.example.com is requested, will be\nsent to the kubia-nodeport service on port 80. \n(continued)\nThis should have spun up an Ingress controller as another pod. Most likely, the\ncontroller pod will be in the kube-system namespace, but not necessarily, so list all\nthe running pods across all namespaces by using the --all-namespaces option:\n$ kubectl get po --all-namespaces\nNAMESPACE    NAME                            READY  STATUS    RESTARTS AGE\ndefault      kubia-rsv5m                     1/1    Running   0        13h\ndefault      kubia-fe4ad                     1/1    Running   0        13h\ndefault      kubia-ke823                     1/1    Running   0        13h\nkube-system  default-http-backend-5wb0h      1/1    Running   0        18m\nkube-system  kube-addon-manager-minikube     1/1    Running   3        6d\nkube-system  kube-dns-v20-101vq              3/3    Running   9        6d\nkube-system  kubernetes-dashboard-jxd9l      1/1    Running   3        6d\nkube-system  nginx-ingress-controller-gdts0  1/1    Running   0        18m\nAt the bottom of the output, you see the Ingress controller pod. The name suggests\nthat Nginx (an open-source HTTP server and reverse proxy) is used to provide the\nIngress functionality.\nListing 5.13\nAn Ingress resource definition: kubia-ingress.yaml\nThis Ingress maps the \nkubia.example.com domain \nname to your service.\nAll requests will be sent to \nport 80 of the kubia-\nnodeport service.\n \n"}, {"color": "green", "id": "text_88", "label": "145\nExposing services externally through an Ingress resource\nNOTE\nIngress controllers on cloud providers (in GKE, for example) require\nthe Ingress to point to a NodePort service. But that\u2019s not a requirement of\nKubernetes itself.\n5.4.2\nAccessing the service through the Ingress\nTo access your service through http:/\n/kubia.example.com, you\u2019ll need to make sure\nthe domain name resolves to the IP of the Ingress controller. \nOBTAINING THE IP ADDRESS OF THE INGRESS\nTo look up the IP, you need to list Ingresses:\n$ kubectl get ingresses\nNAME      HOSTS               ADDRESS          PORTS     AGE\nkubia     kubia.example.com   192.168.99.100   80        29m\nNOTE\nWhen running on cloud providers, the address may take time to appear,\nbecause the Ingress controller provisions a load balancer behind the scenes.\nThe IP is shown in the ADDRESS column. \nENSURING THE HOST CONFIGURED IN THE INGRESS POINTS TO THE INGRESS\u2019 IP ADDRESS\nOnce you know the IP, you can then either configure your DNS servers to resolve\nkubia.example.com to that IP or you can add the following line to /etc/hosts (or\nC:\\windows\\system32\\drivers\\etc\\hosts on Windows):\n192.168.99.100    kubia.example.com\nACCESSING PODS THROUGH THE INGRESS\nEverything is now set up, so you can access the service at http:/\n/kubia.example.com\n(using a browser or curl):\n$ curl http://kubia.example.com\nYou\u0027ve hit kubia-ke823\nYou\u2019ve successfully accessed the service through an Ingress. Let\u2019s take a better look at\nhow that unfolded.\nUNDERSTANDING HOW INGRESSES WORK\nFigure 5.10 shows how the client connected to one of the pods through the Ingress\ncontroller. The client first performed a DNS lookup of kubia.example.com, and the\nDNS server (or the local operating system) returned the IP of the Ingress controller.\nThe client then sent an HTTP request to the Ingress controller and specified\nkubia.example.com in the Host header. From that header, the controller determined\nwhich service the client is trying to access, looked up the pod IPs through the End-\npoints object associated with the service, and forwarded the client\u2019s request to one of\nthe pods.\n As you can see, the Ingress controller didn\u2019t forward the request to the service. It\nonly used it to select a pod. Most, if not all, controllers work like this. \n \n", "shape": "dot", "size": 10, "title": "145\nExposing services externally through an Ingress resource\nNOTE\nIngress controllers on cloud providers (in GKE, for example) require\nthe Ingress to point to a NodePort service. But that\u2019s not a requirement of\nKubernetes itself.\n5.4.2\nAccessing the service through the Ingress\nTo access your service through http:/\n/kubia.example.com, you\u2019ll need to make sure\nthe domain name resolves to the IP of the Ingress controller. \nOBTAINING THE IP ADDRESS OF THE INGRESS\nTo look up the IP, you need to list Ingresses:\n$ kubectl get ingresses\nNAME      HOSTS               ADDRESS          PORTS     AGE\nkubia     kubia.example.com   192.168.99.100   80        29m\nNOTE\nWhen running on cloud providers, the address may take time to appear,\nbecause the Ingress controller provisions a load balancer behind the scenes.\nThe IP is shown in the ADDRESS column. \nENSURING THE HOST CONFIGURED IN THE INGRESS POINTS TO THE INGRESS\u2019 IP ADDRESS\nOnce you know the IP, you can then either configure your DNS servers to resolve\nkubia.example.com to that IP or you can add the following line to /etc/hosts (or\nC:\\windows\\system32\\drivers\\etc\\hosts on Windows):\n192.168.99.100    kubia.example.com\nACCESSING PODS THROUGH THE INGRESS\nEverything is now set up, so you can access the service at http:/\n/kubia.example.com\n(using a browser or curl):\n$ curl http://kubia.example.com\nYou\u0027ve hit kubia-ke823\nYou\u2019ve successfully accessed the service through an Ingress. Let\u2019s take a better look at\nhow that unfolded.\nUNDERSTANDING HOW INGRESSES WORK\nFigure 5.10 shows how the client connected to one of the pods through the Ingress\ncontroller. The client first performed a DNS lookup of kubia.example.com, and the\nDNS server (or the local operating system) returned the IP of the Ingress controller.\nThe client then sent an HTTP request to the Ingress controller and specified\nkubia.example.com in the Host header. From that header, the controller determined\nwhich service the client is trying to access, looked up the pod IPs through the End-\npoints object associated with the service, and forwarded the client\u2019s request to one of\nthe pods.\n As you can see, the Ingress controller didn\u2019t forward the request to the service. It\nonly used it to select a pod. Most, if not all, controllers work like this. \n \n"}, {"color": "green", "id": "text_89", "label": "146\nCHAPTER 5\nServices: enabling clients to discover and talk to pods\n5.4.3\nExposing multiple services through the same Ingress\nIf you look at the Ingress spec closely, you\u2019ll see that both rules and paths are arrays,\nso they can contain multiple items. An Ingress can map multiple hosts and paths to\nmultiple services, as you\u2019ll see next. Let\u2019s focus on paths first. \nMAPPING DIFFERENT SERVICES TO DIFFERENT PATHS OF THE SAME HOST\nYou can map multiple paths on the same host to different services, as shown in the\nfollowing listing.\n...\n  - host: kubia.example.com\n    http:\n      paths:\n      - path: /kubia                \n        backend:                    \n          serviceName: kubia        \n          servicePort: 80           \n      - path: /foo                \n        backend:                  \n          serviceName: bar        \n          servicePort: 80         \nIn this case, requests will be sent to two different services, depending on the path in\nthe requested URL. Clients can therefore reach two different services through a single\nIP address (that of the Ingress controller).\nListing 5.14\nIngress exposing multiple services on same host, but different paths\nNode A\nPod\nNode B\nPod\nPod\nIngress\ncontroller\nEndpoints\nService\nIngress\nClient\n2. Client sends HTTP GET\nrequest with header\nHost: kubia.example.com\n3. Controller sends\nrequest to one of\nthe pods.\n1. Client looks up\nkubia.example.com\nDNS\nFigure 5.10\nAccessing pods through an Ingress\nRequests to kubia.example.com/kubia \nwill be routed to the kubia service.\nRequests to kubia.example.com/bar \nwill be routed to the bar service.\n \n", "shape": "dot", "size": 10, "title": "146\nCHAPTER 5\nServices: enabling clients to discover and talk to pods\n5.4.3\nExposing multiple services through the same Ingress\nIf you look at the Ingress spec closely, you\u2019ll see that both rules and paths are arrays,\nso they can contain multiple items. An Ingress can map multiple hosts and paths to\nmultiple services, as you\u2019ll see next. Let\u2019s focus on paths first. \nMAPPING DIFFERENT SERVICES TO DIFFERENT PATHS OF THE SAME HOST\nYou can map multiple paths on the same host to different services, as shown in the\nfollowing listing.\n...\n  - host: kubia.example.com\n    http:\n      paths:\n      - path: /kubia                \n        backend:                    \n          serviceName: kubia        \n          servicePort: 80           \n      - path: /foo                \n        backend:                  \n          serviceName: bar        \n          servicePort: 80         \nIn this case, requests will be sent to two different services, depending on the path in\nthe requested URL. Clients can therefore reach two different services through a single\nIP address (that of the Ingress controller).\nListing 5.14\nIngress exposing multiple services on same host, but different paths\nNode A\nPod\nNode B\nPod\nPod\nIngress\ncontroller\nEndpoints\nService\nIngress\nClient\n2. Client sends HTTP GET\nrequest with header\nHost: kubia.example.com\n3. Controller sends\nrequest to one of\nthe pods.\n1. Client looks up\nkubia.example.com\nDNS\nFigure 5.10\nAccessing pods through an Ingress\nRequests to kubia.example.com/kubia \nwill be routed to the kubia service.\nRequests to kubia.example.com/bar \nwill be routed to the bar service.\n \n"}, {"color": "green", "id": "text_90", "label": "147\nExposing services externally through an Ingress resource\nMAPPING DIFFERENT SERVICES TO DIFFERENT HOSTS\nSimilarly, you can use an Ingress to map to different services based on the host in the\nHTTP request instead of (only) the path, as shown in the next listing.\nspec:\n  rules:\n  - host: foo.example.com          \n    http:\n      paths:\n      - path: / \n        backend:\n          serviceName: foo         \n          servicePort: 80\n  - host: bar.example.com          \n    http:\n      paths:\n      - path: /\n        backend:\n          serviceName: bar         \n          servicePort: 80\nRequests received by the controller will be forwarded to either service foo or bar,\ndepending on the Host header in the request (the way virtual hosts are handled in\nweb servers). DNS needs to point both the foo.example.com and the bar.exam-\nple.com domain names to the Ingress controller\u2019s IP address. \n5.4.4\nConfiguring Ingress to handle TLS traffic\nYou\u2019ve seen how an Ingress forwards HTTP traffic. But what about HTTPS? Let\u2019s take\na quick look at how to configure Ingress to support TLS. \nCREATING A TLS CERTIFICATE FOR THE INGRESS\nWhen a client opens a TLS connection to an Ingress controller, the controller termi-\nnates the TLS connection. The communication between the client and the controller\nis encrypted, whereas the communication between the controller and the backend\npod isn\u2019t. The application running in the pod doesn\u2019t need to support TLS. For exam-\nple, if the pod runs a web server, it can accept only HTTP traffic and let the Ingress\ncontroller take care of everything related to TLS. To enable the controller to do that,\nyou need to attach a certificate and a private key to the Ingress. The two need to be\nstored in a Kubernetes resource called a Secret, which is then referenced in the\nIngress manifest. We\u2019ll explain Secrets in detail in chapter 7. For now, you\u2019ll create the\nSecret without paying too much attention to it.\n First, you need to create the private key and certificate:\n$ openssl genrsa -out tls.key 2048\n$ openssl req -new -x509 -key tls.key -out tls.cert -days 360 -subj \n\u27a5 /CN=kubia.example.com\nListing 5.15\nIngress exposing multiple services on different hosts\nRequests for \nfoo.example.com will be \nrouted to service foo.\nRequests for \nbar.example.com will be \nrouted to service bar.\n \n", "shape": "dot", "size": 10, "title": "147\nExposing services externally through an Ingress resource\nMAPPING DIFFERENT SERVICES TO DIFFERENT HOSTS\nSimilarly, you can use an Ingress to map to different services based on the host in the\nHTTP request instead of (only) the path, as shown in the next listing.\nspec:\n  rules:\n  - host: foo.example.com          \n    http:\n      paths:\n      - path: / \n        backend:\n          serviceName: foo         \n          servicePort: 80\n  - host: bar.example.com          \n    http:\n      paths:\n      - path: /\n        backend:\n          serviceName: bar         \n          servicePort: 80\nRequests received by the controller will be forwarded to either service foo or bar,\ndepending on the Host header in the request (the way virtual hosts are handled in\nweb servers). DNS needs to point both the foo.example.com and the bar.exam-\nple.com domain names to the Ingress controller\u2019s IP address. \n5.4.4\nConfiguring Ingress to handle TLS traffic\nYou\u2019ve seen how an Ingress forwards HTTP traffic. But what about HTTPS? Let\u2019s take\na quick look at how to configure Ingress to support TLS. \nCREATING A TLS CERTIFICATE FOR THE INGRESS\nWhen a client opens a TLS connection to an Ingress controller, the controller termi-\nnates the TLS connection. The communication between the client and the controller\nis encrypted, whereas the communication between the controller and the backend\npod isn\u2019t. The application running in the pod doesn\u2019t need to support TLS. For exam-\nple, if the pod runs a web server, it can accept only HTTP traffic and let the Ingress\ncontroller take care of everything related to TLS. To enable the controller to do that,\nyou need to attach a certificate and a private key to the Ingress. The two need to be\nstored in a Kubernetes resource called a Secret, which is then referenced in the\nIngress manifest. We\u2019ll explain Secrets in detail in chapter 7. For now, you\u2019ll create the\nSecret without paying too much attention to it.\n First, you need to create the private key and certificate:\n$ openssl genrsa -out tls.key 2048\n$ openssl req -new -x509 -key tls.key -out tls.cert -days 360 -subj \n\u27a5 /CN=kubia.example.com\nListing 5.15\nIngress exposing multiple services on different hosts\nRequests for \nfoo.example.com will be \nrouted to service foo.\nRequests for \nbar.example.com will be \nrouted to service bar.\n \n"}, {"color": "green", "id": "text_91", "label": "148\nCHAPTER 5\nServices: enabling clients to discover and talk to pods\nThen you create the Secret from the two files like this:\n$ kubectl create secret tls tls-secret --cert=tls.cert --key=tls.key\nsecret \"tls-secret\" created\nThe private key and the certificate are now stored in the Secret called tls-secret.\nNow, you can update your Ingress object so it will also accept HTTPS requests for\nkubia.example.com. The Ingress manifest should now look like the following listing.\napiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  name: kubia\nspec:\n  tls:                           \n  - hosts:                        \n    - kubia.example.com           \n    secretName: tls-secret       \n  rules:\n  - host: kubia.example.com\n    http:\n      paths:\n      - path: /\n        backend:\n          serviceName: kubia-nodeport\n          servicePort: 80\nTIP\nInstead of deleting the Ingress and re-creating it from the new file, you\ncan invoke kubectl apply -f kubia-ingress-tls.yaml, which updates the\nIngress resource with what\u2019s specified in the file.\nSigning certificates through the CertificateSigningRequest resource\nInstead of signing the certificate ourselves, you can get the certificate signed by\ncreating a CertificateSigningRequest (CSR) resource. Users or their applications\ncan create a regular certificate request, put it into a CSR, and then either a human\noperator or an automated process can approve the request like this:\n$ kubectl certificate approve \u003cname of the CSR\u003e \nThe signed certificate can then be retrieved from the CSR\u2019s status.certificate\nfield. \nNote that a certificate signer component must be running in the cluster; otherwise\ncreating CertificateSigningRequest and approving or denying them won\u2019t have\nany effect.\nListing 5.16\nIngress handling TLS traffic: kubia-ingress-tls.yaml\nThe whole TLS configuration \nis under this attribute.\nTLS connections will be accepted for \nthe kubia.example.com hostname.\nThe private key and the certificate \nshould be obtained from the tls-\nsecret you created previously.\n \n", "shape": "dot", "size": 10, "title": "148\nCHAPTER 5\nServices: enabling clients to discover and talk to pods\nThen you create the Secret from the two files like this:\n$ kubectl create secret tls tls-secret --cert=tls.cert --key=tls.key\nsecret \"tls-secret\" created\nThe private key and the certificate are now stored in the Secret called tls-secret.\nNow, you can update your Ingress object so it will also accept HTTPS requests for\nkubia.example.com. The Ingress manifest should now look like the following listing.\napiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  name: kubia\nspec:\n  tls:                           \n  - hosts:                        \n    - kubia.example.com           \n    secretName: tls-secret       \n  rules:\n  - host: kubia.example.com\n    http:\n      paths:\n      - path: /\n        backend:\n          serviceName: kubia-nodeport\n          servicePort: 80\nTIP\nInstead of deleting the Ingress and re-creating it from the new file, you\ncan invoke kubectl apply -f kubia-ingress-tls.yaml, which updates the\nIngress resource with what\u2019s specified in the file.\nSigning certificates through the CertificateSigningRequest resource\nInstead of signing the certificate ourselves, you can get the certificate signed by\ncreating a CertificateSigningRequest (CSR) resource. Users or their applications\ncan create a regular certificate request, put it into a CSR, and then either a human\noperator or an automated process can approve the request like this:\n$ kubectl certificate approve \u003cname of the CSR\u003e \nThe signed certificate can then be retrieved from the CSR\u2019s status.certificate\nfield. \nNote that a certificate signer component must be running in the cluster; otherwise\ncreating CertificateSigningRequest and approving or denying them won\u2019t have\nany effect.\nListing 5.16\nIngress handling TLS traffic: kubia-ingress-tls.yaml\nThe whole TLS configuration \nis under this attribute.\nTLS connections will be accepted for \nthe kubia.example.com hostname.\nThe private key and the certificate \nshould be obtained from the tls-\nsecret you created previously.\n \n"}, {"color": "green", "id": "text_92", "label": "149\nSignaling when a pod is ready to accept connections\nYou can now use HTTPS to access your service through the Ingress:\n$ curl -k -v https://kubia.example.com/kubia\n* About to connect() to kubia.example.com port 443 (#0)\n...\n* Server certificate:\n*   subject: CN=kubia.example.com\n...\n\u003e GET /kubia HTTP/1.1\n\u003e ...\nYou\u0027ve hit kubia-xueq1\nThe command\u2019s output shows the response from the app, as well as the server certifi-\ncate you configured the Ingress with.\nNOTE\nSupport for Ingress features varies between the different Ingress con-\ntroller implementations, so check the implementation-specific documenta-\ntion to see what\u2019s supported. \nIngresses are a relatively new Kubernetes feature, so you can expect to see many\nimprovements and new features in the future. Although they currently support only\nL7 (HTTP/HTTPS) load balancing, support for L4 load balancing is also planned.\n5.5\nSignaling when a pod is ready to accept connections\nThere\u2019s one more thing we need to cover regarding both Services and Ingresses.\nYou\u2019ve already learned that pods are included as endpoints of a service if their labels\nmatch the service\u2019s pod selector. As soon as a new pod with proper labels is created, it\nbecomes part of the service and requests start to be redirected to the pod. But what if\nthe pod isn\u2019t ready to start serving requests immediately? \n The pod may need time to load either configuration or data, or it may need to per-\nform a warm-up procedure to prevent the first user request from taking too long and\naffecting the user experience. In such cases you don\u2019t want the pod to start receiving\nrequests immediately, especially when the already-running instances can process\nrequests properly and quickly. It makes sense to not forward requests to a pod that\u2019s in\nthe process of starting up until it\u2019s fully ready.\n5.5.1\nIntroducing readiness probes\nIn the previous chapter you learned about liveness probes and how they help keep\nyour apps healthy by ensuring unhealthy containers are restarted automatically.\nSimilar to liveness probes, Kubernetes allows you to also define a readiness probe\nfor your pod.\n The readiness probe is invoked periodically and determines whether the specific\npod should receive client requests or not. When a container\u2019s readiness probe returns\nsuccess, it\u2019s signaling that the container is ready to accept requests. \n This notion of being ready is obviously something that\u2019s specific to each container.\nKubernetes can merely check if the app running in the container responds to a simple\n \n", "shape": "dot", "size": 10, "title": "149\nSignaling when a pod is ready to accept connections\nYou can now use HTTPS to access your service through the Ingress:\n$ curl -k -v https://kubia.example.com/kubia\n* About to connect() to kubia.example.com port 443 (#0)\n...\n* Server certificate:\n*   subject: CN=kubia.example.com\n...\n\u003e GET /kubia HTTP/1.1\n\u003e ...\nYou\u0027ve hit kubia-xueq1\nThe command\u2019s output shows the response from the app, as well as the server certifi-\ncate you configured the Ingress with.\nNOTE\nSupport for Ingress features varies between the different Ingress con-\ntroller implementations, so check the implementation-specific documenta-\ntion to see what\u2019s supported. \nIngresses are a relatively new Kubernetes feature, so you can expect to see many\nimprovements and new features in the future. Although they currently support only\nL7 (HTTP/HTTPS) load balancing, support for L4 load balancing is also planned.\n5.5\nSignaling when a pod is ready to accept connections\nThere\u2019s one more thing we need to cover regarding both Services and Ingresses.\nYou\u2019ve already learned that pods are included as endpoints of a service if their labels\nmatch the service\u2019s pod selector. As soon as a new pod with proper labels is created, it\nbecomes part of the service and requests start to be redirected to the pod. But what if\nthe pod isn\u2019t ready to start serving requests immediately? \n The pod may need time to load either configuration or data, or it may need to per-\nform a warm-up procedure to prevent the first user request from taking too long and\naffecting the user experience. In such cases you don\u2019t want the pod to start receiving\nrequests immediately, especially when the already-running instances can process\nrequests properly and quickly. It makes sense to not forward requests to a pod that\u2019s in\nthe process of starting up until it\u2019s fully ready.\n5.5.1\nIntroducing readiness probes\nIn the previous chapter you learned about liveness probes and how they help keep\nyour apps healthy by ensuring unhealthy containers are restarted automatically.\nSimilar to liveness probes, Kubernetes allows you to also define a readiness probe\nfor your pod.\n The readiness probe is invoked periodically and determines whether the specific\npod should receive client requests or not. When a container\u2019s readiness probe returns\nsuccess, it\u2019s signaling that the container is ready to accept requests. \n This notion of being ready is obviously something that\u2019s specific to each container.\nKubernetes can merely check if the app running in the container responds to a simple\n \n"}, {"color": "green", "id": "text_93", "label": "150\nCHAPTER 5\nServices: enabling clients to discover and talk to pods\nGET / request or it can hit a specific URL path, which causes the app to perform a\nwhole list of checks to determine if it\u2019s ready. Such a detailed readiness probe, which\ntakes the app\u2019s specifics into account, is the app developer\u2019s responsibility. \nTYPES OF READINESS PROBES\nLike liveness probes, three types of readiness probes exist:\n\uf0a1An Exec probe, where a process is executed. The container\u2019s status is deter-\nmined by the process\u2019 exit status code.\n\uf0a1An HTTP GET probe, which sends an HTTP GET request to the container and\nthe HTTP status code of the response determines whether the container is\nready or not.\n\uf0a1A TCP Socket probe, which opens a TCP connection to a specified port of the\ncontainer. If the connection is established, the container is considered ready.\nUNDERSTANDING THE OPERATION OF READINESS PROBES\nWhen a container is started, Kubernetes can be configured to wait for a configurable\namount of time to pass before performing the first readiness check. After that, it\ninvokes the probe periodically and acts based on the result of the readiness probe. If a\npod reports that it\u2019s not ready, it\u2019s removed from the service. If the pod then becomes\nready again, it\u2019s re-added. \n Unlike liveness probes, if a container fails the readiness check, it won\u2019t be killed or\nrestarted. This is an important distinction between liveness and readiness probes.\nLiveness probes keep pods healthy by killing off unhealthy containers and replacing\nthem with new, healthy ones, whereas readiness probes make sure that only pods that\nare ready to serve requests receive them. This is mostly necessary during container\nstart up, but it\u2019s also useful after the container has been running for a while. \n As you can see in figure 5.11, if a pod\u2019s readiness probe fails, the pod is removed\nfrom the Endpoints object. Clients connecting to the service will not be redirected to\nthe pod. The effect is the same as when the pod doesn\u2019t match the service\u2019s label\nselector at all.\nEndpoints\nService\nSelector: app=kubia\napp: kubia\nPod: kubia-q3vkg\napp: kubia\nPod: kubia-k0xz6\napp: kubia\nPod: kubia-53thy\nNot ready\nThis pod is no longer\nan endpoint, because its\nreadiness probe has failed.\nFigure 5.11\nA pod whose readiness probe fails is removed as an endpoint of a service.\n \n", "shape": "dot", "size": 10, "title": "150\nCHAPTER 5\nServices: enabling clients to discover and talk to pods\nGET / request or it can hit a specific URL path, which causes the app to perform a\nwhole list of checks to determine if it\u2019s ready. Such a detailed readiness probe, which\ntakes the app\u2019s specifics into account, is the app developer\u2019s responsibility. \nTYPES OF READINESS PROBES\nLike liveness probes, three types of readiness probes exist:\n\uf0a1An Exec probe, where a process is executed. The container\u2019s status is deter-\nmined by the process\u2019 exit status code.\n\uf0a1An HTTP GET probe, which sends an HTTP GET request to the container and\nthe HTTP status code of the response determines whether the container is\nready or not.\n\uf0a1A TCP Socket probe, which opens a TCP connection to a specified port of the\ncontainer. If the connection is established, the container is considered ready.\nUNDERSTANDING THE OPERATION OF READINESS PROBES\nWhen a container is started, Kubernetes can be configured to wait for a configurable\namount of time to pass before performing the first readiness check. After that, it\ninvokes the probe periodically and acts based on the result of the readiness probe. If a\npod reports that it\u2019s not ready, it\u2019s removed from the service. If the pod then becomes\nready again, it\u2019s re-added. \n Unlike liveness probes, if a container fails the readiness check, it won\u2019t be killed or\nrestarted. This is an important distinction between liveness and readiness probes.\nLiveness probes keep pods healthy by killing off unhealthy containers and replacing\nthem with new, healthy ones, whereas readiness probes make sure that only pods that\nare ready to serve requests receive them. This is mostly necessary during container\nstart up, but it\u2019s also useful after the container has been running for a while. \n As you can see in figure 5.11, if a pod\u2019s readiness probe fails, the pod is removed\nfrom the Endpoints object. Clients connecting to the service will not be redirected to\nthe pod. The effect is the same as when the pod doesn\u2019t match the service\u2019s label\nselector at all.\nEndpoints\nService\nSelector: app=kubia\napp: kubia\nPod: kubia-q3vkg\napp: kubia\nPod: kubia-k0xz6\napp: kubia\nPod: kubia-53thy\nNot ready\nThis pod is no longer\nan endpoint, because its\nreadiness probe has failed.\nFigure 5.11\nA pod whose readiness probe fails is removed as an endpoint of a service.\n \n"}, {"color": "green", "id": "text_94", "label": "151\nSignaling when a pod is ready to accept connections\nUNDERSTANDING WHY READINESS PROBES ARE IMPORTANT\nImagine that a group of pods (for example, pods running application servers)\ndepends on a service provided by another pod (a backend database, for example). If\nat any point one of the frontend pods experiences connectivity problems and can\u2019t\nreach the database anymore, it may be wise for its readiness probe to signal to Kuber-\nnetes that the pod isn\u2019t ready to serve any requests at that time. If other pod instances\naren\u2019t experiencing the same type of connectivity issues, they can serve requests nor-\nmally. A readiness probe makes sure clients only talk to those healthy pods and never\nnotice there\u2019s anything wrong with the system.\n5.5.2\nAdding a readiness probe to a pod\nNext you\u2019ll add a readiness probe to your existing pods by modifying the Replication-\nController\u2019s pod template. \nADDING A READINESS PROBE TO THE POD TEMPLATE\nYou\u2019ll use the kubectl edit command to add the probe to the pod template in your\nexisting ReplicationController:\n$ kubectl edit rc kubia\nWhen the ReplicationController\u2019s YAML opens in the text editor, find the container\nspecification in the pod template and add the following readiness probe definition to\nthe first container under spec.template.spec.containers. The YAML should look\nlike the following listing.\napiVersion: v1\nkind: ReplicationController\n...\nspec:\n  ...\n  template:\n    ...\n    spec:\n      containers:\n      - name: kubia\n        image: luksa/kubia\n        readinessProbe:       \n          exec:               \n            command:          \n            - ls              \n            - /var/ready      \n        ...\nThe readiness probe will periodically perform the command ls /var/ready inside the\ncontainer. The ls command returns exit code zero if the file exists, or a non-zero exit\ncode otherwise. If the file exists, the readiness probe will succeed; otherwise, it will fail. \nListing 5.17\nRC creating a pod with a readiness probe: kubia-rc-readinessprobe.yaml\nA readinessProbe may \nbe defined for each \ncontainer in the pod.\n \n", "shape": "dot", "size": 10, "title": "151\nSignaling when a pod is ready to accept connections\nUNDERSTANDING WHY READINESS PROBES ARE IMPORTANT\nImagine that a group of pods (for example, pods running application servers)\ndepends on a service provided by another pod (a backend database, for example). If\nat any point one of the frontend pods experiences connectivity problems and can\u2019t\nreach the database anymore, it may be wise for its readiness probe to signal to Kuber-\nnetes that the pod isn\u2019t ready to serve any requests at that time. If other pod instances\naren\u2019t experiencing the same type of connectivity issues, they can serve requests nor-\nmally. A readiness probe makes sure clients only talk to those healthy pods and never\nnotice there\u2019s anything wrong with the system.\n5.5.2\nAdding a readiness probe to a pod\nNext you\u2019ll add a readiness probe to your existing pods by modifying the Replication-\nController\u2019s pod template. \nADDING A READINESS PROBE TO THE POD TEMPLATE\nYou\u2019ll use the kubectl edit command to add the probe to the pod template in your\nexisting ReplicationController:\n$ kubectl edit rc kubia\nWhen the ReplicationController\u2019s YAML opens in the text editor, find the container\nspecification in the pod template and add the following readiness probe definition to\nthe first container under spec.template.spec.containers. The YAML should look\nlike the following listing.\napiVersion: v1\nkind: ReplicationController\n...\nspec:\n  ...\n  template:\n    ...\n    spec:\n      containers:\n      - name: kubia\n        image: luksa/kubia\n        readinessProbe:       \n          exec:               \n            command:          \n            - ls              \n            - /var/ready      \n        ...\nThe readiness probe will periodically perform the command ls /var/ready inside the\ncontainer. The ls command returns exit code zero if the file exists, or a non-zero exit\ncode otherwise. If the file exists, the readiness probe will succeed; otherwise, it will fail. \nListing 5.17\nRC creating a pod with a readiness probe: kubia-rc-readinessprobe.yaml\nA readinessProbe may \nbe defined for each \ncontainer in the pod.\n \n"}, {"color": "green", "id": "text_95", "label": "152\nCHAPTER 5\nServices: enabling clients to discover and talk to pods\n The reason you\u2019re defining such a strange readiness probe is so you can toggle its\nresult by creating or removing the file in question. The file doesn\u2019t exist yet, so all the\npods should now report not being ready, right? Well, not exactly. As you may remem-\nber from the previous chapter, changing a ReplicationController\u2019s pod template has\nno effect on existing pods. \n In other words, all your existing pods still have no readiness probe defined. You\ncan see this by listing the pods with kubectl get pods and looking at the READY col-\numn. You need to delete the pods and have them re-created by the Replication-\nController. The new pods will fail the readiness check and won\u2019t be included as\nendpoints of the service until you create the /var/ready file in each of them. \nOBSERVING AND MODIFYING THE PODS\u2019 READINESS STATUS\nList the pods again and inspect whether they\u2019re ready or not:\n$ kubectl get po\nNAME          READY     STATUS    RESTARTS   AGE\nkubia-2r1qb   0/1       Running   0          1m\nkubia-3rax1   0/1       Running   0          1m\nkubia-3yw4s   0/1       Running   0          1m\nThe READY column shows that none of the containers are ready. Now make the readi-\nness probe of one of them start returning success by creating the /var/ready file,\nwhose existence makes your mock readiness probe succeed:\n$ kubectl exec kubia-2r1qb -- touch /var/ready\nYou\u2019ve used the kubectl exec command to execute the touch command inside the\ncontainer of the kubia-2r1qb pod. The touch command creates the file if it doesn\u2019t\nyet exist. The pod\u2019s readiness probe command should now exit with status code 0,\nwhich means the probe is successful, and the pod should now be shown as ready. Let\u2019s\nsee if it is:\n$ kubectl get po kubia-2r1qb\nNAME          READY     STATUS    RESTARTS   AGE\nkubia-2r1qb   0/1       Running   0          2m\nThe pod still isn\u2019t ready. Is there something wrong or is this the expected result? Take\na more detailed look at the pod with kubectl describe. The output should contain\nthe following line:\nReadiness: exec [ls /var/ready] delay=0s timeout=1s period=10s #success=1\n\u27a5 #failure=3\nThe readiness probe is checked periodically\u2014every 10 seconds by default. The pod\nisn\u2019t ready because the readiness probe hasn\u2019t been invoked yet. But in 10 seconds at\nthe latest, the pod should become ready and its IP should be listed as the only end-\npoint of the service (run kubectl get endpoints kubia-loadbalancer to confirm). \n \n", "shape": "dot", "size": 10, "title": "152\nCHAPTER 5\nServices: enabling clients to discover and talk to pods\n The reason you\u2019re defining such a strange readiness probe is so you can toggle its\nresult by creating or removing the file in question. The file doesn\u2019t exist yet, so all the\npods should now report not being ready, right? Well, not exactly. As you may remem-\nber from the previous chapter, changing a ReplicationController\u2019s pod template has\nno effect on existing pods. \n In other words, all your existing pods still have no readiness probe defined. You\ncan see this by listing the pods with kubectl get pods and looking at the READY col-\numn. You need to delete the pods and have them re-created by the Replication-\nController. The new pods will fail the readiness check and won\u2019t be included as\nendpoints of the service until you create the /var/ready file in each of them. \nOBSERVING AND MODIFYING THE PODS\u2019 READINESS STATUS\nList the pods again and inspect whether they\u2019re ready or not:\n$ kubectl get po\nNAME          READY     STATUS    RESTARTS   AGE\nkubia-2r1qb   0/1       Running   0          1m\nkubia-3rax1   0/1       Running   0          1m\nkubia-3yw4s   0/1       Running   0          1m\nThe READY column shows that none of the containers are ready. Now make the readi-\nness probe of one of them start returning success by creating the /var/ready file,\nwhose existence makes your mock readiness probe succeed:\n$ kubectl exec kubia-2r1qb -- touch /var/ready\nYou\u2019ve used the kubectl exec command to execute the touch command inside the\ncontainer of the kubia-2r1qb pod. The touch command creates the file if it doesn\u2019t\nyet exist. The pod\u2019s readiness probe command should now exit with status code 0,\nwhich means the probe is successful, and the pod should now be shown as ready. Let\u2019s\nsee if it is:\n$ kubectl get po kubia-2r1qb\nNAME          READY     STATUS    RESTARTS   AGE\nkubia-2r1qb   0/1       Running   0          2m\nThe pod still isn\u2019t ready. Is there something wrong or is this the expected result? Take\na more detailed look at the pod with kubectl describe. The output should contain\nthe following line:\nReadiness: exec [ls /var/ready] delay=0s timeout=1s period=10s #success=1\n\u27a5 #failure=3\nThe readiness probe is checked periodically\u2014every 10 seconds by default. The pod\nisn\u2019t ready because the readiness probe hasn\u2019t been invoked yet. But in 10 seconds at\nthe latest, the pod should become ready and its IP should be listed as the only end-\npoint of the service (run kubectl get endpoints kubia-loadbalancer to confirm). \n \n"}, {"color": "green", "id": "text_96", "label": "153\nSignaling when a pod is ready to accept connections\nHITTING THE SERVICE WITH THE SINGLE READY POD\nYou can now hit the service URL a few times to see that each and every request is redi-\nrected to this one pod:\n$ curl http://130.211.53.173\nYou\u2019ve hit kubia-2r1qb\n$ curl http://130.211.53.173\nYou\u2019ve hit kubia-2r1qb\n...\n$ curl http://130.211.53.173\nYou\u2019ve hit kubia-2r1qb\nEven though there are three pods running, only a single pod is reporting as being\nready and is therefore the only pod receiving requests. If you now delete the file, the\npod will be removed from the service again. \n5.5.3\nUnderstanding what real-world readiness probes should do\nThis mock readiness probe is useful only for demonstrating what readiness probes do.\nIn the real world, the readiness probe should return success or failure depending on\nwhether the app can (and wants to) receive client requests or not. \n Manually removing pods from services should be performed by either deleting the\npod or changing the pod\u2019s labels instead of manually flipping a switch in the probe. \nTIP\nIf you want to add or remove a pod from a service manually, add\nenabled=true as a label to your pod and to the label selector of your service.\nRemove the label when you want to remove the pod from the service.\nALWAYS DEFINE A READINESS PROBE\nBefore we conclude this section, there are two final notes about readiness probes that\nI need to emphasize. First, if you don\u2019t add a readiness probe to your pods, they\u2019ll\nbecome service endpoints almost immediately. If your application takes too long to\nstart listening for incoming connections, client requests hitting the service will be for-\nwarded to the pod while it\u2019s still starting up and not ready to accept incoming connec-\ntions. Clients will therefore see \u201cConnection refused\u201d types of errors. \nTIP\nYou should always define a readiness probe, even if it\u2019s as simple as send-\ning an HTTP request to the base URL. \nDON\u2019T INCLUDE POD SHUTDOWN LOGIC INTO YOUR READINESS PROBES\nThe other thing I need to mention applies to the other end of the pod\u2019s life (pod\nshutdown) and is also related to clients experiencing connection errors. \n When a pod is being shut down, the app running in it usually stops accepting con-\nnections as soon as it receives the termination signal. Because of this, you might think\nyou need to make your readiness probe start failing as soon as the shutdown proce-\ndure is initiated, ensuring the pod is removed from all services it\u2019s part of. But that\u2019s\nnot necessary, because Kubernetes removes the pod from all services as soon as you\ndelete the pod.\n \n", "shape": "dot", "size": 10, "title": "153\nSignaling when a pod is ready to accept connections\nHITTING THE SERVICE WITH THE SINGLE READY POD\nYou can now hit the service URL a few times to see that each and every request is redi-\nrected to this one pod:\n$ curl http://130.211.53.173\nYou\u2019ve hit kubia-2r1qb\n$ curl http://130.211.53.173\nYou\u2019ve hit kubia-2r1qb\n...\n$ curl http://130.211.53.173\nYou\u2019ve hit kubia-2r1qb\nEven though there are three pods running, only a single pod is reporting as being\nready and is therefore the only pod receiving requests. If you now delete the file, the\npod will be removed from the service again. \n5.5.3\nUnderstanding what real-world readiness probes should do\nThis mock readiness probe is useful only for demonstrating what readiness probes do.\nIn the real world, the readiness probe should return success or failure depending on\nwhether the app can (and wants to) receive client requests or not. \n Manually removing pods from services should be performed by either deleting the\npod or changing the pod\u2019s labels instead of manually flipping a switch in the probe. \nTIP\nIf you want to add or remove a pod from a service manually, add\nenabled=true as a label to your pod and to the label selector of your service.\nRemove the label when you want to remove the pod from the service.\nALWAYS DEFINE A READINESS PROBE\nBefore we conclude this section, there are two final notes about readiness probes that\nI need to emphasize. First, if you don\u2019t add a readiness probe to your pods, they\u2019ll\nbecome service endpoints almost immediately. If your application takes too long to\nstart listening for incoming connections, client requests hitting the service will be for-\nwarded to the pod while it\u2019s still starting up and not ready to accept incoming connec-\ntions. Clients will therefore see \u201cConnection refused\u201d types of errors. \nTIP\nYou should always define a readiness probe, even if it\u2019s as simple as send-\ning an HTTP request to the base URL. \nDON\u2019T INCLUDE POD SHUTDOWN LOGIC INTO YOUR READINESS PROBES\nThe other thing I need to mention applies to the other end of the pod\u2019s life (pod\nshutdown) and is also related to clients experiencing connection errors. \n When a pod is being shut down, the app running in it usually stops accepting con-\nnections as soon as it receives the termination signal. Because of this, you might think\nyou need to make your readiness probe start failing as soon as the shutdown proce-\ndure is initiated, ensuring the pod is removed from all services it\u2019s part of. But that\u2019s\nnot necessary, because Kubernetes removes the pod from all services as soon as you\ndelete the pod.\n \n"}, {"color": "green", "id": "text_97", "label": "154\nCHAPTER 5\nServices: enabling clients to discover and talk to pods\n5.6\nUsing a headless service for discovering individual pods\nYou\u2019ve seen how services can be used to provide a stable IP address allowing clients to\nconnect to pods (or other endpoints) backing each service. Each connection to the\nservice is forwarded to one randomly selected backing pod. But what if the client\nneeds to connect to all of those pods? What if the backing pods themselves need to\neach connect to all the other backing pods? Connecting through the service clearly\nisn\u2019t the way to do this. What is?\n For a client to connect to all pods, it needs to figure out the the IP of each individ-\nual pod. One option is to have the client call the Kubernetes API server and get the\nlist of pods and their IP addresses through an API call, but because you should always\nstrive to keep your apps Kubernetes-agnostic, using the API server isn\u2019t ideal. \n Luckily, Kubernetes allows clients to discover pod IPs through DNS lookups. Usually,\nwhen you perform a DNS lookup for a service, the DNS server returns a single IP\u2014the\nservice\u2019s cluster IP. But if you tell Kubernetes you don\u2019t need a cluster IP for your service\n(you do this by setting the clusterIP field to None in the service specification), the DNS\nserver will return the pod IPs instead of the single service IP.\n Instead of returning a single DNS A record, the DNS server will return multiple A\nrecords for the service, each pointing to the IP of an individual pod backing the ser-\nvice at that moment. Clients can therefore do a simple DNS A record lookup and get\nthe IPs of all the pods that are part of the service. The client can then use that infor-\nmation to connect to one, many, or all of them.\n5.6.1\nCreating a headless service\nSetting the clusterIP field in a service spec to None makes the service headless, as\nKubernetes won\u2019t assign it a cluster IP through which clients could connect to the\npods backing it. \n You\u2019ll create a headless service called kubia-headless now. The following listing\nshows its definition.\napiVersion: v1\nkind: Service\nmetadata:\n  name: kubia-headless\nspec:\n  clusterIP: None       \n  ports:\n  - port: 80\n    targetPort: 8080\n  selector:\n    app: kubia\nAfter you create the service with kubectl create, you can inspect it with kubectl get\nand kubectl describe. You\u2019ll see it has no cluster IP and its endpoints include (part of)\nListing 5.18\nA headless service: kubia-svc-headless.yaml\nThis makes the \nservice headless.\n \n", "shape": "dot", "size": 10, "title": "154\nCHAPTER 5\nServices: enabling clients to discover and talk to pods\n5.6\nUsing a headless service for discovering individual pods\nYou\u2019ve seen how services can be used to provide a stable IP address allowing clients to\nconnect to pods (or other endpoints) backing each service. Each connection to the\nservice is forwarded to one randomly selected backing pod. But what if the client\nneeds to connect to all of those pods? What if the backing pods themselves need to\neach connect to all the other backing pods? Connecting through the service clearly\nisn\u2019t the way to do this. What is?\n For a client to connect to all pods, it needs to figure out the the IP of each individ-\nual pod. One option is to have the client call the Kubernetes API server and get the\nlist of pods and their IP addresses through an API call, but because you should always\nstrive to keep your apps Kubernetes-agnostic, using the API server isn\u2019t ideal. \n Luckily, Kubernetes allows clients to discover pod IPs through DNS lookups. Usually,\nwhen you perform a DNS lookup for a service, the DNS server returns a single IP\u2014the\nservice\u2019s cluster IP. But if you tell Kubernetes you don\u2019t need a cluster IP for your service\n(you do this by setting the clusterIP field to None in the service specification), the DNS\nserver will return the pod IPs instead of the single service IP.\n Instead of returning a single DNS A record, the DNS server will return multiple A\nrecords for the service, each pointing to the IP of an individual pod backing the ser-\nvice at that moment. Clients can therefore do a simple DNS A record lookup and get\nthe IPs of all the pods that are part of the service. The client can then use that infor-\nmation to connect to one, many, or all of them.\n5.6.1\nCreating a headless service\nSetting the clusterIP field in a service spec to None makes the service headless, as\nKubernetes won\u2019t assign it a cluster IP through which clients could connect to the\npods backing it. \n You\u2019ll create a headless service called kubia-headless now. The following listing\nshows its definition.\napiVersion: v1\nkind: Service\nmetadata:\n  name: kubia-headless\nspec:\n  clusterIP: None       \n  ports:\n  - port: 80\n    targetPort: 8080\n  selector:\n    app: kubia\nAfter you create the service with kubectl create, you can inspect it with kubectl get\nand kubectl describe. You\u2019ll see it has no cluster IP and its endpoints include (part of)\nListing 5.18\nA headless service: kubia-svc-headless.yaml\nThis makes the \nservice headless.\n \n"}, {"color": "green", "id": "text_98", "label": "155\nUsing a headless service for discovering individual pods\nthe pods matching its pod selector. I say \u201cpart of\u201d because your pods contain a readi-\nness probe, so only pods that are ready will be listed as endpoints of the service.\nBefore continuing, please make sure at least two pods report being ready, by creating\nthe /var/ready file, as in the previous example:\n$ kubectl exec \u003cpod name\u003e -- touch /var/ready\n5.6.2\nDiscovering pods through DNS\nWith your pods ready, you can now try performing a DNS lookup to see if you get the\nactual pod IPs or not. You\u2019ll need to perform the lookup from inside one of the pods.\nUnfortunately, your kubia container image doesn\u2019t include the nslookup (or the dig)\nbinary, so you can\u2019t use it to perform the DNS lookup.\n All you\u2019re trying to do is perform a DNS lookup from inside a pod running in the\ncluster. Why not run a new pod based on an image that contains the binaries you\nneed? To perform DNS-related actions, you can use the tutum/dnsutils container\nimage, which is available on Docker Hub and contains both the nslookup and the dig\nbinaries. To run the pod, you can go through the whole process of creating a YAML\nmanifest for it and passing it to kubectl create, but that\u2019s too much work, right?\nLuckily, there\u2019s a faster way.\nRUNNING A POD WITHOUT WRITING A YAML MANIFEST\nIn chapter 1, you already created pods without writing a YAML manifest by using the\nkubectl run command. But this time you want to create only a pod\u2014you don\u2019t need\nto create a ReplicationController to manage the pod. You can do that like this:\n$ kubectl run dnsutils --image=tutum/dnsutils --generator=run-pod/v1\n\u27a5 --command -- sleep infinity\npod \"dnsutils\" created\nThe trick is in the --generator=run-pod/v1 option, which tells kubectl to create the\npod directly, without any kind of ReplicationController or similar behind it. \nUNDERSTANDING DNS A RECORDS RETURNED FOR A HEADLESS SERVICE\nLet\u2019s use the newly created pod to perform a DNS lookup:\n$ kubectl exec dnsutils nslookup kubia-headless\n...\nName:    kubia-headless.default.svc.cluster.local\nAddress: 10.108.1.4 \nName:    kubia-headless.default.svc.cluster.local\nAddress: 10.108.2.5 \nThe DNS server returns two different IPs for the kubia-headless.default.svc\n.cluster.local FQDN. Those are the IPs of the two pods that are reporting being\nready. You can confirm this by listing pods with kubectl get pods -o wide, which\nshows the pods\u2019 IPs. \n \n", "shape": "dot", "size": 10, "title": "155\nUsing a headless service for discovering individual pods\nthe pods matching its pod selector. I say \u201cpart of\u201d because your pods contain a readi-\nness probe, so only pods that are ready will be listed as endpoints of the service.\nBefore continuing, please make sure at least two pods report being ready, by creating\nthe /var/ready file, as in the previous example:\n$ kubectl exec \u003cpod name\u003e -- touch /var/ready\n5.6.2\nDiscovering pods through DNS\nWith your pods ready, you can now try performing a DNS lookup to see if you get the\nactual pod IPs or not. You\u2019ll need to perform the lookup from inside one of the pods.\nUnfortunately, your kubia container image doesn\u2019t include the nslookup (or the dig)\nbinary, so you can\u2019t use it to perform the DNS lookup.\n All you\u2019re trying to do is perform a DNS lookup from inside a pod running in the\ncluster. Why not run a new pod based on an image that contains the binaries you\nneed? To perform DNS-related actions, you can use the tutum/dnsutils container\nimage, which is available on Docker Hub and contains both the nslookup and the dig\nbinaries. To run the pod, you can go through the whole process of creating a YAML\nmanifest for it and passing it to kubectl create, but that\u2019s too much work, right?\nLuckily, there\u2019s a faster way.\nRUNNING A POD WITHOUT WRITING A YAML MANIFEST\nIn chapter 1, you already created pods without writing a YAML manifest by using the\nkubectl run command. But this time you want to create only a pod\u2014you don\u2019t need\nto create a ReplicationController to manage the pod. You can do that like this:\n$ kubectl run dnsutils --image=tutum/dnsutils --generator=run-pod/v1\n\u27a5 --command -- sleep infinity\npod \"dnsutils\" created\nThe trick is in the --generator=run-pod/v1 option, which tells kubectl to create the\npod directly, without any kind of ReplicationController or similar behind it. \nUNDERSTANDING DNS A RECORDS RETURNED FOR A HEADLESS SERVICE\nLet\u2019s use the newly created pod to perform a DNS lookup:\n$ kubectl exec dnsutils nslookup kubia-headless\n...\nName:    kubia-headless.default.svc.cluster.local\nAddress: 10.108.1.4 \nName:    kubia-headless.default.svc.cluster.local\nAddress: 10.108.2.5 \nThe DNS server returns two different IPs for the kubia-headless.default.svc\n.cluster.local FQDN. Those are the IPs of the two pods that are reporting being\nready. You can confirm this by listing pods with kubectl get pods -o wide, which\nshows the pods\u2019 IPs. \n \n"}, {"color": "green", "id": "text_99", "label": "156\nCHAPTER 5\nServices: enabling clients to discover and talk to pods\n This is different from what DNS returns for regular (non-headless) services, such\nas for your kubia service, where the returned IP is the service\u2019s cluster IP:\n$ kubectl exec dnsutils nslookup kubia\n...\nName:    kubia.default.svc.cluster.local\nAddress: 10.111.249.153\nAlthough headless services may seem different from regular services, they aren\u2019t that\ndifferent from the clients\u2019 perspective. Even with a headless service, clients can con-\nnect to its pods by connecting to the service\u2019s DNS name, as they can with regular ser-\nvices. But with headless services, because DNS returns the pods\u2019 IPs, clients connect\ndirectly to the pods, instead of through the service proxy. \nNOTE\nA headless services still provides load balancing across pods, but through\nthe DNS round-robin mechanism instead of through the service proxy.\n5.6.3\nDiscovering all pods\u2014even those that aren\u2019t ready\nYou\u2019ve seen that only pods that are ready become endpoints of services. But some-\ntimes you want to use the service discovery mechanism to find all pods matching the\nservice\u2019s label selector, even those that aren\u2019t ready. \n Luckily, you don\u2019t have to resort to querying the Kubernetes API server. You can\nuse the DNS lookup mechanism to find even those unready pods. To tell Kubernetes\nyou want all pods added to a service, regardless of the pod\u2019s readiness status, you must\nadd the following annotation to the service:\nkind: Service\nmetadata:\n  annotations:\n    service.alpha.kubernetes.io/tolerate-unready-endpoints: \"true\"\nWARNING\nAs the annotation name suggests, as I\u2019m writing this, this is an alpha\nfeature. The Kubernetes Service API already supports a new service spec field\ncalled publishNotReadyAddresses, which will replace the tolerate-unready-\nendpoints annotation. In Kubernetes version 1.9.0, the field is not honored yet\n(the annotation is what determines whether unready endpoints are included in\nthe DNS or not). Check the documentation to see whether that\u2019s changed.\n5.7\nTroubleshooting services\nServices are a crucial Kubernetes concept and the source of frustration for many\ndevelopers. I\u2019ve seen many developers lose heaps of time figuring out why they can\u2019t\nconnect to their pods through the service IP or FQDN. For this reason, a short look at\nhow to troubleshoot services is in order.\n When you\u2019re unable to access your pods through the service, you should start by\ngoing through the following list:\n \n", "shape": "dot", "size": 10, "title": "156\nCHAPTER 5\nServices: enabling clients to discover and talk to pods\n This is different from what DNS returns for regular (non-headless) services, such\nas for your kubia service, where the returned IP is the service\u2019s cluster IP:\n$ kubectl exec dnsutils nslookup kubia\n...\nName:    kubia.default.svc.cluster.local\nAddress: 10.111.249.153\nAlthough headless services may seem different from regular services, they aren\u2019t that\ndifferent from the clients\u2019 perspective. Even with a headless service, clients can con-\nnect to its pods by connecting to the service\u2019s DNS name, as they can with regular ser-\nvices. But with headless services, because DNS returns the pods\u2019 IPs, clients connect\ndirectly to the pods, instead of through the service proxy. \nNOTE\nA headless services still provides load balancing across pods, but through\nthe DNS round-robin mechanism instead of through the service proxy.\n5.6.3\nDiscovering all pods\u2014even those that aren\u2019t ready\nYou\u2019ve seen that only pods that are ready become endpoints of services. But some-\ntimes you want to use the service discovery mechanism to find all pods matching the\nservice\u2019s label selector, even those that aren\u2019t ready. \n Luckily, you don\u2019t have to resort to querying the Kubernetes API server. You can\nuse the DNS lookup mechanism to find even those unready pods. To tell Kubernetes\nyou want all pods added to a service, regardless of the pod\u2019s readiness status, you must\nadd the following annotation to the service:\nkind: Service\nmetadata:\n  annotations:\n    service.alpha.kubernetes.io/tolerate-unready-endpoints: \"true\"\nWARNING\nAs the annotation name suggests, as I\u2019m writing this, this is an alpha\nfeature. The Kubernetes Service API already supports a new service spec field\ncalled publishNotReadyAddresses, which will replace the tolerate-unready-\nendpoints annotation. In Kubernetes version 1.9.0, the field is not honored yet\n(the annotation is what determines whether unready endpoints are included in\nthe DNS or not). Check the documentation to see whether that\u2019s changed.\n5.7\nTroubleshooting services\nServices are a crucial Kubernetes concept and the source of frustration for many\ndevelopers. I\u2019ve seen many developers lose heaps of time figuring out why they can\u2019t\nconnect to their pods through the service IP or FQDN. For this reason, a short look at\nhow to troubleshoot services is in order.\n When you\u2019re unable to access your pods through the service, you should start by\ngoing through the following list:\n \n"}, {"color": "green", "id": "text_100", "label": "157\nSummary\n\uf0a1First, make sure you\u2019re connecting to the service\u2019s cluster IP from within the\ncluster, not from the outside.\n\uf0a1Don\u2019t bother pinging the service IP to figure out if the service is accessible\n(remember, the service\u2019s cluster IP is a virtual IP and pinging it will never work).\n\uf0a1If you\u2019ve defined a readiness probe, make sure it\u2019s succeeding; otherwise the\npod won\u2019t be part of the service.\n\uf0a1To confirm that a pod is part of the service, examine the corresponding End-\npoints object with kubectl get endpoints.\n\uf0a1If you\u2019re trying to access the service through its FQDN or a part of it (for exam-\nple, myservice.mynamespace.svc.cluster.local or myservice.mynamespace) and\nit doesn\u2019t work, see if you can access it using its cluster IP instead of the FQDN.\n\uf0a1Check whether you\u2019re connecting to the port exposed by the service and not\nthe target port.\n\uf0a1Try connecting to the pod IP directly to confirm your pod is accepting connec-\ntions on the correct port.\n\uf0a1If you can\u2019t even access your app through the pod\u2019s IP, make sure your app isn\u2019t\nonly binding to localhost.\nThis should help you resolve most of your service-related problems. You\u2019ll learn much\nmore about how services work in chapter 11. By understanding exactly how they\u2019re\nimplemented, it should be much easier for you to troubleshoot them.\n5.8\nSummary\nIn this chapter, you\u2019ve learned how to create Kubernetes Service resources to expose\nthe services available in your application, regardless of how many pod instances are\nproviding each service. You\u2019ve learned how Kubernetes\n\uf0a1Exposes multiple pods that match a certain label selector under a single, stable\nIP address and port\n\uf0a1Makes services accessible from inside the cluster by default, but allows you to\nmake the service accessible from outside the cluster by setting its type to either\nNodePort or LoadBalancer\n\uf0a1Enables pods to discover services together with their IP addresses and ports by\nlooking up environment variables\n\uf0a1Allows discovery of and communication with services residing outside the\ncluster by creating a Service resource without specifying a selector, by creating\nan associated Endpoints resource instead\n\uf0a1Provides a DNS CNAME alias for external services with the ExternalName ser-\nvice type\n\uf0a1Exposes multiple HTTP services through a single Ingress (consuming a sin-\ngle IP)\n \n", "shape": "dot", "size": 10, "title": "157\nSummary\n\uf0a1First, make sure you\u2019re connecting to the service\u2019s cluster IP from within the\ncluster, not from the outside.\n\uf0a1Don\u2019t bother pinging the service IP to figure out if the service is accessible\n(remember, the service\u2019s cluster IP is a virtual IP and pinging it will never work).\n\uf0a1If you\u2019ve defined a readiness probe, make sure it\u2019s succeeding; otherwise the\npod won\u2019t be part of the service.\n\uf0a1To confirm that a pod is part of the service, examine the corresponding End-\npoints object with kubectl get endpoints.\n\uf0a1If you\u2019re trying to access the service through its FQDN or a part of it (for exam-\nple, myservice.mynamespace.svc.cluster.local or myservice.mynamespace) and\nit doesn\u2019t work, see if you can access it using its cluster IP instead of the FQDN.\n\uf0a1Check whether you\u2019re connecting to the port exposed by the service and not\nthe target port.\n\uf0a1Try connecting to the pod IP directly to confirm your pod is accepting connec-\ntions on the correct port.\n\uf0a1If you can\u2019t even access your app through the pod\u2019s IP, make sure your app isn\u2019t\nonly binding to localhost.\nThis should help you resolve most of your service-related problems. You\u2019ll learn much\nmore about how services work in chapter 11. By understanding exactly how they\u2019re\nimplemented, it should be much easier for you to troubleshoot them.\n5.8\nSummary\nIn this chapter, you\u2019ve learned how to create Kubernetes Service resources to expose\nthe services available in your application, regardless of how many pod instances are\nproviding each service. You\u2019ve learned how Kubernetes\n\uf0a1Exposes multiple pods that match a certain label selector under a single, stable\nIP address and port\n\uf0a1Makes services accessible from inside the cluster by default, but allows you to\nmake the service accessible from outside the cluster by setting its type to either\nNodePort or LoadBalancer\n\uf0a1Enables pods to discover services together with their IP addresses and ports by\nlooking up environment variables\n\uf0a1Allows discovery of and communication with services residing outside the\ncluster by creating a Service resource without specifying a selector, by creating\nan associated Endpoints resource instead\n\uf0a1Provides a DNS CNAME alias for external services with the ExternalName ser-\nvice type\n\uf0a1Exposes multiple HTTP services through a single Ingress (consuming a sin-\ngle IP)\n \n"}, {"color": "green", "id": "text_101", "label": "158\nCHAPTER 5\nServices: enabling clients to discover and talk to pods\n\uf0a1Uses a pod container\u2019s readiness probe to determine whether a pod should or\nshouldn\u2019t be included as a service endpoint\n\uf0a1Enables discovery of pod IPs through DNS when you create a headless service\nAlong with getting a better understanding of services, you\u2019ve also learned how to\n\uf0a1Troubleshoot them\n\uf0a1Modify firewall rules in Google Kubernetes/Compute Engine\n\uf0a1Execute commands in pod containers through kubectl exec \n\uf0a1Run a bash shell in an existing pod\u2019s container\n\uf0a1Modify Kubernetes resources through the kubectl apply command\n\uf0a1Run an unmanaged ad hoc pod with kubectl run --generator=run-pod/v1\n \n", "shape": "dot", "size": 10, "title": "158\nCHAPTER 5\nServices: enabling clients to discover and talk to pods\n\uf0a1Uses a pod container\u2019s readiness probe to determine whether a pod should or\nshouldn\u2019t be included as a service endpoint\n\uf0a1Enables discovery of pod IPs through DNS when you create a headless service\nAlong with getting a better understanding of services, you\u2019ve also learned how to\n\uf0a1Troubleshoot them\n\uf0a1Modify firewall rules in Google Kubernetes/Compute Engine\n\uf0a1Execute commands in pod containers through kubectl exec \n\uf0a1Run a bash shell in an existing pod\u2019s container\n\uf0a1Modify Kubernetes resources through the kubectl apply command\n\uf0a1Run an unmanaged ad hoc pod with kubectl run --generator=run-pod/v1\n \n"}, {"color": "green", "id": "text_102", "label": "159\nVolumes: attaching\ndisk storage to containers\nIn the previous three chapters, we introduced pods and other Kubernetes resources\nthat interact with them, namely ReplicationControllers, ReplicaSets, DaemonSets,\nJobs, and Services. Now, we\u2019re going back inside the pod to learn how its containers\ncan access external disk storage and/or share storage between them.\n We\u2019ve said that pods are similar to logical hosts where processes running inside\nthem share resources such as CPU, RAM, network interfaces, and others. One\nwould expect the processes to also share disks, but that\u2019s not the case. You\u2019ll remem-\nber that each container in a pod has its own isolated filesystem, because the file-\nsystem comes from the container\u2019s image.\nThis chapter covers\n\uf0a1Creating multi-container pods\n\uf0a1Creating a volume to share disk storage between \ncontainers\n\uf0a1Using a Git repository inside a pod\n\uf0a1Attaching persistent storage such as a GCE \nPersistent Disk to pods\n\uf0a1Using pre-provisioned persistent storage\n\uf0a1Dynamic provisioning of persistent storage\n \n", "shape": "dot", "size": 10, "title": "159\nVolumes: attaching\ndisk storage to containers\nIn the previous three chapters, we introduced pods and other Kubernetes resources\nthat interact with them, namely ReplicationControllers, ReplicaSets, DaemonSets,\nJobs, and Services. Now, we\u2019re going back inside the pod to learn how its containers\ncan access external disk storage and/or share storage between them.\n We\u2019ve said that pods are similar to logical hosts where processes running inside\nthem share resources such as CPU, RAM, network interfaces, and others. One\nwould expect the processes to also share disks, but that\u2019s not the case. You\u2019ll remem-\nber that each container in a pod has its own isolated filesystem, because the file-\nsystem comes from the container\u2019s image.\nThis chapter covers\n\uf0a1Creating multi-container pods\n\uf0a1Creating a volume to share disk storage between \ncontainers\n\uf0a1Using a Git repository inside a pod\n\uf0a1Attaching persistent storage such as a GCE \nPersistent Disk to pods\n\uf0a1Using pre-provisioned persistent storage\n\uf0a1Dynamic provisioning of persistent storage\n \n"}, {"color": "green", "id": "text_103", "label": "160\nCHAPTER 6\nVolumes: attaching disk storage to containers\n Every new container starts off with the exact set of files that was added to the image\nat build time. Combine this with the fact that containers in a pod get restarted (either\nbecause the process died or because the liveness probe signaled to Kubernetes that\nthe container wasn\u2019t healthy anymore) and you\u2019ll realize that the new container will\nnot see anything that was written to the filesystem by the previous container, even\nthough the newly started container runs in the same pod.\n In certain scenarios you want the new container to continue where the last one fin-\nished, such as when restarting a process on a physical machine. You may not need (or\nwant) the whole filesystem to be persisted, but you do want to preserve the directories\nthat hold actual data.\n Kubernetes provides this by defining storage volumes. They aren\u2019t top-level resources\nlike pods, but are instead defined as a part of a pod and share the same lifecycle as the\npod. This means a volume is created when the pod is started and is destroyed when\nthe pod is deleted. Because of this, a volume\u2019s contents will persist across container\nrestarts. After a container is restarted, the new container can see all the files that were\nwritten to the volume by the previous container. Also, if a pod contains multiple con-\ntainers, the volume can be used by all of them at once. \n6.1\nIntroducing volumes\nKubernetes volumes are a component of a pod and are thus defined in the pod\u2019s spec-\nification\u2014much like containers. They aren\u2019t a standalone Kubernetes object and can-\nnot be created or deleted on their own. A volume is available to all containers in the\npod, but it must be mounted in each container that needs to access it. In each con-\ntainer, you can mount the volume in any location of its filesystem.\n6.1.1\nExplaining volumes in an example\nImagine you have a pod with three containers (shown in figure 6.1). One container\nruns a web server that serves HTML pages from the /var/htdocs directory and stores\nthe access log to /var/logs. The second container runs an agent that creates HTML\nfiles and stores them in /var/html. The third container processes the logs it finds in\nthe /var/logs directory (rotates them, compresses them, analyzes them, or whatever).\n Each container has a nicely defined single responsibility, but on its own each con-\ntainer wouldn\u2019t be of much use. Creating a pod with these three containers without\nthem sharing disk storage doesn\u2019t make any sense, because the content generator\nwould write the generated HTML files inside its own container and the web server\ncouldn\u2019t access those files, as it runs in a separate isolated container. Instead, it would\nserve an empty directory or whatever you put in the /var/htdocs directory in its con-\ntainer image. Similarly, the log rotator would never have anything to do, because its\n/var/logs directory would always remain empty with nothing writing logs there. A pod\nwith these three containers and no volumes basically does nothing.\n But if you add two volumes to the pod and mount them at appropriate paths inside\nthe three containers, as shown in figure 6.2, you\u2019ve created a system that\u2019s much more\n \n", "shape": "dot", "size": 10, "title": "160\nCHAPTER 6\nVolumes: attaching disk storage to containers\n Every new container starts off with the exact set of files that was added to the image\nat build time. Combine this with the fact that containers in a pod get restarted (either\nbecause the process died or because the liveness probe signaled to Kubernetes that\nthe container wasn\u2019t healthy anymore) and you\u2019ll realize that the new container will\nnot see anything that was written to the filesystem by the previous container, even\nthough the newly started container runs in the same pod.\n In certain scenarios you want the new container to continue where the last one fin-\nished, such as when restarting a process on a physical machine. You may not need (or\nwant) the whole filesystem to be persisted, but you do want to preserve the directories\nthat hold actual data.\n Kubernetes provides this by defining storage volumes. They aren\u2019t top-level resources\nlike pods, but are instead defined as a part of a pod and share the same lifecycle as the\npod. This means a volume is created when the pod is started and is destroyed when\nthe pod is deleted. Because of this, a volume\u2019s contents will persist across container\nrestarts. After a container is restarted, the new container can see all the files that were\nwritten to the volume by the previous container. Also, if a pod contains multiple con-\ntainers, the volume can be used by all of them at once. \n6.1\nIntroducing volumes\nKubernetes volumes are a component of a pod and are thus defined in the pod\u2019s spec-\nification\u2014much like containers. They aren\u2019t a standalone Kubernetes object and can-\nnot be created or deleted on their own. A volume is available to all containers in the\npod, but it must be mounted in each container that needs to access it. In each con-\ntainer, you can mount the volume in any location of its filesystem.\n6.1.1\nExplaining volumes in an example\nImagine you have a pod with three containers (shown in figure 6.1). One container\nruns a web server that serves HTML pages from the /var/htdocs directory and stores\nthe access log to /var/logs. The second container runs an agent that creates HTML\nfiles and stores them in /var/html. The third container processes the logs it finds in\nthe /var/logs directory (rotates them, compresses them, analyzes them, or whatever).\n Each container has a nicely defined single responsibility, but on its own each con-\ntainer wouldn\u2019t be of much use. Creating a pod with these three containers without\nthem sharing disk storage doesn\u2019t make any sense, because the content generator\nwould write the generated HTML files inside its own container and the web server\ncouldn\u2019t access those files, as it runs in a separate isolated container. Instead, it would\nserve an empty directory or whatever you put in the /var/htdocs directory in its con-\ntainer image. Similarly, the log rotator would never have anything to do, because its\n/var/logs directory would always remain empty with nothing writing logs there. A pod\nwith these three containers and no volumes basically does nothing.\n But if you add two volumes to the pod and mount them at appropriate paths inside\nthe three containers, as shown in figure 6.2, you\u2019ve created a system that\u2019s much more\n \n"}, {"color": "green", "id": "text_104", "label": "161\nIntroducing volumes\nPod\nContainer: WebServer\nFilesystem\nWebserver\nprocess\nWrites\nReads\n/\nvar/\nhtdocs/\nlogs/\nContainer: ContentAgent\nFilesystem\nContentAgent\nprocess\nWrites\n/\nvar/\nhtml/\nContainer: LogRotator\nFilesystem\nLogRotator\nprocess\nReads\n/\nvar/\nlogs/\nFigure 6.1\nThree containers of the \nsame pod without shared storage\nPod\nContainer: WebServer\nFilesystem\n/\nvar/\nhtdocs/\nlogs/\nContainer: ContentAgent\nFilesystem\n/\nvar/\nhtml/\nContainer: LogRotator\nFilesystem\n/\nvar/\nlogs/\nVolume:\npublicHtml\nVolume:\nlogVol\nFigure 6.2\nThree containers sharing two \nvolumes mounted at various mount paths\n \n", "shape": "dot", "size": 10, "title": "161\nIntroducing volumes\nPod\nContainer: WebServer\nFilesystem\nWebserver\nprocess\nWrites\nReads\n/\nvar/\nhtdocs/\nlogs/\nContainer: ContentAgent\nFilesystem\nContentAgent\nprocess\nWrites\n/\nvar/\nhtml/\nContainer: LogRotator\nFilesystem\nLogRotator\nprocess\nReads\n/\nvar/\nlogs/\nFigure 6.1\nThree containers of the \nsame pod without shared storage\nPod\nContainer: WebServer\nFilesystem\n/\nvar/\nhtdocs/\nlogs/\nContainer: ContentAgent\nFilesystem\n/\nvar/\nhtml/\nContainer: LogRotator\nFilesystem\n/\nvar/\nlogs/\nVolume:\npublicHtml\nVolume:\nlogVol\nFigure 6.2\nThree containers sharing two \nvolumes mounted at various mount paths\n \n"}, {"color": "green", "id": "text_105", "label": "162\nCHAPTER 6\nVolumes: attaching disk storage to containers\nthan the sum of its parts. Linux allows you to mount a filesystem at arbitrary locations\nin the file tree. When you do that, the contents of the mounted filesystem are accessi-\nble in the directory it\u2019s mounted into. By mounting the same volume into two contain-\ners, they can operate on the same files. In your case, you\u2019re mounting two volumes in\nthree containers. By doing this, your three containers can work together and do some-\nthing useful. Let me explain how.\n First, the pod has a volume called publicHtml. This volume is mounted in the Web-\nServer container at /var/htdocs, because that\u2019s the directory the web server serves\nfiles from. The same volume is also mounted in the ContentAgent container, but at\n/var/html, because that\u2019s where the agent writes the files to. By mounting this single vol-\nume like that, the web server will now serve the content generated by the content agent.\n Similarly, the pod also has a volume called logVol for storing logs. This volume is\nmounted at /var/logs in both the WebServer and the LogRotator containers. Note\nthat it isn\u2019t mounted in the ContentAgent container. The container cannot access its\nfiles, even though the container and the volume are part of the same pod. It\u2019s not\nenough to define a volume in the pod; you need to define a VolumeMount inside the\ncontainer\u2019s spec also, if you want the container to be able to access it.\n The two volumes in this example can both initially be empty, so you can use a type\nof volume called emptyDir. Kubernetes also supports other types of volumes that are\neither populated during initialization of the volume from an external source, or an\nexisting directory is mounted inside the volume. This process of populating or mount-\ning a volume is performed before the pod\u2019s containers are started. \n A volume is bound to the lifecycle of a pod and will stay in existence only while the\npod exists, but depending on the volume type, the volume\u2019s files may remain intact\neven after the pod and volume disappear, and can later be mounted into a new vol-\nume. Let\u2019s see what types of volumes exist.\n6.1.2\nIntroducing available volume types\nA wide variety of volume types is available. Several are generic, while others are spe-\ncific to the actual storage technologies used underneath. Don\u2019t worry if you\u2019ve never\nheard of those technologies\u2014I hadn\u2019t heard of at least half of them. You\u2019ll probably\nonly use volume types for the technologies you already know and use. Here\u2019s a list of\nseveral of the available volume types:\n\uf0a1\nemptyDir\u2014A simple empty directory used for storing transient data.\n\uf0a1\nhostPath\u2014Used for mounting directories from the worker node\u2019s filesystem\ninto the pod.\n\uf0a1\ngitRepo\u2014A volume initialized by checking out the contents of a Git repository.\n\uf0a1\nnfs\u2014An NFS share mounted into the pod.\n\uf0a1\ngcePersistentDisk (Google Compute Engine Persistent Disk), awsElastic-\nBlockStore (Amazon Web Services Elastic Block Store Volume), azureDisk\n(Microsoft Azure Disk Volume)\u2014Used for mounting cloud provider-specific\nstorage.\n \n", "shape": "dot", "size": 10, "title": "162\nCHAPTER 6\nVolumes: attaching disk storage to containers\nthan the sum of its parts. Linux allows you to mount a filesystem at arbitrary locations\nin the file tree. When you do that, the contents of the mounted filesystem are accessi-\nble in the directory it\u2019s mounted into. By mounting the same volume into two contain-\ners, they can operate on the same files. In your case, you\u2019re mounting two volumes in\nthree containers. By doing this, your three containers can work together and do some-\nthing useful. Let me explain how.\n First, the pod has a volume called publicHtml. This volume is mounted in the Web-\nServer container at /var/htdocs, because that\u2019s the directory the web server serves\nfiles from. The same volume is also mounted in the ContentAgent container, but at\n/var/html, because that\u2019s where the agent writes the files to. By mounting this single vol-\nume like that, the web server will now serve the content generated by the content agent.\n Similarly, the pod also has a volume called logVol for storing logs. This volume is\nmounted at /var/logs in both the WebServer and the LogRotator containers. Note\nthat it isn\u2019t mounted in the ContentAgent container. The container cannot access its\nfiles, even though the container and the volume are part of the same pod. It\u2019s not\nenough to define a volume in the pod; you need to define a VolumeMount inside the\ncontainer\u2019s spec also, if you want the container to be able to access it.\n The two volumes in this example can both initially be empty, so you can use a type\nof volume called emptyDir. Kubernetes also supports other types of volumes that are\neither populated during initialization of the volume from an external source, or an\nexisting directory is mounted inside the volume. This process of populating or mount-\ning a volume is performed before the pod\u2019s containers are started. \n A volume is bound to the lifecycle of a pod and will stay in existence only while the\npod exists, but depending on the volume type, the volume\u2019s files may remain intact\neven after the pod and volume disappear, and can later be mounted into a new vol-\nume. Let\u2019s see what types of volumes exist.\n6.1.2\nIntroducing available volume types\nA wide variety of volume types is available. Several are generic, while others are spe-\ncific to the actual storage technologies used underneath. Don\u2019t worry if you\u2019ve never\nheard of those technologies\u2014I hadn\u2019t heard of at least half of them. You\u2019ll probably\nonly use volume types for the technologies you already know and use. Here\u2019s a list of\nseveral of the available volume types:\n\uf0a1\nemptyDir\u2014A simple empty directory used for storing transient data.\n\uf0a1\nhostPath\u2014Used for mounting directories from the worker node\u2019s filesystem\ninto the pod.\n\uf0a1\ngitRepo\u2014A volume initialized by checking out the contents of a Git repository.\n\uf0a1\nnfs\u2014An NFS share mounted into the pod.\n\uf0a1\ngcePersistentDisk (Google Compute Engine Persistent Disk), awsElastic-\nBlockStore (Amazon Web Services Elastic Block Store Volume), azureDisk\n(Microsoft Azure Disk Volume)\u2014Used for mounting cloud provider-specific\nstorage.\n \n"}, {"color": "green", "id": "text_106", "label": "163\nUsing volumes to share data between containers\n\uf0a1\ncinder, cephfs, iscsi, flocker, glusterfs, quobyte, rbd, flexVolume, vsphere-\nVolume, photonPersistentDisk, scaleIO\u2014Used for mounting other types of\nnetwork storage.\n\uf0a1\nconfigMap, secret, downwardAPI\u2014Special types of volumes used to expose cer-\ntain Kubernetes resources and cluster information to the pod.\n\uf0a1\npersistentVolumeClaim\u2014A way to use a pre- or dynamically provisioned per-\nsistent storage. (We\u2019ll talk about them in the last section of this chapter.)\nThese volume types serve various purposes. You\u2019ll learn about some of them in the\nfollowing sections. Special types of volumes (secret, downwardAPI, configMap) are\ncovered in the next two chapters, because they aren\u2019t used for storing data, but for\nexposing Kubernetes metadata to apps running in the pod. \n A single pod can use multiple volumes of different types at the same time, and, as\nwe\u2019ve mentioned before, each of the pod\u2019s containers can either have the volume\nmounted or not.\n6.2\nUsing volumes to share data between containers\nAlthough a volume can prove useful even when used by a single container, let\u2019s first\nfocus on how it\u2019s used for sharing data between multiple containers in a pod.\n6.2.1\nUsing an emptyDir volume\nThe simplest volume type is the emptyDir volume, so let\u2019s look at it in the first exam-\nple of how to define a volume in a pod. As the name suggests, the volume starts out as\nan empty directory. The app running inside the pod can then write any files it needs\nto it. Because the volume\u2019s lifetime is tied to that of the pod, the volume\u2019s contents are\nlost when the pod is deleted.\n An emptyDir volume is especially useful for sharing files between containers\nrunning in the same pod. But it can also be used by a single container for when a con-\ntainer needs to write data to disk temporarily, such as when performing a sort\noperation on a large dataset, which can\u2019t fit into the available memory. The data could\nalso be written to the container\u2019s filesystem itself (remember the top read-write layer\nin a container?), but subtle differences exist between the two options. A container\u2019s\nfilesystem may not even be writable (we\u2019ll talk about this toward the end of the book),\nso writing to a mounted volume might be the only option. \nUSING AN EMPTYDIR VOLUME IN A POD\nLet\u2019s revisit the previous example where a web server, a content agent, and a log rota-\ntor share two volumes, but let\u2019s simplify a bit. You\u2019ll build a pod with only the web\nserver container and the content agent and a single volume for the HTML. \n You\u2019ll use Nginx as the web server and the UNIX fortune command to generate\nthe HTML content. The fortune command prints out a random quote every time you\nrun it. You\u2019ll create a script that invokes the fortune command every 10 seconds and\nstores its output in index.html. You\u2019ll find an existing Nginx image available on\n \n", "shape": "dot", "size": 10, "title": "163\nUsing volumes to share data between containers\n\uf0a1\ncinder, cephfs, iscsi, flocker, glusterfs, quobyte, rbd, flexVolume, vsphere-\nVolume, photonPersistentDisk, scaleIO\u2014Used for mounting other types of\nnetwork storage.\n\uf0a1\nconfigMap, secret, downwardAPI\u2014Special types of volumes used to expose cer-\ntain Kubernetes resources and cluster information to the pod.\n\uf0a1\npersistentVolumeClaim\u2014A way to use a pre- or dynamically provisioned per-\nsistent storage. (We\u2019ll talk about them in the last section of this chapter.)\nThese volume types serve various purposes. You\u2019ll learn about some of them in the\nfollowing sections. Special types of volumes (secret, downwardAPI, configMap) are\ncovered in the next two chapters, because they aren\u2019t used for storing data, but for\nexposing Kubernetes metadata to apps running in the pod. \n A single pod can use multiple volumes of different types at the same time, and, as\nwe\u2019ve mentioned before, each of the pod\u2019s containers can either have the volume\nmounted or not.\n6.2\nUsing volumes to share data between containers\nAlthough a volume can prove useful even when used by a single container, let\u2019s first\nfocus on how it\u2019s used for sharing data between multiple containers in a pod.\n6.2.1\nUsing an emptyDir volume\nThe simplest volume type is the emptyDir volume, so let\u2019s look at it in the first exam-\nple of how to define a volume in a pod. As the name suggests, the volume starts out as\nan empty directory. The app running inside the pod can then write any files it needs\nto it. Because the volume\u2019s lifetime is tied to that of the pod, the volume\u2019s contents are\nlost when the pod is deleted.\n An emptyDir volume is especially useful for sharing files between containers\nrunning in the same pod. But it can also be used by a single container for when a con-\ntainer needs to write data to disk temporarily, such as when performing a sort\noperation on a large dataset, which can\u2019t fit into the available memory. The data could\nalso be written to the container\u2019s filesystem itself (remember the top read-write layer\nin a container?), but subtle differences exist between the two options. A container\u2019s\nfilesystem may not even be writable (we\u2019ll talk about this toward the end of the book),\nso writing to a mounted volume might be the only option. \nUSING AN EMPTYDIR VOLUME IN A POD\nLet\u2019s revisit the previous example where a web server, a content agent, and a log rota-\ntor share two volumes, but let\u2019s simplify a bit. You\u2019ll build a pod with only the web\nserver container and the content agent and a single volume for the HTML. \n You\u2019ll use Nginx as the web server and the UNIX fortune command to generate\nthe HTML content. The fortune command prints out a random quote every time you\nrun it. You\u2019ll create a script that invokes the fortune command every 10 seconds and\nstores its output in index.html. You\u2019ll find an existing Nginx image available on\n \n"}, {"color": "green", "id": "text_107", "label": "164\nCHAPTER 6\nVolumes: attaching disk storage to containers\nDocker Hub, but you\u2019ll need to either create the fortune image yourself or use the\none I\u2019ve already built and pushed to Docker Hub under luksa/fortune. If you want a\nrefresher on how to build Docker images, refer to the sidebar.\nCREATING THE POD\nNow that you have the two images required to run your pod, it\u2019s time to create the pod\nmanifest. Create a file called fortune-pod.yaml with the contents shown in the follow-\ning listing.\napiVersion: v1\nkind: Pod\nmetadata:\n  name: fortune\nspec:\n  containers:\nBuilding the fortune container image\nHere\u2019s how to build the image. Create a new directory called fortune and then inside\nit, create a fortuneloop.sh shell script with the following contents:\n#!/bin/bash\ntrap \"exit\" SIGINT\nmkdir /var/htdocs\nwhile :\ndo\n  echo $(date) Writing fortune to /var/htdocs/index.html\n  /usr/games/fortune \u003e /var/htdocs/index.html\n  sleep 10\ndone\nThen, in the same directory, create a file called Dockerfile containing the following:\nFROM ubuntu:latest\nRUN apt-get update ; apt-get -y install fortune\nADD fortuneloop.sh /bin/fortuneloop.sh\nENTRYPOINT /bin/fortuneloop.sh\nThe image is based on the ubuntu:latest image, which doesn\u2019t include the fortune\nbinary by default. That\u2019s why in the second line of the Dockerfile you install it with\napt-get. After that, you add the fortuneloop.sh script to the image\u2019s /bin folder.\nIn the last line of the Dockerfile, you specify that the fortuneloop.sh script should\nbe executed when the image is run.\nAfter preparing both files, build and upload the image to Docker Hub with the following\ntwo commands (replace luksa with your own Docker Hub user ID):\n$ docker build -t luksa/fortune .\n$ docker push luksa/fortune\nListing 6.1\nA pod with two containers sharing the same volume: fortune-pod.yaml\n \n", "shape": "dot", "size": 10, "title": "164\nCHAPTER 6\nVolumes: attaching disk storage to containers\nDocker Hub, but you\u2019ll need to either create the fortune image yourself or use the\none I\u2019ve already built and pushed to Docker Hub under luksa/fortune. If you want a\nrefresher on how to build Docker images, refer to the sidebar.\nCREATING THE POD\nNow that you have the two images required to run your pod, it\u2019s time to create the pod\nmanifest. Create a file called fortune-pod.yaml with the contents shown in the follow-\ning listing.\napiVersion: v1\nkind: Pod\nmetadata:\n  name: fortune\nspec:\n  containers:\nBuilding the fortune container image\nHere\u2019s how to build the image. Create a new directory called fortune and then inside\nit, create a fortuneloop.sh shell script with the following contents:\n#!/bin/bash\ntrap \"exit\" SIGINT\nmkdir /var/htdocs\nwhile :\ndo\n  echo $(date) Writing fortune to /var/htdocs/index.html\n  /usr/games/fortune \u003e /var/htdocs/index.html\n  sleep 10\ndone\nThen, in the same directory, create a file called Dockerfile containing the following:\nFROM ubuntu:latest\nRUN apt-get update ; apt-get -y install fortune\nADD fortuneloop.sh /bin/fortuneloop.sh\nENTRYPOINT /bin/fortuneloop.sh\nThe image is based on the ubuntu:latest image, which doesn\u2019t include the fortune\nbinary by default. That\u2019s why in the second line of the Dockerfile you install it with\napt-get. After that, you add the fortuneloop.sh script to the image\u2019s /bin folder.\nIn the last line of the Dockerfile, you specify that the fortuneloop.sh script should\nbe executed when the image is run.\nAfter preparing both files, build and upload the image to Docker Hub with the following\ntwo commands (replace luksa with your own Docker Hub user ID):\n$ docker build -t luksa/fortune .\n$ docker push luksa/fortune\nListing 6.1\nA pod with two containers sharing the same volume: fortune-pod.yaml\n \n"}, {"color": "green", "id": "text_108", "label": "165\nUsing volumes to share data between containers\n  - image: luksa/fortune                   \n    name: html-generator                   \n    volumeMounts:                          \n    - name: html                           \n      mountPath: /var/htdocs               \n  - image: nginx:alpine                   \n    name: web-server                      \n    volumeMounts:                         \n    - name: html                          \n      mountPath: /usr/share/nginx/html    \n      readOnly: true                      \n    ports:\n    - containerPort: 80\n      protocol: TCP\n  volumes:                 \n  - name: html             \n    emptyDir: {}           \nThe pod contains two containers and a single volume that\u2019s mounted in both of\nthem, yet at different paths. When the html-generator container starts, it starts writ-\ning the output of the fortune command to the /var/htdocs/index.html file every 10\nseconds. Because the volume is mounted at /var/htdocs, the index.html file is writ-\nten to the volume instead of the container\u2019s top layer. As soon as the web-server con-\ntainer starts, it starts serving whatever HTML files are in the /usr/share/nginx/html\ndirectory (this is the default directory Nginx serves files from). Because you mounted\nthe volume in that exact location, Nginx will serve the index.html file written there\nby the container running the fortune loop. The end effect is that a client sending an\nHTTP request to the pod on port 80 will receive the current fortune message as\nthe response. \nSEEING THE POD IN ACTION\nTo see the fortune message, you need to enable access to the pod. You\u2019ll do that by\nforwarding a port from your local machine to the pod:\n$ kubectl port-forward fortune 8080:80\nForwarding from 127.0.0.1:8080 -\u003e 80\nForwarding from [::1]:8080 -\u003e 80\nNOTE\nAs an exercise, you can also expose the pod through a service instead\nof using port forwarding.\nNow you can access the Nginx server through port 8080 of your local machine. Use\ncurl to do that:\n$ curl http://localhost:8080\nBeware of a tall blond man with one black shoe.\nIf you wait a few seconds and send another request, you should receive a different\nmessage. By combining two containers, you created a simple app to see how a volume\ncan glue together two containers and enhance what each of them does.\nThe first container is called html-generator \nand runs the luksa/fortune image.\nThe volume called html is mounted \nat /var/htdocs in the container.\nThe second container is called web-server \nand runs the nginx:alpine image.\nThe same volume as above is \nmounted at /usr/share/nginx/html \nas read-only.\nA single emptyDir volume \ncalled html that\u2019s mounted \nin the two containers above\n \n", "shape": "dot", "size": 10, "title": "165\nUsing volumes to share data between containers\n  - image: luksa/fortune                   \n    name: html-generator                   \n    volumeMounts:                          \n    - name: html                           \n      mountPath: /var/htdocs               \n  - image: nginx:alpine                   \n    name: web-server                      \n    volumeMounts:                         \n    - name: html                          \n      mountPath: /usr/share/nginx/html    \n      readOnly: true                      \n    ports:\n    - containerPort: 80\n      protocol: TCP\n  volumes:                 \n  - name: html             \n    emptyDir: {}           \nThe pod contains two containers and a single volume that\u2019s mounted in both of\nthem, yet at different paths. When the html-generator container starts, it starts writ-\ning the output of the fortune command to the /var/htdocs/index.html file every 10\nseconds. Because the volume is mounted at /var/htdocs, the index.html file is writ-\nten to the volume instead of the container\u2019s top layer. As soon as the web-server con-\ntainer starts, it starts serving whatever HTML files are in the /usr/share/nginx/html\ndirectory (this is the default directory Nginx serves files from). Because you mounted\nthe volume in that exact location, Nginx will serve the index.html file written there\nby the container running the fortune loop. The end effect is that a client sending an\nHTTP request to the pod on port 80 will receive the current fortune message as\nthe response. \nSEEING THE POD IN ACTION\nTo see the fortune message, you need to enable access to the pod. You\u2019ll do that by\nforwarding a port from your local machine to the pod:\n$ kubectl port-forward fortune 8080:80\nForwarding from 127.0.0.1:8080 -\u003e 80\nForwarding from [::1]:8080 -\u003e 80\nNOTE\nAs an exercise, you can also expose the pod through a service instead\nof using port forwarding.\nNow you can access the Nginx server through port 8080 of your local machine. Use\ncurl to do that:\n$ curl http://localhost:8080\nBeware of a tall blond man with one black shoe.\nIf you wait a few seconds and send another request, you should receive a different\nmessage. By combining two containers, you created a simple app to see how a volume\ncan glue together two containers and enhance what each of them does.\nThe first container is called html-generator \nand runs the luksa/fortune image.\nThe volume called html is mounted \nat /var/htdocs in the container.\nThe second container is called web-server \nand runs the nginx:alpine image.\nThe same volume as above is \nmounted at /usr/share/nginx/html \nas read-only.\nA single emptyDir volume \ncalled html that\u2019s mounted \nin the two containers above\n \n"}, {"color": "green", "id": "text_109", "label": "166\nCHAPTER 6\nVolumes: attaching disk storage to containers\nSPECIFYING THE MEDIUM TO USE FOR THE EMPTYDIR\nThe emptyDir you used as the volume was created on the actual disk of the worker\nnode hosting your pod, so its performance depends on the type of the node\u2019s disks.\nBut you can tell Kubernetes to create the emptyDir on a tmpfs filesystem (in memory\ninstead of on disk). To do this, set the emptyDir\u2019s medium to Memory like this:\nvolumes:\n  - name: html\n    emptyDir:\n      medium: Memory    \nAn emptyDir volume is the simplest type of volume, but other types build upon it.\nAfter the empty directory is created, they populate it with data. One such volume type\nis the gitRepo volume type, which we\u2019ll introduce next.\n6.2.2\nUsing a Git repository as the starting point for a volume \nA gitRepo volume is basically an emptyDir volume that gets populated by cloning a\nGit repository and checking out a specific revision when the pod is starting up (but\nbefore its containers are created). Figure 6.3 shows how this unfolds.\nNOTE\nAfter the gitRepo volume is created, it isn\u2019t kept in sync with the repo\nit\u2019s referencing. The files in the volume will not be updated when you push\nadditional commits to the Git repository. However, if your pod is managed by\na ReplicationController, deleting the pod will result in a new pod being cre-\nated and this new pod\u2019s volume will then contain the latest commits. \nFor example, you can use a Git repository to store static HTML files of your website\nand create a pod containing a web server container and a gitRepo volume. Every time\nthe pod is created, it pulls the latest version of your website and starts serving it. The\nThis emptyDir\u2019s \nfiles should be \nstored in memory.\nPod\nContainer\nUser\ngitRepo\nvolume\n1. User (or a replication\ncontroller) creates pod\nwith gitRepo volume\n2. Kubernetes creates\nan empty directory and\nclones the speci\ufb01ed Git\nrepository into it\n3. The pod\u2019s container is started\n(with the volume mounted at\nthe mount path)\nRepository\nFigure 6.3\nA gitRepo volume is an emptyDir volume initially populated with the contents of a \nGit repository.\n \n", "shape": "dot", "size": 10, "title": "166\nCHAPTER 6\nVolumes: attaching disk storage to containers\nSPECIFYING THE MEDIUM TO USE FOR THE EMPTYDIR\nThe emptyDir you used as the volume was created on the actual disk of the worker\nnode hosting your pod, so its performance depends on the type of the node\u2019s disks.\nBut you can tell Kubernetes to create the emptyDir on a tmpfs filesystem (in memory\ninstead of on disk). To do this, set the emptyDir\u2019s medium to Memory like this:\nvolumes:\n  - name: html\n    emptyDir:\n      medium: Memory    \nAn emptyDir volume is the simplest type of volume, but other types build upon it.\nAfter the empty directory is created, they populate it with data. One such volume type\nis the gitRepo volume type, which we\u2019ll introduce next.\n6.2.2\nUsing a Git repository as the starting point for a volume \nA gitRepo volume is basically an emptyDir volume that gets populated by cloning a\nGit repository and checking out a specific revision when the pod is starting up (but\nbefore its containers are created). Figure 6.3 shows how this unfolds.\nNOTE\nAfter the gitRepo volume is created, it isn\u2019t kept in sync with the repo\nit\u2019s referencing. The files in the volume will not be updated when you push\nadditional commits to the Git repository. However, if your pod is managed by\na ReplicationController, deleting the pod will result in a new pod being cre-\nated and this new pod\u2019s volume will then contain the latest commits. \nFor example, you can use a Git repository to store static HTML files of your website\nand create a pod containing a web server container and a gitRepo volume. Every time\nthe pod is created, it pulls the latest version of your website and starts serving it. The\nThis emptyDir\u2019s \nfiles should be \nstored in memory.\nPod\nContainer\nUser\ngitRepo\nvolume\n1. User (or a replication\ncontroller) creates pod\nwith gitRepo volume\n2. Kubernetes creates\nan empty directory and\nclones the speci\ufb01ed Git\nrepository into it\n3. The pod\u2019s container is started\n(with the volume mounted at\nthe mount path)\nRepository\nFigure 6.3\nA gitRepo volume is an emptyDir volume initially populated with the contents of a \nGit repository.\n \n"}, {"color": "green", "id": "text_110", "label": "167\nUsing volumes to share data between containers\nonly drawback to this is that you need to delete the pod every time you push changes\nto the gitRepo and want to start serving the new version of the website. \n Let\u2019s do this right now. It\u2019s not that different from what you did before. \nRUNNING A WEB SERVER POD SERVING FILES FROM A CLONED GIT REPOSITORY\nBefore you create your pod, you\u2019ll need an actual Git repository with HTML files in it.\nI\u2019ve created a repo on GitHub at https:/\n/github.com/luksa/kubia-website-example.git.\nYou\u2019ll need to fork it (create your own copy of the repo on GitHub) so you can push\nchanges to it later. \n Once you\u2019ve created your fork, you can move on to creating the pod. This time,\nyou\u2019ll only need a single Nginx container and a single gitRepo volume in the pod (be\nsure to point the gitRepo volume to your own fork of my repository), as shown in the\nfollowing listing.\napiVersion: v1\nkind: Pod\nmetadata:\n  name: gitrepo-volume-pod\nspec:\n  containers:\n  - image: nginx:alpine\n    name: web-server\n    volumeMounts:\n    - name: html\n      mountPath: /usr/share/nginx/html\n      readOnly: true\n    ports:\n    - containerPort: 80\n      protocol: TCP\n  volumes:\n  - name: html\n    gitRepo:                     \n      repository: https://github.com/luksa/kubia-website-example.git   \n      revision: master                     \n      directory: .      \nWhen you create the pod, the volume is first initialized as an empty directory and then\nthe specified Git repository is cloned into it. If you hadn\u2019t set the directory to . (dot),\nthe repository would have been cloned into the kubia-website-example subdirectory,\nwhich isn\u2019t what you want. You want the repo to be cloned into the root directory of\nyour volume. Along with the repository, you also specified you want Kubernetes to\ncheck out whatever revision the master branch is pointing to at the time the volume\nis created. \n With the pod running, you can try hitting it through port forwarding, a service, or by\nexecuting the curl command from within the pod (or any other pod inside the cluster). \nListing 6.2\nA pod using a gitRepo volume: gitrepo-volume-pod.yaml\nYou\u2019re creating a \ngitRepo volume.\nThe volume will clone\nthis Git repository.\nThe master branch \nwill be checked out.\nYou want the repo to \nbe cloned into the root \ndir of the volume.\n \n", "shape": "dot", "size": 10, "title": "167\nUsing volumes to share data between containers\nonly drawback to this is that you need to delete the pod every time you push changes\nto the gitRepo and want to start serving the new version of the website. \n Let\u2019s do this right now. It\u2019s not that different from what you did before. \nRUNNING A WEB SERVER POD SERVING FILES FROM A CLONED GIT REPOSITORY\nBefore you create your pod, you\u2019ll need an actual Git repository with HTML files in it.\nI\u2019ve created a repo on GitHub at https:/\n/github.com/luksa/kubia-website-example.git.\nYou\u2019ll need to fork it (create your own copy of the repo on GitHub) so you can push\nchanges to it later. \n Once you\u2019ve created your fork, you can move on to creating the pod. This time,\nyou\u2019ll only need a single Nginx container and a single gitRepo volume in the pod (be\nsure to point the gitRepo volume to your own fork of my repository), as shown in the\nfollowing listing.\napiVersion: v1\nkind: Pod\nmetadata:\n  name: gitrepo-volume-pod\nspec:\n  containers:\n  - image: nginx:alpine\n    name: web-server\n    volumeMounts:\n    - name: html\n      mountPath: /usr/share/nginx/html\n      readOnly: true\n    ports:\n    - containerPort: 80\n      protocol: TCP\n  volumes:\n  - name: html\n    gitRepo:                     \n      repository: https://github.com/luksa/kubia-website-example.git   \n      revision: master                     \n      directory: .      \nWhen you create the pod, the volume is first initialized as an empty directory and then\nthe specified Git repository is cloned into it. If you hadn\u2019t set the directory to . (dot),\nthe repository would have been cloned into the kubia-website-example subdirectory,\nwhich isn\u2019t what you want. You want the repo to be cloned into the root directory of\nyour volume. Along with the repository, you also specified you want Kubernetes to\ncheck out whatever revision the master branch is pointing to at the time the volume\nis created. \n With the pod running, you can try hitting it through port forwarding, a service, or by\nexecuting the curl command from within the pod (or any other pod inside the cluster). \nListing 6.2\nA pod using a gitRepo volume: gitrepo-volume-pod.yaml\nYou\u2019re creating a \ngitRepo volume.\nThe volume will clone\nthis Git repository.\nThe master branch \nwill be checked out.\nYou want the repo to \nbe cloned into the root \ndir of the volume.\n \n"}, {"color": "green", "id": "text_111", "label": "168\nCHAPTER 6\nVolumes: attaching disk storage to containers\nCONFIRMING THE FILES AREN\u2019T KEPT IN SYNC WITH THE GIT REPO\nNow you\u2019ll make changes to the index.html file in your GitHub repository. If you\ndon\u2019t use Git locally, you can edit the file on GitHub directly\u2014click on the file in your\nGitHub repository to open it and then click on the pencil icon to start editing it.\nChange the text and then commit the changes by clicking the button at the bottom.\n The master branch of the Git repository now includes the changes you made to the\nHTML file. These changes will not be visible on your Nginx web server yet, because\nthe gitRepo volume isn\u2019t kept in sync with the Git repository. You can confirm this by\nhitting the pod again. \n To see the new version of the website, you need to delete the pod and create\nit again. Instead of having to delete the pod every time you make changes, you could\nrun an additional process, which keeps your volume in sync with the Git repository.\nI won\u2019t explain in detail how to do this. Instead, try doing this yourself as an exer-\ncise, but here are a few pointers.\nINTRODUCING SIDECAR CONTAINERS\nThe Git sync process shouldn\u2019t run in the same container as the Nginx web server, but\nin a second container: a sidecar container. A sidecar container is a container that aug-\nments the operation of the main container of the pod. You add a sidecar to a pod so\nyou can use an existing container image instead of cramming additional logic into the\nmain app\u2019s code, which would make it overly complex and less reusable. \n To find an existing container image, which keeps a local directory synchronized\nwith a Git repository, go to Docker Hub and search for \u201cgit sync.\u201d You\u2019ll find many\nimages that do that. Then use the image in a new container in the pod from the previ-\nous example, mount the pod\u2019s existing gitRepo volume in the new container, and\nconfigure the Git sync container to keep the files in sync with your Git repo. If you set\neverything up correctly, you should see that the files the web server is serving are kept\nin sync with your GitHub repo. \nNOTE\nAn example in chapter 18 includes using a Git sync container like the\none explained here, so you can wait until you reach chapter 18 and follow the\nstep-by-step instructions then instead of doing this exercise on your own now. \nUSING A GITREPO VOLUME WITH PRIVATE GIT REPOSITORIES\nThere\u2019s one other reason for having to resort to Git sync sidecar containers. We\nhaven\u2019t talked about whether you can use a gitRepo volume with a private Git repo. It\nturns out you can\u2019t. The current consensus among Kubernetes developers is to keep\nthe gitRepo volume simple and not add any support for cloning private repositories\nthrough the SSH protocol, because that would require adding additional config\noptions to the gitRepo volume. \n If you want to clone a private Git repo into your container, you should use a git-\nsync sidecar or a similar method instead of a gitRepo volume.\n \n", "shape": "dot", "size": 10, "title": "168\nCHAPTER 6\nVolumes: attaching disk storage to containers\nCONFIRMING THE FILES AREN\u2019T KEPT IN SYNC WITH THE GIT REPO\nNow you\u2019ll make changes to the index.html file in your GitHub repository. If you\ndon\u2019t use Git locally, you can edit the file on GitHub directly\u2014click on the file in your\nGitHub repository to open it and then click on the pencil icon to start editing it.\nChange the text and then commit the changes by clicking the button at the bottom.\n The master branch of the Git repository now includes the changes you made to the\nHTML file. These changes will not be visible on your Nginx web server yet, because\nthe gitRepo volume isn\u2019t kept in sync with the Git repository. You can confirm this by\nhitting the pod again. \n To see the new version of the website, you need to delete the pod and create\nit again. Instead of having to delete the pod every time you make changes, you could\nrun an additional process, which keeps your volume in sync with the Git repository.\nI won\u2019t explain in detail how to do this. Instead, try doing this yourself as an exer-\ncise, but here are a few pointers.\nINTRODUCING SIDECAR CONTAINERS\nThe Git sync process shouldn\u2019t run in the same container as the Nginx web server, but\nin a second container: a sidecar container. A sidecar container is a container that aug-\nments the operation of the main container of the pod. You add a sidecar to a pod so\nyou can use an existing container image instead of cramming additional logic into the\nmain app\u2019s code, which would make it overly complex and less reusable. \n To find an existing container image, which keeps a local directory synchronized\nwith a Git repository, go to Docker Hub and search for \u201cgit sync.\u201d You\u2019ll find many\nimages that do that. Then use the image in a new container in the pod from the previ-\nous example, mount the pod\u2019s existing gitRepo volume in the new container, and\nconfigure the Git sync container to keep the files in sync with your Git repo. If you set\neverything up correctly, you should see that the files the web server is serving are kept\nin sync with your GitHub repo. \nNOTE\nAn example in chapter 18 includes using a Git sync container like the\none explained here, so you can wait until you reach chapter 18 and follow the\nstep-by-step instructions then instead of doing this exercise on your own now. \nUSING A GITREPO VOLUME WITH PRIVATE GIT REPOSITORIES\nThere\u2019s one other reason for having to resort to Git sync sidecar containers. We\nhaven\u2019t talked about whether you can use a gitRepo volume with a private Git repo. It\nturns out you can\u2019t. The current consensus among Kubernetes developers is to keep\nthe gitRepo volume simple and not add any support for cloning private repositories\nthrough the SSH protocol, because that would require adding additional config\noptions to the gitRepo volume. \n If you want to clone a private Git repo into your container, you should use a git-\nsync sidecar or a similar method instead of a gitRepo volume.\n \n"}, {"color": "green", "id": "text_112", "label": "169\nAccessing files on the worker node\u2019s filesystem\nWRAPPING UP THE GITREPO VOLUME\nA gitRepo volume, like the emptyDir volume, is basically a dedicated directory cre-\nated specifically for, and used exclusively by, the pod that contains the volume. When\nthe pod is deleted, the volume and its contents are deleted. Other types of volumes,\nhowever, don\u2019t create a new directory, but instead mount an existing external direc-\ntory into the pod\u2019s container\u2019s filesystem. The contents of that volume can survive\nmultiple pod instantiations. We\u2019ll learn about those types of volumes next.\n6.3\nAccessing files on the worker node\u2019s filesystem\nMost  pods should be oblivious of their host node, so they shouldn\u2019t access any files on\nthe node\u2019s filesystem. But certain system-level pods (remember, these will usually be\nmanaged by a DaemonSet) do need to either read the node\u2019s files or use the node\u2019s\nfilesystem to access the node\u2019s devices through the filesystem. Kubernetes makes this\npossible through a hostPath volume. \n6.3.1\nIntroducing the hostPath volume\nA hostPath volume points to a specific file or directory on the node\u2019s filesystem (see\nfigure 6.4). Pods running on the same node and using the same path in their host-\nPath volume see the same files.\nhostPath volumes are the first type of persistent storage we\u2019re introducing, because\nboth the gitRepo and emptyDir volumes\u2019 contents get deleted when a pod is torn\ndown, whereas a hostPath volume\u2019s contents don\u2019t. If a pod is deleted and the next\npod uses a hostPath volume pointing to the same path on the host, the new pod will\nsee whatever was left behind by the previous pod, but only if it\u2019s scheduled to the same\nnode as the first pod.\nNode 1\nPod\nhostPath\nvolume\nPod\nhostPath\nvolume\nNode 2\nPod\nhostPath\nvolume\n/some/path/on/host\n/some/path/on/host\nFigure 6.4\nA hostPath volume mounts a file or directory on the worker node into \nthe container\u2019s filesystem.\n \n", "shape": "dot", "size": 10, "title": "169\nAccessing files on the worker node\u2019s filesystem\nWRAPPING UP THE GITREPO VOLUME\nA gitRepo volume, like the emptyDir volume, is basically a dedicated directory cre-\nated specifically for, and used exclusively by, the pod that contains the volume. When\nthe pod is deleted, the volume and its contents are deleted. Other types of volumes,\nhowever, don\u2019t create a new directory, but instead mount an existing external direc-\ntory into the pod\u2019s container\u2019s filesystem. The contents of that volume can survive\nmultiple pod instantiations. We\u2019ll learn about those types of volumes next.\n6.3\nAccessing files on the worker node\u2019s filesystem\nMost  pods should be oblivious of their host node, so they shouldn\u2019t access any files on\nthe node\u2019s filesystem. But certain system-level pods (remember, these will usually be\nmanaged by a DaemonSet) do need to either read the node\u2019s files or use the node\u2019s\nfilesystem to access the node\u2019s devices through the filesystem. Kubernetes makes this\npossible through a hostPath volume. \n6.3.1\nIntroducing the hostPath volume\nA hostPath volume points to a specific file or directory on the node\u2019s filesystem (see\nfigure 6.4). Pods running on the same node and using the same path in their host-\nPath volume see the same files.\nhostPath volumes are the first type of persistent storage we\u2019re introducing, because\nboth the gitRepo and emptyDir volumes\u2019 contents get deleted when a pod is torn\ndown, whereas a hostPath volume\u2019s contents don\u2019t. If a pod is deleted and the next\npod uses a hostPath volume pointing to the same path on the host, the new pod will\nsee whatever was left behind by the previous pod, but only if it\u2019s scheduled to the same\nnode as the first pod.\nNode 1\nPod\nhostPath\nvolume\nPod\nhostPath\nvolume\nNode 2\nPod\nhostPath\nvolume\n/some/path/on/host\n/some/path/on/host\nFigure 6.4\nA hostPath volume mounts a file or directory on the worker node into \nthe container\u2019s filesystem.\n \n"}, {"color": "green", "id": "text_113", "label": "170\nCHAPTER 6\nVolumes: attaching disk storage to containers\n If you\u2019re thinking of using a hostPath volume as the place to store a database\u2019s\ndata directory, think again. Because the volume\u2019s contents are stored on a specific\nnode\u2019s filesystem, when the database pod gets rescheduled to another node, it will no\nlonger see the data. This explains why it\u2019s not a good idea to use a hostPath volume\nfor regular pods, because it makes the pod sensitive to what node it\u2019s scheduled to.\n6.3.2\nExamining system pods that use hostPath volumes\nLet\u2019s see how a hostPath volume can be used properly. Instead of creating a new pod,\nlet\u2019s see if any existing system-wide pods are already using this type of volume. As you\nmay remember from one of the previous chapters, several such pods are running in\nthe kube-system namespace. Let\u2019s list them again:\n$ kubectl get pod s --namespace kube-system\nNAME                          READY     STATUS    RESTARTS   AGE\nfluentd-kubia-4ebc2f1e-9a3e   1/1       Running   1          4d\nfluentd-kubia-4ebc2f1e-e2vz   1/1       Running   1          31d\n...\nPick the first one and see what kinds of volumes it uses (shown in the following listing).\n$ kubectl describe po fluentd-kubia-4ebc2f1e-9a3e --namespace kube-system\nName:           fluentd-cloud-logging-gke-kubia-default-pool-4ebc2f1e-9a3e\nNamespace:      kube-system\n...\nVolumes:\n  varlog:\n    Type:       HostPath (bare host directory volume)\n    Path:       /var/log\n  varlibdockercontainers:\n    Type:       HostPath (bare host directory volume)\n    Path:       /var/lib/docker/containers\nTIP\nIf you\u2019re using Minikube, try the kube-addon-manager-minikube pod.\nAha! The pod uses two hostPath volumes to gain access to the node\u2019s /var/log and\nthe /var/lib/docker/containers directories. You\u2019d think you were lucky to find a pod\nusing a hostPath volume on the first try, but not really (at least not on GKE). Check\nthe other pods, and you\u2019ll see most use this type of volume either to access the node\u2019s\nlog files, kubeconfig (the Kubernetes config file), or the CA certificates.\n If you inspect the other pods, you\u2019ll see none of them uses the hostPath volume\nfor storing their own data. They all use it to get access to the node\u2019s data. But as we\u2019ll\nsee later in the chapter, hostPath volumes are often used for trying out persistent stor-\nage in single-node clusters, such as the one created by Minikube. Read on to learn\nabout the types of volumes you should use for storing persistent data properly even in\na multi-node cluster.\nListing 6.3\n A pod using hostPath volumes to access the node\u2019s logs\n \n", "shape": "dot", "size": 10, "title": "170\nCHAPTER 6\nVolumes: attaching disk storage to containers\n If you\u2019re thinking of using a hostPath volume as the place to store a database\u2019s\ndata directory, think again. Because the volume\u2019s contents are stored on a specific\nnode\u2019s filesystem, when the database pod gets rescheduled to another node, it will no\nlonger see the data. This explains why it\u2019s not a good idea to use a hostPath volume\nfor regular pods, because it makes the pod sensitive to what node it\u2019s scheduled to.\n6.3.2\nExamining system pods that use hostPath volumes\nLet\u2019s see how a hostPath volume can be used properly. Instead of creating a new pod,\nlet\u2019s see if any existing system-wide pods are already using this type of volume. As you\nmay remember from one of the previous chapters, several such pods are running in\nthe kube-system namespace. Let\u2019s list them again:\n$ kubectl get pod s --namespace kube-system\nNAME                          READY     STATUS    RESTARTS   AGE\nfluentd-kubia-4ebc2f1e-9a3e   1/1       Running   1          4d\nfluentd-kubia-4ebc2f1e-e2vz   1/1       Running   1          31d\n...\nPick the first one and see what kinds of volumes it uses (shown in the following listing).\n$ kubectl describe po fluentd-kubia-4ebc2f1e-9a3e --namespace kube-system\nName:           fluentd-cloud-logging-gke-kubia-default-pool-4ebc2f1e-9a3e\nNamespace:      kube-system\n...\nVolumes:\n  varlog:\n    Type:       HostPath (bare host directory volume)\n    Path:       /var/log\n  varlibdockercontainers:\n    Type:       HostPath (bare host directory volume)\n    Path:       /var/lib/docker/containers\nTIP\nIf you\u2019re using Minikube, try the kube-addon-manager-minikube pod.\nAha! The pod uses two hostPath volumes to gain access to the node\u2019s /var/log and\nthe /var/lib/docker/containers directories. You\u2019d think you were lucky to find a pod\nusing a hostPath volume on the first try, but not really (at least not on GKE). Check\nthe other pods, and you\u2019ll see most use this type of volume either to access the node\u2019s\nlog files, kubeconfig (the Kubernetes config file), or the CA certificates.\n If you inspect the other pods, you\u2019ll see none of them uses the hostPath volume\nfor storing their own data. They all use it to get access to the node\u2019s data. But as we\u2019ll\nsee later in the chapter, hostPath volumes are often used for trying out persistent stor-\nage in single-node clusters, such as the one created by Minikube. Read on to learn\nabout the types of volumes you should use for storing persistent data properly even in\na multi-node cluster.\nListing 6.3\n A pod using hostPath volumes to access the node\u2019s logs\n \n"}, {"color": "green", "id": "text_114", "label": "171\nUsing persistent storage\nTIP\nRemember to use hostPath volumes only if you need to read or write sys-\ntem files on the node. Never use them to persist data across pods. \n6.4\nUsing persistent storage\nWhen an application running in a pod needs to persist data to disk and have that\nsame data available even when the pod is rescheduled to another node, you can\u2019t use\nany of the volume types we\u2019ve mentioned so far. Because this data needs to be accessi-\nble from any cluster node, it must be stored on some type of network-attached stor-\nage (NAS).\n To learn about volumes that allow persisting data, you\u2019ll create a pod that will run\nthe MongoDB document-oriented NoSQL database. Running a database pod without\na volume or with a non-persistent volume doesn\u2019t make sense, except for testing\npurposes, so you\u2019ll add an appropriate type of volume to the pod and mount it in the\nMongoDB container. \n6.4.1\nUsing a GCE Persistent Disk in a pod volume\nIf you\u2019ve been running these examples on Google Kubernetes Engine, which runs\nyour cluster nodes on Google Compute Engine (GCE), you\u2019ll use a GCE Persistent\nDisk as your underlying storage mechanism. \n In the early versions, Kubernetes didn\u2019t provision the underlying storage automati-\ncally\u2014you had to do that manually. Automatic provisioning is now possible, and you\u2019ll\nlearn about it later in the chapter, but first, you\u2019ll start by provisioning the storage\nmanually. It will give you a chance to learn exactly what\u2019s going on underneath. \nCREATING A GCE PERSISTENT DISK\nYou\u2019ll start by creating the GCE persistent disk first. You need to create it in the same\nzone as your Kubernetes cluster. If you don\u2019t remember what zone you created the\ncluster in, you can see it by listing your Kubernetes clusters with the gcloud command\nlike this:\n$ gcloud container clusters list\nNAME   ZONE            MASTER_VERSION  MASTER_IP       ...\nkubia  europe-west1-b  1.2.5           104.155.84.137  ...\nThis shows you\u2019ve created your cluster in zone europe-west1-b, so you need to create\nthe GCE persistent disk in the same zone as well. You create the disk like this:\n$ gcloud compute disks create --size=1GiB --zone=europe-west1-b mongodb\nWARNING: You have selected a disk size of under [200GB]. This may result in \npoor I/O performance. For more information, see: \nhttps://developers.google.com/compute/docs/disks#pdperformance.\nCreated [https://www.googleapis.com/compute/v1/projects/rapid-pivot-\n136513/zones/europe-west1-b/disks/mongodb].\nNAME     ZONE            SIZE_GB  TYPE         STATUS\nmongodb  europe-west1-b  1        pd-standard  READY\n \n", "shape": "dot", "size": 10, "title": "171\nUsing persistent storage\nTIP\nRemember to use hostPath volumes only if you need to read or write sys-\ntem files on the node. Never use them to persist data across pods. \n6.4\nUsing persistent storage\nWhen an application running in a pod needs to persist data to disk and have that\nsame data available even when the pod is rescheduled to another node, you can\u2019t use\nany of the volume types we\u2019ve mentioned so far. Because this data needs to be accessi-\nble from any cluster node, it must be stored on some type of network-attached stor-\nage (NAS).\n To learn about volumes that allow persisting data, you\u2019ll create a pod that will run\nthe MongoDB document-oriented NoSQL database. Running a database pod without\na volume or with a non-persistent volume doesn\u2019t make sense, except for testing\npurposes, so you\u2019ll add an appropriate type of volume to the pod and mount it in the\nMongoDB container. \n6.4.1\nUsing a GCE Persistent Disk in a pod volume\nIf you\u2019ve been running these examples on Google Kubernetes Engine, which runs\nyour cluster nodes on Google Compute Engine (GCE), you\u2019ll use a GCE Persistent\nDisk as your underlying storage mechanism. \n In the early versions, Kubernetes didn\u2019t provision the underlying storage automati-\ncally\u2014you had to do that manually. Automatic provisioning is now possible, and you\u2019ll\nlearn about it later in the chapter, but first, you\u2019ll start by provisioning the storage\nmanually. It will give you a chance to learn exactly what\u2019s going on underneath. \nCREATING A GCE PERSISTENT DISK\nYou\u2019ll start by creating the GCE persistent disk first. You need to create it in the same\nzone as your Kubernetes cluster. If you don\u2019t remember what zone you created the\ncluster in, you can see it by listing your Kubernetes clusters with the gcloud command\nlike this:\n$ gcloud container clusters list\nNAME   ZONE            MASTER_VERSION  MASTER_IP       ...\nkubia  europe-west1-b  1.2.5           104.155.84.137  ...\nThis shows you\u2019ve created your cluster in zone europe-west1-b, so you need to create\nthe GCE persistent disk in the same zone as well. You create the disk like this:\n$ gcloud compute disks create --size=1GiB --zone=europe-west1-b mongodb\nWARNING: You have selected a disk size of under [200GB]. This may result in \npoor I/O performance. For more information, see: \nhttps://developers.google.com/compute/docs/disks#pdperformance.\nCreated [https://www.googleapis.com/compute/v1/projects/rapid-pivot-\n136513/zones/europe-west1-b/disks/mongodb].\nNAME     ZONE            SIZE_GB  TYPE         STATUS\nmongodb  europe-west1-b  1        pd-standard  READY\n \n"}, {"color": "green", "id": "text_115", "label": "172\nCHAPTER 6\nVolumes: attaching disk storage to containers\nThis command creates a 1 GiB large GCE persistent disk called mongodb. You can\nignore the warning about the disk size, because you don\u2019t care about the disk\u2019s perfor-\nmance for the tests you\u2019re about to run.\nCREATING A POD USING A GCEPERSISTENTDISK VOLUME\nNow that you have your physical storage properly set up, you can use it in a volume\ninside your MongoDB pod. You\u2019re going to prepare the YAML for the pod, which is\nshown in the following listing.\napiVersion: v1\nkind: Pod\nmetadata:\n  name: mongodb \nspec:\n  volumes:\n  - name: mongodb-data          \n    gcePersistentDisk:           \n      pdName: mongodb            \n      fsType: ext4             \n  containers:\n  - image: mongo\n    name: mongodb\n    volumeMounts:                \n    - name: mongodb-data         \n      mountPath: /data/db      \n    ports:\n    - containerPort: 27017\n      protocol: TCP\nNOTE\nIf you\u2019re using Minikube, you can\u2019t use a GCE Persistent Disk, but you\ncan deploy mongodb-pod-hostpath.yaml, which uses a hostPath volume\ninstead of a GCE PD.\nThe pod contains a single container and a single volume backed by the GCE Per-\nsistent Disk you\u2019ve created (as shown in figure 6.5). You\u2019re mounting the volume\ninside the container at /data/db, because that\u2019s where MongoDB stores its data.\nListing 6.4\nA pod using a gcePersistentDisk volume: mongodb-pod-gcepd.yaml\nThe name\nof the\nvolume\n(also\nreferenced\nwhen\nmounting\nthe volume)\nThe type of the volume \nis a GCE Persistent Disk.\nThe name of the persistent \ndisk must match the actual \nPD you created earlier.\nThe filesystem type is EXT4 \n(a type of Linux filesystem).\nThe path where MongoDB \nstores its data\nPod: mongodb\nContainer: mongodb\nvolumeMounts:\nname: mongodb-data\nmountPath: /data/db\ngcePersistentDisk:\npdName: mongodb\nGCE\nPersistent Disk:\nmongodb\nVolume:\nmongodb\nFigure 6.5\nA pod with a single container running MongoDB, which mounts a volume referencing an \nexternal GCE Persistent Disk\n \n", "shape": "dot", "size": 10, "title": "172\nCHAPTER 6\nVolumes: attaching disk storage to containers\nThis command creates a 1 GiB large GCE persistent disk called mongodb. You can\nignore the warning about the disk size, because you don\u2019t care about the disk\u2019s perfor-\nmance for the tests you\u2019re about to run.\nCREATING A POD USING A GCEPERSISTENTDISK VOLUME\nNow that you have your physical storage properly set up, you can use it in a volume\ninside your MongoDB pod. You\u2019re going to prepare the YAML for the pod, which is\nshown in the following listing.\napiVersion: v1\nkind: Pod\nmetadata:\n  name: mongodb \nspec:\n  volumes:\n  - name: mongodb-data          \n    gcePersistentDisk:           \n      pdName: mongodb            \n      fsType: ext4             \n  containers:\n  - image: mongo\n    name: mongodb\n    volumeMounts:                \n    - name: mongodb-data         \n      mountPath: /data/db      \n    ports:\n    - containerPort: 27017\n      protocol: TCP\nNOTE\nIf you\u2019re using Minikube, you can\u2019t use a GCE Persistent Disk, but you\ncan deploy mongodb-pod-hostpath.yaml, which uses a hostPath volume\ninstead of a GCE PD.\nThe pod contains a single container and a single volume backed by the GCE Per-\nsistent Disk you\u2019ve created (as shown in figure 6.5). You\u2019re mounting the volume\ninside the container at /data/db, because that\u2019s where MongoDB stores its data.\nListing 6.4\nA pod using a gcePersistentDisk volume: mongodb-pod-gcepd.yaml\nThe name\nof the\nvolume\n(also\nreferenced\nwhen\nmounting\nthe volume)\nThe type of the volume \nis a GCE Persistent Disk.\nThe name of the persistent \ndisk must match the actual \nPD you created earlier.\nThe filesystem type is EXT4 \n(a type of Linux filesystem).\nThe path where MongoDB \nstores its data\nPod: mongodb\nContainer: mongodb\nvolumeMounts:\nname: mongodb-data\nmountPath: /data/db\ngcePersistentDisk:\npdName: mongodb\nGCE\nPersistent Disk:\nmongodb\nVolume:\nmongodb\nFigure 6.5\nA pod with a single container running MongoDB, which mounts a volume referencing an \nexternal GCE Persistent Disk\n \n"}, {"color": "green", "id": "text_116", "label": "173\nUsing persistent storage\nWRITING DATA TO THE PERSISTENT STORAGE BY ADDING DOCUMENTS TO YOUR MONGODB DATABASE\nNow that you\u2019ve created the pod and the container has been started, you can run the\nMongoDB shell inside the container and use it to write some data to the data store.\n You\u2019ll run the shell as shown in the following listing.\n$ kubectl exec -it mongodb mongo\nMongoDB shell version: 3.2.8\nconnecting to: mongodb://127.0.0.1:27017\nWelcome to the MongoDB shell.\nFor interactive help, type \"help\".\nFor more comprehensive documentation, see\n    http://docs.mongodb.org/\nQuestions? Try the support group\n    http://groups.google.com/group/mongodb-user\n...\n\u003e \nMongoDB allows storing JSON documents, so you\u2019ll store one to see if it\u2019s stored per-\nsistently and can be retrieved after the pod is re-created. Insert a new JSON document\nwith the following commands: \n\u003e use mystore\nswitched to db mystore\n\u003e db.foo.insert({name:\u0027foo\u0027})\nWriteResult({ \"nInserted\" : 1 })\nYou\u2019ve inserted a simple JSON document with a single property (name: \u2019foo\u2019). Now,\nuse the find() command to see the document you inserted:\n\u003e db.foo.find()\n{ \"_id\" : ObjectId(\"57a61eb9de0cfd512374cc75\"), \"name\" : \"foo\" }\nThere it is. The document should be stored in your GCE persistent disk now. \nRE-CREATING THE POD AND VERIFYING THAT IT CAN READ THE DATA PERSISTED BY THE PREVIOUS POD\nYou can now exit the mongodb shell (type exit and press Enter), and then delete the\npod and recreate it:\n$ kubectl delete pod mongodb\npod \"mongodb\" deleted\n$ kubectl create -f mongodb-pod-gcepd.yaml\npod \"mongodb\" created\nThe new pod uses the exact same GCE persistent disk as the previous pod, so the\nMongoDB container running inside it should see the exact same data, even if the pod\nis scheduled to a different node.\nTIP\nYou can see what node a pod is scheduled to by running kubectl get po\n-o wide.\nListing 6.5\nEntering the MongoDB shell inside the mongodb pod\n \n", "shape": "dot", "size": 10, "title": "173\nUsing persistent storage\nWRITING DATA TO THE PERSISTENT STORAGE BY ADDING DOCUMENTS TO YOUR MONGODB DATABASE\nNow that you\u2019ve created the pod and the container has been started, you can run the\nMongoDB shell inside the container and use it to write some data to the data store.\n You\u2019ll run the shell as shown in the following listing.\n$ kubectl exec -it mongodb mongo\nMongoDB shell version: 3.2.8\nconnecting to: mongodb://127.0.0.1:27017\nWelcome to the MongoDB shell.\nFor interactive help, type \"help\".\nFor more comprehensive documentation, see\n    http://docs.mongodb.org/\nQuestions? Try the support group\n    http://groups.google.com/group/mongodb-user\n...\n\u003e \nMongoDB allows storing JSON documents, so you\u2019ll store one to see if it\u2019s stored per-\nsistently and can be retrieved after the pod is re-created. Insert a new JSON document\nwith the following commands: \n\u003e use mystore\nswitched to db mystore\n\u003e db.foo.insert({name:\u0027foo\u0027})\nWriteResult({ \"nInserted\" : 1 })\nYou\u2019ve inserted a simple JSON document with a single property (name: \u2019foo\u2019). Now,\nuse the find() command to see the document you inserted:\n\u003e db.foo.find()\n{ \"_id\" : ObjectId(\"57a61eb9de0cfd512374cc75\"), \"name\" : \"foo\" }\nThere it is. The document should be stored in your GCE persistent disk now. \nRE-CREATING THE POD AND VERIFYING THAT IT CAN READ THE DATA PERSISTED BY THE PREVIOUS POD\nYou can now exit the mongodb shell (type exit and press Enter), and then delete the\npod and recreate it:\n$ kubectl delete pod mongodb\npod \"mongodb\" deleted\n$ kubectl create -f mongodb-pod-gcepd.yaml\npod \"mongodb\" created\nThe new pod uses the exact same GCE persistent disk as the previous pod, so the\nMongoDB container running inside it should see the exact same data, even if the pod\nis scheduled to a different node.\nTIP\nYou can see what node a pod is scheduled to by running kubectl get po\n-o wide.\nListing 6.5\nEntering the MongoDB shell inside the mongodb pod\n \n"}, {"color": "green", "id": "text_117", "label": "174\nCHAPTER 6\nVolumes: attaching disk storage to containers\nOnce the container is up, you can again run the MongoDB shell and check to see if the\ndocument you stored earlier can still be retrieved, as shown in the following listing.\n$ kubectl exec -it mongodb mongo\nMongoDB shell version: 3.2.8\nconnecting to: mongodb://127.0.0.1:27017\nWelcome to the MongoDB shell.\n...\n\u003e use mystore\nswitched to db mystore\n\u003e db.foo.find()\n{ \"_id\" : ObjectId(\"57a61eb9de0cfd512374cc75\"), \"name\" : \"foo\" }\nAs expected, the data is still there, even though you deleted the pod and re-created it.\nThis confirms you can use a GCE persistent disk to persist data across multiple pod\ninstances. \n You\u2019re done playing with the MongoDB pod, so go ahead and delete it again, but\nhold off on deleting the underlying GCE persistent disk. You\u2019ll use it again later in\nthe chapter.\n6.4.2\nUsing other types of volumes with underlying persistent storage\nThe reason you created the GCE Persistent Disk volume is because your Kubernetes\ncluster runs on Google Kubernetes Engine. When you run your cluster elsewhere, you\nshould use other types of volumes, depending on the underlying infrastructure.\n If your Kubernetes cluster is running on Amazon\u2019s AWS EC2, for example, you can\nuse an awsElasticBlockStore volume to provide persistent storage for your pods. If\nyour cluster runs on Microsoft Azure, you can use the azureFile or the azureDisk\nvolume. We won\u2019t go into detail on how to do that here, but it\u2019s virtually the same as in\nthe previous example. First, you need to create the actual underlying storage, and\nthen set the appropriate properties in the volume definition.\nUSING AN AWS ELASTIC BLOCK STORE VOLUME\nFor example, to use an AWS elastic block store instead of the GCE Persistent Disk,\nyou\u2019d only need to change the volume definition as shown in the following listing (see\nthose lines printed in bold).\napiVersion: v1\nkind: Pod\nmetadata:\n  name: mongodb \nspec:\n  volumes:                       \n  - name: mongodb-data           \n    awsElasticBlockStore:          \nListing 6.6\nRetrieving MongoDB\u2019s persisted data in a new pod\nListing 6.7\nA pod using an awsElasticBlockStore volume: mongodb-pod-aws.yaml\nUsing awsElasticBlockStore \ninstead of gcePersistentDisk\n \n", "shape": "dot", "size": 10, "title": "174\nCHAPTER 6\nVolumes: attaching disk storage to containers\nOnce the container is up, you can again run the MongoDB shell and check to see if the\ndocument you stored earlier can still be retrieved, as shown in the following listing.\n$ kubectl exec -it mongodb mongo\nMongoDB shell version: 3.2.8\nconnecting to: mongodb://127.0.0.1:27017\nWelcome to the MongoDB shell.\n...\n\u003e use mystore\nswitched to db mystore\n\u003e db.foo.find()\n{ \"_id\" : ObjectId(\"57a61eb9de0cfd512374cc75\"), \"name\" : \"foo\" }\nAs expected, the data is still there, even though you deleted the pod and re-created it.\nThis confirms you can use a GCE persistent disk to persist data across multiple pod\ninstances. \n You\u2019re done playing with the MongoDB pod, so go ahead and delete it again, but\nhold off on deleting the underlying GCE persistent disk. You\u2019ll use it again later in\nthe chapter.\n6.4.2\nUsing other types of volumes with underlying persistent storage\nThe reason you created the GCE Persistent Disk volume is because your Kubernetes\ncluster runs on Google Kubernetes Engine. When you run your cluster elsewhere, you\nshould use other types of volumes, depending on the underlying infrastructure.\n If your Kubernetes cluster is running on Amazon\u2019s AWS EC2, for example, you can\nuse an awsElasticBlockStore volume to provide persistent storage for your pods. If\nyour cluster runs on Microsoft Azure, you can use the azureFile or the azureDisk\nvolume. We won\u2019t go into detail on how to do that here, but it\u2019s virtually the same as in\nthe previous example. First, you need to create the actual underlying storage, and\nthen set the appropriate properties in the volume definition.\nUSING AN AWS ELASTIC BLOCK STORE VOLUME\nFor example, to use an AWS elastic block store instead of the GCE Persistent Disk,\nyou\u2019d only need to change the volume definition as shown in the following listing (see\nthose lines printed in bold).\napiVersion: v1\nkind: Pod\nmetadata:\n  name: mongodb \nspec:\n  volumes:                       \n  - name: mongodb-data           \n    awsElasticBlockStore:          \nListing 6.6\nRetrieving MongoDB\u2019s persisted data in a new pod\nListing 6.7\nA pod using an awsElasticBlockStore volume: mongodb-pod-aws.yaml\nUsing awsElasticBlockStore \ninstead of gcePersistentDisk\n \n"}, {"color": "green", "id": "text_118", "label": "175\nUsing persistent storage\n      volumeId: my-volume          \n      fsType: ext4       \n  containers:\n  - ...\nUSING AN NFS VOLUME\nIf your cluster is running on your own set of servers, you have a vast array of other sup-\nported options for mounting external storage inside your volume. For example, to\nmount a simple NFS share, you only need to specify the NFS server and the path\nexported by the server, as shown in the following listing.\n  volumes:                       \n  - name: mongodb-data           \n    nfs:                     \n      server: 1.2.3.4         \n      path: /some/path     \nUSING OTHER STORAGE TECHNOLOGIES\nOther supported options include iscsi for mounting an ISCSI disk resource, glusterfs\nfor a GlusterFS mount, rbd for a RADOS Block Device, flexVolume, cinder, cephfs,\nflocker, fc (Fibre Channel), and others. You don\u2019t need to know all of them if you\u2019re\nnot using them. They\u2019re mentioned here to show you that Kubernetes supports a\nbroad range of storage technologies and you can use whichever you prefer and are\nused to.\n To see details on what properties you need to set for each of these volume types,\nyou can either turn to the Kubernetes API definitions in the Kubernetes API refer-\nence or look up the information through kubectl explain, as shown in chapter 3. If\nyou\u2019re already familiar with a particular storage technology, using the explain com-\nmand should allow you to easily figure out how to mount a volume of the proper type\nand use it in your pods.\n But does a developer need to know all this stuff? Should a developer, when creat-\ning a pod, have to deal with infrastructure-related storage details, or should that be\nleft to the cluster administrator? \n Having a pod\u2019s volumes refer to the actual underlying infrastructure isn\u2019t what\nKubernetes is about, is it? For example, for a developer to have to specify the host-\nname of the NFS server feels wrong. And that\u2019s not even the worst thing about it. \n Including this type of infrastructure-related information into a pod definition\nmeans the pod definition is pretty much tied to a specific Kubernetes cluster. You\ncan\u2019t use the same pod definition in another one. That\u2019s why using volumes like this\nisn\u2019t the best way to attach persistent storage to your pods. You\u2019ll learn how to improve\non this in the next section.\nListing 6.8\nA pod using an nfs volume: mongodb-pod-nfs.yaml\nSpecify the ID of the EBS \nvolume you created.\nThe filesystem type \nis EXT4 as before.\nThis volume is backed \nby an NFS share.\nThe IP of the \nNFS server\nThe path exported \nby the server\n \n", "shape": "dot", "size": 10, "title": "175\nUsing persistent storage\n      volumeId: my-volume          \n      fsType: ext4       \n  containers:\n  - ...\nUSING AN NFS VOLUME\nIf your cluster is running on your own set of servers, you have a vast array of other sup-\nported options for mounting external storage inside your volume. For example, to\nmount a simple NFS share, you only need to specify the NFS server and the path\nexported by the server, as shown in the following listing.\n  volumes:                       \n  - name: mongodb-data           \n    nfs:                     \n      server: 1.2.3.4         \n      path: /some/path     \nUSING OTHER STORAGE TECHNOLOGIES\nOther supported options include iscsi for mounting an ISCSI disk resource, glusterfs\nfor a GlusterFS mount, rbd for a RADOS Block Device, flexVolume, cinder, cephfs,\nflocker, fc (Fibre Channel), and others. You don\u2019t need to know all of them if you\u2019re\nnot using them. They\u2019re mentioned here to show you that Kubernetes supports a\nbroad range of storage technologies and you can use whichever you prefer and are\nused to.\n To see details on what properties you need to set for each of these volume types,\nyou can either turn to the Kubernetes API definitions in the Kubernetes API refer-\nence or look up the information through kubectl explain, as shown in chapter 3. If\nyou\u2019re already familiar with a particular storage technology, using the explain com-\nmand should allow you to easily figure out how to mount a volume of the proper type\nand use it in your pods.\n But does a developer need to know all this stuff? Should a developer, when creat-\ning a pod, have to deal with infrastructure-related storage details, or should that be\nleft to the cluster administrator? \n Having a pod\u2019s volumes refer to the actual underlying infrastructure isn\u2019t what\nKubernetes is about, is it? For example, for a developer to have to specify the host-\nname of the NFS server feels wrong. And that\u2019s not even the worst thing about it. \n Including this type of infrastructure-related information into a pod definition\nmeans the pod definition is pretty much tied to a specific Kubernetes cluster. You\ncan\u2019t use the same pod definition in another one. That\u2019s why using volumes like this\nisn\u2019t the best way to attach persistent storage to your pods. You\u2019ll learn how to improve\non this in the next section.\nListing 6.8\nA pod using an nfs volume: mongodb-pod-nfs.yaml\nSpecify the ID of the EBS \nvolume you created.\nThe filesystem type \nis EXT4 as before.\nThis volume is backed \nby an NFS share.\nThe IP of the \nNFS server\nThe path exported \nby the server\n \n"}, {"color": "green", "id": "text_119", "label": "176\nCHAPTER 6\nVolumes: attaching disk storage to containers\n6.5\nDecoupling pods from the underlying storage technology\nAll the persistent volume types we\u2019ve explored so far have required the developer of the\npod to have knowledge of the actual network storage infrastructure available in the clus-\nter. For example, to create a NFS-backed volume, the developer has to know the actual\nserver the NFS export is located on. This is against the basic idea of Kubernetes, which\naims to hide the actual infrastructure from both the application and its developer, leav-\ning them free from worrying about the specifics of the infrastructure and making apps\nportable across a wide array of cloud providers and on-premises datacenters.\n Ideally, a developer deploying their apps on Kubernetes should never have to\nknow what kind of storage technology is used underneath, the same way they don\u2019t\nhave to know what type of physical servers are being used to run their pods. Infrastruc-\nture-related dealings should be the sole domain of the cluster administrator.\n When a developer needs a certain amount of persistent storage for their applica-\ntion, they can request it from Kubernetes, the same way they can request CPU, mem-\nory, and other resources when creating a pod. The system administrator can configure\nthe cluster so it can give the apps what they request.\n6.5.1\nIntroducing PersistentVolumes and PersistentVolumeClaims\nTo enable apps to request storage in a Kubernetes cluster without having to deal with\ninfrastructure specifics, two new resources were introduced. They are Persistent-\nVolumes and PersistentVolumeClaims. The names may be a bit misleading, because as\nyou\u2019ve seen in the previous few sections, even regular Kubernetes volumes can be\nused to store persistent data. \n Using a PersistentVolume inside a pod is a little more complex than using a regular\npod volume, so let\u2019s illustrate how pods, PersistentVolumeClaims, PersistentVolumes,\nand the actual underlying storage relate to each other in figure 6.6.\nPod\nAdmin\nVolume\n1. Cluster admin sets up some type of\nnetwork storage (NFS export or similar)\n2. Admin then creates a PersistentVolume (PV)\nby posting a PV descriptor to the Kubernetes API\nNFS\nexport\nPersistent\nVolume\nUser\nPersistent\nVolumeClaim\n3. User creates a\nPersistentVolumeClaim (PVC)\n4. Kubernetes \ufb01nds a PV of\nadequate size and access\nmode and binds the PVC\nto the PV\n5. User creates a\npod with a volume\nreferencing the PVC\nFigure 6.6\nPersistentVolumes are provisioned by cluster admins and consumed by pods \nthrough PersistentVolumeClaims.\n \n", "shape": "dot", "size": 10, "title": "176\nCHAPTER 6\nVolumes: attaching disk storage to containers\n6.5\nDecoupling pods from the underlying storage technology\nAll the persistent volume types we\u2019ve explored so far have required the developer of the\npod to have knowledge of the actual network storage infrastructure available in the clus-\nter. For example, to create a NFS-backed volume, the developer has to know the actual\nserver the NFS export is located on. This is against the basic idea of Kubernetes, which\naims to hide the actual infrastructure from both the application and its developer, leav-\ning them free from worrying about the specifics of the infrastructure and making apps\nportable across a wide array of cloud providers and on-premises datacenters.\n Ideally, a developer deploying their apps on Kubernetes should never have to\nknow what kind of storage technology is used underneath, the same way they don\u2019t\nhave to know what type of physical servers are being used to run their pods. Infrastruc-\nture-related dealings should be the sole domain of the cluster administrator.\n When a developer needs a certain amount of persistent storage for their applica-\ntion, they can request it from Kubernetes, the same way they can request CPU, mem-\nory, and other resources when creating a pod. The system administrator can configure\nthe cluster so it can give the apps what they request.\n6.5.1\nIntroducing PersistentVolumes and PersistentVolumeClaims\nTo enable apps to request storage in a Kubernetes cluster without having to deal with\ninfrastructure specifics, two new resources were introduced. They are Persistent-\nVolumes and PersistentVolumeClaims. The names may be a bit misleading, because as\nyou\u2019ve seen in the previous few sections, even regular Kubernetes volumes can be\nused to store persistent data. \n Using a PersistentVolume inside a pod is a little more complex than using a regular\npod volume, so let\u2019s illustrate how pods, PersistentVolumeClaims, PersistentVolumes,\nand the actual underlying storage relate to each other in figure 6.6.\nPod\nAdmin\nVolume\n1. Cluster admin sets up some type of\nnetwork storage (NFS export or similar)\n2. Admin then creates a PersistentVolume (PV)\nby posting a PV descriptor to the Kubernetes API\nNFS\nexport\nPersistent\nVolume\nUser\nPersistent\nVolumeClaim\n3. User creates a\nPersistentVolumeClaim (PVC)\n4. Kubernetes \ufb01nds a PV of\nadequate size and access\nmode and binds the PVC\nto the PV\n5. User creates a\npod with a volume\nreferencing the PVC\nFigure 6.6\nPersistentVolumes are provisioned by cluster admins and consumed by pods \nthrough PersistentVolumeClaims.\n \n"}, {"color": "green", "id": "text_120", "label": "177\nDecoupling pods from the underlying storage technology\nInstead of the developer adding a technology-specific volume to their pod, it\u2019s the\ncluster administrator who sets up the underlying storage and then registers it in\nKubernetes by creating a PersistentVolume resource through the Kubernetes API\nserver. When creating the PersistentVolume, the admin specifies its size and the access\nmodes it supports. \n When a cluster user needs to use persistent storage in one of their pods, they first\ncreate a PersistentVolumeClaim manifest, specifying the minimum size and the access\nmode they require. The user then submits the PersistentVolumeClaim manifest to the\nKubernetes API server, and Kubernetes finds the appropriate PersistentVolume and\nbinds the volume to the claim. \n The PersistentVolumeClaim can then be used as one of the volumes inside a pod.\nOther users cannot use the same PersistentVolume until it has been released by delet-\ning the bound PersistentVolumeClaim.\n6.5.2\nCreating a PersistentVolume\nLet\u2019s revisit the MongoDB example, but unlike before, you won\u2019t reference the GCE\nPersistent Disk in the pod directly. Instead, you\u2019ll first assume the role of a cluster\nadministrator and create a PersistentVolume backed by the GCE Persistent Disk. Then\nyou\u2019ll assume the role of the application developer and first claim the PersistentVol-\nume and then use it inside your pod.\n In section 6.4.1 you set up the physical storage by provisioning the GCE Persistent\nDisk, so you don\u2019t need to do that again. All you need to do is create the Persistent-\nVolume resource in Kubernetes by preparing the manifest shown in the following list-\ning and posting it to the API server.\napiVersion: v1\nkind: PersistentVolume\nmetadata:\n  name: mongodb-pv\nspec:\n  capacity:                  \n    storage: 1Gi             \n  accessModes:                              \n  - ReadWriteOnce                           \n  - ReadOnlyMany                            \n  persistentVolumeReclaimPolicy: Retain    \n  gcePersistentDisk:                      \n    pdName: mongodb                       \n    fsType: ext4                          \nListing 6.9\nA gcePersistentDisk PersistentVolume: mongodb-pv-gcepd.yaml\nDefining the \nPersistentVolume\u2019s size\nIt can either be mounted by a single \nclient for reading and writing or by \nmultiple clients for reading only.\nAfter the claim is released, \nthe PersistentVolume \nshould be retained (not \nerased or deleted).\nThe PersistentVolume is \nbacked by the GCE Persistent \nDisk you created earlier.\n \n", "shape": "dot", "size": 10, "title": "177\nDecoupling pods from the underlying storage technology\nInstead of the developer adding a technology-specific volume to their pod, it\u2019s the\ncluster administrator who sets up the underlying storage and then registers it in\nKubernetes by creating a PersistentVolume resource through the Kubernetes API\nserver. When creating the PersistentVolume, the admin specifies its size and the access\nmodes it supports. \n When a cluster user needs to use persistent storage in one of their pods, they first\ncreate a PersistentVolumeClaim manifest, specifying the minimum size and the access\nmode they require. The user then submits the PersistentVolumeClaim manifest to the\nKubernetes API server, and Kubernetes finds the appropriate PersistentVolume and\nbinds the volume to the claim. \n The PersistentVolumeClaim can then be used as one of the volumes inside a pod.\nOther users cannot use the same PersistentVolume until it has been released by delet-\ning the bound PersistentVolumeClaim.\n6.5.2\nCreating a PersistentVolume\nLet\u2019s revisit the MongoDB example, but unlike before, you won\u2019t reference the GCE\nPersistent Disk in the pod directly. Instead, you\u2019ll first assume the role of a cluster\nadministrator and create a PersistentVolume backed by the GCE Persistent Disk. Then\nyou\u2019ll assume the role of the application developer and first claim the PersistentVol-\nume and then use it inside your pod.\n In section 6.4.1 you set up the physical storage by provisioning the GCE Persistent\nDisk, so you don\u2019t need to do that again. All you need to do is create the Persistent-\nVolume resource in Kubernetes by preparing the manifest shown in the following list-\ning and posting it to the API server.\napiVersion: v1\nkind: PersistentVolume\nmetadata:\n  name: mongodb-pv\nspec:\n  capacity:                  \n    storage: 1Gi             \n  accessModes:                              \n  - ReadWriteOnce                           \n  - ReadOnlyMany                            \n  persistentVolumeReclaimPolicy: Retain    \n  gcePersistentDisk:                      \n    pdName: mongodb                       \n    fsType: ext4                          \nListing 6.9\nA gcePersistentDisk PersistentVolume: mongodb-pv-gcepd.yaml\nDefining the \nPersistentVolume\u2019s size\nIt can either be mounted by a single \nclient for reading and writing or by \nmultiple clients for reading only.\nAfter the claim is released, \nthe PersistentVolume \nshould be retained (not \nerased or deleted).\nThe PersistentVolume is \nbacked by the GCE Persistent \nDisk you created earlier.\n \n"}, {"color": "green", "id": "text_121", "label": "178\nCHAPTER 6\nVolumes: attaching disk storage to containers\nNOTE\nIf you\u2019re using Minikube, create the PV using the mongodb-pv-host-\npath.yaml file.\nWhen creating a PersistentVolume, the administrator needs to tell Kubernetes what its\ncapacity is and whether it can be read from and/or written to by a single node or by\nmultiple nodes at the same time. They also need to tell Kubernetes what to do with the\nPersistentVolume when it\u2019s released (when the PersistentVolumeClaim it\u2019s bound to is\ndeleted). And last, but certainly not least, they need to specify the type, location, and\nother properties of the actual storage this PersistentVolume is backed by. If you look\nclosely, this last part is exactly the same as earlier, when you referenced the GCE Per-\nsistent Disk in the pod volume directly (shown again in the following listing).\nspec:\n  volumes:                       \n  - name: mongodb-data           \n    gcePersistentDisk:           \n      pdName: mongodb            \n      fsType: ext4               \n  ...\nAfter you create the PersistentVolume with the kubectl create command, it should\nbe ready to be claimed. See if it is by listing all PersistentVolumes:\n$ kubectl get pv\nNAME         CAPACITY   RECLAIMPOLICY   ACCESSMODES   STATUS      CLAIM\nmongodb-pv   1Gi        Retain          RWO,ROX       Available   \nNOTE\nSeveral columns are omitted. Also, pv is used as a shorthand for\npersistentvolume.\nAs expected, the PersistentVolume is shown as Available, because you haven\u2019t yet cre-\nated the PersistentVolumeClaim. \nNOTE\nPersistentVolumes don\u2019t belong to any namespace (see figure 6.7).\nThey\u2019re cluster-level resources like nodes.\nListing 6.10\nReferencing a GCE PD in a pod\u2019s volume\n \n", "shape": "dot", "size": 10, "title": "178\nCHAPTER 6\nVolumes: attaching disk storage to containers\nNOTE\nIf you\u2019re using Minikube, create the PV using the mongodb-pv-host-\npath.yaml file.\nWhen creating a PersistentVolume, the administrator needs to tell Kubernetes what its\ncapacity is and whether it can be read from and/or written to by a single node or by\nmultiple nodes at the same time. They also need to tell Kubernetes what to do with the\nPersistentVolume when it\u2019s released (when the PersistentVolumeClaim it\u2019s bound to is\ndeleted). And last, but certainly not least, they need to specify the type, location, and\nother properties of the actual storage this PersistentVolume is backed by. If you look\nclosely, this last part is exactly the same as earlier, when you referenced the GCE Per-\nsistent Disk in the pod volume directly (shown again in the following listing).\nspec:\n  volumes:                       \n  - name: mongodb-data           \n    gcePersistentDisk:           \n      pdName: mongodb            \n      fsType: ext4               \n  ...\nAfter you create the PersistentVolume with the kubectl create command, it should\nbe ready to be claimed. See if it is by listing all PersistentVolumes:\n$ kubectl get pv\nNAME         CAPACITY   RECLAIMPOLICY   ACCESSMODES   STATUS      CLAIM\nmongodb-pv   1Gi        Retain          RWO,ROX       Available   \nNOTE\nSeveral columns are omitted. Also, pv is used as a shorthand for\npersistentvolume.\nAs expected, the PersistentVolume is shown as Available, because you haven\u2019t yet cre-\nated the PersistentVolumeClaim. \nNOTE\nPersistentVolumes don\u2019t belong to any namespace (see figure 6.7).\nThey\u2019re cluster-level resources like nodes.\nListing 6.10\nReferencing a GCE PD in a pod\u2019s volume\n \n"}, {"color": "green", "id": "text_122", "label": "179\nDecoupling pods from the underlying storage technology\n6.5.3\nClaiming a PersistentVolume by creating a \nPersistentVolumeClaim\nNow let\u2019s lay down our admin hats and put our developer hats back on. Say you need\nto deploy a pod that requires persistent storage. You\u2019ll use the PersistentVolume you\ncreated earlier. But you can\u2019t use it directly in the pod. You need to claim it first.\n Claiming a PersistentVolume is a completely separate process from creating a pod,\nbecause you want the same PersistentVolumeClaim to stay available even if the pod is\nrescheduled (remember, rescheduling means the previous pod is deleted and a new\none is created). \nCREATING A PERSISTENTVOLUMECLAIM\nYou\u2019ll create the claim now. You need to prepare a PersistentVolumeClaim manifest\nlike the one shown in the following listing and post it to the Kubernetes API through\nkubectl create.\napiVersion: v1\nkind: PersistentVolumeClaim\nmetadata:\n  name: mongodb-pvc          \nListing 6.11\nA PersistentVolumeClaim: mongodb-pvc.yaml\nPod(s)\nPod(s)\nPersistent\nVolume\nPersistent\nVolume\nPersistent\nVolume\nPersistent\nVolume\n...\nUser A\nPersistent\nVolume\nClaim(s)\nPersistent\nVolume\nClaim(s)\nNamespace A\nUser B\nNamespace B\nNode\nNode\nNode\nNode\nNode\nNode\nPersistent\nVolume\nFigure 6.7\nPersistentVolumes, like cluster Nodes, don\u2019t belong to any namespace, unlike pods and \nPersistentVolumeClaims.\nThe name of your claim\u2014you\u2019ll \nneed this later when using the \nclaim as the pod\u2019s volume.\n \n", "shape": "dot", "size": 10, "title": "179\nDecoupling pods from the underlying storage technology\n6.5.3\nClaiming a PersistentVolume by creating a \nPersistentVolumeClaim\nNow let\u2019s lay down our admin hats and put our developer hats back on. Say you need\nto deploy a pod that requires persistent storage. You\u2019ll use the PersistentVolume you\ncreated earlier. But you can\u2019t use it directly in the pod. You need to claim it first.\n Claiming a PersistentVolume is a completely separate process from creating a pod,\nbecause you want the same PersistentVolumeClaim to stay available even if the pod is\nrescheduled (remember, rescheduling means the previous pod is deleted and a new\none is created). \nCREATING A PERSISTENTVOLUMECLAIM\nYou\u2019ll create the claim now. You need to prepare a PersistentVolumeClaim manifest\nlike the one shown in the following listing and post it to the Kubernetes API through\nkubectl create.\napiVersion: v1\nkind: PersistentVolumeClaim\nmetadata:\n  name: mongodb-pvc          \nListing 6.11\nA PersistentVolumeClaim: mongodb-pvc.yaml\nPod(s)\nPod(s)\nPersistent\nVolume\nPersistent\nVolume\nPersistent\nVolume\nPersistent\nVolume\n...\nUser A\nPersistent\nVolume\nClaim(s)\nPersistent\nVolume\nClaim(s)\nNamespace A\nUser B\nNamespace B\nNode\nNode\nNode\nNode\nNode\nNode\nPersistent\nVolume\nFigure 6.7\nPersistentVolumes, like cluster Nodes, don\u2019t belong to any namespace, unlike pods and \nPersistentVolumeClaims.\nThe name of your claim\u2014you\u2019ll \nneed this later when using the \nclaim as the pod\u2019s volume.\n \n"}, {"color": "green", "id": "text_123", "label": "180\nCHAPTER 6\nVolumes: attaching disk storage to containers\nspec:\n  resources:\n    requests:                \n      storage: 1Gi           \n  accessModes:              \n  - ReadWriteOnce           \n  storageClassName: \"\"     \nAs soon as you create the claim, Kubernetes finds the appropriate PersistentVolume\nand binds it to the claim. The PersistentVolume\u2019s capacity must be large enough to\naccommodate what the claim requests. Additionally, the volume\u2019s access modes must\ninclude the access modes requested by the claim. In your case, the claim requests 1 GiB\nof storage and a ReadWriteOnce access mode. The PersistentVolume you created ear-\nlier matches those two requirements so it is bound to your claim. You can see this by\ninspecting the claim.\nLISTING PERSISTENTVOLUMECLAIMS\nList all PersistentVolumeClaims to see the state of your PVC:\n$ kubectl get pvc\nNAME          STATUS    VOLUME       CAPACITY   ACCESSMODES   AGE\nmongodb-pvc   Bound     mongodb-pv   1Gi        RWO,ROX       3s\nNOTE\nWe\u2019re using pvc as a shorthand for persistentvolumeclaim.\nThe claim is shown as Bound to PersistentVolume mongodb-pv. Note the abbreviations\nused for the access modes:\n\uf0a1\nRWO\u2014ReadWriteOnce\u2014Only a single node can mount the volume for reading\nand writing.\n\uf0a1\nROX\u2014ReadOnlyMany\u2014Multiple nodes can mount the volume for reading.\n\uf0a1\nRWX\u2014ReadWriteMany\u2014Multiple nodes can mount the volume for both reading\nand writing.\nNOTE\nRWO, ROX, and RWX pertain to the number of worker nodes that can use\nthe volume at the same time, not to the number of pods!\nLISTING PERSISTENTVOLUMES\nYou can also see that the PersistentVolume is now Bound and no longer Available by\ninspecting it with kubectl get:\n$ kubectl get pv\nNAME         CAPACITY   ACCESSMODES   STATUS   CLAIM                 AGE\nmongodb-pv   1Gi        RWO,ROX       Bound    default/mongodb-pvc   1m\nThe PersistentVolume shows it\u2019s bound to claim default/mongodb-pvc. The default\npart is the namespace the claim resides in (you created the claim in the default\nRequesting 1 GiB of storage\nYou want the storage to support a single \nclient (performing both reads and writes).\nYou\u2019ll learn about this in the section \nabout dynamic provisioning.\n \n", "shape": "dot", "size": 10, "title": "180\nCHAPTER 6\nVolumes: attaching disk storage to containers\nspec:\n  resources:\n    requests:                \n      storage: 1Gi           \n  accessModes:              \n  - ReadWriteOnce           \n  storageClassName: \"\"     \nAs soon as you create the claim, Kubernetes finds the appropriate PersistentVolume\nand binds it to the claim. The PersistentVolume\u2019s capacity must be large enough to\naccommodate what the claim requests. Additionally, the volume\u2019s access modes must\ninclude the access modes requested by the claim. In your case, the claim requests 1 GiB\nof storage and a ReadWriteOnce access mode. The PersistentVolume you created ear-\nlier matches those two requirements so it is bound to your claim. You can see this by\ninspecting the claim.\nLISTING PERSISTENTVOLUMECLAIMS\nList all PersistentVolumeClaims to see the state of your PVC:\n$ kubectl get pvc\nNAME          STATUS    VOLUME       CAPACITY   ACCESSMODES   AGE\nmongodb-pvc   Bound     mongodb-pv   1Gi        RWO,ROX       3s\nNOTE\nWe\u2019re using pvc as a shorthand for persistentvolumeclaim.\nThe claim is shown as Bound to PersistentVolume mongodb-pv. Note the abbreviations\nused for the access modes:\n\uf0a1\nRWO\u2014ReadWriteOnce\u2014Only a single node can mount the volume for reading\nand writing.\n\uf0a1\nROX\u2014ReadOnlyMany\u2014Multiple nodes can mount the volume for reading.\n\uf0a1\nRWX\u2014ReadWriteMany\u2014Multiple nodes can mount the volume for both reading\nand writing.\nNOTE\nRWO, ROX, and RWX pertain to the number of worker nodes that can use\nthe volume at the same time, not to the number of pods!\nLISTING PERSISTENTVOLUMES\nYou can also see that the PersistentVolume is now Bound and no longer Available by\ninspecting it with kubectl get:\n$ kubectl get pv\nNAME         CAPACITY   ACCESSMODES   STATUS   CLAIM                 AGE\nmongodb-pv   1Gi        RWO,ROX       Bound    default/mongodb-pvc   1m\nThe PersistentVolume shows it\u2019s bound to claim default/mongodb-pvc. The default\npart is the namespace the claim resides in (you created the claim in the default\nRequesting 1 GiB of storage\nYou want the storage to support a single \nclient (performing both reads and writes).\nYou\u2019ll learn about this in the section \nabout dynamic provisioning.\n \n"}, {"color": "green", "id": "text_124", "label": "181\nDecoupling pods from the underlying storage technology\nnamespace). We\u2019ve already said that PersistentVolume resources are cluster-scoped\nand thus cannot be created in a specific namespace, but PersistentVolumeClaims can\nonly be created in a specific namespace. They can then only be used by pods in the\nsame namespace.\n6.5.4\nUsing a PersistentVolumeClaim in a pod\nThe PersistentVolume is now yours to use. Nobody else can claim the same volume\nuntil you release it. To use it inside a pod, you need to reference the Persistent-\nVolumeClaim by name inside the pod\u2019s volume (yes, the PersistentVolumeClaim, not\nthe PersistentVolume directly!), as shown in the following listing.\napiVersion: v1\nkind: Pod\nmetadata:\n  name: mongodb \nspec:\n  containers:\n  - image: mongo\n    name: mongodb\n    volumeMounts:\n    - name: mongodb-data\n      mountPath: /data/db\n    ports:\n    - containerPort: 27017\n      protocol: TCP\n  volumes:\n  - name: mongodb-data\n    persistentVolumeClaim:       \n      claimName: mongodb-pvc     \nGo ahead and create the pod. Now, check to see if the pod is indeed using the same\nPersistentVolume and its underlying GCE PD. You should see the data you stored ear-\nlier by running the MongoDB shell again, as shown in the following listing.\n$ kubectl exec -it mongodb mongo\nMongoDB shell version: 3.2.8\nconnecting to: mongodb://127.0.0.1:27017\nWelcome to the MongoDB shell.\n...\n\u003e use mystore\nswitched to db mystore\n\u003e db.foo.find()\n{ \"_id\" : ObjectId(\"57a61eb9de0cfd512374cc75\"), \"name\" : \"foo\" }\nAnd there it is. You\u2018re able to retrieve the document you stored into MongoDB\npreviously.\nListing 6.12\nA pod using a PersistentVolumeClaim volume: mongodb-pod-pvc.yaml\nListing 6.13\nRetrieving MongoDB\u2019s persisted data in the pod using the PVC and PV\nReferencing the PersistentVolumeClaim \nby name in the pod volume\n \n", "shape": "dot", "size": 10, "title": "181\nDecoupling pods from the underlying storage technology\nnamespace). We\u2019ve already said that PersistentVolume resources are cluster-scoped\nand thus cannot be created in a specific namespace, but PersistentVolumeClaims can\nonly be created in a specific namespace. They can then only be used by pods in the\nsame namespace.\n6.5.4\nUsing a PersistentVolumeClaim in a pod\nThe PersistentVolume is now yours to use. Nobody else can claim the same volume\nuntil you release it. To use it inside a pod, you need to reference the Persistent-\nVolumeClaim by name inside the pod\u2019s volume (yes, the PersistentVolumeClaim, not\nthe PersistentVolume directly!), as shown in the following listing.\napiVersion: v1\nkind: Pod\nmetadata:\n  name: mongodb \nspec:\n  containers:\n  - image: mongo\n    name: mongodb\n    volumeMounts:\n    - name: mongodb-data\n      mountPath: /data/db\n    ports:\n    - containerPort: 27017\n      protocol: TCP\n  volumes:\n  - name: mongodb-data\n    persistentVolumeClaim:       \n      claimName: mongodb-pvc     \nGo ahead and create the pod. Now, check to see if the pod is indeed using the same\nPersistentVolume and its underlying GCE PD. You should see the data you stored ear-\nlier by running the MongoDB shell again, as shown in the following listing.\n$ kubectl exec -it mongodb mongo\nMongoDB shell version: 3.2.8\nconnecting to: mongodb://127.0.0.1:27017\nWelcome to the MongoDB shell.\n...\n\u003e use mystore\nswitched to db mystore\n\u003e db.foo.find()\n{ \"_id\" : ObjectId(\"57a61eb9de0cfd512374cc75\"), \"name\" : \"foo\" }\nAnd there it is. You\u2018re able to retrieve the document you stored into MongoDB\npreviously.\nListing 6.12\nA pod using a PersistentVolumeClaim volume: mongodb-pod-pvc.yaml\nListing 6.13\nRetrieving MongoDB\u2019s persisted data in the pod using the PVC and PV\nReferencing the PersistentVolumeClaim \nby name in the pod volume\n \n"}, {"color": "green", "id": "text_125", "label": "182\nCHAPTER 6\nVolumes: attaching disk storage to containers\n6.5.5\nUnderstanding the benefits of using PersistentVolumes and claims\nExamine figure 6.8, which shows both ways a pod can use a GCE Persistent Disk\u2014\ndirectly or through a PersistentVolume and claim.\nConsider how using this indirect method of obtaining storage from the infrastructure\nis much simpler for the application developer (or cluster user). Yes, it does require\nthe additional steps of creating the PersistentVolume and the PersistentVolumeClaim,\nbut the developer doesn\u2019t have to know anything about the actual storage technology\nused underneath. \n Additionally, the same pod and claim manifests can now be used on many different\nKubernetes clusters, because they don\u2019t refer to anything infrastructure-specific. The\nclaim states, \u201cI need x amount of storage and I need to be able to read and write to it\nby a single client at once,\u201d and then the pod references the claim by name in one of\nits volumes.\nPod: mongodb\nContainer: mongodb\nvolumeMounts:\nname: mongodb-data\nmountPath: /data/db\ngcePersistentDisk:\npdName: mongodb\nGCE\nPersistent Disk:\nmongodb\nVolume:\nmongodb\nPod: mongodb\nContainer: mongodb\nvolumeMounts:\nname: mongodb-data\nmountPath: /data/db\npersistentVolumeClaim:\nclaimName: mongodb-pvc\ngcePersistentDisk:\npdName: mongodb\nGCE\nPersistent Disk:\nmongodb\nPersistentVolume:\nmongodb-pv\n(1 Gi, RWO, RWX)\nVolume:\nmongodb\nClaim lists\n1Gi and\nReadWriteOnce\naccess\nPersistentVolumeClaim:\nmongodb-pvc\nFigure 6.8\nUsing the GCE Persistent Disk directly or through a PVC and PV\n \n", "shape": "dot", "size": 10, "title": "182\nCHAPTER 6\nVolumes: attaching disk storage to containers\n6.5.5\nUnderstanding the benefits of using PersistentVolumes and claims\nExamine figure 6.8, which shows both ways a pod can use a GCE Persistent Disk\u2014\ndirectly or through a PersistentVolume and claim.\nConsider how using this indirect method of obtaining storage from the infrastructure\nis much simpler for the application developer (or cluster user). Yes, it does require\nthe additional steps of creating the PersistentVolume and the PersistentVolumeClaim,\nbut the developer doesn\u2019t have to know anything about the actual storage technology\nused underneath. \n Additionally, the same pod and claim manifests can now be used on many different\nKubernetes clusters, because they don\u2019t refer to anything infrastructure-specific. The\nclaim states, \u201cI need x amount of storage and I need to be able to read and write to it\nby a single client at once,\u201d and then the pod references the claim by name in one of\nits volumes.\nPod: mongodb\nContainer: mongodb\nvolumeMounts:\nname: mongodb-data\nmountPath: /data/db\ngcePersistentDisk:\npdName: mongodb\nGCE\nPersistent Disk:\nmongodb\nVolume:\nmongodb\nPod: mongodb\nContainer: mongodb\nvolumeMounts:\nname: mongodb-data\nmountPath: /data/db\npersistentVolumeClaim:\nclaimName: mongodb-pvc\ngcePersistentDisk:\npdName: mongodb\nGCE\nPersistent Disk:\nmongodb\nPersistentVolume:\nmongodb-pv\n(1 Gi, RWO, RWX)\nVolume:\nmongodb\nClaim lists\n1Gi and\nReadWriteOnce\naccess\nPersistentVolumeClaim:\nmongodb-pvc\nFigure 6.8\nUsing the GCE Persistent Disk directly or through a PVC and PV\n \n"}, {"color": "green", "id": "text_126", "label": "183\nDecoupling pods from the underlying storage technology\n6.5.6\nRecycling PersistentVolumes\nBefore you wrap up this section on PersistentVolumes, let\u2019s do one last quick experi-\nment. Delete the pod and the PersistentVolumeClaim:\n$ kubectl delete pod mongodb\npod \"mongodb\" deleted\n$ kubectl delete pvc mongodb-pvc\npersistentvolumeclaim \"mongodb-pvc\" deleted\nWhat if you create the PersistentVolumeClaim again? Will it be bound to the Persistent-\nVolume or not? After you create the claim, what does kubectl get pvc show?\n$ kubectl get pvc\nNAME           STATUS    VOLUME       CAPACITY   ACCESSMODES   AGE\nmongodb-pvc    Pending                                         13s\nThe claim\u2019s status is shown as Pending. Interesting. When you created the claim ear-\nlier, it was immediately bound to the PersistentVolume, so why wasn\u2019t it bound now?\nMaybe listing the PersistentVolumes can shed more light on this:\n$ kubectl get pv\nNAME        CAPACITY  ACCESSMODES  STATUS    CLAIM               REASON AGE\nmongodb-pv  1Gi       RWO,ROX      Released  default/mongodb-pvc        5m\nThe STATUS column shows the PersistentVolume as Released, not Available like\nbefore. Because you\u2019ve already used the volume, it may contain data and shouldn\u2019t be\nbound to a completely new claim without giving the cluster admin a chance to clean it\nup. Without this, a new pod using the same PersistentVolume could read the data\nstored there by the previous pod, even if the claim and pod were created in a different\nnamespace (and thus likely belong to a different cluster tenant).\nRECLAIMING PERSISTENTVOLUMES MANUALLY\nYou told Kubernetes you wanted your PersistentVolume to behave like this when you\ncreated it\u2014by setting its persistentVolumeReclaimPolicy to Retain. You wanted\nKubernetes to retain the volume and its contents after it\u2019s released from its claim. As\nfar as I\u2019m aware, the only way to manually recycle the PersistentVolume to make it\navailable again is to delete and recreate the PersistentVolume resource. As you do\nthat, it\u2019s your decision what to do with the files on the underlying storage: you can\neither delete them or leave them alone so they can be reused by the next  pod.\nRECLAIMING PERSISTENTVOLUMES AUTOMATICALLY\nTwo other possible reclaim policies exist: Recycle and Delete. The first one deletes\nthe volume\u2019s contents and makes the volume available to be claimed again. This way,\nthe PersistentVolume can be reused multiple times by different PersistentVolume-\nClaims and different pods, as you can see in figure 6.9.\n The Delete policy, on the other hand, deletes the underlying storage. Note that\nthe Recycle option is currently not available for GCE Persistent Disks. This type of\n \n", "shape": "dot", "size": 10, "title": "183\nDecoupling pods from the underlying storage technology\n6.5.6\nRecycling PersistentVolumes\nBefore you wrap up this section on PersistentVolumes, let\u2019s do one last quick experi-\nment. Delete the pod and the PersistentVolumeClaim:\n$ kubectl delete pod mongodb\npod \"mongodb\" deleted\n$ kubectl delete pvc mongodb-pvc\npersistentvolumeclaim \"mongodb-pvc\" deleted\nWhat if you create the PersistentVolumeClaim again? Will it be bound to the Persistent-\nVolume or not? After you create the claim, what does kubectl get pvc show?\n$ kubectl get pvc\nNAME           STATUS    VOLUME       CAPACITY   ACCESSMODES   AGE\nmongodb-pvc    Pending                                         13s\nThe claim\u2019s status is shown as Pending. Interesting. When you created the claim ear-\nlier, it was immediately bound to the PersistentVolume, so why wasn\u2019t it bound now?\nMaybe listing the PersistentVolumes can shed more light on this:\n$ kubectl get pv\nNAME        CAPACITY  ACCESSMODES  STATUS    CLAIM               REASON AGE\nmongodb-pv  1Gi       RWO,ROX      Released  default/mongodb-pvc        5m\nThe STATUS column shows the PersistentVolume as Released, not Available like\nbefore. Because you\u2019ve already used the volume, it may contain data and shouldn\u2019t be\nbound to a completely new claim without giving the cluster admin a chance to clean it\nup. Without this, a new pod using the same PersistentVolume could read the data\nstored there by the previous pod, even if the claim and pod were created in a different\nnamespace (and thus likely belong to a different cluster tenant).\nRECLAIMING PERSISTENTVOLUMES MANUALLY\nYou told Kubernetes you wanted your PersistentVolume to behave like this when you\ncreated it\u2014by setting its persistentVolumeReclaimPolicy to Retain. You wanted\nKubernetes to retain the volume and its contents after it\u2019s released from its claim. As\nfar as I\u2019m aware, the only way to manually recycle the PersistentVolume to make it\navailable again is to delete and recreate the PersistentVolume resource. As you do\nthat, it\u2019s your decision what to do with the files on the underlying storage: you can\neither delete them or leave them alone so they can be reused by the next  pod.\nRECLAIMING PERSISTENTVOLUMES AUTOMATICALLY\nTwo other possible reclaim policies exist: Recycle and Delete. The first one deletes\nthe volume\u2019s contents and makes the volume available to be claimed again. This way,\nthe PersistentVolume can be reused multiple times by different PersistentVolume-\nClaims and different pods, as you can see in figure 6.9.\n The Delete policy, on the other hand, deletes the underlying storage. Note that\nthe Recycle option is currently not available for GCE Persistent Disks. This type of\n \n"}, {"color": "green", "id": "text_127", "label": "184\nCHAPTER 6\nVolumes: attaching disk storage to containers\nA PersistentVolume only supports the Retain or Delete policies. Other Persistent-\nVolume types may or may not support each of these options, so before creating your\nown PersistentVolume, be sure to check what reclaim policies are supported for the\nspecific underlying storage you\u2019ll use in the volume.\nTIP\nYou can change the PersistentVolume reclaim policy on an existing\nPersistentVolume. For example, if it\u2019s initially set to Delete, you can easily\nchange it to Retain to prevent losing valuable data.\n6.6\nDynamic provisioning of PersistentVolumes\nYou\u2019ve seen how using PersistentVolumes and PersistentVolumeClaims makes it easy\nto obtain persistent storage without the developer having to deal with the actual stor-\nage technology used underneath. But this still requires a cluster administrator to pro-\nvision the actual storage up front. Luckily, Kubernetes can also perform this job\nautomatically through dynamic provisioning of PersistentVolumes.\n The cluster admin, instead of creating PersistentVolumes, can deploy a Persistent-\nVolume provisioner and define one or more StorageClass objects to let users choose\nwhat type of PersistentVolume they want. The users can refer to the StorageClass in\ntheir PersistentVolumeClaims and the provisioner will take that into account when\nprovisioning the persistent storage. \nNOTE\nSimilar to PersistentVolumes, StorageClass resources aren\u2019t namespaced.\nKubernetes includes provisioners for the most popular cloud providers, so the admin-\nistrator doesn\u2019t always need to deploy a provisioner. But if Kubernetes is deployed\non-premises, a custom provisioner needs to be deployed.\nPersistentVolume\nPersistentVolumeClaim 1\nPod 1\nPod 2\nPersistentVolumeClaim 2\nPod 3\nPVC is deleted;\nPV is automatically\nrecycled and ready\nto be claimed and\nre-used again\nUser creates\nPersistentVolumeClaim\nPod 2\nunmounts\nPVC\nPod 2\nmounts\nPVC\nPod 1\nmounts\nPVC\nPod 1\nunmounts\nPVC\nAdmin deletes\nPersistentVolume\nAdmin creates\nPersistentVolume\nTime\nFigure 6.9\nThe lifespan of a PersistentVolume, PersistentVolumeClaims, and pods using them\n \n", "shape": "dot", "size": 10, "title": "184\nCHAPTER 6\nVolumes: attaching disk storage to containers\nA PersistentVolume only supports the Retain or Delete policies. Other Persistent-\nVolume types may or may not support each of these options, so before creating your\nown PersistentVolume, be sure to check what reclaim policies are supported for the\nspecific underlying storage you\u2019ll use in the volume.\nTIP\nYou can change the PersistentVolume reclaim policy on an existing\nPersistentVolume. For example, if it\u2019s initially set to Delete, you can easily\nchange it to Retain to prevent losing valuable data.\n6.6\nDynamic provisioning of PersistentVolumes\nYou\u2019ve seen how using PersistentVolumes and PersistentVolumeClaims makes it easy\nto obtain persistent storage without the developer having to deal with the actual stor-\nage technology used underneath. But this still requires a cluster administrator to pro-\nvision the actual storage up front. Luckily, Kubernetes can also perform this job\nautomatically through dynamic provisioning of PersistentVolumes.\n The cluster admin, instead of creating PersistentVolumes, can deploy a Persistent-\nVolume provisioner and define one or more StorageClass objects to let users choose\nwhat type of PersistentVolume they want. The users can refer to the StorageClass in\ntheir PersistentVolumeClaims and the provisioner will take that into account when\nprovisioning the persistent storage. \nNOTE\nSimilar to PersistentVolumes, StorageClass resources aren\u2019t namespaced.\nKubernetes includes provisioners for the most popular cloud providers, so the admin-\nistrator doesn\u2019t always need to deploy a provisioner. But if Kubernetes is deployed\non-premises, a custom provisioner needs to be deployed.\nPersistentVolume\nPersistentVolumeClaim 1\nPod 1\nPod 2\nPersistentVolumeClaim 2\nPod 3\nPVC is deleted;\nPV is automatically\nrecycled and ready\nto be claimed and\nre-used again\nUser creates\nPersistentVolumeClaim\nPod 2\nunmounts\nPVC\nPod 2\nmounts\nPVC\nPod 1\nmounts\nPVC\nPod 1\nunmounts\nPVC\nAdmin deletes\nPersistentVolume\nAdmin creates\nPersistentVolume\nTime\nFigure 6.9\nThe lifespan of a PersistentVolume, PersistentVolumeClaims, and pods using them\n \n"}, {"color": "green", "id": "text_128", "label": "185\nDynamic provisioning of PersistentVolumes\n Instead of the administrator pre-provisioning a bunch of PersistentVolumes, they\nneed to define one or two (or more) StorageClasses and let the system create a new\nPersistentVolume each time one is requested through a PersistentVolumeClaim. The\ngreat thing about this is that it\u2019s impossible to run out of PersistentVolumes (obviously,\nyou can run out of storage space). \n6.6.1\nDefining the available storage types through StorageClass \nresources\nBefore a user can create a PersistentVolumeClaim, which will result in a new Persistent-\nVolume being provisioned, an admin needs to create one or more StorageClass\nresources. Let\u2019s look at an example of one in the following listing.\napiVersion: storage.k8s.io/v1\nkind: StorageClass\nmetadata:\n  name: fast\nprovisioner: kubernetes.io/gce-pd       \nparameters:\n  type: pd-ssd                     \n  zone: europe-west1-b             \nNOTE\nIf using Minikube, deploy the file storageclass-fast-hostpath.yaml.\nThe StorageClass resource specifies which provisioner should be used for provision-\ning the PersistentVolume when a PersistentVolumeClaim requests this StorageClass.\nThe parameters defined in the StorageClass definition are passed to the provisioner\nand are specific to each provisioner plugin. \n The StorageClass uses the Google Compute Engine (GCE) Persistent Disk (PD)\nprovisioner, which means it can be used when Kubernetes is running in GCE. For\nother cloud providers, other provisioners need to be used.\n6.6.2\nRequesting the storage class in a PersistentVolumeClaim\nAfter the StorageClass resource is created, users can refer to the storage class by name\nin their PersistentVolumeClaims. \nCREATING A PVC DEFINITION REQUESTING A SPECIFIC STORAGE CLASS\nYou can modify your mongodb-pvc to use dynamic provisioning. The following listing\nshows the updated YAML definition of the PVC.\napiVersion: v1\nkind: PersistentVolumeClaim\nmetadata:\n  name: mongodb-pvc \nListing 6.14\nA StorageClass definition: storageclass-fast-gcepd.yaml\nListing 6.15\nA PVC with dynamic provisioning: mongodb-pvc-dp.yaml\nThe volume plugin to \nuse for provisioning \nthe PersistentVolume\nThe parameters passed \nto the provisioner\n \n", "shape": "dot", "size": 10, "title": "185\nDynamic provisioning of PersistentVolumes\n Instead of the administrator pre-provisioning a bunch of PersistentVolumes, they\nneed to define one or two (or more) StorageClasses and let the system create a new\nPersistentVolume each time one is requested through a PersistentVolumeClaim. The\ngreat thing about this is that it\u2019s impossible to run out of PersistentVolumes (obviously,\nyou can run out of storage space). \n6.6.1\nDefining the available storage types through StorageClass \nresources\nBefore a user can create a PersistentVolumeClaim, which will result in a new Persistent-\nVolume being provisioned, an admin needs to create one or more StorageClass\nresources. Let\u2019s look at an example of one in the following listing.\napiVersion: storage.k8s.io/v1\nkind: StorageClass\nmetadata:\n  name: fast\nprovisioner: kubernetes.io/gce-pd       \nparameters:\n  type: pd-ssd                     \n  zone: europe-west1-b             \nNOTE\nIf using Minikube, deploy the file storageclass-fast-hostpath.yaml.\nThe StorageClass resource specifies which provisioner should be used for provision-\ning the PersistentVolume when a PersistentVolumeClaim requests this StorageClass.\nThe parameters defined in the StorageClass definition are passed to the provisioner\nand are specific to each provisioner plugin. \n The StorageClass uses the Google Compute Engine (GCE) Persistent Disk (PD)\nprovisioner, which means it can be used when Kubernetes is running in GCE. For\nother cloud providers, other provisioners need to be used.\n6.6.2\nRequesting the storage class in a PersistentVolumeClaim\nAfter the StorageClass resource is created, users can refer to the storage class by name\nin their PersistentVolumeClaims. \nCREATING A PVC DEFINITION REQUESTING A SPECIFIC STORAGE CLASS\nYou can modify your mongodb-pvc to use dynamic provisioning. The following listing\nshows the updated YAML definition of the PVC.\napiVersion: v1\nkind: PersistentVolumeClaim\nmetadata:\n  name: mongodb-pvc \nListing 6.14\nA StorageClass definition: storageclass-fast-gcepd.yaml\nListing 6.15\nA PVC with dynamic provisioning: mongodb-pvc-dp.yaml\nThe volume plugin to \nuse for provisioning \nthe PersistentVolume\nThe parameters passed \nto the provisioner\n \n"}, {"color": "green", "id": "text_129", "label": "186\nCHAPTER 6\nVolumes: attaching disk storage to containers\nspec:\n  storageClassName: fast     \n  resources:\n    requests:\n      storage: 100Mi\n  accessModes:\n    - ReadWriteOnce\nApart from specifying the size and access modes, your PersistentVolumeClaim now\nalso specifies the class of storage you want to use. When you create the claim, the\nPersistentVolume is created by the provisioner referenced in the fast StorageClass\nresource. The provisioner is used even if an existing manually provisioned Persistent-\nVolume matches the PersistentVolumeClaim. \nNOTE\nIf you reference a non-existing storage class in a PVC, the provisioning\nof the PV will fail (you\u2019ll see a ProvisioningFailed event when you use\nkubectl describe on the PVC).\nEXAMINING THE CREATED PVC AND THE DYNAMICALLY PROVISIONED PV\nNext you\u2019ll create the PVC and then use kubectl get to see it:\n$ kubectl get pvc mongodb-pvc\nNAME          STATUS   VOLUME         CAPACITY   ACCESSMODES   STORAGECLASS\nmongodb-pvc   Bound    pvc-1e6bc048   1Gi        RWO           fast \nThe VOLUME column shows the PersistentVolume that\u2019s bound to this claim (the actual\nname is longer than what\u2019s shown above). You can try listing PersistentVolumes now to\nsee that a new PV has indeed been created automatically:\n$ kubectl get pv\nNAME           CAPACITY  ACCESSMODES  RECLAIMPOLICY  STATUS    STORAGECLASS   \nmongodb-pv     1Gi       RWO,ROX      Retain         Released \npvc-1e6bc048   1Gi       RWO          Delete         Bound     fast\nNOTE\nOnly pertinent columns are shown.\nYou can see the dynamically provisioned PersistentVolume. Its capacity and access\nmodes are what you requested in the PVC. Its reclaim policy is Delete, which means\nthe PersistentVolume will be deleted when the PVC is deleted. Beside the PV, the pro-\nvisioner also provisioned the actual storage. Your fast StorageClass is configured to\nuse the kubernetes.io/gce-pd provisioner, which provisions GCE Persistent Disks.\nYou can see the disk with the following command:\n$ gcloud compute disks list\nNAME                          ZONE            SIZE_GB  TYPE         STATUS\ngke-kubia-dyn-pvc-1e6bc048    europe-west1-d  1        pd-ssd       READY\ngke-kubia-default-pool-71df   europe-west1-d  100      pd-standard  READY\ngke-kubia-default-pool-79cd   europe-west1-d  100      pd-standard  READY\ngke-kubia-default-pool-blc4   europe-west1-d  100      pd-standard  READY\nmongodb                       europe-west1-d  1        pd-standard  READY\nThis PVC requests the \ncustom storage class.\n \n", "shape": "dot", "size": 10, "title": "186\nCHAPTER 6\nVolumes: attaching disk storage to containers\nspec:\n  storageClassName: fast     \n  resources:\n    requests:\n      storage: 100Mi\n  accessModes:\n    - ReadWriteOnce\nApart from specifying the size and access modes, your PersistentVolumeClaim now\nalso specifies the class of storage you want to use. When you create the claim, the\nPersistentVolume is created by the provisioner referenced in the fast StorageClass\nresource. The provisioner is used even if an existing manually provisioned Persistent-\nVolume matches the PersistentVolumeClaim. \nNOTE\nIf you reference a non-existing storage class in a PVC, the provisioning\nof the PV will fail (you\u2019ll see a ProvisioningFailed event when you use\nkubectl describe on the PVC).\nEXAMINING THE CREATED PVC AND THE DYNAMICALLY PROVISIONED PV\nNext you\u2019ll create the PVC and then use kubectl get to see it:\n$ kubectl get pvc mongodb-pvc\nNAME          STATUS   VOLUME         CAPACITY   ACCESSMODES   STORAGECLASS\nmongodb-pvc   Bound    pvc-1e6bc048   1Gi        RWO           fast \nThe VOLUME column shows the PersistentVolume that\u2019s bound to this claim (the actual\nname is longer than what\u2019s shown above). You can try listing PersistentVolumes now to\nsee that a new PV has indeed been created automatically:\n$ kubectl get pv\nNAME           CAPACITY  ACCESSMODES  RECLAIMPOLICY  STATUS    STORAGECLASS   \nmongodb-pv     1Gi       RWO,ROX      Retain         Released \npvc-1e6bc048   1Gi       RWO          Delete         Bound     fast\nNOTE\nOnly pertinent columns are shown.\nYou can see the dynamically provisioned PersistentVolume. Its capacity and access\nmodes are what you requested in the PVC. Its reclaim policy is Delete, which means\nthe PersistentVolume will be deleted when the PVC is deleted. Beside the PV, the pro-\nvisioner also provisioned the actual storage. Your fast StorageClass is configured to\nuse the kubernetes.io/gce-pd provisioner, which provisions GCE Persistent Disks.\nYou can see the disk with the following command:\n$ gcloud compute disks list\nNAME                          ZONE            SIZE_GB  TYPE         STATUS\ngke-kubia-dyn-pvc-1e6bc048    europe-west1-d  1        pd-ssd       READY\ngke-kubia-default-pool-71df   europe-west1-d  100      pd-standard  READY\ngke-kubia-default-pool-79cd   europe-west1-d  100      pd-standard  READY\ngke-kubia-default-pool-blc4   europe-west1-d  100      pd-standard  READY\nmongodb                       europe-west1-d  1        pd-standard  READY\nThis PVC requests the \ncustom storage class.\n \n"}, {"color": "green", "id": "text_130", "label": "187\nDynamic provisioning of PersistentVolumes\nAs you can see, the first persistent disk\u2019s name suggests it was provisioned dynamically\nand its type shows it\u2019s an SSD, as specified in the storage class you created earlier. \nUNDERSTANDING HOW TO USE STORAGE CLASSES\nThe cluster admin can create multiple storage classes with different performance or\nother characteristics. The developer then decides which one is most appropriate for\neach claim they create. \n The nice thing about StorageClasses is the fact that claims refer to them by\nname. The PVC definitions are therefore portable across different clusters, as long\nas the StorageClass names are the same across all of them. To see this portability\nyourself, you can try running the same example on Minikube, if you\u2019ve been using\nGKE up to this point. As a cluster admin, you\u2019ll have to create a different storage\nclass (but with the same name). The storage class defined in the storageclass-fast-\nhostpath.yaml file is tailor-made for use in Minikube. Then, once you deploy the stor-\nage class, you as a cluster user can deploy the exact same PVC manifest and the exact\nsame pod manifest as before. This shows how the pods and PVCs are portable across\ndifferent clusters.\n6.6.3\nDynamic provisioning without specifying a storage class\nAs we\u2019ve progressed through this chapter, attaching persistent storage to pods has\nbecome ever simpler. The sections in this chapter reflect how provisioning of storage\nhas evolved from early Kubernetes versions to now. In this final section, we\u2019ll look at\nthe latest and simplest way of attaching a PersistentVolume to a pod. \nLISTING STORAGE CLASSES\nWhen you created your custom storage class called fast, you didn\u2019t check if any exist-\ning storage classes were already defined in your cluster. Why don\u2019t you do that now?\nHere are the storage classes available in GKE:\n$ kubectl get sc\nNAME                 TYPE\nfast                 kubernetes.io/gce-pd\nstandard (default)   kubernetes.io/gce-pd\nNOTE\nWe\u2019re using sc as shorthand for storageclass.\nBeside the fast storage class, which you created yourself, a standard storage class\nexists and is marked as default. You\u2019ll learn what that means in a moment. Let\u2019s list the\nstorage classes available in Minikube, so we can compare:\n$ kubectl get sc\nNAME                 TYPE\nfast                 k8s.io/minikube-hostpath\nstandard (default)   k8s.io/minikube-hostpath\nAgain, the fast storage class was created by you and a default standard storage class\nexists here as well. Comparing the TYPE columns in the two listings, you see GKE is\n \n", "shape": "dot", "size": 10, "title": "187\nDynamic provisioning of PersistentVolumes\nAs you can see, the first persistent disk\u2019s name suggests it was provisioned dynamically\nand its type shows it\u2019s an SSD, as specified in the storage class you created earlier. \nUNDERSTANDING HOW TO USE STORAGE CLASSES\nThe cluster admin can create multiple storage classes with different performance or\nother characteristics. The developer then decides which one is most appropriate for\neach claim they create. \n The nice thing about StorageClasses is the fact that claims refer to them by\nname. The PVC definitions are therefore portable across different clusters, as long\nas the StorageClass names are the same across all of them. To see this portability\nyourself, you can try running the same example on Minikube, if you\u2019ve been using\nGKE up to this point. As a cluster admin, you\u2019ll have to create a different storage\nclass (but with the same name). The storage class defined in the storageclass-fast-\nhostpath.yaml file is tailor-made for use in Minikube. Then, once you deploy the stor-\nage class, you as a cluster user can deploy the exact same PVC manifest and the exact\nsame pod manifest as before. This shows how the pods and PVCs are portable across\ndifferent clusters.\n6.6.3\nDynamic provisioning without specifying a storage class\nAs we\u2019ve progressed through this chapter, attaching persistent storage to pods has\nbecome ever simpler. The sections in this chapter reflect how provisioning of storage\nhas evolved from early Kubernetes versions to now. In this final section, we\u2019ll look at\nthe latest and simplest way of attaching a PersistentVolume to a pod. \nLISTING STORAGE CLASSES\nWhen you created your custom storage class called fast, you didn\u2019t check if any exist-\ning storage classes were already defined in your cluster. Why don\u2019t you do that now?\nHere are the storage classes available in GKE:\n$ kubectl get sc\nNAME                 TYPE\nfast                 kubernetes.io/gce-pd\nstandard (default)   kubernetes.io/gce-pd\nNOTE\nWe\u2019re using sc as shorthand for storageclass.\nBeside the fast storage class, which you created yourself, a standard storage class\nexists and is marked as default. You\u2019ll learn what that means in a moment. Let\u2019s list the\nstorage classes available in Minikube, so we can compare:\n$ kubectl get sc\nNAME                 TYPE\nfast                 k8s.io/minikube-hostpath\nstandard (default)   k8s.io/minikube-hostpath\nAgain, the fast storage class was created by you and a default standard storage class\nexists here as well. Comparing the TYPE columns in the two listings, you see GKE is\n \n"}, {"color": "green", "id": "text_131", "label": "188\nCHAPTER 6\nVolumes: attaching disk storage to containers\nusing the kubernetes.io/gce-pd provisioner, whereas Minikube is using k8s.io/\nminikube-hostpath. \nEXAMINING THE DEFAULT STORAGE CLASS\nYou\u2019re going to use kubectl get to see more info about the standard storage class in a\nGKE cluster, as shown in the following listing.\n$ kubectl get sc standard -o yaml\napiVersion: storage.k8s.io/v1\nkind: StorageClass\nmetadata:\n  annotations:\n    storageclass.beta.kubernetes.io/is-default-class: \"true\"   \n  creationTimestamp: 2017-05-16T15:24:11Z\n  labels:\n    addonmanager.kubernetes.io/mode: EnsureExists\n    kubernetes.io/cluster-service: \"true\"\n  name: standard\n  resourceVersion: \"180\"\n  selfLink: /apis/storage.k8s.io/v1/storageclassesstandard\n  uid: b6498511-3a4b-11e7-ba2c-42010a840014\nparameters:                                    \n  type: pd-standard                            \nprovisioner: kubernetes.io/gce-pd      \nIf you look closely toward the top of the listing, the storage class definition includes an\nannotation, which makes this the default storage class. The default storage class is\nwhat\u2019s used to dynamically provision a PersistentVolume if the PersistentVolumeClaim\ndoesn\u2019t explicitly say which storage class to use. \nCREATING A PERSISTENTVOLUMECLAIM WITHOUT SPECIFYING A STORAGE CLASS\nYou can create a PVC without specifying the storageClassName attribute and (on\nGoogle Kubernetes Engine) a GCE Persistent Disk of type pd-standard will be provi-\nsioned for you. Try this by creating a claim from the YAML in the following listing.\napiVersion: v1\nkind: PersistentVolumeClaim\nmetadata:\n  name: mongodb-pvc2\nspec:                        \n  resources:                 \n    requests:                \n      storage: 100Mi         \n  accessModes:               \n    - ReadWriteOnce          \nListing 6.16\nThe definition of the standard storage class on GKE\nListing 6.17\nPVC with no storage class defined: mongodb-pvc-dp-nostorageclass.yaml\nThis annotation \nmarks the storage \nclass as default.\nThe type parameter is used by the provisioner \nto know what type of GCE PD to create.\nThe GCE Persistent Disk provisioner \nis used to provision PVs of this class.\nYou\u2019re not specifying \nthe storageClassName \nattribute (unlike earlier \nexamples).\n \n", "shape": "dot", "size": 10, "title": "188\nCHAPTER 6\nVolumes: attaching disk storage to containers\nusing the kubernetes.io/gce-pd provisioner, whereas Minikube is using k8s.io/\nminikube-hostpath. \nEXAMINING THE DEFAULT STORAGE CLASS\nYou\u2019re going to use kubectl get to see more info about the standard storage class in a\nGKE cluster, as shown in the following listing.\n$ kubectl get sc standard -o yaml\napiVersion: storage.k8s.io/v1\nkind: StorageClass\nmetadata:\n  annotations:\n    storageclass.beta.kubernetes.io/is-default-class: \"true\"   \n  creationTimestamp: 2017-05-16T15:24:11Z\n  labels:\n    addonmanager.kubernetes.io/mode: EnsureExists\n    kubernetes.io/cluster-service: \"true\"\n  name: standard\n  resourceVersion: \"180\"\n  selfLink: /apis/storage.k8s.io/v1/storageclassesstandard\n  uid: b6498511-3a4b-11e7-ba2c-42010a840014\nparameters:                                    \n  type: pd-standard                            \nprovisioner: kubernetes.io/gce-pd      \nIf you look closely toward the top of the listing, the storage class definition includes an\nannotation, which makes this the default storage class. The default storage class is\nwhat\u2019s used to dynamically provision a PersistentVolume if the PersistentVolumeClaim\ndoesn\u2019t explicitly say which storage class to use. \nCREATING A PERSISTENTVOLUMECLAIM WITHOUT SPECIFYING A STORAGE CLASS\nYou can create a PVC without specifying the storageClassName attribute and (on\nGoogle Kubernetes Engine) a GCE Persistent Disk of type pd-standard will be provi-\nsioned for you. Try this by creating a claim from the YAML in the following listing.\napiVersion: v1\nkind: PersistentVolumeClaim\nmetadata:\n  name: mongodb-pvc2\nspec:                        \n  resources:                 \n    requests:                \n      storage: 100Mi         \n  accessModes:               \n    - ReadWriteOnce          \nListing 6.16\nThe definition of the standard storage class on GKE\nListing 6.17\nPVC with no storage class defined: mongodb-pvc-dp-nostorageclass.yaml\nThis annotation \nmarks the storage \nclass as default.\nThe type parameter is used by the provisioner \nto know what type of GCE PD to create.\nThe GCE Persistent Disk provisioner \nis used to provision PVs of this class.\nYou\u2019re not specifying \nthe storageClassName \nattribute (unlike earlier \nexamples).\n \n"}, {"color": "green", "id": "text_132", "label": "189\nDynamic provisioning of PersistentVolumes\nThis PVC definition includes only the storage size request and the desired access\nmodes, but no storage class. When you create the PVC, whatever storage class is\nmarked as default will be used. You can confirm that\u2019s the case:\n$ kubectl get pvc mongodb-pvc2\nNAME          STATUS   VOLUME         CAPACITY   ACCESSMODES   STORAGECLASS\nmongodb-pvc2  Bound    pvc-95a5ec12   1Gi        RWO           standard\n$ kubectl get pv pvc-95a5ec12\nNAME           CAPACITY  ACCESSMODES  RECLAIMPOLICY  STATUS    STORAGECLASS   \npvc-95a5ec12   1Gi       RWO          Delete         Bound     standard\n$ gcloud compute disks list\nNAME                          ZONE            SIZE_GB  TYPE         STATUS\ngke-kubia-dyn-pvc-95a5ec12    europe-west1-d  1        pd-standard  READY\n...\nFORCING A PERSISTENTVOLUMECLAIM TO BE BOUND TO ONE OF THE PRE-PROVISIONED \nPERSISTENTVOLUMES\nThis finally brings us to why you set storageClassName to an empty string in listing 6.11\n(when you wanted the PVC to bind to the PV you\u2019d provisioned manually). Let me\nrepeat the relevant lines of that PVC definition here:\nkind: PersistentVolumeClaim\nspec:\n  storageClassName: \"\"       \nIf you hadn\u2019t set the storageClassName attribute to an empty string, the dynamic vol-\nume provisioner would have provisioned a new PersistentVolume, despite there being\nan appropriate pre-provisioned PersistentVolume. At that point, I wanted to demon-\nstrate how a claim gets bound to a manually pre-provisioned PersistentVolume. I didn\u2019t\nwant the dynamic provisioner to interfere. \nTIP\nExplicitly set storageClassName to \"\" if you want the PVC to use a pre-\nprovisioned PersistentVolume.\nUNDERSTANDING THE COMPLETE PICTURE OF DYNAMIC PERSISTENTVOLUME PROVISIONING\nThis brings us to the end of this chapter. To summarize, the best way to attach per-\nsistent storage to a pod is to only create the PVC (with an explicitly specified storage-\nClassName if necessary) and the pod (which refers to the PVC by name). Everything\nelse is taken care of by the dynamic PersistentVolume provisioner.\n To get a complete picture of the steps involved in getting a dynamically provi-\nsioned PersistentVolume, examine figure 6.10.\n \n \n \nSpecifying an empty string as the storage class \nname ensures the PVC binds to a pre-provisioned \nPV instead of dynamically provisioning a new one.\n \n", "shape": "dot", "size": 10, "title": "189\nDynamic provisioning of PersistentVolumes\nThis PVC definition includes only the storage size request and the desired access\nmodes, but no storage class. When you create the PVC, whatever storage class is\nmarked as default will be used. You can confirm that\u2019s the case:\n$ kubectl get pvc mongodb-pvc2\nNAME          STATUS   VOLUME         CAPACITY   ACCESSMODES   STORAGECLASS\nmongodb-pvc2  Bound    pvc-95a5ec12   1Gi        RWO           standard\n$ kubectl get pv pvc-95a5ec12\nNAME           CAPACITY  ACCESSMODES  RECLAIMPOLICY  STATUS    STORAGECLASS   \npvc-95a5ec12   1Gi       RWO          Delete         Bound     standard\n$ gcloud compute disks list\nNAME                          ZONE            SIZE_GB  TYPE         STATUS\ngke-kubia-dyn-pvc-95a5ec12    europe-west1-d  1        pd-standard  READY\n...\nFORCING A PERSISTENTVOLUMECLAIM TO BE BOUND TO ONE OF THE PRE-PROVISIONED \nPERSISTENTVOLUMES\nThis finally brings us to why you set storageClassName to an empty string in listing 6.11\n(when you wanted the PVC to bind to the PV you\u2019d provisioned manually). Let me\nrepeat the relevant lines of that PVC definition here:\nkind: PersistentVolumeClaim\nspec:\n  storageClassName: \"\"       \nIf you hadn\u2019t set the storageClassName attribute to an empty string, the dynamic vol-\nume provisioner would have provisioned a new PersistentVolume, despite there being\nan appropriate pre-provisioned PersistentVolume. At that point, I wanted to demon-\nstrate how a claim gets bound to a manually pre-provisioned PersistentVolume. I didn\u2019t\nwant the dynamic provisioner to interfere. \nTIP\nExplicitly set storageClassName to \"\" if you want the PVC to use a pre-\nprovisioned PersistentVolume.\nUNDERSTANDING THE COMPLETE PICTURE OF DYNAMIC PERSISTENTVOLUME PROVISIONING\nThis brings us to the end of this chapter. To summarize, the best way to attach per-\nsistent storage to a pod is to only create the PVC (with an explicitly specified storage-\nClassName if necessary) and the pod (which refers to the PVC by name). Everything\nelse is taken care of by the dynamic PersistentVolume provisioner.\n To get a complete picture of the steps involved in getting a dynamically provi-\nsioned PersistentVolume, examine figure 6.10.\n \n \n \nSpecifying an empty string as the storage class \nname ensures the PVC binds to a pre-provisioned \nPV instead of dynamically provisioning a new one.\n \n"}, {"color": "green", "id": "text_133", "label": "190\nCHAPTER 6\nVolumes: attaching disk storage to containers\n6.7\nSummary\nThis chapter has shown you how volumes are used to provide either temporary or per-\nsistent storage to a pod\u2019s containers. You\u2019ve learned how to\n\uf0a1Create a multi-container pod and have the pod\u2019s containers operate on the\nsame files by adding a volume to the pod and mounting it in each container\n\uf0a1Use the emptyDir volume to store temporary, non-persistent data\n\uf0a1Use the gitRepo volume to easily populate a directory with the contents of a Git\nrepository at pod startup\n\uf0a1Use the hostPath volume to access files from the host node\n\uf0a1Mount external storage in a volume to persist pod data across pod restarts\n\uf0a1Decouple the pod from the storage infrastructure by using PersistentVolumes\nand PersistentVolumeClaims\n\uf0a1Have PersistentVolumes of the desired (or the default) storage class dynami-\ncally provisioned for each PersistentVolumeClaim\n\uf0a1Prevent the dynamic provisioner from interfering when you want the Persistent-\nVolumeClaim to be bound to a pre-provisioned PersistentVolume\nIn the next chapter, you\u2019ll see what mechanisms Kubernetes provides to deliver con-\nfiguration data, secret information, and metadata about the pod and container to the\nprocesses running inside a pod. This is done with the special types of volumes we\u2019ve\nmentioned in this chapter, but not yet explored.\nPod\nAdmin\nVolume\n1. Cluster admin sets up a PersistentVolume\nprovisioner (if one\u2019s not already deployed)\n2. Admin creates one or\nmore StorageClasses\nand marks one as the\ndefault (it may already\nexist)\nActual\nstorage\nPersistent\nVolume\nUser\nPersistent\nVolume\nprovisioner\nPersistent\nVolumeClaim\nStorage\nClass\n3. User creates a PVC referencing one of the\nStorageClasses (or none to use the default)\n6. User creates a pod with\na volume referencing the\nPVC by name\n4. Kubernetes looks up the\nStorageClass and the provisioner\nreferenced in it and asks the provisioner\nto provision a new PV based on the\nPVC\u2019s requested access mode and\nstorage size and the parameters\nin the StorageClass\n5. Provisioner provisions the\nactual storage, creates\na PersistentVolume, and\nbinds it to the PVC\nFigure 6.10\nThe complete picture of dynamic provisioning of PersistentVolumes\n \n", "shape": "dot", "size": 10, "title": "190\nCHAPTER 6\nVolumes: attaching disk storage to containers\n6.7\nSummary\nThis chapter has shown you how volumes are used to provide either temporary or per-\nsistent storage to a pod\u2019s containers. You\u2019ve learned how to\n\uf0a1Create a multi-container pod and have the pod\u2019s containers operate on the\nsame files by adding a volume to the pod and mounting it in each container\n\uf0a1Use the emptyDir volume to store temporary, non-persistent data\n\uf0a1Use the gitRepo volume to easily populate a directory with the contents of a Git\nrepository at pod startup\n\uf0a1Use the hostPath volume to access files from the host node\n\uf0a1Mount external storage in a volume to persist pod data across pod restarts\n\uf0a1Decouple the pod from the storage infrastructure by using PersistentVolumes\nand PersistentVolumeClaims\n\uf0a1Have PersistentVolumes of the desired (or the default) storage class dynami-\ncally provisioned for each PersistentVolumeClaim\n\uf0a1Prevent the dynamic provisioner from interfering when you want the Persistent-\nVolumeClaim to be bound to a pre-provisioned PersistentVolume\nIn the next chapter, you\u2019ll see what mechanisms Kubernetes provides to deliver con-\nfiguration data, secret information, and metadata about the pod and container to the\nprocesses running inside a pod. This is done with the special types of volumes we\u2019ve\nmentioned in this chapter, but not yet explored.\nPod\nAdmin\nVolume\n1. Cluster admin sets up a PersistentVolume\nprovisioner (if one\u2019s not already deployed)\n2. Admin creates one or\nmore StorageClasses\nand marks one as the\ndefault (it may already\nexist)\nActual\nstorage\nPersistent\nVolume\nUser\nPersistent\nVolume\nprovisioner\nPersistent\nVolumeClaim\nStorage\nClass\n3. User creates a PVC referencing one of the\nStorageClasses (or none to use the default)\n6. User creates a pod with\na volume referencing the\nPVC by name\n4. Kubernetes looks up the\nStorageClass and the provisioner\nreferenced in it and asks the provisioner\nto provision a new PV based on the\nPVC\u2019s requested access mode and\nstorage size and the parameters\nin the StorageClass\n5. Provisioner provisions the\nactual storage, creates\na PersistentVolume, and\nbinds it to the PVC\nFigure 6.10\nThe complete picture of dynamic provisioning of PersistentVolumes\n \n"}, {"color": "green", "id": "text_134", "label": "191\nConfigMaps and Secrets:\nconfiguring applications\nUp to now you haven\u2019t had to pass any kind of configuration data to the apps you\u2019ve\nrun in the exercises in this book. Because almost all apps require configuration (set-\ntings that differ between deployed instances, credentials for accessing external sys-\ntems, and so on), which shouldn\u2019t be baked into the built app itself, let\u2019s see how to\npass configuration options to your app when running it in Kubernetes.\n7.1\nConfiguring containerized applications\nBefore we go over how to pass configuration data to apps running in Kubernetes,\nlet\u2019s look at how containerized applications are usually configured.\n If you skip the fact that you can bake the configuration into the application\nitself, when starting development of a new app, you usually start off by having the\nThis chapter covers\n\uf0a1Changing the main process of a container\n\uf0a1Passing command-line options to the app\n\uf0a1Setting environment variables exposed to the app\n\uf0a1Configuring apps through ConfigMaps\n\uf0a1Passing sensitive information through Secrets\n \n", "shape": "dot", "size": 10, "title": "191\nConfigMaps and Secrets:\nconfiguring applications\nUp to now you haven\u2019t had to pass any kind of configuration data to the apps you\u2019ve\nrun in the exercises in this book. Because almost all apps require configuration (set-\ntings that differ between deployed instances, credentials for accessing external sys-\ntems, and so on), which shouldn\u2019t be baked into the built app itself, let\u2019s see how to\npass configuration options to your app when running it in Kubernetes.\n7.1\nConfiguring containerized applications\nBefore we go over how to pass configuration data to apps running in Kubernetes,\nlet\u2019s look at how containerized applications are usually configured.\n If you skip the fact that you can bake the configuration into the application\nitself, when starting development of a new app, you usually start off by having the\nThis chapter covers\n\uf0a1Changing the main process of a container\n\uf0a1Passing command-line options to the app\n\uf0a1Setting environment variables exposed to the app\n\uf0a1Configuring apps through ConfigMaps\n\uf0a1Passing sensitive information through Secrets\n \n"}, {"color": "green", "id": "text_135", "label": "192\nCHAPTER 7\nConfigMaps and Secrets: configuring applications\napp configured through command-line arguments. Then, as the list of configuration\noptions grows, you can move the configuration into a config file. \n Another way of passing configuration options to an application that\u2019s widely popu-\nlar in containerized applications is through environment variables. Instead of having\nthe app read a config file or command-line arguments, the app looks up the value of a\ncertain environment variable. The official MySQL container image, for example, uses\nan environment variable called MYSQL_ROOT_PASSWORD for setting the password for the\nroot super-user account. \n But why are environment variables so popular in containers? Using configuration\nfiles inside Docker containers is a bit tricky, because you\u2019d have to bake the config file\ninto the container image itself or mount a volume containing the file into the con-\ntainer. Obviously, baking files into the image is similar to hardcoding configuration\ninto the source code of the application, because it requires you to rebuild the image\nevery time you want to change the config. Plus, everyone with access to the image can\nsee the config, including any information that should be kept secret, such as creden-\ntials or encryption keys. Using a volume is better, but still requires you to make sure\nthe file is written to the volume before the container is started. \n If you\u2019ve read the previous chapter, you might think of using a gitRepo volume as\na configuration source. That\u2019s not a bad idea, because it allows you to keep the config\nnicely versioned and enables you to easily rollback a config change if necessary. But a\nsimpler way allows you to put the configuration data into a top-level Kubernetes\nresource and store it and all the other resource definitions in the same Git repository\nor in any other file-based storage. The Kubernetes resource for storing configuration\ndata is called a ConfigMap. We\u2019ll learn how to use it in this chapter.\n Regardless if you\u2019re using a ConfigMap to store configuration data or not, you can\nconfigure your apps by\n\uf0a1Passing command-line arguments to containers\n\uf0a1Setting custom environment variables for each container\n\uf0a1Mounting configuration files into containers through a special type of volume\nWe\u2019ll go over all these options in the next few sections, but before we start, let\u2019s look\nat config options from a security perspective. Though most configuration options\ndon\u2019t contain any sensitive information, several can. These include credentials, pri-\nvate encryption keys, and similar data that needs to be kept secure. This type of infor-\nmation needs to be handled with special care, which is why Kubernetes offers\nanother type of first-class object called a Secret. We\u2019ll learn about it in the last part of\nthis chapter.\n7.2\nPassing command-line arguments to containers\nIn all the examples so far, you\u2019ve created containers that ran the default command\ndefined in the container image, but Kubernetes allows overriding the command as\npart of the pod\u2019s container definition when you want to run a different executable\n \n", "shape": "dot", "size": 10, "title": "192\nCHAPTER 7\nConfigMaps and Secrets: configuring applications\napp configured through command-line arguments. Then, as the list of configuration\noptions grows, you can move the configuration into a config file. \n Another way of passing configuration options to an application that\u2019s widely popu-\nlar in containerized applications is through environment variables. Instead of having\nthe app read a config file or command-line arguments, the app looks up the value of a\ncertain environment variable. The official MySQL container image, for example, uses\nan environment variable called MYSQL_ROOT_PASSWORD for setting the password for the\nroot super-user account. \n But why are environment variables so popular in containers? Using configuration\nfiles inside Docker containers is a bit tricky, because you\u2019d have to bake the config file\ninto the container image itself or mount a volume containing the file into the con-\ntainer. Obviously, baking files into the image is similar to hardcoding configuration\ninto the source code of the application, because it requires you to rebuild the image\nevery time you want to change the config. Plus, everyone with access to the image can\nsee the config, including any information that should be kept secret, such as creden-\ntials or encryption keys. Using a volume is better, but still requires you to make sure\nthe file is written to the volume before the container is started. \n If you\u2019ve read the previous chapter, you might think of using a gitRepo volume as\na configuration source. That\u2019s not a bad idea, because it allows you to keep the config\nnicely versioned and enables you to easily rollback a config change if necessary. But a\nsimpler way allows you to put the configuration data into a top-level Kubernetes\nresource and store it and all the other resource definitions in the same Git repository\nor in any other file-based storage. The Kubernetes resource for storing configuration\ndata is called a ConfigMap. We\u2019ll learn how to use it in this chapter.\n Regardless if you\u2019re using a ConfigMap to store configuration data or not, you can\nconfigure your apps by\n\uf0a1Passing command-line arguments to containers\n\uf0a1Setting custom environment variables for each container\n\uf0a1Mounting configuration files into containers through a special type of volume\nWe\u2019ll go over all these options in the next few sections, but before we start, let\u2019s look\nat config options from a security perspective. Though most configuration options\ndon\u2019t contain any sensitive information, several can. These include credentials, pri-\nvate encryption keys, and similar data that needs to be kept secure. This type of infor-\nmation needs to be handled with special care, which is why Kubernetes offers\nanother type of first-class object called a Secret. We\u2019ll learn about it in the last part of\nthis chapter.\n7.2\nPassing command-line arguments to containers\nIn all the examples so far, you\u2019ve created containers that ran the default command\ndefined in the container image, but Kubernetes allows overriding the command as\npart of the pod\u2019s container definition when you want to run a different executable\n \n"}, {"color": "green", "id": "text_136", "label": "193\nPassing command-line arguments to containers\ninstead of the one specified in the image, or want to run it with a different set of com-\nmand-line arguments. We\u2019ll look at how to do that now.\n7.2.1\nDefining the command and arguments in Docker\nThe first thing I need to explain is that the whole command that gets executed in the\ncontainer is composed of two parts: the command and the arguments. \nUNDERSTANDING ENTRYPOINT AND CMD\nIn a Dockerfile, two instructions define the two parts:\n\uf0a1\nENTRYPOINT defines the executable invoked when the container is started.\n\uf0a1\nCMD specifies the arguments that get passed to the ENTRYPOINT.\nAlthough you can use the CMD instruction to specify the command you want to execute\nwhen the image is run, the correct way is to do it through the ENTRYPOINT instruction\nand to only specify the CMD if you want to define the default arguments. The image can\nthen be run without specifying any arguments\n$ docker run \u003cimage\u003e\nor with additional arguments, which override whatever\u2019s set under CMD in the Dockerfile:\n$ docker run \u003cimage\u003e \u003carguments\u003e\nUNDERSTANDING THE DIFFERENCE BETWEEN THE SHELL AND EXEC FORMS\nBut there\u2019s more. Both instructions support two different forms:\n\uf0a1\nshell form\u2014For example, ENTRYPOINT node app.js.\n\uf0a1\nexec form\u2014For example, ENTRYPOINT [\"node\", \"app.js\"].\nThe difference is whether the specified command is invoked inside a shell or not. \n In the kubia image you created in chapter 2, you used the exec form of the ENTRY-\nPOINT instruction: \nENTRYPOINT [\"node\", \"app.js\"]\nThis runs the node process directly (not inside a shell), as you can see by listing the\nprocesses running inside the container:\n$ docker exec 4675d ps x\n  PID TTY      STAT   TIME COMMAND\n    1 ?        Ssl    0:00 node app.js\n   12 ?        Rs     0:00 ps x\nIf you\u2019d used the shell form (ENTRYPOINT node app.js), these would have been the\ncontainer\u2019s processes:\n$ docker exec -it e4bad ps x\n  PID TTY      STAT   TIME COMMAND\n    1 ?        Ss     0:00 /bin/sh -c node app.js\n \n", "shape": "dot", "size": 10, "title": "193\nPassing command-line arguments to containers\ninstead of the one specified in the image, or want to run it with a different set of com-\nmand-line arguments. We\u2019ll look at how to do that now.\n7.2.1\nDefining the command and arguments in Docker\nThe first thing I need to explain is that the whole command that gets executed in the\ncontainer is composed of two parts: the command and the arguments. \nUNDERSTANDING ENTRYPOINT AND CMD\nIn a Dockerfile, two instructions define the two parts:\n\uf0a1\nENTRYPOINT defines the executable invoked when the container is started.\n\uf0a1\nCMD specifies the arguments that get passed to the ENTRYPOINT.\nAlthough you can use the CMD instruction to specify the command you want to execute\nwhen the image is run, the correct way is to do it through the ENTRYPOINT instruction\nand to only specify the CMD if you want to define the default arguments. The image can\nthen be run without specifying any arguments\n$ docker run \u003cimage\u003e\nor with additional arguments, which override whatever\u2019s set under CMD in the Dockerfile:\n$ docker run \u003cimage\u003e \u003carguments\u003e\nUNDERSTANDING THE DIFFERENCE BETWEEN THE SHELL AND EXEC FORMS\nBut there\u2019s more. Both instructions support two different forms:\n\uf0a1\nshell form\u2014For example, ENTRYPOINT node app.js.\n\uf0a1\nexec form\u2014For example, ENTRYPOINT [\"node\", \"app.js\"].\nThe difference is whether the specified command is invoked inside a shell or not. \n In the kubia image you created in chapter 2, you used the exec form of the ENTRY-\nPOINT instruction: \nENTRYPOINT [\"node\", \"app.js\"]\nThis runs the node process directly (not inside a shell), as you can see by listing the\nprocesses running inside the container:\n$ docker exec 4675d ps x\n  PID TTY      STAT   TIME COMMAND\n    1 ?        Ssl    0:00 node app.js\n   12 ?        Rs     0:00 ps x\nIf you\u2019d used the shell form (ENTRYPOINT node app.js), these would have been the\ncontainer\u2019s processes:\n$ docker exec -it e4bad ps x\n  PID TTY      STAT   TIME COMMAND\n    1 ?        Ss     0:00 /bin/sh -c node app.js\n \n"}, {"color": "green", "id": "text_137", "label": "194\nCHAPTER 7\nConfigMaps and Secrets: configuring applications\n    7 ?        Sl     0:00 node app.js\n   13 ?        Rs+    0:00 ps x\nAs you can see, in that case, the main process (PID 1) would be the shell process\ninstead of the node process. The node process (PID 7) would be started from that\nshell. The shell process is unnecessary, which is why you should always use the exec\nform of the ENTRYPOINT instruction.\nMAKING THE INTERVAL CONFIGURABLE IN YOUR FORTUNE IMAGE\nLet\u2019s modify your fortune script and image so the delay interval in the loop is configu-\nrable. You\u2019ll add an INTERVAL variable and initialize it with the value of the first com-\nmand-line argument, as shown in the following listing.\n#!/bin/bash\ntrap \"exit\" SIGINT\nINTERVAL=$1\necho Configured to generate new fortune every $INTERVAL seconds\nmkdir -p /var/htdocs\nwhile :\ndo\n  echo $(date) Writing fortune to /var/htdocs/index.html\n  /usr/games/fortune \u003e /var/htdocs/index.html\n  sleep $INTERVAL\ndone\nYou\u2019ve added or modified the lines in bold font. Now, you\u2019ll modify the Dockerfile so\nit uses the exec version of the ENTRYPOINT instruction and sets the default interval to\n10 seconds using the CMD instruction, as shown in the following listing.\nFROM ubuntu:latest\nRUN apt-get update ; apt-get -y install fortune\nADD fortuneloop.sh /bin/fortuneloop.sh\nENTRYPOINT [\"/bin/fortuneloop.sh\"]        \nCMD [\"10\"]                                \nYou can now build and push the image to Docker Hub. This time, you\u2019ll tag the image\nas args instead of latest:\n$ docker build -t docker.io/luksa/fortune:args .\n$ docker push docker.io/luksa/fortune:args\nYou can test the image by running it locally with Docker:\n$ docker run -it docker.io/luksa/fortune:args\nConfigured to generate new fortune every 10 seconds\nFri May 19 10:39:44 UTC 2017 Writing fortune to /var/htdocs/index.html\nListing 7.1\nFortune script with interval configurable through argument: fortune-args/\nfortuneloop.sh\nListing 7.2\nDockerfile for the updated fortune image: fortune-args/Dockerfile\nThe exec form of the \nENTRYPOINT instruction\nThe default argument \nfor the executable\n \n", "shape": "dot", "size": 10, "title": "194\nCHAPTER 7\nConfigMaps and Secrets: configuring applications\n    7 ?        Sl     0:00 node app.js\n   13 ?        Rs+    0:00 ps x\nAs you can see, in that case, the main process (PID 1) would be the shell process\ninstead of the node process. The node process (PID 7) would be started from that\nshell. The shell process is unnecessary, which is why you should always use the exec\nform of the ENTRYPOINT instruction.\nMAKING THE INTERVAL CONFIGURABLE IN YOUR FORTUNE IMAGE\nLet\u2019s modify your fortune script and image so the delay interval in the loop is configu-\nrable. You\u2019ll add an INTERVAL variable and initialize it with the value of the first com-\nmand-line argument, as shown in the following listing.\n#!/bin/bash\ntrap \"exit\" SIGINT\nINTERVAL=$1\necho Configured to generate new fortune every $INTERVAL seconds\nmkdir -p /var/htdocs\nwhile :\ndo\n  echo $(date) Writing fortune to /var/htdocs/index.html\n  /usr/games/fortune \u003e /var/htdocs/index.html\n  sleep $INTERVAL\ndone\nYou\u2019ve added or modified the lines in bold font. Now, you\u2019ll modify the Dockerfile so\nit uses the exec version of the ENTRYPOINT instruction and sets the default interval to\n10 seconds using the CMD instruction, as shown in the following listing.\nFROM ubuntu:latest\nRUN apt-get update ; apt-get -y install fortune\nADD fortuneloop.sh /bin/fortuneloop.sh\nENTRYPOINT [\"/bin/fortuneloop.sh\"]        \nCMD [\"10\"]                                \nYou can now build and push the image to Docker Hub. This time, you\u2019ll tag the image\nas args instead of latest:\n$ docker build -t docker.io/luksa/fortune:args .\n$ docker push docker.io/luksa/fortune:args\nYou can test the image by running it locally with Docker:\n$ docker run -it docker.io/luksa/fortune:args\nConfigured to generate new fortune every 10 seconds\nFri May 19 10:39:44 UTC 2017 Writing fortune to /var/htdocs/index.html\nListing 7.1\nFortune script with interval configurable through argument: fortune-args/\nfortuneloop.sh\nListing 7.2\nDockerfile for the updated fortune image: fortune-args/Dockerfile\nThe exec form of the \nENTRYPOINT instruction\nThe default argument \nfor the executable\n \n"}, {"color": "green", "id": "text_138", "label": "195\nPassing command-line arguments to containers\nNOTE\nYou can stop the script with Control+C.\nAnd you can override the default sleep interval by passing it as an argument:\n$ docker run -it docker.io/luksa/fortune:args 15\nConfigured to generate new fortune every 15 seconds\nNow that you\u2019re sure your image honors the argument passed to it, let\u2019s see how to use\nit in a pod.\n7.2.2\nOverriding the command and arguments in Kubernetes\nIn Kubernetes, when specifying a container, you can choose to override both ENTRY-\nPOINT and CMD. To do that, you set the properties command and args in the container\nspecification, as shown in the following listing.\nkind: Pod\nspec:\n  containers:\n  - image: some/image\n    command: [\"/bin/command\"]\n    args: [\"arg1\", \"arg2\", \"arg3\"]\nIn most cases, you\u2019ll only set custom arguments and rarely override the command\n(except in general-purpose images such as busybox, which doesn\u2019t define an ENTRY-\nPOINT at all). \nNOTE\nThe command and args fields can\u2019t be updated after the pod is created.\nThe two Dockerfile instructions and the equivalent pod spec fields are shown in table 7.1.\nRUNNING THE FORTUNE POD WITH A CUSTOM INTERVAL\nTo run the fortune pod with a custom delay interval, you\u2019ll copy your fortune-\npod.yaml into fortune-pod-args.yaml and modify it as shown in the following listing.\napiVersion: v1\nkind: Pod\nmetadata:\n  name: fortune2s        \nListing 7.3\nA pod definition specifying a custom command and arguments\nTable 7.1\nSpecifying the executable and its arguments in Docker vs Kubernetes\nDocker\nKubernetes\nDescription\nENTRYPOINT\ncommand\nThe executable that\u2019s executed inside the container\nCMD\nargs\nThe arguments passed to the executable\nListing 7.4\nPassing an argument in the pod definition: fortune-pod-args.yaml\nYou changed the \npod\u2019s name.\n \n", "shape": "dot", "size": 10, "title": "195\nPassing command-line arguments to containers\nNOTE\nYou can stop the script with Control+C.\nAnd you can override the default sleep interval by passing it as an argument:\n$ docker run -it docker.io/luksa/fortune:args 15\nConfigured to generate new fortune every 15 seconds\nNow that you\u2019re sure your image honors the argument passed to it, let\u2019s see how to use\nit in a pod.\n7.2.2\nOverriding the command and arguments in Kubernetes\nIn Kubernetes, when specifying a container, you can choose to override both ENTRY-\nPOINT and CMD. To do that, you set the properties command and args in the container\nspecification, as shown in the following listing.\nkind: Pod\nspec:\n  containers:\n  - image: some/image\n    command: [\"/bin/command\"]\n    args: [\"arg1\", \"arg2\", \"arg3\"]\nIn most cases, you\u2019ll only set custom arguments and rarely override the command\n(except in general-purpose images such as busybox, which doesn\u2019t define an ENTRY-\nPOINT at all). \nNOTE\nThe command and args fields can\u2019t be updated after the pod is created.\nThe two Dockerfile instructions and the equivalent pod spec fields are shown in table 7.1.\nRUNNING THE FORTUNE POD WITH A CUSTOM INTERVAL\nTo run the fortune pod with a custom delay interval, you\u2019ll copy your fortune-\npod.yaml into fortune-pod-args.yaml and modify it as shown in the following listing.\napiVersion: v1\nkind: Pod\nmetadata:\n  name: fortune2s        \nListing 7.3\nA pod definition specifying a custom command and arguments\nTable 7.1\nSpecifying the executable and its arguments in Docker vs Kubernetes\nDocker\nKubernetes\nDescription\nENTRYPOINT\ncommand\nThe executable that\u2019s executed inside the container\nCMD\nargs\nThe arguments passed to the executable\nListing 7.4\nPassing an argument in the pod definition: fortune-pod-args.yaml\nYou changed the \npod\u2019s name.\n \n"}, {"color": "green", "id": "text_139", "label": "196\nCHAPTER 7\nConfigMaps and Secrets: configuring applications\nspec:\n  containers:\n  - image: luksa/fortune:args      \n    args: [\"2\"]                  \n    name: html-generator\n    volumeMounts:\n    - name: html\n      mountPath: /var/htdocs\n...\nYou added the args array to the container definition. Try creating this pod now. The\nvalues of the array will be passed to the container as command-line arguments when it\nis run. \n The array notation used in this listing is great if you have one argument or a few. If\nyou have several, you can also use the following notation:\n    args:\n    - foo\n    - bar\n    - \"15\"\nTIP\nYou don\u2019t need to enclose string values in quotations marks (but you\nmust enclose numbers). \nSpecifying arguments is one way of passing config\noptions to your containers through command-\nline arguments. Next, you\u2019ll see how to do it\nthrough environment variables.\n7.3\nSetting environment variables for \na container\nAs I\u2019ve already mentioned, containerized appli-\ncations often use environment variables as a\nsource of configuration options. Kubernetes\nallows you to specify a custom list of environ-\nment variables for each container of a pod, as\nshown in figure 7.1. Although it would be use-\nful to also define environment variables at the\npod level and have them be inherited by its\ncontainers, no such option currently exists.\nNOTE\nLike the container\u2019s command and\narguments, the list of environment variables\nalso cannot be updated after the pod is created.\nUsing fortune:args \ninstead of fortune:latest\nThis argument makes the \nscript generate a new fortune \nevery two seconds.\nPod\nContainer A\nEnvironment variables\nFOO=BAR\nABC=123\nContainer B\nEnvironment variables\nFOO=FOOBAR\nBAR=567\nFigure 7.1\nEnvironment variables can \nbe set per container.\n \n", "shape": "dot", "size": 10, "title": "196\nCHAPTER 7\nConfigMaps and Secrets: configuring applications\nspec:\n  containers:\n  - image: luksa/fortune:args      \n    args: [\"2\"]                  \n    name: html-generator\n    volumeMounts:\n    - name: html\n      mountPath: /var/htdocs\n...\nYou added the args array to the container definition. Try creating this pod now. The\nvalues of the array will be passed to the container as command-line arguments when it\nis run. \n The array notation used in this listing is great if you have one argument or a few. If\nyou have several, you can also use the following notation:\n    args:\n    - foo\n    - bar\n    - \"15\"\nTIP\nYou don\u2019t need to enclose string values in quotations marks (but you\nmust enclose numbers). \nSpecifying arguments is one way of passing config\noptions to your containers through command-\nline arguments. Next, you\u2019ll see how to do it\nthrough environment variables.\n7.3\nSetting environment variables for \na container\nAs I\u2019ve already mentioned, containerized appli-\ncations often use environment variables as a\nsource of configuration options. Kubernetes\nallows you to specify a custom list of environ-\nment variables for each container of a pod, as\nshown in figure 7.1. Although it would be use-\nful to also define environment variables at the\npod level and have them be inherited by its\ncontainers, no such option currently exists.\nNOTE\nLike the container\u2019s command and\narguments, the list of environment variables\nalso cannot be updated after the pod is created.\nUsing fortune:args \ninstead of fortune:latest\nThis argument makes the \nscript generate a new fortune \nevery two seconds.\nPod\nContainer A\nEnvironment variables\nFOO=BAR\nABC=123\nContainer B\nEnvironment variables\nFOO=FOOBAR\nBAR=567\nFigure 7.1\nEnvironment variables can \nbe set per container.\n \n"}, {"color": "green", "id": "text_140", "label": "197\nSetting environment variables for a container\nMAKING THE INTERVAL IN YOUR FORTUNE IMAGE CONFIGURABLE THROUGH AN ENVIRONMENT VARIABLE\nLet\u2019s see how to modify your fortuneloop.sh script once again to allow it to be config-\nured from an environment variable, as shown in the following listing.\n#!/bin/bash\ntrap \"exit\" SIGINT\necho Configured to generate new fortune every $INTERVAL seconds\nmkdir -p /var/htdocs\nwhile :\ndo\n  echo $(date) Writing fortune to /var/htdocs/index.html\n  /usr/games/fortune \u003e /var/htdocs/index.html\n  sleep $INTERVAL\ndone\nAll you had to do was remove the row where the INTERVAL variable is initialized. Because\nyour \u201capp\u201d is a simple bash script, you didn\u2019t need to do anything else. If the app was\nwritten in Java you\u2019d use System.getenv(\"INTERVAL\"), whereas in Node.JS you\u2019d use\nprocess.env.INTERVAL, and in Python you\u2019d use os.environ[\u0027INTERVAL\u0027].\n7.3.1\nSpecifying environment variables in a container definition\nAfter building the new image (I\u2019ve tagged it as luksa/fortune:env this time) and\npushing it to Docker Hub, you can run it by creating a new pod, in which you pass the\nenvironment variable to the script by including it in your container definition, as\nshown in the following listing.\nkind: Pod\nspec:\n containers:\n - image: luksa/fortune:env\n   env:                        \n   - name: INTERVAL            \n     value: \"30\"               \n   name: html-generator\n...\nAs mentioned previously, you set the environment variable inside the container defini-\ntion, not at the pod level. \nNOTE\nDon\u2019t forget that in each container, Kubernetes also automatically\nexposes environment variables for each service in the same namespace. These\nenvironment variables are basically auto-injected configuration.\nListing 7.5\nFortune script with interval configurable through env var: fortune-env/\nfortuneloop.sh\nListing 7.6\nDefining an environment variable in a pod: fortune-pod-env.yaml\nAdding a single variable to \nthe environment variable list\n \n", "shape": "dot", "size": 10, "title": "197\nSetting environment variables for a container\nMAKING THE INTERVAL IN YOUR FORTUNE IMAGE CONFIGURABLE THROUGH AN ENVIRONMENT VARIABLE\nLet\u2019s see how to modify your fortuneloop.sh script once again to allow it to be config-\nured from an environment variable, as shown in the following listing.\n#!/bin/bash\ntrap \"exit\" SIGINT\necho Configured to generate new fortune every $INTERVAL seconds\nmkdir -p /var/htdocs\nwhile :\ndo\n  echo $(date) Writing fortune to /var/htdocs/index.html\n  /usr/games/fortune \u003e /var/htdocs/index.html\n  sleep $INTERVAL\ndone\nAll you had to do was remove the row where the INTERVAL variable is initialized. Because\nyour \u201capp\u201d is a simple bash script, you didn\u2019t need to do anything else. If the app was\nwritten in Java you\u2019d use System.getenv(\"INTERVAL\"), whereas in Node.JS you\u2019d use\nprocess.env.INTERVAL, and in Python you\u2019d use os.environ[\u0027INTERVAL\u0027].\n7.3.1\nSpecifying environment variables in a container definition\nAfter building the new image (I\u2019ve tagged it as luksa/fortune:env this time) and\npushing it to Docker Hub, you can run it by creating a new pod, in which you pass the\nenvironment variable to the script by including it in your container definition, as\nshown in the following listing.\nkind: Pod\nspec:\n containers:\n - image: luksa/fortune:env\n   env:                        \n   - name: INTERVAL            \n     value: \"30\"               \n   name: html-generator\n...\nAs mentioned previously, you set the environment variable inside the container defini-\ntion, not at the pod level. \nNOTE\nDon\u2019t forget that in each container, Kubernetes also automatically\nexposes environment variables for each service in the same namespace. These\nenvironment variables are basically auto-injected configuration.\nListing 7.5\nFortune script with interval configurable through env var: fortune-env/\nfortuneloop.sh\nListing 7.6\nDefining an environment variable in a pod: fortune-pod-env.yaml\nAdding a single variable to \nthe environment variable list\n \n"}, {"color": "green", "id": "text_141", "label": "198\nCHAPTER 7\nConfigMaps and Secrets: configuring applications\n7.3.2\nReferring to other environment variables in a variable\u2019s value\nIn the previous example, you set a fixed value for the environment variable, but you\ncan also reference previously defined environment variables or any other existing vari-\nables by using the $(VAR) syntax. If you define two environment variables, the second\none can include the value of the first one as shown in the following listing.\nenv:\n- name: FIRST_VAR\n  value: \"foo\"\n- name: SECOND_VAR\n  value: \"$(FIRST_VAR)bar\"\nIn this case, the SECOND_VAR\u2019s value will be \"foobar\". Similarly, both the command and\nargs attributes you learned about in section 7.2 can also refer to environment vari-\nables like this. You\u2019ll use this method in section 7.4.5.\n7.3.3\nUnderstanding the drawback of hardcoding environment \nvariables\nHaving values effectively hardcoded in the pod definition means you need to have\nseparate pod definitions for your production and your development pods. To reuse\nthe same pod definition in multiple environments, it makes sense to decouple the\nconfiguration from the pod descriptor. Luckily, you can do that using a ConfigMap\nresource and using it as a source for environment variable values using the valueFrom\ninstead of the value field. You\u2019ll learn about this next. \n7.4\nDecoupling configuration with a ConfigMap\nThe whole point of an app\u2019s configuration is to keep the config options that vary\nbetween environments, or change frequently, separate from the application\u2019s source\ncode. If you think of a pod descriptor as source code for your app (and in microservices\narchitectures that\u2019s what it really is, because it defines how to compose the individual\ncomponents into a functioning system), it\u2019s clear you should move the configuration\nout of the pod description.\n7.4.1\nIntroducing ConfigMaps\nKubernetes allows separating configuration options into a separate object called a\nConfigMap, which is a map containing key/value pairs with the values ranging from\nshort literals to full config files. \n An application doesn\u2019t need to read the ConfigMap directly or even know that it\nexists. The contents of the map are instead passed to containers as either environ-\nment variables or as files in a volume (see figure 7.2). And because environment\nListing 7.7\nReferring to an environment variable inside another one\n \n", "shape": "dot", "size": 10, "title": "198\nCHAPTER 7\nConfigMaps and Secrets: configuring applications\n7.3.2\nReferring to other environment variables in a variable\u2019s value\nIn the previous example, you set a fixed value for the environment variable, but you\ncan also reference previously defined environment variables or any other existing vari-\nables by using the $(VAR) syntax. If you define two environment variables, the second\none can include the value of the first one as shown in the following listing.\nenv:\n- name: FIRST_VAR\n  value: \"foo\"\n- name: SECOND_VAR\n  value: \"$(FIRST_VAR)bar\"\nIn this case, the SECOND_VAR\u2019s value will be \"foobar\". Similarly, both the command and\nargs attributes you learned about in section 7.2 can also refer to environment vari-\nables like this. You\u2019ll use this method in section 7.4.5.\n7.3.3\nUnderstanding the drawback of hardcoding environment \nvariables\nHaving values effectively hardcoded in the pod definition means you need to have\nseparate pod definitions for your production and your development pods. To reuse\nthe same pod definition in multiple environments, it makes sense to decouple the\nconfiguration from the pod descriptor. Luckily, you can do that using a ConfigMap\nresource and using it as a source for environment variable values using the valueFrom\ninstead of the value field. You\u2019ll learn about this next. \n7.4\nDecoupling configuration with a ConfigMap\nThe whole point of an app\u2019s configuration is to keep the config options that vary\nbetween environments, or change frequently, separate from the application\u2019s source\ncode. If you think of a pod descriptor as source code for your app (and in microservices\narchitectures that\u2019s what it really is, because it defines how to compose the individual\ncomponents into a functioning system), it\u2019s clear you should move the configuration\nout of the pod description.\n7.4.1\nIntroducing ConfigMaps\nKubernetes allows separating configuration options into a separate object called a\nConfigMap, which is a map containing key/value pairs with the values ranging from\nshort literals to full config files. \n An application doesn\u2019t need to read the ConfigMap directly or even know that it\nexists. The contents of the map are instead passed to containers as either environ-\nment variables or as files in a volume (see figure 7.2). And because environment\nListing 7.7\nReferring to an environment variable inside another one\n \n"}, {"color": "green", "id": "text_142", "label": "199\nDecoupling configuration with a ConfigMap\nvariables can be referenced in command-line arguments using the $(ENV_VAR) syn-\ntax, you can also pass ConfigMap entries to processes as command-line arguments.\nSure, the application can also read the contents of a ConfigMap directly through the\nKubernetes REST API endpoint if needed, but unless you have a real need for this,\nyou should keep your app Kubernetes-agnostic as much as possible.\n Regardless of how an app consumes a ConfigMap, having the config in a separate\nstandalone object like this allows you to keep multiple manifests for ConfigMaps with\nthe same name, each for a different environment (development, testing, QA, produc-\ntion, and so on). Because pods reference the ConfigMap by name, you can use a dif-\nferent config in each environment while using the same pod specification across all of\nthem (see figure 7.3).\nPod\nEnvironment variables\nCon\ufb01gMap\nkey1=value1\nkey2=value2\n...\ncon\ufb01gMap\nvolume\nFigure 7.2\nPods use ConfigMaps \nthrough environment variables and \nconfigMap volumes.\nCon\ufb01gMap:\napp-con\ufb01g\nNamespace: development\n(contains\ndevelopment\nvalues)\nPod(s)\nCon\ufb01gMaps created\nfrom different manifests\nPods created from the\nsame pod manifests\nNamespace: production\nCon\ufb01gMap:\napp-con\ufb01g\n(contains\nproduction\nvalues)\nPod(s)\nFigure 7.3\nTwo different ConfigMaps with the same name used in different \nenvironments\n \n", "shape": "dot", "size": 10, "title": "199\nDecoupling configuration with a ConfigMap\nvariables can be referenced in command-line arguments using the $(ENV_VAR) syn-\ntax, you can also pass ConfigMap entries to processes as command-line arguments.\nSure, the application can also read the contents of a ConfigMap directly through the\nKubernetes REST API endpoint if needed, but unless you have a real need for this,\nyou should keep your app Kubernetes-agnostic as much as possible.\n Regardless of how an app consumes a ConfigMap, having the config in a separate\nstandalone object like this allows you to keep multiple manifests for ConfigMaps with\nthe same name, each for a different environment (development, testing, QA, produc-\ntion, and so on). Because pods reference the ConfigMap by name, you can use a dif-\nferent config in each environment while using the same pod specification across all of\nthem (see figure 7.3).\nPod\nEnvironment variables\nCon\ufb01gMap\nkey1=value1\nkey2=value2\n...\ncon\ufb01gMap\nvolume\nFigure 7.2\nPods use ConfigMaps \nthrough environment variables and \nconfigMap volumes.\nCon\ufb01gMap:\napp-con\ufb01g\nNamespace: development\n(contains\ndevelopment\nvalues)\nPod(s)\nCon\ufb01gMaps created\nfrom different manifests\nPods created from the\nsame pod manifests\nNamespace: production\nCon\ufb01gMap:\napp-con\ufb01g\n(contains\nproduction\nvalues)\nPod(s)\nFigure 7.3\nTwo different ConfigMaps with the same name used in different \nenvironments\n \n"}, {"color": "green", "id": "text_143", "label": "200\nCHAPTER 7\nConfigMaps and Secrets: configuring applications\n7.4.2\nCreating a ConfigMap\nLet\u2019s see how to use a ConfigMap in one of your pods. To start with the simplest exam-\nple, you\u2019ll first create a map with a single key and use it to fill the INTERVAL environment\nvariable from your previous example. You\u2019ll create the ConfigMap with the special\nkubectl create configmap command instead of posting a YAML with the generic\nkubectl create -f command. \nUSING THE KUBECTL CREATE CONFIGMAP COMMAND\nYou can define the map\u2019s entries by passing literals to the kubectl command or you\ncan create the ConfigMap from files stored on your disk. Use a simple literal first:\n$ kubectl create configmap fortune-config --from-literal=sleep-interval=25\nconfigmap \"fortune-config\" created\nNOTE\nConfigMap keys must be a valid DNS subdomain (they may only con-\ntain alphanumeric characters, dashes, underscores, and dots). They may\noptionally include a leading dot.\nThis creates a ConfigMap called fortune-config with the single-entry sleep-interval\n=25 (figure 7.4).\nConfigMaps usually contain more than one entry. To create a ConfigMap with multi-\nple literal entries, you add multiple --from-literal arguments:\n$ kubectl create configmap myconfigmap\n\u27a5  --from-literal=foo=bar --from-literal=bar=baz --from-literal=one=two\nLet\u2019s inspect the YAML descriptor of the ConfigMap you created by using the kubectl\nget command, as shown in the following listing.\n$ kubectl get configmap fortune-config -o yaml\napiVersion: v1\ndata:\n  sleep-interval: \"25\"                      \nkind: ConfigMap                              \nmetadata:\n  creationTimestamp: 2016-08-11T20:31:08Z\n  name: fortune-config                      \n  namespace: default\n  resourceVersion: \"910025\"\n  selfLink: /api/v1/namespaces/default/configmaps/fortune-config\n  uid: 88c4167e-6002-11e6-a50d-42010af00237\nListing 7.8\nA ConfigMap definition\nsleep-interval\n25\nCon\ufb01gMap: fortune-con\ufb01g\nFigure 7.4\nThe fortune-config \nConfigMap containing a single entry\nThe single entry \nin this map\nThis descriptor \ndescribes a ConfigMap.\nThe name of this map \n(you\u2019re referencing it \nby this name)\n \n", "shape": "dot", "size": 10, "title": "200\nCHAPTER 7\nConfigMaps and Secrets: configuring applications\n7.4.2\nCreating a ConfigMap\nLet\u2019s see how to use a ConfigMap in one of your pods. To start with the simplest exam-\nple, you\u2019ll first create a map with a single key and use it to fill the INTERVAL environment\nvariable from your previous example. You\u2019ll create the ConfigMap with the special\nkubectl create configmap command instead of posting a YAML with the generic\nkubectl create -f command. \nUSING THE KUBECTL CREATE CONFIGMAP COMMAND\nYou can define the map\u2019s entries by passing literals to the kubectl command or you\ncan create the ConfigMap from files stored on your disk. Use a simple literal first:\n$ kubectl create configmap fortune-config --from-literal=sleep-interval=25\nconfigmap \"fortune-config\" created\nNOTE\nConfigMap keys must be a valid DNS subdomain (they may only con-\ntain alphanumeric characters, dashes, underscores, and dots). They may\noptionally include a leading dot.\nThis creates a ConfigMap called fortune-config with the single-entry sleep-interval\n=25 (figure 7.4).\nConfigMaps usually contain more than one entry. To create a ConfigMap with multi-\nple literal entries, you add multiple --from-literal arguments:\n$ kubectl create configmap myconfigmap\n\u27a5  --from-literal=foo=bar --from-literal=bar=baz --from-literal=one=two\nLet\u2019s inspect the YAML descriptor of the ConfigMap you created by using the kubectl\nget command, as shown in the following listing.\n$ kubectl get configmap fortune-config -o yaml\napiVersion: v1\ndata:\n  sleep-interval: \"25\"                      \nkind: ConfigMap                              \nmetadata:\n  creationTimestamp: 2016-08-11T20:31:08Z\n  name: fortune-config                      \n  namespace: default\n  resourceVersion: \"910025\"\n  selfLink: /api/v1/namespaces/default/configmaps/fortune-config\n  uid: 88c4167e-6002-11e6-a50d-42010af00237\nListing 7.8\nA ConfigMap definition\nsleep-interval\n25\nCon\ufb01gMap: fortune-con\ufb01g\nFigure 7.4\nThe fortune-config \nConfigMap containing a single entry\nThe single entry \nin this map\nThis descriptor \ndescribes a ConfigMap.\nThe name of this map \n(you\u2019re referencing it \nby this name)\n \n"}, {"color": "green", "id": "text_144", "label": "201\nDecoupling configuration with a ConfigMap\nNothing extraordinary. You could easily have written this YAML yourself (you wouldn\u2019t\nneed to specify anything but the name in the metadata section, of course) and posted\nit to the Kubernetes API with the well-known\n$ kubectl create -f fortune-config.yaml\nCREATING A CONFIGMAP ENTRY FROM THE CONTENTS OF A FILE\nConfigMaps can also store coarse-grained config data, such as complete config files.\nTo do this, the kubectl create configmap command also supports reading files from\ndisk and storing them as individual entries in the ConfigMap:\n$ kubectl create configmap my-config --from-file=config-file.conf\nWhen you run the previous command, kubectl looks for the file config-file.conf in\nthe directory you run kubectl in. It will then store the contents of the file under the\nkey config-file.conf in the ConfigMap (the filename is used as the map key), but\nyou can also specify a key manually like this:\n$ kubectl create configmap my-config --from-file=customkey=config-file.conf\nThis command will store the file\u2019s contents under the key customkey. As with literals,\nyou can add multiple files by using the --from-file argument multiple times. \nCREATING A CONFIGMAP FROM FILES IN A DIRECTORY\nInstead of importing each file individually, you can even import all files from a file\ndirectory:\n$ kubectl create configmap my-config --from-file=/path/to/dir\nIn this case, kubectl will create an individual map entry for each file in the specified\ndirectory, but only for files whose name is a valid ConfigMap key. \nCOMBINING DIFFERENT OPTIONS\nWhen creating ConfigMaps, you can use a combination of all the options mentioned\nhere (note that these files aren\u2019t included in the book\u2019s code archive\u2014you can create\nthem yourself if you\u2019d like to try out the command):\n$ kubectl create configmap my-config  \n\u27a5  --from-file=foo.json                  \n\u27a5  --from-file=bar=foobar.conf              \n\u27a5  --from-file=config-opts/               \n\u27a5  --from-literal=some=thing    \nHere, you\u2019ve created the ConfigMap from multiple sources: a whole directory, a file,\nanother file (but stored under a custom key instead of using the filename as the key),\nand a literal value. Figure 7.5 shows all these sources and the resulting ConfigMap.\nA single file\nA file stored under \na custom key\nA whole directory\nA literal value\n \n", "shape": "dot", "size": 10, "title": "201\nDecoupling configuration with a ConfigMap\nNothing extraordinary. You could easily have written this YAML yourself (you wouldn\u2019t\nneed to specify anything but the name in the metadata section, of course) and posted\nit to the Kubernetes API with the well-known\n$ kubectl create -f fortune-config.yaml\nCREATING A CONFIGMAP ENTRY FROM THE CONTENTS OF A FILE\nConfigMaps can also store coarse-grained config data, such as complete config files.\nTo do this, the kubectl create configmap command also supports reading files from\ndisk and storing them as individual entries in the ConfigMap:\n$ kubectl create configmap my-config --from-file=config-file.conf\nWhen you run the previous command, kubectl looks for the file config-file.conf in\nthe directory you run kubectl in. It will then store the contents of the file under the\nkey config-file.conf in the ConfigMap (the filename is used as the map key), but\nyou can also specify a key manually like this:\n$ kubectl create configmap my-config --from-file=customkey=config-file.conf\nThis command will store the file\u2019s contents under the key customkey. As with literals,\nyou can add multiple files by using the --from-file argument multiple times. \nCREATING A CONFIGMAP FROM FILES IN A DIRECTORY\nInstead of importing each file individually, you can even import all files from a file\ndirectory:\n$ kubectl create configmap my-config --from-file=/path/to/dir\nIn this case, kubectl will create an individual map entry for each file in the specified\ndirectory, but only for files whose name is a valid ConfigMap key. \nCOMBINING DIFFERENT OPTIONS\nWhen creating ConfigMaps, you can use a combination of all the options mentioned\nhere (note that these files aren\u2019t included in the book\u2019s code archive\u2014you can create\nthem yourself if you\u2019d like to try out the command):\n$ kubectl create configmap my-config  \n\u27a5  --from-file=foo.json                  \n\u27a5  --from-file=bar=foobar.conf              \n\u27a5  --from-file=config-opts/               \n\u27a5  --from-literal=some=thing    \nHere, you\u2019ve created the ConfigMap from multiple sources: a whole directory, a file,\nanother file (but stored under a custom key instead of using the filename as the key),\nand a literal value. Figure 7.5 shows all these sources and the resulting ConfigMap.\nA single file\nA file stored under \na custom key\nA whole directory\nA literal value\n \n"}, {"color": "green", "id": "text_145", "label": "202\nCHAPTER 7\nConfigMaps and Secrets: configuring applications\n7.4.3\nPassing a ConfigMap entry to a container as an environment \nvariable\nHow do you now get the values from this map into a pod\u2019s container? You have three\noptions. Let\u2019s start with the simplest\u2014setting an environment variable. You\u2019ll use the\nvalueFrom field I mentioned in section 7.3.3. The pod descriptor should look like\nthe following listing.\napiVersion: v1\nkind: Pod\nListing 7.9\nPod with env var from a config map: fortune-pod-env-configmap.yaml\nCon\ufb01gMap: my-con\ufb01g\nKey\nfoo.json\nfoo.json\nValue\nbar\nabc\ndebug\ntrue\nrepeat\n100\nsome\nthing\n{\nfoo: bar\nbaz: 5\n}\ncon\ufb01g-opts directory\nLiteral\nsome=thing\n{\nfoo: bar\nbaz: 5\n}\n--from-\ufb01le=foo.json\n--from-\ufb01le=con\ufb01g-opts/\n--from-literal=some=thing\nfoobar.conf\nabc\ndebug\ntrue\nrepeat\n100\n--from-\ufb01le=bar=foobar.conf\nFigure 7.5\nCreating a ConfigMap from individual files, a directory, and a literal value\n \n", "shape": "dot", "size": 10, "title": "202\nCHAPTER 7\nConfigMaps and Secrets: configuring applications\n7.4.3\nPassing a ConfigMap entry to a container as an environment \nvariable\nHow do you now get the values from this map into a pod\u2019s container? You have three\noptions. Let\u2019s start with the simplest\u2014setting an environment variable. You\u2019ll use the\nvalueFrom field I mentioned in section 7.3.3. The pod descriptor should look like\nthe following listing.\napiVersion: v1\nkind: Pod\nListing 7.9\nPod with env var from a config map: fortune-pod-env-configmap.yaml\nCon\ufb01gMap: my-con\ufb01g\nKey\nfoo.json\nfoo.json\nValue\nbar\nabc\ndebug\ntrue\nrepeat\n100\nsome\nthing\n{\nfoo: bar\nbaz: 5\n}\ncon\ufb01g-opts directory\nLiteral\nsome=thing\n{\nfoo: bar\nbaz: 5\n}\n--from-\ufb01le=foo.json\n--from-\ufb01le=con\ufb01g-opts/\n--from-literal=some=thing\nfoobar.conf\nabc\ndebug\ntrue\nrepeat\n100\n--from-\ufb01le=bar=foobar.conf\nFigure 7.5\nCreating a ConfigMap from individual files, a directory, and a literal value\n \n"}, {"color": "green", "id": "text_146", "label": "203\nDecoupling configuration with a ConfigMap\nmetadata:\n  name: fortune-env-from-configmap\nspec:\n  containers:\n  - image: luksa/fortune:env\n    env:                             \n    - name: INTERVAL                 \n      valueFrom:                       \n        configMapKeyRef:               \n          name: fortune-config      \n          key: sleep-interval    \n...\nYou defined an environment variable called INTERVAL and set its value to whatever is\nstored in the fortune-config ConfigMap under the key sleep-interval. When the\nprocess running in the html-generator container reads the INTERVAL environment\nvariable, it will see the value 25 (shown in figure 7.6).\nREFERENCING NON-EXISTING CONFIGMAPS IN A POD\nYou might wonder what happens if the referenced ConfigMap doesn\u2019t exist when you\ncreate the pod. Kubernetes schedules the pod normally and tries to run its containers.\nThe container referencing the non-existing ConfigMap will fail to start, but the other\ncontainer will start normally. If you then create the missing ConfigMap, the failed con-\ntainer is started without requiring you to recreate the pod.\nNOTE\nYou can also mark a reference to a ConfigMap as optional (by setting\nconfigMapKeyRef.optional: true). In that case, the container starts even if\nthe ConfigMap doesn\u2019t exist.\nThis example shows you how to decouple the configuration from the pod specifica-\ntion. This allows you to keep all the configuration options closely together (even for\nmultiple pods) instead of having them splattered around the pod definition (or dupli-\ncated across multiple pod manifests). \nYou\u2019re setting the environment \nvariable called INTERVAL.\nInstead of setting a fixed value, you\u0027re \ninitializing it from a ConfigMap key.\nThe name of the ConfigMap \nyou\u0027re referencing\nYou\u0027re setting the variable to whatever is\nstored under this key in the ConfigMap.\nCon\ufb01gMap: fortune-con\ufb01g\nsleep-interval\n25\nPod\nContainer: web-server\nContainer: html-generator\nEnvironment variables\nINTERVAL=25\nfortuneloop.sh\nprocess\nFigure 7.6\nPassing a ConfigMap entry as \nan environment variable to a container\n \n", "shape": "dot", "size": 10, "title": "203\nDecoupling configuration with a ConfigMap\nmetadata:\n  name: fortune-env-from-configmap\nspec:\n  containers:\n  - image: luksa/fortune:env\n    env:                             \n    - name: INTERVAL                 \n      valueFrom:                       \n        configMapKeyRef:               \n          name: fortune-config      \n          key: sleep-interval    \n...\nYou defined an environment variable called INTERVAL and set its value to whatever is\nstored in the fortune-config ConfigMap under the key sleep-interval. When the\nprocess running in the html-generator container reads the INTERVAL environment\nvariable, it will see the value 25 (shown in figure 7.6).\nREFERENCING NON-EXISTING CONFIGMAPS IN A POD\nYou might wonder what happens if the referenced ConfigMap doesn\u2019t exist when you\ncreate the pod. Kubernetes schedules the pod normally and tries to run its containers.\nThe container referencing the non-existing ConfigMap will fail to start, but the other\ncontainer will start normally. If you then create the missing ConfigMap, the failed con-\ntainer is started without requiring you to recreate the pod.\nNOTE\nYou can also mark a reference to a ConfigMap as optional (by setting\nconfigMapKeyRef.optional: true). In that case, the container starts even if\nthe ConfigMap doesn\u2019t exist.\nThis example shows you how to decouple the configuration from the pod specifica-\ntion. This allows you to keep all the configuration options closely together (even for\nmultiple pods) instead of having them splattered around the pod definition (or dupli-\ncated across multiple pod manifests). \nYou\u2019re setting the environment \nvariable called INTERVAL.\nInstead of setting a fixed value, you\u0027re \ninitializing it from a ConfigMap key.\nThe name of the ConfigMap \nyou\u0027re referencing\nYou\u0027re setting the variable to whatever is\nstored under this key in the ConfigMap.\nCon\ufb01gMap: fortune-con\ufb01g\nsleep-interval\n25\nPod\nContainer: web-server\nContainer: html-generator\nEnvironment variables\nINTERVAL=25\nfortuneloop.sh\nprocess\nFigure 7.6\nPassing a ConfigMap entry as \nan environment variable to a container\n \n"}, {"color": "green", "id": "text_147", "label": "204\nCHAPTER 7\nConfigMaps and Secrets: configuring applications\n7.4.4\nPassing all entries of a ConfigMap as environment variables \nat once\nWhen your ConfigMap contains more than just a few entries, it becomes tedious and\nerror-prone to create environment variables from each entry individually. Luckily,\nKubernetes version 1.6 provides a way to expose all entries of a ConfigMap as environ-\nment variables. \n Imagine having a ConfigMap with three keys called FOO, BAR, and FOO-BAR. You can\nexpose them all as environment variables by using the envFrom attribute, instead of\nenv the way you did in previous examples. The following listing shows an example.\nspec:\n  containers:\n  - image: some-image\n    envFrom:                \n    - prefix: CONFIG_             \n      configMapRef:              \n        name: my-config-map      \n...\nAs you can see, you can also specify a prefix for the environment variables (CONFIG_ in\nthis case). This results in the following two environment variables being present inside\nthe container: CONFIG_FOO and CONFIG_BAR. \nNOTE\nThe prefix is optional, so if you omit it the environment variables will\nhave the same name as the keys. \nDid you notice I said two variables, but earlier, I said the ConfigMap has three entries\n(FOO, BAR, and FOO-BAR)? Why is there no environment variable for the FOO-BAR\nConfigMap entry?\n The reason is that CONFIG_FOO-BAR isn\u2019t a valid environment variable name\nbecause it contains a dash. Kubernetes doesn\u2019t convert the keys in any way (it doesn\u2019t\nconvert dashes to underscores, for example). If a ConfigMap key isn\u2019t in the proper\nformat, it skips the entry (but it does record an event informing you it skipped it).\n7.4.5\nPassing a ConfigMap entry as a command-line argument\nNow, let\u2019s also look at how to pass values from a ConfigMap as arguments to the main\nprocess running in the container. You can\u2019t reference ConfigMap entries directly in\nthe pod.spec.containers.args field, but you can first initialize an environment vari-\nable from the ConfigMap entry and then refer to the variable inside the arguments as\nshown in figure 7.7.\n Listing 7.11 shows an example of how to do this in the YAML.\n \nListing 7.10\nPod with env vars from all entries of a ConfigMap\nUsing envFrom instead of env\nAll environment variables will \nbe prefixed with CONFIG_.\nReferencing the ConfigMap \ncalled my-config-map\n \n", "shape": "dot", "size": 10, "title": "204\nCHAPTER 7\nConfigMaps and Secrets: configuring applications\n7.4.4\nPassing all entries of a ConfigMap as environment variables \nat once\nWhen your ConfigMap contains more than just a few entries, it becomes tedious and\nerror-prone to create environment variables from each entry individually. Luckily,\nKubernetes version 1.6 provides a way to expose all entries of a ConfigMap as environ-\nment variables. \n Imagine having a ConfigMap with three keys called FOO, BAR, and FOO-BAR. You can\nexpose them all as environment variables by using the envFrom attribute, instead of\nenv the way you did in previous examples. The following listing shows an example.\nspec:\n  containers:\n  - image: some-image\n    envFrom:                \n    - prefix: CONFIG_             \n      configMapRef:              \n        name: my-config-map      \n...\nAs you can see, you can also specify a prefix for the environment variables (CONFIG_ in\nthis case). This results in the following two environment variables being present inside\nthe container: CONFIG_FOO and CONFIG_BAR. \nNOTE\nThe prefix is optional, so if you omit it the environment variables will\nhave the same name as the keys. \nDid you notice I said two variables, but earlier, I said the ConfigMap has three entries\n(FOO, BAR, and FOO-BAR)? Why is there no environment variable for the FOO-BAR\nConfigMap entry?\n The reason is that CONFIG_FOO-BAR isn\u2019t a valid environment variable name\nbecause it contains a dash. Kubernetes doesn\u2019t convert the keys in any way (it doesn\u2019t\nconvert dashes to underscores, for example). If a ConfigMap key isn\u2019t in the proper\nformat, it skips the entry (but it does record an event informing you it skipped it).\n7.4.5\nPassing a ConfigMap entry as a command-line argument\nNow, let\u2019s also look at how to pass values from a ConfigMap as arguments to the main\nprocess running in the container. You can\u2019t reference ConfigMap entries directly in\nthe pod.spec.containers.args field, but you can first initialize an environment vari-\nable from the ConfigMap entry and then refer to the variable inside the arguments as\nshown in figure 7.7.\n Listing 7.11 shows an example of how to do this in the YAML.\n \nListing 7.10\nPod with env vars from all entries of a ConfigMap\nUsing envFrom instead of env\nAll environment variables will \nbe prefixed with CONFIG_.\nReferencing the ConfigMap \ncalled my-config-map\n \n"}, {"color": "green", "id": "text_148", "label": "205\nDecoupling configuration with a ConfigMap\napiVersion: v1\nkind: Pod\nmetadata:\n  name: fortune-args-from-configmap\nspec:\n  containers:\n  - image: luksa/fortune:args         \n    env:                               \n    - name: INTERVAL                   \n      valueFrom:                       \n        configMapKeyRef:               \n          name: fortune-config         \n          key: sleep-interval          \n    args: [\"$(INTERVAL)\"]      \n...\nYou defined the environment variable exactly as you did before, but then you used the\n$(ENV_VARIABLE_NAME) syntax to have Kubernetes inject the value of the variable into\nthe argument. \n7.4.6\nUsing a configMap volume to expose ConfigMap entries as files\nPassing configuration options as environment variables or command-line arguments\nis usually used for short variable values. A ConfigMap, as you\u2019ve seen, can also con-\ntain whole config files. When you want to expose those to the container, you can use\none of the special volume types I mentioned in the previous chapter, namely a\nconfigMap volume.\n A configMap volume will expose each entry of the ConfigMap as a file. The pro-\ncess running in the container can obtain the entry\u2019s value by reading the contents of\nthe file.\nListing 7.11\nUsing ConfigMap entries as arguments: fortune-pod-args-configmap.yaml\nCon\ufb01gMap: fortune-con\ufb01g\nsleep-interval\n25\nPod\nContainer: web-server\nContainer: html-generator\nEnvironment variables\nINTERVAL=25\nfortuneloop.sh $(INTERVAL)\nFigure 7.7\nPassing a ConfigMap entry as a command-line argument\nUsing the image that takes the \ninterval from the first argument, \nnot from an environment variable\nDefining the \nenvironment variable \nexactly as before\nReferencing the environment \nvariable in the argument\n \n", "shape": "dot", "size": 10, "title": "205\nDecoupling configuration with a ConfigMap\napiVersion: v1\nkind: Pod\nmetadata:\n  name: fortune-args-from-configmap\nspec:\n  containers:\n  - image: luksa/fortune:args         \n    env:                               \n    - name: INTERVAL                   \n      valueFrom:                       \n        configMapKeyRef:               \n          name: fortune-config         \n          key: sleep-interval          \n    args: [\"$(INTERVAL)\"]      \n...\nYou defined the environment variable exactly as you did before, but then you used the\n$(ENV_VARIABLE_NAME) syntax to have Kubernetes inject the value of the variable into\nthe argument. \n7.4.6\nUsing a configMap volume to expose ConfigMap entries as files\nPassing configuration options as environment variables or command-line arguments\nis usually used for short variable values. A ConfigMap, as you\u2019ve seen, can also con-\ntain whole config files. When you want to expose those to the container, you can use\none of the special volume types I mentioned in the previous chapter, namely a\nconfigMap volume.\n A configMap volume will expose each entry of the ConfigMap as a file. The pro-\ncess running in the container can obtain the entry\u2019s value by reading the contents of\nthe file.\nListing 7.11\nUsing ConfigMap entries as arguments: fortune-pod-args-configmap.yaml\nCon\ufb01gMap: fortune-con\ufb01g\nsleep-interval\n25\nPod\nContainer: web-server\nContainer: html-generator\nEnvironment variables\nINTERVAL=25\nfortuneloop.sh $(INTERVAL)\nFigure 7.7\nPassing a ConfigMap entry as a command-line argument\nUsing the image that takes the \ninterval from the first argument, \nnot from an environment variable\nDefining the \nenvironment variable \nexactly as before\nReferencing the environment \nvariable in the argument\n \n"}, {"color": "green", "id": "text_149", "label": "206\nCHAPTER 7\nConfigMaps and Secrets: configuring applications\n Although this method is mostly meant for passing large config files to the con-\ntainer, nothing prevents you from passing short single values this way. \nCREATING THE CONFIGMAP\nInstead of modifying your fortuneloop.sh script once again, you\u2019ll now try a different\nexample. You\u2019ll use a config file to configure the Nginx web server running inside the\nfortune pod\u2019s web-server container. Let\u2019s say you want your Nginx server to compress\nresponses it sends to the client. To enable compression, the config file for Nginx\nneeds to look like the following listing.\nserver {\n  listen              80;\n  server_name         www.kubia-example.com;\n  gzip on;                                       \n  gzip_types text/plain application/xml;         \n  location / {\n    root   /usr/share/nginx/html;\n    index  index.html index.htm;\n  }\n}\nNow delete your existing fortune-config ConfigMap with kubectl delete config-\nmap fortune-config, so that you can replace it with a new one, which will include the\nNginx config file. You\u2019ll create the ConfigMap from files stored on your local disk. \n Create a new directory called configmap-files and store the Nginx config from the\nprevious listing into configmap-files/my-nginx-config.conf. To make the ConfigMap\nalso contain the sleep-interval entry, add a plain text file called sleep-interval to the\nsame directory and store the number 25 in it (see figure 7.8).\nNow create a ConfigMap from all the files in the directory like this:\n$ kubectl create configmap fortune-config --from-file=configmap-files\nconfigmap \"fortune-config\" created\nListing 7.12\nAn Nginx config with enabled gzip compression: my-nginx-config.conf\nThis enables gzip compression \nfor plain text and XML files.\ncon\ufb01gmap-\ufb01les/\nmy-nginx-con\ufb01g.conf\nserver {\nlisten 80;\nserver_name www.kubia...\n...\n}\nsleep-interval\n25\nFigure 7.8\nThe contents of the \nconfigmap-files directory and its files\n \n", "shape": "dot", "size": 10, "title": "206\nCHAPTER 7\nConfigMaps and Secrets: configuring applications\n Although this method is mostly meant for passing large config files to the con-\ntainer, nothing prevents you from passing short single values this way. \nCREATING THE CONFIGMAP\nInstead of modifying your fortuneloop.sh script once again, you\u2019ll now try a different\nexample. You\u2019ll use a config file to configure the Nginx web server running inside the\nfortune pod\u2019s web-server container. Let\u2019s say you want your Nginx server to compress\nresponses it sends to the client. To enable compression, the config file for Nginx\nneeds to look like the following listing.\nserver {\n  listen              80;\n  server_name         www.kubia-example.com;\n  gzip on;                                       \n  gzip_types text/plain application/xml;         \n  location / {\n    root   /usr/share/nginx/html;\n    index  index.html index.htm;\n  }\n}\nNow delete your existing fortune-config ConfigMap with kubectl delete config-\nmap fortune-config, so that you can replace it with a new one, which will include the\nNginx config file. You\u2019ll create the ConfigMap from files stored on your local disk. \n Create a new directory called configmap-files and store the Nginx config from the\nprevious listing into configmap-files/my-nginx-config.conf. To make the ConfigMap\nalso contain the sleep-interval entry, add a plain text file called sleep-interval to the\nsame directory and store the number 25 in it (see figure 7.8).\nNow create a ConfigMap from all the files in the directory like this:\n$ kubectl create configmap fortune-config --from-file=configmap-files\nconfigmap \"fortune-config\" created\nListing 7.12\nAn Nginx config with enabled gzip compression: my-nginx-config.conf\nThis enables gzip compression \nfor plain text and XML files.\ncon\ufb01gmap-\ufb01les/\nmy-nginx-con\ufb01g.conf\nserver {\nlisten 80;\nserver_name www.kubia...\n...\n}\nsleep-interval\n25\nFigure 7.8\nThe contents of the \nconfigmap-files directory and its files\n \n"}, {"color": "green", "id": "text_150", "label": "207\nDecoupling configuration with a ConfigMap\nThe following listing shows what the YAML of this ConfigMap looks like.\n$ kubectl get configmap fortune-config -o yaml\napiVersion: v1\ndata:\n  my-nginx-config.conf: |                            \n    server {                                         \n      listen              80;                        \n      server_name         www.kubia-example.com;     \n      gzip on;                                       \n      gzip_types text/plain application/xml;         \n      location / {                                   \n        root   /usr/share/nginx/html;                \n        index  index.html index.htm;                 \n      }                                              \n    }                                                \n  sleep-interval: |         \n    25                      \nkind: ConfigMap\n...\nNOTE\nThe pipeline character after the colon in the first line of both entries\nsignals that a literal multi-line value follows.\nThe ConfigMap contains two entries, with keys corresponding to the actual names\nof the files they were created from. You\u2019ll now use the ConfigMap in both of your\npod\u2019s containers.\nUSING THE CONFIGMAP\u0027S ENTRIES IN A VOLUME\nCreating a volume populated with the contents of a ConfigMap is as easy as creating\na volume that references the ConfigMap by name and mounting the volume in a\ncontainer. You already learned how to create volumes and mount them, so the only\nthing left to learn is how to initialize the volume with files created from a Config-\nMap\u2019s entries.\n Nginx reads its config file from /etc/nginx/nginx.conf. The Nginx image\nalready contains this file with default configuration options, which you don\u2019t want\nto override, so you don\u2019t want to replace this file as a whole. Luckily, the default\nconfig file automatically includes all .conf files in the /etc/nginx/conf.d/ subdirec-\ntory as well, so you should add your config file in there. Figure 7.9 shows what you\nwant to achieve.\n The pod descriptor is shown in listing 7.14 (the irrelevant parts are omitted, but\nyou\u2019ll find the complete file in the code archive).\n \n \nListing 7.13\nYAML definition of a config map created from a file\nThe entry holding the \nNginx config file\u2019s \ncontents\nThe sleep-interval entry\n \n", "shape": "dot", "size": 10, "title": "207\nDecoupling configuration with a ConfigMap\nThe following listing shows what the YAML of this ConfigMap looks like.\n$ kubectl get configmap fortune-config -o yaml\napiVersion: v1\ndata:\n  my-nginx-config.conf: |                            \n    server {                                         \n      listen              80;                        \n      server_name         www.kubia-example.com;     \n      gzip on;                                       \n      gzip_types text/plain application/xml;         \n      location / {                                   \n        root   /usr/share/nginx/html;                \n        index  index.html index.htm;                 \n      }                                              \n    }                                                \n  sleep-interval: |         \n    25                      \nkind: ConfigMap\n...\nNOTE\nThe pipeline character after the colon in the first line of both entries\nsignals that a literal multi-line value follows.\nThe ConfigMap contains two entries, with keys corresponding to the actual names\nof the files they were created from. You\u2019ll now use the ConfigMap in both of your\npod\u2019s containers.\nUSING THE CONFIGMAP\u0027S ENTRIES IN A VOLUME\nCreating a volume populated with the contents of a ConfigMap is as easy as creating\na volume that references the ConfigMap by name and mounting the volume in a\ncontainer. You already learned how to create volumes and mount them, so the only\nthing left to learn is how to initialize the volume with files created from a Config-\nMap\u2019s entries.\n Nginx reads its config file from /etc/nginx/nginx.conf. The Nginx image\nalready contains this file with default configuration options, which you don\u2019t want\nto override, so you don\u2019t want to replace this file as a whole. Luckily, the default\nconfig file automatically includes all .conf files in the /etc/nginx/conf.d/ subdirec-\ntory as well, so you should add your config file in there. Figure 7.9 shows what you\nwant to achieve.\n The pod descriptor is shown in listing 7.14 (the irrelevant parts are omitted, but\nyou\u2019ll find the complete file in the code archive).\n \n \nListing 7.13\nYAML definition of a config map created from a file\nThe entry holding the \nNginx config file\u2019s \ncontents\nThe sleep-interval entry\n \n"}, {"color": "green", "id": "text_151", "label": "208\nCHAPTER 7\nConfigMaps and Secrets: configuring applications\napiVersion: v1\nkind: Pod\nmetadata:\n  name: fortune-configmap-volume\nspec:\n  containers:\n  - image: nginx:alpine\n    name: web-server\n    volumeMounts:\n    ...\n    - name: config\n      mountPath: /etc/nginx/conf.d      \n      readOnly: true\n    ...\n  volumes:\n  ...\n  - name: config              \n    configMap:                 \n      name: fortune-config     \n  ...\nThis pod definition includes a volume, which references your fortune-config\nConfigMap. You mount the volume into the /etc/nginx/conf.d directory to make\nNginx use it. \nVERIFYING NGINX IS USING THE MOUNTED CONFIG FILE\nThe web server should now be configured to compress the responses it sends. You can\nverify this by enabling port-forwarding from localhost:8080 to the pod\u2019s port 80 and\nchecking the server\u2019s response with curl, as shown in the following listing.\n \nListing 7.14\nA pod with ConfigMap entries mounted as files: fortune-pod-configmap-\nvolume.yaml\nPod\nContainer: html-generator\nContainer: web-server\nFilesystem\n/\netc/\nnginx/\nconf.d/\nCon\ufb01gMap: fortune-con\ufb01g\nmy-nginx-con\ufb01g.conf\nserver {\n\u2026\n}\nVolume:\ncon\ufb01g\nFigure 7.9\nPassing ConfigMap entries to a pod as files in a volume\nYou\u2019re mounting the \nconfigMap volume at \nthis location.\nThe volume refers to your \nfortune-config ConfigMap.\n \n", "shape": "dot", "size": 10, "title": "208\nCHAPTER 7\nConfigMaps and Secrets: configuring applications\napiVersion: v1\nkind: Pod\nmetadata:\n  name: fortune-configmap-volume\nspec:\n  containers:\n  - image: nginx:alpine\n    name: web-server\n    volumeMounts:\n    ...\n    - name: config\n      mountPath: /etc/nginx/conf.d      \n      readOnly: true\n    ...\n  volumes:\n  ...\n  - name: config              \n    configMap:                 \n      name: fortune-config     \n  ...\nThis pod definition includes a volume, which references your fortune-config\nConfigMap. You mount the volume into the /etc/nginx/conf.d directory to make\nNginx use it. \nVERIFYING NGINX IS USING THE MOUNTED CONFIG FILE\nThe web server should now be configured to compress the responses it sends. You can\nverify this by enabling port-forwarding from localhost:8080 to the pod\u2019s port 80 and\nchecking the server\u2019s response with curl, as shown in the following listing.\n \nListing 7.14\nA pod with ConfigMap entries mounted as files: fortune-pod-configmap-\nvolume.yaml\nPod\nContainer: html-generator\nContainer: web-server\nFilesystem\n/\netc/\nnginx/\nconf.d/\nCon\ufb01gMap: fortune-con\ufb01g\nmy-nginx-con\ufb01g.conf\nserver {\n\u2026\n}\nVolume:\ncon\ufb01g\nFigure 7.9\nPassing ConfigMap entries to a pod as files in a volume\nYou\u2019re mounting the \nconfigMap volume at \nthis location.\nThe volume refers to your \nfortune-config ConfigMap.\n \n"}, {"color": "green", "id": "text_152", "label": "209\nDecoupling configuration with a ConfigMap\n$ kubectl port-forward fortune-configmap-volume 8080:80 \u0026\nForwarding from 127.0.0.1:8080 -\u003e 80\nForwarding from [::1]:8080 -\u003e 80\n$ curl -H \"Accept-Encoding: gzip\" -I localhost:8080\nHTTP/1.1 200 OK\nServer: nginx/1.11.1\nDate: Thu, 18 Aug 2016 11:52:57 GMT\nContent-Type: text/html\nLast-Modified: Thu, 18 Aug 2016 11:52:55 GMT\nConnection: keep-alive\nETag: W/\"57b5a197-37\"\nContent-Encoding: gzip           \nEXAMINING THE MOUNTED CONFIGMAP VOLUME\u2019S CONTENTS\nThe response shows you achieved what you wanted, but let\u2019s look at what\u2019s in the\n/etc/nginx/conf.d directory now:\n$ kubectl exec fortune-configmap-volume -c web-server ls /etc/nginx/conf.d\nmy-nginx-config.conf\nsleep-interval\nBoth entries from the ConfigMap have been added as files to the directory. The\nsleep-interval entry is also included, although it has no business being there,\nbecause it\u2019s only meant to be used by the fortuneloop container. You could create\ntwo different ConfigMaps and use one to configure the fortuneloop container and\nthe other one to configure the web-server container. But somehow it feels wrong to\nuse multiple ConfigMaps to configure containers of the same pod. After all, having\ncontainers in the same pod implies that the containers are closely related and should\nprobably also be configured as a unit. \nEXPOSING CERTAIN CONFIGMAP ENTRIES IN THE VOLUME\nLuckily, you can populate a configMap volume with only part of the ConfigMap\u2019s\nentries\u2014in your case, only the my-nginx-config.conf entry. This won\u2019t affect the\nfortuneloop container, because you\u2019re passing the sleep-interval entry to it through\nan environment variable and not through the volume. \n To define which entries should be exposed as files in a configMap volume, use the\nvolume\u2019s items attribute as shown in the following listing.\n  volumes:\n  - name: config              \n    configMap:                                  \n      name: fortune-config                      \n      items:                       \n      - key: my-nginx-config.conf        \n        path: gzip.conf                  \nListing 7.15\nSeeing if nginx responses have compression enabled\nListing 7.16\nA pod with a specific ConfigMap entry mounted into a file directory: \nfortune-pod-configmap-volume-with-items.yaml\nThis shows the response \nis compressed.\nSelecting which entries to include \nin the volume by listing them\nYou want the entry \nunder this key included.\nThe entry\u2019s value should \nbe stored in this file.\n \n", "shape": "dot", "size": 10, "title": "209\nDecoupling configuration with a ConfigMap\n$ kubectl port-forward fortune-configmap-volume 8080:80 \u0026\nForwarding from 127.0.0.1:8080 -\u003e 80\nForwarding from [::1]:8080 -\u003e 80\n$ curl -H \"Accept-Encoding: gzip\" -I localhost:8080\nHTTP/1.1 200 OK\nServer: nginx/1.11.1\nDate: Thu, 18 Aug 2016 11:52:57 GMT\nContent-Type: text/html\nLast-Modified: Thu, 18 Aug 2016 11:52:55 GMT\nConnection: keep-alive\nETag: W/\"57b5a197-37\"\nContent-Encoding: gzip           \nEXAMINING THE MOUNTED CONFIGMAP VOLUME\u2019S CONTENTS\nThe response shows you achieved what you wanted, but let\u2019s look at what\u2019s in the\n/etc/nginx/conf.d directory now:\n$ kubectl exec fortune-configmap-volume -c web-server ls /etc/nginx/conf.d\nmy-nginx-config.conf\nsleep-interval\nBoth entries from the ConfigMap have been added as files to the directory. The\nsleep-interval entry is also included, although it has no business being there,\nbecause it\u2019s only meant to be used by the fortuneloop container. You could create\ntwo different ConfigMaps and use one to configure the fortuneloop container and\nthe other one to configure the web-server container. But somehow it feels wrong to\nuse multiple ConfigMaps to configure containers of the same pod. After all, having\ncontainers in the same pod implies that the containers are closely related and should\nprobably also be configured as a unit. \nEXPOSING CERTAIN CONFIGMAP ENTRIES IN THE VOLUME\nLuckily, you can populate a configMap volume with only part of the ConfigMap\u2019s\nentries\u2014in your case, only the my-nginx-config.conf entry. This won\u2019t affect the\nfortuneloop container, because you\u2019re passing the sleep-interval entry to it through\nan environment variable and not through the volume. \n To define which entries should be exposed as files in a configMap volume, use the\nvolume\u2019s items attribute as shown in the following listing.\n  volumes:\n  - name: config              \n    configMap:                                  \n      name: fortune-config                      \n      items:                       \n      - key: my-nginx-config.conf        \n        path: gzip.conf                  \nListing 7.15\nSeeing if nginx responses have compression enabled\nListing 7.16\nA pod with a specific ConfigMap entry mounted into a file directory: \nfortune-pod-configmap-volume-with-items.yaml\nThis shows the response \nis compressed.\nSelecting which entries to include \nin the volume by listing them\nYou want the entry \nunder this key included.\nThe entry\u2019s value should \nbe stored in this file.\n \n"}, {"color": "green", "id": "text_153", "label": "210\nCHAPTER 7\nConfigMaps and Secrets: configuring applications\nWhen specifying individual entries, you need to set the filename for each individual\nentry, along with the entry\u2019s key. If you run the pod from the previous listing, the\n/etc/nginx/conf.d directory is kept nice and clean, because it only contains the\ngzip.conf file and nothing else. \nUNDERSTANDING THAT MOUNTING A DIRECTORY HIDES EXISTING FILES IN THAT DIRECTORY\nThere\u2019s one important thing to discuss at this point. In both this and in your previous\nexample, you mounted the volume as a directory, which means you\u2019ve hidden any files\nthat are stored in the /etc/nginx/conf.d directory in the container image itself. \n This is generally what happens in Linux when you mount a filesystem into a non-\nempty directory. The directory then only contains the files from the mounted filesys-\ntem, whereas the original files in that directory are inaccessible for as long as the\nfilesystem is mounted. \n In your case, this has no terrible side effects, but imagine mounting a volume to\nthe /etc directory, which usually contains many important files. This would most likely\nbreak the whole container, because all of the original files that should be in the /etc\ndirectory would no longer be there. If you need to add a file to a directory like /etc,\nyou can\u2019t use this method at all.\nMOUNTING INDIVIDUAL CONFIGMAP ENTRIES AS FILES WITHOUT HIDING OTHER FILES IN THE DIRECTORY\nNaturally, you\u2019re now wondering how to add individual files from a ConfigMap into\nan existing directory without hiding existing files stored in it. An additional subPath\nproperty on the volumeMount allows you to mount either a single file or a single direc-\ntory from the volume instead of mounting the whole volume. Perhaps this is easier to\nexplain visually (see figure 7.10).\n Say you have a configMap volume containing a myconfig.conf file, which you want\nto add to the /etc directory as someconfig.conf. You can use the subPath property to\nmount it there without affecting any other files in that directory. The relevant part of\nthe pod definition is shown in the following listing.\nPod\nContainer\nFilesystem\n/\netc/\nsomecon\ufb01g.conf\nexisting\ufb01le1\nexisting\ufb01le2\nCon\ufb01gMap: app-con\ufb01g\nmycon\ufb01g.conf\nContents\nof the \ufb01le\nanother-\ufb01le\nContents\nof the \ufb01le\ncon\ufb01gMap\nvolume\nmycon\ufb01g.conf\nanother-\ufb01le\nexisting\ufb01le1\nand existing\ufb01le2\naren\u2019t hidden.\nOnly mycon\ufb01g.conf is mounted\ninto the container (yet under a\ndifferent \ufb01lename).\nanother-\ufb01le isn\u2019t\nmounted into the\ncontainer.\nFigure 7.10\nMounting a single file from a volume\n \n", "shape": "dot", "size": 10, "title": "210\nCHAPTER 7\nConfigMaps and Secrets: configuring applications\nWhen specifying individual entries, you need to set the filename for each individual\nentry, along with the entry\u2019s key. If you run the pod from the previous listing, the\n/etc/nginx/conf.d directory is kept nice and clean, because it only contains the\ngzip.conf file and nothing else. \nUNDERSTANDING THAT MOUNTING A DIRECTORY HIDES EXISTING FILES IN THAT DIRECTORY\nThere\u2019s one important thing to discuss at this point. In both this and in your previous\nexample, you mounted the volume as a directory, which means you\u2019ve hidden any files\nthat are stored in the /etc/nginx/conf.d directory in the container image itself. \n This is generally what happens in Linux when you mount a filesystem into a non-\nempty directory. The directory then only contains the files from the mounted filesys-\ntem, whereas the original files in that directory are inaccessible for as long as the\nfilesystem is mounted. \n In your case, this has no terrible side effects, but imagine mounting a volume to\nthe /etc directory, which usually contains many important files. This would most likely\nbreak the whole container, because all of the original files that should be in the /etc\ndirectory would no longer be there. If you need to add a file to a directory like /etc,\nyou can\u2019t use this method at all.\nMOUNTING INDIVIDUAL CONFIGMAP ENTRIES AS FILES WITHOUT HIDING OTHER FILES IN THE DIRECTORY\nNaturally, you\u2019re now wondering how to add individual files from a ConfigMap into\nan existing directory without hiding existing files stored in it. An additional subPath\nproperty on the volumeMount allows you to mount either a single file or a single direc-\ntory from the volume instead of mounting the whole volume. Perhaps this is easier to\nexplain visually (see figure 7.10).\n Say you have a configMap volume containing a myconfig.conf file, which you want\nto add to the /etc directory as someconfig.conf. You can use the subPath property to\nmount it there without affecting any other files in that directory. The relevant part of\nthe pod definition is shown in the following listing.\nPod\nContainer\nFilesystem\n/\netc/\nsomecon\ufb01g.conf\nexisting\ufb01le1\nexisting\ufb01le2\nCon\ufb01gMap: app-con\ufb01g\nmycon\ufb01g.conf\nContents\nof the \ufb01le\nanother-\ufb01le\nContents\nof the \ufb01le\ncon\ufb01gMap\nvolume\nmycon\ufb01g.conf\nanother-\ufb01le\nexisting\ufb01le1\nand existing\ufb01le2\naren\u2019t hidden.\nOnly mycon\ufb01g.conf is mounted\ninto the container (yet under a\ndifferent \ufb01lename).\nanother-\ufb01le isn\u2019t\nmounted into the\ncontainer.\nFigure 7.10\nMounting a single file from a volume\n \n"}, {"color": "green", "id": "text_154", "label": "211\nDecoupling configuration with a ConfigMap\nspec:\n  containers:\n  - image: some/image\n    volumeMounts:\n    - name: myvolume\n      mountPath: /etc/someconfig.conf     \n      subPath: myconfig.conf            \nThe subPath property can be used when mounting any kind of volume. Instead of\nmounting the whole volume, you can mount part of it. But this method of mounting\nindividual files has a relatively big deficiency related to updating files. You\u2019ll learn\nmore about this in the following section, but first, let\u2019s finish talking about the initial\nstate of a configMap volume by saying a few words about file permissions.\nSETTING THE FILE PERMISSIONS FOR FILES IN A CONFIGMAP VOLUME\nBy default, the permissions on all files in a configMap volume are set to 644 (-rw-r\u2014r--).\nYou can change this by setting the defaultMode property in the volume spec, as shown\nin the following listing.\n  volumes:\n  - name: config\n    configMap:\n      name: fortune-config\n      defaultMode: \"6600\"       \nAlthough ConfigMaps should be used for non-sensitive configuration data, you may\nwant to make the file readable and writable only to the user and group the file is\nowned by, as the example in the previous listing shows. \n7.4.7\nUpdating an app\u2019s config without having to restart the app\nWe\u2019ve said that one of the drawbacks of using environment variables or command-line\narguments as a configuration source is the inability to update them while the pro-\ncess is running. Using a ConfigMap and exposing it through a volume brings the\nability to update the configuration without having to recreate the pod or even restart\nthe container. \n When you update a ConfigMap, the files in all the volumes referencing it are\nupdated. It\u2019s then up to the process to detect that they\u2019ve been changed and reload\nthem. But Kubernetes will most likely eventually also support sending a signal to the\ncontainer after updating the files.\nWARNING\nBe aware that as I\u2019m writing this, it takes a surprisingly long time\nfor the files to be updated after you update the ConfigMap (it can take up to\none whole minute).\nListing 7.17\nA pod with a specific config map entry mounted into a specific file\nListing 7.18\nSetting file permissions: fortune-pod-configmap-volume-defaultMode.yaml \nYou\u2019re mounting into \na file, not a directory.\nInstead of mounting the whole \nvolume, you\u2019re only mounting \nthe myconfig.conf entry.\nThis sets the permissions \nfor all files to -rw-rw------.\n \n", "shape": "dot", "size": 10, "title": "211\nDecoupling configuration with a ConfigMap\nspec:\n  containers:\n  - image: some/image\n    volumeMounts:\n    - name: myvolume\n      mountPath: /etc/someconfig.conf     \n      subPath: myconfig.conf            \nThe subPath property can be used when mounting any kind of volume. Instead of\nmounting the whole volume, you can mount part of it. But this method of mounting\nindividual files has a relatively big deficiency related to updating files. You\u2019ll learn\nmore about this in the following section, but first, let\u2019s finish talking about the initial\nstate of a configMap volume by saying a few words about file permissions.\nSETTING THE FILE PERMISSIONS FOR FILES IN A CONFIGMAP VOLUME\nBy default, the permissions on all files in a configMap volume are set to 644 (-rw-r\u2014r--).\nYou can change this by setting the defaultMode property in the volume spec, as shown\nin the following listing.\n  volumes:\n  - name: config\n    configMap:\n      name: fortune-config\n      defaultMode: \"6600\"       \nAlthough ConfigMaps should be used for non-sensitive configuration data, you may\nwant to make the file readable and writable only to the user and group the file is\nowned by, as the example in the previous listing shows. \n7.4.7\nUpdating an app\u2019s config without having to restart the app\nWe\u2019ve said that one of the drawbacks of using environment variables or command-line\narguments as a configuration source is the inability to update them while the pro-\ncess is running. Using a ConfigMap and exposing it through a volume brings the\nability to update the configuration without having to recreate the pod or even restart\nthe container. \n When you update a ConfigMap, the files in all the volumes referencing it are\nupdated. It\u2019s then up to the process to detect that they\u2019ve been changed and reload\nthem. But Kubernetes will most likely eventually also support sending a signal to the\ncontainer after updating the files.\nWARNING\nBe aware that as I\u2019m writing this, it takes a surprisingly long time\nfor the files to be updated after you update the ConfigMap (it can take up to\none whole minute).\nListing 7.17\nA pod with a specific config map entry mounted into a specific file\nListing 7.18\nSetting file permissions: fortune-pod-configmap-volume-defaultMode.yaml \nYou\u2019re mounting into \na file, not a directory.\nInstead of mounting the whole \nvolume, you\u2019re only mounting \nthe myconfig.conf entry.\nThis sets the permissions \nfor all files to -rw-rw------.\n \n"}, {"color": "green", "id": "text_155", "label": "212\nCHAPTER 7\nConfigMaps and Secrets: configuring applications\nEDITING A CONFIGMAP\nLet\u2019s see how you can change a ConfigMap and have the process running in the pod\nreload the files exposed in the configMap volume. You\u2019ll modify the Nginx config file\nfrom your previous example and make Nginx use the new config without restarting\nthe pod. Try switching gzip compression off by editing the fortune-config Config-\nMap with kubectl edit:\n$ kubectl edit configmap fortune-config\nOnce your editor opens, change the gzip on line to gzip off, save the file, and then\nclose the editor. The ConfigMap is then updated, and soon afterward, the actual file\nin the volume is updated as well. You can confirm this by printing the contents of the\nfile with kubectl exec:\n$ kubectl exec fortune-configmap-volume -c web-server\n\u27a5  cat /etc/nginx/conf.d/my-nginx-config.conf\nIf you don\u2019t see the update yet, wait a while and try again. It takes a while for the\nfiles to get updated. Eventually, you\u2019ll see the change in the config file, but you\u2019ll\nfind this has no effect on Nginx, because it doesn\u2019t watch the files and reload them\nautomatically. \nSIGNALING NGINX TO RELOAD THE CONFIG\nNginx will continue to compress its responses until you tell it to reload its config files,\nwhich you can do with the following command:\n$ kubectl exec fortune-configmap-volume -c web-server -- nginx -s reload\nNow, if you try hitting the server again with curl, you should see the response is no\nlonger compressed (it no longer contains the Content-Encoding: gzip header).\nYou\u2019ve effectively changed the app\u2019s config without having to restart the container or\nrecreate the pod. \nUNDERSTANDING HOW THE FILES ARE UPDATED ATOMICALLY\nYou may wonder what happens if an app can detect config file changes on its own and\nreloads them before Kubernetes has finished updating all the files in the configMap\nvolume. Luckily, this can\u2019t happen, because all the files are updated atomically, which\nmeans all updates occur at once. Kubernetes achieves this by using symbolic links. If\nyou list all the files in the mounted configMap volume, you\u2019ll see something like the\nfollowing listing.\n$ kubectl exec -it fortune-configmap-volume -c web-server -- ls -lA \n\u27a5  /etc/nginx/conf.d\ntotal 4\ndrwxr-xr-x  ... 12:15 ..4984_09_04_12_15_06.865837643\nListing 7.19\nFiles in a mounted configMap volume\n \n", "shape": "dot", "size": 10, "title": "212\nCHAPTER 7\nConfigMaps and Secrets: configuring applications\nEDITING A CONFIGMAP\nLet\u2019s see how you can change a ConfigMap and have the process running in the pod\nreload the files exposed in the configMap volume. You\u2019ll modify the Nginx config file\nfrom your previous example and make Nginx use the new config without restarting\nthe pod. Try switching gzip compression off by editing the fortune-config Config-\nMap with kubectl edit:\n$ kubectl edit configmap fortune-config\nOnce your editor opens, change the gzip on line to gzip off, save the file, and then\nclose the editor. The ConfigMap is then updated, and soon afterward, the actual file\nin the volume is updated as well. You can confirm this by printing the contents of the\nfile with kubectl exec:\n$ kubectl exec fortune-configmap-volume -c web-server\n\u27a5  cat /etc/nginx/conf.d/my-nginx-config.conf\nIf you don\u2019t see the update yet, wait a while and try again. It takes a while for the\nfiles to get updated. Eventually, you\u2019ll see the change in the config file, but you\u2019ll\nfind this has no effect on Nginx, because it doesn\u2019t watch the files and reload them\nautomatically. \nSIGNALING NGINX TO RELOAD THE CONFIG\nNginx will continue to compress its responses until you tell it to reload its config files,\nwhich you can do with the following command:\n$ kubectl exec fortune-configmap-volume -c web-server -- nginx -s reload\nNow, if you try hitting the server again with curl, you should see the response is no\nlonger compressed (it no longer contains the Content-Encoding: gzip header).\nYou\u2019ve effectively changed the app\u2019s config without having to restart the container or\nrecreate the pod. \nUNDERSTANDING HOW THE FILES ARE UPDATED ATOMICALLY\nYou may wonder what happens if an app can detect config file changes on its own and\nreloads them before Kubernetes has finished updating all the files in the configMap\nvolume. Luckily, this can\u2019t happen, because all the files are updated atomically, which\nmeans all updates occur at once. Kubernetes achieves this by using symbolic links. If\nyou list all the files in the mounted configMap volume, you\u2019ll see something like the\nfollowing listing.\n$ kubectl exec -it fortune-configmap-volume -c web-server -- ls -lA \n\u27a5  /etc/nginx/conf.d\ntotal 4\ndrwxr-xr-x  ... 12:15 ..4984_09_04_12_15_06.865837643\nListing 7.19\nFiles in a mounted configMap volume\n \n"}, {"color": "green", "id": "text_156", "label": "213\nUsing Secrets to pass sensitive data to containers\nlrwxrwxrwx  ... 12:15 ..data -\u003e ..4984_09_04_12_15_06.865837643\nlrwxrwxrwx  ... 12:15 my-nginx-config.conf -\u003e ..data/my-nginx-config.conf\nlrwxrwxrwx  ... 12:15 sleep-interval -\u003e ..data/sleep-interval\nAs you can see, the files in the mounted configMap volume are symbolic links point-\ning to files in the ..data dir. The ..data dir is also a symbolic link pointing to a direc-\ntory called ..4984_09_04_something. When the ConfigMap is updated, Kubernetes\ncreates a new directory like this, writes all the files to it, and then re-links the ..data\nsymbolic link to the new directory, effectively changing all files at once.\nUNDERSTANDING THAT FILES MOUNTED INTO EXISTING DIRECTORIES DON\u2019T GET UPDATED\nOne big caveat relates to updating ConfigMap-backed volumes. If you\u2019ve mounted a\nsingle file in the container instead of the whole volume, the file will not be updated!\nAt least, this is true at the time of writing this chapter. \n For now, if you need to add an individual file and have it updated when you update\nits source ConfigMap, one workaround is to mount the whole volume into a different\ndirectory and then create a symbolic link pointing to the file in question. The sym-\nlink can either be created in the container image itself, or you could create the\nsymlink when the container starts.\nUNDERSTANDING THE CONSEQUENCES OF UPDATING A CONFIGMAP\nOne of the most important features of containers is their immutability, which allows\nus to be certain that no differences exist between multiple running containers created\nfrom the same image, so is it wrong to bypass this immutability by modifying a Config-\nMap used by running containers? \n The main problem occurs when the app doesn\u2019t support reloading its configura-\ntion. This results in different running instances being configured differently\u2014those\npods that are created after the ConfigMap is changed will use the new config, whereas\nthe old pods will still use the old one. And this isn\u2019t limited to new pods. If a pod\u2019s con-\ntainer is restarted (for whatever reason), the new process will also see the new config.\nTherefore, if the app doesn\u2019t reload its config automatically, modifying an existing\nConfigMap (while pods are using it) may not be a good idea. \n If the app does support reloading, modifying the ConfigMap usually isn\u2019t such a\nbig deal, but you do need to be aware that because files in the ConfigMap volumes\naren\u2019t updated synchronously across all running instances, the files in individual pods\nmay be out of sync for up to a whole minute.\n7.5\nUsing Secrets to pass sensitive data to containers\nAll the information you\u2019ve passed to your containers so far is regular, non-sensitive\nconfiguration data that doesn\u2019t need to be kept secure. But as we mentioned at the\nstart of the chapter, the config usually also includes sensitive information, such as cre-\ndentials and private encryption keys, which need to be kept secure.\n \n", "shape": "dot", "size": 10, "title": "213\nUsing Secrets to pass sensitive data to containers\nlrwxrwxrwx  ... 12:15 ..data -\u003e ..4984_09_04_12_15_06.865837643\nlrwxrwxrwx  ... 12:15 my-nginx-config.conf -\u003e ..data/my-nginx-config.conf\nlrwxrwxrwx  ... 12:15 sleep-interval -\u003e ..data/sleep-interval\nAs you can see, the files in the mounted configMap volume are symbolic links point-\ning to files in the ..data dir. The ..data dir is also a symbolic link pointing to a direc-\ntory called ..4984_09_04_something. When the ConfigMap is updated, Kubernetes\ncreates a new directory like this, writes all the files to it, and then re-links the ..data\nsymbolic link to the new directory, effectively changing all files at once.\nUNDERSTANDING THAT FILES MOUNTED INTO EXISTING DIRECTORIES DON\u2019T GET UPDATED\nOne big caveat relates to updating ConfigMap-backed volumes. If you\u2019ve mounted a\nsingle file in the container instead of the whole volume, the file will not be updated!\nAt least, this is true at the time of writing this chapter. \n For now, if you need to add an individual file and have it updated when you update\nits source ConfigMap, one workaround is to mount the whole volume into a different\ndirectory and then create a symbolic link pointing to the file in question. The sym-\nlink can either be created in the container image itself, or you could create the\nsymlink when the container starts.\nUNDERSTANDING THE CONSEQUENCES OF UPDATING A CONFIGMAP\nOne of the most important features of containers is their immutability, which allows\nus to be certain that no differences exist between multiple running containers created\nfrom the same image, so is it wrong to bypass this immutability by modifying a Config-\nMap used by running containers? \n The main problem occurs when the app doesn\u2019t support reloading its configura-\ntion. This results in different running instances being configured differently\u2014those\npods that are created after the ConfigMap is changed will use the new config, whereas\nthe old pods will still use the old one. And this isn\u2019t limited to new pods. If a pod\u2019s con-\ntainer is restarted (for whatever reason), the new process will also see the new config.\nTherefore, if the app doesn\u2019t reload its config automatically, modifying an existing\nConfigMap (while pods are using it) may not be a good idea. \n If the app does support reloading, modifying the ConfigMap usually isn\u2019t such a\nbig deal, but you do need to be aware that because files in the ConfigMap volumes\naren\u2019t updated synchronously across all running instances, the files in individual pods\nmay be out of sync for up to a whole minute.\n7.5\nUsing Secrets to pass sensitive data to containers\nAll the information you\u2019ve passed to your containers so far is regular, non-sensitive\nconfiguration data that doesn\u2019t need to be kept secure. But as we mentioned at the\nstart of the chapter, the config usually also includes sensitive information, such as cre-\ndentials and private encryption keys, which need to be kept secure.\n \n"}, {"color": "green", "id": "text_157", "label": "214\nCHAPTER 7\nConfigMaps and Secrets: configuring applications\n7.5.1\nIntroducing Secrets\nTo store and distribute such information, Kubernetes provides a separate object called\na Secret. Secrets are much like ConfigMaps\u2014they\u2019re also maps that hold key-value\npairs. They can be used the same way as a ConfigMap. You can\n\uf0a1Pass Secret entries to the container as environment variables\n\uf0a1Expose Secret entries as files in a volume\nKubernetes helps keep your Secrets safe by making sure each Secret is only distributed\nto the nodes that run the pods that need access to the Secret. Also, on the nodes\nthemselves, Secrets are always stored in memory and never written to physical storage,\nwhich would require wiping the disks after deleting the Secrets from them. \n On the master node itself (more specifically in etcd), Secrets used to be stored in\nunencrypted form, which meant the master node needs to be secured to keep the sensi-\ntive data stored in Secrets secure. This didn\u2019t only include keeping the etcd storage\nsecure, but also preventing unauthorized users from using the API server, because any-\none who can create pods can mount the Secret into the pod and gain access to the sen-\nsitive data through it. From Kubernetes version 1.7, etcd stores Secrets in encrypted\nform, making the system much more secure. Because of this, it\u2019s imperative you prop-\nerly choose when to use a Secret or a ConfigMap. Choosing between them is simple:\n\uf0a1Use a ConfigMap to store non-sensitive, plain configuration data.\n\uf0a1Use a Secret to store any data that is sensitive in nature and needs to be kept\nunder key. If a config file includes both sensitive and not-sensitive data, you\nshould store the file in a Secret.\nYou already used Secrets in chapter 5, when you created a Secret to hold the TLS certifi-\ncate needed for the Ingress resource. Now you\u2019ll explore Secrets in more detail.\n7.5.2\nIntroducing the default token Secret\nYou\u2019ll start learning about Secrets by examining a Secret that\u2019s mounted into every\ncontainer you run. You may have noticed it when using kubectl describe on a pod.\nThe command\u2019s output has always contained something like this:\nVolumes:\n  default-token-cfee9:\n    Type:       Secret (a volume populated by a Secret)\n    SecretName: default-token-cfee9\nEvery pod has a secret volume attached to it automatically. The volume in the previ-\nous kubectl describe output refers to a Secret called default-token-cfee9. Because\nSecrets are resources, you can list them with kubectl get secrets and find the\ndefault-token Secret in that list. Let\u2019s see:\n$ kubectl get secrets\nNAME                  TYPE                                  DATA      AGE\ndefault-token-cfee9   kubernetes.io/service-account-token   3         39d\n \n", "shape": "dot", "size": 10, "title": "214\nCHAPTER 7\nConfigMaps and Secrets: configuring applications\n7.5.1\nIntroducing Secrets\nTo store and distribute such information, Kubernetes provides a separate object called\na Secret. Secrets are much like ConfigMaps\u2014they\u2019re also maps that hold key-value\npairs. They can be used the same way as a ConfigMap. You can\n\uf0a1Pass Secret entries to the container as environment variables\n\uf0a1Expose Secret entries as files in a volume\nKubernetes helps keep your Secrets safe by making sure each Secret is only distributed\nto the nodes that run the pods that need access to the Secret. Also, on the nodes\nthemselves, Secrets are always stored in memory and never written to physical storage,\nwhich would require wiping the disks after deleting the Secrets from them. \n On the master node itself (more specifically in etcd), Secrets used to be stored in\nunencrypted form, which meant the master node needs to be secured to keep the sensi-\ntive data stored in Secrets secure. This didn\u2019t only include keeping the etcd storage\nsecure, but also preventing unauthorized users from using the API server, because any-\none who can create pods can mount the Secret into the pod and gain access to the sen-\nsitive data through it. From Kubernetes version 1.7, etcd stores Secrets in encrypted\nform, making the system much more secure. Because of this, it\u2019s imperative you prop-\nerly choose when to use a Secret or a ConfigMap. Choosing between them is simple:\n\uf0a1Use a ConfigMap to store non-sensitive, plain configuration data.\n\uf0a1Use a Secret to store any data that is sensitive in nature and needs to be kept\nunder key. If a config file includes both sensitive and not-sensitive data, you\nshould store the file in a Secret.\nYou already used Secrets in chapter 5, when you created a Secret to hold the TLS certifi-\ncate needed for the Ingress resource. Now you\u2019ll explore Secrets in more detail.\n7.5.2\nIntroducing the default token Secret\nYou\u2019ll start learning about Secrets by examining a Secret that\u2019s mounted into every\ncontainer you run. You may have noticed it when using kubectl describe on a pod.\nThe command\u2019s output has always contained something like this:\nVolumes:\n  default-token-cfee9:\n    Type:       Secret (a volume populated by a Secret)\n    SecretName: default-token-cfee9\nEvery pod has a secret volume attached to it automatically. The volume in the previ-\nous kubectl describe output refers to a Secret called default-token-cfee9. Because\nSecrets are resources, you can list them with kubectl get secrets and find the\ndefault-token Secret in that list. Let\u2019s see:\n$ kubectl get secrets\nNAME                  TYPE                                  DATA      AGE\ndefault-token-cfee9   kubernetes.io/service-account-token   3         39d\n \n"}, {"color": "green", "id": "text_158", "label": "215\nUsing Secrets to pass sensitive data to containers\nYou can also use kubectl describe to learn a bit more about it, as shown in the follow-\ning listing.\n$ kubectl describe secrets\nName:        default-token-cfee9\nNamespace:   default\nLabels:      \u003cnone\u003e\nAnnotations: kubernetes.io/service-account.name=default\n             kubernetes.io/service-account.uid=cc04bb39-b53f-42010af00237\nType:        kubernetes.io/service-account-token\nData\n====\nca.crt:      1139 bytes                                   \nnamespace:   7 bytes                                      \ntoken:       eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9...      \nYou can see that the Secret contains three entries\u2014ca.crt, namespace, and token\u2014\nwhich represent everything you need to securely talk to the Kubernetes API server\nfrom within your pods, should you need to do that. Although ideally you want your\napplication to be completely Kubernetes-agnostic, when there\u2019s no alternative other\nthan to talk to Kubernetes directly, you\u2019ll use the files provided through this secret\nvolume. \n The kubectl describe pod command shows where the secret volume is mounted:\nMounts:\n  /var/run/secrets/kubernetes.io/serviceaccount from default-token-cfee9\nNOTE\nBy default, the default-token Secret is mounted into every container,\nbut you can disable that in each pod by setting the automountService-\nAccountToken field in the pod spec to false or by setting it to false on the\nservice account the pod is using. (You\u2019ll learn about service accounts later in\nthe book.)\nTo help you visualize where and how the default token Secret is mounted, see fig-\nure 7.11.\n We\u2019ve said Secrets are like ConfigMaps, so because this Secret contains three\nentries, you can expect to see three files in the directory the secret volume is mounted\ninto. You can check this easily with kubectl exec:\n$ kubectl exec mypod ls /var/run/secrets/kubernetes.io/serviceaccount/\nca.crt\nnamespace\ntoken\nYou\u2019ll see how your app can use these files to access the API server in the next chapter.\nListing 7.20\nDescribing a Secret\nThis secret \ncontains three \nentries.\n \n", "shape": "dot", "size": 10, "title": "215\nUsing Secrets to pass sensitive data to containers\nYou can also use kubectl describe to learn a bit more about it, as shown in the follow-\ning listing.\n$ kubectl describe secrets\nName:        default-token-cfee9\nNamespace:   default\nLabels:      \u003cnone\u003e\nAnnotations: kubernetes.io/service-account.name=default\n             kubernetes.io/service-account.uid=cc04bb39-b53f-42010af00237\nType:        kubernetes.io/service-account-token\nData\n====\nca.crt:      1139 bytes                                   \nnamespace:   7 bytes                                      \ntoken:       eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9...      \nYou can see that the Secret contains three entries\u2014ca.crt, namespace, and token\u2014\nwhich represent everything you need to securely talk to the Kubernetes API server\nfrom within your pods, should you need to do that. Although ideally you want your\napplication to be completely Kubernetes-agnostic, when there\u2019s no alternative other\nthan to talk to Kubernetes directly, you\u2019ll use the files provided through this secret\nvolume. \n The kubectl describe pod command shows where the secret volume is mounted:\nMounts:\n  /var/run/secrets/kubernetes.io/serviceaccount from default-token-cfee9\nNOTE\nBy default, the default-token Secret is mounted into every container,\nbut you can disable that in each pod by setting the automountService-\nAccountToken field in the pod spec to false or by setting it to false on the\nservice account the pod is using. (You\u2019ll learn about service accounts later in\nthe book.)\nTo help you visualize where and how the default token Secret is mounted, see fig-\nure 7.11.\n We\u2019ve said Secrets are like ConfigMaps, so because this Secret contains three\nentries, you can expect to see three files in the directory the secret volume is mounted\ninto. You can check this easily with kubectl exec:\n$ kubectl exec mypod ls /var/run/secrets/kubernetes.io/serviceaccount/\nca.crt\nnamespace\ntoken\nYou\u2019ll see how your app can use these files to access the API server in the next chapter.\nListing 7.20\nDescribing a Secret\nThis secret \ncontains three \nentries.\n \n"}, {"color": "green", "id": "text_159", "label": "216\nCHAPTER 7\nConfigMaps and Secrets: configuring applications\n7.5.3\nCreating a Secret\nNow, you\u2019ll create your own little Secret. You\u2019ll improve your fortune-serving Nginx\ncontainer by configuring it to also serve HTTPS traffic. For this, you need to create a\ncertificate and a private key. The private key needs to be kept secure, so you\u2019ll put it\nand the certificate into a Secret.\n First, generate the certificate and private key files (do this on your local machine).\nYou can also use the files in the book\u2019s code archive (the cert and key files are in the\nfortune-https directory):\n$ openssl genrsa -out https.key 2048\n$ openssl req -new -x509 -key https.key -out https.cert -days 3650 -subj \n/CN=www.kubia-example.com\nNow, to help better demonstrate a few things about Secrets, create an additional\ndummy file called foo and make it contain the string bar. You\u2019ll understand why you\nneed to do this in a moment or two:\n$ echo bar \u003e foo\nNow you can use kubectl create secret to create a Secret from the three files:\n$ kubectl create secret generic fortune-https --from-file=https.key\n\u27a5  --from-file=https.cert --from-file=foo\nsecret \"fortune-https\" created\nThis isn\u2019t very different from creating ConfigMaps. In this case, you\u2019re creating a\ngeneric Secret called fortune-https and including two entries in it (https.key with\nthe contents of the https.key file and likewise for the https.cert key/file). As you\nlearned earlier, you could also include the whole directory with --from-file=fortune-\nhttps instead of specifying each file individually.\nPod\nContainer\nFilesystem\n/\nvar/\nrun/\nsecrets/\nkubernetes.io/\nserviceaccount/\nDefault token Secret\nDefault token\nsecret\nvolume\nca.crt\n...\n...\n...\nnamespace\ntoken\nFigure 7.11\nThe default-token Secret is created automatically and a corresponding \nvolume is mounted in each pod automatically.\n \n", "shape": "dot", "size": 10, "title": "216\nCHAPTER 7\nConfigMaps and Secrets: configuring applications\n7.5.3\nCreating a Secret\nNow, you\u2019ll create your own little Secret. You\u2019ll improve your fortune-serving Nginx\ncontainer by configuring it to also serve HTTPS traffic. For this, you need to create a\ncertificate and a private key. The private key needs to be kept secure, so you\u2019ll put it\nand the certificate into a Secret.\n First, generate the certificate and private key files (do this on your local machine).\nYou can also use the files in the book\u2019s code archive (the cert and key files are in the\nfortune-https directory):\n$ openssl genrsa -out https.key 2048\n$ openssl req -new -x509 -key https.key -out https.cert -days 3650 -subj \n/CN=www.kubia-example.com\nNow, to help better demonstrate a few things about Secrets, create an additional\ndummy file called foo and make it contain the string bar. You\u2019ll understand why you\nneed to do this in a moment or two:\n$ echo bar \u003e foo\nNow you can use kubectl create secret to create a Secret from the three files:\n$ kubectl create secret generic fortune-https --from-file=https.key\n\u27a5  --from-file=https.cert --from-file=foo\nsecret \"fortune-https\" created\nThis isn\u2019t very different from creating ConfigMaps. In this case, you\u2019re creating a\ngeneric Secret called fortune-https and including two entries in it (https.key with\nthe contents of the https.key file and likewise for the https.cert key/file). As you\nlearned earlier, you could also include the whole directory with --from-file=fortune-\nhttps instead of specifying each file individually.\nPod\nContainer\nFilesystem\n/\nvar/\nrun/\nsecrets/\nkubernetes.io/\nserviceaccount/\nDefault token Secret\nDefault token\nsecret\nvolume\nca.crt\n...\n...\n...\nnamespace\ntoken\nFigure 7.11\nThe default-token Secret is created automatically and a corresponding \nvolume is mounted in each pod automatically.\n \n"}, {"color": "green", "id": "text_160", "label": "217\nUsing Secrets to pass sensitive data to containers\nNOTE\nYou\u2019re creating a generic Secret, but you could also have created a tls\nSecret with the kubectl create secret tls command, as you did in chapter 5.\nThis would create the Secret with different entry names, though.\n7.5.4\nComparing ConfigMaps and Secrets\nSecrets and ConfigMaps have a pretty big difference. This is what drove Kubernetes\ndevelopers to create ConfigMaps after Kubernetes had already supported Secrets for a\nwhile. The following listing shows the YAML of the Secret you created.\n$ kubectl get secret fortune-https -o yaml\napiVersion: v1\ndata:\n  foo: YmFyCg==\n  https.cert: LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk1JSURCekNDQ...\n  https.key: LS0tLS1CRUdJTiBSU0EgUFJJVkFURSBLRVktLS0tLQpNSUlFcE...\nkind: Secret\n...\nNow compare this to the YAML of the ConfigMap you created earlier, which is shown\nin the following listing.\n$ kubectl get configmap fortune-config -o yaml\napiVersion: v1\ndata:\n  my-nginx-config.conf: |\n    server {\n      ...\n    }\n  sleep-interval: |\n    25\nkind: ConfigMap\n...\nNotice the difference? The contents of a Secret\u2019s entries are shown as Base64-encoded\nstrings, whereas those of a ConfigMap are shown in clear text. This initially made\nworking with Secrets in YAML and JSON manifests a bit more painful, because you\nhad to encode and decode them when setting and reading their entries. \nUSING SECRETS FOR BINARY DATA\nThe reason for using Base64 encoding is simple. A Secret\u2019s entries can contain binary\nvalues, not only plain-text. Base64 encoding allows you to include the binary data in\nYAML or JSON, which are both plain-text formats. \nTIP\nYou can use Secrets even for non-sensitive binary data, but be aware that\nthe maximum size of a Secret is limited to 1MB.\nListing 7.21\nA Secret\u2019s YAML definition\nListing 7.22\nA ConfigMap\u2019s YAML definition\n \n", "shape": "dot", "size": 10, "title": "217\nUsing Secrets to pass sensitive data to containers\nNOTE\nYou\u2019re creating a generic Secret, but you could also have created a tls\nSecret with the kubectl create secret tls command, as you did in chapter 5.\nThis would create the Secret with different entry names, though.\n7.5.4\nComparing ConfigMaps and Secrets\nSecrets and ConfigMaps have a pretty big difference. This is what drove Kubernetes\ndevelopers to create ConfigMaps after Kubernetes had already supported Secrets for a\nwhile. The following listing shows the YAML of the Secret you created.\n$ kubectl get secret fortune-https -o yaml\napiVersion: v1\ndata:\n  foo: YmFyCg==\n  https.cert: LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk1JSURCekNDQ...\n  https.key: LS0tLS1CRUdJTiBSU0EgUFJJVkFURSBLRVktLS0tLQpNSUlFcE...\nkind: Secret\n...\nNow compare this to the YAML of the ConfigMap you created earlier, which is shown\nin the following listing.\n$ kubectl get configmap fortune-config -o yaml\napiVersion: v1\ndata:\n  my-nginx-config.conf: |\n    server {\n      ...\n    }\n  sleep-interval: |\n    25\nkind: ConfigMap\n...\nNotice the difference? The contents of a Secret\u2019s entries are shown as Base64-encoded\nstrings, whereas those of a ConfigMap are shown in clear text. This initially made\nworking with Secrets in YAML and JSON manifests a bit more painful, because you\nhad to encode and decode them when setting and reading their entries. \nUSING SECRETS FOR BINARY DATA\nThe reason for using Base64 encoding is simple. A Secret\u2019s entries can contain binary\nvalues, not only plain-text. Base64 encoding allows you to include the binary data in\nYAML or JSON, which are both plain-text formats. \nTIP\nYou can use Secrets even for non-sensitive binary data, but be aware that\nthe maximum size of a Secret is limited to 1MB.\nListing 7.21\nA Secret\u2019s YAML definition\nListing 7.22\nA ConfigMap\u2019s YAML definition\n \n"}, {"color": "green", "id": "text_161", "label": "218\nCHAPTER 7\nConfigMaps and Secrets: configuring applications\nINTRODUCING THE STRINGDATA FIELD\nBecause not all sensitive data is in binary form, Kubernetes also allows setting a Secret\u2019s\nvalues through the stringData field. The following listing shows how it\u2019s used.\nkind: Secret\napiVersion: v1\nstringData:           \n  foo: plain text      \ndata:\n  https.cert: LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk1JSURCekNDQ...\n  https.key: LS0tLS1CRUdJTiBSU0EgUFJJVkFURSBLRVktLS0tLQpNSUlFcE...\nThe stringData field is write-only (note: write-only, not read-only). It can only be\nused to set values. When you retrieve the Secret\u2019s YAML with kubectl get -o yaml, the\nstringData field will not be shown. Instead, all entries you specified in the string-\nData field (such as the foo entry in the previous example) will be shown under data\nand will be Base64-encoded like all the other entries. \nREADING A SECRET\u2019S ENTRY IN A POD\nWhen you expose the Secret to a container through a secret volume, the value of the\nSecret entry is decoded and written to the file in its actual form (regardless if it\u2019s plain\ntext or binary). The same is also true when exposing the Secret entry through an envi-\nronment variable. In both cases, the app doesn\u2019t need to decode it, but can read the\nfile\u2019s contents or look up the environment variable value and use it directly.\n7.5.5\nUsing the Secret in a pod\nWith your fortune-https Secret containing both the cert and key files, all you need to\ndo now is configure Nginx to use them. \nMODIFYING THE FORTUNE-CONFIG CONFIGMAP TO ENABLE HTTPS\nFor this, you need to modify the config file again by editing the ConfigMap:\n$ kubectl edit configmap fortune-config\nAfter the text editor opens, modify the part that defines the contents of the my-nginx-\nconfig.conf entry so it looks like the following listing.\n...\ndata:\n  my-nginx-config.conf: |\n    server {\n      listen              80;\n      listen              443 ssl;\n      server_name         www.kubia-example.com;\nListing 7.23\nAdding plain text entries to a Secret using the stringData field\nListing 7.24\nModifying the fortune-config ConfigMap\u2019s data\nThe stringData can be used \nfor non-binary Secret data.\nSee, \u201cplain text\u201d is not Base64-encoded.\n \n", "shape": "dot", "size": 10, "title": "218\nCHAPTER 7\nConfigMaps and Secrets: configuring applications\nINTRODUCING THE STRINGDATA FIELD\nBecause not all sensitive data is in binary form, Kubernetes also allows setting a Secret\u2019s\nvalues through the stringData field. The following listing shows how it\u2019s used.\nkind: Secret\napiVersion: v1\nstringData:           \n  foo: plain text      \ndata:\n  https.cert: LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk1JSURCekNDQ...\n  https.key: LS0tLS1CRUdJTiBSU0EgUFJJVkFURSBLRVktLS0tLQpNSUlFcE...\nThe stringData field is write-only (note: write-only, not read-only). It can only be\nused to set values. When you retrieve the Secret\u2019s YAML with kubectl get -o yaml, the\nstringData field will not be shown. Instead, all entries you specified in the string-\nData field (such as the foo entry in the previous example) will be shown under data\nand will be Base64-encoded like all the other entries. \nREADING A SECRET\u2019S ENTRY IN A POD\nWhen you expose the Secret to a container through a secret volume, the value of the\nSecret entry is decoded and written to the file in its actual form (regardless if it\u2019s plain\ntext or binary). The same is also true when exposing the Secret entry through an envi-\nronment variable. In both cases, the app doesn\u2019t need to decode it, but can read the\nfile\u2019s contents or look up the environment variable value and use it directly.\n7.5.5\nUsing the Secret in a pod\nWith your fortune-https Secret containing both the cert and key files, all you need to\ndo now is configure Nginx to use them. \nMODIFYING THE FORTUNE-CONFIG CONFIGMAP TO ENABLE HTTPS\nFor this, you need to modify the config file again by editing the ConfigMap:\n$ kubectl edit configmap fortune-config\nAfter the text editor opens, modify the part that defines the contents of the my-nginx-\nconfig.conf entry so it looks like the following listing.\n...\ndata:\n  my-nginx-config.conf: |\n    server {\n      listen              80;\n      listen              443 ssl;\n      server_name         www.kubia-example.com;\nListing 7.23\nAdding plain text entries to a Secret using the stringData field\nListing 7.24\nModifying the fortune-config ConfigMap\u2019s data\nThe stringData can be used \nfor non-binary Secret data.\nSee, \u201cplain text\u201d is not Base64-encoded.\n \n"}, {"color": "green", "id": "text_162", "label": "219\nUsing Secrets to pass sensitive data to containers\n      ssl_certificate     certs/https.cert;           \n      ssl_certificate_key certs/https.key;            \n      ssl_protocols       TLSv1 TLSv1.1 TLSv1.2;\n      ssl_ciphers         HIGH:!aNULL:!MD5;\n      location / {\n        root   /usr/share/nginx/html;\n        index  index.html index.htm;\n      }\n    }\n  sleep-interval: |\n...\nThis configures the server to read the certificate and key files from /etc/nginx/certs,\nso you\u2019ll need to mount the secret volume there. \nMOUNTING THE FORTUNE-HTTPS SECRET IN A POD\nNext, you\u2019ll create a new fortune-https pod and mount the secret volume holding\nthe certificate and key into the proper location in the web-server container, as shown\nin the following listing.\napiVersion: v1\nkind: Pod\nmetadata:\n  name: fortune-https\nspec:\n  containers:\n  - image: luksa/fortune:env\n    name: html-generator\n    env:\n    - name: INTERVAL\n      valueFrom: \n        configMapKeyRef:\n          name: fortune-config\n          key: sleep-interval\n    volumeMounts:\n    - name: html\n      mountPath: /var/htdocs\n  - image: nginx:alpine\n    name: web-server\n    volumeMounts:\n    - name: html\n      mountPath: /usr/share/nginx/html\n      readOnly: true\n    - name: config\n      mountPath: /etc/nginx/conf.d\n      readOnly: true\n    - name: certs                         \n      mountPath: /etc/nginx/certs/        \n      readOnly: true                      \n    ports:\n    - containerPort: 80\nListing 7.25\nYAML definition of the fortune-https pod: fortune-pod-https.yaml\nThe paths are \nrelative to /etc/nginx.\nYou configured Nginx to read the cert and \nkey file from /etc/nginx/certs, so you need \nto mount the Secret volume there.\n \n", "shape": "dot", "size": 10, "title": "219\nUsing Secrets to pass sensitive data to containers\n      ssl_certificate     certs/https.cert;           \n      ssl_certificate_key certs/https.key;            \n      ssl_protocols       TLSv1 TLSv1.1 TLSv1.2;\n      ssl_ciphers         HIGH:!aNULL:!MD5;\n      location / {\n        root   /usr/share/nginx/html;\n        index  index.html index.htm;\n      }\n    }\n  sleep-interval: |\n...\nThis configures the server to read the certificate and key files from /etc/nginx/certs,\nso you\u2019ll need to mount the secret volume there. \nMOUNTING THE FORTUNE-HTTPS SECRET IN A POD\nNext, you\u2019ll create a new fortune-https pod and mount the secret volume holding\nthe certificate and key into the proper location in the web-server container, as shown\nin the following listing.\napiVersion: v1\nkind: Pod\nmetadata:\n  name: fortune-https\nspec:\n  containers:\n  - image: luksa/fortune:env\n    name: html-generator\n    env:\n    - name: INTERVAL\n      valueFrom: \n        configMapKeyRef:\n          name: fortune-config\n          key: sleep-interval\n    volumeMounts:\n    - name: html\n      mountPath: /var/htdocs\n  - image: nginx:alpine\n    name: web-server\n    volumeMounts:\n    - name: html\n      mountPath: /usr/share/nginx/html\n      readOnly: true\n    - name: config\n      mountPath: /etc/nginx/conf.d\n      readOnly: true\n    - name: certs                         \n      mountPath: /etc/nginx/certs/        \n      readOnly: true                      \n    ports:\n    - containerPort: 80\nListing 7.25\nYAML definition of the fortune-https pod: fortune-pod-https.yaml\nThe paths are \nrelative to /etc/nginx.\nYou configured Nginx to read the cert and \nkey file from /etc/nginx/certs, so you need \nto mount the Secret volume there.\n \n"}, {"color": "green", "id": "text_163", "label": "220\nCHAPTER 7\nConfigMaps and Secrets: configuring applications\n    - containerPort: 443\n  volumes:\n  - name: html\n    emptyDir: {}\n  - name: config\n    configMap:\n      name: fortune-config\n      items:\n      - key: my-nginx-config.conf\n        path: https.conf\n  - name: certs                            \n    secret:                                \n      secretName: fortune-https            \nMuch is going on in this pod descriptor, so let me help you visualize it. Figure 7.12\nshows the components defined in the YAML. The default-token Secret, volume, and\nvolume mount, which aren\u2019t part of the YAML, but are added to your pod automati-\ncally, aren\u2019t shown in the figure.\nNOTE\nLike configMap volumes, secret volumes also support specifying file\npermissions for the files exposed in the volume through the defaultMode\nproperty.\nYou define the secret \nvolume here, referring to \nthe fortune-https Secret.\nContainer: web-server\nContainer: html-generator\nSecret: fortune-https\nDefault token Secret and volume not shown\nsecret\nvolume:\ncerts\nemptyDir\nvolume:\nhtml\ncon\ufb01gMap\nvolume:\ncon\ufb01g\nhttps.cert\n...\n...\n...\nhttps.key\nfoo\n/etc/nginx/conf.d/\n/etc/nginx/certs/\n/usr/share/nginx/html/\n/var/htdocs\nCon\ufb01gMap: fortune-con\ufb01g\nmy-nginx-con\ufb01g.conf\nserver {\n\u2026\n}\nPod\nEnvironment variables:\nINTERVAL=25\nsleep-interval\n25\nFigure 7.12\nCombining a ConfigMap and a Secret to run your fortune-https pod\n \n", "shape": "dot", "size": 10, "title": "220\nCHAPTER 7\nConfigMaps and Secrets: configuring applications\n    - containerPort: 443\n  volumes:\n  - name: html\n    emptyDir: {}\n  - name: config\n    configMap:\n      name: fortune-config\n      items:\n      - key: my-nginx-config.conf\n        path: https.conf\n  - name: certs                            \n    secret:                                \n      secretName: fortune-https            \nMuch is going on in this pod descriptor, so let me help you visualize it. Figure 7.12\nshows the components defined in the YAML. The default-token Secret, volume, and\nvolume mount, which aren\u2019t part of the YAML, but are added to your pod automati-\ncally, aren\u2019t shown in the figure.\nNOTE\nLike configMap volumes, secret volumes also support specifying file\npermissions for the files exposed in the volume through the defaultMode\nproperty.\nYou define the secret \nvolume here, referring to \nthe fortune-https Secret.\nContainer: web-server\nContainer: html-generator\nSecret: fortune-https\nDefault token Secret and volume not shown\nsecret\nvolume:\ncerts\nemptyDir\nvolume:\nhtml\ncon\ufb01gMap\nvolume:\ncon\ufb01g\nhttps.cert\n...\n...\n...\nhttps.key\nfoo\n/etc/nginx/conf.d/\n/etc/nginx/certs/\n/usr/share/nginx/html/\n/var/htdocs\nCon\ufb01gMap: fortune-con\ufb01g\nmy-nginx-con\ufb01g.conf\nserver {\n\u2026\n}\nPod\nEnvironment variables:\nINTERVAL=25\nsleep-interval\n25\nFigure 7.12\nCombining a ConfigMap and a Secret to run your fortune-https pod\n \n"}, {"color": "green", "id": "text_164", "label": "221\nUsing Secrets to pass sensitive data to containers\nTESTING WHETHER NGINX IS USING THE CERT AND KEY FROM THE SECRET\nOnce the pod is running, you can see if it\u2019s serving HTTPS traffic by opening a port-\nforward tunnel to the pod\u2019s port 443 and using it to send a request to the server\nwith curl: \n$ kubectl port-forward fortune-https 8443:443 \u0026\nForwarding from 127.0.0.1:8443 -\u003e 443\nForwarding from [::1]:8443 -\u003e 443\n$ curl https://localhost:8443 -k\nIf you configured the server properly, you should get a response. You can check the\nserver\u2019s certificate to see if it matches the one you generated earlier. This can also be\ndone with curl by turning on verbose logging using the -v option, as shown in the fol-\nlowing listing.\n$ curl https://localhost:8443 -k -v\n* About to connect() to localhost port 8443 (#0)\n*   Trying ::1...\n* Connected to localhost (::1) port 8443 (#0)\n* Initializing NSS with certpath: sql:/etc/pki/nssdb\n* skipping SSL peer certificate verification\n* SSL connection using TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384\n* Server certificate:\n*   subject: CN=www.kubia-example.com          \n*   start date: aug 16 18:43:13 2016 GMT       \n*   expire date: aug 14 18:43:13 2026 GMT      \n*   common name: www.kubia-example.com         \n*   issuer: CN=www.kubia-example.com           \nUNDERSTANDING SECRET VOLUMES ARE STORED IN MEMORY\nYou successfully delivered your certificate and private key to your container by mount-\ning a secret volume in its directory tree at /etc/nginx/certs. The secret volume uses\nan in-memory filesystem (tmpfs) for the Secret files. You can see this if you list mounts\nin the container:\n$ kubectl exec fortune-https -c web-server -- mount | grep certs\ntmpfs on /etc/nginx/certs type tmpfs (ro,relatime) \nBecause tmpfs is used, the sensitive data stored in the Secret is never written to disk,\nwhere it could be compromised. \nEXPOSING A SECRET\u2019S ENTRIES THROUGH ENVIRONMENT VARIABLES\nInstead of using a volume, you could also have exposed individual entries from the\nsecret as environment variables, the way you did with the sleep-interval entry from\nthe ConfigMap. For example, if you wanted to expose the foo key from your Secret as\nenvironment variable FOO_SECRET, you\u2019d add the snippet from the following listing to\nthe container definition.\nListing 7.26\nDisplaying the server certificate sent by Nginx\nThe certificate \nmatches the one you \ncreated and stored \nin the Secret.\n \n", "shape": "dot", "size": 10, "title": "221\nUsing Secrets to pass sensitive data to containers\nTESTING WHETHER NGINX IS USING THE CERT AND KEY FROM THE SECRET\nOnce the pod is running, you can see if it\u2019s serving HTTPS traffic by opening a port-\nforward tunnel to the pod\u2019s port 443 and using it to send a request to the server\nwith curl: \n$ kubectl port-forward fortune-https 8443:443 \u0026\nForwarding from 127.0.0.1:8443 -\u003e 443\nForwarding from [::1]:8443 -\u003e 443\n$ curl https://localhost:8443 -k\nIf you configured the server properly, you should get a response. You can check the\nserver\u2019s certificate to see if it matches the one you generated earlier. This can also be\ndone with curl by turning on verbose logging using the -v option, as shown in the fol-\nlowing listing.\n$ curl https://localhost:8443 -k -v\n* About to connect() to localhost port 8443 (#0)\n*   Trying ::1...\n* Connected to localhost (::1) port 8443 (#0)\n* Initializing NSS with certpath: sql:/etc/pki/nssdb\n* skipping SSL peer certificate verification\n* SSL connection using TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384\n* Server certificate:\n*   subject: CN=www.kubia-example.com          \n*   start date: aug 16 18:43:13 2016 GMT       \n*   expire date: aug 14 18:43:13 2026 GMT      \n*   common name: www.kubia-example.com         \n*   issuer: CN=www.kubia-example.com           \nUNDERSTANDING SECRET VOLUMES ARE STORED IN MEMORY\nYou successfully delivered your certificate and private key to your container by mount-\ning a secret volume in its directory tree at /etc/nginx/certs. The secret volume uses\nan in-memory filesystem (tmpfs) for the Secret files. You can see this if you list mounts\nin the container:\n$ kubectl exec fortune-https -c web-server -- mount | grep certs\ntmpfs on /etc/nginx/certs type tmpfs (ro,relatime) \nBecause tmpfs is used, the sensitive data stored in the Secret is never written to disk,\nwhere it could be compromised. \nEXPOSING A SECRET\u2019S ENTRIES THROUGH ENVIRONMENT VARIABLES\nInstead of using a volume, you could also have exposed individual entries from the\nsecret as environment variables, the way you did with the sleep-interval entry from\nthe ConfigMap. For example, if you wanted to expose the foo key from your Secret as\nenvironment variable FOO_SECRET, you\u2019d add the snippet from the following listing to\nthe container definition.\nListing 7.26\nDisplaying the server certificate sent by Nginx\nThe certificate \nmatches the one you \ncreated and stored \nin the Secret.\n \n"}, {"color": "green", "id": "text_165", "label": "222\nCHAPTER 7\nConfigMaps and Secrets: configuring applications\n    env:\n    - name: FOO_SECRET\n      valueFrom:                  \n        secretKeyRef:             \n          name: fortune-https    \n          key: foo           \nThis is almost exactly like when you set the INTERVAL environment variable, except\nthat this time you\u2019re referring to a Secret by using secretKeyRef instead of config-\nMapKeyRef, which is used to refer to a ConfigMap.\n Even though Kubernetes enables you to expose Secrets through environment vari-\nables, it may not be the best idea to use this feature. Applications usually dump envi-\nronment variables in error reports or even write them to the application log at startup,\nwhich may unintentionally expose them. Additionally, child processes inherit all the\nenvironment variables of the parent process, so if your app runs a third-party binary,\nyou have no way of knowing what happens with your secret data. \nTIP\nThink twice before using environment variables to pass your Secrets to\nyour container, because they may get exposed inadvertently. To be safe, always\nuse secret volumes for exposing Secrets.\n7.5.6\nUnderstanding image pull Secrets\nYou\u2019ve learned how to pass Secrets to your applications and use the data they contain.\nBut sometimes Kubernetes itself requires you to pass credentials to it\u2014for example,\nwhen you\u2019d like to use images from a private container image registry. This is also\ndone through Secrets.\n Up to now all your container images have been stored on public image registries,\nwhich don\u2019t require any special credentials to pull images from them. But most orga-\nnizations don\u2019t want their images to be available to everyone and thus use a private\nimage registry. When deploying a pod, whose container images reside in a private reg-\nistry, Kubernetes needs to know the credentials required to pull the image. Let\u2019s see\nhow to do that.\nUSING A PRIVATE IMAGE REPOSITORY ON DOCKER HUB\nDocker Hub, in addition to public image repositories, also allows you to create private\nrepositories. You can mark a repository as private by logging in at http:/\n/hub.docker\n.com with your web browser, finding the repository and checking a checkbox. \n To run a pod, which uses an image from the private repository, you need to do\ntwo things:\n\uf0a1Create a Secret holding the credentials for the Docker registry.\n\uf0a1Reference that Secret in the imagePullSecrets field of the pod manifest.\nListing 7.27\nExposing a Secret\u2019s entry as an environment variable\nThe variable should be set \nfrom the entry of a Secret.\nThe name of the Secret \nholding the key\nThe key of the Secret \nto expose\n \n", "shape": "dot", "size": 10, "title": "222\nCHAPTER 7\nConfigMaps and Secrets: configuring applications\n    env:\n    - name: FOO_SECRET\n      valueFrom:                  \n        secretKeyRef:             \n          name: fortune-https    \n          key: foo           \nThis is almost exactly like when you set the INTERVAL environment variable, except\nthat this time you\u2019re referring to a Secret by using secretKeyRef instead of config-\nMapKeyRef, which is used to refer to a ConfigMap.\n Even though Kubernetes enables you to expose Secrets through environment vari-\nables, it may not be the best idea to use this feature. Applications usually dump envi-\nronment variables in error reports or even write them to the application log at startup,\nwhich may unintentionally expose them. Additionally, child processes inherit all the\nenvironment variables of the parent process, so if your app runs a third-party binary,\nyou have no way of knowing what happens with your secret data. \nTIP\nThink twice before using environment variables to pass your Secrets to\nyour container, because they may get exposed inadvertently. To be safe, always\nuse secret volumes for exposing Secrets.\n7.5.6\nUnderstanding image pull Secrets\nYou\u2019ve learned how to pass Secrets to your applications and use the data they contain.\nBut sometimes Kubernetes itself requires you to pass credentials to it\u2014for example,\nwhen you\u2019d like to use images from a private container image registry. This is also\ndone through Secrets.\n Up to now all your container images have been stored on public image registries,\nwhich don\u2019t require any special credentials to pull images from them. But most orga-\nnizations don\u2019t want their images to be available to everyone and thus use a private\nimage registry. When deploying a pod, whose container images reside in a private reg-\nistry, Kubernetes needs to know the credentials required to pull the image. Let\u2019s see\nhow to do that.\nUSING A PRIVATE IMAGE REPOSITORY ON DOCKER HUB\nDocker Hub, in addition to public image repositories, also allows you to create private\nrepositories. You can mark a repository as private by logging in at http:/\n/hub.docker\n.com with your web browser, finding the repository and checking a checkbox. \n To run a pod, which uses an image from the private repository, you need to do\ntwo things:\n\uf0a1Create a Secret holding the credentials for the Docker registry.\n\uf0a1Reference that Secret in the imagePullSecrets field of the pod manifest.\nListing 7.27\nExposing a Secret\u2019s entry as an environment variable\nThe variable should be set \nfrom the entry of a Secret.\nThe name of the Secret \nholding the key\nThe key of the Secret \nto expose\n \n"}, {"color": "green", "id": "text_166", "label": "223\nUsing Secrets to pass sensitive data to containers\nCREATING A SECRET FOR AUTHENTICATING WITH A DOCKER REGISTRY\nCreating a Secret holding the credentials for authenticating with a Docker registry\nisn\u2019t that different from creating the generic Secret you created in section 7.5.3. You\nuse the same kubectl create secret command, but with a different type and\noptions:\n$ kubectl create secret docker-registry mydockerhubsecret \\\n  --docker-username=myusername --docker-password=mypassword \\ \n  --docker-email=my.email@provider.com\nRather than create a generic secret, you\u2019re creating a docker-registry Secret called\nmydockerhubsecret. You\u2019re specifying your Docker Hub username, password, and\nemail. If you inspect the contents of the newly created Secret with kubectl describe,\nyou\u2019ll see that it includes a single entry called .dockercfg. This is equivalent to the\n.dockercfg file in your home directory, which is created by Docker when you run the\ndocker login command.\nUSING THE DOCKER-REGISTRY SECRET IN A POD DEFINITION\nTo have Kubernetes use the Secret when pulling images from your private Docker\nHub repository, all you need to do is specify the Secret\u2019s name in the pod spec, as\nshown in the following listing.\napiVersion: v1\nkind: Pod\nmetadata:\n  name: private-pod\nspec:\n  imagePullSecrets:                 \n  - name: mydockerhubsecret         \n  containers:\n  - image: username/private:tag\n    name: main\nIn the pod definition in the previous listing, you\u2019re specifying the mydockerhubsecret\nSecret as one of the imagePullSecrets. I suggest you try this out yourself, because it\u2019s\nlikely you\u2019ll deal with private container images soon.\nNOT HAVING TO SPECIFY IMAGE PULL SECRETS ON EVERY POD\nGiven that people usually run many different pods in their systems, it makes you won-\nder if you need to add the same image pull Secrets to every pod. Luckily, that\u2019s not the\ncase. In chapter 12 you\u2019ll learn how image pull Secrets can be added to all your pods\nautomatically if you add the Secrets to a ServiceAccount.\nListing 7.28\nA pod definition using an image pull Secret: pod-with-private-image.yaml\nThis enables pulling images \nfrom a private image registry.\n \n", "shape": "dot", "size": 10, "title": "223\nUsing Secrets to pass sensitive data to containers\nCREATING A SECRET FOR AUTHENTICATING WITH A DOCKER REGISTRY\nCreating a Secret holding the credentials for authenticating with a Docker registry\nisn\u2019t that different from creating the generic Secret you created in section 7.5.3. You\nuse the same kubectl create secret command, but with a different type and\noptions:\n$ kubectl create secret docker-registry mydockerhubsecret \\\n  --docker-username=myusername --docker-password=mypassword \\ \n  --docker-email=my.email@provider.com\nRather than create a generic secret, you\u2019re creating a docker-registry Secret called\nmydockerhubsecret. You\u2019re specifying your Docker Hub username, password, and\nemail. If you inspect the contents of the newly created Secret with kubectl describe,\nyou\u2019ll see that it includes a single entry called .dockercfg. This is equivalent to the\n.dockercfg file in your home directory, which is created by Docker when you run the\ndocker login command.\nUSING THE DOCKER-REGISTRY SECRET IN A POD DEFINITION\nTo have Kubernetes use the Secret when pulling images from your private Docker\nHub repository, all you need to do is specify the Secret\u2019s name in the pod spec, as\nshown in the following listing.\napiVersion: v1\nkind: Pod\nmetadata:\n  name: private-pod\nspec:\n  imagePullSecrets:                 \n  - name: mydockerhubsecret         \n  containers:\n  - image: username/private:tag\n    name: main\nIn the pod definition in the previous listing, you\u2019re specifying the mydockerhubsecret\nSecret as one of the imagePullSecrets. I suggest you try this out yourself, because it\u2019s\nlikely you\u2019ll deal with private container images soon.\nNOT HAVING TO SPECIFY IMAGE PULL SECRETS ON EVERY POD\nGiven that people usually run many different pods in their systems, it makes you won-\nder if you need to add the same image pull Secrets to every pod. Luckily, that\u2019s not the\ncase. In chapter 12 you\u2019ll learn how image pull Secrets can be added to all your pods\nautomatically if you add the Secrets to a ServiceAccount.\nListing 7.28\nA pod definition using an image pull Secret: pod-with-private-image.yaml\nThis enables pulling images \nfrom a private image registry.\n \n"}, {"color": "green", "id": "text_167", "label": "224\nCHAPTER 7\nConfigMaps and Secrets: configuring applications\n7.6\nSummary\nThis wraps up this chapter on how to pass configuration data to containers. You\u2019ve\nlearned how to\n\uf0a1Override the default command defined in a container image in the pod definition\n\uf0a1Pass command-line arguments to the main container process\n\uf0a1Set environment variables for a container\n\uf0a1Decouple configuration from a pod specification and put it into a ConfigMap\n\uf0a1Store sensitive data in a Secret and deliver it securely to containers\n\uf0a1Create a docker-registry Secret and use it to pull images from a private image\nregistry\nIn the next chapter, you\u2019ll learn how to pass pod and container metadata to applica-\ntions running inside them. You\u2019ll also see how the default token Secret, which we\nlearned about in this chapter, is used to talk to the API server from within a pod. \n \n", "shape": "dot", "size": 10, "title": "224\nCHAPTER 7\nConfigMaps and Secrets: configuring applications\n7.6\nSummary\nThis wraps up this chapter on how to pass configuration data to containers. You\u2019ve\nlearned how to\n\uf0a1Override the default command defined in a container image in the pod definition\n\uf0a1Pass command-line arguments to the main container process\n\uf0a1Set environment variables for a container\n\uf0a1Decouple configuration from a pod specification and put it into a ConfigMap\n\uf0a1Store sensitive data in a Secret and deliver it securely to containers\n\uf0a1Create a docker-registry Secret and use it to pull images from a private image\nregistry\nIn the next chapter, you\u2019ll learn how to pass pod and container metadata to applica-\ntions running inside them. You\u2019ll also see how the default token Secret, which we\nlearned about in this chapter, is used to talk to the API server from within a pod. \n \n"}, {"color": "green", "id": "text_168", "label": "225\nAccessing pod metadata\nand other resources\nfrom applications\nApplications often need information about the environment they\u2019re running in,\nincluding details about themselves and that of other components in the cluster.\nYou\u2019ve already seen how Kubernetes enables service discovery through environ-\nment variables or DNS, but what about other information? In this chapter, you\u2019ll\nsee how certain pod and container metadata can be passed to the container and\nhow easy it is for an app running inside a container to talk to the Kubernetes API\nserver to get information about the resources deployed in the cluster and even how\nto create or modify those resources.\nThis chapter covers\n\uf0a1Using the Downward API to pass information into \ncontainers\n\uf0a1Exploring the Kubernetes REST API\n\uf0a1Leaving authentication and server verification to \nkubectl proxy\n\uf0a1Accessing the API server from within a container\n\uf0a1Understanding the ambassador container pattern\n\uf0a1Using Kubernetes client libraries\n \n", "shape": "dot", "size": 10, "title": "225\nAccessing pod metadata\nand other resources\nfrom applications\nApplications often need information about the environment they\u2019re running in,\nincluding details about themselves and that of other components in the cluster.\nYou\u2019ve already seen how Kubernetes enables service discovery through environ-\nment variables or DNS, but what about other information? In this chapter, you\u2019ll\nsee how certain pod and container metadata can be passed to the container and\nhow easy it is for an app running inside a container to talk to the Kubernetes API\nserver to get information about the resources deployed in the cluster and even how\nto create or modify those resources.\nThis chapter covers\n\uf0a1Using the Downward API to pass information into \ncontainers\n\uf0a1Exploring the Kubernetes REST API\n\uf0a1Leaving authentication and server verification to \nkubectl proxy\n\uf0a1Accessing the API server from within a container\n\uf0a1Understanding the ambassador container pattern\n\uf0a1Using Kubernetes client libraries\n \n"}, {"color": "green", "id": "text_169", "label": "226\nCHAPTER 8\nAccessing pod metadata and other resources from applications\n8.1\nPassing metadata through the Downward API\nIn the previous chapter you saw how you can pass configuration data to your appli-\ncations through environment variables or through configMap and secret volumes.\nThis works well for data that you set yourself and that is known before the pod is\nscheduled to a node and run there. But what about data that isn\u2019t known up until\nthat point\u2014such as the pod\u2019s IP, the host node\u2019s name, or even the pod\u2019s own name\n(when the name is generated; for example, when the pod is created by a ReplicaSet\nor similar controller)? And what about data that\u2019s already specified elsewhere, such\nas a pod\u2019s labels and annotations? You don\u2019t want to repeat the same information in\nmultiple places.\n Both these problems are solved by the Kubernetes Downward API. It allows you to\npass metadata about the pod and its environment through environment variables or\nfiles (in a downwardAPI volume). Don\u2019t be confused by the name. The Downward API\nisn\u2019t like a REST endpoint that your app needs to hit so it can get the data. It\u2019s a way of\nhaving environment variables or files populated with values from the pod\u2019s specifica-\ntion or status, as shown in figure 8.1.\n8.1.1\nUnderstanding the available metadata\nThe Downward API enables you to expose the pod\u2019s own metadata to the processes\nrunning inside that pod. Currently, it allows you to pass the following information to\nyour containers:\n\uf0a1The pod\u2019s name\n\uf0a1The pod\u2019s IP address\nContainer: main\nEnvironment\nvariables\nAPI server\nUsed to initialize environment\nvariables and \ufb01les in the\ndownwardAPI volume\nPod manifest\n- Metadata\n- Status\nPod\ndownwardAPI\nvolume\nApp process\nFigure 8.1\nThe Downward API exposes pod metadata through environment variables or files.\n \n", "shape": "dot", "size": 10, "title": "226\nCHAPTER 8\nAccessing pod metadata and other resources from applications\n8.1\nPassing metadata through the Downward API\nIn the previous chapter you saw how you can pass configuration data to your appli-\ncations through environment variables or through configMap and secret volumes.\nThis works well for data that you set yourself and that is known before the pod is\nscheduled to a node and run there. But what about data that isn\u2019t known up until\nthat point\u2014such as the pod\u2019s IP, the host node\u2019s name, or even the pod\u2019s own name\n(when the name is generated; for example, when the pod is created by a ReplicaSet\nor similar controller)? And what about data that\u2019s already specified elsewhere, such\nas a pod\u2019s labels and annotations? You don\u2019t want to repeat the same information in\nmultiple places.\n Both these problems are solved by the Kubernetes Downward API. It allows you to\npass metadata about the pod and its environment through environment variables or\nfiles (in a downwardAPI volume). Don\u2019t be confused by the name. The Downward API\nisn\u2019t like a REST endpoint that your app needs to hit so it can get the data. It\u2019s a way of\nhaving environment variables or files populated with values from the pod\u2019s specifica-\ntion or status, as shown in figure 8.1.\n8.1.1\nUnderstanding the available metadata\nThe Downward API enables you to expose the pod\u2019s own metadata to the processes\nrunning inside that pod. Currently, it allows you to pass the following information to\nyour containers:\n\uf0a1The pod\u2019s name\n\uf0a1The pod\u2019s IP address\nContainer: main\nEnvironment\nvariables\nAPI server\nUsed to initialize environment\nvariables and \ufb01les in the\ndownwardAPI volume\nPod manifest\n- Metadata\n- Status\nPod\ndownwardAPI\nvolume\nApp process\nFigure 8.1\nThe Downward API exposes pod metadata through environment variables or files.\n \n"}, {"color": "green", "id": "text_170", "label": "227\nPassing metadata through the Downward API\n\uf0a1The namespace the pod belongs to\n\uf0a1The name of the node the pod is running on\n\uf0a1The name of the service account the pod is running under\n\uf0a1The CPU and memory requests for each container\n\uf0a1The CPU and memory limits for each container\n\uf0a1The pod\u2019s labels\n\uf0a1The pod\u2019s annotations\nMost of the items in the list shouldn\u2019t require further explanation, except perhaps the\nservice account and CPU/memory requests and limits, which we haven\u2019t introduced\nyet. We\u2019ll cover service accounts in detail in chapter 12. For now, all you need to know\nis that a service account is the account that the pod authenticates as when talking to\nthe API server. CPU and memory requests and limits are explained in chapter 14.\nThey\u2019re the amount of CPU and memory guaranteed to a container and the maxi-\nmum amount it can get.\n Most items in the list can be passed to containers either through environment vari-\nables or through a downwardAPI volume, but labels and annotations can only be\nexposed through the volume. Part of the data can be acquired by other means (for\nexample, from the operating system directly), but the Downward API provides a sim-\npler alternative.\n Let\u2019s look at an example to pass metadata to your containerized process.\n8.1.2\nExposing metadata through environment variables\nFirst, let\u2019s look at how you can pass the pod\u2019s and container\u2019s metadata to the con-\ntainer through environment variables. You\u2019ll create a simple single-container pod\nfrom the following listing\u2019s manifest.\napiVersion: v1\nkind: Pod\nmetadata:\n  name: downward\nspec:\n  containers:\n  - name: main\n    image: busybox\n    command: [\"sleep\", \"9999999\"]\n    resources:\n      requests:\n        cpu: 15m\n        memory: 100Ki\n      limits:\n        cpu: 100m\n        memory: 4Mi\n    env:\n    - name: POD_NAME\nListing 8.1\nDownward API used in environment variables: downward-api-env.yaml\n \n", "shape": "dot", "size": 10, "title": "227\nPassing metadata through the Downward API\n\uf0a1The namespace the pod belongs to\n\uf0a1The name of the node the pod is running on\n\uf0a1The name of the service account the pod is running under\n\uf0a1The CPU and memory requests for each container\n\uf0a1The CPU and memory limits for each container\n\uf0a1The pod\u2019s labels\n\uf0a1The pod\u2019s annotations\nMost of the items in the list shouldn\u2019t require further explanation, except perhaps the\nservice account and CPU/memory requests and limits, which we haven\u2019t introduced\nyet. We\u2019ll cover service accounts in detail in chapter 12. For now, all you need to know\nis that a service account is the account that the pod authenticates as when talking to\nthe API server. CPU and memory requests and limits are explained in chapter 14.\nThey\u2019re the amount of CPU and memory guaranteed to a container and the maxi-\nmum amount it can get.\n Most items in the list can be passed to containers either through environment vari-\nables or through a downwardAPI volume, but labels and annotations can only be\nexposed through the volume. Part of the data can be acquired by other means (for\nexample, from the operating system directly), but the Downward API provides a sim-\npler alternative.\n Let\u2019s look at an example to pass metadata to your containerized process.\n8.1.2\nExposing metadata through environment variables\nFirst, let\u2019s look at how you can pass the pod\u2019s and container\u2019s metadata to the con-\ntainer through environment variables. You\u2019ll create a simple single-container pod\nfrom the following listing\u2019s manifest.\napiVersion: v1\nkind: Pod\nmetadata:\n  name: downward\nspec:\n  containers:\n  - name: main\n    image: busybox\n    command: [\"sleep\", \"9999999\"]\n    resources:\n      requests:\n        cpu: 15m\n        memory: 100Ki\n      limits:\n        cpu: 100m\n        memory: 4Mi\n    env:\n    - name: POD_NAME\nListing 8.1\nDownward API used in environment variables: downward-api-env.yaml\n \n"}, {"color": "green", "id": "text_171", "label": "228\nCHAPTER 8\nAccessing pod metadata and other resources from applications\n      valueFrom:                            \n        fieldRef:                           \n          fieldPath: metadata.name          \n    - name: POD_NAMESPACE\n      valueFrom:\n        fieldRef:\n          fieldPath: metadata.namespace\n    - name: POD_IP\n      valueFrom:\n        fieldRef:\n          fieldPath: status.podIP\n    - name: NODE_NAME\n      valueFrom:\n        fieldRef:\n          fieldPath: spec.nodeName\n    - name: SERVICE_ACCOUNT\n      valueFrom:\n        fieldRef:\n          fieldPath: spec.serviceAccountName\n    - name: CONTAINER_CPU_REQUEST_MILLICORES\n      valueFrom:                                   \n        resourceFieldRef:                          \n          resource: requests.cpu                   \n          divisor: 1m                            \n    - name: CONTAINER_MEMORY_LIMIT_KIBIBYTES\n      valueFrom:\n        resourceFieldRef:\n          resource: limits.memory\n          divisor: 1Ki\nWhen your process runs, it can look up all the environment variables you defined in\nthe pod spec. Figure 8.2 shows the environment variables and the sources of their val-\nues. The pod\u2019s name, IP, and namespace will be exposed through the POD_NAME,\nPOD_IP, and POD_NAMESPACE environment variables, respectively. The name of the\nnode the container is running on will be exposed through the NODE_NAME variable.\nThe name of the service account is made available through the SERVICE_ACCOUNT\nenvironment variable. You\u2019re also creating two environment variables that will hold\nthe amount of CPU requested for this container and the maximum amount of mem-\nory the container is allowed to consume.\n For environment variables exposing resource limits or requests, you specify a divi-\nsor. The actual value of the limit or the request will be divided by the divisor and the\nresult exposed through the environment variable. In the previous example, you\u2019re set-\nting the divisor for CPU requests to 1m (one milli-core, or one one-thousandth of a\nCPU core). Because you\u2019ve set the CPU request to 15m, the environment variable\nCONTAINER_CPU_REQUEST_MILLICORES will be set to 15. Likewise, you set the memory\nlimit to 4Mi (4 mebibytes) and the divisor to 1Ki (1 Kibibyte), so the CONTAINER_MEMORY\n_LIMIT_KIBIBYTES environment variable will be set to 4096. \nInstead of specifying an absolute value, \nyou\u2019re referencing the metadata.name \nfield from the pod manifest.\nA container\u2019s CPU and memory \nrequests and limits are referenced \nby using resourceFieldRef instead \nof fieldRef.\nFor resource fields, you \ndefine a divisor to get the \nvalue in the unit you need.\n \n", "shape": "dot", "size": 10, "title": "228\nCHAPTER 8\nAccessing pod metadata and other resources from applications\n      valueFrom:                            \n        fieldRef:                           \n          fieldPath: metadata.name          \n    - name: POD_NAMESPACE\n      valueFrom:\n        fieldRef:\n          fieldPath: metadata.namespace\n    - name: POD_IP\n      valueFrom:\n        fieldRef:\n          fieldPath: status.podIP\n    - name: NODE_NAME\n      valueFrom:\n        fieldRef:\n          fieldPath: spec.nodeName\n    - name: SERVICE_ACCOUNT\n      valueFrom:\n        fieldRef:\n          fieldPath: spec.serviceAccountName\n    - name: CONTAINER_CPU_REQUEST_MILLICORES\n      valueFrom:                                   \n        resourceFieldRef:                          \n          resource: requests.cpu                   \n          divisor: 1m                            \n    - name: CONTAINER_MEMORY_LIMIT_KIBIBYTES\n      valueFrom:\n        resourceFieldRef:\n          resource: limits.memory\n          divisor: 1Ki\nWhen your process runs, it can look up all the environment variables you defined in\nthe pod spec. Figure 8.2 shows the environment variables and the sources of their val-\nues. The pod\u2019s name, IP, and namespace will be exposed through the POD_NAME,\nPOD_IP, and POD_NAMESPACE environment variables, respectively. The name of the\nnode the container is running on will be exposed through the NODE_NAME variable.\nThe name of the service account is made available through the SERVICE_ACCOUNT\nenvironment variable. You\u2019re also creating two environment variables that will hold\nthe amount of CPU requested for this container and the maximum amount of mem-\nory the container is allowed to consume.\n For environment variables exposing resource limits or requests, you specify a divi-\nsor. The actual value of the limit or the request will be divided by the divisor and the\nresult exposed through the environment variable. In the previous example, you\u2019re set-\nting the divisor for CPU requests to 1m (one milli-core, or one one-thousandth of a\nCPU core). Because you\u2019ve set the CPU request to 15m, the environment variable\nCONTAINER_CPU_REQUEST_MILLICORES will be set to 15. Likewise, you set the memory\nlimit to 4Mi (4 mebibytes) and the divisor to 1Ki (1 Kibibyte), so the CONTAINER_MEMORY\n_LIMIT_KIBIBYTES environment variable will be set to 4096. \nInstead of specifying an absolute value, \nyou\u2019re referencing the metadata.name \nfield from the pod manifest.\nA container\u2019s CPU and memory \nrequests and limits are referenced \nby using resourceFieldRef instead \nof fieldRef.\nFor resource fields, you \ndefine a divisor to get the \nvalue in the unit you need.\n \n"}, {"color": "green", "id": "text_172", "label": "229\nPassing metadata through the Downward API\nThe divisor for CPU limits and requests can be either 1, which means one whole core,\nor 1m, which is one millicore. The divisor for memory limits/requests can be 1 (byte),\n1k (kilobyte) or 1Ki (kibibyte), 1M (megabyte) or 1Mi (mebibyte), and so on.\n After creating the pod, you can use kubectl exec to see all these environment vari-\nables in your container, as shown in the following listing.\n$ kubectl exec downward env\nPATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin\nHOSTNAME=downward\nCONTAINER_MEMORY_LIMIT_KIBIBYTES=4096\nPOD_NAME=downward\nPOD_NAMESPACE=default\nPOD_IP=10.0.0.10\nNODE_NAME=gke-kubia-default-pool-32a2cac8-sgl7\nSERVICE_ACCOUNT=default\nCONTAINER_CPU_REQUEST_MILLICORES=15\nKUBERNETES_SERVICE_HOST=10.3.240.1\nKUBERNETES_SERVICE_PORT=443\n...\nListing 8.2\nEnvironment variables in the downward pod\nPod manifest\nmetadata:\nname: downward\nnamespace: default\nspec:\nnodeName: minikube\nserviceAccountName: default\ncontainers:\n- name: main\nimage: busybox\ncommand: [\"sleep\", \"9999999\"]\nresources:\nrequests:\ncpu: 15m\nmemory: 100Ki\nlimits:\ncpu: 100m\nmemory: 4Mi\n...\nstatus:\npodIP: 172.17.0.4\n...\nPod: downward\nContainer: main\nEnvironment variables\nPOD_NAME=downward\nPOD_NAMESPACE=default\nPOD_IP=172.17.0.4\nNODE_NAME=minikube\nSERVICE_ACCOUNT=default\nCONTAINER_CPU_REQUEST_MILLICORES=15\nCONTAINER_MEMORY_LIMIT_KIBIBYTES=4096\ndivisor: 1m\ndivisor: 1Ki\nFigure 8.2\nPod metadata and attributes can be exposed to the pod through environment variables.\n \n", "shape": "dot", "size": 10, "title": "229\nPassing metadata through the Downward API\nThe divisor for CPU limits and requests can be either 1, which means one whole core,\nor 1m, which is one millicore. The divisor for memory limits/requests can be 1 (byte),\n1k (kilobyte) or 1Ki (kibibyte), 1M (megabyte) or 1Mi (mebibyte), and so on.\n After creating the pod, you can use kubectl exec to see all these environment vari-\nables in your container, as shown in the following listing.\n$ kubectl exec downward env\nPATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin\nHOSTNAME=downward\nCONTAINER_MEMORY_LIMIT_KIBIBYTES=4096\nPOD_NAME=downward\nPOD_NAMESPACE=default\nPOD_IP=10.0.0.10\nNODE_NAME=gke-kubia-default-pool-32a2cac8-sgl7\nSERVICE_ACCOUNT=default\nCONTAINER_CPU_REQUEST_MILLICORES=15\nKUBERNETES_SERVICE_HOST=10.3.240.1\nKUBERNETES_SERVICE_PORT=443\n...\nListing 8.2\nEnvironment variables in the downward pod\nPod manifest\nmetadata:\nname: downward\nnamespace: default\nspec:\nnodeName: minikube\nserviceAccountName: default\ncontainers:\n- name: main\nimage: busybox\ncommand: [\"sleep\", \"9999999\"]\nresources:\nrequests:\ncpu: 15m\nmemory: 100Ki\nlimits:\ncpu: 100m\nmemory: 4Mi\n...\nstatus:\npodIP: 172.17.0.4\n...\nPod: downward\nContainer: main\nEnvironment variables\nPOD_NAME=downward\nPOD_NAMESPACE=default\nPOD_IP=172.17.0.4\nNODE_NAME=minikube\nSERVICE_ACCOUNT=default\nCONTAINER_CPU_REQUEST_MILLICORES=15\nCONTAINER_MEMORY_LIMIT_KIBIBYTES=4096\ndivisor: 1m\ndivisor: 1Ki\nFigure 8.2\nPod metadata and attributes can be exposed to the pod through environment variables.\n \n"}, {"color": "green", "id": "text_173", "label": "230\nCHAPTER 8\nAccessing pod metadata and other resources from applications\nAll processes running inside the container can read those variables and use them how-\never they need. \n8.1.3\nPassing metadata through files in a downwardAPI volume\nIf you prefer to expose the metadata through files instead of environment variables,\nyou can define a downwardAPI volume and mount it into your container. You must use\na downwardAPI volume for exposing the pod\u2019s labels or its annotations, because nei-\nther can be exposed through environment variables. We\u2019ll discuss why later.\n As with environment variables, you need to specify each metadata field explicitly if\nyou want to have it exposed to the process. Let\u2019s see how to modify the previous exam-\nple to use a volume instead of environment variables, as shown in the following listing.\napiVersion: v1\nkind: Pod\nmetadata:\n  name: downward\n  labels:                  \n    foo: bar               \n  annotations:             \n    key1: value1           \n    key2: |                \n      multi                \n      line                 \n      value                \nspec:\n  containers:\n  - name: main\n    image: busybox\n    command: [\"sleep\", \"9999999\"]\n    resources:\n      requests:\n        cpu: 15m\n        memory: 100Ki\n      limits:\n        cpu: 100m\n        memory: 4Mi\n    volumeMounts:                        \n    - name: downward                     \n      mountPath: /etc/downward           \n  volumes:\n  - name: downward                 \n    downwardAPI:                   \n      items:\n      - path: \"podName\"                     \n        fieldRef:                           \n          fieldPath: metadata.name          \n      - path: \"podNamespace\"\n        fieldRef:\n          fieldPath: metadata.namespace\nListing 8.3\nPod with a downwardAPI volume: downward-api-volume.yaml\nThese labels and \nannotations will be \nexposed through the \ndownwardAPI volume.\nYou\u2019re mounting the \ndownward volume \nunder /etc/downward.\nYou\u2019re defining a downwardAPI \nvolume with the name downward.\nThe pod\u2019s name (from the metadata.name \nfield in the manifest) will be written to \nthe podName file.\n \n", "shape": "dot", "size": 10, "title": "230\nCHAPTER 8\nAccessing pod metadata and other resources from applications\nAll processes running inside the container can read those variables and use them how-\never they need. \n8.1.3\nPassing metadata through files in a downwardAPI volume\nIf you prefer to expose the metadata through files instead of environment variables,\nyou can define a downwardAPI volume and mount it into your container. You must use\na downwardAPI volume for exposing the pod\u2019s labels or its annotations, because nei-\nther can be exposed through environment variables. We\u2019ll discuss why later.\n As with environment variables, you need to specify each metadata field explicitly if\nyou want to have it exposed to the process. Let\u2019s see how to modify the previous exam-\nple to use a volume instead of environment variables, as shown in the following listing.\napiVersion: v1\nkind: Pod\nmetadata:\n  name: downward\n  labels:                  \n    foo: bar               \n  annotations:             \n    key1: value1           \n    key2: |                \n      multi                \n      line                 \n      value                \nspec:\n  containers:\n  - name: main\n    image: busybox\n    command: [\"sleep\", \"9999999\"]\n    resources:\n      requests:\n        cpu: 15m\n        memory: 100Ki\n      limits:\n        cpu: 100m\n        memory: 4Mi\n    volumeMounts:                        \n    - name: downward                     \n      mountPath: /etc/downward           \n  volumes:\n  - name: downward                 \n    downwardAPI:                   \n      items:\n      - path: \"podName\"                     \n        fieldRef:                           \n          fieldPath: metadata.name          \n      - path: \"podNamespace\"\n        fieldRef:\n          fieldPath: metadata.namespace\nListing 8.3\nPod with a downwardAPI volume: downward-api-volume.yaml\nThese labels and \nannotations will be \nexposed through the \ndownwardAPI volume.\nYou\u2019re mounting the \ndownward volume \nunder /etc/downward.\nYou\u2019re defining a downwardAPI \nvolume with the name downward.\nThe pod\u2019s name (from the metadata.name \nfield in the manifest) will be written to \nthe podName file.\n \n"}, {"color": "green", "id": "text_174", "label": "231\nPassing metadata through the Downward API\n      - path: \"labels\"                       \n        fieldRef:                            \n          fieldPath: metadata.labels         \n      - path: \"annotations\"                       \n        fieldRef:                                 \n          fieldPath: metadata.annotations         \n      - path: \"containerCpuRequestMilliCores\"\n        resourceFieldRef:\n          containerName: main\n          resource: requests.cpu\n          divisor: 1m\n      - path: \"containerMemoryLimitBytes\"\n        resourceFieldRef:\n          containerName: main\n          resource: limits.memory\n          divisor: 1\nInstead of passing the metadata through environment variables, you\u2019re defining a vol-\nume called downward and mounting it in your container under /etc/downward. The\nfiles this volume will contain are configured under the downwardAPI.items attribute\nin the volume specification.\n Each item specifies the path (the filename) where the metadata should be written\nto and references either a pod-level field or a container resource field whose value you\nwant stored in the file (see figure 8.3).\nThe pod\u2019s labels will be written \nto the /etc/downward/labels file.\nThe pod\u2019s annotations will be \nwritten to the /etc/downward/\nannotations file.\ndownwardAPI volume\nPod manifest\nmetadata:\nname: downward\nnamespace: default\nlabels:\nfoo: bar\nannotations:\nkey1: value1\n...\nspec:\ncontainers:\n- name: main\nimage: busybox\ncommand: [\"sleep\", \"9999999\"]\nresources:\nrequests:\ncpu: 15m\nmemory: 100Ki\nlimits:\ncpu: 100m\nmemory: 4Mi\n...\n/podName\n/podNamespace\n/labels\n/annotations\n/containerCpuRequestMilliCores\n/containerMemoryLimitBytes\ndivisor: 1\ndivisor: 1m\nContainer: main\nPod: downward\nFilesystem\n/\netc/\ndownward/\nFigure 8.3\nUsing a downwardAPI volume to pass metadata to the container\n \n", "shape": "dot", "size": 10, "title": "231\nPassing metadata through the Downward API\n      - path: \"labels\"                       \n        fieldRef:                            \n          fieldPath: metadata.labels         \n      - path: \"annotations\"                       \n        fieldRef:                                 \n          fieldPath: metadata.annotations         \n      - path: \"containerCpuRequestMilliCores\"\n        resourceFieldRef:\n          containerName: main\n          resource: requests.cpu\n          divisor: 1m\n      - path: \"containerMemoryLimitBytes\"\n        resourceFieldRef:\n          containerName: main\n          resource: limits.memory\n          divisor: 1\nInstead of passing the metadata through environment variables, you\u2019re defining a vol-\nume called downward and mounting it in your container under /etc/downward. The\nfiles this volume will contain are configured under the downwardAPI.items attribute\nin the volume specification.\n Each item specifies the path (the filename) where the metadata should be written\nto and references either a pod-level field or a container resource field whose value you\nwant stored in the file (see figure 8.3).\nThe pod\u2019s labels will be written \nto the /etc/downward/labels file.\nThe pod\u2019s annotations will be \nwritten to the /etc/downward/\nannotations file.\ndownwardAPI volume\nPod manifest\nmetadata:\nname: downward\nnamespace: default\nlabels:\nfoo: bar\nannotations:\nkey1: value1\n...\nspec:\ncontainers:\n- name: main\nimage: busybox\ncommand: [\"sleep\", \"9999999\"]\nresources:\nrequests:\ncpu: 15m\nmemory: 100Ki\nlimits:\ncpu: 100m\nmemory: 4Mi\n...\n/podName\n/podNamespace\n/labels\n/annotations\n/containerCpuRequestMilliCores\n/containerMemoryLimitBytes\ndivisor: 1\ndivisor: 1m\nContainer: main\nPod: downward\nFilesystem\n/\netc/\ndownward/\nFigure 8.3\nUsing a downwardAPI volume to pass metadata to the container\n \n"}, {"color": "green", "id": "text_175", "label": "232\nCHAPTER 8\nAccessing pod metadata and other resources from applications\nDelete the previous pod and create a new one from the manifest in the previous list-\ning. Then look at the contents of the mounted downwardAPI volume directory. You\nmounted the volume under /etc/downward/, so list the files in there, as shown in the\nfollowing listing.\n$ kubectl exec downward ls -lL /etc/downward\n-rw-r--r--   1 root   root   134 May 25 10:23 annotations\n-rw-r--r--   1 root   root     2 May 25 10:23 containerCpuRequestMilliCores\n-rw-r--r--   1 root   root     7 May 25 10:23 containerMemoryLimitBytes\n-rw-r--r--   1 root   root     9 May 25 10:23 labels\n-rw-r--r--   1 root   root     8 May 25 10:23 podName\n-rw-r--r--   1 root   root     7 May 25 10:23 podNamespace\nNOTE\nAs with the configMap and secret volumes, you can change the file\npermissions through the downwardAPI volume\u2019s defaultMode property in the\npod spec.\nEach file corresponds to an item in the volume\u2019s definition. The contents of files,\nwhich correspond to the same metadata fields as in the previous example, are the\nsame as the values of environment variables you used before, so we won\u2019t show them\nhere. But because you couldn\u2019t expose labels and annotations through environment\nvariables before, examine the following listing for the contents of the two files you\nexposed them in.\n$ kubectl exec downward cat /etc/downward/labels\nfoo=\"bar\"\n$ kubectl exec downward cat /etc/downward/annotations\nkey1=\"value1\"\nkey2=\"multi\\nline\\nvalue\\n\"\nkubernetes.io/config.seen=\"2016-11-28T14:27:45.664924282Z\"\nkubernetes.io/config.source=\"api\"\nAs you can see, each label/annotation is written in the key=value format on a sepa-\nrate line. Multi-line values are written to a single line with newline characters denoted\nwith \\n.\nUPDATING LABELS AND ANNOTATIONS\nYou may remember that labels and annotations can be modified while a pod is run-\nning. As you might expect, when they change, Kubernetes updates the files holding\nthem, allowing the pod to always see up-to-date data. This also explains why labels and\nannotations can\u2019t be exposed through environment variables. Because environment\nvariable values can\u2019t be updated afterward, if the labels or annotations of a pod were\nexposed through environment variables, there\u2019s no way to expose the new values after\nthey\u2019re modified.\nListing 8.4\nFiles in the downwardAPI volume\nListing 8.5\nDisplaying labels and annotations in the downwardAPI volume\n \n", "shape": "dot", "size": 10, "title": "232\nCHAPTER 8\nAccessing pod metadata and other resources from applications\nDelete the previous pod and create a new one from the manifest in the previous list-\ning. Then look at the contents of the mounted downwardAPI volume directory. You\nmounted the volume under /etc/downward/, so list the files in there, as shown in the\nfollowing listing.\n$ kubectl exec downward ls -lL /etc/downward\n-rw-r--r--   1 root   root   134 May 25 10:23 annotations\n-rw-r--r--   1 root   root     2 May 25 10:23 containerCpuRequestMilliCores\n-rw-r--r--   1 root   root     7 May 25 10:23 containerMemoryLimitBytes\n-rw-r--r--   1 root   root     9 May 25 10:23 labels\n-rw-r--r--   1 root   root     8 May 25 10:23 podName\n-rw-r--r--   1 root   root     7 May 25 10:23 podNamespace\nNOTE\nAs with the configMap and secret volumes, you can change the file\npermissions through the downwardAPI volume\u2019s defaultMode property in the\npod spec.\nEach file corresponds to an item in the volume\u2019s definition. The contents of files,\nwhich correspond to the same metadata fields as in the previous example, are the\nsame as the values of environment variables you used before, so we won\u2019t show them\nhere. But because you couldn\u2019t expose labels and annotations through environment\nvariables before, examine the following listing for the contents of the two files you\nexposed them in.\n$ kubectl exec downward cat /etc/downward/labels\nfoo=\"bar\"\n$ kubectl exec downward cat /etc/downward/annotations\nkey1=\"value1\"\nkey2=\"multi\\nline\\nvalue\\n\"\nkubernetes.io/config.seen=\"2016-11-28T14:27:45.664924282Z\"\nkubernetes.io/config.source=\"api\"\nAs you can see, each label/annotation is written in the key=value format on a sepa-\nrate line. Multi-line values are written to a single line with newline characters denoted\nwith \\n.\nUPDATING LABELS AND ANNOTATIONS\nYou may remember that labels and annotations can be modified while a pod is run-\nning. As you might expect, when they change, Kubernetes updates the files holding\nthem, allowing the pod to always see up-to-date data. This also explains why labels and\nannotations can\u2019t be exposed through environment variables. Because environment\nvariable values can\u2019t be updated afterward, if the labels or annotations of a pod were\nexposed through environment variables, there\u2019s no way to expose the new values after\nthey\u2019re modified.\nListing 8.4\nFiles in the downwardAPI volume\nListing 8.5\nDisplaying labels and annotations in the downwardAPI volume\n \n"}, {"color": "green", "id": "text_176", "label": "233\nTalking to the Kubernetes API server\nREFERRING TO CONTAINER-LEVEL METADATA IN THE VOLUME SPECIFICATION\nBefore we wrap up this section, we need to point out one thing. When exposing con-\ntainer-level metadata, such as a container\u2019s resource limit or requests (done using\nresourceFieldRef), you need to specify the name of the container whose resource\nfield you\u2019re referencing, as shown in the following listing.\nspec:\n  volumes:\n  - name: downward                       \n    downwardAPI:                         \n      items:\n      - path: \"containerCpuRequestMilliCores\"\n        resourceFieldRef:\n          containerName: main       \n          resource: requests.cpu\n          divisor: 1m\nThe reason for this becomes obvious if you consider that volumes are defined at the\npod level, not at the container level. When referring to a container\u2019s resource field\ninside a volume specification, you need to explicitly specify the name of the container\nyou\u2019re referring to. This is true even for single-container pods. \n Using volumes to expose a container\u2019s resource requests and/or limits is slightly\nmore complicated than using environment variables, but the benefit is that it allows\nyou to pass one container\u2019s resource fields to a different container if needed (but\nboth containers need to be in the same pod). With environment variables, a container\ncan only be passed its own resource limits and requests. \nUNDERSTANDING WHEN TO USE THE DOWNWARD API\nAs you\u2019ve seen, using the Downward API isn\u2019t complicated. It allows you to keep the\napplication Kubernetes-agnostic. This is especially useful when you\u2019re dealing with an\nexisting application that expects certain data in environment variables. The Down-\nward API allows you to expose the data to the application without having to rewrite\nthe application or wrap it in a shell script, which collects the data and then exposes it\nthrough environment variables.\n But the metadata available through the Downward API is fairly limited. If you need\nmore, you\u2019ll need to obtain it from the Kubernetes API server directly. You\u2019ll learn\nhow to do that next.\n8.2\nTalking to the Kubernetes API server\nWe\u2019ve seen how the Downward API provides a simple way to pass certain pod and con-\ntainer metadata to the process running inside them. It only exposes the pod\u2019s own\nmetadata and a subset of all of the pod\u2019s data. But sometimes your app will need to\nknow more about other pods and even other resources defined in your cluster. The\nDownward API doesn\u2019t help in those cases.\nListing 8.6\nReferring to container-level metadata in a downwardAPI volume\nContainer name \nmust be specified\n \n", "shape": "dot", "size": 10, "title": "233\nTalking to the Kubernetes API server\nREFERRING TO CONTAINER-LEVEL METADATA IN THE VOLUME SPECIFICATION\nBefore we wrap up this section, we need to point out one thing. When exposing con-\ntainer-level metadata, such as a container\u2019s resource limit or requests (done using\nresourceFieldRef), you need to specify the name of the container whose resource\nfield you\u2019re referencing, as shown in the following listing.\nspec:\n  volumes:\n  - name: downward                       \n    downwardAPI:                         \n      items:\n      - path: \"containerCpuRequestMilliCores\"\n        resourceFieldRef:\n          containerName: main       \n          resource: requests.cpu\n          divisor: 1m\nThe reason for this becomes obvious if you consider that volumes are defined at the\npod level, not at the container level. When referring to a container\u2019s resource field\ninside a volume specification, you need to explicitly specify the name of the container\nyou\u2019re referring to. This is true even for single-container pods. \n Using volumes to expose a container\u2019s resource requests and/or limits is slightly\nmore complicated than using environment variables, but the benefit is that it allows\nyou to pass one container\u2019s resource fields to a different container if needed (but\nboth containers need to be in the same pod). With environment variables, a container\ncan only be passed its own resource limits and requests. \nUNDERSTANDING WHEN TO USE THE DOWNWARD API\nAs you\u2019ve seen, using the Downward API isn\u2019t complicated. It allows you to keep the\napplication Kubernetes-agnostic. This is especially useful when you\u2019re dealing with an\nexisting application that expects certain data in environment variables. The Down-\nward API allows you to expose the data to the application without having to rewrite\nthe application or wrap it in a shell script, which collects the data and then exposes it\nthrough environment variables.\n But the metadata available through the Downward API is fairly limited. If you need\nmore, you\u2019ll need to obtain it from the Kubernetes API server directly. You\u2019ll learn\nhow to do that next.\n8.2\nTalking to the Kubernetes API server\nWe\u2019ve seen how the Downward API provides a simple way to pass certain pod and con-\ntainer metadata to the process running inside them. It only exposes the pod\u2019s own\nmetadata and a subset of all of the pod\u2019s data. But sometimes your app will need to\nknow more about other pods and even other resources defined in your cluster. The\nDownward API doesn\u2019t help in those cases.\nListing 8.6\nReferring to container-level metadata in a downwardAPI volume\nContainer name \nmust be specified\n \n"}, {"color": "green", "id": "text_177", "label": "234\nCHAPTER 8\nAccessing pod metadata and other resources from applications\n As you\u2019ve seen throughout the book, information about services and pods can be\nobtained by looking at the service-related environment variables or through DNS. But\nwhen the app needs data about other resources or when it requires access to the most\nup-to-date information as possible, it needs to talk to the API server directly (as shown\nin figure 8.4).\nBefore you see how apps within pods can talk to the Kubernetes API server, let\u2019s first\nexplore the server\u2019s REST endpoints from your local machine, so you can see what\ntalking to the API server looks like.\n8.2.1\nExploring the Kubernetes REST API\nYou\u2019ve learned about different Kubernetes resource types. But if you\u2019re planning on\ndeveloping apps that talk to the Kubernetes API, you\u2019ll want to know the API first. \n To do that, you can try hitting the API server directly. You can get its URL by run-\nning kubectl cluster-info:\n$ kubectl cluster-info\nKubernetes master is running at https://192.168.99.100:8443\nBecause the server uses HTTPS and requires authentication, it\u2019s not simple to talk to\nit directly. You can try accessing it with curl and using curl\u2019s --insecure (or -k)\noption to skip the server certificate check, but that doesn\u2019t get you far:\n$ curl https://192.168.99.100:8443 -k\nUnauthorized\nLuckily, rather than dealing with authentication yourself, you can talk to the server\nthrough a proxy by running the kubectl proxy command. \nACCESSING THE API SERVER THROUGH KUBECTL PROXY \nThe kubectl proxy command runs a proxy server that accepts HTTP connections on\nyour local machine and proxies them to the API server while taking care of authenti-\ncation, so you don\u2019t need to pass the authentication token in every request. It also\nmakes sure you\u2019re talking to the actual API server and not a man in the middle (by\nverifying the server\u2019s certificate on each request).\nContainer\nAPI server\nPod\nApp process\nAPI objects\nFigure 8.4\nTalking to the API server \nfrom inside a pod to get information \nabout other API objects\n \n", "shape": "dot", "size": 10, "title": "234\nCHAPTER 8\nAccessing pod metadata and other resources from applications\n As you\u2019ve seen throughout the book, information about services and pods can be\nobtained by looking at the service-related environment variables or through DNS. But\nwhen the app needs data about other resources or when it requires access to the most\nup-to-date information as possible, it needs to talk to the API server directly (as shown\nin figure 8.4).\nBefore you see how apps within pods can talk to the Kubernetes API server, let\u2019s first\nexplore the server\u2019s REST endpoints from your local machine, so you can see what\ntalking to the API server looks like.\n8.2.1\nExploring the Kubernetes REST API\nYou\u2019ve learned about different Kubernetes resource types. But if you\u2019re planning on\ndeveloping apps that talk to the Kubernetes API, you\u2019ll want to know the API first. \n To do that, you can try hitting the API server directly. You can get its URL by run-\nning kubectl cluster-info:\n$ kubectl cluster-info\nKubernetes master is running at https://192.168.99.100:8443\nBecause the server uses HTTPS and requires authentication, it\u2019s not simple to talk to\nit directly. You can try accessing it with curl and using curl\u2019s --insecure (or -k)\noption to skip the server certificate check, but that doesn\u2019t get you far:\n$ curl https://192.168.99.100:8443 -k\nUnauthorized\nLuckily, rather than dealing with authentication yourself, you can talk to the server\nthrough a proxy by running the kubectl proxy command. \nACCESSING THE API SERVER THROUGH KUBECTL PROXY \nThe kubectl proxy command runs a proxy server that accepts HTTP connections on\nyour local machine and proxies them to the API server while taking care of authenti-\ncation, so you don\u2019t need to pass the authentication token in every request. It also\nmakes sure you\u2019re talking to the actual API server and not a man in the middle (by\nverifying the server\u2019s certificate on each request).\nContainer\nAPI server\nPod\nApp process\nAPI objects\nFigure 8.4\nTalking to the API server \nfrom inside a pod to get information \nabout other API objects\n \n"}, {"color": "green", "id": "text_178", "label": "235\nTalking to the Kubernetes API server\n Running the proxy is trivial. All you need to do is run the following command:\n$ kubectl proxy\nStarting to serve on 127.0.0.1:8001\nYou don\u2019t need to pass in any other arguments, because kubectl already knows every-\nthing it needs (the API server URL, authorization token, and so on). As soon as it starts\nup, the proxy starts accepting connections on local port 8001. Let\u2019s see if it works:\n$ curl localhost:8001\n{\n  \"paths\": [\n    \"/api\",\n    \"/api/v1\",\n    ...\nVoila! You sent the request to the proxy, it sent a request to the API server, and then\nthe proxy returned whatever the server returned. Now, let\u2019s start exploring.\nEXPLORING THE KUBERNETES API THROUGH THE KUBECTL PROXY\nYou can continue to use curl, or you can open your web browser and point it to\nhttp:/\n/localhost:8001. Let\u2019s examine what the API server returns when you hit its base\nURL more closely. The server responds with a list of paths, as shown in the follow-\ning listing.\n$ curl http://localhost:8001\n{\n  \"paths\": [\n    \"/api\",\n    \"/api/v1\",                  \n    \"/apis\",\n    \"/apis/apps\",\n    \"/apis/apps/v1beta1\",\n    ...\n    \"/apis/batch\",              \n    \"/apis/batch/v1\",           \n    \"/apis/batch/v2alpha1\",     \n    ...\nThese paths correspond to the API groups and versions you specify in your resource\ndefinitions when creating resources such as Pods, Services, and so on. \n You may recognize the batch/v1 in the /apis/batch/v1 path as the API group and\nversion of the Job resources you learned about in chapter 4. Likewise, the /api/v1\ncorresponds to the apiVersion: v1 you refer to in the common resources you created\n(Pods, Services, ReplicationControllers, and so on). The most common resource\ntypes, which were introduced in the earliest versions of Kubernetes, don\u2019t belong to\nListing 8.7\nListing the API server\u2019s REST endpoints: http:/\n/localhost:8001\nMost resource types \ncan be found here.\nThe batch API \ngroup and its \ntwo versions\n \n", "shape": "dot", "size": 10, "title": "235\nTalking to the Kubernetes API server\n Running the proxy is trivial. All you need to do is run the following command:\n$ kubectl proxy\nStarting to serve on 127.0.0.1:8001\nYou don\u2019t need to pass in any other arguments, because kubectl already knows every-\nthing it needs (the API server URL, authorization token, and so on). As soon as it starts\nup, the proxy starts accepting connections on local port 8001. Let\u2019s see if it works:\n$ curl localhost:8001\n{\n  \"paths\": [\n    \"/api\",\n    \"/api/v1\",\n    ...\nVoila! You sent the request to the proxy, it sent a request to the API server, and then\nthe proxy returned whatever the server returned. Now, let\u2019s start exploring.\nEXPLORING THE KUBERNETES API THROUGH THE KUBECTL PROXY\nYou can continue to use curl, or you can open your web browser and point it to\nhttp:/\n/localhost:8001. Let\u2019s examine what the API server returns when you hit its base\nURL more closely. The server responds with a list of paths, as shown in the follow-\ning listing.\n$ curl http://localhost:8001\n{\n  \"paths\": [\n    \"/api\",\n    \"/api/v1\",                  \n    \"/apis\",\n    \"/apis/apps\",\n    \"/apis/apps/v1beta1\",\n    ...\n    \"/apis/batch\",              \n    \"/apis/batch/v1\",           \n    \"/apis/batch/v2alpha1\",     \n    ...\nThese paths correspond to the API groups and versions you specify in your resource\ndefinitions when creating resources such as Pods, Services, and so on. \n You may recognize the batch/v1 in the /apis/batch/v1 path as the API group and\nversion of the Job resources you learned about in chapter 4. Likewise, the /api/v1\ncorresponds to the apiVersion: v1 you refer to in the common resources you created\n(Pods, Services, ReplicationControllers, and so on). The most common resource\ntypes, which were introduced in the earliest versions of Kubernetes, don\u2019t belong to\nListing 8.7\nListing the API server\u2019s REST endpoints: http:/\n/localhost:8001\nMost resource types \ncan be found here.\nThe batch API \ngroup and its \ntwo versions\n \n"}, {"color": "green", "id": "text_179", "label": "236\nCHAPTER 8\nAccessing pod metadata and other resources from applications\nany specific group, because Kubernetes initially didn\u2019t even use the concept of API\ngroups; they were introduced later. \nNOTE\nThese initial resource types without an API group are now considered\nto belong to the core API group.\nEXPLORING THE BATCH API GROUP\u2019S REST ENDPOINT\nLet\u2019s explore the Job resource API. You\u2019ll start by looking at what\u2019s behind the\n/apis/batch path (you\u2019ll omit the version for now), as shown in the following listing.\n$ curl http://localhost:8001/apis/batch\n{\n  \"kind\": \"APIGroup\",\n  \"apiVersion\": \"v1\",\n  \"name\": \"batch\",\n  \"versions\": [\n    {\n      \"groupVersion\": \"batch/v1\",             \n      \"version\": \"v1\"                         \n    },\n    {\n      \"groupVersion\": \"batch/v2alpha1\",       \n      \"version\": \"v2alpha1\"                   \n    }\n  ],\n  \"preferredVersion\": {                    \n    \"groupVersion\": \"batch/v1\",            \n    \"version\": \"v1\"                        \n  },\n  \"serverAddressByClientCIDRs\": null\n}\nThe response shows a description of the batch API group, including the available ver-\nsions and the preferred version clients should use. Let\u2019s continue and see what\u2019s\nbehind the /apis/batch/v1 path. It\u2019s shown in the following listing.\n$ curl http://localhost:8001/apis/batch/v1\n{\n  \"kind\": \"APIResourceList\",              \n  \"apiVersion\": \"v1\",\n  \"groupVersion\": \"batch/v1\",             \n  \"resources\": [                          \n    {\n      \"name\": \"jobs\",             \n      \"namespaced\": true,         \n      \"kind\": \"Job\",              \nListing 8.8\nListing endpoints under /apis/batch: http:/\n/localhost:8001/apis/batch\nListing 8.9\nResource types in batch/v1: http:/\n/localhost:8001/apis/batch/v1\nThe batch API \ngroup contains \ntwo versions.\nClients should use the \nv1 version instead of \nv2alpha1.\nThis is a list of API resources \nin the batch/v1 API group.\nHere\u2019s an array holding \nall the resource types \nin this group.\nThis describes the \nJob resource, which \nis namespaced.\n \n", "shape": "dot", "size": 10, "title": "236\nCHAPTER 8\nAccessing pod metadata and other resources from applications\nany specific group, because Kubernetes initially didn\u2019t even use the concept of API\ngroups; they were introduced later. \nNOTE\nThese initial resource types without an API group are now considered\nto belong to the core API group.\nEXPLORING THE BATCH API GROUP\u2019S REST ENDPOINT\nLet\u2019s explore the Job resource API. You\u2019ll start by looking at what\u2019s behind the\n/apis/batch path (you\u2019ll omit the version for now), as shown in the following listing.\n$ curl http://localhost:8001/apis/batch\n{\n  \"kind\": \"APIGroup\",\n  \"apiVersion\": \"v1\",\n  \"name\": \"batch\",\n  \"versions\": [\n    {\n      \"groupVersion\": \"batch/v1\",             \n      \"version\": \"v1\"                         \n    },\n    {\n      \"groupVersion\": \"batch/v2alpha1\",       \n      \"version\": \"v2alpha1\"                   \n    }\n  ],\n  \"preferredVersion\": {                    \n    \"groupVersion\": \"batch/v1\",            \n    \"version\": \"v1\"                        \n  },\n  \"serverAddressByClientCIDRs\": null\n}\nThe response shows a description of the batch API group, including the available ver-\nsions and the preferred version clients should use. Let\u2019s continue and see what\u2019s\nbehind the /apis/batch/v1 path. It\u2019s shown in the following listing.\n$ curl http://localhost:8001/apis/batch/v1\n{\n  \"kind\": \"APIResourceList\",              \n  \"apiVersion\": \"v1\",\n  \"groupVersion\": \"batch/v1\",             \n  \"resources\": [                          \n    {\n      \"name\": \"jobs\",             \n      \"namespaced\": true,         \n      \"kind\": \"Job\",              \nListing 8.8\nListing endpoints under /apis/batch: http:/\n/localhost:8001/apis/batch\nListing 8.9\nResource types in batch/v1: http:/\n/localhost:8001/apis/batch/v1\nThe batch API \ngroup contains \ntwo versions.\nClients should use the \nv1 version instead of \nv2alpha1.\nThis is a list of API resources \nin the batch/v1 API group.\nHere\u2019s an array holding \nall the resource types \nin this group.\nThis describes the \nJob resource, which \nis namespaced.\n \n"}, {"color": "green", "id": "text_180", "label": "237\nTalking to the Kubernetes API server\n      \"verbs\": [                 \n        \"create\",                \n        \"delete\",                \n        \"deletecollection\",      \n        \"get\",                   \n        \"list\",                  \n        \"patch\",                 \n        \"update\",                \n        \"watch\"                  \n      ]\n    },\n    {\n      \"name\": \"jobs/status\",            \n      \"namespaced\": true,                  \n      \"kind\": \"Job\",\n      \"verbs\": [             \n        \"get\",               \n        \"patch\",             \n        \"update\"             \n      ]\n    }\n  ]\n}\nAs you can see, the API server returns a list of resource types and REST endpoints in\nthe batch/v1 API group. One of those is the Job resource. In addition to the name of\nthe resource and the associated kind, the API server also includes information on\nwhether the resource is namespaced or not, its short name (if it has one; Jobs don\u2019t),\nand a list of verbs you can use with the resource. \n The returned list describes the REST resources exposed in the API server. The\n\"name\": \"jobs\" line tells you that the API contains the /apis/batch/v1/jobs end-\npoint. The \"verbs\" array says you can retrieve, update, and delete Job resources\nthrough that endpoint. For certain resources, additional API endpoints are also\nexposed (such as the jobs/status path, which allows modifying only the status of\na Job).\nLISTING ALL JOB INSTANCES IN THE CLUSTER\nTo get a list of Jobs in your cluster, perform a GET request on path /apis/batch/\nv1/jobs, as shown in the following listing.\n$ curl http://localhost:8001/apis/batch/v1/jobs\n{\n  \"kind\": \"JobList\",\n  \"apiVersion\": \"batch/v1\",\n  \"metadata\": {\n    \"selfLink\": \"/apis/batch/v1/jobs\",\n    \"resourceVersion\": \"225162\"\n  },\nListing 8.10\nList of Jobs: http:/\n/localhost:8001/apis/batch/v1/jobs\nHere are the verbs that can be used \nwith this resource (you can create \nJobs; delete individual ones or a \ncollection of them; and retrieve, \nwatch, and update them).\nResources also have a \nspecial REST endpoint for \nmodifying their status.\nThe status can be \nretrieved, patched, \nor updated.\n \n", "shape": "dot", "size": 10, "title": "237\nTalking to the Kubernetes API server\n      \"verbs\": [                 \n        \"create\",                \n        \"delete\",                \n        \"deletecollection\",      \n        \"get\",                   \n        \"list\",                  \n        \"patch\",                 \n        \"update\",                \n        \"watch\"                  \n      ]\n    },\n    {\n      \"name\": \"jobs/status\",            \n      \"namespaced\": true,                  \n      \"kind\": \"Job\",\n      \"verbs\": [             \n        \"get\",               \n        \"patch\",             \n        \"update\"             \n      ]\n    }\n  ]\n}\nAs you can see, the API server returns a list of resource types and REST endpoints in\nthe batch/v1 API group. One of those is the Job resource. In addition to the name of\nthe resource and the associated kind, the API server also includes information on\nwhether the resource is namespaced or not, its short name (if it has one; Jobs don\u2019t),\nand a list of verbs you can use with the resource. \n The returned list describes the REST resources exposed in the API server. The\n\"name\": \"jobs\" line tells you that the API contains the /apis/batch/v1/jobs end-\npoint. The \"verbs\" array says you can retrieve, update, and delete Job resources\nthrough that endpoint. For certain resources, additional API endpoints are also\nexposed (such as the jobs/status path, which allows modifying only the status of\na Job).\nLISTING ALL JOB INSTANCES IN THE CLUSTER\nTo get a list of Jobs in your cluster, perform a GET request on path /apis/batch/\nv1/jobs, as shown in the following listing.\n$ curl http://localhost:8001/apis/batch/v1/jobs\n{\n  \"kind\": \"JobList\",\n  \"apiVersion\": \"batch/v1\",\n  \"metadata\": {\n    \"selfLink\": \"/apis/batch/v1/jobs\",\n    \"resourceVersion\": \"225162\"\n  },\nListing 8.10\nList of Jobs: http:/\n/localhost:8001/apis/batch/v1/jobs\nHere are the verbs that can be used \nwith this resource (you can create \nJobs; delete individual ones or a \ncollection of them; and retrieve, \nwatch, and update them).\nResources also have a \nspecial REST endpoint for \nmodifying their status.\nThe status can be \nretrieved, patched, \nor updated.\n \n"}, {"color": "green", "id": "text_181", "label": "238\nCHAPTER 8\nAccessing pod metadata and other resources from applications\n  \"items\": [\n    {\n      \"metadata\": {\n        \"name\": \"my-job\",\n        \"namespace\": \"default\",\n        ...\nYou probably have no Job resources deployed in your cluster, so the items array will be\nempty. You can try deploying the Job in Chapter08/my-job.yaml and hitting the REST\nendpoint again to get the same output as in listing 8.10.\nRETRIEVING A SPECIFIC JOB INSTANCE BY NAME\nThe previous endpoint returned a list of all Jobs across all namespaces. To get back\nonly one specific Job, you need to specify its name and namespace in the URL. To\nretrieve the Job shown in the previous listing (name: my-job; namespace: default),\nyou need to request the following path: /apis/batch/v1/namespaces/default/jobs/\nmy-job, as shown in the following listing.\n$ curl http://localhost:8001/apis/batch/v1/namespaces/default/jobs/my-job\n{\n  \"kind\": \"Job\",\n  \"apiVersion\": \"batch/v1\",\n  \"metadata\": {\n    \"name\": \"my-job\",\n    \"namespace\": \"default\",\n    ...\nAs you can see, you get back the complete JSON definition of the my-job Job resource,\nexactly like you do if you run:\n$ kubectl get job my-job -o json\nYou\u2019ve seen that you can browse the Kubernetes REST API server without using any\nspecial tools, but to fully explore the REST API and interact with it, a better option is\ndescribed at the end of this chapter. For now, exploring it with curl like this is enough\nto make you understand how an application running in a pod talks to Kubernetes. \n8.2.2\nTalking to the API server from within a pod\nYou\u2019ve learned how to talk to the API server from your local machine, using the\nkubectl proxy. Now, let\u2019s see how to talk to it from within a pod, where you (usually)\ndon\u2019t have kubectl. Therefore, to talk to the API server from inside a pod, you need\nto take care of three things:\n\uf0a1Find the location of the API server.\n\uf0a1Make sure you\u2019re talking to the API server and not something impersonating it.\n\uf0a1Authenticate with the server; otherwise it won\u2019t let you see or do anything.\nListing 8.11\nRetrieving a resource in a specific namespace by name\n \n", "shape": "dot", "size": 10, "title": "238\nCHAPTER 8\nAccessing pod metadata and other resources from applications\n  \"items\": [\n    {\n      \"metadata\": {\n        \"name\": \"my-job\",\n        \"namespace\": \"default\",\n        ...\nYou probably have no Job resources deployed in your cluster, so the items array will be\nempty. You can try deploying the Job in Chapter08/my-job.yaml and hitting the REST\nendpoint again to get the same output as in listing 8.10.\nRETRIEVING A SPECIFIC JOB INSTANCE BY NAME\nThe previous endpoint returned a list of all Jobs across all namespaces. To get back\nonly one specific Job, you need to specify its name and namespace in the URL. To\nretrieve the Job shown in the previous listing (name: my-job; namespace: default),\nyou need to request the following path: /apis/batch/v1/namespaces/default/jobs/\nmy-job, as shown in the following listing.\n$ curl http://localhost:8001/apis/batch/v1/namespaces/default/jobs/my-job\n{\n  \"kind\": \"Job\",\n  \"apiVersion\": \"batch/v1\",\n  \"metadata\": {\n    \"name\": \"my-job\",\n    \"namespace\": \"default\",\n    ...\nAs you can see, you get back the complete JSON definition of the my-job Job resource,\nexactly like you do if you run:\n$ kubectl get job my-job -o json\nYou\u2019ve seen that you can browse the Kubernetes REST API server without using any\nspecial tools, but to fully explore the REST API and interact with it, a better option is\ndescribed at the end of this chapter. For now, exploring it with curl like this is enough\nto make you understand how an application running in a pod talks to Kubernetes. \n8.2.2\nTalking to the API server from within a pod\nYou\u2019ve learned how to talk to the API server from your local machine, using the\nkubectl proxy. Now, let\u2019s see how to talk to it from within a pod, where you (usually)\ndon\u2019t have kubectl. Therefore, to talk to the API server from inside a pod, you need\nto take care of three things:\n\uf0a1Find the location of the API server.\n\uf0a1Make sure you\u2019re talking to the API server and not something impersonating it.\n\uf0a1Authenticate with the server; otherwise it won\u2019t let you see or do anything.\nListing 8.11\nRetrieving a resource in a specific namespace by name\n \n"}, {"color": "green", "id": "text_182", "label": "239\nTalking to the Kubernetes API server\nYou\u2019ll see how this is done in the next three sections. \nRUNNING A POD TO TRY OUT COMMUNICATION WITH THE API SERVER\nThe first thing you need is a pod from which to talk to the API server. You\u2019ll run a pod\nthat does nothing (it runs the sleep command in its only container), and then run a\nshell in the container with kubectl exec. Then you\u2019ll try to access the API server from\nwithin that shell using curl.\n Therefore, you need to use a container image that contains the curl binary. If you\nsearch for such an image on, say, Docker Hub, you\u2019ll find the tutum/curl image, so\nuse it (you can also use any other existing image containing the curl binary or you\ncan build your own). The pod definition is shown in the following listing.\napiVersion: v1\nkind: Pod\nmetadata:\n  name: curl\nspec:\n  containers:\n  - name: main\n    image: tutum/curl                \n    command: [\"sleep\", \"9999999\"]    \nAfter creating the pod, run kubectl exec to run a bash shell inside its container:\n$ kubectl exec -it curl bash\nroot@curl:/#\nYou\u2019re now ready to talk to the API server.\nFINDING THE API SERVER\u2019S ADDRESS\nFirst, you need to find the IP and port of the Kubernetes API server. This is easy,\nbecause a Service called kubernetes is automatically exposed in the default name-\nspace and configured to point to the API server. You may remember seeing it every\ntime you listed services with kubectl get svc:\n$ kubectl get svc\nNAME         CLUSTER-IP   EXTERNAL-IP   PORT(S)   AGE\nkubernetes   10.0.0.1     \u003cnone\u003e        443/TCP   46d\nAnd you\u2019ll remember from chapter 5 that environment variables are configured for\neach service. You can get both the IP address and the port of the API server by looking\nup the KUBERNETES_SERVICE_HOST and KUBERNETES_SERVICE_PORT variables (inside\nthe container):\nroot@curl:/# env | grep KUBERNETES_SERVICE\nKUBERNETES_SERVICE_PORT=443\nKUBERNETES_SERVICE_HOST=10.0.0.1\nKUBERNETES_SERVICE_PORT_HTTPS=443\nListing 8.12\nA pod for trying out communication with the API server: curl.yaml\nUsing the tutum/curl image, \nbecause you need curl \navailable in the container\nYou\u2019re running the sleep \ncommand with a long delay to \nkeep your container running.\n \n", "shape": "dot", "size": 10, "title": "239\nTalking to the Kubernetes API server\nYou\u2019ll see how this is done in the next three sections. \nRUNNING A POD TO TRY OUT COMMUNICATION WITH THE API SERVER\nThe first thing you need is a pod from which to talk to the API server. You\u2019ll run a pod\nthat does nothing (it runs the sleep command in its only container), and then run a\nshell in the container with kubectl exec. Then you\u2019ll try to access the API server from\nwithin that shell using curl.\n Therefore, you need to use a container image that contains the curl binary. If you\nsearch for such an image on, say, Docker Hub, you\u2019ll find the tutum/curl image, so\nuse it (you can also use any other existing image containing the curl binary or you\ncan build your own). The pod definition is shown in the following listing.\napiVersion: v1\nkind: Pod\nmetadata:\n  name: curl\nspec:\n  containers:\n  - name: main\n    image: tutum/curl                \n    command: [\"sleep\", \"9999999\"]    \nAfter creating the pod, run kubectl exec to run a bash shell inside its container:\n$ kubectl exec -it curl bash\nroot@curl:/#\nYou\u2019re now ready to talk to the API server.\nFINDING THE API SERVER\u2019S ADDRESS\nFirst, you need to find the IP and port of the Kubernetes API server. This is easy,\nbecause a Service called kubernetes is automatically exposed in the default name-\nspace and configured to point to the API server. You may remember seeing it every\ntime you listed services with kubectl get svc:\n$ kubectl get svc\nNAME         CLUSTER-IP   EXTERNAL-IP   PORT(S)   AGE\nkubernetes   10.0.0.1     \u003cnone\u003e        443/TCP   46d\nAnd you\u2019ll remember from chapter 5 that environment variables are configured for\neach service. You can get both the IP address and the port of the API server by looking\nup the KUBERNETES_SERVICE_HOST and KUBERNETES_SERVICE_PORT variables (inside\nthe container):\nroot@curl:/# env | grep KUBERNETES_SERVICE\nKUBERNETES_SERVICE_PORT=443\nKUBERNETES_SERVICE_HOST=10.0.0.1\nKUBERNETES_SERVICE_PORT_HTTPS=443\nListing 8.12\nA pod for trying out communication with the API server: curl.yaml\nUsing the tutum/curl image, \nbecause you need curl \navailable in the container\nYou\u2019re running the sleep \ncommand with a long delay to \nkeep your container running.\n \n"}, {"color": "green", "id": "text_183", "label": "240\nCHAPTER 8\nAccessing pod metadata and other resources from applications\nYou may also remember that each service also gets a DNS entry, so you don\u2019t even\nneed to look up the environment variables, but instead simply point curl to\nhttps:/\n/kubernetes. To be fair, if you don\u2019t know which port the service is available at,\nyou also either need to look up the environment variables or perform a DNS SRV\nrecord lookup to get the service\u2019s actual port number. \n The environment variables shown previously say that the API server is listening on\nport 443, which is the default port for HTTPS, so try hitting the server through\nHTTPS:\nroot@curl:/# curl https://kubernetes\ncurl: (60) SSL certificate problem: unable to get local issuer certificate\n...\nIf you\u0027d like to turn off curl\u0027s verification of the certificate, use\n  the -k (or --insecure) option.\nAlthough the simplest way to get around this is to use the proposed -k option (and\nthis is what you\u2019d normally use when playing with the API server manually), let\u2019s look\nat the longer (and correct) route. Instead of blindly trusting that the server you\u2019re\nconnecting to is the authentic API server, you\u2019ll verify its identity by having curl check\nits certificate. \nTIP\nNever skip checking the server\u2019s certificate in an actual application.\nDoing so could make your app expose its authentication token to an attacker\nusing a man-in-the-middle attack.\nVERIFYING THE SERVER\u2019S IDENTITY\nIn the previous chapter, while discussing Secrets, we looked at an automatically cre-\nated Secret called default-token-xyz, which is mounted into each container at\n/var/run/secrets/kubernetes.io/serviceaccount/. Let\u2019s see the contents of that Secret\nagain, by listing files in that directory:\nroot@curl:/# \nls \n/var/run/secrets/kubernetes.io/serviceaccount/ \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \nca.crt    namespace    token\nThe Secret has three entries (and therefore three files in the Secret volume). Right\nnow, we\u2019ll focus on the ca.crt file, which holds the certificate of the certificate author-\nity (CA) used to sign the Kubernetes API server\u2019s certificate. To verify you\u2019re talking to\nthe API server, you need to check if the server\u2019s certificate is signed by the CA. curl\nallows you to specify the CA certificate with the --cacert option, so try hitting the API\nserver again:\nroot@curl:/# curl --cacert /var/run/secrets/kubernetes.io/serviceaccount\n             \u27a5 /ca.crt https://kubernetes\nUnauthorized\nNOTE\nYou may see a longer error description than \u201cUnauthorized.\u201d\n \n", "shape": "dot", "size": 10, "title": "240\nCHAPTER 8\nAccessing pod metadata and other resources from applications\nYou may also remember that each service also gets a DNS entry, so you don\u2019t even\nneed to look up the environment variables, but instead simply point curl to\nhttps:/\n/kubernetes. To be fair, if you don\u2019t know which port the service is available at,\nyou also either need to look up the environment variables or perform a DNS SRV\nrecord lookup to get the service\u2019s actual port number. \n The environment variables shown previously say that the API server is listening on\nport 443, which is the default port for HTTPS, so try hitting the server through\nHTTPS:\nroot@curl:/# curl https://kubernetes\ncurl: (60) SSL certificate problem: unable to get local issuer certificate\n...\nIf you\u0027d like to turn off curl\u0027s verification of the certificate, use\n  the -k (or --insecure) option.\nAlthough the simplest way to get around this is to use the proposed -k option (and\nthis is what you\u2019d normally use when playing with the API server manually), let\u2019s look\nat the longer (and correct) route. Instead of blindly trusting that the server you\u2019re\nconnecting to is the authentic API server, you\u2019ll verify its identity by having curl check\nits certificate. \nTIP\nNever skip checking the server\u2019s certificate in an actual application.\nDoing so could make your app expose its authentication token to an attacker\nusing a man-in-the-middle attack.\nVERIFYING THE SERVER\u2019S IDENTITY\nIn the previous chapter, while discussing Secrets, we looked at an automatically cre-\nated Secret called default-token-xyz, which is mounted into each container at\n/var/run/secrets/kubernetes.io/serviceaccount/. Let\u2019s see the contents of that Secret\nagain, by listing files in that directory:\nroot@curl:/# \nls \n/var/run/secrets/kubernetes.io/serviceaccount/ \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \nca.crt    namespace    token\nThe Secret has three entries (and therefore three files in the Secret volume). Right\nnow, we\u2019ll focus on the ca.crt file, which holds the certificate of the certificate author-\nity (CA) used to sign the Kubernetes API server\u2019s certificate. To verify you\u2019re talking to\nthe API server, you need to check if the server\u2019s certificate is signed by the CA. curl\nallows you to specify the CA certificate with the --cacert option, so try hitting the API\nserver again:\nroot@curl:/# curl --cacert /var/run/secrets/kubernetes.io/serviceaccount\n             \u27a5 /ca.crt https://kubernetes\nUnauthorized\nNOTE\nYou may see a longer error description than \u201cUnauthorized.\u201d\n \n"}, {"color": "green", "id": "text_184", "label": "241\nTalking to the Kubernetes API server\nOkay, you\u2019ve made progress. curl verified the server\u2019s identity because its certificate\nwas signed by the CA you trust. As the Unauthorized response suggests, you still need\nto take care of authentication. You\u2019ll do that in a moment, but first let\u2019s see how to\nmake life easier by setting the CURL_CA_BUNDLE environment variable, so you don\u2019t\nneed to specify --cacert every time you run curl:\nroot@curl:/# export CURL_CA_BUNDLE=/var/run/secrets/kubernetes.io/\n             \u27a5 serviceaccount/ca.crt\nYou can now hit the API server without using --cacert:\nroot@curl:/# curl https://kubernetes\nUnauthorized\nThis is much nicer now. Your client (curl) trusts the API server now, but the API\nserver itself says you\u2019re not authorized to access it, because it doesn\u2019t know who\nyou are.\nAUTHENTICATING WITH THE API SERVER\nYou need to authenticate with the server, so it allows you to read and even update\nand/or delete the API objects deployed in the cluster. To authenticate, you need an\nauthentication token. Luckily, the token is provided through the default-token Secret\nmentioned previously, and is stored in the token file in the secret volume. As the\nSecret\u2019s name suggests, that\u2019s the primary purpose of the Secret. \n You\u2019re going to use the token to access the API server. First, load the token into an\nenvironment variable:\nroot@curl:/# TOKEN=$(cat /var/run/secrets/kubernetes.io/\n             \u27a5 serviceaccount/token)\nThe token is now stored in the TOKEN environment variable. You can use it when send-\ning requests to the API server, as shown in the following listing.\nroot@curl:/# curl -H \"Authorization: Bearer $TOKEN\" https://kubernetes\n{\n  \"paths\": [\n    \"/api\",\n    \"/api/v1\",\n    \"/apis\",\n    \"/apis/apps\",\n    \"/apis/apps/v1beta1\",\n    \"/apis/authorization.k8s.io\",    \n    ...\n    \"/ui/\",\n    \"/version\"\n  ]\n}\nListing 8.13\nGetting a proper response from the API server\n \n", "shape": "dot", "size": 10, "title": "241\nTalking to the Kubernetes API server\nOkay, you\u2019ve made progress. curl verified the server\u2019s identity because its certificate\nwas signed by the CA you trust. As the Unauthorized response suggests, you still need\nto take care of authentication. You\u2019ll do that in a moment, but first let\u2019s see how to\nmake life easier by setting the CURL_CA_BUNDLE environment variable, so you don\u2019t\nneed to specify --cacert every time you run curl:\nroot@curl:/# export CURL_CA_BUNDLE=/var/run/secrets/kubernetes.io/\n             \u27a5 serviceaccount/ca.crt\nYou can now hit the API server without using --cacert:\nroot@curl:/# curl https://kubernetes\nUnauthorized\nThis is much nicer now. Your client (curl) trusts the API server now, but the API\nserver itself says you\u2019re not authorized to access it, because it doesn\u2019t know who\nyou are.\nAUTHENTICATING WITH THE API SERVER\nYou need to authenticate with the server, so it allows you to read and even update\nand/or delete the API objects deployed in the cluster. To authenticate, you need an\nauthentication token. Luckily, the token is provided through the default-token Secret\nmentioned previously, and is stored in the token file in the secret volume. As the\nSecret\u2019s name suggests, that\u2019s the primary purpose of the Secret. \n You\u2019re going to use the token to access the API server. First, load the token into an\nenvironment variable:\nroot@curl:/# TOKEN=$(cat /var/run/secrets/kubernetes.io/\n             \u27a5 serviceaccount/token)\nThe token is now stored in the TOKEN environment variable. You can use it when send-\ning requests to the API server, as shown in the following listing.\nroot@curl:/# curl -H \"Authorization: Bearer $TOKEN\" https://kubernetes\n{\n  \"paths\": [\n    \"/api\",\n    \"/api/v1\",\n    \"/apis\",\n    \"/apis/apps\",\n    \"/apis/apps/v1beta1\",\n    \"/apis/authorization.k8s.io\",    \n    ...\n    \"/ui/\",\n    \"/version\"\n  ]\n}\nListing 8.13\nGetting a proper response from the API server\n \n"}, {"color": "green", "id": "text_185", "label": "242\nCHAPTER 8\nAccessing pod metadata and other resources from applications\nAs you can see, you passed the token inside the Authorization HTTP header in the\nrequest. The API server recognized the token as authentic and returned a proper\nresponse. You can now explore all the resources in your cluster, the way you did a few\nsections ago. \n For example, you could list all the pods in the same namespace. But first you need\nto know what namespace the curl pod is running in.\nGETTING THE NAMESPACE THE POD IS RUNNING IN\nIn the first part of this chapter, you saw how to pass the namespace to the pod\nthrough the Downward API. But if you\u2019re paying attention, you probably noticed\nyour secret volume also contains a file called namespace. It contains the name-\nspace the pod is running in, so you can read the file instead of having to explicitly\npass the namespace to your pod through an environment variable. Load the con-\ntents of the file into the NS environment variable and then list all the pods, as shown\nin the following listing.\nroot@curl:/# NS=$(cat /var/run/secrets/kubernetes.io/\n             \u27a5 serviceaccount/namespace)           \nroot@curl:/# curl -H \"Authorization: Bearer $TOKEN\"\n             \u27a5 https://kubernetes/api/v1/namespaces/$NS/pods\n{\n  \"kind\": \"PodList\",\n  \"apiVersion\": \"v1\",\n  ...\nAnd there you go. By using the three files in the mounted secret volume directory,\nyou listed all the pods running in the same namespace as your pod. In the same man-\nner, you could also retrieve other API objects and even update them by sending PUT or\nPATCH instead of simple GET requests. \nDisabling role-based access control (RBAC)\nIf you\u2019re using a Kubernetes cluster with RBAC enabled, the service account may not\nbe authorized to access (parts of) the API server. You\u2019ll learn about service accounts\nand RBAC in chapter 12. For now, the simplest way to allow you to query the API\nserver is to work around RBAC by running the following command:\n$ kubectl create clusterrolebinding permissive-binding \\\n  --clusterrole=cluster-admin \\\n  --group=system:serviceaccounts\nThis gives all service accounts (we could also say all pods) cluster-admin privileges,\nallowing them to do whatever they want. Obviously, doing this is dangerous and\nshould never be done on production clusters. For test purposes, it\u2019s fine.\nListing 8.14\nListing pods in the pod\u2019s own namespace\n \n", "shape": "dot", "size": 10, "title": "242\nCHAPTER 8\nAccessing pod metadata and other resources from applications\nAs you can see, you passed the token inside the Authorization HTTP header in the\nrequest. The API server recognized the token as authentic and returned a proper\nresponse. You can now explore all the resources in your cluster, the way you did a few\nsections ago. \n For example, you could list all the pods in the same namespace. But first you need\nto know what namespace the curl pod is running in.\nGETTING THE NAMESPACE THE POD IS RUNNING IN\nIn the first part of this chapter, you saw how to pass the namespace to the pod\nthrough the Downward API. But if you\u2019re paying attention, you probably noticed\nyour secret volume also contains a file called namespace. It contains the name-\nspace the pod is running in, so you can read the file instead of having to explicitly\npass the namespace to your pod through an environment variable. Load the con-\ntents of the file into the NS environment variable and then list all the pods, as shown\nin the following listing.\nroot@curl:/# NS=$(cat /var/run/secrets/kubernetes.io/\n             \u27a5 serviceaccount/namespace)           \nroot@curl:/# curl -H \"Authorization: Bearer $TOKEN\"\n             \u27a5 https://kubernetes/api/v1/namespaces/$NS/pods\n{\n  \"kind\": \"PodList\",\n  \"apiVersion\": \"v1\",\n  ...\nAnd there you go. By using the three files in the mounted secret volume directory,\nyou listed all the pods running in the same namespace as your pod. In the same man-\nner, you could also retrieve other API objects and even update them by sending PUT or\nPATCH instead of simple GET requests. \nDisabling role-based access control (RBAC)\nIf you\u2019re using a Kubernetes cluster with RBAC enabled, the service account may not\nbe authorized to access (parts of) the API server. You\u2019ll learn about service accounts\nand RBAC in chapter 12. For now, the simplest way to allow you to query the API\nserver is to work around RBAC by running the following command:\n$ kubectl create clusterrolebinding permissive-binding \\\n  --clusterrole=cluster-admin \\\n  --group=system:serviceaccounts\nThis gives all service accounts (we could also say all pods) cluster-admin privileges,\nallowing them to do whatever they want. Obviously, doing this is dangerous and\nshould never be done on production clusters. For test purposes, it\u2019s fine.\nListing 8.14\nListing pods in the pod\u2019s own namespace\n \n"}, {"color": "green", "id": "text_186", "label": "243\nTalking to the Kubernetes API server\nRECAPPING HOW PODS TALK TO KUBERNETES\nLet\u2019s recap how an app running inside a pod can access the Kubernetes API properly:\n\uf0a1The app should verify whether the API server\u2019s certificate is signed by the certif-\nicate authority, whose certificate is in the ca.crt file. \n\uf0a1The app should authenticate itself by sending the Authorization header with\nthe bearer token from the token file. \n\uf0a1The namespace file should be used to pass the namespace to the API server when\nperforming CRUD operations on API objects inside the pod\u2019s namespace.\nDEFINITION\nCRUD stands for Create, Read, Update, and Delete. The corre-\nsponding HTTP methods are POST, GET, PATCH/PUT, and DELETE, respectively.\nAll three aspects of pod to API server communication are displayed in figure 8.5.\n8.2.3\nSimplifying API server communication with ambassador \ncontainers\nDealing with HTTPS, certificates, and authentication tokens sometimes seems too\ncomplicated to developers. I\u2019ve seen developers disable validation of server certifi-\ncates on way too many occasions (and I\u2019ll admit to doing it myself a few times). Luck-\nily, you can make the communication much simpler while keeping it secure. \nAPI server\nGET /api/v1/namespaces/\u003cnamespace\u003e/pods\nAuthorization: Bearer \u003ctoken\u003e\nPod\nContainer\nFilesystem\nApp\n/\nvar/\nrun/\nsecrets/\nkubernetes.io/\nserviceaccount/\nDefault token secret volume\nca.crt\ntoken\nnamespace\nServer\ncerti\ufb01cate\nValidate\ncerti\ufb01cate\nFigure 8.5\nUsing the files from the default-token Secret to talk to the API server\n \n", "shape": "dot", "size": 10, "title": "243\nTalking to the Kubernetes API server\nRECAPPING HOW PODS TALK TO KUBERNETES\nLet\u2019s recap how an app running inside a pod can access the Kubernetes API properly:\n\uf0a1The app should verify whether the API server\u2019s certificate is signed by the certif-\nicate authority, whose certificate is in the ca.crt file. \n\uf0a1The app should authenticate itself by sending the Authorization header with\nthe bearer token from the token file. \n\uf0a1The namespace file should be used to pass the namespace to the API server when\nperforming CRUD operations on API objects inside the pod\u2019s namespace.\nDEFINITION\nCRUD stands for Create, Read, Update, and Delete. The corre-\nsponding HTTP methods are POST, GET, PATCH/PUT, and DELETE, respectively.\nAll three aspects of pod to API server communication are displayed in figure 8.5.\n8.2.3\nSimplifying API server communication with ambassador \ncontainers\nDealing with HTTPS, certificates, and authentication tokens sometimes seems too\ncomplicated to developers. I\u2019ve seen developers disable validation of server certifi-\ncates on way too many occasions (and I\u2019ll admit to doing it myself a few times). Luck-\nily, you can make the communication much simpler while keeping it secure. \nAPI server\nGET /api/v1/namespaces/\u003cnamespace\u003e/pods\nAuthorization: Bearer \u003ctoken\u003e\nPod\nContainer\nFilesystem\nApp\n/\nvar/\nrun/\nsecrets/\nkubernetes.io/\nserviceaccount/\nDefault token secret volume\nca.crt\ntoken\nnamespace\nServer\ncerti\ufb01cate\nValidate\ncerti\ufb01cate\nFigure 8.5\nUsing the files from the default-token Secret to talk to the API server\n \n"}, {"color": "green", "id": "text_187", "label": "244\nCHAPTER 8\nAccessing pod metadata and other resources from applications\n Remember the kubectl proxy command we mentioned in section 8.2.1? You ran\nthe command on your local machine to make it easier to access the API server. Instead\nof sending requests to the API server directly, you sent them to the proxy and let it\ntake care of authentication, encryption, and server verification. The same method can\nbe used inside your pods, as well.\nINTRODUCING THE AMBASSADOR CONTAINER PATTERN\nImagine having an application that (among other things) needs to query the API\nserver. Instead of it talking to the API server directly, as you did in the previous sec-\ntion, you can run kubectl proxy in an ambassador container alongside the main con-\ntainer and communicate with the API server through it. \n Instead of talking to the API server directly, the app in the main container can con-\nnect to the ambassador through HTTP (instead of HTTPS) and let the ambassador\nproxy handle the HTTPS connection to the API server, taking care of security trans-\nparently (see figure 8.6). It does this by using the files from the default token\u2019s secret\nvolume.\nBecause all containers in a pod share the same loopback network interface, your app\ncan access the proxy through a port on localhost.\nRUNNING THE CURL POD WITH AN ADDITIONAL AMBASSADOR CONTAINER\nTo see the ambassador container pattern in action, you\u2019ll create a new pod like the\ncurl pod you created earlier, but this time, instead of running a single container in\nthe pod, you\u2019ll run an additional ambassador container based on a general-purpose\nkubectl-proxy container image I\u2019ve created and pushed to Docker Hub. You\u2019ll find\nthe Dockerfile for the image in the code archive (in /Chapter08/kubectl-proxy/) if\nyou want to build it yourself.\n The pod\u2019s manifest is shown in the following listing.\napiVersion: v1\nkind: Pod\nmetadata:\n  name: curl-with-ambassador\nspec:\n  containers:\n  - name: main\nListing 8.15\nA pod with an ambassador container: curl-with-ambassador.yaml\nContainer:\nmain\nContainer:\nambassador\nHTTP\nHTTPS\nAPI server\nPod\nFigure 8.6\nUsing an ambassador to connect to the API server\n \n", "shape": "dot", "size": 10, "title": "244\nCHAPTER 8\nAccessing pod metadata and other resources from applications\n Remember the kubectl proxy command we mentioned in section 8.2.1? You ran\nthe command on your local machine to make it easier to access the API server. Instead\nof sending requests to the API server directly, you sent them to the proxy and let it\ntake care of authentication, encryption, and server verification. The same method can\nbe used inside your pods, as well.\nINTRODUCING THE AMBASSADOR CONTAINER PATTERN\nImagine having an application that (among other things) needs to query the API\nserver. Instead of it talking to the API server directly, as you did in the previous sec-\ntion, you can run kubectl proxy in an ambassador container alongside the main con-\ntainer and communicate with the API server through it. \n Instead of talking to the API server directly, the app in the main container can con-\nnect to the ambassador through HTTP (instead of HTTPS) and let the ambassador\nproxy handle the HTTPS connection to the API server, taking care of security trans-\nparently (see figure 8.6). It does this by using the files from the default token\u2019s secret\nvolume.\nBecause all containers in a pod share the same loopback network interface, your app\ncan access the proxy through a port on localhost.\nRUNNING THE CURL POD WITH AN ADDITIONAL AMBASSADOR CONTAINER\nTo see the ambassador container pattern in action, you\u2019ll create a new pod like the\ncurl pod you created earlier, but this time, instead of running a single container in\nthe pod, you\u2019ll run an additional ambassador container based on a general-purpose\nkubectl-proxy container image I\u2019ve created and pushed to Docker Hub. You\u2019ll find\nthe Dockerfile for the image in the code archive (in /Chapter08/kubectl-proxy/) if\nyou want to build it yourself.\n The pod\u2019s manifest is shown in the following listing.\napiVersion: v1\nkind: Pod\nmetadata:\n  name: curl-with-ambassador\nspec:\n  containers:\n  - name: main\nListing 8.15\nA pod with an ambassador container: curl-with-ambassador.yaml\nContainer:\nmain\nContainer:\nambassador\nHTTP\nHTTPS\nAPI server\nPod\nFigure 8.6\nUsing an ambassador to connect to the API server\n \n"}, {"color": "green", "id": "text_188", "label": "245\nTalking to the Kubernetes API server\n    image: tutum/curl\n    command: [\"sleep\", \"9999999\"]\n  - name: ambassador                         \n    image: luksa/kubectl-proxy:1.6.2         \nThe pod spec is almost the same as before, but with a different pod name and an addi-\ntional container. Run the pod and then enter the main container with\n$ kubectl exec -it curl-with-ambassador -c main bash\nroot@curl-with-ambassador:/#\nYour pod now has two containers, and you want to run bash in the main container,\nhence the -c main option. You don\u2019t need to specify the container explicitly if you\nwant to run the command in the pod\u2019s first container. But if you want to run a com-\nmand inside any other container, you do need to specify the container\u2019s name using\nthe -c option.\nTALKING TO THE API SERVER THROUGH THE AMBASSADOR\nNext you\u2019ll try connecting to the API server through the ambassador container. By\ndefault, kubectl proxy binds to port 8001, and because both containers in the pod\nshare the same network interfaces, including loopback, you can point curl to local-\nhost:8001, as shown in the following listing.\nroot@curl-with-ambassador:/# curl localhost:8001\n{\n  \"paths\": [\n    \"/api\",\n    ...\n  ]\n}\nSuccess! The output printed by curl is the same response you saw earlier, but this time\nyou didn\u2019t need to deal with authentication tokens and server certificates. \n To get a clear picture of what exactly happened, refer to figure 8.7. curl sent the\nplain HTTP request (without any authentication headers) to the proxy running inside\nthe ambassador container, and then the proxy sent an HTTPS request to the API\nserver, handling the client authentication by sending the token and checking the\nserver\u2019s identity by validating its certificate.\n This is a great example of how an ambassador container can be used to hide the\ncomplexities of connecting to an external service and simplify the app running in\nthe main container. The ambassador container is reusable across many different apps,\nregardless of what language the main app is written in. The downside is that an addi-\ntional process is running and consuming additional resources.\nListing 8.16\nAccessing the API server through the ambassador container\nThe ambassador container, \nrunning the kubectl-proxy image\n \n", "shape": "dot", "size": 10, "title": "245\nTalking to the Kubernetes API server\n    image: tutum/curl\n    command: [\"sleep\", \"9999999\"]\n  - name: ambassador                         \n    image: luksa/kubectl-proxy:1.6.2         \nThe pod spec is almost the same as before, but with a different pod name and an addi-\ntional container. Run the pod and then enter the main container with\n$ kubectl exec -it curl-with-ambassador -c main bash\nroot@curl-with-ambassador:/#\nYour pod now has two containers, and you want to run bash in the main container,\nhence the -c main option. You don\u2019t need to specify the container explicitly if you\nwant to run the command in the pod\u2019s first container. But if you want to run a com-\nmand inside any other container, you do need to specify the container\u2019s name using\nthe -c option.\nTALKING TO THE API SERVER THROUGH THE AMBASSADOR\nNext you\u2019ll try connecting to the API server through the ambassador container. By\ndefault, kubectl proxy binds to port 8001, and because both containers in the pod\nshare the same network interfaces, including loopback, you can point curl to local-\nhost:8001, as shown in the following listing.\nroot@curl-with-ambassador:/# curl localhost:8001\n{\n  \"paths\": [\n    \"/api\",\n    ...\n  ]\n}\nSuccess! The output printed by curl is the same response you saw earlier, but this time\nyou didn\u2019t need to deal with authentication tokens and server certificates. \n To get a clear picture of what exactly happened, refer to figure 8.7. curl sent the\nplain HTTP request (without any authentication headers) to the proxy running inside\nthe ambassador container, and then the proxy sent an HTTPS request to the API\nserver, handling the client authentication by sending the token and checking the\nserver\u2019s identity by validating its certificate.\n This is a great example of how an ambassador container can be used to hide the\ncomplexities of connecting to an external service and simplify the app running in\nthe main container. The ambassador container is reusable across many different apps,\nregardless of what language the main app is written in. The downside is that an addi-\ntional process is running and consuming additional resources.\nListing 8.16\nAccessing the API server through the ambassador container\nThe ambassador container, \nrunning the kubectl-proxy image\n \n"}, {"color": "green", "id": "text_189", "label": "246\nCHAPTER 8\nAccessing pod metadata and other resources from applications\n8.2.4\nUsing client libraries to talk to the API server\nIf your app only needs to perform a few simple operations on the API server, you can\noften use a regular HTTP client library and perform simple HTTP requests, especially\nif you take advantage of the kubectl-proxy ambassador container the way you did in\nthe previous example. But if you plan on doing more than simple API requests, it\u2019s\nbetter to use one of the existing Kubernetes API client libraries.\nUSING EXISTING CLIENT LIBRARIES\nCurrently, two Kubernetes API client libraries exist that are supported by the API\nMachinery special interest group (SIG):\n\uf0a1Golang client\u2014https:/\n/github.com/kubernetes/client-go\n\uf0a1Python\u2014https:/\n/github.com/kubernetes-incubator/client-python\nNOTE\nThe Kubernetes community has a number of Special Interest Groups\n(SIGs) and Working Groups that focus on specific parts of the Kubernetes\necosystem. You\u2019ll find a list of them at https:/\n/github.com/kubernetes/com-\nmunity/blob/master/sig-list.md.\nIn addition to the two officially supported libraries, here\u2019s a list of user-contributed cli-\nent libraries for many other languages:\n\uf0a1Java client by Fabric8\u2014https:/\n/github.com/fabric8io/kubernetes-client\n\uf0a1Java client by Amdatu\u2014https:/\n/bitbucket.org/amdatulabs/amdatu-kubernetes\n\uf0a1Node.js client by tenxcloud\u2014https:/\n/github.com/tenxcloud/node-kubernetes-client\n\uf0a1Node.js client by GoDaddy\u2014https:/\n/github.com/godaddy/kubernetes-client\n\uf0a1PHP\u2014https:/\n/github.com/devstub/kubernetes-api-php-client\n\uf0a1Another PHP client\u2014https:/\n/github.com/maclof/kubernetes-client\nContainer: main\nAPI server\nsleep\ncurl\nContainer: ambassador\nkubectl proxy\nPort 8001\nGET http://localhost:8001\nGET https://kubernetes:443\nAuthorization: Bearer \u003ctoken\u003e\nPod\nFigure 8.7\nOffloading encryption, authentication, and server verification to kubectl proxy in an \nambassador container \n \n", "shape": "dot", "size": 10, "title": "246\nCHAPTER 8\nAccessing pod metadata and other resources from applications\n8.2.4\nUsing client libraries to talk to the API server\nIf your app only needs to perform a few simple operations on the API server, you can\noften use a regular HTTP client library and perform simple HTTP requests, especially\nif you take advantage of the kubectl-proxy ambassador container the way you did in\nthe previous example. But if you plan on doing more than simple API requests, it\u2019s\nbetter to use one of the existing Kubernetes API client libraries.\nUSING EXISTING CLIENT LIBRARIES\nCurrently, two Kubernetes API client libraries exist that are supported by the API\nMachinery special interest group (SIG):\n\uf0a1Golang client\u2014https:/\n/github.com/kubernetes/client-go\n\uf0a1Python\u2014https:/\n/github.com/kubernetes-incubator/client-python\nNOTE\nThe Kubernetes community has a number of Special Interest Groups\n(SIGs) and Working Groups that focus on specific parts of the Kubernetes\necosystem. You\u2019ll find a list of them at https:/\n/github.com/kubernetes/com-\nmunity/blob/master/sig-list.md.\nIn addition to the two officially supported libraries, here\u2019s a list of user-contributed cli-\nent libraries for many other languages:\n\uf0a1Java client by Fabric8\u2014https:/\n/github.com/fabric8io/kubernetes-client\n\uf0a1Java client by Amdatu\u2014https:/\n/bitbucket.org/amdatulabs/amdatu-kubernetes\n\uf0a1Node.js client by tenxcloud\u2014https:/\n/github.com/tenxcloud/node-kubernetes-client\n\uf0a1Node.js client by GoDaddy\u2014https:/\n/github.com/godaddy/kubernetes-client\n\uf0a1PHP\u2014https:/\n/github.com/devstub/kubernetes-api-php-client\n\uf0a1Another PHP client\u2014https:/\n/github.com/maclof/kubernetes-client\nContainer: main\nAPI server\nsleep\ncurl\nContainer: ambassador\nkubectl proxy\nPort 8001\nGET http://localhost:8001\nGET https://kubernetes:443\nAuthorization: Bearer \u003ctoken\u003e\nPod\nFigure 8.7\nOffloading encryption, authentication, and server verification to kubectl proxy in an \nambassador container \n \n"}, {"color": "green", "id": "text_190", "label": "247\nTalking to the Kubernetes API server\n\uf0a1Ruby\u2014https:/\n/github.com/Ch00k/kubr\n\uf0a1Another Ruby client\u2014https:/\n/github.com/abonas/kubeclient\n\uf0a1Clojure\u2014https:/\n/github.com/yanatan16/clj-kubernetes-api\n\uf0a1Scala\u2014https:/\n/github.com/doriordan/skuber\n\uf0a1Perl\u2014https:/\n/metacpan.org/pod/Net::Kubernetes\nThese libraries usually support HTTPS and take care of authentication, so you won\u2019t\nneed to use the ambassador container. \nAN EXAMPLE OF INTERACTING WITH KUBERNETES WITH THE FABRIC8 JAVA CLIENT\nTo give you a sense of how client libraries enable you to talk to the API server, the fol-\nlowing listing shows an example of how to list services in a Java app using the Fabric8\nKubernetes client.\nimport java.util.Arrays;\nimport io.fabric8.kubernetes.api.model.Pod;\nimport io.fabric8.kubernetes.api.model.PodList;\nimport io.fabric8.kubernetes.client.DefaultKubernetesClient;\nimport io.fabric8.kubernetes.client.KubernetesClient;\npublic class Test {\n  public static void main(String[] args) throws Exception {\n    KubernetesClient client = new DefaultKubernetesClient();\n    // list pods in the default namespace\n    PodList pods = client.pods().inNamespace(\"default\").list();\n    pods.getItems().stream()\n      .forEach(s -\u003e System.out.println(\"Found pod: \" +\n               s.getMetadata().getName()));\n    // create a pod\n    System.out.println(\"Creating a pod\");\n    Pod pod = client.pods().inNamespace(\"default\")\n      .createNew()\n      .withNewMetadata()\n        .withName(\"programmatically-created-pod\")\n      .endMetadata()\n      .withNewSpec()\n        .addNewContainer()\n          .withName(\"main\")\n          .withImage(\"busybox\")\n          .withCommand(Arrays.asList(\"sleep\", \"99999\"))\n        .endContainer()\n      .endSpec()\n      .done();\n    System.out.println(\"Created pod: \" + pod);\n    // edit the pod (add a label to it)\n    client.pods().inNamespace(\"default\")\n      .withName(\"programmatically-created-pod\")\n      .edit()\n      .editMetadata()\nListing 8.17\nListing, creating, updating, and deleting pods with the Fabric8 Java client\n \n", "shape": "dot", "size": 10, "title": "247\nTalking to the Kubernetes API server\n\uf0a1Ruby\u2014https:/\n/github.com/Ch00k/kubr\n\uf0a1Another Ruby client\u2014https:/\n/github.com/abonas/kubeclient\n\uf0a1Clojure\u2014https:/\n/github.com/yanatan16/clj-kubernetes-api\n\uf0a1Scala\u2014https:/\n/github.com/doriordan/skuber\n\uf0a1Perl\u2014https:/\n/metacpan.org/pod/Net::Kubernetes\nThese libraries usually support HTTPS and take care of authentication, so you won\u2019t\nneed to use the ambassador container. \nAN EXAMPLE OF INTERACTING WITH KUBERNETES WITH THE FABRIC8 JAVA CLIENT\nTo give you a sense of how client libraries enable you to talk to the API server, the fol-\nlowing listing shows an example of how to list services in a Java app using the Fabric8\nKubernetes client.\nimport java.util.Arrays;\nimport io.fabric8.kubernetes.api.model.Pod;\nimport io.fabric8.kubernetes.api.model.PodList;\nimport io.fabric8.kubernetes.client.DefaultKubernetesClient;\nimport io.fabric8.kubernetes.client.KubernetesClient;\npublic class Test {\n  public static void main(String[] args) throws Exception {\n    KubernetesClient client = new DefaultKubernetesClient();\n    // list pods in the default namespace\n    PodList pods = client.pods().inNamespace(\"default\").list();\n    pods.getItems().stream()\n      .forEach(s -\u003e System.out.println(\"Found pod: \" +\n               s.getMetadata().getName()));\n    // create a pod\n    System.out.println(\"Creating a pod\");\n    Pod pod = client.pods().inNamespace(\"default\")\n      .createNew()\n      .withNewMetadata()\n        .withName(\"programmatically-created-pod\")\n      .endMetadata()\n      .withNewSpec()\n        .addNewContainer()\n          .withName(\"main\")\n          .withImage(\"busybox\")\n          .withCommand(Arrays.asList(\"sleep\", \"99999\"))\n        .endContainer()\n      .endSpec()\n      .done();\n    System.out.println(\"Created pod: \" + pod);\n    // edit the pod (add a label to it)\n    client.pods().inNamespace(\"default\")\n      .withName(\"programmatically-created-pod\")\n      .edit()\n      .editMetadata()\nListing 8.17\nListing, creating, updating, and deleting pods with the Fabric8 Java client\n \n"}, {"color": "green", "id": "text_191", "label": "248\nCHAPTER 8\nAccessing pod metadata and other resources from applications\n        .addToLabels(\"foo\", \"bar\")\n      .endMetadata()\n      .done();\n    System.out.println(\"Added label foo=bar to pod\");\n    System.out.println(\"Waiting 1 minute before deleting pod...\");\n    Thread.sleep(60000);\n    // delete the pod\n    client.pods().inNamespace(\"default\")\n      .withName(\"programmatically-created-pod\")\n      .delete();\n    System.out.println(\"Deleted the pod\");\n  }\n}\nThe code should be self-explanatory, especially because the Fabric8 client exposes\na nice, fluent Domain-Specific-Language (DSL) API, which is easy to read and\nunderstand.\nBUILDING YOUR OWN LIBRARY WITH SWAGGER AND OPENAPI\nIf no client is available for your programming language of choice, you can use the\nSwagger API framework to generate the client library and documentation. The Kuber-\nnetes API server exposes Swagger API definitions at /swaggerapi and OpenAPI spec at\n/swagger.json. \n To find out more about the Swagger framework, visit the website at http:/\n/swagger.io.\nEXPLORING THE API WITH SWAGGER UI\nEarlier in the chapter I said I\u2019d point you to a better way of exploring the REST API\ninstead of hitting the REST endpoints with curl. Swagger, which I mentioned in the\nprevious section, is not just a tool for specifying an API, but also provides a web UI for\nexploring REST APIs if they expose the Swagger API definitions. The better way of\nexploring REST APIs is through this UI.\n Kubernetes not only exposes the Swagger API, but it also has Swagger UI inte-\ngrated into the API server, though it\u2019s not enabled by default. You can enable it by\nrunning the API server with the --enable-swagger-ui=true option.\nTIP\nIf you\u2019re using Minikube, you can enable Swagger UI when starting the\ncluster: minikube start --extra-config=apiserver.Features.Enable-\nSwaggerUI=true\nAfter you enable the UI, you can open it in your browser by pointing it to:\nhttp(s)://\u003capi server\u003e:\u003cport\u003e/swagger-ui\nI urge you to give Swagger UI a try. It not only allows you to browse the Kubernetes\nAPI, but also interact with it (you can POST JSON resource manifests, PATCH resources,\nor DELETE them, for example). \n \n", "shape": "dot", "size": 10, "title": "248\nCHAPTER 8\nAccessing pod metadata and other resources from applications\n        .addToLabels(\"foo\", \"bar\")\n      .endMetadata()\n      .done();\n    System.out.println(\"Added label foo=bar to pod\");\n    System.out.println(\"Waiting 1 minute before deleting pod...\");\n    Thread.sleep(60000);\n    // delete the pod\n    client.pods().inNamespace(\"default\")\n      .withName(\"programmatically-created-pod\")\n      .delete();\n    System.out.println(\"Deleted the pod\");\n  }\n}\nThe code should be self-explanatory, especially because the Fabric8 client exposes\na nice, fluent Domain-Specific-Language (DSL) API, which is easy to read and\nunderstand.\nBUILDING YOUR OWN LIBRARY WITH SWAGGER AND OPENAPI\nIf no client is available for your programming language of choice, you can use the\nSwagger API framework to generate the client library and documentation. The Kuber-\nnetes API server exposes Swagger API definitions at /swaggerapi and OpenAPI spec at\n/swagger.json. \n To find out more about the Swagger framework, visit the website at http:/\n/swagger.io.\nEXPLORING THE API WITH SWAGGER UI\nEarlier in the chapter I said I\u2019d point you to a better way of exploring the REST API\ninstead of hitting the REST endpoints with curl. Swagger, which I mentioned in the\nprevious section, is not just a tool for specifying an API, but also provides a web UI for\nexploring REST APIs if they expose the Swagger API definitions. The better way of\nexploring REST APIs is through this UI.\n Kubernetes not only exposes the Swagger API, but it also has Swagger UI inte-\ngrated into the API server, though it\u2019s not enabled by default. You can enable it by\nrunning the API server with the --enable-swagger-ui=true option.\nTIP\nIf you\u2019re using Minikube, you can enable Swagger UI when starting the\ncluster: minikube start --extra-config=apiserver.Features.Enable-\nSwaggerUI=true\nAfter you enable the UI, you can open it in your browser by pointing it to:\nhttp(s)://\u003capi server\u003e:\u003cport\u003e/swagger-ui\nI urge you to give Swagger UI a try. It not only allows you to browse the Kubernetes\nAPI, but also interact with it (you can POST JSON resource manifests, PATCH resources,\nor DELETE them, for example). \n \n"}, {"color": "green", "id": "text_192", "label": "249\nSummary\n8.3\nSummary\nAfter reading this chapter, you now know how your app, running inside a pod, can get\ndata about itself, other pods, and other components deployed in the cluster. You\u2019ve\nlearned\n\uf0a1How a pod\u2019s name, namespace, and other metadata can be exposed to the pro-\ncess either through environment variables or files in a downwardAPI volume\n\uf0a1How CPU and memory requests and limits are passed to your app in any unit\nthe app requires\n\uf0a1How a pod can use downwardAPI volumes to get up-to-date metadata, which\nmay change during the lifetime of the pod (such as labels and annotations) \n\uf0a1How you can browse the Kubernetes REST API through kubectl proxy\n\uf0a1How pods can find the API server\u2019s location through environment variables or\nDNS, similar to any other Service defined in Kubernetes\n\uf0a1How an application running in a pod can verify that it\u2019s talking to the API\nserver and how it can authenticate itself\n\uf0a1How using an ambassador container can make talking to the API server from\nwithin an app much simpler\n\uf0a1How client libraries can get you interacting with Kubernetes in minutes\nIn this chapter, you learned how to talk to the API server, so the next step is learning\nmore about how it works. You\u2019ll do that in chapter 11, but before we dive into such\ndetails, you still need to learn about two other Kubernetes resources\u2014Deployments\nand StatefulSets. They\u2019re explained in the next two chapters.\n \n", "shape": "dot", "size": 10, "title": "249\nSummary\n8.3\nSummary\nAfter reading this chapter, you now know how your app, running inside a pod, can get\ndata about itself, other pods, and other components deployed in the cluster. You\u2019ve\nlearned\n\uf0a1How a pod\u2019s name, namespace, and other metadata can be exposed to the pro-\ncess either through environment variables or files in a downwardAPI volume\n\uf0a1How CPU and memory requests and limits are passed to your app in any unit\nthe app requires\n\uf0a1How a pod can use downwardAPI volumes to get up-to-date metadata, which\nmay change during the lifetime of the pod (such as labels and annotations) \n\uf0a1How you can browse the Kubernetes REST API through kubectl proxy\n\uf0a1How pods can find the API server\u2019s location through environment variables or\nDNS, similar to any other Service defined in Kubernetes\n\uf0a1How an application running in a pod can verify that it\u2019s talking to the API\nserver and how it can authenticate itself\n\uf0a1How using an ambassador container can make talking to the API server from\nwithin an app much simpler\n\uf0a1How client libraries can get you interacting with Kubernetes in minutes\nIn this chapter, you learned how to talk to the API server, so the next step is learning\nmore about how it works. You\u2019ll do that in chapter 11, but before we dive into such\ndetails, you still need to learn about two other Kubernetes resources\u2014Deployments\nand StatefulSets. They\u2019re explained in the next two chapters.\n \n"}, {"color": "green", "id": "text_193", "label": "250\nDeployments: updating\napplications declaratively\nYou now know how to package your app components into containers, group them\ninto pods, provide them with temporary or permanent storage, pass both secret\nand non-secret config data to them, and allow pods to find and talk to each other.\nYou know how to run a full-fledged system composed of independently running\nsmaller components\u2014microservices, if you will. Is there anything else? \n Eventually, you\u2019re going to want to update your app. This chapter covers how to\nupdate apps running in a Kubernetes cluster and how Kubernetes helps you move\ntoward a true zero-downtime update process. Although this can be achieved using\nonly ReplicationControllers or ReplicaSets, Kubernetes also provides a Deployment\nThis chapter covers\n\uf0a1Replacing pods with newer versions\n\uf0a1Updating managed pods\n\uf0a1Updating pods declaratively using Deployment \nresources\n\uf0a1Performing rolling updates\n\uf0a1Automatically blocking rollouts of bad versions\n\uf0a1Controlling the rate of the rollout\n\uf0a1Reverting pods to a previous version\n \n", "shape": "dot", "size": 10, "title": "250\nDeployments: updating\napplications declaratively\nYou now know how to package your app components into containers, group them\ninto pods, provide them with temporary or permanent storage, pass both secret\nand non-secret config data to them, and allow pods to find and talk to each other.\nYou know how to run a full-fledged system composed of independently running\nsmaller components\u2014microservices, if you will. Is there anything else? \n Eventually, you\u2019re going to want to update your app. This chapter covers how to\nupdate apps running in a Kubernetes cluster and how Kubernetes helps you move\ntoward a true zero-downtime update process. Although this can be achieved using\nonly ReplicationControllers or ReplicaSets, Kubernetes also provides a Deployment\nThis chapter covers\n\uf0a1Replacing pods with newer versions\n\uf0a1Updating managed pods\n\uf0a1Updating pods declaratively using Deployment \nresources\n\uf0a1Performing rolling updates\n\uf0a1Automatically blocking rollouts of bad versions\n\uf0a1Controlling the rate of the rollout\n\uf0a1Reverting pods to a previous version\n \n"}, {"color": "green", "id": "text_194", "label": "251\nUpdating applications running in pods\nresource that sits on top of ReplicaSets and enables declarative application updates. If\nyou\u2019re not completely sure what that means, keep reading\u2014it\u2019s not as complicated as\nit sounds.\n9.1\nUpdating applications running in pods\nLet\u2019s start off with a simple example. Imagine having a set of pod instances providing a\nservice to other pods and/or external clients. After reading this book up to this point,\nyou likely recognize that these pods are backed by a ReplicationController or a\nReplicaSet. A Service also exists through which clients (apps running in other pods or\nexternal clients) access the pods. This is how a basic application looks in Kubernetes\n(shown in figure 9.1).\nInitially, the pods run the first version of your application\u2014let\u2019s suppose its image is\ntagged as v1. You then develop a newer version of the app and push it to an image\nrepository as a new image, tagged as v2. You\u2019d next like to replace all the pods with\nthis new version. Because you can\u2019t change an existing pod\u2019s image after the pod is\ncreated, you need to remove the old pods and replace them with new ones running\nthe new image. \n You have two ways of updating all those pods. You can do one of the following:\n\uf0a1Delete all existing pods first and then start the new ones.\n\uf0a1Start new ones and, once they\u2019re up, delete the old ones. You can do this either\nby adding all the new pods and then deleting all the old ones at once, or\nsequentially, by adding new pods and removing old ones gradually.\nBoth these strategies have their benefits and drawbacks. The first option would lead to\na short period of time when your application is unavailable. The second option\nrequires your app to handle running two versions of the app at the same time. If your\napp stores data in a data store, the new version shouldn\u2019t modify the data schema or\nthe data in such a way that breaks the previous version.\nReplicationController\nor ReplicaSet\nClients\nService\nPod\nPod\nPod\nFigure 9.1\nThe basic outline of an \napplication running in Kubernetes\n \n", "shape": "dot", "size": 10, "title": "251\nUpdating applications running in pods\nresource that sits on top of ReplicaSets and enables declarative application updates. If\nyou\u2019re not completely sure what that means, keep reading\u2014it\u2019s not as complicated as\nit sounds.\n9.1\nUpdating applications running in pods\nLet\u2019s start off with a simple example. Imagine having a set of pod instances providing a\nservice to other pods and/or external clients. After reading this book up to this point,\nyou likely recognize that these pods are backed by a ReplicationController or a\nReplicaSet. A Service also exists through which clients (apps running in other pods or\nexternal clients) access the pods. This is how a basic application looks in Kubernetes\n(shown in figure 9.1).\nInitially, the pods run the first version of your application\u2014let\u2019s suppose its image is\ntagged as v1. You then develop a newer version of the app and push it to an image\nrepository as a new image, tagged as v2. You\u2019d next like to replace all the pods with\nthis new version. Because you can\u2019t change an existing pod\u2019s image after the pod is\ncreated, you need to remove the old pods and replace them with new ones running\nthe new image. \n You have two ways of updating all those pods. You can do one of the following:\n\uf0a1Delete all existing pods first and then start the new ones.\n\uf0a1Start new ones and, once they\u2019re up, delete the old ones. You can do this either\nby adding all the new pods and then deleting all the old ones at once, or\nsequentially, by adding new pods and removing old ones gradually.\nBoth these strategies have their benefits and drawbacks. The first option would lead to\na short period of time when your application is unavailable. The second option\nrequires your app to handle running two versions of the app at the same time. If your\napp stores data in a data store, the new version shouldn\u2019t modify the data schema or\nthe data in such a way that breaks the previous version.\nReplicationController\nor ReplicaSet\nClients\nService\nPod\nPod\nPod\nFigure 9.1\nThe basic outline of an \napplication running in Kubernetes\n \n"}, {"color": "green", "id": "text_195", "label": "252\nCHAPTER 9\nDeployments: updating applications declaratively\n How do you perform these two update methods in Kubernetes? First, let\u2019s look at\nhow to do this manually; then, once you know what\u2019s involved in the process, you\u2019ll\nlearn how to have Kubernetes perform the update automatically.\n9.1.1\nDeleting old pods and replacing them with new ones\nYou already know how to get a ReplicationController to replace all its pod instances\nwith pods running a new version. You probably remember the pod template of a\nReplicationController can be updated at any time. When the ReplicationController\ncreates new instances, it uses the updated pod template to create them.\n If you have a ReplicationController managing a set of v1 pods, you can easily\nreplace them by modifying the pod template so it refers to version v2 of the image and\nthen deleting the old pod instances. The ReplicationController will notice that no\npods match its label selector and it will spin up new instances. The whole process is\nshown in figure 9.2.\nThis is the simplest way to update a set of pods, if you can accept the short downtime\nbetween the time the old pods are deleted and new ones are started.\n9.1.2\nSpinning up new pods and then deleting the old ones\nIf you don\u2019t want to see any downtime and your app supports running multiple ver-\nsions at once, you can turn the process around and first spin up all the new pods and\nPod template\nchanged\nv pods deleted\n1\nmanually\nReplicationController\nService\nPod: v1\nPod: v1\nPod\ntemplate: v2\nReplicationController\nPod\ntemplate: v2\nPod: v1\nService\nPod: v2\nPod: v2\nPod: v2\nReplicationController\nService\nPod: v1\nPod: v1\nPod\ntemplate: v1\nPod: v1\nReplicationController\nService\nPod: v1\nPod: v1\nPod: v1\nPod\ntemplate: v2\nShort period of\ndowntime here\nv2 pods created by\nReplicationController\nFigure 9.2\nUpdating pods by changing a ReplicationController\u2019s pod template and deleting old Pods\n \n", "shape": "dot", "size": 10, "title": "252\nCHAPTER 9\nDeployments: updating applications declaratively\n How do you perform these two update methods in Kubernetes? First, let\u2019s look at\nhow to do this manually; then, once you know what\u2019s involved in the process, you\u2019ll\nlearn how to have Kubernetes perform the update automatically.\n9.1.1\nDeleting old pods and replacing them with new ones\nYou already know how to get a ReplicationController to replace all its pod instances\nwith pods running a new version. You probably remember the pod template of a\nReplicationController can be updated at any time. When the ReplicationController\ncreates new instances, it uses the updated pod template to create them.\n If you have a ReplicationController managing a set of v1 pods, you can easily\nreplace them by modifying the pod template so it refers to version v2 of the image and\nthen deleting the old pod instances. The ReplicationController will notice that no\npods match its label selector and it will spin up new instances. The whole process is\nshown in figure 9.2.\nThis is the simplest way to update a set of pods, if you can accept the short downtime\nbetween the time the old pods are deleted and new ones are started.\n9.1.2\nSpinning up new pods and then deleting the old ones\nIf you don\u2019t want to see any downtime and your app supports running multiple ver-\nsions at once, you can turn the process around and first spin up all the new pods and\nPod template\nchanged\nv pods deleted\n1\nmanually\nReplicationController\nService\nPod: v1\nPod: v1\nPod\ntemplate: v2\nReplicationController\nPod\ntemplate: v2\nPod: v1\nService\nPod: v2\nPod: v2\nPod: v2\nReplicationController\nService\nPod: v1\nPod: v1\nPod\ntemplate: v1\nPod: v1\nReplicationController\nService\nPod: v1\nPod: v1\nPod: v1\nPod\ntemplate: v2\nShort period of\ndowntime here\nv2 pods created by\nReplicationController\nFigure 9.2\nUpdating pods by changing a ReplicationController\u2019s pod template and deleting old Pods\n \n"}, {"color": "green", "id": "text_196", "label": "253\nUpdating applications running in pods\nonly then delete the old ones. This will require more hardware resources, because\nyou\u2019ll have double the number of pods running at the same time for a short while. \n This is a slightly more complex method compared to the previous one, but you\nshould be able to do it by combining what you\u2019ve learned about ReplicationControl-\nlers and Services so far.\nSWITCHING FROM THE OLD TO THE NEW VERSION AT ONCE\nPods are usually fronted by a Service. It\u2019s possible to have the Service front only the\ninitial version of the pods while you bring up the pods running the new version. Then,\nonce all the new pods are up, you can change the Service\u2019s label selector and have the\nService switch over to the new pods, as shown in figure 9.3. This is called a blue-green\ndeployment. After switching over, and once you\u2019re sure the new version functions cor-\nrectly, you\u2019re free to delete the old pods by deleting the old ReplicationController.\nNOTE\nYou can change a Service\u2019s pod selector with the kubectl set selec-\ntor command.\nPERFORMING A ROLLING UPDATE\nInstead of bringing up all the new pods and deleting the old pods at once, you can\nalso perform a rolling update, which replaces pods step by step. You do this by slowly\nscaling down the previous ReplicationController and scaling up the new one. In this\ncase, you\u2019ll want the Service\u2019s pod selector to include both the old and the new pods,\nso it directs requests toward both sets of pods. See figure 9.4.\n Doing a rolling update manually is laborious and error-prone. Depending on the\nnumber of replicas, you\u2019d need to run a dozen or more commands in the proper\norder to perform the update process. Luckily, Kubernetes allows you to perform the\nrolling update with a single command. You\u2019ll learn how in the next section.\nService\nService\nReplicationController:\nv1\nPod: v1\nPod: v1\nPod\ntemplate: v1\nPod: v1\nReplicationController:\nv2\nPod\ntemplate: v2\nPod: v2\nPod: v2\nPod: v2\nReplicationController:\nv1\nPod: v1\nPod: v1\nPod\ntemplate: v1\nPod: v1\nReplicationController:\nv2\nPod\ntemplate: v2\nPod: v2\nPod: v2\nPod: v2\nFigure 9.3\nSwitching a Service from the old pods to the new ones\n \n", "shape": "dot", "size": 10, "title": "253\nUpdating applications running in pods\nonly then delete the old ones. This will require more hardware resources, because\nyou\u2019ll have double the number of pods running at the same time for a short while. \n This is a slightly more complex method compared to the previous one, but you\nshould be able to do it by combining what you\u2019ve learned about ReplicationControl-\nlers and Services so far.\nSWITCHING FROM THE OLD TO THE NEW VERSION AT ONCE\nPods are usually fronted by a Service. It\u2019s possible to have the Service front only the\ninitial version of the pods while you bring up the pods running the new version. Then,\nonce all the new pods are up, you can change the Service\u2019s label selector and have the\nService switch over to the new pods, as shown in figure 9.3. This is called a blue-green\ndeployment. After switching over, and once you\u2019re sure the new version functions cor-\nrectly, you\u2019re free to delete the old pods by deleting the old ReplicationController.\nNOTE\nYou can change a Service\u2019s pod selector with the kubectl set selec-\ntor command.\nPERFORMING A ROLLING UPDATE\nInstead of bringing up all the new pods and deleting the old pods at once, you can\nalso perform a rolling update, which replaces pods step by step. You do this by slowly\nscaling down the previous ReplicationController and scaling up the new one. In this\ncase, you\u2019ll want the Service\u2019s pod selector to include both the old and the new pods,\nso it directs requests toward both sets of pods. See figure 9.4.\n Doing a rolling update manually is laborious and error-prone. Depending on the\nnumber of replicas, you\u2019d need to run a dozen or more commands in the proper\norder to perform the update process. Luckily, Kubernetes allows you to perform the\nrolling update with a single command. You\u2019ll learn how in the next section.\nService\nService\nReplicationController:\nv1\nPod: v1\nPod: v1\nPod\ntemplate: v1\nPod: v1\nReplicationController:\nv2\nPod\ntemplate: v2\nPod: v2\nPod: v2\nPod: v2\nReplicationController:\nv1\nPod: v1\nPod: v1\nPod\ntemplate: v1\nPod: v1\nReplicationController:\nv2\nPod\ntemplate: v2\nPod: v2\nPod: v2\nPod: v2\nFigure 9.3\nSwitching a Service from the old pods to the new ones\n \n"}, {"color": "green", "id": "text_197", "label": "254\nCHAPTER 9\nDeployments: updating applications declaratively\n9.2\nPerforming an automatic rolling update with a \nReplicationController\nInstead of performing rolling updates using ReplicationControllers manually, you can\nhave kubectl perform them. Using kubectl to perform the update makes the process\nmuch easier, but, as you\u2019ll see later, this is now an outdated way of updating apps. Nev-\nertheless, we\u2019ll walk through this option first, because it was historically the first way of\ndoing an automatic rolling update, and also allows us to discuss the process without\nintroducing too many additional concepts. \n9.2.1\nRunning the initial version of the app\nObviously, before you can update an app, you need to have an app deployed. You\u2019re\ngoing to use a slightly modified version of the kubia NodeJS app you created in chap-\nter 2 as your initial version. In case you don\u2019t remember what it does, it\u2019s a simple web-\napp that returns the pod\u2019s hostname in the HTTP response. \nCREATING THE V1 APP\nYou\u2019ll change the app so it also returns its version number in the response, which will\nallow you to distinguish between the different versions you\u2019re about to build. I\u2019ve\nalready built and pushed the app image to Docker Hub under luksa/kubia:v1. The\nfollowing listing shows the app\u2019s code.\nconst http = require(\u0027http\u0027);\nconst os = require(\u0027os\u0027);\nconsole.log(\"Kubia server starting...\");\nListing 9.1\nThe v1 version of our app: v1/app.js\nService\nPod: v1\nPod: v1\nReplication\nController:\nv1\nv1\nReplication\nController:\nv2\nPod: v2\nService\nPod: v2\nPod: v2\nPod: v2\nService\nPod: v1\nPod: v1\nPod: v1\nService\nPod: v1\nPod: v2\nPod: v2\nv2\nReplication\nController:\nv1\nv1\nReplication\nController:\nv2\nv2\nReplication\nController:\nv1\nReplication\nController:\nv2\nv2\nReplication\nController:\nv1\nv1\nv1\nReplication\nController:\nv2\nv2\nFigure 9.4\nA rolling update of pods using two ReplicationControllers\n \n", "shape": "dot", "size": 10, "title": "254\nCHAPTER 9\nDeployments: updating applications declaratively\n9.2\nPerforming an automatic rolling update with a \nReplicationController\nInstead of performing rolling updates using ReplicationControllers manually, you can\nhave kubectl perform them. Using kubectl to perform the update makes the process\nmuch easier, but, as you\u2019ll see later, this is now an outdated way of updating apps. Nev-\nertheless, we\u2019ll walk through this option first, because it was historically the first way of\ndoing an automatic rolling update, and also allows us to discuss the process without\nintroducing too many additional concepts. \n9.2.1\nRunning the initial version of the app\nObviously, before you can update an app, you need to have an app deployed. You\u2019re\ngoing to use a slightly modified version of the kubia NodeJS app you created in chap-\nter 2 as your initial version. In case you don\u2019t remember what it does, it\u2019s a simple web-\napp that returns the pod\u2019s hostname in the HTTP response. \nCREATING THE V1 APP\nYou\u2019ll change the app so it also returns its version number in the response, which will\nallow you to distinguish between the different versions you\u2019re about to build. I\u2019ve\nalready built and pushed the app image to Docker Hub under luksa/kubia:v1. The\nfollowing listing shows the app\u2019s code.\nconst http = require(\u0027http\u0027);\nconst os = require(\u0027os\u0027);\nconsole.log(\"Kubia server starting...\");\nListing 9.1\nThe v1 version of our app: v1/app.js\nService\nPod: v1\nPod: v1\nReplication\nController:\nv1\nv1\nReplication\nController:\nv2\nPod: v2\nService\nPod: v2\nPod: v2\nPod: v2\nService\nPod: v1\nPod: v1\nPod: v1\nService\nPod: v1\nPod: v2\nPod: v2\nv2\nReplication\nController:\nv1\nv1\nReplication\nController:\nv2\nv2\nReplication\nController:\nv1\nReplication\nController:\nv2\nv2\nReplication\nController:\nv1\nv1\nv1\nReplication\nController:\nv2\nv2\nFigure 9.4\nA rolling update of pods using two ReplicationControllers\n \n"}, {"color": "green", "id": "text_198", "label": "255\nPerforming an automatic rolling update with a ReplicationController\nvar handler = function(request, response) {\n  console.log(\"Received request from \" + request.connection.remoteAddress);\n  response.writeHead(200);\n  response.end(\"This is v1 running in pod \" + os.hostname() + \"\\n\");\n};\nvar www = http.createServer(handler);\nwww.listen(8080);\nRUNNING THE APP AND EXPOSING IT THROUGH A SERVICE USING A SINGLE YAML FILE\nTo run your app, you\u2019ll create a ReplicationController and a LoadBalancer Service to\nenable you to access the app externally. This time, rather than create these two\nresources separately, you\u2019ll create a single YAML for both of them and post it to the\nKubernetes API with a single kubectl create command. A YAML manifest can con-\ntain multiple objects delimited with a line containing three dashes, as shown in the\nfollowing listing.\napiVersion: v1\nkind: ReplicationController\nmetadata:\n  name: kubia-v1\nspec:\n  replicas: 3\n  template:\n    metadata:\n      name: kubia\n      labels:                      \n        app: kubia                 \n    spec:\n      containers:\n      - image: luksa/kubia:v1     \n        name: nodejs\n---                         \napiVersion: v1\nkind: Service\nmetadata:\n  name: kubia\nspec:\n  type: LoadBalancer\n  selector:                                        \n    app: kubia                                     \n  ports:\n  - port: 80\n    targetPort: 8080\nThe YAML defines a ReplicationController called kubia-v1 and a Service called\nkubia. Go ahead and post the YAML to Kubernetes. After a while, your three v1 pods\nand the load balancer should all be running, so you can look up the Service\u2019s external\nIP and start hitting the service with curl, as shown in the following listing.\nListing 9.2\nA YAML containing an RC and a Service: kubia-rc-and-service-v1.yaml\nThe Service fronts all \npods created by the \nReplicationController.\nYou\u2019re creating a \nReplicationController for \npods running this image.\nYAML files can contain \nmultiple resource \ndefinitions separated by \na line with three dashes.\n \n", "shape": "dot", "size": 10, "title": "255\nPerforming an automatic rolling update with a ReplicationController\nvar handler = function(request, response) {\n  console.log(\"Received request from \" + request.connection.remoteAddress);\n  response.writeHead(200);\n  response.end(\"This is v1 running in pod \" + os.hostname() + \"\\n\");\n};\nvar www = http.createServer(handler);\nwww.listen(8080);\nRUNNING THE APP AND EXPOSING IT THROUGH A SERVICE USING A SINGLE YAML FILE\nTo run your app, you\u2019ll create a ReplicationController and a LoadBalancer Service to\nenable you to access the app externally. This time, rather than create these two\nresources separately, you\u2019ll create a single YAML for both of them and post it to the\nKubernetes API with a single kubectl create command. A YAML manifest can con-\ntain multiple objects delimited with a line containing three dashes, as shown in the\nfollowing listing.\napiVersion: v1\nkind: ReplicationController\nmetadata:\n  name: kubia-v1\nspec:\n  replicas: 3\n  template:\n    metadata:\n      name: kubia\n      labels:                      \n        app: kubia                 \n    spec:\n      containers:\n      - image: luksa/kubia:v1     \n        name: nodejs\n---                         \napiVersion: v1\nkind: Service\nmetadata:\n  name: kubia\nspec:\n  type: LoadBalancer\n  selector:                                        \n    app: kubia                                     \n  ports:\n  - port: 80\n    targetPort: 8080\nThe YAML defines a ReplicationController called kubia-v1 and a Service called\nkubia. Go ahead and post the YAML to Kubernetes. After a while, your three v1 pods\nand the load balancer should all be running, so you can look up the Service\u2019s external\nIP and start hitting the service with curl, as shown in the following listing.\nListing 9.2\nA YAML containing an RC and a Service: kubia-rc-and-service-v1.yaml\nThe Service fronts all \npods created by the \nReplicationController.\nYou\u2019re creating a \nReplicationController for \npods running this image.\nYAML files can contain \nmultiple resource \ndefinitions separated by \na line with three dashes.\n \n"}, {"color": "green", "id": "text_199", "label": "256\nCHAPTER 9\nDeployments: updating applications declaratively\n$ kubectl get svc kubia\nNAME      CLUSTER-IP     EXTERNAL-IP       PORT(S)         AGE\nkubia     10.3.246.195   130.211.109.222   80:32143/TCP    5m\n$ while true; do curl http://130.211.109.222; done\nThis is v1 running in pod kubia-v1-qr192\nThis is v1 running in pod kubia-v1-kbtsk\nThis is v1 running in pod kubia-v1-qr192\nThis is v1 running in pod kubia-v1-2321o\n...\nNOTE\nIf you\u2019re using Minikube or any other Kubernetes cluster where load\nbalancer services aren\u2019t supported, you can use the Service\u2019s node port to\naccess the app. This was explained in chapter 5.\n9.2.2\nPerforming a rolling update with kubectl\nNext you\u2019ll create version 2 of the app. To keep things simple, all you\u2019ll do is change\nthe response to say, \u201cThis is v2\u201d:\n  response.end(\"This is v2 running in pod \" + os.hostname() + \"\\n\");\nThis new version is available in the image luksa/kubia:v2 on Docker Hub, so you\ndon\u2019t need to build it yourself.\nListing 9.3\nGetting the Service\u2019s external IP and hitting the service in a loop with curl\nPushing updates to the same image tag\nModifying an app and pushing the changes to the same image tag isn\u2019t a good idea,\nbut we all tend to do that during development. If you\u2019re modifying the latest tag,\nthat\u2019s not a problem, but when you\u2019re tagging an image with a different tag (for exam-\nple, tag v1 instead of latest), once the image is pulled by a worker node, the image\nwill be stored on the node and not pulled again when a new pod using the same\nimage is run (at least that\u2019s the default policy for pulling images).\nThat means any changes you make to the image won\u2019t be picked up if you push them\nto the same tag. If a new pod is scheduled to the same node, the Kubelet will run the\nold version of the image. On the other hand, nodes that haven\u2019t run the old version\nwill pull and run the new image, so you might end up with two different versions of\nthe pod running. To make sure this doesn\u2019t happen, you need to set the container\u2019s\nimagePullPolicy property to Always. \nYou need to be aware that the default imagePullPolicy depends on the image tag.\nIf a container refers to the latest tag (either explicitly or by not specifying the tag at\nall), imagePullPolicy defaults to Always, but if the container refers to any other\ntag, the policy defaults to IfNotPresent. \nWhen using a tag other than latest, you need to set the imagePullPolicy properly\nif you make changes to an image without changing the tag. Or better yet, make sure\nyou always push changes to an image under a new tag.\n \n", "shape": "dot", "size": 10, "title": "256\nCHAPTER 9\nDeployments: updating applications declaratively\n$ kubectl get svc kubia\nNAME      CLUSTER-IP     EXTERNAL-IP       PORT(S)         AGE\nkubia     10.3.246.195   130.211.109.222   80:32143/TCP    5m\n$ while true; do curl http://130.211.109.222; done\nThis is v1 running in pod kubia-v1-qr192\nThis is v1 running in pod kubia-v1-kbtsk\nThis is v1 running in pod kubia-v1-qr192\nThis is v1 running in pod kubia-v1-2321o\n...\nNOTE\nIf you\u2019re using Minikube or any other Kubernetes cluster where load\nbalancer services aren\u2019t supported, you can use the Service\u2019s node port to\naccess the app. This was explained in chapter 5.\n9.2.2\nPerforming a rolling update with kubectl\nNext you\u2019ll create version 2 of the app. To keep things simple, all you\u2019ll do is change\nthe response to say, \u201cThis is v2\u201d:\n  response.end(\"This is v2 running in pod \" + os.hostname() + \"\\n\");\nThis new version is available in the image luksa/kubia:v2 on Docker Hub, so you\ndon\u2019t need to build it yourself.\nListing 9.3\nGetting the Service\u2019s external IP and hitting the service in a loop with curl\nPushing updates to the same image tag\nModifying an app and pushing the changes to the same image tag isn\u2019t a good idea,\nbut we all tend to do that during development. If you\u2019re modifying the latest tag,\nthat\u2019s not a problem, but when you\u2019re tagging an image with a different tag (for exam-\nple, tag v1 instead of latest), once the image is pulled by a worker node, the image\nwill be stored on the node and not pulled again when a new pod using the same\nimage is run (at least that\u2019s the default policy for pulling images).\nThat means any changes you make to the image won\u2019t be picked up if you push them\nto the same tag. If a new pod is scheduled to the same node, the Kubelet will run the\nold version of the image. On the other hand, nodes that haven\u2019t run the old version\nwill pull and run the new image, so you might end up with two different versions of\nthe pod running. To make sure this doesn\u2019t happen, you need to set the container\u2019s\nimagePullPolicy property to Always. \nYou need to be aware that the default imagePullPolicy depends on the image tag.\nIf a container refers to the latest tag (either explicitly or by not specifying the tag at\nall), imagePullPolicy defaults to Always, but if the container refers to any other\ntag, the policy defaults to IfNotPresent. \nWhen using a tag other than latest, you need to set the imagePullPolicy properly\nif you make changes to an image without changing the tag. Or better yet, make sure\nyou always push changes to an image under a new tag.\n \n"}, {"color": "green", "id": "text_200", "label": "257\nPerforming an automatic rolling update with a ReplicationController\nKeep the curl loop running and open another terminal, where you\u2019ll get the rolling\nupdate started. To perform the update, you\u2019ll run the kubectl rolling-update com-\nmand. All you need to do is tell it which ReplicationController you\u2019re replacing, give a\nname for the new ReplicationController, and specify the new image you\u2019d like to\nreplace the original one with. The following listing shows the full command for per-\nforming the rolling update.\n$ kubectl rolling-update kubia-v1 kubia-v2 --image=luksa/kubia:v2\nCreated kubia-v2\nScaling up kubia-v2 from 0 to 3, scaling down kubia-v1 from 3 to 0 (keep 3 \npods available, don\u0027t exceed 4 pods)\n...\nBecause you\u2019re replacing ReplicationController kubia-v1 with one running version 2\nof your kubia app, you\u2019d like the new ReplicationController to be called kubia-v2\nand use the luksa/kubia:v2 container image. \n When you run the command, a new ReplicationController called kubia-v2 is cre-\nated immediately. The state of the system at this point is shown in figure 9.5.\nThe new ReplicationController\u2019s pod template references the luksa/kubia:v2 image\nand its initial desired replica count is set to 0, as you can see in the following listing.\n$ kubectl describe rc kubia-v2\nName:       kubia-v2\nNamespace:  default\nImage(s):   luksa/kubia:v2          \nSelector:   app=kubia,deployment=757d16a0f02f6a5c387f2b5edb62b155\nLabels:     app=kubia            \nReplicas:   0 current / 0 desired    \n...\nListing 9.4\nInitiating a rolling-update of a ReplicationController using kubectl\nListing 9.5\nDescribing the new ReplicationController created by the rolling update\nPod: v1\nPod: v1\nNo v2 pods yet\nPod: v1\nReplicationController: kubia-v1\nImage: kubia/v1\nReplicas: 3\nReplicationController: kubia-v2\nImage: kubia/v2\nReplicas: 0\nFigure 9.5\nThe state of the system immediately after starting the rolling update\nThe new \nReplicationController \nrefers to the v2 image.\nInitially, the desired \nnumber of replicas is zero.\n \n", "shape": "dot", "size": 10, "title": "257\nPerforming an automatic rolling update with a ReplicationController\nKeep the curl loop running and open another terminal, where you\u2019ll get the rolling\nupdate started. To perform the update, you\u2019ll run the kubectl rolling-update com-\nmand. All you need to do is tell it which ReplicationController you\u2019re replacing, give a\nname for the new ReplicationController, and specify the new image you\u2019d like to\nreplace the original one with. The following listing shows the full command for per-\nforming the rolling update.\n$ kubectl rolling-update kubia-v1 kubia-v2 --image=luksa/kubia:v2\nCreated kubia-v2\nScaling up kubia-v2 from 0 to 3, scaling down kubia-v1 from 3 to 0 (keep 3 \npods available, don\u0027t exceed 4 pods)\n...\nBecause you\u2019re replacing ReplicationController kubia-v1 with one running version 2\nof your kubia app, you\u2019d like the new ReplicationController to be called kubia-v2\nand use the luksa/kubia:v2 container image. \n When you run the command, a new ReplicationController called kubia-v2 is cre-\nated immediately. The state of the system at this point is shown in figure 9.5.\nThe new ReplicationController\u2019s pod template references the luksa/kubia:v2 image\nand its initial desired replica count is set to 0, as you can see in the following listing.\n$ kubectl describe rc kubia-v2\nName:       kubia-v2\nNamespace:  default\nImage(s):   luksa/kubia:v2          \nSelector:   app=kubia,deployment=757d16a0f02f6a5c387f2b5edb62b155\nLabels:     app=kubia            \nReplicas:   0 current / 0 desired    \n...\nListing 9.4\nInitiating a rolling-update of a ReplicationController using kubectl\nListing 9.5\nDescribing the new ReplicationController created by the rolling update\nPod: v1\nPod: v1\nNo v2 pods yet\nPod: v1\nReplicationController: kubia-v1\nImage: kubia/v1\nReplicas: 3\nReplicationController: kubia-v2\nImage: kubia/v2\nReplicas: 0\nFigure 9.5\nThe state of the system immediately after starting the rolling update\nThe new \nReplicationController \nrefers to the v2 image.\nInitially, the desired \nnumber of replicas is zero.\n \n"}, {"color": "green", "id": "text_201", "label": "258\nCHAPTER 9\nDeployments: updating applications declaratively\nUNDERSTANDING THE STEPS PERFORMED BY KUBECTL BEFORE THE ROLLING UPDATE COMMENCES\nkubectl created this ReplicationController by copying the kubia-v1 controller and\nchanging the image in its pod template. If you look closely at the controller\u2019s label\nselector, you\u2019ll notice it has been modified, too. It includes not only a simple\napp=kubia label, but also an additional deployment label which the pods must have in\norder to be managed by this ReplicationController.\n You probably know this already, but this is necessary to avoid having both the new\nand the old ReplicationControllers operating on the same set of pods. But even if pods\ncreated by the new controller have the additional deployment label in addition to the\napp=kubia label, doesn\u2019t this mean they\u2019ll be selected by the first ReplicationControl-\nler\u2019s selector, because it\u2019s set to app=kubia? \n Yes, that\u2019s exactly what would happen, but there\u2019s a catch. The rolling-update pro-\ncess has modified the selector of the first ReplicationController, as well:\n$ kubectl describe rc kubia-v1\nName:       kubia-v1\nNamespace:  default\nImage(s):   luksa/kubia:v1\nSelector:   app=kubia,deployment=3ddd307978b502a5b975ed4045ae4964-orig \nOkay, but doesn\u2019t this mean the first controller now sees zero pods matching its selec-\ntor, because the three pods previously created by it contain only the app=kubia label?\nNo, because kubectl had also modified the labels of the live pods just before modify-\ning the ReplicationController\u2019s selector:\n$ kubectl get po --show-labels\nNAME            READY  STATUS   RESTARTS  AGE  LABELS\nkubia-v1-m33mv  1/1    Running  0         2m   app=kubia,deployment=3ddd...\nkubia-v1-nmzw9  1/1    Running  0         2m   app=kubia,deployment=3ddd...\nkubia-v1-cdtey  1/1    Running  0         2m   app=kubia,deployment=3ddd...\nIf this is getting too complicated, examine figure 9.6, which shows the pods, their\nlabels, and the two ReplicationControllers, along with their pod selectors.\nReplicationController: kubia-v1\nReplicas: 3\nSelector: app=kubia,\ndeployment=3ddd\u2026\nReplicationController: kubia-v2\nReplicas: 0\nSelector: app=kubia,\ndeployment=757d...\ndeployment: 3ddd...\napp: kubia\nPod: v1\ndeployment: 3ddd...\napp: kubia\nPod: v1\ndeployment: 3ddd...\napp: kubia\nPod: v1\nFigure 9.6\nDetailed state of the old and new ReplicationControllers and pods at the start of a rolling \nupdate\n \n", "shape": "dot", "size": 10, "title": "258\nCHAPTER 9\nDeployments: updating applications declaratively\nUNDERSTANDING THE STEPS PERFORMED BY KUBECTL BEFORE THE ROLLING UPDATE COMMENCES\nkubectl created this ReplicationController by copying the kubia-v1 controller and\nchanging the image in its pod template. If you look closely at the controller\u2019s label\nselector, you\u2019ll notice it has been modified, too. It includes not only a simple\napp=kubia label, but also an additional deployment label which the pods must have in\norder to be managed by this ReplicationController.\n You probably know this already, but this is necessary to avoid having both the new\nand the old ReplicationControllers operating on the same set of pods. But even if pods\ncreated by the new controller have the additional deployment label in addition to the\napp=kubia label, doesn\u2019t this mean they\u2019ll be selected by the first ReplicationControl-\nler\u2019s selector, because it\u2019s set to app=kubia? \n Yes, that\u2019s exactly what would happen, but there\u2019s a catch. The rolling-update pro-\ncess has modified the selector of the first ReplicationController, as well:\n$ kubectl describe rc kubia-v1\nName:       kubia-v1\nNamespace:  default\nImage(s):   luksa/kubia:v1\nSelector:   app=kubia,deployment=3ddd307978b502a5b975ed4045ae4964-orig \nOkay, but doesn\u2019t this mean the first controller now sees zero pods matching its selec-\ntor, because the three pods previously created by it contain only the app=kubia label?\nNo, because kubectl had also modified the labels of the live pods just before modify-\ning the ReplicationController\u2019s selector:\n$ kubectl get po --show-labels\nNAME            READY  STATUS   RESTARTS  AGE  LABELS\nkubia-v1-m33mv  1/1    Running  0         2m   app=kubia,deployment=3ddd...\nkubia-v1-nmzw9  1/1    Running  0         2m   app=kubia,deployment=3ddd...\nkubia-v1-cdtey  1/1    Running  0         2m   app=kubia,deployment=3ddd...\nIf this is getting too complicated, examine figure 9.6, which shows the pods, their\nlabels, and the two ReplicationControllers, along with their pod selectors.\nReplicationController: kubia-v1\nReplicas: 3\nSelector: app=kubia,\ndeployment=3ddd\u2026\nReplicationController: kubia-v2\nReplicas: 0\nSelector: app=kubia,\ndeployment=757d...\ndeployment: 3ddd...\napp: kubia\nPod: v1\ndeployment: 3ddd...\napp: kubia\nPod: v1\ndeployment: 3ddd...\napp: kubia\nPod: v1\nFigure 9.6\nDetailed state of the old and new ReplicationControllers and pods at the start of a rolling \nupdate\n \n"}, {"color": "green", "id": "text_202", "label": "259\nPerforming an automatic rolling update with a ReplicationController\nkubectl had to do all this before even starting to scale anything up or down. Now\nimagine doing the rolling update manually. It\u2019s easy to see yourself making a mistake\nhere and possibly having the ReplicationController kill off all your pods\u2014pods that\nare actively serving your production clients!\nREPLACING OLD PODS WITH NEW ONES BY SCALING THE TWO REPLICATIONCONTROLLERS\nAfter setting up all this, kubectl starts replacing pods by first scaling up the new\ncontroller to 1. The controller thus creates the first v2 pod. kubectl then scales\ndown the old ReplicationController by 1. This is shown in the next two lines printed\nby kubectl:\nScaling kubia-v2 up to 1\nScaling kubia-v1 down to 2\nBecause the Service is targeting all pods with the app=kubia label, you should start see-\ning your curl requests redirected to the new v2 pod every few loop iterations:\nThis is v2 running in pod kubia-v2-nmzw9      \nThis is v1 running in pod kubia-v1-kbtsk\nThis is v1 running in pod kubia-v1-2321o\nThis is v2 running in pod kubia-v2-nmzw9      \n...\nFigure 9.7 shows the current state of the system.\nAs kubectl continues with the rolling update, you start seeing a progressively bigger\npercentage of requests hitting v2 pods, as the update process deletes more of the v1\npods and replaces them with those running your new image. Eventually, the original\nRequests hitting the pod \nrunning the new version\nReplicationController: kubia-v1\nReplicas: 2\nSelector: app=kubia,\ndeployment=3ddd\u2026\nReplicationController: kubia-v2\nReplicas: 1\nSelector: app=kubia,\ndeployment=757d\u2026\ndeployment: 3ddd...\napp: kubia\nPod: v1\ndeployment: 3ddd...\napp: kubia\nPod: v1\ndeployment: 757d...\napp: kubia\nPod: v2\ncurl\nService\nSelector: app=kubia\nFigure 9.7\nThe Service is redirecting requests to both the old and new pods during the \nrolling update.\n \n", "shape": "dot", "size": 10, "title": "259\nPerforming an automatic rolling update with a ReplicationController\nkubectl had to do all this before even starting to scale anything up or down. Now\nimagine doing the rolling update manually. It\u2019s easy to see yourself making a mistake\nhere and possibly having the ReplicationController kill off all your pods\u2014pods that\nare actively serving your production clients!\nREPLACING OLD PODS WITH NEW ONES BY SCALING THE TWO REPLICATIONCONTROLLERS\nAfter setting up all this, kubectl starts replacing pods by first scaling up the new\ncontroller to 1. The controller thus creates the first v2 pod. kubectl then scales\ndown the old ReplicationController by 1. This is shown in the next two lines printed\nby kubectl:\nScaling kubia-v2 up to 1\nScaling kubia-v1 down to 2\nBecause the Service is targeting all pods with the app=kubia label, you should start see-\ning your curl requests redirected to the new v2 pod every few loop iterations:\nThis is v2 running in pod kubia-v2-nmzw9      \nThis is v1 running in pod kubia-v1-kbtsk\nThis is v1 running in pod kubia-v1-2321o\nThis is v2 running in pod kubia-v2-nmzw9      \n...\nFigure 9.7 shows the current state of the system.\nAs kubectl continues with the rolling update, you start seeing a progressively bigger\npercentage of requests hitting v2 pods, as the update process deletes more of the v1\npods and replaces them with those running your new image. Eventually, the original\nRequests hitting the pod \nrunning the new version\nReplicationController: kubia-v1\nReplicas: 2\nSelector: app=kubia,\ndeployment=3ddd\u2026\nReplicationController: kubia-v2\nReplicas: 1\nSelector: app=kubia,\ndeployment=757d\u2026\ndeployment: 3ddd...\napp: kubia\nPod: v1\ndeployment: 3ddd...\napp: kubia\nPod: v1\ndeployment: 757d...\napp: kubia\nPod: v2\ncurl\nService\nSelector: app=kubia\nFigure 9.7\nThe Service is redirecting requests to both the old and new pods during the \nrolling update.\n \n"}, {"color": "green", "id": "text_203", "label": "260\nCHAPTER 9\nDeployments: updating applications declaratively\nReplicationController is scaled to zero, causing the last v1 pod to be deleted, which\nmeans the Service will now be backed by v2 pods only. At that point, kubectl will\ndelete the original ReplicationController and the update process will be finished, as\nshown in the following listing.\n...\nScaling kubia-v2 up to 2\nScaling kubia-v1 down to 1\nScaling kubia-v2 up to 3\nScaling kubia-v1 down to 0\nUpdate succeeded. Deleting kubia-v1\nreplicationcontroller \"kubia-v1\" rolling updated to \"kubia-v2\"\nYou\u2019re now left with only the kubia-v2 ReplicationController and three v2 pods. All\nthroughout this update process, you\u2019ve hit your service and gotten a response every\ntime. You have, in fact, performed a rolling update with zero downtime. \n9.2.3\nUnderstanding why kubectl rolling-update is now obsolete\nAt the beginning of this section, I mentioned an even better way of doing updates\nthan through kubectl rolling-update. What\u2019s so wrong with this process that a bet-\nter one had to be introduced? \n Well, for starters, I, for one, don\u2019t like Kubernetes modifying objects I\u2019ve created.\nOkay, it\u2019s perfectly fine for the scheduler to assign a node to my pods after I create\nthem, but Kubernetes modifying the labels of my pods and the label selectors of my\nReplicationControllers is something that I don\u2019t expect and could cause me to go\naround the office yelling at my colleagues, \u201cWho\u2019s been messing with my controllers!?!?\u201d \n But even more importantly, if you\u2019ve paid close attention to the words I\u2019ve used,\nyou probably noticed that all this time I said explicitly that the kubectl client was the\none performing all these steps of the rolling update. \n You can see this by turning on verbose logging with the --v option when triggering\nthe rolling update:\n$ kubectl rolling-update kubia-v1 kubia-v2 --image=luksa/kubia:v2 --v 6\nTIP\nUsing the --v 6 option increases the logging level enough to let you see\nthe requests kubectl is sending to the API server.\nUsing this option, kubectl will print out each HTTP request it sends to the Kuberne-\ntes API server. You\u2019ll see PUT requests to\n/api/v1/namespaces/default/replicationcontrollers/kubia-v1\nwhich is the RESTful URL representing your kubia-v1 ReplicationController resource.\nThese requests are the ones scaling down your ReplicationController, which shows\nListing 9.6\nThe final steps performed by kubectl rolling-update\n \n", "shape": "dot", "size": 10, "title": "260\nCHAPTER 9\nDeployments: updating applications declaratively\nReplicationController is scaled to zero, causing the last v1 pod to be deleted, which\nmeans the Service will now be backed by v2 pods only. At that point, kubectl will\ndelete the original ReplicationController and the update process will be finished, as\nshown in the following listing.\n...\nScaling kubia-v2 up to 2\nScaling kubia-v1 down to 1\nScaling kubia-v2 up to 3\nScaling kubia-v1 down to 0\nUpdate succeeded. Deleting kubia-v1\nreplicationcontroller \"kubia-v1\" rolling updated to \"kubia-v2\"\nYou\u2019re now left with only the kubia-v2 ReplicationController and three v2 pods. All\nthroughout this update process, you\u2019ve hit your service and gotten a response every\ntime. You have, in fact, performed a rolling update with zero downtime. \n9.2.3\nUnderstanding why kubectl rolling-update is now obsolete\nAt the beginning of this section, I mentioned an even better way of doing updates\nthan through kubectl rolling-update. What\u2019s so wrong with this process that a bet-\nter one had to be introduced? \n Well, for starters, I, for one, don\u2019t like Kubernetes modifying objects I\u2019ve created.\nOkay, it\u2019s perfectly fine for the scheduler to assign a node to my pods after I create\nthem, but Kubernetes modifying the labels of my pods and the label selectors of my\nReplicationControllers is something that I don\u2019t expect and could cause me to go\naround the office yelling at my colleagues, \u201cWho\u2019s been messing with my controllers!?!?\u201d \n But even more importantly, if you\u2019ve paid close attention to the words I\u2019ve used,\nyou probably noticed that all this time I said explicitly that the kubectl client was the\none performing all these steps of the rolling update. \n You can see this by turning on verbose logging with the --v option when triggering\nthe rolling update:\n$ kubectl rolling-update kubia-v1 kubia-v2 --image=luksa/kubia:v2 --v 6\nTIP\nUsing the --v 6 option increases the logging level enough to let you see\nthe requests kubectl is sending to the API server.\nUsing this option, kubectl will print out each HTTP request it sends to the Kuberne-\ntes API server. You\u2019ll see PUT requests to\n/api/v1/namespaces/default/replicationcontrollers/kubia-v1\nwhich is the RESTful URL representing your kubia-v1 ReplicationController resource.\nThese requests are the ones scaling down your ReplicationController, which shows\nListing 9.6\nThe final steps performed by kubectl rolling-update\n \n"}, {"color": "green", "id": "text_204", "label": "261\nUsing Deployments for updating apps declaratively\nthat the kubectl client is the one doing the scaling, instead of it being performed by\nthe Kubernetes master. \nTIP\nUse the verbose logging option when running other kubectl commands,\nto learn more about the communication between kubectl and the API server. \nBut why is it such a bad thing that the update process is being performed by the client\ninstead of on the server? Well, in your case, the update went smoothly, but what if you\nlost network connectivity while kubectl was performing the update? The update pro-\ncess would be interrupted mid-way. Pods and ReplicationControllers would end up in\nan intermediate state.\n Another reason why performing an update like this isn\u2019t as good as it could be is\nbecause it\u2019s imperative. Throughout this book, I\u2019ve stressed how Kubernetes is about\nyou telling it the desired state of the system and having Kubernetes achieve that\nstate on its own, by figuring out the best way to do it. This is how pods are deployed\nand how pods are scaled up and down. You never tell Kubernetes to add an addi-\ntional pod or remove an excess one\u2014you change the number of desired replicas\nand that\u2019s it.\n Similarly, you will also want to change the desired image tag in your pod defini-\ntions and have Kubernetes replace the pods with new ones running the new image.\nThis is exactly what drove the introduction of a new resource called a Deployment,\nwhich is now the preferred way of deploying applications in Kubernetes. \n9.3\nUsing Deployments for updating apps declaratively\nA Deployment is a higher-level resource meant for deploying applications and\nupdating them declaratively, instead of doing it through a ReplicationController or\na ReplicaSet, which are both considered lower-level concepts.\n When you create a Deployment, a ReplicaSet resource is created underneath\n(eventually more of them). As you may remember from chapter 4, ReplicaSets are a\nnew generation of ReplicationControllers, and should be used instead of them. Replica-\nSets replicate and manage pods, as well. When using a Deployment, the actual pods\nare created and managed by the Deployment\u2019s ReplicaSets, not by the Deployment\ndirectly (the relationship is shown in figure 9.8).\nYou might wonder why you\u2019d want to complicate things by introducing another object\non top of a ReplicationController or ReplicaSet, when they\u2019re what suffices to keep a set\nof pod instances running. As the rolling update example in section 9.2 demonstrates,\nwhen updating the app, you need to introduce an additional ReplicationController and\nPods\nReplicaSet\nDeployment\nFigure 9.8\nA Deployment is backed \nby a ReplicaSet, which supervises the \ndeployment\u2019s pods.\n \n", "shape": "dot", "size": 10, "title": "261\nUsing Deployments for updating apps declaratively\nthat the kubectl client is the one doing the scaling, instead of it being performed by\nthe Kubernetes master. \nTIP\nUse the verbose logging option when running other kubectl commands,\nto learn more about the communication between kubectl and the API server. \nBut why is it such a bad thing that the update process is being performed by the client\ninstead of on the server? Well, in your case, the update went smoothly, but what if you\nlost network connectivity while kubectl was performing the update? The update pro-\ncess would be interrupted mid-way. Pods and ReplicationControllers would end up in\nan intermediate state.\n Another reason why performing an update like this isn\u2019t as good as it could be is\nbecause it\u2019s imperative. Throughout this book, I\u2019ve stressed how Kubernetes is about\nyou telling it the desired state of the system and having Kubernetes achieve that\nstate on its own, by figuring out the best way to do it. This is how pods are deployed\nand how pods are scaled up and down. You never tell Kubernetes to add an addi-\ntional pod or remove an excess one\u2014you change the number of desired replicas\nand that\u2019s it.\n Similarly, you will also want to change the desired image tag in your pod defini-\ntions and have Kubernetes replace the pods with new ones running the new image.\nThis is exactly what drove the introduction of a new resource called a Deployment,\nwhich is now the preferred way of deploying applications in Kubernetes. \n9.3\nUsing Deployments for updating apps declaratively\nA Deployment is a higher-level resource meant for deploying applications and\nupdating them declaratively, instead of doing it through a ReplicationController or\na ReplicaSet, which are both considered lower-level concepts.\n When you create a Deployment, a ReplicaSet resource is created underneath\n(eventually more of them). As you may remember from chapter 4, ReplicaSets are a\nnew generation of ReplicationControllers, and should be used instead of them. Replica-\nSets replicate and manage pods, as well. When using a Deployment, the actual pods\nare created and managed by the Deployment\u2019s ReplicaSets, not by the Deployment\ndirectly (the relationship is shown in figure 9.8).\nYou might wonder why you\u2019d want to complicate things by introducing another object\non top of a ReplicationController or ReplicaSet, when they\u2019re what suffices to keep a set\nof pod instances running. As the rolling update example in section 9.2 demonstrates,\nwhen updating the app, you need to introduce an additional ReplicationController and\nPods\nReplicaSet\nDeployment\nFigure 9.8\nA Deployment is backed \nby a ReplicaSet, which supervises the \ndeployment\u2019s pods.\n \n"}, {"color": "green", "id": "text_205", "label": "262\nCHAPTER 9\nDeployments: updating applications declaratively\ncoordinate the two controllers to dance around each other without stepping on each\nother\u2019s toes. You need something coordinating this dance. A Deployment resource\ntakes care of that (it\u2019s not the Deployment resource itself, but the controller process\nrunning in the Kubernetes control plane that does that; but we\u2019ll get to that in chap-\nter 11).\n Using a Deployment instead of the lower-level constructs makes updating an app\nmuch easier, because you\u2019re defining the desired state through the single Deployment\nresource and letting Kubernetes take care of the rest, as you\u2019ll see in the next few pages.\n9.3.1\nCreating a Deployment\nCreating a Deployment isn\u2019t that different from creating a ReplicationController. A\nDeployment is also composed of a label selector, a desired replica count, and a pod\ntemplate. In addition to that, it also contains a field, which specifies a deployment\nstrategy that defines how an update should be performed when the Deployment\nresource is modified.  \nCREATING A DEPLOYMENT MANIFEST\nLet\u2019s see how to use the kubia-v1 ReplicationController example from earlier in this\nchapter and modify it so it describes a Deployment instead of a ReplicationController.\nAs you\u2019ll see, this requires only three trivial changes. The following listing shows the\nmodified YAML.\napiVersion: apps/v1beta1          \nkind: Deployment                  \nmetadata:\n  name: kubia          \nspec:\n  replicas: 3\n  template:\n    metadata:\n      name: kubia\n      labels:\n        app: kubia\n    spec:\n      containers:\n      - image: luksa/kubia:v1\n        name: nodejs\nNOTE\nYou\u2019ll find an older version of the Deployment resource in extensions/\nv1beta1, and a newer one in apps/v1beta2 with different required fields and\ndifferent defaults. Be aware that kubectl explain shows the older version.\nBecause the ReplicationController from before was managing a specific version of the\npods, you called it kubia-v1. A Deployment, on the other hand, is above that version\nstuff. At a given point in time, the Deployment can have multiple pod versions run-\nning under its wing, so its name shouldn\u2019t reference the app version.\nListing 9.7\nA Deployment definition: kubia-deployment-v1.yaml\nDeployments are in the apps \nAPI group, version v1beta1.\nYou\u2019ve changed the kind \nfrom ReplicationController \nto Deployment.\nThere\u2019s no need to include \nthe version in the name of \nthe Deployment.\n \n", "shape": "dot", "size": 10, "title": "262\nCHAPTER 9\nDeployments: updating applications declaratively\ncoordinate the two controllers to dance around each other without stepping on each\nother\u2019s toes. You need something coordinating this dance. A Deployment resource\ntakes care of that (it\u2019s not the Deployment resource itself, but the controller process\nrunning in the Kubernetes control plane that does that; but we\u2019ll get to that in chap-\nter 11).\n Using a Deployment instead of the lower-level constructs makes updating an app\nmuch easier, because you\u2019re defining the desired state through the single Deployment\nresource and letting Kubernetes take care of the rest, as you\u2019ll see in the next few pages.\n9.3.1\nCreating a Deployment\nCreating a Deployment isn\u2019t that different from creating a ReplicationController. A\nDeployment is also composed of a label selector, a desired replica count, and a pod\ntemplate. In addition to that, it also contains a field, which specifies a deployment\nstrategy that defines how an update should be performed when the Deployment\nresource is modified.  \nCREATING A DEPLOYMENT MANIFEST\nLet\u2019s see how to use the kubia-v1 ReplicationController example from earlier in this\nchapter and modify it so it describes a Deployment instead of a ReplicationController.\nAs you\u2019ll see, this requires only three trivial changes. The following listing shows the\nmodified YAML.\napiVersion: apps/v1beta1          \nkind: Deployment                  \nmetadata:\n  name: kubia          \nspec:\n  replicas: 3\n  template:\n    metadata:\n      name: kubia\n      labels:\n        app: kubia\n    spec:\n      containers:\n      - image: luksa/kubia:v1\n        name: nodejs\nNOTE\nYou\u2019ll find an older version of the Deployment resource in extensions/\nv1beta1, and a newer one in apps/v1beta2 with different required fields and\ndifferent defaults. Be aware that kubectl explain shows the older version.\nBecause the ReplicationController from before was managing a specific version of the\npods, you called it kubia-v1. A Deployment, on the other hand, is above that version\nstuff. At a given point in time, the Deployment can have multiple pod versions run-\nning under its wing, so its name shouldn\u2019t reference the app version.\nListing 9.7\nA Deployment definition: kubia-deployment-v1.yaml\nDeployments are in the apps \nAPI group, version v1beta1.\nYou\u2019ve changed the kind \nfrom ReplicationController \nto Deployment.\nThere\u2019s no need to include \nthe version in the name of \nthe Deployment.\n \n"}, {"color": "green", "id": "text_206", "label": "263\nUsing Deployments for updating apps declaratively\nCREATING THE DEPLOYMENT RESOURCE\nBefore you create this Deployment, make sure you delete any ReplicationControllers\nand pods that are still running, but keep the kubia Service for now. You can use the\n--all switch to delete all those ReplicationControllers like this:\n$ kubectl delete rc --all\nYou\u2019re now ready to create the Deployment: \n$ kubectl create -f kubia-deployment-v1.yaml --record\ndeployment \"kubia\" created\nTIP\nBe sure to include the --record command-line option when creating it.\nThis records the command in the revision history, which will be useful later.\nDISPLAYING THE STATUS OF THE DEPLOYMENT ROLLOUT\nYou can use the usual kubectl get deployment and the kubectl describe deployment\ncommands to see details of the Deployment, but let me point you to an additional\ncommand, which is made specifically for checking a Deployment\u2019s status:\n$ kubectl rollout status deployment kubia\ndeployment kubia successfully rolled out\nAccording to this, the Deployment has been successfully rolled out, so you should see\nthe three pod replicas up and running. Let\u2019s see:\n$ kubectl get po\nNAME                     READY     STATUS    RESTARTS   AGE\nkubia-1506449474-otnnh   1/1       Running   0          14s\nkubia-1506449474-vmn7s   1/1       Running   0          14s\nkubia-1506449474-xis6m   1/1       Running   0          14s\nUNDERSTANDING HOW DEPLOYMENTS CREATE REPLICASETS, WHICH THEN CREATE THE PODS\nTake note of the names of these pods. Earlier, when you used a ReplicationController\nto create pods, their names were composed of the name of the controller plus a ran-\ndomly generated string (for example, kubia-v1-m33mv). The three pods created by\nthe Deployment include an additional numeric value in the middle of their names.\nWhat is that exactly?\n The number corresponds to the hashed value of the pod template in the Deploy-\nment and the ReplicaSet managing these pods. As we said earlier, a Deployment\ndoesn\u2019t manage pods directly. Instead, it creates ReplicaSets and leaves the managing\nto them, so let\u2019s look at the ReplicaSet created by your Deployment:\n$ kubectl get replicasets\nNAME               DESIRED   CURRENT   AGE\nkubia-1506449474   3         3         10s\nThe ReplicaSet\u2019s name also contains the hash value of its pod template. As you\u2019ll see\nlater, a Deployment creates multiple ReplicaSets\u2014one for each version of the pod\n \n", "shape": "dot", "size": 10, "title": "263\nUsing Deployments for updating apps declaratively\nCREATING THE DEPLOYMENT RESOURCE\nBefore you create this Deployment, make sure you delete any ReplicationControllers\nand pods that are still running, but keep the kubia Service for now. You can use the\n--all switch to delete all those ReplicationControllers like this:\n$ kubectl delete rc --all\nYou\u2019re now ready to create the Deployment: \n$ kubectl create -f kubia-deployment-v1.yaml --record\ndeployment \"kubia\" created\nTIP\nBe sure to include the --record command-line option when creating it.\nThis records the command in the revision history, which will be useful later.\nDISPLAYING THE STATUS OF THE DEPLOYMENT ROLLOUT\nYou can use the usual kubectl get deployment and the kubectl describe deployment\ncommands to see details of the Deployment, but let me point you to an additional\ncommand, which is made specifically for checking a Deployment\u2019s status:\n$ kubectl rollout status deployment kubia\ndeployment kubia successfully rolled out\nAccording to this, the Deployment has been successfully rolled out, so you should see\nthe three pod replicas up and running. Let\u2019s see:\n$ kubectl get po\nNAME                     READY     STATUS    RESTARTS   AGE\nkubia-1506449474-otnnh   1/1       Running   0          14s\nkubia-1506449474-vmn7s   1/1       Running   0          14s\nkubia-1506449474-xis6m   1/1       Running   0          14s\nUNDERSTANDING HOW DEPLOYMENTS CREATE REPLICASETS, WHICH THEN CREATE THE PODS\nTake note of the names of these pods. Earlier, when you used a ReplicationController\nto create pods, their names were composed of the name of the controller plus a ran-\ndomly generated string (for example, kubia-v1-m33mv). The three pods created by\nthe Deployment include an additional numeric value in the middle of their names.\nWhat is that exactly?\n The number corresponds to the hashed value of the pod template in the Deploy-\nment and the ReplicaSet managing these pods. As we said earlier, a Deployment\ndoesn\u2019t manage pods directly. Instead, it creates ReplicaSets and leaves the managing\nto them, so let\u2019s look at the ReplicaSet created by your Deployment:\n$ kubectl get replicasets\nNAME               DESIRED   CURRENT   AGE\nkubia-1506449474   3         3         10s\nThe ReplicaSet\u2019s name also contains the hash value of its pod template. As you\u2019ll see\nlater, a Deployment creates multiple ReplicaSets\u2014one for each version of the pod\n \n"}, {"color": "green", "id": "text_207", "label": "264\nCHAPTER 9\nDeployments: updating applications declaratively\ntemplate. Using the hash value of the pod template like this allows the Deployment\nto always use the same (possibly existing) ReplicaSet for a given version of the pod\ntemplate.\nACCESSING THE PODS THROUGH THE SERVICE\nWith the three replicas created by this ReplicaSet now running, you can use the Ser-\nvice you created a while ago to access them, because you made the new pods\u2019 labels\nmatch the Service\u2019s label selector. \n Up until this point, you probably haven\u2019t seen a good-enough reason why you should\nuse Deployments over ReplicationControllers. Luckily, creating a Deployment also hasn\u2019t\nbeen any harder than creating a ReplicationController. Now, you\u2019ll start doing things\nwith this Deployment, which will make it clear why Deployments are superior. This will\nbecome clear in the next few moments, when you see how updating the app through\na Deployment resource compares to updating it through a ReplicationController.\n9.3.2\nUpdating a Deployment\nPreviously, when you ran your app using a ReplicationController, you had to explicitly\ntell Kubernetes to perform the update by running kubectl rolling-update. You even\nhad to specify the name for the new ReplicationController that should replace the old\none. Kubernetes replaced all the original pods with new ones and deleted the original\nReplicationController at the end of the process. During the process, you basically had\nto stay around, keeping your terminal open and waiting for kubectl to finish the roll-\ning update. \n Now compare this to how you\u2019re about to update a Deployment. The only thing\nyou need to do is modify the pod template defined in the Deployment resource and\nKubernetes will take all the steps necessary to get the actual system state to what\u2019s\ndefined in the resource. Similar to scaling a ReplicationController or ReplicaSet up or\ndown, all you need to do is reference a new image tag in the Deployment\u2019s pod tem-\nplate and leave it to Kubernetes to transform your system so it matches the new\ndesired state.\nUNDERSTANDING THE AVAILABLE DEPLOYMENT STRATEGIES\nHow this new state should be achieved is governed by the deployment strategy config-\nured on the Deployment itself. The default strategy is to perform a rolling update (the\nstrategy is called RollingUpdate). The alternative is the Recreate strategy, which\ndeletes all the old pods at once and then creates new ones, similar to modifying a\nReplicationController\u2019s pod template and then deleting all the pods (we talked about\nthis in section 9.1.1).\n The Recreate strategy causes all old pods to be deleted before the new ones are\ncreated. Use this strategy when your application doesn\u2019t support running multiple ver-\nsions in parallel and requires the old version to be stopped completely before the\nnew one is started. This strategy does involve a short period of time when your app\nbecomes completely unavailable.\n \n", "shape": "dot", "size": 10, "title": "264\nCHAPTER 9\nDeployments: updating applications declaratively\ntemplate. Using the hash value of the pod template like this allows the Deployment\nto always use the same (possibly existing) ReplicaSet for a given version of the pod\ntemplate.\nACCESSING THE PODS THROUGH THE SERVICE\nWith the three replicas created by this ReplicaSet now running, you can use the Ser-\nvice you created a while ago to access them, because you made the new pods\u2019 labels\nmatch the Service\u2019s label selector. \n Up until this point, you probably haven\u2019t seen a good-enough reason why you should\nuse Deployments over ReplicationControllers. Luckily, creating a Deployment also hasn\u2019t\nbeen any harder than creating a ReplicationController. Now, you\u2019ll start doing things\nwith this Deployment, which will make it clear why Deployments are superior. This will\nbecome clear in the next few moments, when you see how updating the app through\na Deployment resource compares to updating it through a ReplicationController.\n9.3.2\nUpdating a Deployment\nPreviously, when you ran your app using a ReplicationController, you had to explicitly\ntell Kubernetes to perform the update by running kubectl rolling-update. You even\nhad to specify the name for the new ReplicationController that should replace the old\none. Kubernetes replaced all the original pods with new ones and deleted the original\nReplicationController at the end of the process. During the process, you basically had\nto stay around, keeping your terminal open and waiting for kubectl to finish the roll-\ning update. \n Now compare this to how you\u2019re about to update a Deployment. The only thing\nyou need to do is modify the pod template defined in the Deployment resource and\nKubernetes will take all the steps necessary to get the actual system state to what\u2019s\ndefined in the resource. Similar to scaling a ReplicationController or ReplicaSet up or\ndown, all you need to do is reference a new image tag in the Deployment\u2019s pod tem-\nplate and leave it to Kubernetes to transform your system so it matches the new\ndesired state.\nUNDERSTANDING THE AVAILABLE DEPLOYMENT STRATEGIES\nHow this new state should be achieved is governed by the deployment strategy config-\nured on the Deployment itself. The default strategy is to perform a rolling update (the\nstrategy is called RollingUpdate). The alternative is the Recreate strategy, which\ndeletes all the old pods at once and then creates new ones, similar to modifying a\nReplicationController\u2019s pod template and then deleting all the pods (we talked about\nthis in section 9.1.1).\n The Recreate strategy causes all old pods to be deleted before the new ones are\ncreated. Use this strategy when your application doesn\u2019t support running multiple ver-\nsions in parallel and requires the old version to be stopped completely before the\nnew one is started. This strategy does involve a short period of time when your app\nbecomes completely unavailable.\n \n"}, {"color": "green", "id": "text_208", "label": "265\nUsing Deployments for updating apps declaratively\n The RollingUpdate strategy, on the other hand, removes old pods one by one,\nwhile adding new ones at the same time, keeping the application available throughout\nthe whole process, and ensuring there\u2019s no drop in its capacity to handle requests.\nThis is the default strategy. The upper and lower limits for the number of pods above\nor below the desired replica count are configurable. You should use this strategy only\nwhen your app can handle running both the old and new version at the same time.\nSLOWING DOWN THE ROLLING UPDATE FOR DEMO PURPOSES\nIn the next exercise, you\u2019ll use the RollingUpdate strategy, but you need to slow down\nthe update process a little, so you can see that the update is indeed performed in a\nrolling fashion. You can do that by setting the minReadySeconds attribute on the\nDeployment. We\u2019ll explain what this attribute does by the end of this chapter. For\nnow, set it to 10 seconds with the kubectl patch command.\n$ kubectl patch deployment kubia -p \u0027{\"spec\": {\"minReadySeconds\": 10}}\u0027\n\"kubia\" patched\nTIP\nThe kubectl patch command is useful for modifying a single property\nor a limited number of properties of a resource without having to edit its defi-\nnition in a text editor.\nYou used the patch command to change the spec of the Deployment. This doesn\u2019t\ncause any kind of update to the pods, because you didn\u2019t change the pod template.\nChanging other Deployment properties, like the desired replica count or the deploy-\nment strategy, also doesn\u2019t trigger a rollout, because it doesn\u2019t affect the existing indi-\nvidual pods in any way.\nTRIGGERING THE ROLLING UPDATE\nIf you\u2019d like to track the update process as it progresses, first run the curl loop again\nin another terminal to see what\u2019s happening with the requests (don\u2019t forget to replace\nthe IP with the actual external IP of your service):\n$ while true; do curl http://130.211.109.222; done\nTo trigger the actual rollout, you\u2019ll change the image used in the single pod container\nto luksa/kubia:v2. Instead of editing the whole YAML of the Deployment object or\nusing the patch command to change the image, you\u2019ll use the kubectl set image\ncommand, which allows changing the image of any resource that contains a container\n(ReplicationControllers, ReplicaSets, Deployments, and so on). You\u2019ll use it to modify\nyour Deployment like this:\n$ kubectl set image deployment kubia nodejs=luksa/kubia:v2\ndeployment \"kubia\" image updated\nWhen you execute this command, you\u2019re updating the kubia Deployment\u2019s pod tem-\nplate so the image used in its nodejs container is changed to luksa/kubia:v2 (from\n:v1). This is shown in figure 9.9.\n \n", "shape": "dot", "size": 10, "title": "265\nUsing Deployments for updating apps declaratively\n The RollingUpdate strategy, on the other hand, removes old pods one by one,\nwhile adding new ones at the same time, keeping the application available throughout\nthe whole process, and ensuring there\u2019s no drop in its capacity to handle requests.\nThis is the default strategy. The upper and lower limits for the number of pods above\nor below the desired replica count are configurable. You should use this strategy only\nwhen your app can handle running both the old and new version at the same time.\nSLOWING DOWN THE ROLLING UPDATE FOR DEMO PURPOSES\nIn the next exercise, you\u2019ll use the RollingUpdate strategy, but you need to slow down\nthe update process a little, so you can see that the update is indeed performed in a\nrolling fashion. You can do that by setting the minReadySeconds attribute on the\nDeployment. We\u2019ll explain what this attribute does by the end of this chapter. For\nnow, set it to 10 seconds with the kubectl patch command.\n$ kubectl patch deployment kubia -p \u0027{\"spec\": {\"minReadySeconds\": 10}}\u0027\n\"kubia\" patched\nTIP\nThe kubectl patch command is useful for modifying a single property\nor a limited number of properties of a resource without having to edit its defi-\nnition in a text editor.\nYou used the patch command to change the spec of the Deployment. This doesn\u2019t\ncause any kind of update to the pods, because you didn\u2019t change the pod template.\nChanging other Deployment properties, like the desired replica count or the deploy-\nment strategy, also doesn\u2019t trigger a rollout, because it doesn\u2019t affect the existing indi-\nvidual pods in any way.\nTRIGGERING THE ROLLING UPDATE\nIf you\u2019d like to track the update process as it progresses, first run the curl loop again\nin another terminal to see what\u2019s happening with the requests (don\u2019t forget to replace\nthe IP with the actual external IP of your service):\n$ while true; do curl http://130.211.109.222; done\nTo trigger the actual rollout, you\u2019ll change the image used in the single pod container\nto luksa/kubia:v2. Instead of editing the whole YAML of the Deployment object or\nusing the patch command to change the image, you\u2019ll use the kubectl set image\ncommand, which allows changing the image of any resource that contains a container\n(ReplicationControllers, ReplicaSets, Deployments, and so on). You\u2019ll use it to modify\nyour Deployment like this:\n$ kubectl set image deployment kubia nodejs=luksa/kubia:v2\ndeployment \"kubia\" image updated\nWhen you execute this command, you\u2019re updating the kubia Deployment\u2019s pod tem-\nplate so the image used in its nodejs container is changed to luksa/kubia:v2 (from\n:v1). This is shown in figure 9.9.\n \n"}, {"color": "green", "id": "text_209", "label": "266\nCHAPTER 9\nDeployments: updating applications declaratively\nWays of modifying Deployments and other resources\nOver the course of this book, you\u2019ve learned several ways how to modify an existing\nobject. Let\u2019s list all of them together to refresh your memory.\nAll these methods are equivalent as far as Deployments go. What they do is change\nthe Deployment\u2019s specification. This change then triggers the rollout process.\nImage registry\nPod template\nDeployment\nkubectl set image\u2026\nluksa/kubia:v2\nContainer:\nnodejs\n:v1\n:v2\nImage registry\nPod template\nDeployment\nContainer:\nnodejs\n:v1\n:v2\nFigure 9.9\nUpdating a Deployment\u2019s pod template to point to a new image\nTable 9.1\nModifying an existing resource in Kubernetes\nMethod\nWhat it does\nkubectl edit\nOpens the object\u2019s manifest in your default editor. After making \nchanges, saving the file, and exiting the editor, the object is updated.\nExample: kubectl edit deployment kubia\nkubectl patch\nModifies individual properties of an object.\nExample: kubectl patch deployment kubia -p \u0027{\"spec\": \n{\"template\": {\"spec\": {\"containers\": [{\"name\": \n\"nodejs\", \"image\": \"luksa/kubia:v2\"}]}}}}\u0027\nkubectl apply\nModifies the object by applying property values from a full YAML or \nJSON file. If the object specified in the YAML/JSON doesn\u2019t exist yet, \nit\u2019s created. The file needs to contain the full definition of the \nresource (it can\u2019t include only the fields you want to update, as is the \ncase with kubectl patch).\nExample: kubectl apply -f kubia-deployment-v2.yaml\nkubectl replace\nReplaces the object with a new one from a YAML/JSON file. In con-\ntrast to the apply command, this command requires the object to \nexist; otherwise it prints an error.\nExample: kubectl replace -f kubia-deployment-v2.yaml\nkubectl set image\nChanges the container image defined in a Pod, ReplicationControl-\nler\u2019s template, Deployment, DaemonSet, Job, or ReplicaSet.\nExample: kubectl set image deployment kubia \nnodejs=luksa/kubia:v2\n \n", "shape": "dot", "size": 10, "title": "266\nCHAPTER 9\nDeployments: updating applications declaratively\nWays of modifying Deployments and other resources\nOver the course of this book, you\u2019ve learned several ways how to modify an existing\nobject. Let\u2019s list all of them together to refresh your memory.\nAll these methods are equivalent as far as Deployments go. What they do is change\nthe Deployment\u2019s specification. This change then triggers the rollout process.\nImage registry\nPod template\nDeployment\nkubectl set image\u2026\nluksa/kubia:v2\nContainer:\nnodejs\n:v1\n:v2\nImage registry\nPod template\nDeployment\nContainer:\nnodejs\n:v1\n:v2\nFigure 9.9\nUpdating a Deployment\u2019s pod template to point to a new image\nTable 9.1\nModifying an existing resource in Kubernetes\nMethod\nWhat it does\nkubectl edit\nOpens the object\u2019s manifest in your default editor. After making \nchanges, saving the file, and exiting the editor, the object is updated.\nExample: kubectl edit deployment kubia\nkubectl patch\nModifies individual properties of an object.\nExample: kubectl patch deployment kubia -p \u0027{\"spec\": \n{\"template\": {\"spec\": {\"containers\": [{\"name\": \n\"nodejs\", \"image\": \"luksa/kubia:v2\"}]}}}}\u0027\nkubectl apply\nModifies the object by applying property values from a full YAML or \nJSON file. If the object specified in the YAML/JSON doesn\u2019t exist yet, \nit\u2019s created. The file needs to contain the full definition of the \nresource (it can\u2019t include only the fields you want to update, as is the \ncase with kubectl patch).\nExample: kubectl apply -f kubia-deployment-v2.yaml\nkubectl replace\nReplaces the object with a new one from a YAML/JSON file. In con-\ntrast to the apply command, this command requires the object to \nexist; otherwise it prints an error.\nExample: kubectl replace -f kubia-deployment-v2.yaml\nkubectl set image\nChanges the container image defined in a Pod, ReplicationControl-\nler\u2019s template, Deployment, DaemonSet, Job, or ReplicaSet.\nExample: kubectl set image deployment kubia \nnodejs=luksa/kubia:v2\n \n"}, {"color": "green", "id": "text_210", "label": "267\nUsing Deployments for updating apps declaratively\nIf you\u2019ve run the curl loop, you\u2019ll see requests initially hitting only the v1 pods; then\nmore and more of them hit the v2 pods until, finally, all of them hit only the remain-\ning v2 pods, after all v1 pods are deleted. This works much like the rolling update per-\nformed by kubectl.\nUNDERSTANDING THE AWESOMENESS OF DEPLOYMENTS\nLet\u2019s think about what has happened. By changing the pod template in your Deploy-\nment resource, you\u2019ve updated your app to a newer version\u2014by changing a single\nfield! \n The controllers running as part of the Kubernetes control plane then performed\nthe update. The process wasn\u2019t performed by the kubectl client, like it was when you\nused kubectl rolling-update. I don\u2019t know about you, but I think that\u2019s simpler than\nhaving to run a special command telling Kubernetes what to do and then waiting\naround for the process to be completed.\nNOTE\nBe aware that if the pod template in the Deployment references a\nConfigMap (or a Secret), modifying the ConfigMap will not trigger an\nupdate. One way to trigger an update when you need to modify an app\u2019s con-\nfig is to create a new ConfigMap and modify the pod template so it references\nthe new ConfigMap.\nThe events that occurred below the Deployment\u2019s surface during the update are simi-\nlar to what happened during the kubectl rolling-update. An additional ReplicaSet\nwas created and it was then scaled up slowly, while the previous ReplicaSet was scaled\ndown to zero (the initial and final states are shown in figure 9.10).\nYou can still see the old ReplicaSet next to the new one if you list them:\n$ kubectl get rs\nNAME               DESIRED   CURRENT   AGE\nkubia-1506449474   0         0         24m\nkubia-1581357123   3         3         23m\nPods: v1\nReplicaSet: v1\nReplicas: --\nBefore\nAfter\nReplicaSet: v2\nReplicas: ++\nDeployment\nPods: v2\nReplicaSet: v1\nReplicaSet: v2\nDeployment\nFigure 9.10\nA Deployment at the start and end of a rolling update\n \n", "shape": "dot", "size": 10, "title": "267\nUsing Deployments for updating apps declaratively\nIf you\u2019ve run the curl loop, you\u2019ll see requests initially hitting only the v1 pods; then\nmore and more of them hit the v2 pods until, finally, all of them hit only the remain-\ning v2 pods, after all v1 pods are deleted. This works much like the rolling update per-\nformed by kubectl.\nUNDERSTANDING THE AWESOMENESS OF DEPLOYMENTS\nLet\u2019s think about what has happened. By changing the pod template in your Deploy-\nment resource, you\u2019ve updated your app to a newer version\u2014by changing a single\nfield! \n The controllers running as part of the Kubernetes control plane then performed\nthe update. The process wasn\u2019t performed by the kubectl client, like it was when you\nused kubectl rolling-update. I don\u2019t know about you, but I think that\u2019s simpler than\nhaving to run a special command telling Kubernetes what to do and then waiting\naround for the process to be completed.\nNOTE\nBe aware that if the pod template in the Deployment references a\nConfigMap (or a Secret), modifying the ConfigMap will not trigger an\nupdate. One way to trigger an update when you need to modify an app\u2019s con-\nfig is to create a new ConfigMap and modify the pod template so it references\nthe new ConfigMap.\nThe events that occurred below the Deployment\u2019s surface during the update are simi-\nlar to what happened during the kubectl rolling-update. An additional ReplicaSet\nwas created and it was then scaled up slowly, while the previous ReplicaSet was scaled\ndown to zero (the initial and final states are shown in figure 9.10).\nYou can still see the old ReplicaSet next to the new one if you list them:\n$ kubectl get rs\nNAME               DESIRED   CURRENT   AGE\nkubia-1506449474   0         0         24m\nkubia-1581357123   3         3         23m\nPods: v1\nReplicaSet: v1\nReplicas: --\nBefore\nAfter\nReplicaSet: v2\nReplicas: ++\nDeployment\nPods: v2\nReplicaSet: v1\nReplicaSet: v2\nDeployment\nFigure 9.10\nA Deployment at the start and end of a rolling update\n \n"}, {"color": "green", "id": "text_211", "label": "268\nCHAPTER 9\nDeployments: updating applications declaratively\nSimilar to ReplicationControllers, all your new pods are now managed by the new\nReplicaSet. Unlike before, the old ReplicaSet is still there, whereas the old Replication-\nController was deleted at the end of the rolling-update process. You\u2019ll soon see what\nthe purpose of this inactive ReplicaSet is. \n But you shouldn\u2019t care about ReplicaSets here, because you didn\u2019t create them\ndirectly. You created and operated only on the Deployment resource; the underlying\nReplicaSets are an implementation detail. You\u2019ll agree that managing a single Deploy-\nment object is much easier compared to dealing with and keeping track of multiple\nReplicationControllers. \n Although this difference may not be so apparent when everything goes well with a\nrollout, it becomes much more obvious when you hit a problem during the rollout\nprocess. Let\u2019s simulate one problem right now.\n9.3.3\nRolling back a deployment\nYou\u2019re currently running version v2 of your image, so you\u2019ll need to prepare version 3\nfirst. \nCREATING VERSION 3 OF YOUR APP\nIn version 3, you\u2019ll introduce a bug that makes your app handle only the first four\nrequests properly. All requests from the fifth request onward will return an internal\nserver error (HTTP status code 500). You\u2019ll simulate this by adding an if statement at\nthe beginning of the handler function. The following listing shows the new code, with\nall required changes shown in bold.\nconst http = require(\u0027http\u0027);\nconst os = require(\u0027os\u0027);\nvar requestCount = 0;\nconsole.log(\"Kubia server starting...\");\nvar handler = function(request, response) {\n  console.log(\"Received request from \" + request.connection.remoteAddress);\n  if (++requestCount \u003e= 5) {\n    response.writeHead(500);\n    response.end(\"Some internal error has occurred! This is pod \" + \nos.hostname() + \"\\n\");\n    return;\n  }\n  response.writeHead(200);\n  response.end(\"This is v3 running in pod \" + os.hostname() + \"\\n\");\n};\nvar www = http.createServer(handler);\nwww.listen(8080); \nAs you can see, on the fifth and all subsequent requests, the code returns a 500 error\nwith the message \u201cSome internal error has occurred...\u201d\nListing 9.8\nVersion 3 of our app (a broken version): v3/app.js\n \n", "shape": "dot", "size": 10, "title": "268\nCHAPTER 9\nDeployments: updating applications declaratively\nSimilar to ReplicationControllers, all your new pods are now managed by the new\nReplicaSet. Unlike before, the old ReplicaSet is still there, whereas the old Replication-\nController was deleted at the end of the rolling-update process. You\u2019ll soon see what\nthe purpose of this inactive ReplicaSet is. \n But you shouldn\u2019t care about ReplicaSets here, because you didn\u2019t create them\ndirectly. You created and operated only on the Deployment resource; the underlying\nReplicaSets are an implementation detail. You\u2019ll agree that managing a single Deploy-\nment object is much easier compared to dealing with and keeping track of multiple\nReplicationControllers. \n Although this difference may not be so apparent when everything goes well with a\nrollout, it becomes much more obvious when you hit a problem during the rollout\nprocess. Let\u2019s simulate one problem right now.\n9.3.3\nRolling back a deployment\nYou\u2019re currently running version v2 of your image, so you\u2019ll need to prepare version 3\nfirst. \nCREATING VERSION 3 OF YOUR APP\nIn version 3, you\u2019ll introduce a bug that makes your app handle only the first four\nrequests properly. All requests from the fifth request onward will return an internal\nserver error (HTTP status code 500). You\u2019ll simulate this by adding an if statement at\nthe beginning of the handler function. The following listing shows the new code, with\nall required changes shown in bold.\nconst http = require(\u0027http\u0027);\nconst os = require(\u0027os\u0027);\nvar requestCount = 0;\nconsole.log(\"Kubia server starting...\");\nvar handler = function(request, response) {\n  console.log(\"Received request from \" + request.connection.remoteAddress);\n  if (++requestCount \u003e= 5) {\n    response.writeHead(500);\n    response.end(\"Some internal error has occurred! This is pod \" + \nos.hostname() + \"\\n\");\n    return;\n  }\n  response.writeHead(200);\n  response.end(\"This is v3 running in pod \" + os.hostname() + \"\\n\");\n};\nvar www = http.createServer(handler);\nwww.listen(8080); \nAs you can see, on the fifth and all subsequent requests, the code returns a 500 error\nwith the message \u201cSome internal error has occurred...\u201d\nListing 9.8\nVersion 3 of our app (a broken version): v3/app.js\n \n"}, {"color": "green", "id": "text_212", "label": "269\nUsing Deployments for updating apps declaratively\nDEPLOYING VERSION 3\nI\u2019ve made the v3 version of the image available as luksa/kubia:v3. You\u2019ll deploy this\nnew version by changing the image in the Deployment specification again: \n$ kubectl set image deployment kubia nodejs=luksa/kubia:v3\ndeployment \"kubia\" image updated\nYou can follow the progress of the rollout with kubectl rollout status:\n$ kubectl rollout status deployment kubia\nWaiting for rollout to finish: 1 out of 3 new replicas have been updated...\nWaiting for rollout to finish: 2 out of 3 new replicas have been updated...\nWaiting for rollout to finish: 1 old replicas are pending termination...\ndeployment \"kubia\" successfully rolled out\nThe new version is now live. As the following listing shows, after a few requests, your\nweb clients start receiving errors.\n$ while true; do curl http://130.211.109.222; done\nThis is v3 running in pod kubia-1914148340-lalmx\nThis is v3 running in pod kubia-1914148340-bz35w\nThis is v3 running in pod kubia-1914148340-w0voh\n...\nThis is v3 running in pod kubia-1914148340-w0voh\nSome internal error has occurred! This is pod kubia-1914148340-bz35w\nThis is v3 running in pod kubia-1914148340-w0voh\nSome internal error has occurred! This is pod kubia-1914148340-lalmx\nThis is v3 running in pod kubia-1914148340-w0voh\nSome internal error has occurred! This is pod kubia-1914148340-lalmx\nSome internal error has occurred! This is pod kubia-1914148340-bz35w\nSome internal error has occurred! This is pod kubia-1914148340-w0voh\nUNDOING A ROLLOUT\nYou can\u2019t have your users experiencing internal server errors, so you need to do some-\nthing about it fast. In section 9.3.6 you\u2019ll see how to block bad rollouts automatically,\nbut for now, let\u2019s see what you can do about your bad rollout manually. Luckily,\nDeployments make it easy to roll back to the previously deployed version by telling\nKubernetes to undo the last rollout of a Deployment:\n$ kubectl rollout undo deployment kubia\ndeployment \"kubia\" rolled back\nThis rolls the Deployment back to the previous revision. \nTIP\nThe undo command can also be used while the rollout process is still in\nprogress to essentially abort the rollout. Pods already created during the roll-\nout process are removed and replaced with the old ones again.\nListing 9.9\nHitting your broken version 3\n \n", "shape": "dot", "size": 10, "title": "269\nUsing Deployments for updating apps declaratively\nDEPLOYING VERSION 3\nI\u2019ve made the v3 version of the image available as luksa/kubia:v3. You\u2019ll deploy this\nnew version by changing the image in the Deployment specification again: \n$ kubectl set image deployment kubia nodejs=luksa/kubia:v3\ndeployment \"kubia\" image updated\nYou can follow the progress of the rollout with kubectl rollout status:\n$ kubectl rollout status deployment kubia\nWaiting for rollout to finish: 1 out of 3 new replicas have been updated...\nWaiting for rollout to finish: 2 out of 3 new replicas have been updated...\nWaiting for rollout to finish: 1 old replicas are pending termination...\ndeployment \"kubia\" successfully rolled out\nThe new version is now live. As the following listing shows, after a few requests, your\nweb clients start receiving errors.\n$ while true; do curl http://130.211.109.222; done\nThis is v3 running in pod kubia-1914148340-lalmx\nThis is v3 running in pod kubia-1914148340-bz35w\nThis is v3 running in pod kubia-1914148340-w0voh\n...\nThis is v3 running in pod kubia-1914148340-w0voh\nSome internal error has occurred! This is pod kubia-1914148340-bz35w\nThis is v3 running in pod kubia-1914148340-w0voh\nSome internal error has occurred! This is pod kubia-1914148340-lalmx\nThis is v3 running in pod kubia-1914148340-w0voh\nSome internal error has occurred! This is pod kubia-1914148340-lalmx\nSome internal error has occurred! This is pod kubia-1914148340-bz35w\nSome internal error has occurred! This is pod kubia-1914148340-w0voh\nUNDOING A ROLLOUT\nYou can\u2019t have your users experiencing internal server errors, so you need to do some-\nthing about it fast. In section 9.3.6 you\u2019ll see how to block bad rollouts automatically,\nbut for now, let\u2019s see what you can do about your bad rollout manually. Luckily,\nDeployments make it easy to roll back to the previously deployed version by telling\nKubernetes to undo the last rollout of a Deployment:\n$ kubectl rollout undo deployment kubia\ndeployment \"kubia\" rolled back\nThis rolls the Deployment back to the previous revision. \nTIP\nThe undo command can also be used while the rollout process is still in\nprogress to essentially abort the rollout. Pods already created during the roll-\nout process are removed and replaced with the old ones again.\nListing 9.9\nHitting your broken version 3\n \n"}, {"color": "green", "id": "text_213", "label": "270\nCHAPTER 9\nDeployments: updating applications declaratively\nDISPLAYING A DEPLOYMENT\u2019S ROLLOUT HISTORY\nRolling back a rollout is possible because Deployments keep a revision history. As\nyou\u2019ll see later, the history is stored in the underlying ReplicaSets. When a rollout\ncompletes, the old ReplicaSet isn\u2019t deleted, and this enables rolling back to any revi-\nsion, not only the previous one. The revision history can be displayed with the\nkubectl rollout history command:\n$ kubectl rollout history deployment kubia\ndeployments \"kubia\":\nREVISION    CHANGE-CAUSE\n2           kubectl set image deployment kubia nodejs=luksa/kubia:v2\n3           kubectl set image deployment kubia nodejs=luksa/kubia:v3\nRemember the --record command-line option you used when creating the Deploy-\nment? Without it, the CHANGE-CAUSE column in the revision history would be empty,\nmaking it much harder to figure out what\u2019s behind each revision.\nROLLING BACK TO A SPECIFIC DEPLOYMENT REVISION\nYou can roll back to a specific revision by specifying the revision in the undo com-\nmand. For example, if you want to roll back to the first version, you\u2019d execute the fol-\nlowing command:\n$ kubectl rollout undo deployment kubia --to-revision=1\nRemember the inactive ReplicaSet left over when you modified the Deployment the\nfirst time? The ReplicaSet represents the first revision of your Deployment. All Replica-\nSets created by a Deployment represent the complete revision history, as shown in fig-\nure 9.11. Each ReplicaSet stores the complete information of the Deployment at that\nspecific revision, so you shouldn\u2019t delete it manually. If you do, you\u2019ll lose that specific\nrevision from the Deployment\u2019s history, preventing you from rolling back to it.\nBut having old ReplicaSets cluttering your ReplicaSet list is not ideal, so the length of\nthe revision history is limited by the revisionHistoryLimit property on the Deploy-\nment resource. It defaults to two, so normally only the current and the previous revision\nare shown in the history (and only the current and the previous ReplicaSet are pre-\nserved). Older ReplicaSets are deleted automatically. \nDeployment\nv1 ReplicaSet\nReplicaSet\nPods: v1\nReplicaSet\nReplicaSet\nReplicaSet\nRevision 2\nRevision 4\nRevision 3\nRevision 1\nRevision history\nCurrent revision\nFigure 9.11\nA Deployment\u2019s ReplicaSets also act as its revision history.\n \n", "shape": "dot", "size": 10, "title": "270\nCHAPTER 9\nDeployments: updating applications declaratively\nDISPLAYING A DEPLOYMENT\u2019S ROLLOUT HISTORY\nRolling back a rollout is possible because Deployments keep a revision history. As\nyou\u2019ll see later, the history is stored in the underlying ReplicaSets. When a rollout\ncompletes, the old ReplicaSet isn\u2019t deleted, and this enables rolling back to any revi-\nsion, not only the previous one. The revision history can be displayed with the\nkubectl rollout history command:\n$ kubectl rollout history deployment kubia\ndeployments \"kubia\":\nREVISION    CHANGE-CAUSE\n2           kubectl set image deployment kubia nodejs=luksa/kubia:v2\n3           kubectl set image deployment kubia nodejs=luksa/kubia:v3\nRemember the --record command-line option you used when creating the Deploy-\nment? Without it, the CHANGE-CAUSE column in the revision history would be empty,\nmaking it much harder to figure out what\u2019s behind each revision.\nROLLING BACK TO A SPECIFIC DEPLOYMENT REVISION\nYou can roll back to a specific revision by specifying the revision in the undo com-\nmand. For example, if you want to roll back to the first version, you\u2019d execute the fol-\nlowing command:\n$ kubectl rollout undo deployment kubia --to-revision=1\nRemember the inactive ReplicaSet left over when you modified the Deployment the\nfirst time? The ReplicaSet represents the first revision of your Deployment. All Replica-\nSets created by a Deployment represent the complete revision history, as shown in fig-\nure 9.11. Each ReplicaSet stores the complete information of the Deployment at that\nspecific revision, so you shouldn\u2019t delete it manually. If you do, you\u2019ll lose that specific\nrevision from the Deployment\u2019s history, preventing you from rolling back to it.\nBut having old ReplicaSets cluttering your ReplicaSet list is not ideal, so the length of\nthe revision history is limited by the revisionHistoryLimit property on the Deploy-\nment resource. It defaults to two, so normally only the current and the previous revision\nare shown in the history (and only the current and the previous ReplicaSet are pre-\nserved). Older ReplicaSets are deleted automatically. \nDeployment\nv1 ReplicaSet\nReplicaSet\nPods: v1\nReplicaSet\nReplicaSet\nReplicaSet\nRevision 2\nRevision 4\nRevision 3\nRevision 1\nRevision history\nCurrent revision\nFigure 9.11\nA Deployment\u2019s ReplicaSets also act as its revision history.\n \n"}, {"color": "green", "id": "text_214", "label": "271\nUsing Deployments for updating apps declaratively\nNOTE\nThe extensions/v1beta1 version of Deployments doesn\u2019t have a default\nrevisionHistoryLimit, whereas the default in version apps/v1beta2 is 10.\n9.3.4\nControlling the rate of the rollout\nWhen you performed the rollout to v3 and tracked its progress with the kubectl\nrollout status command, you saw that first a new pod was created, and when it\nbecame available, one of the old pods was deleted and another new pod was created.\nThis continued until there were no old pods left. The way new pods are created and\nold ones are deleted is configurable through two additional properties of the rolling\nupdate strategy. \nINTRODUCING THE MAXSURGE AND MAXUNAVAILABLE PROPERTIES OF THE ROLLING UPDATE STRATEGY\nTwo properties affect how many pods are replaced at once during a Deployment\u2019s roll-\ning update. They are maxSurge and maxUnavailable and can be set as part of the\nrollingUpdate sub-property of the Deployment\u2019s strategy attribute, as shown in\nthe following listing.\nspec:\n  strategy:\n    rollingUpdate:\n      maxSurge: 1\n      maxUnavailable: 0\n    type: RollingUpdate\nWhat these properties do is explained in table 9.2.\nBecause the desired replica count in your case was three, and both these properties\ndefault to 25%, maxSurge allowed the number of all pods to reach four, and\nListing 9.10\nSpecifying parameters for the rollingUpdate strategy\nTable 9.2\nProperties for configuring the rate of the rolling update\nProperty\nWhat it does\nmaxSurge\nDetermines how many pod instances you allow to exist above the desired replica \ncount configured on the Deployment. It defaults to 25%, so there can be at most \n25% more pod instances than the desired count. If the desired replica count is \nset to four, there will never be more than five pod instances running at the same \ntime during an update. When converting a percentage to an absolute number, \nthe number is rounded up. Instead of a percentage, the value can also be an \nabsolute value (for example, one or two additional pods can be allowed).\nmaxUnavailable\nDetermines how many pod instances can be unavailable relative to the desired \nreplica count during the update. It also defaults to 25%, so the number of avail-\nable pod instances must never fall below 75% of the desired replica count. Here, \nwhen converting a percentage to an absolute number, the number is rounded \ndown. If the desired replica count is set to four and the percentage is 25%, only \none pod can be unavailable. There will always be at least three pod instances \navailable to serve requests during the whole rollout. As with maxSurge, you can \nalso specify an absolute value instead of a percentage.\n \n", "shape": "dot", "size": 10, "title": "271\nUsing Deployments for updating apps declaratively\nNOTE\nThe extensions/v1beta1 version of Deployments doesn\u2019t have a default\nrevisionHistoryLimit, whereas the default in version apps/v1beta2 is 10.\n9.3.4\nControlling the rate of the rollout\nWhen you performed the rollout to v3 and tracked its progress with the kubectl\nrollout status command, you saw that first a new pod was created, and when it\nbecame available, one of the old pods was deleted and another new pod was created.\nThis continued until there were no old pods left. The way new pods are created and\nold ones are deleted is configurable through two additional properties of the rolling\nupdate strategy. \nINTRODUCING THE MAXSURGE AND MAXUNAVAILABLE PROPERTIES OF THE ROLLING UPDATE STRATEGY\nTwo properties affect how many pods are replaced at once during a Deployment\u2019s roll-\ning update. They are maxSurge and maxUnavailable and can be set as part of the\nrollingUpdate sub-property of the Deployment\u2019s strategy attribute, as shown in\nthe following listing.\nspec:\n  strategy:\n    rollingUpdate:\n      maxSurge: 1\n      maxUnavailable: 0\n    type: RollingUpdate\nWhat these properties do is explained in table 9.2.\nBecause the desired replica count in your case was three, and both these properties\ndefault to 25%, maxSurge allowed the number of all pods to reach four, and\nListing 9.10\nSpecifying parameters for the rollingUpdate strategy\nTable 9.2\nProperties for configuring the rate of the rolling update\nProperty\nWhat it does\nmaxSurge\nDetermines how many pod instances you allow to exist above the desired replica \ncount configured on the Deployment. It defaults to 25%, so there can be at most \n25% more pod instances than the desired count. If the desired replica count is \nset to four, there will never be more than five pod instances running at the same \ntime during an update. When converting a percentage to an absolute number, \nthe number is rounded up. Instead of a percentage, the value can also be an \nabsolute value (for example, one or two additional pods can be allowed).\nmaxUnavailable\nDetermines how many pod instances can be unavailable relative to the desired \nreplica count during the update. It also defaults to 25%, so the number of avail-\nable pod instances must never fall below 75% of the desired replica count. Here, \nwhen converting a percentage to an absolute number, the number is rounded \ndown. If the desired replica count is set to four and the percentage is 25%, only \none pod can be unavailable. There will always be at least three pod instances \navailable to serve requests during the whole rollout. As with maxSurge, you can \nalso specify an absolute value instead of a percentage.\n \n"}, {"color": "green", "id": "text_215", "label": "272\nCHAPTER 9\nDeployments: updating applications declaratively\nmaxUnavailable disallowed having any unavailable pods (in other words, three pods\nhad to be available at all times). This is shown in figure 9.12.\nUNDERSTANDING THE MAXUNAVAILABLE PROPERTY\nThe extensions/v1beta1 version of Deployments uses different defaults\u2014it sets both\nmaxSurge and maxUnavailable to 1 instead of 25%. In the case of three replicas, max-\nSurge is the same as before, but maxUnavailable is different (1 instead of 0). This\nmakes the rollout process unwind a bit differently, as shown in figure 9.13.\nv1\nNumber\nof pods\n3\n4\n2\n1\nTime\nv1\n3 available\n1 unavailable\nCreate\none\nv2 pod\n4 available\n3 available\n1 unavailable\n4 available\n3 available\n1 unavailable\nmaxSurge = 1\nmaxUnavailable = 0\nDesired replica count = 3\n3 available\nv2\nv1\nv1\nv2\nv2\nv1\nv1\nv1\nv1\nv1\nv1\nv1\nv1\nv1\nv1\nv2\nv2\nv2\nv2\nv2\nv2\nv2\nv2\nv1\nv2\nv2\nv2\nv2\n4 available\nWait\nuntil\nit\u2019s\navailable\nDelete\none v1\npod and\ncreate one\nv2 pod\nWait\nuntil\nit\u2019s\navailable\nDelete\none v1\npod and\ncreate one\nv2 pod\nWait\nuntil\nit\u2019s\navailable\nDelete\nlast\nv1 pod\nFigure 9.12\nRolling update of a Deployment with three replicas and default maxSurge and maxUnavailable \nv1\nNumber\nof pods\n3\n4\n2\n1\nTime\nv1\n2 available\n2 unavailable\n4 available\n2 available\n1 unavailable\n3 available\nmaxSurge = 1\nmaxUnavailable = 1\nDesired replica count = 3\nv1\nv1\nv1\nv1\nv1\nv2\nv2\nv2\nv2\nv2\nv2\nv2\nv2\nv2\nv2\nWait until\nboth are\navailable\nDelete\ntwo v1\npods and\ncreate one\nv2 pod\nDelete v1\npod and\ncreate two\nv2 pods\nWait\nuntil it\u2019s\navailable\nFigure 9.13\nRolling update of a Deployment with the maxSurge=1 and maxUnavailable=1\n \n", "shape": "dot", "size": 10, "title": "272\nCHAPTER 9\nDeployments: updating applications declaratively\nmaxUnavailable disallowed having any unavailable pods (in other words, three pods\nhad to be available at all times). This is shown in figure 9.12.\nUNDERSTANDING THE MAXUNAVAILABLE PROPERTY\nThe extensions/v1beta1 version of Deployments uses different defaults\u2014it sets both\nmaxSurge and maxUnavailable to 1 instead of 25%. In the case of three replicas, max-\nSurge is the same as before, but maxUnavailable is different (1 instead of 0). This\nmakes the rollout process unwind a bit differently, as shown in figure 9.13.\nv1\nNumber\nof pods\n3\n4\n2\n1\nTime\nv1\n3 available\n1 unavailable\nCreate\none\nv2 pod\n4 available\n3 available\n1 unavailable\n4 available\n3 available\n1 unavailable\nmaxSurge = 1\nmaxUnavailable = 0\nDesired replica count = 3\n3 available\nv2\nv1\nv1\nv2\nv2\nv1\nv1\nv1\nv1\nv1\nv1\nv1\nv1\nv1\nv1\nv2\nv2\nv2\nv2\nv2\nv2\nv2\nv2\nv1\nv2\nv2\nv2\nv2\n4 available\nWait\nuntil\nit\u2019s\navailable\nDelete\none v1\npod and\ncreate one\nv2 pod\nWait\nuntil\nit\u2019s\navailable\nDelete\none v1\npod and\ncreate one\nv2 pod\nWait\nuntil\nit\u2019s\navailable\nDelete\nlast\nv1 pod\nFigure 9.12\nRolling update of a Deployment with three replicas and default maxSurge and maxUnavailable \nv1\nNumber\nof pods\n3\n4\n2\n1\nTime\nv1\n2 available\n2 unavailable\n4 available\n2 available\n1 unavailable\n3 available\nmaxSurge = 1\nmaxUnavailable = 1\nDesired replica count = 3\nv1\nv1\nv1\nv1\nv1\nv2\nv2\nv2\nv2\nv2\nv2\nv2\nv2\nv2\nv2\nWait until\nboth are\navailable\nDelete\ntwo v1\npods and\ncreate one\nv2 pod\nDelete v1\npod and\ncreate two\nv2 pods\nWait\nuntil it\u2019s\navailable\nFigure 9.13\nRolling update of a Deployment with the maxSurge=1 and maxUnavailable=1\n \n"}, {"color": "green", "id": "text_216", "label": "273\nUsing Deployments for updating apps declaratively\nIn this case, one replica can be unavailable, so if the desired replica count is three,\nonly two of them need to be available. That\u2019s why the rollout process immediately\ndeletes one pod and creates two new ones. This ensures two pods are available and\nthat the maximum number of pods isn\u2019t exceeded (the maximum is four in this\ncase\u2014three plus one from maxSurge). As soon as the two new pods are available, the\ntwo remaining old pods are deleted.\n This is a bit hard to grasp, especially since the maxUnavailable property leads you\nto believe that that\u2019s the maximum number of unavailable pods that are allowed. If\nyou look at the previous figure closely, you\u2019ll see two unavailable pods in the second\ncolumn even though maxUnavailable is set to 1. \n It\u2019s important to keep in mind that maxUnavailable is relative to the desired\nreplica count. If the replica count is set to three and maxUnavailable is set to one,\nthat means that the update process must always keep at least two (3 minus 1) pods\navailable, while the number of pods that aren\u2019t available can exceed one.\n9.3.5\nPausing the rollout process\nAfter the bad experience with version 3 of your app, imagine you\u2019ve now fixed the bug\nand pushed version 4 of your image. You\u2019re a little apprehensive about rolling it out\nacross all your pods the way you did before. What you want is to run a single v4 pod\nnext to your existing v2 pods and see how it behaves with only a fraction of all your\nusers. Then, once you\u2019re sure everything\u2019s okay, you can replace all the old pods with\nnew ones. \n You could achieve this by running an additional pod either directly or through an\nadditional Deployment, ReplicationController, or ReplicaSet, but you do have another\noption available on the Deployment itself. A Deployment can also be paused during\nthe rollout process. This allows you to verify that everything is fine with the new ver-\nsion before proceeding with the rest of the rollout.\nPAUSING THE ROLLOUT\nI\u2019ve prepared the v4 image, so go ahead and trigger the rollout by changing the image\nto luksa/kubia:v4, but then immediately (within a few seconds) pause the rollout:\n$ kubectl set image deployment kubia nodejs=luksa/kubia:v4\ndeployment \"kubia\" image updated\n$ kubectl rollout pause deployment kubia\ndeployment \"kubia\" paused\nA single new pod should have been created, but all original pods should also still be\nrunning. Once the new pod is up, a part of all requests to the service will be redirected\nto the new pod. This way, you\u2019ve effectively run a canary release. A canary release is a\ntechnique for minimizing the risk of rolling out a bad version of an application and it\naffecting all your users. Instead of rolling out the new version to everyone, you replace\nonly one or a small number of old pods with new ones. This way only a small number\nof users will initially hit the new version. You can then verify whether the new version\n \n", "shape": "dot", "size": 10, "title": "273\nUsing Deployments for updating apps declaratively\nIn this case, one replica can be unavailable, so if the desired replica count is three,\nonly two of them need to be available. That\u2019s why the rollout process immediately\ndeletes one pod and creates two new ones. This ensures two pods are available and\nthat the maximum number of pods isn\u2019t exceeded (the maximum is four in this\ncase\u2014three plus one from maxSurge). As soon as the two new pods are available, the\ntwo remaining old pods are deleted.\n This is a bit hard to grasp, especially since the maxUnavailable property leads you\nto believe that that\u2019s the maximum number of unavailable pods that are allowed. If\nyou look at the previous figure closely, you\u2019ll see two unavailable pods in the second\ncolumn even though maxUnavailable is set to 1. \n It\u2019s important to keep in mind that maxUnavailable is relative to the desired\nreplica count. If the replica count is set to three and maxUnavailable is set to one,\nthat means that the update process must always keep at least two (3 minus 1) pods\navailable, while the number of pods that aren\u2019t available can exceed one.\n9.3.5\nPausing the rollout process\nAfter the bad experience with version 3 of your app, imagine you\u2019ve now fixed the bug\nand pushed version 4 of your image. You\u2019re a little apprehensive about rolling it out\nacross all your pods the way you did before. What you want is to run a single v4 pod\nnext to your existing v2 pods and see how it behaves with only a fraction of all your\nusers. Then, once you\u2019re sure everything\u2019s okay, you can replace all the old pods with\nnew ones. \n You could achieve this by running an additional pod either directly or through an\nadditional Deployment, ReplicationController, or ReplicaSet, but you do have another\noption available on the Deployment itself. A Deployment can also be paused during\nthe rollout process. This allows you to verify that everything is fine with the new ver-\nsion before proceeding with the rest of the rollout.\nPAUSING THE ROLLOUT\nI\u2019ve prepared the v4 image, so go ahead and trigger the rollout by changing the image\nto luksa/kubia:v4, but then immediately (within a few seconds) pause the rollout:\n$ kubectl set image deployment kubia nodejs=luksa/kubia:v4\ndeployment \"kubia\" image updated\n$ kubectl rollout pause deployment kubia\ndeployment \"kubia\" paused\nA single new pod should have been created, but all original pods should also still be\nrunning. Once the new pod is up, a part of all requests to the service will be redirected\nto the new pod. This way, you\u2019ve effectively run a canary release. A canary release is a\ntechnique for minimizing the risk of rolling out a bad version of an application and it\naffecting all your users. Instead of rolling out the new version to everyone, you replace\nonly one or a small number of old pods with new ones. This way only a small number\nof users will initially hit the new version. You can then verify whether the new version\n \n"}, {"color": "green", "id": "text_217", "label": "274\nCHAPTER 9\nDeployments: updating applications declaratively\nis working fine or not and then either continue the rollout across all remaining pods\nor roll back to the previous version. \nRESUMING THE ROLLOUT\nIn your case, by pausing the rollout process, only a small portion of client requests will\nhit your v4 pod, while most will still hit the v3 pods. Once you\u2019re confident the new\nversion works as it should, you can resume the deployment to replace all the old pods\nwith new ones:\n$ kubectl rollout resume deployment kubia\ndeployment \"kubia\" resumed\nObviously, having to pause the deployment at an exact point in the rollout process\nisn\u2019t what you want to do. In the future, a new upgrade strategy may do that automati-\ncally, but currently, the proper way of performing a canary release is by using two dif-\nferent Deployments and scaling them appropriately. \nUSING THE PAUSE FEATURE TO PREVENT ROLLOUTS\nPausing a Deployment can also be used to prevent updates to the Deployment from\nkicking off the rollout process, allowing you to make multiple changes to the Deploy-\nment and starting the rollout only when you\u2019re done making all the necessary changes.\nOnce you\u2019re ready for changes to take effect, you resume the Deployment and the\nrollout process will start.\nNOTE\nIf a Deployment is paused, the undo command won\u2019t undo it until you\nresume the Deployment.\n9.3.6\nBlocking rollouts of bad versions\nBefore you conclude this chapter, we need to discuss one more property of the Deploy-\nment resource. Remember the minReadySeconds property you set on the Deployment\nat the beginning of section 9.3.2? You used it to slow down the rollout, so you could see\nit was indeed performing a rolling update and not replacing all the pods at once. The\nmain function of minReadySeconds is to prevent deploying malfunctioning versions, not\nslowing down a deployment for fun. \nUNDERSTANDING THE APPLICABILITY OF MINREADYSECONDS\nThe minReadySeconds property specifies how long a newly created pod should be\nready before the pod is treated as available. Until the pod is available, the rollout pro-\ncess will not continue (remember the maxUnavailable property?). A pod is ready\nwhen readiness probes of all its containers return a success. If a new pod isn\u2019t func-\ntioning properly and its readiness probe starts failing before minReadySeconds have\npassed, the rollout of the new version will effectively be blocked.\n You used this property to slow down your rollout process by having Kubernetes\nwait 10 seconds after a pod was ready before continuing with the rollout. Usually,\nyou\u2019d set minReadySeconds to something much higher to make sure pods keep report-\ning they\u2019re ready after they\u2019ve already started receiving actual traffic. \n \n", "shape": "dot", "size": 10, "title": "274\nCHAPTER 9\nDeployments: updating applications declaratively\nis working fine or not and then either continue the rollout across all remaining pods\nor roll back to the previous version. \nRESUMING THE ROLLOUT\nIn your case, by pausing the rollout process, only a small portion of client requests will\nhit your v4 pod, while most will still hit the v3 pods. Once you\u2019re confident the new\nversion works as it should, you can resume the deployment to replace all the old pods\nwith new ones:\n$ kubectl rollout resume deployment kubia\ndeployment \"kubia\" resumed\nObviously, having to pause the deployment at an exact point in the rollout process\nisn\u2019t what you want to do. In the future, a new upgrade strategy may do that automati-\ncally, but currently, the proper way of performing a canary release is by using two dif-\nferent Deployments and scaling them appropriately. \nUSING THE PAUSE FEATURE TO PREVENT ROLLOUTS\nPausing a Deployment can also be used to prevent updates to the Deployment from\nkicking off the rollout process, allowing you to make multiple changes to the Deploy-\nment and starting the rollout only when you\u2019re done making all the necessary changes.\nOnce you\u2019re ready for changes to take effect, you resume the Deployment and the\nrollout process will start.\nNOTE\nIf a Deployment is paused, the undo command won\u2019t undo it until you\nresume the Deployment.\n9.3.6\nBlocking rollouts of bad versions\nBefore you conclude this chapter, we need to discuss one more property of the Deploy-\nment resource. Remember the minReadySeconds property you set on the Deployment\nat the beginning of section 9.3.2? You used it to slow down the rollout, so you could see\nit was indeed performing a rolling update and not replacing all the pods at once. The\nmain function of minReadySeconds is to prevent deploying malfunctioning versions, not\nslowing down a deployment for fun. \nUNDERSTANDING THE APPLICABILITY OF MINREADYSECONDS\nThe minReadySeconds property specifies how long a newly created pod should be\nready before the pod is treated as available. Until the pod is available, the rollout pro-\ncess will not continue (remember the maxUnavailable property?). A pod is ready\nwhen readiness probes of all its containers return a success. If a new pod isn\u2019t func-\ntioning properly and its readiness probe starts failing before minReadySeconds have\npassed, the rollout of the new version will effectively be blocked.\n You used this property to slow down your rollout process by having Kubernetes\nwait 10 seconds after a pod was ready before continuing with the rollout. Usually,\nyou\u2019d set minReadySeconds to something much higher to make sure pods keep report-\ning they\u2019re ready after they\u2019ve already started receiving actual traffic. \n \n"}, {"color": "green", "id": "text_218", "label": "275\nUsing Deployments for updating apps declaratively\n Although you should obviously test your pods both in a test and in a staging envi-\nronment before deploying them into production, using minReadySeconds is like an\nairbag that saves your app from making a big mess after you\u2019ve already let a buggy ver-\nsion slip into production. \n With a properly configured readiness probe and a proper minReadySeconds set-\nting, Kubernetes would have prevented us from deploying the buggy v3 version ear-\nlier. Let me show you how.\nDEFINING A READINESS PROBE TO PREVENT OUR V3 VERSION FROM BEING ROLLED OUT FULLY\nYou\u2019re going to deploy version v3 again, but this time, you\u2019ll have the proper readi-\nness probe defined on the pod. Your Deployment is currently at version v4, so before\nyou start, roll back to version v2 again so you can pretend this is the first time you\u2019re\nupgrading to v3. If you wish, you can go straight from v4 to v3, but the text that fol-\nlows assumes you returned to v2 first.\n Unlike before, where you only updated the image in the pod template, you\u2019re now\nalso going to introduce a readiness probe for the container at the same time. Up until\nnow, because there was no explicit readiness probe defined, the container and the\npod were always considered ready, even if the app wasn\u2019t truly ready or was returning\nerrors. There was no way for Kubernetes to know that the app was malfunctioning and\nshouldn\u2019t be exposed to clients. \n To change the image and introduce the readiness probe at once, you\u2019ll use the\nkubectl apply command. You\u2019ll use the following YAML to update the deployment\n(you\u2019ll store it as kubia-deployment-v3-with-readinesscheck.yaml), as shown in\nthe following listing.\napiVersion: apps/v1beta1\nkind: Deployment\nmetadata:\n  name: kubia\nspec:\n  replicas: 3\n  minReadySeconds: 10           \n  strategy:\n    rollingUpdate:\n      maxSurge: 1                  \n      maxUnavailable: 0         \n    type: RollingUpdate\n  template:\n    metadata:\n      name: kubia\n      labels:\n        app: kubia\n    spec:\n      containers:\n      - image: luksa/kubia:v3\nListing 9.11\nDeployment with a readiness probe: kubia-deployment-v3-with-\nreadinesscheck.yaml\nYou\u2019re keeping \nminReadySeconds \nset to 10.\nYou\u2019re keeping maxUnavailable \nset to 0 to make the deployment \nreplace pods one by one\n \n", "shape": "dot", "size": 10, "title": "275\nUsing Deployments for updating apps declaratively\n Although you should obviously test your pods both in a test and in a staging envi-\nronment before deploying them into production, using minReadySeconds is like an\nairbag that saves your app from making a big mess after you\u2019ve already let a buggy ver-\nsion slip into production. \n With a properly configured readiness probe and a proper minReadySeconds set-\nting, Kubernetes would have prevented us from deploying the buggy v3 version ear-\nlier. Let me show you how.\nDEFINING A READINESS PROBE TO PREVENT OUR V3 VERSION FROM BEING ROLLED OUT FULLY\nYou\u2019re going to deploy version v3 again, but this time, you\u2019ll have the proper readi-\nness probe defined on the pod. Your Deployment is currently at version v4, so before\nyou start, roll back to version v2 again so you can pretend this is the first time you\u2019re\nupgrading to v3. If you wish, you can go straight from v4 to v3, but the text that fol-\nlows assumes you returned to v2 first.\n Unlike before, where you only updated the image in the pod template, you\u2019re now\nalso going to introduce a readiness probe for the container at the same time. Up until\nnow, because there was no explicit readiness probe defined, the container and the\npod were always considered ready, even if the app wasn\u2019t truly ready or was returning\nerrors. There was no way for Kubernetes to know that the app was malfunctioning and\nshouldn\u2019t be exposed to clients. \n To change the image and introduce the readiness probe at once, you\u2019ll use the\nkubectl apply command. You\u2019ll use the following YAML to update the deployment\n(you\u2019ll store it as kubia-deployment-v3-with-readinesscheck.yaml), as shown in\nthe following listing.\napiVersion: apps/v1beta1\nkind: Deployment\nmetadata:\n  name: kubia\nspec:\n  replicas: 3\n  minReadySeconds: 10           \n  strategy:\n    rollingUpdate:\n      maxSurge: 1                  \n      maxUnavailable: 0         \n    type: RollingUpdate\n  template:\n    metadata:\n      name: kubia\n      labels:\n        app: kubia\n    spec:\n      containers:\n      - image: luksa/kubia:v3\nListing 9.11\nDeployment with a readiness probe: kubia-deployment-v3-with-\nreadinesscheck.yaml\nYou\u2019re keeping \nminReadySeconds \nset to 10.\nYou\u2019re keeping maxUnavailable \nset to 0 to make the deployment \nreplace pods one by one\n \n"}, {"color": "green", "id": "text_219", "label": "276\nCHAPTER 9\nDeployments: updating applications declaratively\n        name: nodejs\n        readinessProbe:\n          periodSeconds: 1       \n          httpGet:                  \n            path: /                 \n            port: 8080              \nUPDATING A DEPLOYMENT WITH KUBECTL APPLY\nTo update the Deployment this time, you\u2019ll use kubectl apply like this:\n$ kubectl apply -f kubia-deployment-v3-with-readinesscheck.yaml \ndeployment \"kubia\" configured\nThe apply command updates the Deployment with everything that\u2019s defined in the\nYAML file. It not only updates the image but also adds the readiness probe definition\nand anything else you\u2019ve added or modified in the YAML. If the new YAML also con-\ntains the replicas field, which doesn\u2019t match the number of replicas on the existing\nDeployment, the apply operation will also scale the Deployment, which isn\u2019t usually\nwhat you want. \nTIP\nTo keep the desired replica count unchanged when updating a Deploy-\nment with kubectl apply, don\u2019t include the replicas field in the YAML. \nRunning the apply command will kick off the update process, which you can again\nfollow with the rollout status command:\n$ kubectl rollout status deployment kubia\nWaiting for rollout to finish: 1 out of 3 new replicas have been updated...\nBecause the status says one new pod has been created, your service should be hitting it\noccasionally, right? Let\u2019s see:\n$ while true; do curl http://130.211.109.222; done\nThis is v2 running in pod kubia-1765119474-jvslk\nThis is v2 running in pod kubia-1765119474-jvslk\nThis is v2 running in pod kubia-1765119474-xk5g3\nThis is v2 running in pod kubia-1765119474-pmb26\nThis is v2 running in pod kubia-1765119474-pmb26\nThis is v2 running in pod kubia-1765119474-xk5g3\n...\nNope, you never hit the v3 pod. Why not? Is it even there? List the pods:\n$ kubectl get po\nNAME                     READY     STATUS    RESTARTS   AGE\nkubia-1163142519-7ws0i   0/1       Running   0          30s\nkubia-1765119474-jvslk   1/1       Running   0          9m\nkubia-1765119474-pmb26   1/1       Running   0          9m\nkubia-1765119474-xk5g3   1/1       Running   0          8m\nYou\u2019re defining a readiness probe \nthat will be executed every second.\nThe readiness probe will \nperform an HTTP GET request \nagainst our container.\n \n", "shape": "dot", "size": 10, "title": "276\nCHAPTER 9\nDeployments: updating applications declaratively\n        name: nodejs\n        readinessProbe:\n          periodSeconds: 1       \n          httpGet:                  \n            path: /                 \n            port: 8080              \nUPDATING A DEPLOYMENT WITH KUBECTL APPLY\nTo update the Deployment this time, you\u2019ll use kubectl apply like this:\n$ kubectl apply -f kubia-deployment-v3-with-readinesscheck.yaml \ndeployment \"kubia\" configured\nThe apply command updates the Deployment with everything that\u2019s defined in the\nYAML file. It not only updates the image but also adds the readiness probe definition\nand anything else you\u2019ve added or modified in the YAML. If the new YAML also con-\ntains the replicas field, which doesn\u2019t match the number of replicas on the existing\nDeployment, the apply operation will also scale the Deployment, which isn\u2019t usually\nwhat you want. \nTIP\nTo keep the desired replica count unchanged when updating a Deploy-\nment with kubectl apply, don\u2019t include the replicas field in the YAML. \nRunning the apply command will kick off the update process, which you can again\nfollow with the rollout status command:\n$ kubectl rollout status deployment kubia\nWaiting for rollout to finish: 1 out of 3 new replicas have been updated...\nBecause the status says one new pod has been created, your service should be hitting it\noccasionally, right? Let\u2019s see:\n$ while true; do curl http://130.211.109.222; done\nThis is v2 running in pod kubia-1765119474-jvslk\nThis is v2 running in pod kubia-1765119474-jvslk\nThis is v2 running in pod kubia-1765119474-xk5g3\nThis is v2 running in pod kubia-1765119474-pmb26\nThis is v2 running in pod kubia-1765119474-pmb26\nThis is v2 running in pod kubia-1765119474-xk5g3\n...\nNope, you never hit the v3 pod. Why not? Is it even there? List the pods:\n$ kubectl get po\nNAME                     READY     STATUS    RESTARTS   AGE\nkubia-1163142519-7ws0i   0/1       Running   0          30s\nkubia-1765119474-jvslk   1/1       Running   0          9m\nkubia-1765119474-pmb26   1/1       Running   0          9m\nkubia-1765119474-xk5g3   1/1       Running   0          8m\nYou\u2019re defining a readiness probe \nthat will be executed every second.\nThe readiness probe will \nperform an HTTP GET request \nagainst our container.\n \n"}, {"color": "green", "id": "text_220", "label": "277\nUsing Deployments for updating apps declaratively\nAha! There\u2019s your problem (or as you\u2019ll learn soon, your blessing)! The pod is shown\nas not ready, but I guess you\u2019ve been expecting that, right? What has happened?\nUNDERSTANDING HOW A READINESS PROBE PREVENTS BAD VERSIONS FROM BEING ROLLED OUT\nAs soon as your new pod starts, the readiness probe starts being hit every second (you\nset the probe\u2019s interval to one second in the pod spec). On the fifth request the readi-\nness probe began failing, because your app starts returning HTTP status code 500\nfrom the fifth request onward. \n As a result, the pod is removed as an endpoint from the service (see figure 9.14).\nBy the time you start hitting the service in the curl loop, the pod has already been\nmarked as not ready. This explains why you never hit the new pod with curl. And\nthat\u2019s exactly what you want, because you don\u2019t want clients to hit a pod that\u2019s not\nfunctioning properly.\nBut what about the rollout process? The rollout status command shows only one\nnew replica has started. Thankfully, the rollout process will not continue, because the\nnew pod will never become available. To be considered available, it needs to be ready\nfor at least 10 seconds. Until it\u2019s available, the rollout process will not create any new\npods, and it also won\u2019t remove any original pods because you\u2019ve set the maxUnavailable\nproperty to 0. \nService\ncurl\nPod: v2\nPod: v2\nPod: v3\n(unhealthy)\nPod: v2\nReplicaSet: v2\nReplicas: 3\nDeployment\nReplicas: 3\nrollingUpdate:\nmaxSurge: 1\nmaxUnavailable: 0\nReplicaSet: v3\nReplicas: 1\nRequests are not forwarded\nto v3 pod because of failed\nreadiness probe\nFigure 9.14\nDeployment blocked by a failing readiness probe in the new pod\n \n", "shape": "dot", "size": 10, "title": "277\nUsing Deployments for updating apps declaratively\nAha! There\u2019s your problem (or as you\u2019ll learn soon, your blessing)! The pod is shown\nas not ready, but I guess you\u2019ve been expecting that, right? What has happened?\nUNDERSTANDING HOW A READINESS PROBE PREVENTS BAD VERSIONS FROM BEING ROLLED OUT\nAs soon as your new pod starts, the readiness probe starts being hit every second (you\nset the probe\u2019s interval to one second in the pod spec). On the fifth request the readi-\nness probe began failing, because your app starts returning HTTP status code 500\nfrom the fifth request onward. \n As a result, the pod is removed as an endpoint from the service (see figure 9.14).\nBy the time you start hitting the service in the curl loop, the pod has already been\nmarked as not ready. This explains why you never hit the new pod with curl. And\nthat\u2019s exactly what you want, because you don\u2019t want clients to hit a pod that\u2019s not\nfunctioning properly.\nBut what about the rollout process? The rollout status command shows only one\nnew replica has started. Thankfully, the rollout process will not continue, because the\nnew pod will never become available. To be considered available, it needs to be ready\nfor at least 10 seconds. Until it\u2019s available, the rollout process will not create any new\npods, and it also won\u2019t remove any original pods because you\u2019ve set the maxUnavailable\nproperty to 0. \nService\ncurl\nPod: v2\nPod: v2\nPod: v3\n(unhealthy)\nPod: v2\nReplicaSet: v2\nReplicas: 3\nDeployment\nReplicas: 3\nrollingUpdate:\nmaxSurge: 1\nmaxUnavailable: 0\nReplicaSet: v3\nReplicas: 1\nRequests are not forwarded\nto v3 pod because of failed\nreadiness probe\nFigure 9.14\nDeployment blocked by a failing readiness probe in the new pod\n \n"}, {"color": "green", "id": "text_221", "label": "278\nCHAPTER 9\nDeployments: updating applications declaratively\n The fact that the deployment is stuck is a good thing, because if it had continued\nreplacing the old pods with the new ones, you\u2019d end up with a completely non-working\nservice, like you did when you first rolled out version 3, when you weren\u2019t using the\nreadiness probe. But now, with the readiness probe in place, there was virtually no\nnegative impact on your users. A few users may have experienced the internal server\nerror, but that\u2019s not as big of a problem as if the rollout had replaced all pods with the\nfaulty version 3.\nTIP\nIf you only define the readiness probe without setting minReadySeconds\nproperly, new pods are considered available immediately when the first invo-\ncation of the readiness probe succeeds. If the readiness probe starts failing\nshortly after, the bad version is rolled out across all pods. Therefore, you\nshould set minReadySeconds appropriately.\nCONFIGURING A DEADLINE FOR THE ROLLOUT\nBy default, after the rollout can\u2019t make any progress in 10 minutes, it\u2019s considered as\nfailed. If you use the kubectl describe deployment command, you\u2019ll see it display a\nProgressDeadlineExceeded condition, as shown in the following listing.\n$ kubectl describe deploy kubia\nName:                   kubia\n...\nConditions:\n  Type          Status  Reason\n  ----          ------  ------\n  Available     True    MinimumReplicasAvailable\n  Progressing   False   ProgressDeadlineExceeded   \nThe time after which the Deployment is considered failed is configurable through the\nprogressDeadlineSeconds property in the Deployment spec.\nNOTE\nThe extensions/v1beta1 version of Deployments doesn\u2019t set a deadline.\nABORTING A BAD ROLLOUT\nBecause the rollout will never continue, the only thing to do now is abort the rollout\nby undoing it:\n$ kubectl rollout undo deployment kubia\ndeployment \"kubia\" rolled back\nNOTE\nIn future versions, the rollout will be aborted automatically when the\ntime specified in progressDeadlineSeconds is exceeded.\nListing 9.12\nSeeing the conditions of a Deployment with kubectl describe\nThe Deployment \ntook too long to \nmake progress.\n \n", "shape": "dot", "size": 10, "title": "278\nCHAPTER 9\nDeployments: updating applications declaratively\n The fact that the deployment is stuck is a good thing, because if it had continued\nreplacing the old pods with the new ones, you\u2019d end up with a completely non-working\nservice, like you did when you first rolled out version 3, when you weren\u2019t using the\nreadiness probe. But now, with the readiness probe in place, there was virtually no\nnegative impact on your users. A few users may have experienced the internal server\nerror, but that\u2019s not as big of a problem as if the rollout had replaced all pods with the\nfaulty version 3.\nTIP\nIf you only define the readiness probe without setting minReadySeconds\nproperly, new pods are considered available immediately when the first invo-\ncation of the readiness probe succeeds. If the readiness probe starts failing\nshortly after, the bad version is rolled out across all pods. Therefore, you\nshould set minReadySeconds appropriately.\nCONFIGURING A DEADLINE FOR THE ROLLOUT\nBy default, after the rollout can\u2019t make any progress in 10 minutes, it\u2019s considered as\nfailed. If you use the kubectl describe deployment command, you\u2019ll see it display a\nProgressDeadlineExceeded condition, as shown in the following listing.\n$ kubectl describe deploy kubia\nName:                   kubia\n...\nConditions:\n  Type          Status  Reason\n  ----          ------  ------\n  Available     True    MinimumReplicasAvailable\n  Progressing   False   ProgressDeadlineExceeded   \nThe time after which the Deployment is considered failed is configurable through the\nprogressDeadlineSeconds property in the Deployment spec.\nNOTE\nThe extensions/v1beta1 version of Deployments doesn\u2019t set a deadline.\nABORTING A BAD ROLLOUT\nBecause the rollout will never continue, the only thing to do now is abort the rollout\nby undoing it:\n$ kubectl rollout undo deployment kubia\ndeployment \"kubia\" rolled back\nNOTE\nIn future versions, the rollout will be aborted automatically when the\ntime specified in progressDeadlineSeconds is exceeded.\nListing 9.12\nSeeing the conditions of a Deployment with kubectl describe\nThe Deployment \ntook too long to \nmake progress.\n \n"}, {"color": "green", "id": "text_222", "label": "279\nSummary\n9.4\nSummary\nThis chapter has shown you how to make your life easier by using a declarative\napproach to deploying and updating applications in Kubernetes. Now that you\u2019ve\nread this chapter, you should know how to\n\uf0a1Perform a rolling update of pods managed by a ReplicationController\n\uf0a1Create Deployments instead of lower-level ReplicationControllers or ReplicaSets\n\uf0a1Update your pods by editing the pod template in the Deployment specification\n\uf0a1Roll back a Deployment either to the previous revision or to any earlier revision\nstill listed in the revision history\n\uf0a1Abort a Deployment mid-way\n\uf0a1Pause a Deployment to inspect how a single instance of the new version behaves\nin production before allowing additional pod instances to replace the old ones\n\uf0a1Control the rate of the rolling update through maxSurge and maxUnavailable\nproperties\n\uf0a1Use minReadySeconds and readiness probes to have the rollout of a faulty ver-\nsion blocked automatically\nIn addition to these Deployment-specific tasks, you also learned how to\n\uf0a1Use three dashes as a separator to define multiple resources in a single YAML file\n\uf0a1Turn on kubectl\u2019s verbose logging to see exactly what it\u2019s doing behind the\ncurtains\nYou now know how to deploy and manage sets of pods created from the same pod\ntemplate and thus share the same persistent storage. You even know how to update\nthem declaratively. But what about running sets of pods, where each instance needs to\nuse its own persistent storage? We haven\u2019t looked at that yet. That\u2019s the subject of our\nnext chapter.\n \n", "shape": "dot", "size": 10, "title": "279\nSummary\n9.4\nSummary\nThis chapter has shown you how to make your life easier by using a declarative\napproach to deploying and updating applications in Kubernetes. Now that you\u2019ve\nread this chapter, you should know how to\n\uf0a1Perform a rolling update of pods managed by a ReplicationController\n\uf0a1Create Deployments instead of lower-level ReplicationControllers or ReplicaSets\n\uf0a1Update your pods by editing the pod template in the Deployment specification\n\uf0a1Roll back a Deployment either to the previous revision or to any earlier revision\nstill listed in the revision history\n\uf0a1Abort a Deployment mid-way\n\uf0a1Pause a Deployment to inspect how a single instance of the new version behaves\nin production before allowing additional pod instances to replace the old ones\n\uf0a1Control the rate of the rolling update through maxSurge and maxUnavailable\nproperties\n\uf0a1Use minReadySeconds and readiness probes to have the rollout of a faulty ver-\nsion blocked automatically\nIn addition to these Deployment-specific tasks, you also learned how to\n\uf0a1Use three dashes as a separator to define multiple resources in a single YAML file\n\uf0a1Turn on kubectl\u2019s verbose logging to see exactly what it\u2019s doing behind the\ncurtains\nYou now know how to deploy and manage sets of pods created from the same pod\ntemplate and thus share the same persistent storage. You even know how to update\nthem declaratively. But what about running sets of pods, where each instance needs to\nuse its own persistent storage? We haven\u2019t looked at that yet. That\u2019s the subject of our\nnext chapter.\n \n"}, {"color": "green", "id": "text_223", "label": "280\nStatefulSets:\ndeploying replicated\nstateful applications\nYou now know how to run both single-instance and replicated stateless pods,\nand even stateful pods utilizing persistent storage. You can run several repli-\ncated web-server pod instances and you can run a single database pod instance\nthat uses persistent storage, provided either through plain pod volumes or through\nPersistentVolumes bound by a PersistentVolumeClaim. But can you employ a\nReplicaSet to replicate the database pod?\nThis chapter covers\n\uf0a1Deploying stateful clustered applications\n\uf0a1Providing separate storage for each instance of \na replicated pod\n\uf0a1Guaranteeing a stable name and hostname for \npod replicas\n\uf0a1Starting and stopping pod replicas in a \npredictable order\n\uf0a1Discovering peers through DNS SRV records\n \n", "shape": "dot", "size": 10, "title": "280\nStatefulSets:\ndeploying replicated\nstateful applications\nYou now know how to run both single-instance and replicated stateless pods,\nand even stateful pods utilizing persistent storage. You can run several repli-\ncated web-server pod instances and you can run a single database pod instance\nthat uses persistent storage, provided either through plain pod volumes or through\nPersistentVolumes bound by a PersistentVolumeClaim. But can you employ a\nReplicaSet to replicate the database pod?\nThis chapter covers\n\uf0a1Deploying stateful clustered applications\n\uf0a1Providing separate storage for each instance of \na replicated pod\n\uf0a1Guaranteeing a stable name and hostname for \npod replicas\n\uf0a1Starting and stopping pod replicas in a \npredictable order\n\uf0a1Discovering peers through DNS SRV records\n \n"}, {"color": "green", "id": "text_224", "label": "281\nReplicating stateful pods\n10.1\nReplicating stateful pods\nReplicaSets create multiple pod replicas from a single pod template. These replicas\ndon\u2019t differ from each other, apart from their name and IP address. If the pod tem-\nplate includes a volume, which refers to a specific PersistentVolumeClaim, all replicas\nof the ReplicaSet will use the exact same PersistentVolumeClaim and therefore the\nsame PersistentVolume bound by the claim (shown in figure 10.1).\nBecause the reference to the claim is in the pod template, which is used to stamp out\nmultiple pod replicas, you can\u2019t make each replica use its own separate Persistent-\nVolumeClaim. You can\u2019t use a ReplicaSet to run a distributed data store, where each\ninstance needs its own separate storage\u2014at least not by using a single ReplicaSet. To\nbe honest, none of the API objects you\u2019ve seen so far make running such a data store\npossible. You need something else. \n10.1.1 Running multiple replicas with separate storage for each\nHow does one run multiple replicas of a pod and have each pod use its own storage\nvolume? ReplicaSets create exact copies (replicas) of a pod; therefore you can\u2019t use\nthem for these types of pods. What can you use?\nCREATING PODS MANUALLY\nYou could create pods manually and have each of them use its own PersistentVolume-\nClaim, but because no ReplicaSet looks after them, you\u2019d need to manage them man-\nually and recreate them when they disappear (as in the event of a node failure).\nTherefore, this isn\u2019t a viable option.\nUSING ONE REPLICASET PER POD INSTANCE\nInstead of creating pods directly, you could create multiple ReplicaSets\u2014one for each\npod with each ReplicaSet\u2019s desired replica count set to one, and each ReplicaSet\u2019s pod\ntemplate referencing a dedicated PersistentVolumeClaim (as shown in figure 10.2).\n Although this takes care of the automatic rescheduling in case of node failures or\naccidental pod deletions, it\u2019s much more cumbersome compared to having a single\nReplicaSet. For example, think about how you\u2019d scale the pods in that case. You\nPersistent\nVolume\nClaim\nPersistent\nVolume\nReplicaSet\nPod\nPod\nPod\nFigure 10.1\nAll pods from the same ReplicaSet always use the same \nPersistentVolumeClaim and PersistentVolume.\n \n", "shape": "dot", "size": 10, "title": "281\nReplicating stateful pods\n10.1\nReplicating stateful pods\nReplicaSets create multiple pod replicas from a single pod template. These replicas\ndon\u2019t differ from each other, apart from their name and IP address. If the pod tem-\nplate includes a volume, which refers to a specific PersistentVolumeClaim, all replicas\nof the ReplicaSet will use the exact same PersistentVolumeClaim and therefore the\nsame PersistentVolume bound by the claim (shown in figure 10.1).\nBecause the reference to the claim is in the pod template, which is used to stamp out\nmultiple pod replicas, you can\u2019t make each replica use its own separate Persistent-\nVolumeClaim. You can\u2019t use a ReplicaSet to run a distributed data store, where each\ninstance needs its own separate storage\u2014at least not by using a single ReplicaSet. To\nbe honest, none of the API objects you\u2019ve seen so far make running such a data store\npossible. You need something else. \n10.1.1 Running multiple replicas with separate storage for each\nHow does one run multiple replicas of a pod and have each pod use its own storage\nvolume? ReplicaSets create exact copies (replicas) of a pod; therefore you can\u2019t use\nthem for these types of pods. What can you use?\nCREATING PODS MANUALLY\nYou could create pods manually and have each of them use its own PersistentVolume-\nClaim, but because no ReplicaSet looks after them, you\u2019d need to manage them man-\nually and recreate them when they disappear (as in the event of a node failure).\nTherefore, this isn\u2019t a viable option.\nUSING ONE REPLICASET PER POD INSTANCE\nInstead of creating pods directly, you could create multiple ReplicaSets\u2014one for each\npod with each ReplicaSet\u2019s desired replica count set to one, and each ReplicaSet\u2019s pod\ntemplate referencing a dedicated PersistentVolumeClaim (as shown in figure 10.2).\n Although this takes care of the automatic rescheduling in case of node failures or\naccidental pod deletions, it\u2019s much more cumbersome compared to having a single\nReplicaSet. For example, think about how you\u2019d scale the pods in that case. You\nPersistent\nVolume\nClaim\nPersistent\nVolume\nReplicaSet\nPod\nPod\nPod\nFigure 10.1\nAll pods from the same ReplicaSet always use the same \nPersistentVolumeClaim and PersistentVolume.\n \n"}, {"color": "green", "id": "text_225", "label": "282\nCHAPTER 10\nStatefulSets: deploying replicated stateful applications\ncouldn\u2019t change the desired replica count\u2014you\u2019d have to create additional Replica-\nSets instead. \n Using multiple ReplicaSets is therefore not the best solution. But could you maybe\nuse a single ReplicaSet and have each pod instance keep its own persistent state, even\nthough they\u2019re all using the same storage volume? \nUSING MULTIPLE DIRECTORIES IN THE SAME VOLUME\nA trick you can use is to have all pods use the same PersistentVolume, but then have a\nseparate file directory inside that volume for each pod (this is shown in figure 10.3).\nBecause you can\u2019t configure pod replicas differently from a single pod template, you\ncan\u2019t tell each instance what directory it should use, but you can make each instance\nautomatically select (and possibly also create) a data directory that isn\u2019t being used\nby any other instance at that time. This solution does require coordination between\nthe instances, and isn\u2019t easy to do correctly. It also makes the shared storage volume\nthe bottleneck.\n10.1.2 Providing a stable identity for each pod\nIn addition to storage, certain clustered applications also require that each instance\nhas a long-lived stable identity. Pods can be killed from time to time and replaced with\nPVC A1\nPV A1\nReplicaSet A1\nPod A1-xyz\nPVC A2\nPV A2\nReplicaSet A2\nPod A2-xzy\nPVC A3\nPV A3\nReplicaSet A3\nPod A3-zyx\nFigure 10.2\nUsing one ReplicaSet for each pod instance\nPersistent\nVolume\nClaim\nPersistentVolume\nReplicaSet\nPod\nPod\nPod\nApp\nApp\nApp\n/data/1/\n/data/3/\n/data/2/\nFigure 10.3\nWorking around the shared storage problem by having the app \nin each pod use a different file directory \n \n", "shape": "dot", "size": 10, "title": "282\nCHAPTER 10\nStatefulSets: deploying replicated stateful applications\ncouldn\u2019t change the desired replica count\u2014you\u2019d have to create additional Replica-\nSets instead. \n Using multiple ReplicaSets is therefore not the best solution. But could you maybe\nuse a single ReplicaSet and have each pod instance keep its own persistent state, even\nthough they\u2019re all using the same storage volume? \nUSING MULTIPLE DIRECTORIES IN THE SAME VOLUME\nA trick you can use is to have all pods use the same PersistentVolume, but then have a\nseparate file directory inside that volume for each pod (this is shown in figure 10.3).\nBecause you can\u2019t configure pod replicas differently from a single pod template, you\ncan\u2019t tell each instance what directory it should use, but you can make each instance\nautomatically select (and possibly also create) a data directory that isn\u2019t being used\nby any other instance at that time. This solution does require coordination between\nthe instances, and isn\u2019t easy to do correctly. It also makes the shared storage volume\nthe bottleneck.\n10.1.2 Providing a stable identity for each pod\nIn addition to storage, certain clustered applications also require that each instance\nhas a long-lived stable identity. Pods can be killed from time to time and replaced with\nPVC A1\nPV A1\nReplicaSet A1\nPod A1-xyz\nPVC A2\nPV A2\nReplicaSet A2\nPod A2-xzy\nPVC A3\nPV A3\nReplicaSet A3\nPod A3-zyx\nFigure 10.2\nUsing one ReplicaSet for each pod instance\nPersistent\nVolume\nClaim\nPersistentVolume\nReplicaSet\nPod\nPod\nPod\nApp\nApp\nApp\n/data/1/\n/data/3/\n/data/2/\nFigure 10.3\nWorking around the shared storage problem by having the app \nin each pod use a different file directory \n \n"}, {"color": "green", "id": "text_226", "label": "283\nReplicating stateful pods\nnew ones. When a ReplicaSet replaces a pod, the new pod is a completely new pod\nwith a new hostname and IP, although the data in its storage volume may be that of\nthe killed pod. For certain apps, starting up with the old instance\u2019s data but with a\ncompletely new network identity may cause problems.\n Why do certain apps mandate a stable network identity? This requirement is\nfairly common in distributed stateful applications. Certain apps require the adminis-\ntrator to list all the other cluster members and their IP addresses (or hostnames) in\neach member\u2019s configuration file. But in Kubernetes, every time a pod is resched-\nuled, the new pod gets both a new hostname and a new IP address, so the whole\napplication cluster would have to be reconfigured every time one of its members is\nrescheduled. \nUSING A DEDICATED SERVICE FOR EACH POD INSTANCE\nA trick you can use to work around this problem is to provide a stable network address\nfor cluster members by creating a dedicated Kubernetes Service for each individual\nmember. Because service IPs are stable, you can then point to each member through\nits service IP (rather than the pod IP) in the configuration. \n This is similar to creating a ReplicaSet for each member to provide them with indi-\nvidual storage, as described previously. Combining these two techniques results in the\nsetup shown in figure 10.4 (an additional service covering all the cluster members is\nalso shown, because you usually need one for clients of the cluster).\nThe solution is not only ugly, but it still doesn\u2019t solve everything. The individual pods\ncan\u2019t know which Service they are exposed through (and thus can\u2019t know their stable\nIP), so they can\u2019t self-register in other pods using that IP. \nPVC A1\nPV A1\nReplicaSet A1\nPod A1-xzy\nService A1\nService A\nPVC A2\nPV A2\nReplicaSet A2\nPod A2-xzy\nService A2\nPVC A3\nPV A3\nReplicaSet A3\nPod A3-zyx\nService A3\nFigure 10.4\nUsing one \nService and ReplicaSet per \npod to provide a stable \nnetwork address and an \nindividual volume for each \npod, respectively\n \n", "shape": "dot", "size": 10, "title": "283\nReplicating stateful pods\nnew ones. When a ReplicaSet replaces a pod, the new pod is a completely new pod\nwith a new hostname and IP, although the data in its storage volume may be that of\nthe killed pod. For certain apps, starting up with the old instance\u2019s data but with a\ncompletely new network identity may cause problems.\n Why do certain apps mandate a stable network identity? This requirement is\nfairly common in distributed stateful applications. Certain apps require the adminis-\ntrator to list all the other cluster members and their IP addresses (or hostnames) in\neach member\u2019s configuration file. But in Kubernetes, every time a pod is resched-\nuled, the new pod gets both a new hostname and a new IP address, so the whole\napplication cluster would have to be reconfigured every time one of its members is\nrescheduled. \nUSING A DEDICATED SERVICE FOR EACH POD INSTANCE\nA trick you can use to work around this problem is to provide a stable network address\nfor cluster members by creating a dedicated Kubernetes Service for each individual\nmember. Because service IPs are stable, you can then point to each member through\nits service IP (rather than the pod IP) in the configuration. \n This is similar to creating a ReplicaSet for each member to provide them with indi-\nvidual storage, as described previously. Combining these two techniques results in the\nsetup shown in figure 10.4 (an additional service covering all the cluster members is\nalso shown, because you usually need one for clients of the cluster).\nThe solution is not only ugly, but it still doesn\u2019t solve everything. The individual pods\ncan\u2019t know which Service they are exposed through (and thus can\u2019t know their stable\nIP), so they can\u2019t self-register in other pods using that IP. \nPVC A1\nPV A1\nReplicaSet A1\nPod A1-xzy\nService A1\nService A\nPVC A2\nPV A2\nReplicaSet A2\nPod A2-xzy\nService A2\nPVC A3\nPV A3\nReplicaSet A3\nPod A3-zyx\nService A3\nFigure 10.4\nUsing one \nService and ReplicaSet per \npod to provide a stable \nnetwork address and an \nindividual volume for each \npod, respectively\n \n"}, {"color": "green", "id": "text_227", "label": "284\nCHAPTER 10\nStatefulSets: deploying replicated stateful applications\n Luckily, Kubernetes saves us from resorting to such complex solutions. The proper\nclean and simple way of running these special types of applications in Kubernetes is\nthrough a StatefulSet. \n10.2\nUnderstanding StatefulSets\nInstead of using a ReplicaSet to run these types of pods, you create a StatefulSet\nresource, which is specifically tailored to applications where instances of the applica-\ntion must be treated as non-fungible individuals, with each one having a stable name\nand state. \n10.2.1 Comparing StatefulSets with ReplicaSets\nTo understand the purpose of StatefulSets, it\u2019s best to compare them to ReplicaSets or\nReplicationControllers. But first let me explain them with a little analogy that\u2019s widely\nused in the field.\nUNDERSTANDING STATEFUL PODS WITH THE PETS VS. CATTLE ANALOGY\nYou may have already heard of the pets vs. cattle analogy. If not, let me explain it. We\ncan treat our apps either as pets or as cattle. \nNOTE\nStatefulSets were initially called PetSets. That name comes from the\npets vs. cattle analogy explained here.\nWe tend to treat our app instances as pets, where we give each instance a name and\ntake care of each instance individually. But it\u2019s usually better to treat instances as cattle\nand not pay special attention to each individual instance. This makes it easy to replace\nunhealthy instances without giving it a second thought, similar to the way a farmer\nreplaces unhealthy cattle. \n Instances of a stateless app, for example, behave much like heads of cattle. It\ndoesn\u2019t matter if an instance dies\u2014you can create a new instance and people won\u2019t\nnotice the difference. \n On the other hand, with stateful apps, an app instance is more like a pet. When a\npet dies, you can\u2019t go buy a new one and expect people not to notice. To replace a lost\npet, you need to find a new one that looks and behaves exactly like the old one. In the\ncase of apps, this means the new instance needs to have the same state and identity as\nthe old one.\nCOMPARING STATEFULSETS WITH REPLICASETS OR REPLICATIONCONTROLLERS\nPod replicas managed by a ReplicaSet or ReplicationController are much like cattle.\nBecause they\u2019re mostly stateless, they can be replaced with a completely new pod\nreplica at any time. Stateful pods require a different approach. When a stateful pod\ninstance dies (or the node it\u2019s running on fails), the pod instance needs to be resur-\nrected on another node, but the new instance needs to get the same name, network\nidentity, and state as the one it\u2019s replacing. This is what happens when the pods are\nmanaged through a StatefulSet. \n \n", "shape": "dot", "size": 10, "title": "284\nCHAPTER 10\nStatefulSets: deploying replicated stateful applications\n Luckily, Kubernetes saves us from resorting to such complex solutions. The proper\nclean and simple way of running these special types of applications in Kubernetes is\nthrough a StatefulSet. \n10.2\nUnderstanding StatefulSets\nInstead of using a ReplicaSet to run these types of pods, you create a StatefulSet\nresource, which is specifically tailored to applications where instances of the applica-\ntion must be treated as non-fungible individuals, with each one having a stable name\nand state. \n10.2.1 Comparing StatefulSets with ReplicaSets\nTo understand the purpose of StatefulSets, it\u2019s best to compare them to ReplicaSets or\nReplicationControllers. But first let me explain them with a little analogy that\u2019s widely\nused in the field.\nUNDERSTANDING STATEFUL PODS WITH THE PETS VS. CATTLE ANALOGY\nYou may have already heard of the pets vs. cattle analogy. If not, let me explain it. We\ncan treat our apps either as pets or as cattle. \nNOTE\nStatefulSets were initially called PetSets. That name comes from the\npets vs. cattle analogy explained here.\nWe tend to treat our app instances as pets, where we give each instance a name and\ntake care of each instance individually. But it\u2019s usually better to treat instances as cattle\nand not pay special attention to each individual instance. This makes it easy to replace\nunhealthy instances without giving it a second thought, similar to the way a farmer\nreplaces unhealthy cattle. \n Instances of a stateless app, for example, behave much like heads of cattle. It\ndoesn\u2019t matter if an instance dies\u2014you can create a new instance and people won\u2019t\nnotice the difference. \n On the other hand, with stateful apps, an app instance is more like a pet. When a\npet dies, you can\u2019t go buy a new one and expect people not to notice. To replace a lost\npet, you need to find a new one that looks and behaves exactly like the old one. In the\ncase of apps, this means the new instance needs to have the same state and identity as\nthe old one.\nCOMPARING STATEFULSETS WITH REPLICASETS OR REPLICATIONCONTROLLERS\nPod replicas managed by a ReplicaSet or ReplicationController are much like cattle.\nBecause they\u2019re mostly stateless, they can be replaced with a completely new pod\nreplica at any time. Stateful pods require a different approach. When a stateful pod\ninstance dies (or the node it\u2019s running on fails), the pod instance needs to be resur-\nrected on another node, but the new instance needs to get the same name, network\nidentity, and state as the one it\u2019s replacing. This is what happens when the pods are\nmanaged through a StatefulSet. \n \n"}, {"color": "green", "id": "text_228", "label": "285\nUnderstanding StatefulSets\n A StatefulSet makes sure pods are rescheduled in such a way that they retain their\nidentity and state. It also allows you to easily scale the number of pets up and down. A\nStatefulSet, like a ReplicaSet, has a desired replica count field that determines how\nmany pets you want running at that time. Similar to ReplicaSets, pods are created from\na pod template specified as part of the StatefulSet (remember the cookie-cutter anal-\nogy?). But unlike pods created by ReplicaSets, pods created by the StatefulSet aren\u2019t\nexact replicas of each other. Each can have its own set of volumes\u2014in other words,\nstorage (and thus persistent state)\u2014which differentiates it from its peers. Pet pods\nalso have a predictable (and stable) identity instead of each new pod instance getting\na completely random one. \n10.2.2 Providing a stable network identity\nEach pod created by a StatefulSet is assigned an ordinal index (zero-based), which\nis then used to derive the pod\u2019s name and hostname, and to attach stable storage to\nthe pod. The names of the pods are thus predictable, because each pod\u2019s name is\nderived from the StatefulSet\u2019s name and the ordinal index of the instance. Rather\nthan the pods having random names, they\u2019re nicely organized, as shown in the next\nfigure.\nINTRODUCING THE GOVERNING SERVICE\nBut it\u2019s not all about the pods having a predictable name and hostname. Unlike regu-\nlar pods, stateful pods sometimes need to be addressable by their hostname, whereas\nstateless pods usually don\u2019t. After all, each stateless pod is like any other. When you\nneed one, you pick any one of them. But with stateful pods, you usually want to oper-\nate on a specific pod from the group, because they differ from each other (they hold\ndifferent state, for example). \n For this reason, a StatefulSet requires you to create a corresponding governing\nheadless Service that\u2019s used to provide the actual network identity to each pod.\nThrough this Service, each pod gets its own DNS entry, so its peers and possibly other\nclients in the cluster can address the pod by its hostname. For example, if the govern-\ning Service belongs to the default namespace and is called foo, and one of the pods\nReplicaSet A\nPod A-fewrb\nPod A-jwqec\nPod A-dsfwx\nStatefulSet A\nPod A-1\nPod A-2\nPod A-0\nFigure 10.5\nPods created by a StatefulSet have predictable names (and hostnames), \nunlike those created by a ReplicaSet\n \n", "shape": "dot", "size": 10, "title": "285\nUnderstanding StatefulSets\n A StatefulSet makes sure pods are rescheduled in such a way that they retain their\nidentity and state. It also allows you to easily scale the number of pets up and down. A\nStatefulSet, like a ReplicaSet, has a desired replica count field that determines how\nmany pets you want running at that time. Similar to ReplicaSets, pods are created from\na pod template specified as part of the StatefulSet (remember the cookie-cutter anal-\nogy?). But unlike pods created by ReplicaSets, pods created by the StatefulSet aren\u2019t\nexact replicas of each other. Each can have its own set of volumes\u2014in other words,\nstorage (and thus persistent state)\u2014which differentiates it from its peers. Pet pods\nalso have a predictable (and stable) identity instead of each new pod instance getting\na completely random one. \n10.2.2 Providing a stable network identity\nEach pod created by a StatefulSet is assigned an ordinal index (zero-based), which\nis then used to derive the pod\u2019s name and hostname, and to attach stable storage to\nthe pod. The names of the pods are thus predictable, because each pod\u2019s name is\nderived from the StatefulSet\u2019s name and the ordinal index of the instance. Rather\nthan the pods having random names, they\u2019re nicely organized, as shown in the next\nfigure.\nINTRODUCING THE GOVERNING SERVICE\nBut it\u2019s not all about the pods having a predictable name and hostname. Unlike regu-\nlar pods, stateful pods sometimes need to be addressable by their hostname, whereas\nstateless pods usually don\u2019t. After all, each stateless pod is like any other. When you\nneed one, you pick any one of them. But with stateful pods, you usually want to oper-\nate on a specific pod from the group, because they differ from each other (they hold\ndifferent state, for example). \n For this reason, a StatefulSet requires you to create a corresponding governing\nheadless Service that\u2019s used to provide the actual network identity to each pod.\nThrough this Service, each pod gets its own DNS entry, so its peers and possibly other\nclients in the cluster can address the pod by its hostname. For example, if the govern-\ning Service belongs to the default namespace and is called foo, and one of the pods\nReplicaSet A\nPod A-fewrb\nPod A-jwqec\nPod A-dsfwx\nStatefulSet A\nPod A-1\nPod A-2\nPod A-0\nFigure 10.5\nPods created by a StatefulSet have predictable names (and hostnames), \nunlike those created by a ReplicaSet\n \n"}, {"color": "green", "id": "text_229", "label": "286\nCHAPTER 10\nStatefulSets: deploying replicated stateful applications\nis called A-0, you can reach the pod through its fully qualified domain name, which\nis a-0.foo.default.svc.cluster.local. You can\u2019t do that with pods managed by a\nReplicaSet.\n Additionally, you can also use DNS to look up all the StatefulSet\u2019s pods\u2019 names by\nlooking up SRV records for the foo.default.svc.cluster.local domain. We\u2019ll\nexplain SRV records in section 10.4 and learn how they\u2019re used to discover members\nof a StatefulSet.\nREPLACING LOST PETS\nWhen a pod instance managed by a StatefulSet disappears (because the node the pod\nwas running on has failed, it was evicted from the node, or someone deleted the pod\nobject manually), the StatefulSet makes sure it\u2019s replaced with a new instance\u2014similar\nto how ReplicaSets do it. But in contrast to ReplicaSets, the replacement pod gets the\nsame name and hostname as the pod that has disappeared (this distinction between\nReplicaSets and StatefulSets is illustrated in figure 10.6).\nNode 1\nNode 2\nNode 1\nNode 2\nReplicaSet B\nReplicaSet B\nStatefulSet\nStatefulSet A\nPod A-0\nPod A-1\nPod A-0\nPod A-0\nPod A-1\nNode 1 fails\nStatefulSet A\nNode 1\nNode 2\nNode 1\nNode 2\nReplicaSet\nNode 1 fails\nPod B-fdawr\nPod B-jkbde\nPod B-fdawr\nPod B-rsqkw\nPod B-jkbde\nFigure 10.6\nA StatefulSet replaces a lost pod with a new one with the same identity, whereas a \nReplicaSet replaces it with a completely new unrelated pod.\n \n", "shape": "dot", "size": 10, "title": "286\nCHAPTER 10\nStatefulSets: deploying replicated stateful applications\nis called A-0, you can reach the pod through its fully qualified domain name, which\nis a-0.foo.default.svc.cluster.local. You can\u2019t do that with pods managed by a\nReplicaSet.\n Additionally, you can also use DNS to look up all the StatefulSet\u2019s pods\u2019 names by\nlooking up SRV records for the foo.default.svc.cluster.local domain. We\u2019ll\nexplain SRV records in section 10.4 and learn how they\u2019re used to discover members\nof a StatefulSet.\nREPLACING LOST PETS\nWhen a pod instance managed by a StatefulSet disappears (because the node the pod\nwas running on has failed, it was evicted from the node, or someone deleted the pod\nobject manually), the StatefulSet makes sure it\u2019s replaced with a new instance\u2014similar\nto how ReplicaSets do it. But in contrast to ReplicaSets, the replacement pod gets the\nsame name and hostname as the pod that has disappeared (this distinction between\nReplicaSets and StatefulSets is illustrated in figure 10.6).\nNode 1\nNode 2\nNode 1\nNode 2\nReplicaSet B\nReplicaSet B\nStatefulSet\nStatefulSet A\nPod A-0\nPod A-1\nPod A-0\nPod A-0\nPod A-1\nNode 1 fails\nStatefulSet A\nNode 1\nNode 2\nNode 1\nNode 2\nReplicaSet\nNode 1 fails\nPod B-fdawr\nPod B-jkbde\nPod B-fdawr\nPod B-rsqkw\nPod B-jkbde\nFigure 10.6\nA StatefulSet replaces a lost pod with a new one with the same identity, whereas a \nReplicaSet replaces it with a completely new unrelated pod.\n \n"}, {"color": "green", "id": "text_230", "label": "287\nUnderstanding StatefulSets\nThe new pod isn\u2019t necessarily scheduled to the same node, but as you learned early\non, what node a pod runs on shouldn\u2019t matter. This holds true even for stateful pods.\nEven if the pod is scheduled to a different node, it will still be available and reachable\nunder the same hostname as before. \nSCALING A STATEFULSET\nScaling the StatefulSet creates a new pod instance with the next unused ordinal index.\nIf you scale up from two to three instances, the new instance will get index 2 (the exist-\ning instances obviously have indexes 0 and 1). \n The nice thing about scaling down a StatefulSet is the fact that you always know\nwhat pod will be removed. Again, this is also in contrast to scaling down a ReplicaSet,\nwhere you have no idea what instance will be deleted, and you can\u2019t even specify\nwhich one you want removed first (but this feature may be introduced in the future).\nScaling down a StatefulSet always removes the instances with the highest ordinal index\nfirst (shown in figure 10.7). This makes the effects of a scale-down predictable.\nBecause certain stateful applications don\u2019t handle rapid scale-downs nicely, Stateful-\nSets scale down only one pod instance at a time. A distributed data store, for example,\nmay lose data if multiple nodes go down at the same time. For example, if a replicated\ndata store is configured to store two copies of each data entry, in cases where two\nnodes go down at the same time, a data entry would be lost if it was stored on exactly\nthose two nodes. If the scale-down was sequential, the distributed data store has time\nto create an additional replica of the data entry somewhere else to replace the (single)\nlost copy.\n For this exact reason, StatefulSets also never permit scale-down operations if any of\nthe instances are unhealthy. If an instance is unhealthy, and you scale down by one at\nthe same time, you\u2019ve effectively lost two cluster members at once.\n10.2.3 Providing stable dedicated storage to each stateful instance\nYou\u2019ve seen how StatefulSets ensure stateful pods have a stable identity, but what\nabout storage? Each stateful pod instance needs to use its own storage, plus if a state-\nful pod is rescheduled (replaced with a new instance but with the same identity as\nbefore), the new instance must have the same storage attached to it. How do Stateful-\nSets achieve this?\nPod\nA-0\nPod\nA-1\nPod\nA-2\nStatefulSet A\nReplicas: 3\nPod\nA-0\nPod\nA-1\nPod\nA-2\nStatefulSet A\nReplicas: 2\nPod\nA-0\nPod\nA-1\nStatefulSet A\nReplicas: 1\nScale down\nScale down\nFigure 10.7\nScaling down a StatefulSet always removes the pod with the highest ordinal index first.\n \n", "shape": "dot", "size": 10, "title": "287\nUnderstanding StatefulSets\nThe new pod isn\u2019t necessarily scheduled to the same node, but as you learned early\non, what node a pod runs on shouldn\u2019t matter. This holds true even for stateful pods.\nEven if the pod is scheduled to a different node, it will still be available and reachable\nunder the same hostname as before. \nSCALING A STATEFULSET\nScaling the StatefulSet creates a new pod instance with the next unused ordinal index.\nIf you scale up from two to three instances, the new instance will get index 2 (the exist-\ning instances obviously have indexes 0 and 1). \n The nice thing about scaling down a StatefulSet is the fact that you always know\nwhat pod will be removed. Again, this is also in contrast to scaling down a ReplicaSet,\nwhere you have no idea what instance will be deleted, and you can\u2019t even specify\nwhich one you want removed first (but this feature may be introduced in the future).\nScaling down a StatefulSet always removes the instances with the highest ordinal index\nfirst (shown in figure 10.7). This makes the effects of a scale-down predictable.\nBecause certain stateful applications don\u2019t handle rapid scale-downs nicely, Stateful-\nSets scale down only one pod instance at a time. A distributed data store, for example,\nmay lose data if multiple nodes go down at the same time. For example, if a replicated\ndata store is configured to store two copies of each data entry, in cases where two\nnodes go down at the same time, a data entry would be lost if it was stored on exactly\nthose two nodes. If the scale-down was sequential, the distributed data store has time\nto create an additional replica of the data entry somewhere else to replace the (single)\nlost copy.\n For this exact reason, StatefulSets also never permit scale-down operations if any of\nthe instances are unhealthy. If an instance is unhealthy, and you scale down by one at\nthe same time, you\u2019ve effectively lost two cluster members at once.\n10.2.3 Providing stable dedicated storage to each stateful instance\nYou\u2019ve seen how StatefulSets ensure stateful pods have a stable identity, but what\nabout storage? Each stateful pod instance needs to use its own storage, plus if a state-\nful pod is rescheduled (replaced with a new instance but with the same identity as\nbefore), the new instance must have the same storage attached to it. How do Stateful-\nSets achieve this?\nPod\nA-0\nPod\nA-1\nPod\nA-2\nStatefulSet A\nReplicas: 3\nPod\nA-0\nPod\nA-1\nPod\nA-2\nStatefulSet A\nReplicas: 2\nPod\nA-0\nPod\nA-1\nStatefulSet A\nReplicas: 1\nScale down\nScale down\nFigure 10.7\nScaling down a StatefulSet always removes the pod with the highest ordinal index first.\n \n"}, {"color": "green", "id": "text_231", "label": "288\nCHAPTER 10\nStatefulSets: deploying replicated stateful applications\n Obviously, storage for stateful pods needs to be persistent and decoupled from\nthe pods. In chapter 6 you learned about PersistentVolumes and PersistentVolume-\nClaims, which allow persistent storage to be attached to a pod by referencing the\nPersistentVolumeClaim in the pod by name. Because PersistentVolumeClaims map\nto PersistentVolumes one-to-one, each pod of a StatefulSet needs to reference a dif-\nferent PersistentVolumeClaim to have its own separate PersistentVolume. Because\nall pod instances are stamped from the same pod template, how can they each refer\nto a different PersistentVolumeClaim? And who creates these claims? Surely you\u2019re\nnot expected to create as many PersistentVolumeClaims as the number of pods you\nplan to have in the StatefulSet upfront? Of course not.\nTEAMING UP POD TEMPLATES WITH VOLUME CLAIM TEMPLATES\nThe StatefulSet has to create the PersistentVolumeClaims as well, the same way it\u2019s cre-\nating the pods. For this reason, a StatefulSet can also have one or more volume claim\ntemplates, which enable it to stamp out PersistentVolumeClaims along with each pod\ninstance (see figure 10.8).\nThe PersistentVolumes for the claims can either be provisioned up-front by an admin-\nistrator or just in time through dynamic provisioning of PersistentVolumes, as explained\nat the end of chapter 6. \nUNDERSTANDING THE CREATION AND DELETION OF PERSISTENTVOLUMECLAIMS\nScaling up a StatefulSet by one creates two or more API objects (the pod and one or\nmore PersistentVolumeClaims referenced by the pod). Scaling down, however, deletes\nonly the pod, leaving the claims alone. The reason for this is obvious, if you consider\nwhat happens when a claim is deleted. After a claim is deleted, the PersistentVolume it\nwas bound to gets recycled or deleted and its contents are lost. \n Because stateful pods are meant to run stateful applications, which implies that the\ndata they store in the volume is important, deleting the claim on scale-down of a Stateful-\nSet could be catastrophic\u2014especially since triggering a scale-down is as simple as\ndecreasing the replicas field of the StatefulSet. For this reason, you\u2019re required to\ndelete PersistentVolumeClaims manually to release the underlying PersistentVolume.\nPVC A-0\nPV\nPod A-0\nPVC A-1\nPV\nPod A-1\nPVC A-2\nPV\nPod A-2\nStatefulSet A\nPod\ntemplate\nVolume claim\ntemplate\nFigure 10.8\nA StatefulSet creates both pods and PersistentVolumeClaims.\n \n", "shape": "dot", "size": 10, "title": "288\nCHAPTER 10\nStatefulSets: deploying replicated stateful applications\n Obviously, storage for stateful pods needs to be persistent and decoupled from\nthe pods. In chapter 6 you learned about PersistentVolumes and PersistentVolume-\nClaims, which allow persistent storage to be attached to a pod by referencing the\nPersistentVolumeClaim in the pod by name. Because PersistentVolumeClaims map\nto PersistentVolumes one-to-one, each pod of a StatefulSet needs to reference a dif-\nferent PersistentVolumeClaim to have its own separate PersistentVolume. Because\nall pod instances are stamped from the same pod template, how can they each refer\nto a different PersistentVolumeClaim? And who creates these claims? Surely you\u2019re\nnot expected to create as many PersistentVolumeClaims as the number of pods you\nplan to have in the StatefulSet upfront? Of course not.\nTEAMING UP POD TEMPLATES WITH VOLUME CLAIM TEMPLATES\nThe StatefulSet has to create the PersistentVolumeClaims as well, the same way it\u2019s cre-\nating the pods. For this reason, a StatefulSet can also have one or more volume claim\ntemplates, which enable it to stamp out PersistentVolumeClaims along with each pod\ninstance (see figure 10.8).\nThe PersistentVolumes for the claims can either be provisioned up-front by an admin-\nistrator or just in time through dynamic provisioning of PersistentVolumes, as explained\nat the end of chapter 6. \nUNDERSTANDING THE CREATION AND DELETION OF PERSISTENTVOLUMECLAIMS\nScaling up a StatefulSet by one creates two or more API objects (the pod and one or\nmore PersistentVolumeClaims referenced by the pod). Scaling down, however, deletes\nonly the pod, leaving the claims alone. The reason for this is obvious, if you consider\nwhat happens when a claim is deleted. After a claim is deleted, the PersistentVolume it\nwas bound to gets recycled or deleted and its contents are lost. \n Because stateful pods are meant to run stateful applications, which implies that the\ndata they store in the volume is important, deleting the claim on scale-down of a Stateful-\nSet could be catastrophic\u2014especially since triggering a scale-down is as simple as\ndecreasing the replicas field of the StatefulSet. For this reason, you\u2019re required to\ndelete PersistentVolumeClaims manually to release the underlying PersistentVolume.\nPVC A-0\nPV\nPod A-0\nPVC A-1\nPV\nPod A-1\nPVC A-2\nPV\nPod A-2\nStatefulSet A\nPod\ntemplate\nVolume claim\ntemplate\nFigure 10.8\nA StatefulSet creates both pods and PersistentVolumeClaims.\n \n"}, {"color": "green", "id": "text_232", "label": "289\nUnderstanding StatefulSets\nREATTACHING THE PERSISTENTVOLUMECLAIM TO THE NEW INSTANCE OF THE SAME POD\nThe fact that the PersistentVolumeClaim remains after a scale-down means a subse-\nquent scale-up can reattach the same claim along with the bound PersistentVolume\nand its contents to the new pod instance (shown in figure 10.9). If you accidentally\nscale down a StatefulSet, you can undo the mistake by scaling up again and the new\npod will get the same persisted state again (as well as the same name).\n10.2.4 Understanding StatefulSet guarantees\nAs you\u2019ve seen so far, StatefulSets behave differently from ReplicaSets or Replication-\nControllers. But this doesn\u2019t end with the pods having a stable identity and storage.\nStatefulSets also have different guarantees regarding their pods. \nUNDERSTANDING THE IMPLICATIONS OF STABLE IDENTITY AND STORAGE\nWhile regular, stateless pods are fungible, stateful pods aren\u2019t. We\u2019ve already seen how\na stateful pod is always replaced with an identical pod (one having the same name and\nhostname, using the same persistent storage, and so on). This happens when Kuber-\nnetes sees that the old pod is no longer there (for example, when you delete the pod\nmanually). \n But what if Kubernetes can\u2019t be sure about the state of the pod? If it creates a\nreplacement pod with the same identity, two instances of the app with the same iden-\ntity might be running in the system. The two would also be bound to the same storage,\nPod\nA-0\nPod\nA-1\nStatefulSet A\nReplicas: 2\nScale\ndown\nScale\nup\nNew pod instance created\nwith same identity as before\nPVC is\nre-attached\nPVC\nA-0\nPV\nPVC\nA-1\nPV\nPod\nA-0\nStatefulSet A\nReplicas: 1\nPVC\nA-0\nPV\nPVC\nA-1\nPV\nPod\nA-0\nPod has been deleted\nPod\nA-1\nStatefulSet A\nReplicas: 2\nPVC\nA-0\nPV\nPVC\nA-1\nPVC has not\nbeen deleted\nPV\nFigure 10.9\nStatefulSets don\u2019t delete PersistentVolumeClaims when scaling down; then they \nreattach them when scaling back up.\n \n", "shape": "dot", "size": 10, "title": "289\nUnderstanding StatefulSets\nREATTACHING THE PERSISTENTVOLUMECLAIM TO THE NEW INSTANCE OF THE SAME POD\nThe fact that the PersistentVolumeClaim remains after a scale-down means a subse-\nquent scale-up can reattach the same claim along with the bound PersistentVolume\nand its contents to the new pod instance (shown in figure 10.9). If you accidentally\nscale down a StatefulSet, you can undo the mistake by scaling up again and the new\npod will get the same persisted state again (as well as the same name).\n10.2.4 Understanding StatefulSet guarantees\nAs you\u2019ve seen so far, StatefulSets behave differently from ReplicaSets or Replication-\nControllers. But this doesn\u2019t end with the pods having a stable identity and storage.\nStatefulSets also have different guarantees regarding their pods. \nUNDERSTANDING THE IMPLICATIONS OF STABLE IDENTITY AND STORAGE\nWhile regular, stateless pods are fungible, stateful pods aren\u2019t. We\u2019ve already seen how\na stateful pod is always replaced with an identical pod (one having the same name and\nhostname, using the same persistent storage, and so on). This happens when Kuber-\nnetes sees that the old pod is no longer there (for example, when you delete the pod\nmanually). \n But what if Kubernetes can\u2019t be sure about the state of the pod? If it creates a\nreplacement pod with the same identity, two instances of the app with the same iden-\ntity might be running in the system. The two would also be bound to the same storage,\nPod\nA-0\nPod\nA-1\nStatefulSet A\nReplicas: 2\nScale\ndown\nScale\nup\nNew pod instance created\nwith same identity as before\nPVC is\nre-attached\nPVC\nA-0\nPV\nPVC\nA-1\nPV\nPod\nA-0\nStatefulSet A\nReplicas: 1\nPVC\nA-0\nPV\nPVC\nA-1\nPV\nPod\nA-0\nPod has been deleted\nPod\nA-1\nStatefulSet A\nReplicas: 2\nPVC\nA-0\nPV\nPVC\nA-1\nPVC has not\nbeen deleted\nPV\nFigure 10.9\nStatefulSets don\u2019t delete PersistentVolumeClaims when scaling down; then they \nreattach them when scaling back up.\n \n"}, {"color": "green", "id": "text_233", "label": "290\nCHAPTER 10\nStatefulSets: deploying replicated stateful applications\nso two processes with the same identity would be writing over the same files. With pods\nmanaged by a ReplicaSet, this isn\u2019t a problem, because the apps are obviously made to\nwork on the same files. Also, ReplicaSets create pods with a randomly generated iden-\ntity, so there\u2019s no way for two processes to run with the same identity. \nINTRODUCING STATEFULSET\u2019S AT-MOST-ONE SEMANTICS\nKubernetes must thus take great care to ensure two stateful pod instances are never\nrunning with the same identity and are bound to the same PersistentVolumeClaim. A\nStatefulSet must guarantee at-most-one semantics for stateful pod instances. \n This means a StatefulSet must be absolutely certain that a pod is no longer run-\nning before it can create a replacement pod. This has a big effect on how node fail-\nures are handled. We\u2019ll demonstrate this later in the chapter. Before we can do that,\nhowever, you need to create a StatefulSet and see how it behaves. You\u2019ll also learn a\nfew more things about them along the way.\n10.3\nUsing a StatefulSet\nTo properly show StatefulSets in action, you\u2019ll build your own little clustered data\nstore. Nothing fancy\u2014more like a data store from the Stone Age. \n10.3.1 Creating the app and container image\nYou\u2019ll use the kubia app you\u2019ve used throughout the book as your starting point. You\u2019ll\nexpand it so it allows you to store and retrieve a single data entry on each pod instance. \n The important parts of the source code of your data store are shown in the follow-\ning listing.\n...\nconst dataFile = \"/var/data/kubia.txt\";\n...\nvar handler = function(request, response) {\n  if (request.method == \u0027POST\u0027) {                \n    var file = fs.createWriteStream(dataFile);                     \n    file.on(\u0027open\u0027, function (fd) {                                \n      request.pipe(file);                                          \n      console.log(\"New data has been received and stored.\");       \n      response.writeHead(200);                                     \n      response.end(\"Data stored on pod \" + os.hostname() + \"\\n\");  \n    });\n  } else {                                       \n    var data = fileExists(dataFile)                                \n      ? fs.readFileSync(dataFile, \u0027utf8\u0027)                          \n      : \"No data posted yet\";                                      \n    response.writeHead(200);                                       \n    response.write(\"You\u0027ve hit \" + os.hostname() + \"\\n\");          \n    response.end(\"Data stored on this pod: \" + data + \"\\n\");       \n  }\n};\nListing 10.1\nA simple stateful app: kubia-pet-image/app.js\nOn POST \nrequests, store \nthe request\u2019s \nbody into a \ndata file.\nOn GET (and all \nother types of) \nrequests, return \nyour hostname \nand the contents \nof the data file.\n \n", "shape": "dot", "size": 10, "title": "290\nCHAPTER 10\nStatefulSets: deploying replicated stateful applications\nso two processes with the same identity would be writing over the same files. With pods\nmanaged by a ReplicaSet, this isn\u2019t a problem, because the apps are obviously made to\nwork on the same files. Also, ReplicaSets create pods with a randomly generated iden-\ntity, so there\u2019s no way for two processes to run with the same identity. \nINTRODUCING STATEFULSET\u2019S AT-MOST-ONE SEMANTICS\nKubernetes must thus take great care to ensure two stateful pod instances are never\nrunning with the same identity and are bound to the same PersistentVolumeClaim. A\nStatefulSet must guarantee at-most-one semantics for stateful pod instances. \n This means a StatefulSet must be absolutely certain that a pod is no longer run-\nning before it can create a replacement pod. This has a big effect on how node fail-\nures are handled. We\u2019ll demonstrate this later in the chapter. Before we can do that,\nhowever, you need to create a StatefulSet and see how it behaves. You\u2019ll also learn a\nfew more things about them along the way.\n10.3\nUsing a StatefulSet\nTo properly show StatefulSets in action, you\u2019ll build your own little clustered data\nstore. Nothing fancy\u2014more like a data store from the Stone Age. \n10.3.1 Creating the app and container image\nYou\u2019ll use the kubia app you\u2019ve used throughout the book as your starting point. You\u2019ll\nexpand it so it allows you to store and retrieve a single data entry on each pod instance. \n The important parts of the source code of your data store are shown in the follow-\ning listing.\n...\nconst dataFile = \"/var/data/kubia.txt\";\n...\nvar handler = function(request, response) {\n  if (request.method == \u0027POST\u0027) {                \n    var file = fs.createWriteStream(dataFile);                     \n    file.on(\u0027open\u0027, function (fd) {                                \n      request.pipe(file);                                          \n      console.log(\"New data has been received and stored.\");       \n      response.writeHead(200);                                     \n      response.end(\"Data stored on pod \" + os.hostname() + \"\\n\");  \n    });\n  } else {                                       \n    var data = fileExists(dataFile)                                \n      ? fs.readFileSync(dataFile, \u0027utf8\u0027)                          \n      : \"No data posted yet\";                                      \n    response.writeHead(200);                                       \n    response.write(\"You\u0027ve hit \" + os.hostname() + \"\\n\");          \n    response.end(\"Data stored on this pod: \" + data + \"\\n\");       \n  }\n};\nListing 10.1\nA simple stateful app: kubia-pet-image/app.js\nOn POST \nrequests, store \nthe request\u2019s \nbody into a \ndata file.\nOn GET (and all \nother types of) \nrequests, return \nyour hostname \nand the contents \nof the data file.\n \n"}, {"color": "green", "id": "text_234", "label": "291\nUsing a StatefulSet\nvar www = http.createServer(handler);\nwww.listen(8080);\nWhenever the app receives a POST request, it writes the data it receives in the body of\nthe request to the file /var/data/kubia.txt. Upon a GET request, it returns the host-\nname and the stored data (contents of the file). Simple enough, right? This is the first\nversion of your app. It\u2019s not clustered yet, but it\u2019s enough to get you started. You\u2019ll\nexpand the app later in the chapter.\n The Dockerfile for building the container image is shown in the following listing\nand hasn\u2019t changed from before.\nFROM node:7\nADD app.js /app.js\nENTRYPOINT [\"node\", \"app.js\"]\nGo ahead and build the image now, or use the one I pushed to docker.io/luksa/kubia-pet.\n10.3.2 Deploying the app through a StatefulSet\nTo deploy your app, you\u2019ll need to create two (or three) different types of objects:\n\uf0a1PersistentVolumes for storing your data files (you\u2019ll need to create these only if\nthe cluster doesn\u2019t support dynamic provisioning of PersistentVolumes).\n\uf0a1A governing Service required by the StatefulSet.\n\uf0a1The StatefulSet itself.\nFor each pod instance, the StatefulSet will create a PersistentVolumeClaim that will\nbind to a PersistentVolume. If your cluster supports dynamic provisioning, you don\u2019t\nneed to create any PersistentVolumes manually (you can skip the next section). If it\ndoesn\u2019t, you\u2019ll need to create them as explained in the next section. \nCREATING THE PERSISTENT VOLUMES\nYou\u2019ll need three PersistentVolumes, because you\u2019ll be scaling the StatefulSet up to\nthree replicas. You must create more if you plan on scaling the StatefulSet up more\nthan that.\n If you\u2019re using Minikube, deploy the PersistentVolumes defined in the Chapter06/\npersistent-volumes-hostpath.yaml file in the book\u2019s code archive. \n If you\u2019re using Google Kubernetes Engine, you\u2019ll first need to create the actual\nGCE Persistent Disks like this:\n$ gcloud compute disks create --size=1GiB --zone=europe-west1-b pv-a\n$ gcloud compute disks create --size=1GiB --zone=europe-west1-b pv-b\n$ gcloud compute disks create --size=1GiB --zone=europe-west1-b pv-c\nNOTE\nMake sure to create the disks in the same zone that your nodes are\nrunning in.\nListing 10.2\nDockerfile for the stateful app: kubia-pet-image/Dockerfile\n \n", "shape": "dot", "size": 10, "title": "291\nUsing a StatefulSet\nvar www = http.createServer(handler);\nwww.listen(8080);\nWhenever the app receives a POST request, it writes the data it receives in the body of\nthe request to the file /var/data/kubia.txt. Upon a GET request, it returns the host-\nname and the stored data (contents of the file). Simple enough, right? This is the first\nversion of your app. It\u2019s not clustered yet, but it\u2019s enough to get you started. You\u2019ll\nexpand the app later in the chapter.\n The Dockerfile for building the container image is shown in the following listing\nand hasn\u2019t changed from before.\nFROM node:7\nADD app.js /app.js\nENTRYPOINT [\"node\", \"app.js\"]\nGo ahead and build the image now, or use the one I pushed to docker.io/luksa/kubia-pet.\n10.3.2 Deploying the app through a StatefulSet\nTo deploy your app, you\u2019ll need to create two (or three) different types of objects:\n\uf0a1PersistentVolumes for storing your data files (you\u2019ll need to create these only if\nthe cluster doesn\u2019t support dynamic provisioning of PersistentVolumes).\n\uf0a1A governing Service required by the StatefulSet.\n\uf0a1The StatefulSet itself.\nFor each pod instance, the StatefulSet will create a PersistentVolumeClaim that will\nbind to a PersistentVolume. If your cluster supports dynamic provisioning, you don\u2019t\nneed to create any PersistentVolumes manually (you can skip the next section). If it\ndoesn\u2019t, you\u2019ll need to create them as explained in the next section. \nCREATING THE PERSISTENT VOLUMES\nYou\u2019ll need three PersistentVolumes, because you\u2019ll be scaling the StatefulSet up to\nthree replicas. You must create more if you plan on scaling the StatefulSet up more\nthan that.\n If you\u2019re using Minikube, deploy the PersistentVolumes defined in the Chapter06/\npersistent-volumes-hostpath.yaml file in the book\u2019s code archive. \n If you\u2019re using Google Kubernetes Engine, you\u2019ll first need to create the actual\nGCE Persistent Disks like this:\n$ gcloud compute disks create --size=1GiB --zone=europe-west1-b pv-a\n$ gcloud compute disks create --size=1GiB --zone=europe-west1-b pv-b\n$ gcloud compute disks create --size=1GiB --zone=europe-west1-b pv-c\nNOTE\nMake sure to create the disks in the same zone that your nodes are\nrunning in.\nListing 10.2\nDockerfile for the stateful app: kubia-pet-image/Dockerfile\n \n"}, {"color": "green", "id": "text_235", "label": "292\nCHAPTER 10\nStatefulSets: deploying replicated stateful applications\nThen create the PersistentVolumes from the persistent-volumes-gcepd.yaml file,\nwhich is shown in the following listing.\nkind: List                     \napiVersion: v1\nitems:\n- apiVersion: v1\n  kind: PersistentVolume       \n  metadata:\n    name: pv-a                \n  spec:\n    capacity:\n      storage: 1Mi            \n    accessModes:\n      - ReadWriteOnce\n    persistentVolumeReclaimPolicy: Recycle     \n    gcePersistentDisk:         \n      pdName: pv-a             \n      fsType: nfs4                         \n- apiVersion: v1\n  kind: PersistentVolume\n  metadata:\n    name: pv-b\n ...\nNOTE\nIn the previous chapter you specified multiple resources in the same\nYAML by delimiting them with a three-dash line. Here you\u2019re using a differ-\nent approach by defining a List object and listing the resources as items of\nthe object. Both methods are equivalent.\nThis manifest creates PersistentVolumes called pv-a, pv-b, and pv-c. They use GCE Per-\nsistent Disks as the underlying storage mechanism, so they\u2019re not appropriate for clus-\nters that aren\u2019t running on Google Kubernetes Engine or Google Compute Engine. If\nyou\u2019re running the cluster elsewhere, you must modify the PersistentVolume definition\nand use an appropriate volume type, such as NFS (Network File System), or similar.\nCREATING THE GOVERNING SERVICE\nAs explained earlier, before deploying a StatefulSet, you first need to create a headless\nService, which will be used to provide the network identity for your stateful pods. The\nfollowing listing shows the Service manifest.\napiVersion: v1\nkind: Service\nmetadata:\n  name: kubia       \nspec:\n  clusterIP: None    \nListing 10.3\nThree PersistentVolumes: persistent-volumes-gcepd.yaml\nListing 10.4\nHeadless service to be used in the StatefulSet: kubia-service-headless.yaml\nFile describes a list \nof three persistent \nvolumes\nPersistent volumes\u2019 names \nare pv-a, pv-b, and pv-c\nCapacity of each persistent \nvolume is 1 Mebibyte\nWhen the volume \nis released by the \nclaim, it\u2019s recycled \nto be used again.\nThe volume uses a GCE \nPersistent Disk as the underlying \nstorage mechanism.\nName of the \nService\nThe StatefulSet\u2019s governing \nService must be headless.\n \n", "shape": "dot", "size": 10, "title": "292\nCHAPTER 10\nStatefulSets: deploying replicated stateful applications\nThen create the PersistentVolumes from the persistent-volumes-gcepd.yaml file,\nwhich is shown in the following listing.\nkind: List                     \napiVersion: v1\nitems:\n- apiVersion: v1\n  kind: PersistentVolume       \n  metadata:\n    name: pv-a                \n  spec:\n    capacity:\n      storage: 1Mi            \n    accessModes:\n      - ReadWriteOnce\n    persistentVolumeReclaimPolicy: Recycle     \n    gcePersistentDisk:         \n      pdName: pv-a             \n      fsType: nfs4                         \n- apiVersion: v1\n  kind: PersistentVolume\n  metadata:\n    name: pv-b\n ...\nNOTE\nIn the previous chapter you specified multiple resources in the same\nYAML by delimiting them with a three-dash line. Here you\u2019re using a differ-\nent approach by defining a List object and listing the resources as items of\nthe object. Both methods are equivalent.\nThis manifest creates PersistentVolumes called pv-a, pv-b, and pv-c. They use GCE Per-\nsistent Disks as the underlying storage mechanism, so they\u2019re not appropriate for clus-\nters that aren\u2019t running on Google Kubernetes Engine or Google Compute Engine. If\nyou\u2019re running the cluster elsewhere, you must modify the PersistentVolume definition\nand use an appropriate volume type, such as NFS (Network File System), or similar.\nCREATING THE GOVERNING SERVICE\nAs explained earlier, before deploying a StatefulSet, you first need to create a headless\nService, which will be used to provide the network identity for your stateful pods. The\nfollowing listing shows the Service manifest.\napiVersion: v1\nkind: Service\nmetadata:\n  name: kubia       \nspec:\n  clusterIP: None    \nListing 10.3\nThree PersistentVolumes: persistent-volumes-gcepd.yaml\nListing 10.4\nHeadless service to be used in the StatefulSet: kubia-service-headless.yaml\nFile describes a list \nof three persistent \nvolumes\nPersistent volumes\u2019 names \nare pv-a, pv-b, and pv-c\nCapacity of each persistent \nvolume is 1 Mebibyte\nWhen the volume \nis released by the \nclaim, it\u2019s recycled \nto be used again.\nThe volume uses a GCE \nPersistent Disk as the underlying \nstorage mechanism.\nName of the \nService\nThe StatefulSet\u2019s governing \nService must be headless.\n \n"}, {"color": "green", "id": "text_236", "label": "293\nUsing a StatefulSet\n  selector:           \n    app: kubia        \n  ports:\n  - name: http\n    port: 80\nYou\u2019re setting the clusterIP field to None, which makes this a headless Service. It will\nenable peer discovery between your pods (you\u2019ll need this later). Once you create the\nService, you can move on to creating the actual StatefulSet.\nCREATING THE STATEFULSET MANIFEST\nNow you can finally create the StatefulSet. The following listing shows the manifest.\napiVersion: apps/v1beta1\nkind: StatefulSet\nmetadata:\n  name: kubia\nspec:\n  serviceName: kubia\n  replicas: 2\n  template:\n    metadata:\n      labels:                  \n        app: kubia             \n    spec:\n      containers:\n      - name: kubia\n        image: luksa/kubia-pet\n        ports:\n        - name: http\n          containerPort: 8080\n        volumeMounts:\n        - name: data                  \n          mountPath: /var/data        \n  volumeClaimTemplates:\n  - metadata:                  \n      name: data               \n    spec:                      \n      resources:               \n        requests:              \n          storage: 1Mi         \n      accessModes:             \n      - ReadWriteOnce          \nThe StatefulSet manifest isn\u2019t that different from ReplicaSet or Deployment manifests\nyou\u2019ve created so far. What\u2019s new is the volumeClaimTemplates list. In it, you\u2019re defin-\ning one volume claim template called data, which will be used to create a Persistent-\nVolumeClaim for each pod. As you may remember from chapter 6, a pod references a\nclaim by including a persistentVolumeClaim volume in the manifest. In the previous\nListing 10.5\nStatefulSet manifest: kubia-statefulset.yaml\nAll pods with the app=kubia \nlabel belong to this service.\nPods created by the StatefulSet \nwill have the app=kubia label.\nThe container inside the pod will \nmount the pvc volume at this path.\nThe PersistentVolumeClaims \nwill be created from this \ntemplate.\n \n", "shape": "dot", "size": 10, "title": "293\nUsing a StatefulSet\n  selector:           \n    app: kubia        \n  ports:\n  - name: http\n    port: 80\nYou\u2019re setting the clusterIP field to None, which makes this a headless Service. It will\nenable peer discovery between your pods (you\u2019ll need this later). Once you create the\nService, you can move on to creating the actual StatefulSet.\nCREATING THE STATEFULSET MANIFEST\nNow you can finally create the StatefulSet. The following listing shows the manifest.\napiVersion: apps/v1beta1\nkind: StatefulSet\nmetadata:\n  name: kubia\nspec:\n  serviceName: kubia\n  replicas: 2\n  template:\n    metadata:\n      labels:                  \n        app: kubia             \n    spec:\n      containers:\n      - name: kubia\n        image: luksa/kubia-pet\n        ports:\n        - name: http\n          containerPort: 8080\n        volumeMounts:\n        - name: data                  \n          mountPath: /var/data        \n  volumeClaimTemplates:\n  - metadata:                  \n      name: data               \n    spec:                      \n      resources:               \n        requests:              \n          storage: 1Mi         \n      accessModes:             \n      - ReadWriteOnce          \nThe StatefulSet manifest isn\u2019t that different from ReplicaSet or Deployment manifests\nyou\u2019ve created so far. What\u2019s new is the volumeClaimTemplates list. In it, you\u2019re defin-\ning one volume claim template called data, which will be used to create a Persistent-\nVolumeClaim for each pod. As you may remember from chapter 6, a pod references a\nclaim by including a persistentVolumeClaim volume in the manifest. In the previous\nListing 10.5\nStatefulSet manifest: kubia-statefulset.yaml\nAll pods with the app=kubia \nlabel belong to this service.\nPods created by the StatefulSet \nwill have the app=kubia label.\nThe container inside the pod will \nmount the pvc volume at this path.\nThe PersistentVolumeClaims \nwill be created from this \ntemplate.\n \n"}, {"color": "green", "id": "text_237", "label": "294\nCHAPTER 10\nStatefulSets: deploying replicated stateful applications\npod template, you\u2019ll find no such volume. The StatefulSet adds it to the pod specifica-\ntion automatically and configures the volume to be bound to the claim the StatefulSet\ncreated for the specific pod.\nCREATING THE STATEFULSET\nYou\u2019ll create the StatefulSet now:\n$ kubectl create -f kubia-statefulset.yaml \nstatefulset \"kubia\" created\nNow, list your pods:\n$ kubectl get po\nNAME      READY     STATUS              RESTARTS   AGE\nkubia-0   0/1       ContainerCreating   0          1s\nNotice anything strange? Remember how a ReplicationController or a ReplicaSet cre-\nates all the pod instances at the same time? Your StatefulSet is configured to create\ntwo replicas, but it created a single pod. \n Don\u2019t worry, nothing is wrong. The second pod will be created only after the first\none is up and ready. StatefulSets behave this way because certain clustered stateful\napps are sensitive to race conditions if two or more cluster members come up at the\nsame time, so it\u2019s safer to bring each member up fully before continuing to bring up\nthe rest.\n List the pods again to see how the pod creation is progressing:\n$ kubectl get po\nNAME      READY     STATUS              RESTARTS   AGE\nkubia-0   1/1       Running             0          8s\nkubia-1   0/1       ContainerCreating   0          2s\nSee, the first pod is now running, and the second one has been created and is being\nstarted. \nEXAMINING THE GENERATED STATEFUL POD\nLet\u2019s take a closer look at the first pod\u2019s spec in the following listing to see how the\nStatefulSet has constructed the pod from the pod template and the PersistentVolume-\nClaim template.\n$ kubectl get po kubia-0 -o yaml\napiVersion: v1\nkind: Pod\nmetadata:\n  ...\nspec:\n  containers:\n  - image: luksa/kubia-pet\n    ...\nListing 10.6\nA stateful pod created by the StatefulSet\n \n", "shape": "dot", "size": 10, "title": "294\nCHAPTER 10\nStatefulSets: deploying replicated stateful applications\npod template, you\u2019ll find no such volume. The StatefulSet adds it to the pod specifica-\ntion automatically and configures the volume to be bound to the claim the StatefulSet\ncreated for the specific pod.\nCREATING THE STATEFULSET\nYou\u2019ll create the StatefulSet now:\n$ kubectl create -f kubia-statefulset.yaml \nstatefulset \"kubia\" created\nNow, list your pods:\n$ kubectl get po\nNAME      READY     STATUS              RESTARTS   AGE\nkubia-0   0/1       ContainerCreating   0          1s\nNotice anything strange? Remember how a ReplicationController or a ReplicaSet cre-\nates all the pod instances at the same time? Your StatefulSet is configured to create\ntwo replicas, but it created a single pod. \n Don\u2019t worry, nothing is wrong. The second pod will be created only after the first\none is up and ready. StatefulSets behave this way because certain clustered stateful\napps are sensitive to race conditions if two or more cluster members come up at the\nsame time, so it\u2019s safer to bring each member up fully before continuing to bring up\nthe rest.\n List the pods again to see how the pod creation is progressing:\n$ kubectl get po\nNAME      READY     STATUS              RESTARTS   AGE\nkubia-0   1/1       Running             0          8s\nkubia-1   0/1       ContainerCreating   0          2s\nSee, the first pod is now running, and the second one has been created and is being\nstarted. \nEXAMINING THE GENERATED STATEFUL POD\nLet\u2019s take a closer look at the first pod\u2019s spec in the following listing to see how the\nStatefulSet has constructed the pod from the pod template and the PersistentVolume-\nClaim template.\n$ kubectl get po kubia-0 -o yaml\napiVersion: v1\nkind: Pod\nmetadata:\n  ...\nspec:\n  containers:\n  - image: luksa/kubia-pet\n    ...\nListing 10.6\nA stateful pod created by the StatefulSet\n \n"}, {"color": "green", "id": "text_238", "label": "295\nUsing a StatefulSet\n    volumeMounts:\n    - mountPath: /var/data           \n      name: data                     \n    - mountPath: /var/run/secrets/kubernetes.io/serviceaccount\n      name: default-token-r2m41\n      readOnly: true\n  ...\n  volumes:\n  - name: data                       \n    persistentVolumeClaim:           \n      claimName: data-kubia-0            \n  - name: default-token-r2m41\n    secret:\n      secretName: default-token-r2m41\nThe PersistentVolumeClaim template was used to create the PersistentVolumeClaim\nand the volume inside the pod, which refers to the created PersistentVolumeClaim. \nEXAMINING THE GENERATED PERSISTENTVOLUMECLAIMS\nNow list the generated PersistentVolumeClaims to confirm they were created:\n$ kubectl get pvc\nNAME           STATUS    VOLUME    CAPACITY   ACCESSMODES   AGE\ndata-kubia-0   Bound     pv-c      0                        37s\ndata-kubia-1   Bound     pv-a      0                        37s\nThe names of the generated PersistentVolumeClaims are composed of the name\ndefined in the volumeClaimTemplate and the name of each pod. You can examine the\nclaims\u2019 YAML to see that they match the template.\n10.3.3 Playing with your pods\nWith the nodes of your data store cluster now running, you can start exploring it. You\ncan\u2019t communicate with your pods through the Service you created because it\u2019s head-\nless. You\u2019ll need to connect to individual pods directly (or create a regular Service, but\nthat wouldn\u2019t allow you to talk to a specific pod).\n You\u2019ve already seen ways to connect to a pod directly: by piggybacking on another\npod and running curl inside it, by using port-forwarding, and so on. This time, you\u2019ll\ntry another option. You\u2019ll use the API server as a proxy to the pods. \nCOMMUNICATING WITH PODS THROUGH THE API SERVER\nOne useful feature of the API server is the ability to proxy connections directly to indi-\nvidual pods. If you want to perform requests against your kubia-0 pod, you hit the fol-\nlowing URL:\n\u003capiServerHost\u003e:\u003cport\u003e/api/v1/namespaces/default/pods/kubia-0/proxy/\u003cpath\u003e\nBecause the API server is secured, sending requests to pods through the API server is\ncumbersome (among other things, you need to pass the authorization token in each\nrequest). Luckily, in chapter 8 you learned how to use kubectl proxy to talk to the\nThe volume mount, as \nspecified in the manifest\nThe volume created \nby the StatefulSet\nThe claim referenced \nby this volume\n \n", "shape": "dot", "size": 10, "title": "295\nUsing a StatefulSet\n    volumeMounts:\n    - mountPath: /var/data           \n      name: data                     \n    - mountPath: /var/run/secrets/kubernetes.io/serviceaccount\n      name: default-token-r2m41\n      readOnly: true\n  ...\n  volumes:\n  - name: data                       \n    persistentVolumeClaim:           \n      claimName: data-kubia-0            \n  - name: default-token-r2m41\n    secret:\n      secretName: default-token-r2m41\nThe PersistentVolumeClaim template was used to create the PersistentVolumeClaim\nand the volume inside the pod, which refers to the created PersistentVolumeClaim. \nEXAMINING THE GENERATED PERSISTENTVOLUMECLAIMS\nNow list the generated PersistentVolumeClaims to confirm they were created:\n$ kubectl get pvc\nNAME           STATUS    VOLUME    CAPACITY   ACCESSMODES   AGE\ndata-kubia-0   Bound     pv-c      0                        37s\ndata-kubia-1   Bound     pv-a      0                        37s\nThe names of the generated PersistentVolumeClaims are composed of the name\ndefined in the volumeClaimTemplate and the name of each pod. You can examine the\nclaims\u2019 YAML to see that they match the template.\n10.3.3 Playing with your pods\nWith the nodes of your data store cluster now running, you can start exploring it. You\ncan\u2019t communicate with your pods through the Service you created because it\u2019s head-\nless. You\u2019ll need to connect to individual pods directly (or create a regular Service, but\nthat wouldn\u2019t allow you to talk to a specific pod).\n You\u2019ve already seen ways to connect to a pod directly: by piggybacking on another\npod and running curl inside it, by using port-forwarding, and so on. This time, you\u2019ll\ntry another option. You\u2019ll use the API server as a proxy to the pods. \nCOMMUNICATING WITH PODS THROUGH THE API SERVER\nOne useful feature of the API server is the ability to proxy connections directly to indi-\nvidual pods. If you want to perform requests against your kubia-0 pod, you hit the fol-\nlowing URL:\n\u003capiServerHost\u003e:\u003cport\u003e/api/v1/namespaces/default/pods/kubia-0/proxy/\u003cpath\u003e\nBecause the API server is secured, sending requests to pods through the API server is\ncumbersome (among other things, you need to pass the authorization token in each\nrequest). Luckily, in chapter 8 you learned how to use kubectl proxy to talk to the\nThe volume mount, as \nspecified in the manifest\nThe volume created \nby the StatefulSet\nThe claim referenced \nby this volume\n \n"}, {"color": "green", "id": "text_239", "label": "296\nCHAPTER 10\nStatefulSets: deploying replicated stateful applications\nAPI server without having to deal with authentication and SSL certificates. Run the\nproxy again:\n$ kubectl proxy\nStarting to serve on 127.0.0.1:8001\nNow, because you\u2019ll be talking to the API server through the kubectl proxy, you\u2019ll use\nlocalhost:8001 rather than the actual API server host and port. You\u2019ll send a request to\nthe kubia-0 pod like this:\n$ curl localhost:8001/api/v1/namespaces/default/pods/kubia-0/proxy/\nYou\u0027ve hit kubia-0\nData stored on this pod: No data posted yet\nThe response shows that the request was indeed received and handled by the app run-\nning in your pod kubia-0. \nNOTE\nIf you receive an empty response, make sure you haven\u2019t left out that\nlast slash character at the end of the URL (or make sure curl follows redirects\nby using its -L option). \nBecause you\u2019re communicating with the pod through the API server, which you\u2019re\nconnecting to through the kubectl proxy, the request went through two different\nproxies (the first was the kubectl proxy and the other was the API server, which prox-\nied the request to the pod). For a clearer picture, examine figure 10.10.\nThe request you sent to the pod was a GET request, but you can also send POST\nrequests through the API server. This is done by sending a POST request to the same\nproxy URL as the one you sent the GET request to. \n When your app receives a POST request, it stores whatever\u2019s in the request body\ninto a local file. Send a POST request to the kubia-0 pod:\n$ curl -X POST -d \"Hey there! This greeting was submitted to kubia-0.\"\n\u27a5 localhost:8001/api/v1/namespaces/default/pods/kubia-0/proxy/\nData stored on pod kubia-0\nkubectl proxy\ncurl\nGET localhost:8001/api/v1/namespaces/default/pods/kubia-0/proxy/\nGET 192.168.99.100:8443/api/v1/namespaces/default/pods/kubia-0/proxy/\nAuthorization: Bearer \u003ctoken\u003e\nGET 172.17.0.3:8080/\nAPI server\nPod: kubia-0\n192.168.99.100\n172.17.0.3\nlocalhost\nFigure 10.10\nConnecting to a pod through both the kubectl proxy and API server proxy\n \n", "shape": "dot", "size": 10, "title": "296\nCHAPTER 10\nStatefulSets: deploying replicated stateful applications\nAPI server without having to deal with authentication and SSL certificates. Run the\nproxy again:\n$ kubectl proxy\nStarting to serve on 127.0.0.1:8001\nNow, because you\u2019ll be talking to the API server through the kubectl proxy, you\u2019ll use\nlocalhost:8001 rather than the actual API server host and port. You\u2019ll send a request to\nthe kubia-0 pod like this:\n$ curl localhost:8001/api/v1/namespaces/default/pods/kubia-0/proxy/\nYou\u0027ve hit kubia-0\nData stored on this pod: No data posted yet\nThe response shows that the request was indeed received and handled by the app run-\nning in your pod kubia-0. \nNOTE\nIf you receive an empty response, make sure you haven\u2019t left out that\nlast slash character at the end of the URL (or make sure curl follows redirects\nby using its -L option). \nBecause you\u2019re communicating with the pod through the API server, which you\u2019re\nconnecting to through the kubectl proxy, the request went through two different\nproxies (the first was the kubectl proxy and the other was the API server, which prox-\nied the request to the pod). For a clearer picture, examine figure 10.10.\nThe request you sent to the pod was a GET request, but you can also send POST\nrequests through the API server. This is done by sending a POST request to the same\nproxy URL as the one you sent the GET request to. \n When your app receives a POST request, it stores whatever\u2019s in the request body\ninto a local file. Send a POST request to the kubia-0 pod:\n$ curl -X POST -d \"Hey there! This greeting was submitted to kubia-0.\"\n\u27a5 localhost:8001/api/v1/namespaces/default/pods/kubia-0/proxy/\nData stored on pod kubia-0\nkubectl proxy\ncurl\nGET localhost:8001/api/v1/namespaces/default/pods/kubia-0/proxy/\nGET 192.168.99.100:8443/api/v1/namespaces/default/pods/kubia-0/proxy/\nAuthorization: Bearer \u003ctoken\u003e\nGET 172.17.0.3:8080/\nAPI server\nPod: kubia-0\n192.168.99.100\n172.17.0.3\nlocalhost\nFigure 10.10\nConnecting to a pod through both the kubectl proxy and API server proxy\n \n"}, {"color": "green", "id": "text_240", "label": "297\nUsing a StatefulSet\nThe data you sent should now be stored in that pod. Let\u2019s see if it returns the stored\ndata when you perform a GET request again:\n$ curl localhost:8001/api/v1/namespaces/default/pods/kubia-0/proxy/\nYou\u0027ve hit kubia-0\nData stored on this pod: Hey there! This greeting was submitted to kubia-0.\nOkay, so far so good. Now let\u2019s see what the other cluster node (the kubia-1 pod)\nsays:\n$ curl localhost:8001/api/v1/namespaces/default/pods/kubia-1/proxy/\nYou\u0027ve hit kubia-1\nData stored on this pod: No data posted yet\nAs expected, each node has its own state. But is that state persisted? Let\u2019s find out.\nDELETING A STATEFUL POD TO SEE IF THE RESCHEDULED POD IS REATTACHED TO THE SAME STORAGE\nYou\u2019re going to delete the kubia-0 pod and wait for it to be rescheduled. Then you\u2019ll\nsee if it\u2019s still serving the same data as before:\n$ kubectl delete po kubia-0\npod \"kubia-0\" deleted\nIf you list the pods, you\u2019ll see that the pod is terminating: \n$ kubectl get po\nNAME      READY     STATUS        RESTARTS   AGE\nkubia-0   1/1       Terminating   0          3m\nkubia-1   1/1       Running       0          3m\nAs soon as it terminates successfully, a new pod with the same name is created by the\nStatefulSet:\n$ kubectl get po\nNAME      READY     STATUS              RESTARTS   AGE\nkubia-0   0/1       ContainerCreating   0          6s\nkubia-1   1/1       Running             0          4m\n$ kubectl get po\nNAME      READY     STATUS    RESTARTS   AGE\nkubia-0   1/1       Running   0          9s\nkubia-1   1/1       Running   0          4m\nLet me remind you again that this new pod may be scheduled to any node in the clus-\nter, not necessarily the same node that the old pod was scheduled to. The old pod\u2019s\nwhole identity (the name, hostname, and the storage) is effectively moved to the new\nnode (as shown in figure 10.11). If you\u2019re using Minikube, you can\u2019t see this because it\nonly runs a single node, but in a multi-node cluster, you may see the pod scheduled to\na different node than before.\n \n", "shape": "dot", "size": 10, "title": "297\nUsing a StatefulSet\nThe data you sent should now be stored in that pod. Let\u2019s see if it returns the stored\ndata when you perform a GET request again:\n$ curl localhost:8001/api/v1/namespaces/default/pods/kubia-0/proxy/\nYou\u0027ve hit kubia-0\nData stored on this pod: Hey there! This greeting was submitted to kubia-0.\nOkay, so far so good. Now let\u2019s see what the other cluster node (the kubia-1 pod)\nsays:\n$ curl localhost:8001/api/v1/namespaces/default/pods/kubia-1/proxy/\nYou\u0027ve hit kubia-1\nData stored on this pod: No data posted yet\nAs expected, each node has its own state. But is that state persisted? Let\u2019s find out.\nDELETING A STATEFUL POD TO SEE IF THE RESCHEDULED POD IS REATTACHED TO THE SAME STORAGE\nYou\u2019re going to delete the kubia-0 pod and wait for it to be rescheduled. Then you\u2019ll\nsee if it\u2019s still serving the same data as before:\n$ kubectl delete po kubia-0\npod \"kubia-0\" deleted\nIf you list the pods, you\u2019ll see that the pod is terminating: \n$ kubectl get po\nNAME      READY     STATUS        RESTARTS   AGE\nkubia-0   1/1       Terminating   0          3m\nkubia-1   1/1       Running       0          3m\nAs soon as it terminates successfully, a new pod with the same name is created by the\nStatefulSet:\n$ kubectl get po\nNAME      READY     STATUS              RESTARTS   AGE\nkubia-0   0/1       ContainerCreating   0          6s\nkubia-1   1/1       Running             0          4m\n$ kubectl get po\nNAME      READY     STATUS    RESTARTS   AGE\nkubia-0   1/1       Running   0          9s\nkubia-1   1/1       Running   0          4m\nLet me remind you again that this new pod may be scheduled to any node in the clus-\nter, not necessarily the same node that the old pod was scheduled to. The old pod\u2019s\nwhole identity (the name, hostname, and the storage) is effectively moved to the new\nnode (as shown in figure 10.11). If you\u2019re using Minikube, you can\u2019t see this because it\nonly runs a single node, but in a multi-node cluster, you may see the pod scheduled to\na different node than before.\n \n"}, {"color": "green", "id": "text_241", "label": "298\nCHAPTER 10\nStatefulSets: deploying replicated stateful applications\nWith the new pod now running, let\u2019s check to see if it has the exact same identity as in\nits previous incarnation. The pod\u2019s name is the same, but what about the hostname\nand persistent data? You can ask the pod itself to confirm:\n$ curl localhost:8001/api/v1/namespaces/default/pods/kubia-0/proxy/\nYou\u0027ve hit kubia-0\nData stored on this pod: Hey there! This greeting was submitted to kubia-0.\nThe pod\u2019s response shows that both the hostname and the data are the same as before,\nconfirming that a StatefulSet always replaces a deleted pod with what\u2019s effectively the\nexact same pod. \nSCALING A STATEFULSET\nScaling down a StatefulSet and scaling it back up after an extended time period\nshould be no different than deleting a pod and having the StatefulSet recreate it\nimmediately. Remember that scaling down a StatefulSet only deletes the pods, but\nleaves the PersistentVolumeClaims untouched. I\u2019ll let you try scaling down the State-\nfulSet yourself and confirm this behavior. \n The key thing to remember is that scaling down (and up) is performed gradu-\nally\u2014similar to how individual pods are created when the StatefulSet is created ini-\ntially. When scaling down by more than one instance, the pod with the highest ordinal\nnumber is deleted first. Only after the pod terminates completely is the pod with the\nsecond highest ordinal number deleted. \nEXPOSING STATEFUL PODS THROUGH A REGULAR, NON-HEADLESS SERVICE\nBefore you move on to the last part of this chapter, you\u2019re going to add a proper, non-\nheadless Service in front of your pods, because clients usually connect to the pods\nthrough a Service rather than connecting directly.\nNode 1\nPod: kubia-0\nPod: kubia-1\nDelete kubia-0\nStorage\nStorage\nStorage\nPod: kubia-1\nStorage\nNode 1\nkubia-0 rescheduled\nNode 1\nNode 2\nNode 2\nNode 2\nStorage\nPod: kubia-1\nStorage\nPod: kubia-0\nFigure 10.11\nA stateful pod may be rescheduled to a different node, but it retains the name, hostname, and storage.\n \n", "shape": "dot", "size": 10, "title": "298\nCHAPTER 10\nStatefulSets: deploying replicated stateful applications\nWith the new pod now running, let\u2019s check to see if it has the exact same identity as in\nits previous incarnation. The pod\u2019s name is the same, but what about the hostname\nand persistent data? You can ask the pod itself to confirm:\n$ curl localhost:8001/api/v1/namespaces/default/pods/kubia-0/proxy/\nYou\u0027ve hit kubia-0\nData stored on this pod: Hey there! This greeting was submitted to kubia-0.\nThe pod\u2019s response shows that both the hostname and the data are the same as before,\nconfirming that a StatefulSet always replaces a deleted pod with what\u2019s effectively the\nexact same pod. \nSCALING A STATEFULSET\nScaling down a StatefulSet and scaling it back up after an extended time period\nshould be no different than deleting a pod and having the StatefulSet recreate it\nimmediately. Remember that scaling down a StatefulSet only deletes the pods, but\nleaves the PersistentVolumeClaims untouched. I\u2019ll let you try scaling down the State-\nfulSet yourself and confirm this behavior. \n The key thing to remember is that scaling down (and up) is performed gradu-\nally\u2014similar to how individual pods are created when the StatefulSet is created ini-\ntially. When scaling down by more than one instance, the pod with the highest ordinal\nnumber is deleted first. Only after the pod terminates completely is the pod with the\nsecond highest ordinal number deleted. \nEXPOSING STATEFUL PODS THROUGH A REGULAR, NON-HEADLESS SERVICE\nBefore you move on to the last part of this chapter, you\u2019re going to add a proper, non-\nheadless Service in front of your pods, because clients usually connect to the pods\nthrough a Service rather than connecting directly.\nNode 1\nPod: kubia-0\nPod: kubia-1\nDelete kubia-0\nStorage\nStorage\nStorage\nPod: kubia-1\nStorage\nNode 1\nkubia-0 rescheduled\nNode 1\nNode 2\nNode 2\nNode 2\nStorage\nPod: kubia-1\nStorage\nPod: kubia-0\nFigure 10.11\nA stateful pod may be rescheduled to a different node, but it retains the name, hostname, and storage.\n \n"}, {"color": "green", "id": "text_242", "label": "299\nDiscovering peers in a StatefulSet\n You know how to create the Service by now, but in case you don\u2019t, the following list-\ning shows the manifest.\napiVersion: v1\nkind: Service\nmetadata:\n  name: kubia-public\nspec:\n  selector:\n    app: kubia\n  ports:\n  - port: 80\n    targetPort: 8080\nBecause this isn\u2019t an externally exposed Service (it\u2019s a regular ClusterIP Service, not\na NodePort or a LoadBalancer-type Service), you can only access it from inside the\ncluster. You\u2019ll need a pod to access it from, right? Not necessarily.\nCONNECTING TO CLUSTER-INTERNAL SERVICES THROUGH THE API SERVER\nInstead of using a piggyback pod to access the service from inside the cluster, you can\nuse the same proxy feature provided by the API server to access the service the way\nyou\u2019ve accessed individual pods.\n The URI path for proxy-ing requests to Services is formed like this:\n/api/v1/namespaces/\u003cnamespace\u003e/services/\u003cservice name\u003e/proxy/\u003cpath\u003e\nTherefore, you can run curl on your local machine and access the service through the\nkubectl proxy like this (you ran kubectl proxy earlier and it should still be running):\n$ curl localhost:8001/api/v1/namespaces/default/services/kubia-\n\u27a5 public/proxy/\nYou\u0027ve hit kubia-1\nData stored on this pod: No data posted yet\nLikewise, clients (inside the cluster) can use the kubia-public service for storing to\nand reading data from your clustered data store. Of course, each request lands on a\nrandom cluster node, so you\u2019ll get the data from a random node each time. You\u2019ll\nimprove this next.\n10.4\nDiscovering peers in a StatefulSet\nWe still need to cover one more important thing. An important requirement of clus-\ntered apps is peer discovery\u2014the ability to find other members of the cluster. Each\nmember of a StatefulSet needs to easily find all the other members. Sure, it could do\nthat by talking to the API server, but one of Kubernetes\u2019 aims is to expose features that\nhelp keep applications completely Kubernetes-agnostic. Having apps talk to the Kuber-\nnetes API is therefore undesirable.\nListing 10.7\nA regular Service for accessing the stateful pods: kubia-service-public.yaml\n \n", "shape": "dot", "size": 10, "title": "299\nDiscovering peers in a StatefulSet\n You know how to create the Service by now, but in case you don\u2019t, the following list-\ning shows the manifest.\napiVersion: v1\nkind: Service\nmetadata:\n  name: kubia-public\nspec:\n  selector:\n    app: kubia\n  ports:\n  - port: 80\n    targetPort: 8080\nBecause this isn\u2019t an externally exposed Service (it\u2019s a regular ClusterIP Service, not\na NodePort or a LoadBalancer-type Service), you can only access it from inside the\ncluster. You\u2019ll need a pod to access it from, right? Not necessarily.\nCONNECTING TO CLUSTER-INTERNAL SERVICES THROUGH THE API SERVER\nInstead of using a piggyback pod to access the service from inside the cluster, you can\nuse the same proxy feature provided by the API server to access the service the way\nyou\u2019ve accessed individual pods.\n The URI path for proxy-ing requests to Services is formed like this:\n/api/v1/namespaces/\u003cnamespace\u003e/services/\u003cservice name\u003e/proxy/\u003cpath\u003e\nTherefore, you can run curl on your local machine and access the service through the\nkubectl proxy like this (you ran kubectl proxy earlier and it should still be running):\n$ curl localhost:8001/api/v1/namespaces/default/services/kubia-\n\u27a5 public/proxy/\nYou\u0027ve hit kubia-1\nData stored on this pod: No data posted yet\nLikewise, clients (inside the cluster) can use the kubia-public service for storing to\nand reading data from your clustered data store. Of course, each request lands on a\nrandom cluster node, so you\u2019ll get the data from a random node each time. You\u2019ll\nimprove this next.\n10.4\nDiscovering peers in a StatefulSet\nWe still need to cover one more important thing. An important requirement of clus-\ntered apps is peer discovery\u2014the ability to find other members of the cluster. Each\nmember of a StatefulSet needs to easily find all the other members. Sure, it could do\nthat by talking to the API server, but one of Kubernetes\u2019 aims is to expose features that\nhelp keep applications completely Kubernetes-agnostic. Having apps talk to the Kuber-\nnetes API is therefore undesirable.\nListing 10.7\nA regular Service for accessing the stateful pods: kubia-service-public.yaml\n \n"}, {"color": "green", "id": "text_243", "label": "300\nCHAPTER 10\nStatefulSets: deploying replicated stateful applications\n How can a pod discover its peers without talking to the API? Is there an existing,\nwell-known technology you can use that makes this possible? How about the Domain\nName System (DNS)? Depending on how much you know about DNS, you probably\nunderstand what an A, CNAME, or MX record is used for. Other lesser-known types of\nDNS records also exist. One of them is the SRV record.\nINTRODUCING SRV RECORDS\nSRV records are used to point to hostnames and ports of servers providing a specific\nservice. Kubernetes creates SRV records to point to the hostnames of the pods back-\ning a headless service. \n You\u2019re going to list the SRV records for your stateful pods by running the dig DNS\nlookup tool inside a new temporary pod. This is the command you\u2019ll use:\n$ kubectl run -it srvlookup --image=tutum/dnsutils --rm \n\u27a5 --restart=Never -- dig SRV kubia.default.svc.cluster.local\nThe command runs a one-off pod (--restart=Never) called srvlookup, which is\nattached to the console (-it) and is deleted as soon as it terminates (--rm). The\npod runs a single container from the tutum/dnsutils image and runs the following\ncommand:\ndig SRV kubia.default.svc.cluster.local\nThe following listing shows what the command prints out.\n...\n;; ANSWER SECTION:\nk.d.s.c.l. 30 IN  SRV     10 33 0 kubia-0.kubia.default.svc.cluster.local.\nk.d.s.c.l. 30 IN  SRV     10 33 0 kubia-1.kubia.default.svc.cluster.local.\n;; ADDITIONAL SECTION:\nkubia-0.kubia.default.svc.cluster.local. 30 IN A 172.17.0.4\nkubia-1.kubia.default.svc.cluster.local. 30 IN A 172.17.0.6\n...\nNOTE\nI\u2019ve had to shorten the actual name to get records to fit into a single\nline, so kubia.d.s.c.l is actually kubia.default.svc.cluster.local.\nThe ANSWER SECTION shows two SRV records pointing to the two pods backing your head-\nless service. Each pod also gets its own A record, as shown in ADDITIONAL SECTION.\n For a pod to get a list of all the other pods of a StatefulSet, all you need to do is\nperform an SRV DNS lookup. In Node.js, for example, the lookup is performed\nlike this:\ndns.resolveSrv(\"kubia.default.svc.cluster.local\", callBackFunction);\nYou\u2019ll use this command in your app to enable each pod to discover its peers.\nListing 10.8\nListing DNS SRV records of your headless Service\n \n", "shape": "dot", "size": 10, "title": "300\nCHAPTER 10\nStatefulSets: deploying replicated stateful applications\n How can a pod discover its peers without talking to the API? Is there an existing,\nwell-known technology you can use that makes this possible? How about the Domain\nName System (DNS)? Depending on how much you know about DNS, you probably\nunderstand what an A, CNAME, or MX record is used for. Other lesser-known types of\nDNS records also exist. One of them is the SRV record.\nINTRODUCING SRV RECORDS\nSRV records are used to point to hostnames and ports of servers providing a specific\nservice. Kubernetes creates SRV records to point to the hostnames of the pods back-\ning a headless service. \n You\u2019re going to list the SRV records for your stateful pods by running the dig DNS\nlookup tool inside a new temporary pod. This is the command you\u2019ll use:\n$ kubectl run -it srvlookup --image=tutum/dnsutils --rm \n\u27a5 --restart=Never -- dig SRV kubia.default.svc.cluster.local\nThe command runs a one-off pod (--restart=Never) called srvlookup, which is\nattached to the console (-it) and is deleted as soon as it terminates (--rm). The\npod runs a single container from the tutum/dnsutils image and runs the following\ncommand:\ndig SRV kubia.default.svc.cluster.local\nThe following listing shows what the command prints out.\n...\n;; ANSWER SECTION:\nk.d.s.c.l. 30 IN  SRV     10 33 0 kubia-0.kubia.default.svc.cluster.local.\nk.d.s.c.l. 30 IN  SRV     10 33 0 kubia-1.kubia.default.svc.cluster.local.\n;; ADDITIONAL SECTION:\nkubia-0.kubia.default.svc.cluster.local. 30 IN A 172.17.0.4\nkubia-1.kubia.default.svc.cluster.local. 30 IN A 172.17.0.6\n...\nNOTE\nI\u2019ve had to shorten the actual name to get records to fit into a single\nline, so kubia.d.s.c.l is actually kubia.default.svc.cluster.local.\nThe ANSWER SECTION shows two SRV records pointing to the two pods backing your head-\nless service. Each pod also gets its own A record, as shown in ADDITIONAL SECTION.\n For a pod to get a list of all the other pods of a StatefulSet, all you need to do is\nperform an SRV DNS lookup. In Node.js, for example, the lookup is performed\nlike this:\ndns.resolveSrv(\"kubia.default.svc.cluster.local\", callBackFunction);\nYou\u2019ll use this command in your app to enable each pod to discover its peers.\nListing 10.8\nListing DNS SRV records of your headless Service\n \n"}, {"color": "green", "id": "text_244", "label": "301\nDiscovering peers in a StatefulSet\nNOTE\nThe order of the returned SRV records is random, because they all have\nthe same priority. Don\u2019t expect to always see kubia-0 listed before kubia-1.\n10.4.1 Implementing peer discovery through DNS\nYour Stone Age data store isn\u2019t clustered yet. Each data store node runs completely\nindependently of all the others\u2014no communication exists between them. You\u2019ll get\nthem talking to each other next.\n Data posted by clients connecting to your data store cluster through the kubia-\npublic Service lands on a random cluster node. The cluster can store multiple data\nentries, but clients currently have no good way to see all those entries. Because ser-\nvices forward requests to pods randomly, a client would need to perform many\nrequests until it hit all the pods if it wanted to get the data from all the pods. \n You can improve this by having the node respond with data from all the cluster\nnodes. To do this, the node needs to find all its peers. You\u2019re going to use what you\nlearned about StatefulSets and SRV records to do this.\n You\u2019ll modify your app\u2019s source code as shown in the following listing (the full\nsource is available in the book\u2019s code archive; the listing shows only the important\nparts).\n...\nconst dns = require(\u0027dns\u0027);\nconst dataFile = \"/var/data/kubia.txt\";\nconst serviceName = \"kubia.default.svc.cluster.local\";\nconst port = 8080;\n...\nvar handler = function(request, response) {\n  if (request.method == \u0027POST\u0027) {\n    ...\n  } else {\n    response.writeHead(200);\n    if (request.url == \u0027/data\u0027) {\n      var data = fileExists(dataFile) \n        ? fs.readFileSync(dataFile, \u0027utf8\u0027) \n        : \"No data posted yet\";\n      response.end(data);\n    } else {\n      response.write(\"You\u0027ve hit \" + os.hostname() + \"\\n\");\n      response.write(\"Data stored in the cluster:\\n\");\n      dns.resolveSrv(serviceName, function (err, addresses) {    \n        if (err) {\n          response.end(\"Could not look up DNS SRV records: \" + err);\n          return;\n        }\n        var numResponses = 0;\n        if (addresses.length == 0) {\n          response.end(\"No peers discovered.\");\n        } else {\nListing 10.9\nDiscovering peers in a sample app: kubia-pet-peers-image/app.js\nThe app \nperforms a DNS \nlookup to obtain \nSRV records.\n \n", "shape": "dot", "size": 10, "title": "301\nDiscovering peers in a StatefulSet\nNOTE\nThe order of the returned SRV records is random, because they all have\nthe same priority. Don\u2019t expect to always see kubia-0 listed before kubia-1.\n10.4.1 Implementing peer discovery through DNS\nYour Stone Age data store isn\u2019t clustered yet. Each data store node runs completely\nindependently of all the others\u2014no communication exists between them. You\u2019ll get\nthem talking to each other next.\n Data posted by clients connecting to your data store cluster through the kubia-\npublic Service lands on a random cluster node. The cluster can store multiple data\nentries, but clients currently have no good way to see all those entries. Because ser-\nvices forward requests to pods randomly, a client would need to perform many\nrequests until it hit all the pods if it wanted to get the data from all the pods. \n You can improve this by having the node respond with data from all the cluster\nnodes. To do this, the node needs to find all its peers. You\u2019re going to use what you\nlearned about StatefulSets and SRV records to do this.\n You\u2019ll modify your app\u2019s source code as shown in the following listing (the full\nsource is available in the book\u2019s code archive; the listing shows only the important\nparts).\n...\nconst dns = require(\u0027dns\u0027);\nconst dataFile = \"/var/data/kubia.txt\";\nconst serviceName = \"kubia.default.svc.cluster.local\";\nconst port = 8080;\n...\nvar handler = function(request, response) {\n  if (request.method == \u0027POST\u0027) {\n    ...\n  } else {\n    response.writeHead(200);\n    if (request.url == \u0027/data\u0027) {\n      var data = fileExists(dataFile) \n        ? fs.readFileSync(dataFile, \u0027utf8\u0027) \n        : \"No data posted yet\";\n      response.end(data);\n    } else {\n      response.write(\"You\u0027ve hit \" + os.hostname() + \"\\n\");\n      response.write(\"Data stored in the cluster:\\n\");\n      dns.resolveSrv(serviceName, function (err, addresses) {    \n        if (err) {\n          response.end(\"Could not look up DNS SRV records: \" + err);\n          return;\n        }\n        var numResponses = 0;\n        if (addresses.length == 0) {\n          response.end(\"No peers discovered.\");\n        } else {\nListing 10.9\nDiscovering peers in a sample app: kubia-pet-peers-image/app.js\nThe app \nperforms a DNS \nlookup to obtain \nSRV records.\n \n"}, {"color": "green", "id": "text_245", "label": "302\nCHAPTER 10\nStatefulSets: deploying replicated stateful applications\n          addresses.forEach(function (item) {                   \n            var requestOptions = {\n              host: item.name, \n              port: port, \n              path: \u0027/data\u0027\n            };\n            httpGet(requestOptions, function (returnedData) {   \n              numResponses++;\n              response.write(\"- \" + item.name + \": \" + returnedData);\n              response.write(\"\\n\");\n              if (numResponses == addresses.length) {\n                response.end();\n              }\n            });\n          });\n        }\n      });\n    }\n  }\n};\n...\nFigure 10.12 shows what happens when a GET request is received by your app. The\nserver that receives the request first performs a lookup of SRV records for the head-\nless kubia service and then sends a GET request to each of the pods backing the ser-\nvice (even to itself, which obviously isn\u2019t necessary, but I wanted to keep the code as\nsimple as possible). It then returns a list of all the nodes along with the data stored on\neach of them.\nThe container image containing this new version of the app is available at docker.io/\nluksa/kubia-pet-peers.\n10.4.2 Updating a StatefulSet\nYour StatefulSet is already running, so let\u2019s see how to update its pod template so the\npods use the new image. You\u2019ll also set the replica count to 3 at the same time. To\nEach pod \npointed to by \nan SRV record is \nthen contacted \nto get its data.\ncurl\nDNS\n1. GET /\n4. GET /data\n5. GET /data\n2. SRV lookup\n6. Return collated data\nkubia-0\nkubia-1\nkubia-2\n3. GET /data\nFigure 10.12\nThe operation of your simplistic distributed data store\n \n", "shape": "dot", "size": 10, "title": "302\nCHAPTER 10\nStatefulSets: deploying replicated stateful applications\n          addresses.forEach(function (item) {                   \n            var requestOptions = {\n              host: item.name, \n              port: port, \n              path: \u0027/data\u0027\n            };\n            httpGet(requestOptions, function (returnedData) {   \n              numResponses++;\n              response.write(\"- \" + item.name + \": \" + returnedData);\n              response.write(\"\\n\");\n              if (numResponses == addresses.length) {\n                response.end();\n              }\n            });\n          });\n        }\n      });\n    }\n  }\n};\n...\nFigure 10.12 shows what happens when a GET request is received by your app. The\nserver that receives the request first performs a lookup of SRV records for the head-\nless kubia service and then sends a GET request to each of the pods backing the ser-\nvice (even to itself, which obviously isn\u2019t necessary, but I wanted to keep the code as\nsimple as possible). It then returns a list of all the nodes along with the data stored on\neach of them.\nThe container image containing this new version of the app is available at docker.io/\nluksa/kubia-pet-peers.\n10.4.2 Updating a StatefulSet\nYour StatefulSet is already running, so let\u2019s see how to update its pod template so the\npods use the new image. You\u2019ll also set the replica count to 3 at the same time. To\nEach pod \npointed to by \nan SRV record is \nthen contacted \nto get its data.\ncurl\nDNS\n1. GET /\n4. GET /data\n5. GET /data\n2. SRV lookup\n6. Return collated data\nkubia-0\nkubia-1\nkubia-2\n3. GET /data\nFigure 10.12\nThe operation of your simplistic distributed data store\n \n"}, {"color": "green", "id": "text_246", "label": "303\nDiscovering peers in a StatefulSet\nupdate the StatefulSet, use the kubectl edit command (the patch command would\nbe another option):\n$ kubectl edit statefulset kubia\nThis opens the StatefulSet definition in your default editor. In the definition, change\nspec.replicas to 3 and modify the spec.template.spec.containers.image attri-\nbute so it points to the new image (luksa/kubia-pet-peers instead of luksa/kubia-\npet). Save the file and exit the editor to update the StatefulSet. Two replicas were\nrunning previously, so you should now see an additional replica called kubia-2 start-\ning. List the pods to confirm:\n$ kubectl get po\nNAME      READY     STATUS              RESTARTS   AGE\nkubia-0   1/1       Running             0          25m\nkubia-1   1/1       Running             0          26m\nkubia-2   0/1       ContainerCreating   0          4s\nThe new pod instance is running the new image. But what about the existing two rep-\nlicas? Judging from their age, they don\u2019t seem to have been updated. This is expected,\nbecause initially, StatefulSets were more like ReplicaSets and not like Deployments,\nso they don\u2019t perform a rollout when the template is modified. You need to delete\nthe replicas manually and the StatefulSet will bring them up again based on the new\ntemplate:\n$ kubectl delete po kubia-0 kubia-1\npod \"kubia-0\" deleted\npod \"kubia-1\" deleted\nNOTE\nStarting from Kubernetes version 1.7, StatefulSets support rolling\nupdates the same way Deployments and DaemonSets do. See the StatefulSet\u2019s\nspec.updateStrategy field documentation using kubectl explain for more\ninformation.\n10.4.3 Trying out your clustered data store\nOnce the two pods are up, you can see if your shiny new Stone Age data store works as\nexpected. Post a few requests to the cluster, as shown in the following listing.\n$ curl -X POST -d \"The sun is shining\" \\\n\u27a5 localhost:8001/api/v1/namespaces/default/services/kubia-public/proxy/\nData stored on pod kubia-1\n$ curl -X POST -d \"The weather is sweet\" \\\n\u27a5 localhost:8001/api/v1/namespaces/default/services/kubia-public/proxy/\nData stored on pod kubia-0\nNow, read the stored data, as shown in the following listing.\nListing 10.10\nWriting to the clustered data store through the service\n \n", "shape": "dot", "size": 10, "title": "303\nDiscovering peers in a StatefulSet\nupdate the StatefulSet, use the kubectl edit command (the patch command would\nbe another option):\n$ kubectl edit statefulset kubia\nThis opens the StatefulSet definition in your default editor. In the definition, change\nspec.replicas to 3 and modify the spec.template.spec.containers.image attri-\nbute so it points to the new image (luksa/kubia-pet-peers instead of luksa/kubia-\npet). Save the file and exit the editor to update the StatefulSet. Two replicas were\nrunning previously, so you should now see an additional replica called kubia-2 start-\ning. List the pods to confirm:\n$ kubectl get po\nNAME      READY     STATUS              RESTARTS   AGE\nkubia-0   1/1       Running             0          25m\nkubia-1   1/1       Running             0          26m\nkubia-2   0/1       ContainerCreating   0          4s\nThe new pod instance is running the new image. But what about the existing two rep-\nlicas? Judging from their age, they don\u2019t seem to have been updated. This is expected,\nbecause initially, StatefulSets were more like ReplicaSets and not like Deployments,\nso they don\u2019t perform a rollout when the template is modified. You need to delete\nthe replicas manually and the StatefulSet will bring them up again based on the new\ntemplate:\n$ kubectl delete po kubia-0 kubia-1\npod \"kubia-0\" deleted\npod \"kubia-1\" deleted\nNOTE\nStarting from Kubernetes version 1.7, StatefulSets support rolling\nupdates the same way Deployments and DaemonSets do. See the StatefulSet\u2019s\nspec.updateStrategy field documentation using kubectl explain for more\ninformation.\n10.4.3 Trying out your clustered data store\nOnce the two pods are up, you can see if your shiny new Stone Age data store works as\nexpected. Post a few requests to the cluster, as shown in the following listing.\n$ curl -X POST -d \"The sun is shining\" \\\n\u27a5 localhost:8001/api/v1/namespaces/default/services/kubia-public/proxy/\nData stored on pod kubia-1\n$ curl -X POST -d \"The weather is sweet\" \\\n\u27a5 localhost:8001/api/v1/namespaces/default/services/kubia-public/proxy/\nData stored on pod kubia-0\nNow, read the stored data, as shown in the following listing.\nListing 10.10\nWriting to the clustered data store through the service\n \n"}, {"color": "green", "id": "text_247", "label": "304\nCHAPTER 10\nStatefulSets: deploying replicated stateful applications\n$ curl localhost:8001/api/v1/namespaces/default/services\n\u27a5 /kubia-public/proxy/\nYou\u0027ve hit kubia-2\nData stored on each cluster node:\n- kubia-0.kubia.default.svc.cluster.local: The weather is sweet\n- kubia-1.kubia.default.svc.cluster.local: The sun is shining\n- kubia-2.kubia.default.svc.cluster.local: No data posted yet\nNice! When a client request reaches one of your cluster nodes, it discovers all its\npeers, gathers data from them, and sends all the data back to the client. Even if you\nscale the StatefulSet up or down, the pod servicing the client\u2019s request can always find\nall the peers running at that time. \n The app itself isn\u2019t that useful, but I hope you found it a fun way to show how\ninstances of a replicated stateful app can discover their peers and handle horizontal\nscaling with ease.\n10.5\nUnderstanding how StatefulSets deal with node \nfailures\nIn section 10.2.4 we stated that Kubernetes must be absolutely sure that a stateful\npod is no longer running before creating its replacement. When a node fails\nabruptly, Kubernetes can\u2019t know the state of the node or its pods. It can\u2019t know\nwhether the pods are no longer running, or if they still are and are possibly even still\nreachable, and it\u2019s only the Kubelet that has stopped reporting the node\u2019s state to\nthe master.\n Because a StatefulSet guarantees that there will never be two pods running with\nthe same identity and storage, when a node appears to have failed, the StatefulSet can-\nnot and should not create a replacement pod until it knows for certain that the pod is\nno longer running. \n It can only know that when the cluster administrator tells it so. To do that, the\nadmin needs to either delete the pod or delete the whole node (doing so then deletes\nall the pods scheduled to the node).\n As your final exercise in this chapter, you\u2019ll look at what happens to StatefulSets\nand their pods when one of the cluster nodes gets disconnected from the network.\n10.5.1 Simulating a node\u2019s disconnection from the network \nAs in chapter 4, you\u2019ll simulate the node disconnecting from the network by shutting\ndown the node\u2019s eth0 network interface. Because this example requires multiple\nnodes, you can\u2019t run it on Minikube. You\u2019ll use Google Kubernetes Engine instead.\nSHUTTING DOWN THE NODE\u2019S NETWORK ADAPTER\nTo shut down a node\u2019s eth0 interface, you need to ssh into one of the nodes like this:\n$ gcloud compute ssh gke-kubia-default-pool-32a2cac8-m0g1\nListing 10.11\nReading from the data store\n \n", "shape": "dot", "size": 10, "title": "304\nCHAPTER 10\nStatefulSets: deploying replicated stateful applications\n$ curl localhost:8001/api/v1/namespaces/default/services\n\u27a5 /kubia-public/proxy/\nYou\u0027ve hit kubia-2\nData stored on each cluster node:\n- kubia-0.kubia.default.svc.cluster.local: The weather is sweet\n- kubia-1.kubia.default.svc.cluster.local: The sun is shining\n- kubia-2.kubia.default.svc.cluster.local: No data posted yet\nNice! When a client request reaches one of your cluster nodes, it discovers all its\npeers, gathers data from them, and sends all the data back to the client. Even if you\nscale the StatefulSet up or down, the pod servicing the client\u2019s request can always find\nall the peers running at that time. \n The app itself isn\u2019t that useful, but I hope you found it a fun way to show how\ninstances of a replicated stateful app can discover their peers and handle horizontal\nscaling with ease.\n10.5\nUnderstanding how StatefulSets deal with node \nfailures\nIn section 10.2.4 we stated that Kubernetes must be absolutely sure that a stateful\npod is no longer running before creating its replacement. When a node fails\nabruptly, Kubernetes can\u2019t know the state of the node or its pods. It can\u2019t know\nwhether the pods are no longer running, or if they still are and are possibly even still\nreachable, and it\u2019s only the Kubelet that has stopped reporting the node\u2019s state to\nthe master.\n Because a StatefulSet guarantees that there will never be two pods running with\nthe same identity and storage, when a node appears to have failed, the StatefulSet can-\nnot and should not create a replacement pod until it knows for certain that the pod is\nno longer running. \n It can only know that when the cluster administrator tells it so. To do that, the\nadmin needs to either delete the pod or delete the whole node (doing so then deletes\nall the pods scheduled to the node).\n As your final exercise in this chapter, you\u2019ll look at what happens to StatefulSets\nand their pods when one of the cluster nodes gets disconnected from the network.\n10.5.1 Simulating a node\u2019s disconnection from the network \nAs in chapter 4, you\u2019ll simulate the node disconnecting from the network by shutting\ndown the node\u2019s eth0 network interface. Because this example requires multiple\nnodes, you can\u2019t run it on Minikube. You\u2019ll use Google Kubernetes Engine instead.\nSHUTTING DOWN THE NODE\u2019S NETWORK ADAPTER\nTo shut down a node\u2019s eth0 interface, you need to ssh into one of the nodes like this:\n$ gcloud compute ssh gke-kubia-default-pool-32a2cac8-m0g1\nListing 10.11\nReading from the data store\n \n"}, {"color": "green", "id": "text_248", "label": "305\nUnderstanding how StatefulSets deal with node failures\nThen, inside the node, run the following command:\n$ sudo ifconfig eth0 down\nYour ssh session will stop working, so you\u2019ll need to open another terminal to continue.\nCHECKING THE NODE\u2019S STATUS AS SEEN BY THE KUBERNETES MASTER\nWith the node\u2019s network interface down, the Kubelet running on the node can no\nlonger contact the Kubernetes API server and let it know that the node and all its pods\nare still running.\n After a while, the control plane will mark the node as NotReady. You can see this\nwhen listing nodes, as the following listing shows.\n$ kubectl get node\nNAME                                   STATUS     AGE       VERSION\ngke-kubia-default-pool-32a2cac8-596v   Ready      16m       v1.6.2\ngke-kubia-default-pool-32a2cac8-m0g1   NotReady   16m       v1.6.2\ngke-kubia-default-pool-32a2cac8-sgl7   Ready      16m       v1.6.2\nBecause the control plane is no longer getting status updates from the node, the\nstatus of all pods on that node is Unknown. This is shown in the pod list in the follow-\ning listing.\n$ kubectl get po\nNAME      READY     STATUS    RESTARTS   AGE\nkubia-0   1/1       Unknown   0          15m\nkubia-1   1/1       Running   0          14m\nkubia-2   1/1       Running   0          13m\nAs you can see, the kubia-0 pod\u2019s status is no longer known because the pod was (and\nstill is) running on the node whose network interface you shut down.\nUNDERSTANDING WHAT HAPPENS TO PODS WHOSE STATUS IS UNKNOWN\nIf the node were to come back online and report its and its pod statuses again, the pod\nwould again be marked as Running. But if the pod\u2019s status remains unknown for more\nthan a few minutes (this time is configurable), the pod is automatically evicted from\nthe node. This is done by the master (the Kubernetes control plane). It evicts the pod\nby deleting the pod resource. \n When the Kubelet sees that the pod has been marked for deletion, it starts ter-\nminating the pod. In your case, the Kubelet can no longer reach the master (because\nyou disconnected the node from the network), which means the pod will keep\nrunning.\nListing 10.12\nObserving a failed node\u2019s status change to NotReady\nListing 10.13\nObserving the pod\u2019s status change after its node becomes NotReady\n \n", "shape": "dot", "size": 10, "title": "305\nUnderstanding how StatefulSets deal with node failures\nThen, inside the node, run the following command:\n$ sudo ifconfig eth0 down\nYour ssh session will stop working, so you\u2019ll need to open another terminal to continue.\nCHECKING THE NODE\u2019S STATUS AS SEEN BY THE KUBERNETES MASTER\nWith the node\u2019s network interface down, the Kubelet running on the node can no\nlonger contact the Kubernetes API server and let it know that the node and all its pods\nare still running.\n After a while, the control plane will mark the node as NotReady. You can see this\nwhen listing nodes, as the following listing shows.\n$ kubectl get node\nNAME                                   STATUS     AGE       VERSION\ngke-kubia-default-pool-32a2cac8-596v   Ready      16m       v1.6.2\ngke-kubia-default-pool-32a2cac8-m0g1   NotReady   16m       v1.6.2\ngke-kubia-default-pool-32a2cac8-sgl7   Ready      16m       v1.6.2\nBecause the control plane is no longer getting status updates from the node, the\nstatus of all pods on that node is Unknown. This is shown in the pod list in the follow-\ning listing.\n$ kubectl get po\nNAME      READY     STATUS    RESTARTS   AGE\nkubia-0   1/1       Unknown   0          15m\nkubia-1   1/1       Running   0          14m\nkubia-2   1/1       Running   0          13m\nAs you can see, the kubia-0 pod\u2019s status is no longer known because the pod was (and\nstill is) running on the node whose network interface you shut down.\nUNDERSTANDING WHAT HAPPENS TO PODS WHOSE STATUS IS UNKNOWN\nIf the node were to come back online and report its and its pod statuses again, the pod\nwould again be marked as Running. But if the pod\u2019s status remains unknown for more\nthan a few minutes (this time is configurable), the pod is automatically evicted from\nthe node. This is done by the master (the Kubernetes control plane). It evicts the pod\nby deleting the pod resource. \n When the Kubelet sees that the pod has been marked for deletion, it starts ter-\nminating the pod. In your case, the Kubelet can no longer reach the master (because\nyou disconnected the node from the network), which means the pod will keep\nrunning.\nListing 10.12\nObserving a failed node\u2019s status change to NotReady\nListing 10.13\nObserving the pod\u2019s status change after its node becomes NotReady\n \n"}, {"color": "green", "id": "text_249", "label": "306\nCHAPTER 10\nStatefulSets: deploying replicated stateful applications\n Let\u2019s examine the current situation. Use kubectl describe to display details about\nthe kubia-0 pod, as shown in the following listing.\n$ kubectl describe po kubia-0\nName:        kubia-0\nNamespace:   default\nNode:        gke-kubia-default-pool-32a2cac8-m0g1/10.132.0.2\n...\nStatus:      Terminating (expires Tue, 23 May 2017 15:06:09 +0200)\nReason:      NodeLost\nMessage:     Node gke-kubia-default-pool-32a2cac8-m0g1 which was \n             running pod kubia-0 is unresponsive\nThe pod is shown as Terminating, with NodeLost listed as the reason for the termina-\ntion. The message says the node is considered lost because it\u2019s unresponsive.\nNOTE\nWhat\u2019s shown here is the control plane\u2019s view of the world. In reality,\nthe pod\u2019s container is still running perfectly fine. It isn\u2019t terminating at all.\n10.5.2 Deleting the pod manually\nYou know the node isn\u2019t coming back, but you need all three pods running to handle\nclients properly. You need to get the kubia-0 pod rescheduled to a healthy node. As\nmentioned earlier, you need to delete the node or the pod manually. \nDELETING THE POD IN THE USUAL WAY\nDelete the pod the way you\u2019ve always deleted pods:\n$ kubectl delete po kubia-0\npod \"kubia-0\" deleted\nAll done, right? By deleting the pod, the StatefulSet should immediately create a\nreplacement pod, which will get scheduled to one of the remaining nodes. List the\npods again to confirm: \n$ kubectl get po\nNAME      READY     STATUS    RESTARTS   AGE\nkubia-0   1/1       Unknown   0          15m\nkubia-1   1/1       Running   0          14m\nkubia-2   1/1       Running   0          13m\nThat\u2019s strange. You deleted the pod a moment ago and kubectl said it had deleted it.\nWhy is the same pod still there? \nNOTE\nThe kubia-0 pod in the listing isn\u2019t a new pod with the same name\u2014\nthis is clear by looking at the AGE column. If it were new, its age would be\nmerely a few seconds.\nListing 10.14\nDisplaying details of the pod with the unknown status\n \n", "shape": "dot", "size": 10, "title": "306\nCHAPTER 10\nStatefulSets: deploying replicated stateful applications\n Let\u2019s examine the current situation. Use kubectl describe to display details about\nthe kubia-0 pod, as shown in the following listing.\n$ kubectl describe po kubia-0\nName:        kubia-0\nNamespace:   default\nNode:        gke-kubia-default-pool-32a2cac8-m0g1/10.132.0.2\n...\nStatus:      Terminating (expires Tue, 23 May 2017 15:06:09 +0200)\nReason:      NodeLost\nMessage:     Node gke-kubia-default-pool-32a2cac8-m0g1 which was \n             running pod kubia-0 is unresponsive\nThe pod is shown as Terminating, with NodeLost listed as the reason for the termina-\ntion. The message says the node is considered lost because it\u2019s unresponsive.\nNOTE\nWhat\u2019s shown here is the control plane\u2019s view of the world. In reality,\nthe pod\u2019s container is still running perfectly fine. It isn\u2019t terminating at all.\n10.5.2 Deleting the pod manually\nYou know the node isn\u2019t coming back, but you need all three pods running to handle\nclients properly. You need to get the kubia-0 pod rescheduled to a healthy node. As\nmentioned earlier, you need to delete the node or the pod manually. \nDELETING THE POD IN THE USUAL WAY\nDelete the pod the way you\u2019ve always deleted pods:\n$ kubectl delete po kubia-0\npod \"kubia-0\" deleted\nAll done, right? By deleting the pod, the StatefulSet should immediately create a\nreplacement pod, which will get scheduled to one of the remaining nodes. List the\npods again to confirm: \n$ kubectl get po\nNAME      READY     STATUS    RESTARTS   AGE\nkubia-0   1/1       Unknown   0          15m\nkubia-1   1/1       Running   0          14m\nkubia-2   1/1       Running   0          13m\nThat\u2019s strange. You deleted the pod a moment ago and kubectl said it had deleted it.\nWhy is the same pod still there? \nNOTE\nThe kubia-0 pod in the listing isn\u2019t a new pod with the same name\u2014\nthis is clear by looking at the AGE column. If it were new, its age would be\nmerely a few seconds.\nListing 10.14\nDisplaying details of the pod with the unknown status\n \n"}, {"color": "green", "id": "text_250", "label": "307\nSummary\nUNDERSTANDING WHY THE POD ISN\u2019T DELETED\nThe pod was marked for deletion even before you deleted it. That\u2019s because the con-\ntrol plane itself already deleted it (in order to evict it from the node). \n If you look at listing 10.14 again, you\u2019ll see that the pod\u2019s status is Terminating.\nThe pod was already marked for deletion earlier and will be removed as soon as the\nKubelet on its node notifies the API server that the pod\u2019s containers have terminated.\nBecause the node\u2019s network is down, this will never happen. \nFORCIBLY DELETING THE POD\nThe only thing you can do is tell the API server to delete the pod without waiting for\nthe Kubelet to confirm that the pod is no longer running. You do that like this:\n$ kubectl delete po kubia-0 --force --grace-period 0\nwarning: Immediate deletion does not wait for confirmation that the running \nresource has been terminated. The resource may continue to run on the \ncluster indefinitely.\npod \"kubia-0\" deleted\nYou need to use both the --force and --grace-period 0 options. The warning dis-\nplayed by kubectl notifies you of what you did. If you list the pods again, you\u2019ll finally\nsee a new kubia-0 pod created:\n$ kubectl get po\nNAME          READY     STATUS              RESTARTS   AGE\nkubia-0       0/1       ContainerCreating   0          8s\nkubia-1       1/1       Running             0          20m\nkubia-2       1/1       Running             0          19m\nWARNING\nDon\u2019t delete stateful pods forcibly unless you know the node is no\nlonger running or is unreachable (and will remain so forever). \nBefore continuing, you may want to bring the node you disconnected back online.\nYou can do that by restarting the node through the GCE web console or in a terminal\nby issuing the following command:\n$ gcloud compute instances reset \u003cnode name\u003e\n10.6\nSummary\nThis concludes the chapter on using StatefulSets to deploy stateful apps. This chapter\nhas shown you how to\n\uf0a1Give replicated pods individual storage\n\uf0a1Provide a stable identity to a pod\n\uf0a1Create a StatefulSet and a corresponding headless governing Service\n\uf0a1Scale and update a StatefulSet\n\uf0a1Discover other members of the StatefulSet through DNS\n \n", "shape": "dot", "size": 10, "title": "307\nSummary\nUNDERSTANDING WHY THE POD ISN\u2019T DELETED\nThe pod was marked for deletion even before you deleted it. That\u2019s because the con-\ntrol plane itself already deleted it (in order to evict it from the node). \n If you look at listing 10.14 again, you\u2019ll see that the pod\u2019s status is Terminating.\nThe pod was already marked for deletion earlier and will be removed as soon as the\nKubelet on its node notifies the API server that the pod\u2019s containers have terminated.\nBecause the node\u2019s network is down, this will never happen. \nFORCIBLY DELETING THE POD\nThe only thing you can do is tell the API server to delete the pod without waiting for\nthe Kubelet to confirm that the pod is no longer running. You do that like this:\n$ kubectl delete po kubia-0 --force --grace-period 0\nwarning: Immediate deletion does not wait for confirmation that the running \nresource has been terminated. The resource may continue to run on the \ncluster indefinitely.\npod \"kubia-0\" deleted\nYou need to use both the --force and --grace-period 0 options. The warning dis-\nplayed by kubectl notifies you of what you did. If you list the pods again, you\u2019ll finally\nsee a new kubia-0 pod created:\n$ kubectl get po\nNAME          READY     STATUS              RESTARTS   AGE\nkubia-0       0/1       ContainerCreating   0          8s\nkubia-1       1/1       Running             0          20m\nkubia-2       1/1       Running             0          19m\nWARNING\nDon\u2019t delete stateful pods forcibly unless you know the node is no\nlonger running or is unreachable (and will remain so forever). \nBefore continuing, you may want to bring the node you disconnected back online.\nYou can do that by restarting the node through the GCE web console or in a terminal\nby issuing the following command:\n$ gcloud compute instances reset \u003cnode name\u003e\n10.6\nSummary\nThis concludes the chapter on using StatefulSets to deploy stateful apps. This chapter\nhas shown you how to\n\uf0a1Give replicated pods individual storage\n\uf0a1Provide a stable identity to a pod\n\uf0a1Create a StatefulSet and a corresponding headless governing Service\n\uf0a1Scale and update a StatefulSet\n\uf0a1Discover other members of the StatefulSet through DNS\n \n"}, {"color": "green", "id": "text_251", "label": "308\nCHAPTER 10\nStatefulSets: deploying replicated stateful applications\n\uf0a1Connect to other members through their host names\n\uf0a1Forcibly delete stateful pods\nNow that you know the major building blocks you can use to have Kubernetes run and\nmanage your apps, we can look more closely at how it does that. In the next chapter,\nyou\u2019ll learn about the individual components that control the Kubernetes cluster and\nkeep your apps running.\n \n", "shape": "dot", "size": 10, "title": "308\nCHAPTER 10\nStatefulSets: deploying replicated stateful applications\n\uf0a1Connect to other members through their host names\n\uf0a1Forcibly delete stateful pods\nNow that you know the major building blocks you can use to have Kubernetes run and\nmanage your apps, we can look more closely at how it does that. In the next chapter,\nyou\u2019ll learn about the individual components that control the Kubernetes cluster and\nkeep your apps running.\n \n"}, {"color": "green", "id": "text_252", "label": "309\nUnderstanding\nKubernetes internals\nBy reading this book up to this point, you\u2019ve become familiar with what Kubernetes\nhas to offer and what it does. But so far, I\u2019ve intentionally not spent much time\nexplaining exactly how it does all this because, in my opinion, it makes no sense to\ngo into details of how a system works until you have a good understanding of what\nthe system does. That\u2019s why we haven\u2019t talked about exactly how a pod is scheduled\nor how the various controllers running inside the Controller Manager make deployed\nresources come to life. Because you now know most resources that can be deployed in\nKubernetes, it\u2019s time to dive into how they\u2019re implemented.\nThis chapter covers\n\uf0a1What components make up a Kubernetes cluster\n\uf0a1What each component does and how it does it\n\uf0a1How creating a Deployment object results in a \nrunning pod\n\uf0a1What a running pod is\n\uf0a1How the network between pods works\n\uf0a1How Kubernetes Services work\n\uf0a1How high-availability is achieved\n \n", "shape": "dot", "size": 10, "title": "309\nUnderstanding\nKubernetes internals\nBy reading this book up to this point, you\u2019ve become familiar with what Kubernetes\nhas to offer and what it does. But so far, I\u2019ve intentionally not spent much time\nexplaining exactly how it does all this because, in my opinion, it makes no sense to\ngo into details of how a system works until you have a good understanding of what\nthe system does. That\u2019s why we haven\u2019t talked about exactly how a pod is scheduled\nor how the various controllers running inside the Controller Manager make deployed\nresources come to life. Because you now know most resources that can be deployed in\nKubernetes, it\u2019s time to dive into how they\u2019re implemented.\nThis chapter covers\n\uf0a1What components make up a Kubernetes cluster\n\uf0a1What each component does and how it does it\n\uf0a1How creating a Deployment object results in a \nrunning pod\n\uf0a1What a running pod is\n\uf0a1How the network between pods works\n\uf0a1How Kubernetes Services work\n\uf0a1How high-availability is achieved\n \n"}, {"color": "green", "id": "text_253", "label": "310\nCHAPTER 11\nUnderstanding Kubernetes internals\n11.1\nUnderstanding the architecture\nBefore you look at how Kubernetes does what it does, let\u2019s take a closer look at the\ncomponents that make up a Kubernetes cluster. In chapter 1, you saw that a Kuberne-\ntes cluster is split into two parts:\n\uf0a1The Kubernetes Control Plane\n\uf0a1The (worker) nodes\nLet\u2019s look more closely at what these two parts do and what\u2019s running inside them.\nCOMPONENTS OF THE CONTROL PLANE\nThe Control Plane is what controls and makes the whole cluster function. To refresh\nyour memory, the components that make up the Control Plane are\n\uf0a1The etcd distributed persistent storage\n\uf0a1The API server\n\uf0a1The Scheduler\n\uf0a1The Controller Manager\nThese components store and manage the state of the cluster, but they aren\u2019t what runs\nthe application containers. \nCOMPONENTS RUNNING ON THE WORKER NODES\nThe task of running your containers is up to the components running on each\nworker node:\n\uf0a1The Kubelet\n\uf0a1The Kubernetes Service Proxy (kube-proxy)\n\uf0a1The Container Runtime (Docker, rkt, or others)\nADD-ON COMPONENTS\nBeside the Control Plane components and the components running on the nodes, a\nfew add-on components are required for the cluster to provide everything discussed\nso far. This includes\n\uf0a1The Kubernetes DNS server\n\uf0a1The Dashboard\n\uf0a1An Ingress controller\n\uf0a1Heapster, which we\u2019ll talk about in chapter 14\n\uf0a1The Container Network Interface network plugin (we\u2019ll explain it later in this\nchapter)\n11.1.1 The distributed nature of Kubernetes components\nThe previously mentioned components all run as individual processes. The compo-\nnents and their inter-dependencies are shown in figure 11.1.\n \n", "shape": "dot", "size": 10, "title": "310\nCHAPTER 11\nUnderstanding Kubernetes internals\n11.1\nUnderstanding the architecture\nBefore you look at how Kubernetes does what it does, let\u2019s take a closer look at the\ncomponents that make up a Kubernetes cluster. In chapter 1, you saw that a Kuberne-\ntes cluster is split into two parts:\n\uf0a1The Kubernetes Control Plane\n\uf0a1The (worker) nodes\nLet\u2019s look more closely at what these two parts do and what\u2019s running inside them.\nCOMPONENTS OF THE CONTROL PLANE\nThe Control Plane is what controls and makes the whole cluster function. To refresh\nyour memory, the components that make up the Control Plane are\n\uf0a1The etcd distributed persistent storage\n\uf0a1The API server\n\uf0a1The Scheduler\n\uf0a1The Controller Manager\nThese components store and manage the state of the cluster, but they aren\u2019t what runs\nthe application containers. \nCOMPONENTS RUNNING ON THE WORKER NODES\nThe task of running your containers is up to the components running on each\nworker node:\n\uf0a1The Kubelet\n\uf0a1The Kubernetes Service Proxy (kube-proxy)\n\uf0a1The Container Runtime (Docker, rkt, or others)\nADD-ON COMPONENTS\nBeside the Control Plane components and the components running on the nodes, a\nfew add-on components are required for the cluster to provide everything discussed\nso far. This includes\n\uf0a1The Kubernetes DNS server\n\uf0a1The Dashboard\n\uf0a1An Ingress controller\n\uf0a1Heapster, which we\u2019ll talk about in chapter 14\n\uf0a1The Container Network Interface network plugin (we\u2019ll explain it later in this\nchapter)\n11.1.1 The distributed nature of Kubernetes components\nThe previously mentioned components all run as individual processes. The compo-\nnents and their inter-dependencies are shown in figure 11.1.\n \n"}, {"color": "green", "id": "text_254", "label": "311\nUnderstanding the architecture\nTo get all the features Kubernetes provides, all these components need to be running.\nBut several can also perform useful work individually without the other components.\nYou\u2019ll see how as we examine each of them.\nHOW THESE COMPONENTS COMMUNICATE\nKubernetes system components communicate only with the API server. They don\u2019t\ntalk to each other directly. The API server is the only component that communicates\nwith etcd. None of the other components communicate with etcd directly, but instead\nmodify the cluster state by talking to the API server.\n Connections between the API server and the other components are almost always\ninitiated by the components, as shown in figure 11.1. But the API server does connect\nto the Kubelet when you use kubectl to fetch logs, use kubectl attach to connect to\na running container, or use the kubectl port-forward command.\nNOTE\nThe kubectl attach command is similar to kubectl exec, but it attaches\nto the main process running in the container instead of running an addi-\ntional one.\nRUNNING MULTIPLE INSTANCES OF INDIVIDUAL COMPONENTS\nAlthough the components on the worker nodes all need to run on the same node,\nthe components of the Control Plane can easily be split across multiple servers. There\nChecking the status of the Control Plane components\nThe API server exposes an API resource called ComponentStatus, which shows the\nhealth status of each Control Plane component. You can list the components and\ntheir statuses with kubectl:\n$ kubectl get componentstatuses\nNAME                 STATUS    MESSAGE              ERROR\nscheduler            Healthy   ok\ncontroller-manager   Healthy   ok\netcd-0               Healthy   {\"health\": \"true\"}\nControl Plane (master node)\nWorker node(s)\netcd\nAPI server\nkube-proxy\nKubelet\nScheduler\nController\nManager\nController\nRuntime\nFigure 11.1\nKubernetes \ncomponents of the Control \nPlane and the worker nodes\n \n", "shape": "dot", "size": 10, "title": "311\nUnderstanding the architecture\nTo get all the features Kubernetes provides, all these components need to be running.\nBut several can also perform useful work individually without the other components.\nYou\u2019ll see how as we examine each of them.\nHOW THESE COMPONENTS COMMUNICATE\nKubernetes system components communicate only with the API server. They don\u2019t\ntalk to each other directly. The API server is the only component that communicates\nwith etcd. None of the other components communicate with etcd directly, but instead\nmodify the cluster state by talking to the API server.\n Connections between the API server and the other components are almost always\ninitiated by the components, as shown in figure 11.1. But the API server does connect\nto the Kubelet when you use kubectl to fetch logs, use kubectl attach to connect to\na running container, or use the kubectl port-forward command.\nNOTE\nThe kubectl attach command is similar to kubectl exec, but it attaches\nto the main process running in the container instead of running an addi-\ntional one.\nRUNNING MULTIPLE INSTANCES OF INDIVIDUAL COMPONENTS\nAlthough the components on the worker nodes all need to run on the same node,\nthe components of the Control Plane can easily be split across multiple servers. There\nChecking the status of the Control Plane components\nThe API server exposes an API resource called ComponentStatus, which shows the\nhealth status of each Control Plane component. You can list the components and\ntheir statuses with kubectl:\n$ kubectl get componentstatuses\nNAME                 STATUS    MESSAGE              ERROR\nscheduler            Healthy   ok\ncontroller-manager   Healthy   ok\netcd-0               Healthy   {\"health\": \"true\"}\nControl Plane (master node)\nWorker node(s)\netcd\nAPI server\nkube-proxy\nKubelet\nScheduler\nController\nManager\nController\nRuntime\nFigure 11.1\nKubernetes \ncomponents of the Control \nPlane and the worker nodes\n \n"}, {"color": "green", "id": "text_255", "label": "312\nCHAPTER 11\nUnderstanding Kubernetes internals\ncan be more than one instance of each Control Plane component running to ensure\nhigh availability. While multiple instances of etcd and API server can be active at the\nsame time and do perform their jobs in parallel, only a single instance of the Sched-\nuler and the Controller Manager may be active at a given time\u2014with the others in\nstandby mode.\nHOW COMPONENTS ARE RUN\nThe Control Plane components, as well as kube-proxy, can either be deployed on the\nsystem directly or they can run as pods (as shown in listing 11.1). You may be surprised\nto hear this, but it will all make sense later when we talk about the Kubelet. \n The Kubelet is the only component that always runs as a regular system compo-\nnent, and it\u2019s the Kubelet that then runs all the other components as pods. To run the\nControl Plane components as pods, the Kubelet is also deployed on the master. The\nnext listing shows pods in the kube-system namespace in a cluster created with\nkubeadm, which is explained in appendix B.\n$ kubectl get po -o custom-columns=POD:metadata.name,NODE:spec.nodeName \n\u27a5 --sort-by spec.nodeName -n kube-system\nPOD                              NODE\nkube-controller-manager-master   master      \nkube-dns-2334855451-37d9k        master      \netcd-master                      master      \nkube-apiserver-master            master      \nkube-scheduler-master            master      \nkube-flannel-ds-tgj9k            node1      \nkube-proxy-ny3xm                 node1      \nkube-flannel-ds-0eek8            node2      \nkube-proxy-sp362                 node2      \nkube-flannel-ds-r5yf4            node3      \nkube-proxy-og9ac                 node3      \nAs you can see in the listing, all the Control Plane components are running as pods on\nthe master node. There are three worker nodes, and each one runs the kube-proxy\nand a Flannel pod, which provides the overlay network for the pods (we\u2019ll talk about\nFlannel later). \nTIP\nAs shown in the listing, you can tell kubectl to display custom columns\nwith the -o custom-columns option and sort the resource list with --sort-by.\nNow, let\u2019s look at each of the components up close, starting with the lowest level com-\nponent of the Control Plane\u2014the persistent storage.\n11.1.2 How Kubernetes uses etcd\nAll the objects you\u2019ve created throughout this book\u2014Pods, ReplicationControllers,\nServices, Secrets, and so on\u2014need to be stored somewhere in a persistent manner so\ntheir manifests survive API server restarts and failures. For this, Kubernetes uses etcd,\nListing 11.1\nKubernetes components running as pods\netcd, API server, Scheduler, \nController Manager, and \nthe DNS server are running \non the master.\nThe three nodes each run \na Kube Proxy pod and a \nFlannel networking pod.\n \n", "shape": "dot", "size": 10, "title": "312\nCHAPTER 11\nUnderstanding Kubernetes internals\ncan be more than one instance of each Control Plane component running to ensure\nhigh availability. While multiple instances of etcd and API server can be active at the\nsame time and do perform their jobs in parallel, only a single instance of the Sched-\nuler and the Controller Manager may be active at a given time\u2014with the others in\nstandby mode.\nHOW COMPONENTS ARE RUN\nThe Control Plane components, as well as kube-proxy, can either be deployed on the\nsystem directly or they can run as pods (as shown in listing 11.1). You may be surprised\nto hear this, but it will all make sense later when we talk about the Kubelet. \n The Kubelet is the only component that always runs as a regular system compo-\nnent, and it\u2019s the Kubelet that then runs all the other components as pods. To run the\nControl Plane components as pods, the Kubelet is also deployed on the master. The\nnext listing shows pods in the kube-system namespace in a cluster created with\nkubeadm, which is explained in appendix B.\n$ kubectl get po -o custom-columns=POD:metadata.name,NODE:spec.nodeName \n\u27a5 --sort-by spec.nodeName -n kube-system\nPOD                              NODE\nkube-controller-manager-master   master      \nkube-dns-2334855451-37d9k        master      \netcd-master                      master      \nkube-apiserver-master            master      \nkube-scheduler-master            master      \nkube-flannel-ds-tgj9k            node1      \nkube-proxy-ny3xm                 node1      \nkube-flannel-ds-0eek8            node2      \nkube-proxy-sp362                 node2      \nkube-flannel-ds-r5yf4            node3      \nkube-proxy-og9ac                 node3      \nAs you can see in the listing, all the Control Plane components are running as pods on\nthe master node. There are three worker nodes, and each one runs the kube-proxy\nand a Flannel pod, which provides the overlay network for the pods (we\u2019ll talk about\nFlannel later). \nTIP\nAs shown in the listing, you can tell kubectl to display custom columns\nwith the -o custom-columns option and sort the resource list with --sort-by.\nNow, let\u2019s look at each of the components up close, starting with the lowest level com-\nponent of the Control Plane\u2014the persistent storage.\n11.1.2 How Kubernetes uses etcd\nAll the objects you\u2019ve created throughout this book\u2014Pods, ReplicationControllers,\nServices, Secrets, and so on\u2014need to be stored somewhere in a persistent manner so\ntheir manifests survive API server restarts and failures. For this, Kubernetes uses etcd,\nListing 11.1\nKubernetes components running as pods\netcd, API server, Scheduler, \nController Manager, and \nthe DNS server are running \non the master.\nThe three nodes each run \na Kube Proxy pod and a \nFlannel networking pod.\n \n"}, {"color": "green", "id": "text_256", "label": "313\nUnderstanding the architecture\nwhich is a fast, distributed, and consistent key-value store. Because it\u2019s distributed,\nyou can run more than one etcd instance to provide both high availability and bet-\nter performance.\n The only component that talks to etcd directly is the Kubernetes API server. All\nother components read and write data to etcd indirectly through the API server. This\nbrings a few benefits, among them a more robust optimistic locking system as well as\nvalidation; and, by abstracting away the actual storage mechanism from all the other\ncomponents, it\u2019s much simpler to replace it in the future. It\u2019s worth emphasizing that\netcd is the only place Kubernetes stores cluster state and metadata.\nHOW RESOURCES ARE STORED IN ETCD\nAs I\u2019m writing this, Kubernetes can use either etcd version 2 or version 3, but version 3\nis now recommended because of improved performance. etcd v2 stores keys in a hier-\narchical key space, which makes key-value pairs similar to files in a file system. Each\nkey in etcd is either a directory, which contains other keys, or is a regular key with a\ncorresponding value. etcd v3 doesn\u2019t support directories, but because the key format\nremains the same (keys can include slashes), you can still think of them as being\ngrouped into directories. Kubernetes stores all its data in etcd under /registry. The\nfollowing listing shows a list of keys stored under /registry.\n$ etcdctl ls /registry\n/registry/configmaps\n/registry/daemonsets\n/registry/deployments\n/registry/events\n/registry/namespaces\n/registry/pods\n...\nAbout optimistic concurrency control\nOptimistic concurrency control (sometimes referred to as optimistic locking) is a\nmethod where instead of locking a piece of data and preventing it from being read or\nupdated while the lock is in place, the piece of data includes a version number. Every\ntime the data is updated, the version number increases. When updating the data, the\nversion number is checked to see if it has increased between the time the client read\nthe data and the time it submits the update. If this happens, the update is rejected\nand the client must re-read the new data and try to update it again. \nThe result is that when two clients try to update the same data entry, only the first\none succeeds.\nAll Kubernetes resources include a metadata.resourceVersion field, which clients\nneed to pass back to the API server when updating an object. If the version doesn\u2019t\nmatch the one stored in etcd, the API server rejects the update.\nListing 11.2\nTop-level entries stored in etcd by Kubernetes\n \n", "shape": "dot", "size": 10, "title": "313\nUnderstanding the architecture\nwhich is a fast, distributed, and consistent key-value store. Because it\u2019s distributed,\nyou can run more than one etcd instance to provide both high availability and bet-\nter performance.\n The only component that talks to etcd directly is the Kubernetes API server. All\nother components read and write data to etcd indirectly through the API server. This\nbrings a few benefits, among them a more robust optimistic locking system as well as\nvalidation; and, by abstracting away the actual storage mechanism from all the other\ncomponents, it\u2019s much simpler to replace it in the future. It\u2019s worth emphasizing that\netcd is the only place Kubernetes stores cluster state and metadata.\nHOW RESOURCES ARE STORED IN ETCD\nAs I\u2019m writing this, Kubernetes can use either etcd version 2 or version 3, but version 3\nis now recommended because of improved performance. etcd v2 stores keys in a hier-\narchical key space, which makes key-value pairs similar to files in a file system. Each\nkey in etcd is either a directory, which contains other keys, or is a regular key with a\ncorresponding value. etcd v3 doesn\u2019t support directories, but because the key format\nremains the same (keys can include slashes), you can still think of them as being\ngrouped into directories. Kubernetes stores all its data in etcd under /registry. The\nfollowing listing shows a list of keys stored under /registry.\n$ etcdctl ls /registry\n/registry/configmaps\n/registry/daemonsets\n/registry/deployments\n/registry/events\n/registry/namespaces\n/registry/pods\n...\nAbout optimistic concurrency control\nOptimistic concurrency control (sometimes referred to as optimistic locking) is a\nmethod where instead of locking a piece of data and preventing it from being read or\nupdated while the lock is in place, the piece of data includes a version number. Every\ntime the data is updated, the version number increases. When updating the data, the\nversion number is checked to see if it has increased between the time the client read\nthe data and the time it submits the update. If this happens, the update is rejected\nand the client must re-read the new data and try to update it again. \nThe result is that when two clients try to update the same data entry, only the first\none succeeds.\nAll Kubernetes resources include a metadata.resourceVersion field, which clients\nneed to pass back to the API server when updating an object. If the version doesn\u2019t\nmatch the one stored in etcd, the API server rejects the update.\nListing 11.2\nTop-level entries stored in etcd by Kubernetes\n \n"}, {"color": "green", "id": "text_257", "label": "314\nCHAPTER 11\nUnderstanding Kubernetes internals\nYou\u2019ll recognize that these keys correspond to the resource types you learned about in\nthe previous chapters. \nNOTE\nIf you\u2019re using v3 of the etcd API, you can\u2019t use the ls command to see\nthe contents of a directory. Instead, you can list all keys that start with a given\nprefix with etcdctl get /registry --prefix=true.\nThe following listing shows the contents of the /registry/pods directory.\n$ etcdctl ls /registry/pods\n/registry/pods/default\n/registry/pods/kube-system\nAs you can infer from the names, these two entries correspond to the default and the\nkube-system namespaces, which means pods are stored per namespace. The follow-\ning listing shows the entries in the /registry/pods/default directory.\n$ etcdctl ls /registry/pods/default\n/registry/pods/default/kubia-159041347-xk0vc\n/registry/pods/default/kubia-159041347-wt6ga\n/registry/pods/default/kubia-159041347-hp2o5\nEach entry corresponds to an individual pod. These aren\u2019t directories, but key-value\nentries. The following listing shows what\u2019s stored in one of them.\n$ etcdctl get /registry/pods/default/kubia-159041347-wt6ga\n{\"kind\":\"Pod\",\"apiVersion\":\"v1\",\"metadata\":{\"name\":\"kubia-159041347-wt6ga\",\n\"generateName\":\"kubia-159041347-\",\"namespace\":\"default\",\"selfLink\":...\nYou\u2019ll recognize that this is nothing other than a pod definition in JSON format. The\nAPI server stores the complete JSON representation of a resource in etcd. Because of\netcd\u2019s hierarchical key space, you can think of all the stored resources as JSON files in\na filesystem. Simple, right?\nWARNING\nPrior to Kubernetes version 1.7, the JSON manifest of a Secret\nresource was also stored like this (it wasn\u2019t encrypted). If someone got direct\naccess to etcd, they knew all your Secrets. From version 1.7, Secrets are\nencrypted and thus stored much more securely.\nENSURING THE CONSISTENCY AND VALIDITY OF STORED OBJECTS\nRemember Google\u2019s Borg and Omega systems mentioned in chapter 1, which are\nwhat Kubernetes is based on? Like Kubernetes, Omega also uses a centralized store to\nhold the state of the cluster, but in contrast, multiple Control Plane components\naccess the store directly. All these components need to make sure they all adhere to\nListing 11.3\nKeys in the /registry/pods directory\nListing 11.4\netcd entries for pods in the default namespace\nListing 11.5\nAn etcd entry representing a pod\n \n", "shape": "dot", "size": 10, "title": "314\nCHAPTER 11\nUnderstanding Kubernetes internals\nYou\u2019ll recognize that these keys correspond to the resource types you learned about in\nthe previous chapters. \nNOTE\nIf you\u2019re using v3 of the etcd API, you can\u2019t use the ls command to see\nthe contents of a directory. Instead, you can list all keys that start with a given\nprefix with etcdctl get /registry --prefix=true.\nThe following listing shows the contents of the /registry/pods directory.\n$ etcdctl ls /registry/pods\n/registry/pods/default\n/registry/pods/kube-system\nAs you can infer from the names, these two entries correspond to the default and the\nkube-system namespaces, which means pods are stored per namespace. The follow-\ning listing shows the entries in the /registry/pods/default directory.\n$ etcdctl ls /registry/pods/default\n/registry/pods/default/kubia-159041347-xk0vc\n/registry/pods/default/kubia-159041347-wt6ga\n/registry/pods/default/kubia-159041347-hp2o5\nEach entry corresponds to an individual pod. These aren\u2019t directories, but key-value\nentries. The following listing shows what\u2019s stored in one of them.\n$ etcdctl get /registry/pods/default/kubia-159041347-wt6ga\n{\"kind\":\"Pod\",\"apiVersion\":\"v1\",\"metadata\":{\"name\":\"kubia-159041347-wt6ga\",\n\"generateName\":\"kubia-159041347-\",\"namespace\":\"default\",\"selfLink\":...\nYou\u2019ll recognize that this is nothing other than a pod definition in JSON format. The\nAPI server stores the complete JSON representation of a resource in etcd. Because of\netcd\u2019s hierarchical key space, you can think of all the stored resources as JSON files in\na filesystem. Simple, right?\nWARNING\nPrior to Kubernetes version 1.7, the JSON manifest of a Secret\nresource was also stored like this (it wasn\u2019t encrypted). If someone got direct\naccess to etcd, they knew all your Secrets. From version 1.7, Secrets are\nencrypted and thus stored much more securely.\nENSURING THE CONSISTENCY AND VALIDITY OF STORED OBJECTS\nRemember Google\u2019s Borg and Omega systems mentioned in chapter 1, which are\nwhat Kubernetes is based on? Like Kubernetes, Omega also uses a centralized store to\nhold the state of the cluster, but in contrast, multiple Control Plane components\naccess the store directly. All these components need to make sure they all adhere to\nListing 11.3\nKeys in the /registry/pods directory\nListing 11.4\netcd entries for pods in the default namespace\nListing 11.5\nAn etcd entry representing a pod\n \n"}, {"color": "green", "id": "text_258", "label": "315\nUnderstanding the architecture\nthe same optimistic locking mechanism to handle conflicts properly. A single compo-\nnent not adhering fully to the mechanism may lead to inconsistent data. \n Kubernetes improves this by requiring all other Control Plane components to go\nthrough the API server. This way updates to the cluster state are always consistent, because\nthe optimistic locking mechanism is implemented in a single place, so less chance exists,\nif any, of error. The API server also makes sure that the data written to the store is always\nvalid and that changes to the data are only performed by authorized clients. \nENSURING CONSISTENCY WHEN ETCD IS CLUSTERED\nFor ensuring high availability, you\u2019ll usually run more than a single instance of etcd.\nMultiple etcd instances will need to remain consistent. Such a distributed system\nneeds to reach a consensus on what the actual state is. etcd uses the RAFT consensus\nalgorithm to achieve this, which ensures that at any given moment, each node\u2019s state is\neither what the majority of the nodes agrees is the current state or is one of the previ-\nously agreed upon states. \n Clients connecting to different nodes of an etcd cluster will either see the actual\ncurrent state or one of the states from the past (in Kubernetes, the only etcd client is\nthe API server, but there may be multiple instances). \n The consensus algorithm requires a majority (or quorum) for the cluster to progress\nto the next state. As a result, if the cluster splits into two disconnected groups of nodes,\nthe state in the two groups can never diverge, because to transition from the previous\nstate to the new one, there needs to be more than half of the nodes taking part in\nthe state change. If one group contains the majority of all nodes, the other one obvi-\nously doesn\u2019t. The first group can modify the cluster state, whereas the other one can\u2019t.\nWhen the two groups reconnect, the second group can catch up with the state in the\nfirst group (see figure 11.2).\nClients(s)\nClients(s)\nClients(s)\netcd-0\netcd-1\netcd-2\nThe nodes know\nthere are three nodes\nin the etcd cluster.\netcd-0\netcd-1\nThese two nodes know\nthey still have quorum\nand can accept state\nchanges from clients.\netcd-2\nThis node knows it does\nnot have quorum and\nshould therefore not\nallow state changes.\nNetwork\nsplit\nFigure 11.2\nIn a split-brain scenario, only the side which still has the majority (quorum) accepts \nstate changes.\n \n", "shape": "dot", "size": 10, "title": "315\nUnderstanding the architecture\nthe same optimistic locking mechanism to handle conflicts properly. A single compo-\nnent not adhering fully to the mechanism may lead to inconsistent data. \n Kubernetes improves this by requiring all other Control Plane components to go\nthrough the API server. This way updates to the cluster state are always consistent, because\nthe optimistic locking mechanism is implemented in a single place, so less chance exists,\nif any, of error. The API server also makes sure that the data written to the store is always\nvalid and that changes to the data are only performed by authorized clients. \nENSURING CONSISTENCY WHEN ETCD IS CLUSTERED\nFor ensuring high availability, you\u2019ll usually run more than a single instance of etcd.\nMultiple etcd instances will need to remain consistent. Such a distributed system\nneeds to reach a consensus on what the actual state is. etcd uses the RAFT consensus\nalgorithm to achieve this, which ensures that at any given moment, each node\u2019s state is\neither what the majority of the nodes agrees is the current state or is one of the previ-\nously agreed upon states. \n Clients connecting to different nodes of an etcd cluster will either see the actual\ncurrent state or one of the states from the past (in Kubernetes, the only etcd client is\nthe API server, but there may be multiple instances). \n The consensus algorithm requires a majority (or quorum) for the cluster to progress\nto the next state. As a result, if the cluster splits into two disconnected groups of nodes,\nthe state in the two groups can never diverge, because to transition from the previous\nstate to the new one, there needs to be more than half of the nodes taking part in\nthe state change. If one group contains the majority of all nodes, the other one obvi-\nously doesn\u2019t. The first group can modify the cluster state, whereas the other one can\u2019t.\nWhen the two groups reconnect, the second group can catch up with the state in the\nfirst group (see figure 11.2).\nClients(s)\nClients(s)\nClients(s)\netcd-0\netcd-1\netcd-2\nThe nodes know\nthere are three nodes\nin the etcd cluster.\netcd-0\netcd-1\nThese two nodes know\nthey still have quorum\nand can accept state\nchanges from clients.\netcd-2\nThis node knows it does\nnot have quorum and\nshould therefore not\nallow state changes.\nNetwork\nsplit\nFigure 11.2\nIn a split-brain scenario, only the side which still has the majority (quorum) accepts \nstate changes.\n \n"}, {"color": "green", "id": "text_259", "label": "316\nCHAPTER 11\nUnderstanding Kubernetes internals\nWHY THE NUMBER OF ETCD INSTANCES SHOULD BE AN ODD NUMBER\netcd is usually deployed with an odd number of instances. I\u2019m sure you\u2019d like to know\nwhy. Let\u2019s compare having two vs. having one instance. Having two instances requires\nboth instances to be present to have a majority. If either of them fails, the etcd cluster\ncan\u2019t transition to a new state because no majority exists. Having two instances is worse\nthan having only a single instance. By having two, the chance of the whole cluster fail-\ning has increased by 100%, compared to that of a single-node cluster failing. \n The same applies when comparing three vs. four etcd instances. With three instances,\none instance can fail and a majority (of two) still exists. With four instances, you need\nthree nodes for a majority (two aren\u2019t enough). In both three- and four-instance clus-\nters, only a single instance may fail. But when running four instances, if one fails, a\nhigher possibility exists of an additional instance of the three remaining instances fail-\ning (compared to a three-node cluster with one failed node and two remaining nodes).\n Usually, for large clusters, an etcd cluster of five or seven nodes is sufficient. It can\nhandle a two- or a three-node failure, respectively, which suffices in almost all situations. \n11.1.3 What the API server does\nThe Kubernetes API server is the central component used by all other components\nand by clients, such as kubectl. It provides a CRUD (Create, Read, Update, Delete)\ninterface for querying and modifying the cluster state over a RESTful API. It stores\nthat state in etcd.\n In addition to providing a consistent way of storing objects in etcd, it also performs\nvalidation of those objects, so clients can\u2019t store improperly configured objects (which\nthey could if they were writing to the store directly). Along with validation, it also han-\ndles optimistic locking, so changes to an object are never overridden by other clients\nin the event of concurrent updates.\n One of the API server\u2019s clients is the command-line tool kubectl you\u2019ve been\nusing from the beginning of the book. When creating a resource from a JSON file, for\nexample, kubectl posts the file\u2019s contents to the API server through an HTTP POST\nrequest. Figure 11.3 shows what happens inside the API server when it receives the\nrequest. This is explained in more detail in the next few paragraphs.\nAPI server\netcd\nAuthentication\nplugin 1\nAuthentication\nplugin 2\nAuthentication\nplugin 3\nClient\n(\n)\nkubectl\nHTTP POST\nrequest\nAuthorization\nplugin 1\nAuthorization\nplugin 2\nAuthorization\nplugin 3\nAdmission\ncontrol plugin 1\nAdmission\ncontrol plugin 2\nAdmission\ncontrol plugin 3\nResource\nvalidation\nFigure 11.3\nThe operation of the API server\n \n", "shape": "dot", "size": 10, "title": "316\nCHAPTER 11\nUnderstanding Kubernetes internals\nWHY THE NUMBER OF ETCD INSTANCES SHOULD BE AN ODD NUMBER\netcd is usually deployed with an odd number of instances. I\u2019m sure you\u2019d like to know\nwhy. Let\u2019s compare having two vs. having one instance. Having two instances requires\nboth instances to be present to have a majority. If either of them fails, the etcd cluster\ncan\u2019t transition to a new state because no majority exists. Having two instances is worse\nthan having only a single instance. By having two, the chance of the whole cluster fail-\ning has increased by 100%, compared to that of a single-node cluster failing. \n The same applies when comparing three vs. four etcd instances. With three instances,\none instance can fail and a majority (of two) still exists. With four instances, you need\nthree nodes for a majority (two aren\u2019t enough). In both three- and four-instance clus-\nters, only a single instance may fail. But when running four instances, if one fails, a\nhigher possibility exists of an additional instance of the three remaining instances fail-\ning (compared to a three-node cluster with one failed node and two remaining nodes).\n Usually, for large clusters, an etcd cluster of five or seven nodes is sufficient. It can\nhandle a two- or a three-node failure, respectively, which suffices in almost all situations. \n11.1.3 What the API server does\nThe Kubernetes API server is the central component used by all other components\nand by clients, such as kubectl. It provides a CRUD (Create, Read, Update, Delete)\ninterface for querying and modifying the cluster state over a RESTful API. It stores\nthat state in etcd.\n In addition to providing a consistent way of storing objects in etcd, it also performs\nvalidation of those objects, so clients can\u2019t store improperly configured objects (which\nthey could if they were writing to the store directly). Along with validation, it also han-\ndles optimistic locking, so changes to an object are never overridden by other clients\nin the event of concurrent updates.\n One of the API server\u2019s clients is the command-line tool kubectl you\u2019ve been\nusing from the beginning of the book. When creating a resource from a JSON file, for\nexample, kubectl posts the file\u2019s contents to the API server through an HTTP POST\nrequest. Figure 11.3 shows what happens inside the API server when it receives the\nrequest. This is explained in more detail in the next few paragraphs.\nAPI server\netcd\nAuthentication\nplugin 1\nAuthentication\nplugin 2\nAuthentication\nplugin 3\nClient\n(\n)\nkubectl\nHTTP POST\nrequest\nAuthorization\nplugin 1\nAuthorization\nplugin 2\nAuthorization\nplugin 3\nAdmission\ncontrol plugin 1\nAdmission\ncontrol plugin 2\nAdmission\ncontrol plugin 3\nResource\nvalidation\nFigure 11.3\nThe operation of the API server\n \n"}, {"color": "green", "id": "text_260", "label": "317\nUnderstanding the architecture\nAUTHENTICATING THE CLIENT WITH AUTHENTICATION PLUGINS\nFirst, the API server needs to authenticate the client sending the request. This is per-\nformed by one or more authentication plugins configured in the API server. The API\nserver calls these plugins in turn, until one of them determines who is sending the\nrequest. It does this by inspecting the HTTP request. \n Depending on the authentication method, the user can be extracted from the cli-\nent\u2019s certificate or an HTTP header, such as Authorization, which you used in chap-\nter 8. The plugin extracts the client\u2019s username, user ID, and groups the user belongs\nto. This data is then used in the next stage, which is authorization.\nAUTHORIZING THE CLIENT WITH AUTHORIZATION PLUGINS\nBesides authentication plugins, the API server is also configured to use one or more\nauthorization plugins. Their job is to determine whether the authenticated user can\nperform the requested action on the requested resource. For example, when creating\npods, the API server consults all authorization plugins in turn, to determine whether\nthe user can create pods in the requested namespace. As soon as a plugin says the user\ncan perform the action, the API server progresses to the next stage.\nVALIDATING AND/OR MODIFYING THE RESOURCE IN THE REQUEST WITH ADMISSION CONTROL PLUGINS\nIf the request is trying to create, modify, or delete a resource, the request is sent\nthrough Admission Control. Again, the server is configured with multiple Admission\nControl plugins. These plugins can modify the resource for different reasons. They\nmay initialize fields missing from the resource specification to the configured default\nvalues or even override them. They may even modify other related resources, which\naren\u2019t in the request, and can also reject a request for whatever reason. The resource\npasses through all Admission Control plugins.\nNOTE\nWhen the request is only trying to read data, the request doesn\u2019t go\nthrough the Admission Control.\nExamples of Admission Control plugins include\n\uf0a1\nAlwaysPullImages\u2014Overrides the pod\u2019s imagePullPolicy to Always, forcing\nthe image to be pulled every time the pod is deployed.\n\uf0a1\nServiceAccount\u2014Applies the default service account to pods that don\u2019t specify\nit explicitly.\n\uf0a1\nNamespaceLifecycle\u2014Prevents creation of pods in namespaces that are in the\nprocess of being deleted, as well as in non-existing namespaces.\n\uf0a1\nResourceQuota\u2014Ensures pods in a certain namespace only use as much CPU\nand memory as has been allotted to the namespace. We\u2019ll learn more about this\nin chapter 14.\nYou\u2019ll find a list of additional Admission Control plugins in the Kubernetes documen-\ntation at https:/\n/kubernetes.io/docs/admin/admission-controllers/.\n \n", "shape": "dot", "size": 10, "title": "317\nUnderstanding the architecture\nAUTHENTICATING THE CLIENT WITH AUTHENTICATION PLUGINS\nFirst, the API server needs to authenticate the client sending the request. This is per-\nformed by one or more authentication plugins configured in the API server. The API\nserver calls these plugins in turn, until one of them determines who is sending the\nrequest. It does this by inspecting the HTTP request. \n Depending on the authentication method, the user can be extracted from the cli-\nent\u2019s certificate or an HTTP header, such as Authorization, which you used in chap-\nter 8. The plugin extracts the client\u2019s username, user ID, and groups the user belongs\nto. This data is then used in the next stage, which is authorization.\nAUTHORIZING THE CLIENT WITH AUTHORIZATION PLUGINS\nBesides authentication plugins, the API server is also configured to use one or more\nauthorization plugins. Their job is to determine whether the authenticated user can\nperform the requested action on the requested resource. For example, when creating\npods, the API server consults all authorization plugins in turn, to determine whether\nthe user can create pods in the requested namespace. As soon as a plugin says the user\ncan perform the action, the API server progresses to the next stage.\nVALIDATING AND/OR MODIFYING THE RESOURCE IN THE REQUEST WITH ADMISSION CONTROL PLUGINS\nIf the request is trying to create, modify, or delete a resource, the request is sent\nthrough Admission Control. Again, the server is configured with multiple Admission\nControl plugins. These plugins can modify the resource for different reasons. They\nmay initialize fields missing from the resource specification to the configured default\nvalues or even override them. They may even modify other related resources, which\naren\u2019t in the request, and can also reject a request for whatever reason. The resource\npasses through all Admission Control plugins.\nNOTE\nWhen the request is only trying to read data, the request doesn\u2019t go\nthrough the Admission Control.\nExamples of Admission Control plugins include\n\uf0a1\nAlwaysPullImages\u2014Overrides the pod\u2019s imagePullPolicy to Always, forcing\nthe image to be pulled every time the pod is deployed.\n\uf0a1\nServiceAccount\u2014Applies the default service account to pods that don\u2019t specify\nit explicitly.\n\uf0a1\nNamespaceLifecycle\u2014Prevents creation of pods in namespaces that are in the\nprocess of being deleted, as well as in non-existing namespaces.\n\uf0a1\nResourceQuota\u2014Ensures pods in a certain namespace only use as much CPU\nand memory as has been allotted to the namespace. We\u2019ll learn more about this\nin chapter 14.\nYou\u2019ll find a list of additional Admission Control plugins in the Kubernetes documen-\ntation at https:/\n/kubernetes.io/docs/admin/admission-controllers/.\n \n"}, {"color": "green", "id": "text_261", "label": "318\nCHAPTER 11\nUnderstanding Kubernetes internals\nVALIDATING THE RESOURCE AND STORING IT PERSISTENTLY\nAfter letting the request pass through all the Admission Control plugins, the API server\nthen validates the object, stores it in etcd, and returns a response to the client.\n11.1.4 Understanding how the API server notifies clients of resource \nchanges\nThe API server doesn\u2019t do anything else except what we\u2019ve discussed. For example, it\ndoesn\u2019t create pods when you create a ReplicaSet resource and it doesn\u2019t manage the\nendpoints of a service. That\u2019s what controllers in the Controller Manager do. \n But the API server doesn\u2019t even tell these controllers what to do. All it does is\nenable those controllers and other components to observe changes to deployed\nresources. A Control Plane component can request to be notified when a resource is\ncreated, modified, or deleted. This enables the component to perform whatever task\nit needs in response to a change of the cluster metadata.\n Clients watch for changes by opening an HTTP connection to the API server.\nThrough this connection, the client will then receive a stream of modifications to the\nwatched objects. Every time an object is updated, the server sends the new version of\nthe object to all connected clients watching the object. Figure 11.4 shows how clients\ncan watch for changes to pods and how a change to one of the pods is stored into etcd\nand then relayed to all clients watching pods at that moment.\nOne of the API server\u2019s clients is the kubectl tool, which also supports watching\nresources. For example, when deploying a pod, you don\u2019t need to constantly poll the list\nof pods by repeatedly executing kubectl get pods. Instead, you can use the --watch\nflag and be notified of each creation, modification, or deletion of a pod, as shown in\nthe following listing.\n$ kubectl get pods --watch\nNAME                    READY     STATUS              RESTARTS   AGE\nListing 11.6\nWatching a pod being created and then deleted\nVarious\nclients\nkubectl\nAPI server\n1. GET /.../pods?watch=true\n2. POST /.../pods/pod-xyz\n5. Send updated object\nto all watchers\n3. Update object\nin etcd\n4. Modi\ufb01cation\nnoti\ufb01cation\netcd\nFigure 11.4\nWhen an object is updated, the API server sends the updated object to all interested \nwatchers.\n \n", "shape": "dot", "size": 10, "title": "318\nCHAPTER 11\nUnderstanding Kubernetes internals\nVALIDATING THE RESOURCE AND STORING IT PERSISTENTLY\nAfter letting the request pass through all the Admission Control plugins, the API server\nthen validates the object, stores it in etcd, and returns a response to the client.\n11.1.4 Understanding how the API server notifies clients of resource \nchanges\nThe API server doesn\u2019t do anything else except what we\u2019ve discussed. For example, it\ndoesn\u2019t create pods when you create a ReplicaSet resource and it doesn\u2019t manage the\nendpoints of a service. That\u2019s what controllers in the Controller Manager do. \n But the API server doesn\u2019t even tell these controllers what to do. All it does is\nenable those controllers and other components to observe changes to deployed\nresources. A Control Plane component can request to be notified when a resource is\ncreated, modified, or deleted. This enables the component to perform whatever task\nit needs in response to a change of the cluster metadata.\n Clients watch for changes by opening an HTTP connection to the API server.\nThrough this connection, the client will then receive a stream of modifications to the\nwatched objects. Every time an object is updated, the server sends the new version of\nthe object to all connected clients watching the object. Figure 11.4 shows how clients\ncan watch for changes to pods and how a change to one of the pods is stored into etcd\nand then relayed to all clients watching pods at that moment.\nOne of the API server\u2019s clients is the kubectl tool, which also supports watching\nresources. For example, when deploying a pod, you don\u2019t need to constantly poll the list\nof pods by repeatedly executing kubectl get pods. Instead, you can use the --watch\nflag and be notified of each creation, modification, or deletion of a pod, as shown in\nthe following listing.\n$ kubectl get pods --watch\nNAME                    READY     STATUS              RESTARTS   AGE\nListing 11.6\nWatching a pod being created and then deleted\nVarious\nclients\nkubectl\nAPI server\n1. GET /.../pods?watch=true\n2. POST /.../pods/pod-xyz\n5. Send updated object\nto all watchers\n3. Update object\nin etcd\n4. Modi\ufb01cation\nnoti\ufb01cation\netcd\nFigure 11.4\nWhen an object is updated, the API server sends the updated object to all interested \nwatchers.\n \n"}, {"color": "green", "id": "text_262", "label": "319\nUnderstanding the architecture\nkubia-159041347-14j3i   0/1       Pending             0          0s\nkubia-159041347-14j3i   0/1       Pending             0          0s\nkubia-159041347-14j3i   0/1       ContainerCreating   0          1s\nkubia-159041347-14j3i   0/1       Running             0          3s\nkubia-159041347-14j3i   1/1       Running             0          5s\nkubia-159041347-14j3i   1/1       Terminating         0          9s\nkubia-159041347-14j3i   0/1       Terminating         0          17s\nkubia-159041347-14j3i   0/1       Terminating         0          17s\nkubia-159041347-14j3i   0/1       Terminating         0          17s\nYou can even have kubectl print out the whole YAML on each watch event like this:\n$ kubectl get pods -o yaml --watch\nThe watch mechanism is also used by the Scheduler, which is the next Control Plane\ncomponent you\u2019re going to learn more about.\n11.1.5 Understanding the Scheduler\nYou\u2019ve already learned that you don\u2019t usually specify which cluster node a pod should\nrun on. This is left to the Scheduler. From afar, the operation of the Scheduler looks\nsimple. All it does is wait for newly created pods through the API server\u2019s watch mech-\nanism and assign a node to each new pod that doesn\u2019t already have the node set. \n The Scheduler doesn\u2019t instruct the selected node (or the Kubelet running on that\nnode) to run the pod. All the Scheduler does is update the pod definition through the\nAPI server. The API server then notifies the Kubelet (again, through the watch mech-\nanism described previously) that the pod has been scheduled. As soon as the Kubelet\non the target node sees the pod has been scheduled to its node, it creates and runs the\npod\u2019s containers.\n Although a coarse-grained view of the scheduling process seems trivial, the actual\ntask of selecting the best node for the pod isn\u2019t that simple. Sure, the simplest\nScheduler could pick a random node and not care about the pods already running on\nthat node. On the other side of the spectrum, the Scheduler could use advanced tech-\nniques such as machine learning to anticipate what kind of pods are about to be\nscheduled in the next minutes or hours and schedule pods to maximize future hard-\nware utilization without requiring any rescheduling of existing pods. Kubernetes\u2019\ndefault Scheduler falls somewhere in between. \nUNDERSTANDING THE DEFAULT SCHEDULING ALGORITHM\nThe selection of a node can be broken down into two parts, as shown in figure 11.5:\n\uf0a1Filtering the list of all nodes to obtain a list of acceptable nodes the pod can be\nscheduled to.\n\uf0a1Prioritizing the acceptable nodes and choosing the best one. If multiple nodes\nhave the highest score, round-robin is used to ensure pods are deployed across\nall of them evenly.\n \n", "shape": "dot", "size": 10, "title": "319\nUnderstanding the architecture\nkubia-159041347-14j3i   0/1       Pending             0          0s\nkubia-159041347-14j3i   0/1       Pending             0          0s\nkubia-159041347-14j3i   0/1       ContainerCreating   0          1s\nkubia-159041347-14j3i   0/1       Running             0          3s\nkubia-159041347-14j3i   1/1       Running             0          5s\nkubia-159041347-14j3i   1/1       Terminating         0          9s\nkubia-159041347-14j3i   0/1       Terminating         0          17s\nkubia-159041347-14j3i   0/1       Terminating         0          17s\nkubia-159041347-14j3i   0/1       Terminating         0          17s\nYou can even have kubectl print out the whole YAML on each watch event like this:\n$ kubectl get pods -o yaml --watch\nThe watch mechanism is also used by the Scheduler, which is the next Control Plane\ncomponent you\u2019re going to learn more about.\n11.1.5 Understanding the Scheduler\nYou\u2019ve already learned that you don\u2019t usually specify which cluster node a pod should\nrun on. This is left to the Scheduler. From afar, the operation of the Scheduler looks\nsimple. All it does is wait for newly created pods through the API server\u2019s watch mech-\nanism and assign a node to each new pod that doesn\u2019t already have the node set. \n The Scheduler doesn\u2019t instruct the selected node (or the Kubelet running on that\nnode) to run the pod. All the Scheduler does is update the pod definition through the\nAPI server. The API server then notifies the Kubelet (again, through the watch mech-\nanism described previously) that the pod has been scheduled. As soon as the Kubelet\non the target node sees the pod has been scheduled to its node, it creates and runs the\npod\u2019s containers.\n Although a coarse-grained view of the scheduling process seems trivial, the actual\ntask of selecting the best node for the pod isn\u2019t that simple. Sure, the simplest\nScheduler could pick a random node and not care about the pods already running on\nthat node. On the other side of the spectrum, the Scheduler could use advanced tech-\nniques such as machine learning to anticipate what kind of pods are about to be\nscheduled in the next minutes or hours and schedule pods to maximize future hard-\nware utilization without requiring any rescheduling of existing pods. Kubernetes\u2019\ndefault Scheduler falls somewhere in between. \nUNDERSTANDING THE DEFAULT SCHEDULING ALGORITHM\nThe selection of a node can be broken down into two parts, as shown in figure 11.5:\n\uf0a1Filtering the list of all nodes to obtain a list of acceptable nodes the pod can be\nscheduled to.\n\uf0a1Prioritizing the acceptable nodes and choosing the best one. If multiple nodes\nhave the highest score, round-robin is used to ensure pods are deployed across\nall of them evenly.\n \n"}, {"color": "green", "id": "text_263", "label": "320\nCHAPTER 11\nUnderstanding Kubernetes internals\nFINDING ACCEPTABLE NODES\nTo determine which nodes are acceptable for the pod, the Scheduler passes each\nnode through a list of configured predicate functions. These check various things\nsuch as\n\uf0a1Can the node fulfill the pod\u2019s requests for hardware resources? You\u2019ll learn how\nto specify them in chapter 14.\n\uf0a1Is the node running out of resources (is it reporting a memory or a disk pres-\nsure condition)? \n\uf0a1If the pod requests to be scheduled to a specific node (by name), is this the node?\n\uf0a1Does the node have a label that matches the node selector in the pod specifica-\ntion (if one is defined)?\n\uf0a1If the pod requests to be bound to a specific host port (discussed in chapter 13),\nis that port already taken on this node or not? \n\uf0a1If the pod requests a certain type of volume, can this volume be mounted for\nthis pod on this node, or is another pod on the node already using the same\nvolume?\n\uf0a1Does the pod tolerate the taints of the node? Taints and tolerations are explained\nin chapter 16.\n\uf0a1Does the pod specify node and/or pod affinity or anti-affinity rules? If yes,\nwould scheduling the pod to this node break those rules? This is also explained\nin chapter 16.\nAll these checks must pass for the node to be eligible to host the pod. After perform-\ning these checks on every node, the Scheduler ends up with a subset of the nodes. Any\nof these nodes could run the pod, because they have enough available resources for\nthe pod and conform to all requirements you\u2019ve specified in the pod definition.\nSELECTING THE BEST NODE FOR THE POD\nEven though all these nodes are acceptable and can run the pod, several may be a\nbetter choice than others. Suppose you have a two-node cluster. Both nodes are eli-\ngible, but one is already running 10 pods, while the other, for whatever reason, isn\u2019t\nrunning any pods right now. It\u2019s obvious the Scheduler should favor the second\nnode in this case. \nNode 1\nNode 2\nNode 3\nNode 4\nNode 5\n...\nFind acceptable\nnodes\nNode 1\nNode 2\nNode 3\nNode 4\nNode 5\n...\nPrioritize nodes\nand select the\ntop one\nNode 3\nNode 1\nNode 4\nFigure 11.5\nThe Scheduler finds acceptable nodes for a pod and then selects the best node \nfor the pod.\n \n", "shape": "dot", "size": 10, "title": "320\nCHAPTER 11\nUnderstanding Kubernetes internals\nFINDING ACCEPTABLE NODES\nTo determine which nodes are acceptable for the pod, the Scheduler passes each\nnode through a list of configured predicate functions. These check various things\nsuch as\n\uf0a1Can the node fulfill the pod\u2019s requests for hardware resources? You\u2019ll learn how\nto specify them in chapter 14.\n\uf0a1Is the node running out of resources (is it reporting a memory or a disk pres-\nsure condition)? \n\uf0a1If the pod requests to be scheduled to a specific node (by name), is this the node?\n\uf0a1Does the node have a label that matches the node selector in the pod specifica-\ntion (if one is defined)?\n\uf0a1If the pod requests to be bound to a specific host port (discussed in chapter 13),\nis that port already taken on this node or not? \n\uf0a1If the pod requests a certain type of volume, can this volume be mounted for\nthis pod on this node, or is another pod on the node already using the same\nvolume?\n\uf0a1Does the pod tolerate the taints of the node? Taints and tolerations are explained\nin chapter 16.\n\uf0a1Does the pod specify node and/or pod affinity or anti-affinity rules? If yes,\nwould scheduling the pod to this node break those rules? This is also explained\nin chapter 16.\nAll these checks must pass for the node to be eligible to host the pod. After perform-\ning these checks on every node, the Scheduler ends up with a subset of the nodes. Any\nof these nodes could run the pod, because they have enough available resources for\nthe pod and conform to all requirements you\u2019ve specified in the pod definition.\nSELECTING THE BEST NODE FOR THE POD\nEven though all these nodes are acceptable and can run the pod, several may be a\nbetter choice than others. Suppose you have a two-node cluster. Both nodes are eli-\ngible, but one is already running 10 pods, while the other, for whatever reason, isn\u2019t\nrunning any pods right now. It\u2019s obvious the Scheduler should favor the second\nnode in this case. \nNode 1\nNode 2\nNode 3\nNode 4\nNode 5\n...\nFind acceptable\nnodes\nNode 1\nNode 2\nNode 3\nNode 4\nNode 5\n...\nPrioritize nodes\nand select the\ntop one\nNode 3\nNode 1\nNode 4\nFigure 11.5\nThe Scheduler finds acceptable nodes for a pod and then selects the best node \nfor the pod.\n \n"}, {"color": "green", "id": "text_264", "label": "321\nUnderstanding the architecture\n Or is it? If these two nodes are provided by the cloud infrastructure, it may be bet-\nter to schedule the pod to the first node and relinquish the second node back to the\ncloud provider to save money. \nADVANCED SCHEDULING OF PODS\nConsider another example. Imagine having multiple replicas of a pod. Ideally, you\u2019d\nwant them spread across as many nodes as possible instead of having them all sched-\nuled to a single one. Failure of that node would cause the service backed by those\npods to become unavailable. But if the pods were spread across different nodes, a sin-\ngle node failure would barely leave a dent in the service\u2019s capacity. \n Pods belonging to the same Service or ReplicaSet are spread across multiple nodes\nby default. It\u2019s not guaranteed that this is always the case. But you can force pods to be\nspread around the cluster or kept close together by defining pod affinity and anti-\naffinity rules, which are explained in chapter 16. \n Even these two simple cases show how complex scheduling can be, because it\ndepends on a multitude of factors. Because of this, the Scheduler can either be config-\nured to suit your specific needs or infrastructure specifics, or it can even be replaced\nwith a custom implementation altogether. You could also run a Kubernetes cluster\nwithout a Scheduler, but then you\u2019d have to perform the scheduling manually.\nUSING MULTIPLE SCHEDULERS\nInstead of running a single Scheduler in the cluster, you can run multiple Schedulers.\nThen, for each pod, you specify the Scheduler that should schedule this particular\npod by setting the schedulerName property in the pod spec.\n Pods without this property set are scheduled using the default Scheduler, and so\nare pods with schedulerName set to default-scheduler. All other pods are ignored by\nthe default Scheduler, so they need to be scheduled either manually or by another\nScheduler watching for such pods. \n You can implement your own Schedulers and deploy them in the cluster, or you\ncan deploy an additional instance of Kubernetes\u2019 Scheduler with different configura-\ntion options.\n11.1.6 Introducing the controllers running in the Controller Manager\nAs previously mentioned, the API server doesn\u2019t do anything except store resources in\netcd and notify clients about the change. The Scheduler only assigns a node to the\npod, so you need other active components to make sure the actual state of the system\nconverges toward the desired state, as specified in the resources deployed through the\nAPI server. This work is done by controllers running inside the Controller Manager. \n The single Controller Manager process currently combines a multitude of control-\nlers performing various reconciliation tasks. Eventually those controllers will be split\nup into separate processes, enabling you to replace each one with a custom imple-\nmentation if necessary. The list of these controllers includes the\n\uf0a1Replication Manager (a controller for ReplicationController resources)\n\uf0a1ReplicaSet, DaemonSet, and Job controllers\n \n", "shape": "dot", "size": 10, "title": "321\nUnderstanding the architecture\n Or is it? If these two nodes are provided by the cloud infrastructure, it may be bet-\nter to schedule the pod to the first node and relinquish the second node back to the\ncloud provider to save money. \nADVANCED SCHEDULING OF PODS\nConsider another example. Imagine having multiple replicas of a pod. Ideally, you\u2019d\nwant them spread across as many nodes as possible instead of having them all sched-\nuled to a single one. Failure of that node would cause the service backed by those\npods to become unavailable. But if the pods were spread across different nodes, a sin-\ngle node failure would barely leave a dent in the service\u2019s capacity. \n Pods belonging to the same Service or ReplicaSet are spread across multiple nodes\nby default. It\u2019s not guaranteed that this is always the case. But you can force pods to be\nspread around the cluster or kept close together by defining pod affinity and anti-\naffinity rules, which are explained in chapter 16. \n Even these two simple cases show how complex scheduling can be, because it\ndepends on a multitude of factors. Because of this, the Scheduler can either be config-\nured to suit your specific needs or infrastructure specifics, or it can even be replaced\nwith a custom implementation altogether. You could also run a Kubernetes cluster\nwithout a Scheduler, but then you\u2019d have to perform the scheduling manually.\nUSING MULTIPLE SCHEDULERS\nInstead of running a single Scheduler in the cluster, you can run multiple Schedulers.\nThen, for each pod, you specify the Scheduler that should schedule this particular\npod by setting the schedulerName property in the pod spec.\n Pods without this property set are scheduled using the default Scheduler, and so\nare pods with schedulerName set to default-scheduler. All other pods are ignored by\nthe default Scheduler, so they need to be scheduled either manually or by another\nScheduler watching for such pods. \n You can implement your own Schedulers and deploy them in the cluster, or you\ncan deploy an additional instance of Kubernetes\u2019 Scheduler with different configura-\ntion options.\n11.1.6 Introducing the controllers running in the Controller Manager\nAs previously mentioned, the API server doesn\u2019t do anything except store resources in\netcd and notify clients about the change. The Scheduler only assigns a node to the\npod, so you need other active components to make sure the actual state of the system\nconverges toward the desired state, as specified in the resources deployed through the\nAPI server. This work is done by controllers running inside the Controller Manager. \n The single Controller Manager process currently combines a multitude of control-\nlers performing various reconciliation tasks. Eventually those controllers will be split\nup into separate processes, enabling you to replace each one with a custom imple-\nmentation if necessary. The list of these controllers includes the\n\uf0a1Replication Manager (a controller for ReplicationController resources)\n\uf0a1ReplicaSet, DaemonSet, and Job controllers\n \n"}, {"color": "green", "id": "text_265", "label": "322\nCHAPTER 11\nUnderstanding Kubernetes internals\n\uf0a1Deployment controller\n\uf0a1StatefulSet controller\n\uf0a1Node controller\n\uf0a1Service controller\n\uf0a1Endpoints controller\n\uf0a1Namespace controller\n\uf0a1PersistentVolume controller\n\uf0a1Others\nWhat each of these controllers does should be evident from its name. From the list,\nyou can tell there\u2019s a controller for almost every resource you can create. Resources\nare descriptions of what should be running in the cluster, whereas the controllers are\nthe active Kubernetes components that perform actual work as a result of the deployed\nresources.\nUNDERSTANDING WHAT CONTROLLERS DO AND HOW THEY DO IT\nControllers do many different things, but they all watch the API server for changes to\nresources (Deployments, Services, and so on) and perform operations for each change,\nwhether it\u2019s a creation of a new object or an update or deletion of an existing object.\nMost of the time, these operations include creating other resources or updating the\nwatched resources themselves (to update the object\u2019s status, for example).\n In general, controllers run a reconciliation loop, which reconciles the actual state\nwith the desired state (specified in the resource\u2019s spec section) and writes the new\nactual state to the resource\u2019s status section. Controllers use the watch mechanism to\nbe notified of changes, but because using watches doesn\u2019t guarantee the controller\nwon\u2019t miss an event, they also perform a re-list operation periodically to make sure\nthey haven\u2019t missed anything.\n Controllers never talk to each other directly. They don\u2019t even know any other con-\ntrollers exist. Each controller connects to the API server and, through the watch\nmechanism described in section 11.1.3, asks to be notified when a change occurs in\nthe list of resources of any type the controller is responsible for. \n We\u2019ll briefly look at what each of the controllers does, but if you\u2019d like an in-depth\nview of what they do, I suggest you look at their source code directly. The sidebar\nexplains how to get started.\nA few pointers on exploring the controllers\u2019 source code\nIf you\u2019re interested in seeing exactly how these controllers operate, I strongly encour-\nage you to browse through their source code. To make it easier, here are a few tips:\nThe source code for the controllers is available at https:/\n/github.com/kubernetes/\nkubernetes/blob/master/pkg/controller.\nEach controller usually has a constructor in which it creates an Informer, which is\nbasically a listener that gets called every time an API object gets updated. Usually,\n \n", "shape": "dot", "size": 10, "title": "322\nCHAPTER 11\nUnderstanding Kubernetes internals\n\uf0a1Deployment controller\n\uf0a1StatefulSet controller\n\uf0a1Node controller\n\uf0a1Service controller\n\uf0a1Endpoints controller\n\uf0a1Namespace controller\n\uf0a1PersistentVolume controller\n\uf0a1Others\nWhat each of these controllers does should be evident from its name. From the list,\nyou can tell there\u2019s a controller for almost every resource you can create. Resources\nare descriptions of what should be running in the cluster, whereas the controllers are\nthe active Kubernetes components that perform actual work as a result of the deployed\nresources.\nUNDERSTANDING WHAT CONTROLLERS DO AND HOW THEY DO IT\nControllers do many different things, but they all watch the API server for changes to\nresources (Deployments, Services, and so on) and perform operations for each change,\nwhether it\u2019s a creation of a new object or an update or deletion of an existing object.\nMost of the time, these operations include creating other resources or updating the\nwatched resources themselves (to update the object\u2019s status, for example).\n In general, controllers run a reconciliation loop, which reconciles the actual state\nwith the desired state (specified in the resource\u2019s spec section) and writes the new\nactual state to the resource\u2019s status section. Controllers use the watch mechanism to\nbe notified of changes, but because using watches doesn\u2019t guarantee the controller\nwon\u2019t miss an event, they also perform a re-list operation periodically to make sure\nthey haven\u2019t missed anything.\n Controllers never talk to each other directly. They don\u2019t even know any other con-\ntrollers exist. Each controller connects to the API server and, through the watch\nmechanism described in section 11.1.3, asks to be notified when a change occurs in\nthe list of resources of any type the controller is responsible for. \n We\u2019ll briefly look at what each of the controllers does, but if you\u2019d like an in-depth\nview of what they do, I suggest you look at their source code directly. The sidebar\nexplains how to get started.\nA few pointers on exploring the controllers\u2019 source code\nIf you\u2019re interested in seeing exactly how these controllers operate, I strongly encour-\nage you to browse through their source code. To make it easier, here are a few tips:\nThe source code for the controllers is available at https:/\n/github.com/kubernetes/\nkubernetes/blob/master/pkg/controller.\nEach controller usually has a constructor in which it creates an Informer, which is\nbasically a listener that gets called every time an API object gets updated. Usually,\n \n"}, {"color": "green", "id": "text_266", "label": "323\nUnderstanding the architecture\nTHE REPLICATION MANAGER\nThe controller that makes ReplicationController resources come to life is called the\nReplication Manager. We talked about how ReplicationControllers work in chapter 4.\nIt\u2019s not the ReplicationControllers that do the actual work, but the Replication Man-\nager. Let\u2019s quickly review what the controller does, because this will help you under-\nstand the rest of the controllers.\n In chapter 4, we said that the operation of a ReplicationController could be\nthought of as an infinite loop, where in each iteration, the controller finds the num-\nber of pods matching its pod selector and compares the number to the desired replica\ncount. \n Now that you know how the API server can notify clients through the watch\nmechanism, it\u2019s clear that the controller doesn\u2019t poll the pods in every iteration, but\nis instead notified by the watch mechanism of each change that may affect the\ndesired replica count or the number of matched pods (see figure 11.6). Any such\nchanges trigger the controller to recheck the desired vs. actual replica count and act\naccordingly.\n You already know that when too few pod instances are running, the Replication-\nController runs additional instances. But it doesn\u2019t actually run them itself. It creates\nan Informer listens for changes to a specific type of resource. Looking at the con-\nstructor will show you which resources the controller is watching.\nNext, go look for the worker() method. In it, you\u2019ll find the method that gets invoked\neach time the controller needs to do something. The actual function is often stored\nin a field called syncHandler or something similar. This field is also initialized in the\nconstructor, so that\u2019s where you\u2019ll find the name of the function that gets called. That\nfunction is the place where all the magic happens.\nController Manager\nWatches\nCreates and\ndeletes\nReplication\nManager\nAPI server\nReplicationController\nresources\nPod resources\nOther resources\nFigure 11.6\nThe Replication Manager watches for changes to API \nobjects.\n \n", "shape": "dot", "size": 10, "title": "323\nUnderstanding the architecture\nTHE REPLICATION MANAGER\nThe controller that makes ReplicationController resources come to life is called the\nReplication Manager. We talked about how ReplicationControllers work in chapter 4.\nIt\u2019s not the ReplicationControllers that do the actual work, but the Replication Man-\nager. Let\u2019s quickly review what the controller does, because this will help you under-\nstand the rest of the controllers.\n In chapter 4, we said that the operation of a ReplicationController could be\nthought of as an infinite loop, where in each iteration, the controller finds the num-\nber of pods matching its pod selector and compares the number to the desired replica\ncount. \n Now that you know how the API server can notify clients through the watch\nmechanism, it\u2019s clear that the controller doesn\u2019t poll the pods in every iteration, but\nis instead notified by the watch mechanism of each change that may affect the\ndesired replica count or the number of matched pods (see figure 11.6). Any such\nchanges trigger the controller to recheck the desired vs. actual replica count and act\naccordingly.\n You already know that when too few pod instances are running, the Replication-\nController runs additional instances. But it doesn\u2019t actually run them itself. It creates\nan Informer listens for changes to a specific type of resource. Looking at the con-\nstructor will show you which resources the controller is watching.\nNext, go look for the worker() method. In it, you\u2019ll find the method that gets invoked\neach time the controller needs to do something. The actual function is often stored\nin a field called syncHandler or something similar. This field is also initialized in the\nconstructor, so that\u2019s where you\u2019ll find the name of the function that gets called. That\nfunction is the place where all the magic happens.\nController Manager\nWatches\nCreates and\ndeletes\nReplication\nManager\nAPI server\nReplicationController\nresources\nPod resources\nOther resources\nFigure 11.6\nThe Replication Manager watches for changes to API \nobjects.\n \n"}, {"color": "green", "id": "text_267", "label": "324\nCHAPTER 11\nUnderstanding Kubernetes internals\nnew Pod manifests, posts them to the API server, and lets the Scheduler and the\nKubelet do their job of scheduling and running the pod.\n The Replication Manager performs its work by manipulating Pod API objects\nthrough the API server. This is how all controllers operate.\nTHE REPLICASET, THE DAEMONSET, AND THE JOB CONTROLLERS\nThe ReplicaSet controller does almost the same thing as the Replication Manager\ndescribed previously, so we don\u2019t have much to add here. The DaemonSet and Job\ncontrollers are similar. They create Pod resources from the pod template defined in\ntheir respective resources. Like the Replication Manager, these controllers don\u2019t run\nthe pods, but post Pod definitions to the API server, letting the Kubelet create their\ncontainers and run them.\nTHE DEPLOYMENT CONTROLLER\nThe Deployment controller takes care of keeping the actual state of a deployment in\nsync with the desired state specified in the corresponding Deployment API object. \n The Deployment controller performs a rollout of a new version each time a\nDeployment object is modified (if the modification should affect the deployed pods).\nIt does this by creating a ReplicaSet and then appropriately scaling both the old and\nthe new ReplicaSet based on the strategy specified in the Deployment, until all the old\npods have been replaced with new ones. It doesn\u2019t create any pods directly.\nTHE STATEFULSET CONTROLLER\nThe StatefulSet controller, similarly to the ReplicaSet controller and other related\ncontrollers, creates, manages, and deletes Pods according to the spec of a StatefulSet\nresource. But while those other controllers only manage Pods, the StatefulSet control-\nler also instantiates and manages PersistentVolumeClaims for each Pod instance.\nTHE NODE CONTROLLER\nThe Node controller manages the Node resources, which describe the cluster\u2019s worker\nnodes. Among other things, a Node controller keeps the list of Node objects in sync\nwith the actual list of machines running in the cluster. It also monitors each node\u2019s\nhealth and evicts pods from unreachable nodes.\n The Node controller isn\u2019t the only component making changes to Node objects.\nThey\u2019re also changed by the Kubelet, and can obviously also be modified by users\nthrough REST API calls. \nTHE SERVICE CONTROLLER\nIn chapter 5, when we talked about Services, you learned that a few different types\nexist. One of them was the LoadBalancer service, which requests a load balancer from\nthe infrastructure to make the service available externally. The Service controller is\nthe one requesting and releasing a load balancer from the infrastructure, when a\nLoadBalancer-type Service is created or deleted.\n \n", "shape": "dot", "size": 10, "title": "324\nCHAPTER 11\nUnderstanding Kubernetes internals\nnew Pod manifests, posts them to the API server, and lets the Scheduler and the\nKubelet do their job of scheduling and running the pod.\n The Replication Manager performs its work by manipulating Pod API objects\nthrough the API server. This is how all controllers operate.\nTHE REPLICASET, THE DAEMONSET, AND THE JOB CONTROLLERS\nThe ReplicaSet controller does almost the same thing as the Replication Manager\ndescribed previously, so we don\u2019t have much to add here. The DaemonSet and Job\ncontrollers are similar. They create Pod resources from the pod template defined in\ntheir respective resources. Like the Replication Manager, these controllers don\u2019t run\nthe pods, but post Pod definitions to the API server, letting the Kubelet create their\ncontainers and run them.\nTHE DEPLOYMENT CONTROLLER\nThe Deployment controller takes care of keeping the actual state of a deployment in\nsync with the desired state specified in the corresponding Deployment API object. \n The Deployment controller performs a rollout of a new version each time a\nDeployment object is modified (if the modification should affect the deployed pods).\nIt does this by creating a ReplicaSet and then appropriately scaling both the old and\nthe new ReplicaSet based on the strategy specified in the Deployment, until all the old\npods have been replaced with new ones. It doesn\u2019t create any pods directly.\nTHE STATEFULSET CONTROLLER\nThe StatefulSet controller, similarly to the ReplicaSet controller and other related\ncontrollers, creates, manages, and deletes Pods according to the spec of a StatefulSet\nresource. But while those other controllers only manage Pods, the StatefulSet control-\nler also instantiates and manages PersistentVolumeClaims for each Pod instance.\nTHE NODE CONTROLLER\nThe Node controller manages the Node resources, which describe the cluster\u2019s worker\nnodes. Among other things, a Node controller keeps the list of Node objects in sync\nwith the actual list of machines running in the cluster. It also monitors each node\u2019s\nhealth and evicts pods from unreachable nodes.\n The Node controller isn\u2019t the only component making changes to Node objects.\nThey\u2019re also changed by the Kubelet, and can obviously also be modified by users\nthrough REST API calls. \nTHE SERVICE CONTROLLER\nIn chapter 5, when we talked about Services, you learned that a few different types\nexist. One of them was the LoadBalancer service, which requests a load balancer from\nthe infrastructure to make the service available externally. The Service controller is\nthe one requesting and releasing a load balancer from the infrastructure, when a\nLoadBalancer-type Service is created or deleted.\n \n"}, {"color": "green", "id": "text_268", "label": "325\nUnderstanding the architecture\nTHE ENDPOINTS CONTROLLER\nYou\u2019ll remember that Services aren\u2019t linked directly to pods, but instead contain a list\nof endpoints (IPs and ports), which is created and updated either manually or auto-\nmatically according to the pod selector defined on the Service. The Endpoints con-\ntroller is the active component that keeps the endpoint list constantly updated with\nthe IPs and ports of pods matching the label selector.\n As figure 11.7 shows, the controller watches both Services and Pods. When\nServices are added or updated or Pods are added, updated, or deleted, it selects Pods\nmatching the Service\u2019s pod selector and adds their IPs and ports to the Endpoints\nresource. Remember, the Endpoints object is a standalone object, so the controller\ncreates it if necessary. Likewise, it also deletes the Endpoints object when the Service is\ndeleted.\nTHE NAMESPACE CONTROLLER\nRemember namespaces (we talked about them in chapter 3)? Most resources belong\nto a specific namespace. When a Namespace resource is deleted, all the resources in\nthat namespace must also be deleted. This is what the Namespace controller does.\nWhen it\u2019s notified of the deletion of a Namespace object, it deletes all the resources\nbelonging to the namespace through the API server. \nTHE PERSISTENTVOLUME CONTROLLER\nIn chapter 6 you learned about PersistentVolumes and PersistentVolumeClaims.\nOnce a user creates a PersistentVolumeClaim, Kubernetes must find an appropriate\nPersistentVolume and bind it to the claim. This is performed by the PersistentVolume\ncontroller. \n When a PersistentVolumeClaim pops up, the controller finds the best match for\nthe claim by selecting the smallest PersistentVolume with the access mode matching\nthe one requested in the claim and the declared capacity above the capacity requested\nController Manager\nWatches\nCreates, modi\ufb01es,\nand deletes\nEndpoints\ncontroller\nAPI server\nService resources\nPod resources\nEndpoints resources\nFigure 11.7\nThe Endpoints controller watches Service and Pod resources, \nand manages Endpoints.\n \n", "shape": "dot", "size": 10, "title": "325\nUnderstanding the architecture\nTHE ENDPOINTS CONTROLLER\nYou\u2019ll remember that Services aren\u2019t linked directly to pods, but instead contain a list\nof endpoints (IPs and ports), which is created and updated either manually or auto-\nmatically according to the pod selector defined on the Service. The Endpoints con-\ntroller is the active component that keeps the endpoint list constantly updated with\nthe IPs and ports of pods matching the label selector.\n As figure 11.7 shows, the controller watches both Services and Pods. When\nServices are added or updated or Pods are added, updated, or deleted, it selects Pods\nmatching the Service\u2019s pod selector and adds their IPs and ports to the Endpoints\nresource. Remember, the Endpoints object is a standalone object, so the controller\ncreates it if necessary. Likewise, it also deletes the Endpoints object when the Service is\ndeleted.\nTHE NAMESPACE CONTROLLER\nRemember namespaces (we talked about them in chapter 3)? Most resources belong\nto a specific namespace. When a Namespace resource is deleted, all the resources in\nthat namespace must also be deleted. This is what the Namespace controller does.\nWhen it\u2019s notified of the deletion of a Namespace object, it deletes all the resources\nbelonging to the namespace through the API server. \nTHE PERSISTENTVOLUME CONTROLLER\nIn chapter 6 you learned about PersistentVolumes and PersistentVolumeClaims.\nOnce a user creates a PersistentVolumeClaim, Kubernetes must find an appropriate\nPersistentVolume and bind it to the claim. This is performed by the PersistentVolume\ncontroller. \n When a PersistentVolumeClaim pops up, the controller finds the best match for\nthe claim by selecting the smallest PersistentVolume with the access mode matching\nthe one requested in the claim and the declared capacity above the capacity requested\nController Manager\nWatches\nCreates, modi\ufb01es,\nand deletes\nEndpoints\ncontroller\nAPI server\nService resources\nPod resources\nEndpoints resources\nFigure 11.7\nThe Endpoints controller watches Service and Pod resources, \nand manages Endpoints.\n \n"}, {"color": "green", "id": "text_269", "label": "326\nCHAPTER 11\nUnderstanding Kubernetes internals\nin the claim. It does this by keeping an ordered list of PersistentVolumes for each\naccess mode by ascending capacity and returning the first volume from the list.\n Then, when the user deletes the PersistentVolumeClaim, the volume is unbound\nand reclaimed according to the volume\u2019s reclaim policy (left as is, deleted, or emptied).\nCONTROLLER WRAP-UP\nYou should now have a good feel for what each controller does and how controllers\nwork in general. Again, all these controllers operate on the API objects through the\nAPI server. They don\u2019t communicate with the Kubelets directly or issue any kind of\ninstructions to them. In fact, they don\u2019t even know Kubelets exist. After a controller\nupdates a resource in the API server, the Kubelets and Kubernetes Service Proxies,\nalso oblivious of the controllers\u2019 existence, perform their work, such as spinning up a\npod\u2019s containers and attaching network storage to them, or in the case of services, set-\nting up the actual load balancing across pods. \n The Control Plane handles one part of the operation of the whole system, so to\nfully understand how things unfold in a Kubernetes cluster, you also need to under-\nstand what the Kubelet and the Kubernetes Service Proxy do. We\u2019ll learn that next.\n11.1.7 What the Kubelet does\nIn contrast to all the controllers, which are part of the Kubernetes Control Plane and\nrun on the master node(s), the Kubelet and the Service Proxy both run on the worker\nnodes, where the actual pods containers run. What does the Kubelet do exactly?\nUNDERSTANDING THE KUBELET\u2019S JOB\nIn a nutshell, the Kubelet is the component responsible for everything running on a\nworker node. Its initial job is to register the node it\u2019s running on by creating a Node\nresource in the API server. Then it needs to continuously monitor the API server for\nPods that have been scheduled to the node, and start the pod\u2019s containers. It does this\nby telling the configured container runtime (which is Docker, CoreOS\u2019 rkt, or some-\nthing else) to run a container from a specific container image. The Kubelet then con-\nstantly monitors running containers and reports their status, events, and resource\nconsumption to the API server. \n The Kubelet is also the component that runs the container liveness probes, restart-\ning containers when the probes fail. Lastly, it terminates containers when their Pod is\ndeleted from the API server and notifies the server that the pod has terminated.\nRUNNING STATIC PODS WITHOUT THE API SERVER\nAlthough the Kubelet talks to the Kubernetes API server and gets the pod manifests\nfrom there, it can also run pods based on pod manifest files in a specific local direc-\ntory as shown in figure 11.8. This feature is used to run the containerized versions of\nthe Control Plane components as pods, as you saw in the beginning of the chapter.\n Instead of running Kubernetes system components natively, you can put their pod\nmanifests into the Kubelet\u2019s manifest directory and have the Kubelet run and manage\n \n", "shape": "dot", "size": 10, "title": "326\nCHAPTER 11\nUnderstanding Kubernetes internals\nin the claim. It does this by keeping an ordered list of PersistentVolumes for each\naccess mode by ascending capacity and returning the first volume from the list.\n Then, when the user deletes the PersistentVolumeClaim, the volume is unbound\nand reclaimed according to the volume\u2019s reclaim policy (left as is, deleted, or emptied).\nCONTROLLER WRAP-UP\nYou should now have a good feel for what each controller does and how controllers\nwork in general. Again, all these controllers operate on the API objects through the\nAPI server. They don\u2019t communicate with the Kubelets directly or issue any kind of\ninstructions to them. In fact, they don\u2019t even know Kubelets exist. After a controller\nupdates a resource in the API server, the Kubelets and Kubernetes Service Proxies,\nalso oblivious of the controllers\u2019 existence, perform their work, such as spinning up a\npod\u2019s containers and attaching network storage to them, or in the case of services, set-\nting up the actual load balancing across pods. \n The Control Plane handles one part of the operation of the whole system, so to\nfully understand how things unfold in a Kubernetes cluster, you also need to under-\nstand what the Kubelet and the Kubernetes Service Proxy do. We\u2019ll learn that next.\n11.1.7 What the Kubelet does\nIn contrast to all the controllers, which are part of the Kubernetes Control Plane and\nrun on the master node(s), the Kubelet and the Service Proxy both run on the worker\nnodes, where the actual pods containers run. What does the Kubelet do exactly?\nUNDERSTANDING THE KUBELET\u2019S JOB\nIn a nutshell, the Kubelet is the component responsible for everything running on a\nworker node. Its initial job is to register the node it\u2019s running on by creating a Node\nresource in the API server. Then it needs to continuously monitor the API server for\nPods that have been scheduled to the node, and start the pod\u2019s containers. It does this\nby telling the configured container runtime (which is Docker, CoreOS\u2019 rkt, or some-\nthing else) to run a container from a specific container image. The Kubelet then con-\nstantly monitors running containers and reports their status, events, and resource\nconsumption to the API server. \n The Kubelet is also the component that runs the container liveness probes, restart-\ning containers when the probes fail. Lastly, it terminates containers when their Pod is\ndeleted from the API server and notifies the server that the pod has terminated.\nRUNNING STATIC PODS WITHOUT THE API SERVER\nAlthough the Kubelet talks to the Kubernetes API server and gets the pod manifests\nfrom there, it can also run pods based on pod manifest files in a specific local direc-\ntory as shown in figure 11.8. This feature is used to run the containerized versions of\nthe Control Plane components as pods, as you saw in the beginning of the chapter.\n Instead of running Kubernetes system components natively, you can put their pod\nmanifests into the Kubelet\u2019s manifest directory and have the Kubelet run and manage\n \n"}, {"color": "green", "id": "text_270", "label": "327\nUnderstanding the architecture\nthem. You can also use the same method to run your custom system containers, but\ndoing it through a DaemonSet is the recommended method.\n11.1.8 The role of the Kubernetes Service Proxy\nBeside the Kubelet, every worker node also runs the kube-proxy, whose purpose is to\nmake sure clients can connect to the services you define through the Kubernetes API.\nThe kube-proxy makes sure connections to the service IP and port end up at one of\nthe pods backing that service (or other, non-pod service endpoints). When a service is\nbacked by more than one pod, the proxy performs load balancing across those pods. \nWHY IT\u2019S CALLED A PROXY\nThe initial implementation of the kube-proxy was the userspace proxy. It used an\nactual server process to accept connections and proxy them to the pods. To inter-\ncept connections destined to the service IPs, the proxy configured iptables rules\n(iptables is the tool for managing the Linux kernel\u2019s packet filtering features) to\nredirect the connections to the proxy server. A rough diagram of the userspace proxy\nmode is shown in figure 11.9.\nContainer Runtime\n(Docker, rkt, ...)\nKubelet\nAPI server\nWorker node\nRuns, monitors,\nand manages\ncontainers\nPod resource\nContainer A\nContainer B\nContainer A\nContainer B\nContainer C\nPod manifest (\ufb01le)\nLocal manifest directory\nContainer C\nFigure 11.8\nThe Kubelet runs pods based on pod specs from the API server and a local file directory.\nClient\nkube-proxy\nCon\ufb01gures\n:\niptables\nredirect through proxy server\niptables\nPod\nFigure 11.9\nThe userspace proxy mode\n \n", "shape": "dot", "size": 10, "title": "327\nUnderstanding the architecture\nthem. You can also use the same method to run your custom system containers, but\ndoing it through a DaemonSet is the recommended method.\n11.1.8 The role of the Kubernetes Service Proxy\nBeside the Kubelet, every worker node also runs the kube-proxy, whose purpose is to\nmake sure clients can connect to the services you define through the Kubernetes API.\nThe kube-proxy makes sure connections to the service IP and port end up at one of\nthe pods backing that service (or other, non-pod service endpoints). When a service is\nbacked by more than one pod, the proxy performs load balancing across those pods. \nWHY IT\u2019S CALLED A PROXY\nThe initial implementation of the kube-proxy was the userspace proxy. It used an\nactual server process to accept connections and proxy them to the pods. To inter-\ncept connections destined to the service IPs, the proxy configured iptables rules\n(iptables is the tool for managing the Linux kernel\u2019s packet filtering features) to\nredirect the connections to the proxy server. A rough diagram of the userspace proxy\nmode is shown in figure 11.9.\nContainer Runtime\n(Docker, rkt, ...)\nKubelet\nAPI server\nWorker node\nRuns, monitors,\nand manages\ncontainers\nPod resource\nContainer A\nContainer B\nContainer A\nContainer B\nContainer C\nPod manifest (\ufb01le)\nLocal manifest directory\nContainer C\nFigure 11.8\nThe Kubelet runs pods based on pod specs from the API server and a local file directory.\nClient\nkube-proxy\nCon\ufb01gures\n:\niptables\nredirect through proxy server\niptables\nPod\nFigure 11.9\nThe userspace proxy mode\n \n"}, {"color": "green", "id": "text_271", "label": "328\nCHAPTER 11\nUnderstanding Kubernetes internals\nThe kube-proxy got its name because it was an actual proxy, but the current, much\nbetter performing implementation only uses iptables rules to redirect packets to a\nrandomly selected backend pod without passing them through an actual proxy server.\nThis mode is called the iptables proxy mode and is shown in figure 11.10.\nThe major difference between these two modes is whether packets pass through the\nkube-proxy and must be handled in user space, or whether they\u2019re handled only by\nthe Kernel (in kernel space). This has a major impact on performance. \n Another smaller difference is that the userspace proxy mode balanced connec-\ntions across pods in a true round-robin fashion, while the iptables proxy mode\ndoesn\u2019t\u2014it selects pods randomly. When only a few clients use a service, they may not\nbe spread evenly across pods. For example, if a service has two backing pods but only\nfive or so clients, don\u2019t be surprised if you see four clients connect to pod A and only\none client connect to pod B. With a higher number of clients or pods, this problem\nisn\u2019t so apparent.\n You\u2019ll learn exactly how iptables proxy mode works in section 11.5. \n11.1.9 Introducing Kubernetes add-ons\nWe\u2019ve now discussed the core components that make a Kubernetes cluster work. But\nin the beginning of the chapter, we also listed a few add-ons, which although not\nalways required, enable features such as DNS lookup of Kubernetes services, exposing\nmultiple HTTP services through a single external IP address, the Kubernetes web\ndashboard, and so on.\nHOW ADD-ONS ARE DEPLOYED\nThese components are available as add-ons and are deployed as pods by submitting\nYAML manifests to the API server, the way you\u2019ve been doing throughout the book.\nSome of these components are deployed through a Deployment resource or a Repli-\ncationController resource, and some through a DaemonSet. \n For example, as I\u2019m writing this, in Minikube, the Ingress controller and the\ndashboard add-ons are deployed as ReplicationControllers, as shown in the follow-\ning listing.\n \nClient\nCon\ufb01gures\n:\niptables\nredirect straight to pod\n(no proxy server in-between)\niptables\nPod\nkube-proxy\nFigure 11.10\nThe iptables proxy mode\n \n", "shape": "dot", "size": 10, "title": "328\nCHAPTER 11\nUnderstanding Kubernetes internals\nThe kube-proxy got its name because it was an actual proxy, but the current, much\nbetter performing implementation only uses iptables rules to redirect packets to a\nrandomly selected backend pod without passing them through an actual proxy server.\nThis mode is called the iptables proxy mode and is shown in figure 11.10.\nThe major difference between these two modes is whether packets pass through the\nkube-proxy and must be handled in user space, or whether they\u2019re handled only by\nthe Kernel (in kernel space). This has a major impact on performance. \n Another smaller difference is that the userspace proxy mode balanced connec-\ntions across pods in a true round-robin fashion, while the iptables proxy mode\ndoesn\u2019t\u2014it selects pods randomly. When only a few clients use a service, they may not\nbe spread evenly across pods. For example, if a service has two backing pods but only\nfive or so clients, don\u2019t be surprised if you see four clients connect to pod A and only\none client connect to pod B. With a higher number of clients or pods, this problem\nisn\u2019t so apparent.\n You\u2019ll learn exactly how iptables proxy mode works in section 11.5. \n11.1.9 Introducing Kubernetes add-ons\nWe\u2019ve now discussed the core components that make a Kubernetes cluster work. But\nin the beginning of the chapter, we also listed a few add-ons, which although not\nalways required, enable features such as DNS lookup of Kubernetes services, exposing\nmultiple HTTP services through a single external IP address, the Kubernetes web\ndashboard, and so on.\nHOW ADD-ONS ARE DEPLOYED\nThese components are available as add-ons and are deployed as pods by submitting\nYAML manifests to the API server, the way you\u2019ve been doing throughout the book.\nSome of these components are deployed through a Deployment resource or a Repli-\ncationController resource, and some through a DaemonSet. \n For example, as I\u2019m writing this, in Minikube, the Ingress controller and the\ndashboard add-ons are deployed as ReplicationControllers, as shown in the follow-\ning listing.\n \nClient\nCon\ufb01gures\n:\niptables\nredirect straight to pod\n(no proxy server in-between)\niptables\nPod\nkube-proxy\nFigure 11.10\nThe iptables proxy mode\n \n"}, {"color": "green", "id": "text_272", "label": "329\nUnderstanding the architecture\n$ kubectl get rc -n kube-system\nNAME                       DESIRED   CURRENT   READY     AGE\ndefault-http-backend       1         1         1         6d\nkubernetes-dashboard       1         1         1         6d\nnginx-ingress-controller   1         1         1         6d\nThe DNS add-on is deployed as a Deployment, as shown in the following listing.\n$ kubectl get deploy -n kube-system\nNAME       DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE\nkube-dns   1         1         1            1           6d\nLet\u2019s see how DNS and the Ingress controllers work.\nHOW THE DNS SERVER WORKS\nAll the pods in the cluster are configured to use the cluster\u2019s internal DNS server by\ndefault. This allows pods to easily look up services by name or even the pod\u2019s IP\naddresses in the case of headless services.\n The DNS server pod is exposed through the kube-dns service, allowing the pod to\nbe moved around the cluster, like any other pod. The service\u2019s IP address is specified\nas the nameserver in the /etc/resolv.conf file inside every container deployed in the\ncluster. The kube-dns pod uses the API server\u2019s watch mechanism to observe changes\nto Services and Endpoints and updates its DNS records with every change, allowing its\nclients to always get (fairly) up-to-date DNS information. I say fairly because during\nthe time between the update of the Service or Endpoints resource and the time the\nDNS pod receives the watch notification, the DNS records may be invalid.\nHOW (MOST) INGRESS CONTROLLERS WORK\nUnlike the DNS add-on, you\u2019ll find a few different implementations of Ingress con-\ntrollers, but most of them work in the same way. An Ingress controller runs a reverse\nproxy server (like Nginx, for example), and keeps it configured according to the\nIngress, Service, and Endpoints resources defined in the cluster. The controller thus\nneeds to observe those resources (again, through the watch mechanism) and change\nthe proxy server\u2019s config every time one of them changes. \n Although the Ingress resource\u2019s definition points to a Service, Ingress controllers\nforward traffic to the service\u2019s pod directly instead of going through the service IP.\nThis affects the preservation of client IPs when external clients connect through the\nIngress controller, which makes them preferred over Services in certain use cases.\nUSING OTHER ADD-ONS\nYou\u2019ve seen how both the DNS server and the Ingress controller add-ons are similar to\nthe controllers running in the Controller Manager, except that they also accept client\nconnections instead of only observing and modifying resources through the API server. \nListing 11.7\nAdd-ons deployed with ReplicationControllers in Minikube\nListing 11.8\nThe kube-dns Deployment \n \n", "shape": "dot", "size": 10, "title": "329\nUnderstanding the architecture\n$ kubectl get rc -n kube-system\nNAME                       DESIRED   CURRENT   READY     AGE\ndefault-http-backend       1         1         1         6d\nkubernetes-dashboard       1         1         1         6d\nnginx-ingress-controller   1         1         1         6d\nThe DNS add-on is deployed as a Deployment, as shown in the following listing.\n$ kubectl get deploy -n kube-system\nNAME       DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE\nkube-dns   1         1         1            1           6d\nLet\u2019s see how DNS and the Ingress controllers work.\nHOW THE DNS SERVER WORKS\nAll the pods in the cluster are configured to use the cluster\u2019s internal DNS server by\ndefault. This allows pods to easily look up services by name or even the pod\u2019s IP\naddresses in the case of headless services.\n The DNS server pod is exposed through the kube-dns service, allowing the pod to\nbe moved around the cluster, like any other pod. The service\u2019s IP address is specified\nas the nameserver in the /etc/resolv.conf file inside every container deployed in the\ncluster. The kube-dns pod uses the API server\u2019s watch mechanism to observe changes\nto Services and Endpoints and updates its DNS records with every change, allowing its\nclients to always get (fairly) up-to-date DNS information. I say fairly because during\nthe time between the update of the Service or Endpoints resource and the time the\nDNS pod receives the watch notification, the DNS records may be invalid.\nHOW (MOST) INGRESS CONTROLLERS WORK\nUnlike the DNS add-on, you\u2019ll find a few different implementations of Ingress con-\ntrollers, but most of them work in the same way. An Ingress controller runs a reverse\nproxy server (like Nginx, for example), and keeps it configured according to the\nIngress, Service, and Endpoints resources defined in the cluster. The controller thus\nneeds to observe those resources (again, through the watch mechanism) and change\nthe proxy server\u2019s config every time one of them changes. \n Although the Ingress resource\u2019s definition points to a Service, Ingress controllers\nforward traffic to the service\u2019s pod directly instead of going through the service IP.\nThis affects the preservation of client IPs when external clients connect through the\nIngress controller, which makes them preferred over Services in certain use cases.\nUSING OTHER ADD-ONS\nYou\u2019ve seen how both the DNS server and the Ingress controller add-ons are similar to\nthe controllers running in the Controller Manager, except that they also accept client\nconnections instead of only observing and modifying resources through the API server. \nListing 11.7\nAdd-ons deployed with ReplicationControllers in Minikube\nListing 11.8\nThe kube-dns Deployment \n \n"}, {"color": "green", "id": "text_273", "label": "330\nCHAPTER 11\nUnderstanding Kubernetes internals\n Other add-ons are similar. They all need to observe the cluster state and perform\nthe necessary actions when that changes. We\u2019ll introduce a few other add-ons in this\nand the remaining chapters.\n11.1.10Bringing it all together\nYou\u2019ve now learned that the whole Kubernetes system is composed of relatively small,\nloosely coupled components with good separation of concerns. The API server, the\nScheduler, the individual controllers running inside the Controller Manager, the\nKubelet, and the kube-proxy all work together to keep the actual state of the system\nsynchronized with what you specify as the desired state. \n For example, submitting a pod manifest to the API server triggers a coordinated\ndance of various Kubernetes components, which eventually results in the pod\u2019s con-\ntainers running. You\u2019ll learn how this dance unfolds in the next section. \n11.2\nHow controllers cooperate\nYou now know about all the components that a Kubernetes cluster is comprised of.\nNow, to solidify your understanding of how Kubernetes works, let\u2019s go over what hap-\npens when a Pod resource is created. Because you normally don\u2019t create Pods directly,\nyou\u2019re going to create a Deployment resource instead and see everything that must\nhappen for the pod\u2019s containers to be started.\n11.2.1 Understanding which components are involved\nEven before you start the whole process, the controllers, the Scheduler, and the\nKubelet are watching the API server for changes to their respective resource types.\nThis is shown in figure 11.11. The components depicted in the figure will each play a\npart in the process you\u2019re about to trigger. The diagram doesn\u2019t include etcd, because\nit\u2019s hidden behind the API server, and you can think of the API server as the place\nwhere objects are stored.\nMaster node\nController Manager\nWatches\nDeployment\ncontroller\nScheduler\nReplicaSet\ncontroller\nAPI server\nDeployments\nPods\nReplicaSets\nWatches\nWatches\nNode X\nWatches\nDocker\nKubelet\nFigure 11.11\nKubernetes components watching API objects through the API server\n \n", "shape": "dot", "size": 10, "title": "330\nCHAPTER 11\nUnderstanding Kubernetes internals\n Other add-ons are similar. They all need to observe the cluster state and perform\nthe necessary actions when that changes. We\u2019ll introduce a few other add-ons in this\nand the remaining chapters.\n11.1.10Bringing it all together\nYou\u2019ve now learned that the whole Kubernetes system is composed of relatively small,\nloosely coupled components with good separation of concerns. The API server, the\nScheduler, the individual controllers running inside the Controller Manager, the\nKubelet, and the kube-proxy all work together to keep the actual state of the system\nsynchronized with what you specify as the desired state. \n For example, submitting a pod manifest to the API server triggers a coordinated\ndance of various Kubernetes components, which eventually results in the pod\u2019s con-\ntainers running. You\u2019ll learn how this dance unfolds in the next section. \n11.2\nHow controllers cooperate\nYou now know about all the components that a Kubernetes cluster is comprised of.\nNow, to solidify your understanding of how Kubernetes works, let\u2019s go over what hap-\npens when a Pod resource is created. Because you normally don\u2019t create Pods directly,\nyou\u2019re going to create a Deployment resource instead and see everything that must\nhappen for the pod\u2019s containers to be started.\n11.2.1 Understanding which components are involved\nEven before you start the whole process, the controllers, the Scheduler, and the\nKubelet are watching the API server for changes to their respective resource types.\nThis is shown in figure 11.11. The components depicted in the figure will each play a\npart in the process you\u2019re about to trigger. The diagram doesn\u2019t include etcd, because\nit\u2019s hidden behind the API server, and you can think of the API server as the place\nwhere objects are stored.\nMaster node\nController Manager\nWatches\nDeployment\ncontroller\nScheduler\nReplicaSet\ncontroller\nAPI server\nDeployments\nPods\nReplicaSets\nWatches\nWatches\nNode X\nWatches\nDocker\nKubelet\nFigure 11.11\nKubernetes components watching API objects through the API server\n \n"}, {"color": "green", "id": "text_274", "label": "331\nHow controllers cooperate\n11.2.2 The chain of events\nImagine you prepared the YAML file containing the Deployment manifest and you\u2019re\nabout to submit it to Kubernetes through kubectl. kubectl sends the manifest to the\nKubernetes API server in an HTTP POST request. The API server validates the Deploy-\nment specification, stores it in etcd, and returns a response to kubectl. Now a chain\nof events starts to unfold, as shown in figure 11.12.\nTHE DEPLOYMENT CONTROLLER CREATES THE REPLICASET\nAll API server clients watching the list of Deployments through the API server\u2019s watch\nmechanism are notified of the newly created Deployment resource immediately after\nit\u2019s created. One of those clients is the Deployment controller, which, as we discussed\nearlier, is the active component responsible for handling Deployments. \n As you may remember from chapter 9, a Deployment is backed by one or more\nReplicaSets, which then create the actual pods. As a new Deployment object is\ndetected by the Deployment controller, it creates a ReplicaSet for the current speci-\nfication of the Deployment. This involves creating a new ReplicaSet resource\nthrough the Kubernetes API. The Deployment controller doesn\u2019t deal with individ-\nual pods at all.\nMaster node\nController\nManager\n2. Noti\ufb01cation\nthrough watch\n3. Creates\nReplicaSet\n4. Noti\ufb01cation\n5. Creates pod\n6. Noti\ufb01cation\nthrough watch\n7. Assigns pod to node\n1. Creates Deployment\nresource\nDeployment\ncontroller\nScheduler\nkubectl\nReplicaSet\ncontroller\nAPI server\nDeployment A\nDeployments\nReplicaSets\nPod A\nPods\nReplicaSet A\nNode X\n8. Noti\ufb01cation\nthrough watch\n9. Tells Docker to\nrun containers\nDocker\n10. Runs\ncontainers\nContainer(s)\nKubelet\nFigure 11.12\nThe chain of events that unfolds when a Deployment resource is posted to the API server\n \n", "shape": "dot", "size": 10, "title": "331\nHow controllers cooperate\n11.2.2 The chain of events\nImagine you prepared the YAML file containing the Deployment manifest and you\u2019re\nabout to submit it to Kubernetes through kubectl. kubectl sends the manifest to the\nKubernetes API server in an HTTP POST request. The API server validates the Deploy-\nment specification, stores it in etcd, and returns a response to kubectl. Now a chain\nof events starts to unfold, as shown in figure 11.12.\nTHE DEPLOYMENT CONTROLLER CREATES THE REPLICASET\nAll API server clients watching the list of Deployments through the API server\u2019s watch\nmechanism are notified of the newly created Deployment resource immediately after\nit\u2019s created. One of those clients is the Deployment controller, which, as we discussed\nearlier, is the active component responsible for handling Deployments. \n As you may remember from chapter 9, a Deployment is backed by one or more\nReplicaSets, which then create the actual pods. As a new Deployment object is\ndetected by the Deployment controller, it creates a ReplicaSet for the current speci-\nfication of the Deployment. This involves creating a new ReplicaSet resource\nthrough the Kubernetes API. The Deployment controller doesn\u2019t deal with individ-\nual pods at all.\nMaster node\nController\nManager\n2. Noti\ufb01cation\nthrough watch\n3. Creates\nReplicaSet\n4. Noti\ufb01cation\n5. Creates pod\n6. Noti\ufb01cation\nthrough watch\n7. Assigns pod to node\n1. Creates Deployment\nresource\nDeployment\ncontroller\nScheduler\nkubectl\nReplicaSet\ncontroller\nAPI server\nDeployment A\nDeployments\nReplicaSets\nPod A\nPods\nReplicaSet A\nNode X\n8. Noti\ufb01cation\nthrough watch\n9. Tells Docker to\nrun containers\nDocker\n10. Runs\ncontainers\nContainer(s)\nKubelet\nFigure 11.12\nThe chain of events that unfolds when a Deployment resource is posted to the API server\n \n"}, {"color": "green", "id": "text_275", "label": "332\nCHAPTER 11\nUnderstanding Kubernetes internals\nTHE REPLICASET CONTROLLER CREATES THE POD RESOURCES\nThe newly created ReplicaSet is then picked up by the ReplicaSet controller, which\nwatches for creations, modifications, and deletions of ReplicaSet resources in the\nAPI server. The controller takes into consideration the replica count and pod selec-\ntor defined in the ReplicaSet and verifies whether enough existing Pods match\nthe selector.\n The controller then creates the Pod resources based on the pod template in the\nReplicaSet (the pod template was copied over from the Deployment when the Deploy-\nment controller created the ReplicaSet). \nTHE SCHEDULER ASSIGNS A NODE TO THE NEWLY CREATED PODS\nThese newly created Pods are now stored in etcd, but they each still lack one import-\nant thing\u2014they don\u2019t have an associated node yet. Their nodeName attribute isn\u2019t set.\nThe Scheduler watches for Pods like this, and when it encounters one, chooses the\nbest node for the Pod and assigns the Pod to the node. The Pod\u2019s definition now\nincludes the name of the node it should be running on.\n Everything so far has been happening in the Kubernetes Control Plane. None of\nthe controllers that have taken part in this whole process have done anything tangible\nexcept update the resources through the API server. \nTHE KUBELET RUNS THE POD\u2019S CONTAINERS\nThe worker nodes haven\u2019t done anything up to this point. The pod\u2019s containers\nhaven\u2019t been started yet. The images for the pod\u2019s containers haven\u2019t even been down-\nloaded yet. \n But with the Pod now scheduled to a specific node, the Kubelet on that node can\nfinally get to work. The Kubelet, watching for changes to Pods on the API server, sees a\nnew Pod scheduled to its node, so it inspects the Pod definition and instructs Docker,\nor whatever container runtime it\u2019s using, to start the pod\u2019s containers. The container\nruntime then runs the containers.\n11.2.3 Observing cluster events\nBoth the Control Plane components and the Kubelet emit events to the API server as\nthey perform these actions. They do this by creating Event resources, which are like\nany other Kubernetes resource. You\u2019ve already seen events pertaining to specific\nresources every time you used kubectl describe to inspect those resources, but you\ncan also retrieve events directly with kubectl get events.\n Maybe it\u2019s me, but using kubectl get to inspect events is painful, because they\u2019re\nnot shown in proper temporal order. Instead, if an event occurs multiple times, the\nevent is displayed only once, showing when it was first seen, when it was last seen, and\nthe number of times it occurred. Luckily, watching events with the --watch option is\nmuch easier on the eyes and useful for seeing what\u2019s happening in the cluster. \n The following listing shows the events emitted in the process described previously\n(some columns have been removed and the output is edited heavily to make it legible\nin the limited space on the page).\n \n", "shape": "dot", "size": 10, "title": "332\nCHAPTER 11\nUnderstanding Kubernetes internals\nTHE REPLICASET CONTROLLER CREATES THE POD RESOURCES\nThe newly created ReplicaSet is then picked up by the ReplicaSet controller, which\nwatches for creations, modifications, and deletions of ReplicaSet resources in the\nAPI server. The controller takes into consideration the replica count and pod selec-\ntor defined in the ReplicaSet and verifies whether enough existing Pods match\nthe selector.\n The controller then creates the Pod resources based on the pod template in the\nReplicaSet (the pod template was copied over from the Deployment when the Deploy-\nment controller created the ReplicaSet). \nTHE SCHEDULER ASSIGNS A NODE TO THE NEWLY CREATED PODS\nThese newly created Pods are now stored in etcd, but they each still lack one import-\nant thing\u2014they don\u2019t have an associated node yet. Their nodeName attribute isn\u2019t set.\nThe Scheduler watches for Pods like this, and when it encounters one, chooses the\nbest node for the Pod and assigns the Pod to the node. The Pod\u2019s definition now\nincludes the name of the node it should be running on.\n Everything so far has been happening in the Kubernetes Control Plane. None of\nthe controllers that have taken part in this whole process have done anything tangible\nexcept update the resources through the API server. \nTHE KUBELET RUNS THE POD\u2019S CONTAINERS\nThe worker nodes haven\u2019t done anything up to this point. The pod\u2019s containers\nhaven\u2019t been started yet. The images for the pod\u2019s containers haven\u2019t even been down-\nloaded yet. \n But with the Pod now scheduled to a specific node, the Kubelet on that node can\nfinally get to work. The Kubelet, watching for changes to Pods on the API server, sees a\nnew Pod scheduled to its node, so it inspects the Pod definition and instructs Docker,\nor whatever container runtime it\u2019s using, to start the pod\u2019s containers. The container\nruntime then runs the containers.\n11.2.3 Observing cluster events\nBoth the Control Plane components and the Kubelet emit events to the API server as\nthey perform these actions. They do this by creating Event resources, which are like\nany other Kubernetes resource. You\u2019ve already seen events pertaining to specific\nresources every time you used kubectl describe to inspect those resources, but you\ncan also retrieve events directly with kubectl get events.\n Maybe it\u2019s me, but using kubectl get to inspect events is painful, because they\u2019re\nnot shown in proper temporal order. Instead, if an event occurs multiple times, the\nevent is displayed only once, showing when it was first seen, when it was last seen, and\nthe number of times it occurred. Luckily, watching events with the --watch option is\nmuch easier on the eyes and useful for seeing what\u2019s happening in the cluster. \n The following listing shows the events emitted in the process described previously\n(some columns have been removed and the output is edited heavily to make it legible\nin the limited space on the page).\n \n"}, {"color": "green", "id": "text_276", "label": "333\nUnderstanding what a running pod is\n$ kubectl get events --watch\n    NAME             KIND         REASON              SOURCE \n... kubia            Deployment   ScalingReplicaSet   deployment-controller  \n                     \u27a5 Scaled up replica set kubia-193 to 3\n... kubia-193        ReplicaSet   SuccessfulCreate    replicaset-controller  \n                     \u27a5 Created pod: kubia-193-w7ll2\n... kubia-193-tpg6j  Pod          Scheduled           default-scheduler   \n                     \u27a5 Successfully assigned kubia-193-tpg6j to node1\n... kubia-193        ReplicaSet   SuccessfulCreate    replicaset-controller  \n                     \u27a5 Created pod: kubia-193-39590\n... kubia-193        ReplicaSet   SuccessfulCreate    replicaset-controller  \n                     \u27a5 Created pod: kubia-193-tpg6j\n... kubia-193-39590  Pod          Scheduled           default-scheduler  \n                     \u27a5 Successfully assigned kubia-193-39590 to node2\n... kubia-193-w7ll2  Pod          Scheduled           default-scheduler  \n                     \u27a5 Successfully assigned kubia-193-w7ll2 to node2\n... kubia-193-tpg6j  Pod          Pulled              kubelet, node1  \n                     \u27a5 Container image already present on machine\n... kubia-193-tpg6j  Pod          Created             kubelet, node1  \n                     \u27a5 Created container with id 13da752\n... kubia-193-39590  Pod          Pulled              kubelet, node2  \n                     \u27a5 Container image already present on machine\n... kubia-193-tpg6j  Pod          Started             kubelet, node1  \n                     \u27a5 Started container with id 13da752\n... kubia-193-w7ll2  Pod          Pulled              kubelet, node2  \n                     \u27a5 Container image already present on machine\n... kubia-193-39590  Pod          Created             kubelet, node2  \n                     \u27a5 Created container with id 8850184\n...\nAs you can see, the SOURCE column shows the controller performing the action, and\nthe NAME and KIND columns show the resource the controller is acting on. The REASON\ncolumn and the MESSAGE column (shown in every second line) give more details\nabout what the controller has done.\n11.3\nUnderstanding what a running pod is\nWith the pod now running, let\u2019s look more closely at what a running pod even is. If a\npod contains a single container, do you think that the Kubelet just runs this single\ncontainer, or is there more to it?\n You\u2019ve run several pods throughout this book. If you\u2019re the investigative type, you\nmay have already snuck a peek at what exactly Docker ran when you created a pod. If\nnot, let me explain what you\u2019d see.\n Imagine you run a single container pod. Let\u2019s say you create an Nginx pod:\n$ kubectl run nginx --image=nginx\ndeployment \"nginx\" created\nYou can now ssh into the worker node running the pod and inspect the list of run-\nning Docker containers. I\u2019m using Minikube to test this out, so to ssh into the single\nListing 11.9\nWatching events emitted by the controllers\n \n", "shape": "dot", "size": 10, "title": "333\nUnderstanding what a running pod is\n$ kubectl get events --watch\n    NAME             KIND         REASON              SOURCE \n... kubia            Deployment   ScalingReplicaSet   deployment-controller  \n                     \u27a5 Scaled up replica set kubia-193 to 3\n... kubia-193        ReplicaSet   SuccessfulCreate    replicaset-controller  \n                     \u27a5 Created pod: kubia-193-w7ll2\n... kubia-193-tpg6j  Pod          Scheduled           default-scheduler   \n                     \u27a5 Successfully assigned kubia-193-tpg6j to node1\n... kubia-193        ReplicaSet   SuccessfulCreate    replicaset-controller  \n                     \u27a5 Created pod: kubia-193-39590\n... kubia-193        ReplicaSet   SuccessfulCreate    replicaset-controller  \n                     \u27a5 Created pod: kubia-193-tpg6j\n... kubia-193-39590  Pod          Scheduled           default-scheduler  \n                     \u27a5 Successfully assigned kubia-193-39590 to node2\n... kubia-193-w7ll2  Pod          Scheduled           default-scheduler  \n                     \u27a5 Successfully assigned kubia-193-w7ll2 to node2\n... kubia-193-tpg6j  Pod          Pulled              kubelet, node1  \n                     \u27a5 Container image already present on machine\n... kubia-193-tpg6j  Pod          Created             kubelet, node1  \n                     \u27a5 Created container with id 13da752\n... kubia-193-39590  Pod          Pulled              kubelet, node2  \n                     \u27a5 Container image already present on machine\n... kubia-193-tpg6j  Pod          Started             kubelet, node1  \n                     \u27a5 Started container with id 13da752\n... kubia-193-w7ll2  Pod          Pulled              kubelet, node2  \n                     \u27a5 Container image already present on machine\n... kubia-193-39590  Pod          Created             kubelet, node2  \n                     \u27a5 Created container with id 8850184\n...\nAs you can see, the SOURCE column shows the controller performing the action, and\nthe NAME and KIND columns show the resource the controller is acting on. The REASON\ncolumn and the MESSAGE column (shown in every second line) give more details\nabout what the controller has done.\n11.3\nUnderstanding what a running pod is\nWith the pod now running, let\u2019s look more closely at what a running pod even is. If a\npod contains a single container, do you think that the Kubelet just runs this single\ncontainer, or is there more to it?\n You\u2019ve run several pods throughout this book. If you\u2019re the investigative type, you\nmay have already snuck a peek at what exactly Docker ran when you created a pod. If\nnot, let me explain what you\u2019d see.\n Imagine you run a single container pod. Let\u2019s say you create an Nginx pod:\n$ kubectl run nginx --image=nginx\ndeployment \"nginx\" created\nYou can now ssh into the worker node running the pod and inspect the list of run-\nning Docker containers. I\u2019m using Minikube to test this out, so to ssh into the single\nListing 11.9\nWatching events emitted by the controllers\n \n"}, {"color": "green", "id": "text_277", "label": "334\nCHAPTER 11\nUnderstanding Kubernetes internals\nnode, I use minikube ssh. If you\u2019re using GKE, you can ssh into a node with gcloud\ncompute ssh \u003cnode name\u003e.\n Once you\u2019re inside the node, you can list all the running containers with docker\nps, as shown in the following listing.\ndocker@minikubeVM:~$ docker ps\nCONTAINER ID   IMAGE                  COMMAND                 CREATED\nc917a6f3c3f7   nginx                  \"nginx -g \u0027daemon off\"  4 seconds ago \n98b8bf797174   gcr.io/.../pause:3.0   \"/pause\"                7 seconds ago\n...\nNOTE\nI\u2019ve removed irrelevant information from the previous listing\u2014this\nincludes both columns and rows. I\u2019ve also removed all the other running con-\ntainers. If you\u2019re trying this out yourself, pay attention to the two containers\nthat were created a few seconds ago. \nAs expected, you see the Nginx container, but also an additional container. Judging\nfrom the COMMAND column, this additional container isn\u2019t doing anything (the con-\ntainer\u2019s command is \"pause\"). If you look closely, you\u2019ll see that this container was\ncreated a few seconds before the Nginx container. What\u2019s its role?\n This pause container is the container that holds all the containers of a pod\ntogether. Remember how all containers of a pod share the same network and other\nLinux namespaces? The pause container is an infrastructure container whose sole\npurpose is to hold all these namespaces. All other user-defined containers of the pod\nthen use the namespaces of the pod infrastructure container (see figure 11.13).\nActual application containers may die and get restarted. When such a container starts\nup again, it needs to become part of the same Linux namespaces as before. The infra-\nstructure container makes this possible since its lifecycle is tied to that of the pod\u2014the\ncontainer runs from the time the pod is scheduled until the pod is deleted. If the\ninfrastructure pod is killed in the meantime, the Kubelet recreates it and all the pod\u2019s\ncontainers.\nListing 11.10\nListing running Docker containers\nPod\nContainer A\nContainer A\nPod infrastructure\ncontainer\nContainer B\nContainer B\nUses Linux\nnamespaces from\nUses Linux\nnamespaces from\nFigure 11.13\nA two-container pod results in three running containers \nsharing the same Linux namespaces.\n \n", "shape": "dot", "size": 10, "title": "334\nCHAPTER 11\nUnderstanding Kubernetes internals\nnode, I use minikube ssh. If you\u2019re using GKE, you can ssh into a node with gcloud\ncompute ssh \u003cnode name\u003e.\n Once you\u2019re inside the node, you can list all the running containers with docker\nps, as shown in the following listing.\ndocker@minikubeVM:~$ docker ps\nCONTAINER ID   IMAGE                  COMMAND                 CREATED\nc917a6f3c3f7   nginx                  \"nginx -g \u0027daemon off\"  4 seconds ago \n98b8bf797174   gcr.io/.../pause:3.0   \"/pause\"                7 seconds ago\n...\nNOTE\nI\u2019ve removed irrelevant information from the previous listing\u2014this\nincludes both columns and rows. I\u2019ve also removed all the other running con-\ntainers. If you\u2019re trying this out yourself, pay attention to the two containers\nthat were created a few seconds ago. \nAs expected, you see the Nginx container, but also an additional container. Judging\nfrom the COMMAND column, this additional container isn\u2019t doing anything (the con-\ntainer\u2019s command is \"pause\"). If you look closely, you\u2019ll see that this container was\ncreated a few seconds before the Nginx container. What\u2019s its role?\n This pause container is the container that holds all the containers of a pod\ntogether. Remember how all containers of a pod share the same network and other\nLinux namespaces? The pause container is an infrastructure container whose sole\npurpose is to hold all these namespaces. All other user-defined containers of the pod\nthen use the namespaces of the pod infrastructure container (see figure 11.13).\nActual application containers may die and get restarted. When such a container starts\nup again, it needs to become part of the same Linux namespaces as before. The infra-\nstructure container makes this possible since its lifecycle is tied to that of the pod\u2014the\ncontainer runs from the time the pod is scheduled until the pod is deleted. If the\ninfrastructure pod is killed in the meantime, the Kubelet recreates it and all the pod\u2019s\ncontainers.\nListing 11.10\nListing running Docker containers\nPod\nContainer A\nContainer A\nPod infrastructure\ncontainer\nContainer B\nContainer B\nUses Linux\nnamespaces from\nUses Linux\nnamespaces from\nFigure 11.13\nA two-container pod results in three running containers \nsharing the same Linux namespaces.\n \n"}, {"color": "green", "id": "text_278", "label": "335\nInter-pod networking\n11.4\nInter-pod networking\nBy now, you know that each pod gets its own unique IP address and can communicate\nwith all other pods through a flat, NAT-less network. How exactly does Kubernetes\nachieve this? In short, it doesn\u2019t. The network is set up by the system administrator or\nby a Container Network Interface (CNI) plugin, not by Kubernetes itself. \n11.4.1 What the network must be like\nKubernetes doesn\u2019t require you to use a specific networking technology, but it does\nmandate that the pods (or to be more precise, their containers) can communicate\nwith each other, regardless if they\u2019re running on the same worker node or not. The\nnetwork the pods use to communicate must be such that the IP address a pod sees as\nits own is the exact same address that all other pods see as the IP address of the pod in\nquestion. \n Look at figure 11.14. When pod A connects to (sends a network packet to) pod B,\nthe source IP pod B sees must be the same IP that pod A sees as its own. There should\nbe no network address translation (NAT) performed in between\u2014the packet sent by\npod A must reach pod B with both the source and destination address unchanged.\nThis is important, because it makes networking for applications running inside pods\nsimple and exactly as if they were running on machines connected to the same net-\nwork switch. The absence of NAT between pods enables applications running inside\nthem to self-register in other pods. \nNode 1\nPod A\nIP: 10.1.1.1\nsrcIP: 10.1.1.1\ndstIP: 10.1.2.1\nsrcIP: 10.1.1.1\ndstIP: 10.1.2.1\nPacket\nNode 2\nPod B\nIP: 10.1.2.1\nsrcIP: 10.1.1.1\ndstIP: 10.1.2.1\nPacket\nNetwork\nNo NAT (IPs\nare preserved)\nFigure 11.14\nKubernetes mandates pods are connected through a NAT-less \nnetwork.\n \n", "shape": "dot", "size": 10, "title": "335\nInter-pod networking\n11.4\nInter-pod networking\nBy now, you know that each pod gets its own unique IP address and can communicate\nwith all other pods through a flat, NAT-less network. How exactly does Kubernetes\nachieve this? In short, it doesn\u2019t. The network is set up by the system administrator or\nby a Container Network Interface (CNI) plugin, not by Kubernetes itself. \n11.4.1 What the network must be like\nKubernetes doesn\u2019t require you to use a specific networking technology, but it does\nmandate that the pods (or to be more precise, their containers) can communicate\nwith each other, regardless if they\u2019re running on the same worker node or not. The\nnetwork the pods use to communicate must be such that the IP address a pod sees as\nits own is the exact same address that all other pods see as the IP address of the pod in\nquestion. \n Look at figure 11.14. When pod A connects to (sends a network packet to) pod B,\nthe source IP pod B sees must be the same IP that pod A sees as its own. There should\nbe no network address translation (NAT) performed in between\u2014the packet sent by\npod A must reach pod B with both the source and destination address unchanged.\nThis is important, because it makes networking for applications running inside pods\nsimple and exactly as if they were running on machines connected to the same net-\nwork switch. The absence of NAT between pods enables applications running inside\nthem to self-register in other pods. \nNode 1\nPod A\nIP: 10.1.1.1\nsrcIP: 10.1.1.1\ndstIP: 10.1.2.1\nsrcIP: 10.1.1.1\ndstIP: 10.1.2.1\nPacket\nNode 2\nPod B\nIP: 10.1.2.1\nsrcIP: 10.1.1.1\ndstIP: 10.1.2.1\nPacket\nNetwork\nNo NAT (IPs\nare preserved)\nFigure 11.14\nKubernetes mandates pods are connected through a NAT-less \nnetwork.\n \n"}, {"color": "green", "id": "text_279", "label": "336\nCHAPTER 11\nUnderstanding Kubernetes internals\n For example, say you have a client pod X and pod Y, which provides a kind of noti-\nfication service to all pods that register with it. Pod X connects to pod Y and tells it,\n\u201cHey, I\u2019m pod X, available at IP 1.2.3.4; please send updates to me at this IP address.\u201d\nThe pod providing the service can connect to the first pod by using the received\nIP address. \n The requirement for NAT-less communication between pods also extends to pod-\nto-node and node-to-pod communication. But when a pod communicates with ser-\nvices out on the internet, the source IP of the packets the pod sends does need to be\nchanged, because the pod\u2019s IP is private. The source IP of outbound packets is\nchanged to the host worker node\u2019s IP address.\n Building a proper Kubernetes cluster involves setting up the networking according\nto these requirements. There are various methods and technologies available to do\nthis, each with its own benefits or drawbacks in a given scenario. Because of this, we\u2019re\nnot going to go into specific technologies. Instead, let\u2019s explain how inter-pod net-\nworking works in general. \n11.4.2 Diving deeper into how networking works\nIn section 11.3, we saw that a pod\u2019s IP address and network namespace are set up and\nheld by the infrastructure container (the pause container). The pod\u2019s containers then\nuse its network namespace. A pod\u2019s network interface is thus whatever is set up in the\ninfrastructure container. Let\u2019s see how the interface is created and how it\u2019s connected\nto the interfaces in all the other pods. Look at figure 11.15. We\u2019ll discuss it next.\nENABLING COMMUNICATION BETWEEN PODS ON THE SAME NODE\nBefore the infrastructure container is started, a virtual Ethernet interface pair (a veth\npair) is created for the container. One interface of the pair remains in the host\u2019s\nnamespace (you\u2019ll see it listed as vethXXX when you run ifconfig on the node),\nwhereas the other is moved into the container\u2019s network namespace and renamed\neth0. The two virtual interfaces are like two ends of a pipe (or like two network\ndevices connected by an Ethernet cable)\u2014what goes in on one side comes out on the\nother, and vice-versa. \nNode\nPod A\neth0\n10.1.1.1\nveth123\nPod B\neth0\n10.1.1.2\nveth234\nBridge\n10.1.1.0/24\nThis is pod A\u2019s\nveth pair.\nThis is pod B\u2019s\nveth pair.\nFigure 11.15\nPods on a node are \nconnected to the same bridge through \nvirtual Ethernet interface pairs.\n \n", "shape": "dot", "size": 10, "title": "336\nCHAPTER 11\nUnderstanding Kubernetes internals\n For example, say you have a client pod X and pod Y, which provides a kind of noti-\nfication service to all pods that register with it. Pod X connects to pod Y and tells it,\n\u201cHey, I\u2019m pod X, available at IP 1.2.3.4; please send updates to me at this IP address.\u201d\nThe pod providing the service can connect to the first pod by using the received\nIP address. \n The requirement for NAT-less communication between pods also extends to pod-\nto-node and node-to-pod communication. But when a pod communicates with ser-\nvices out on the internet, the source IP of the packets the pod sends does need to be\nchanged, because the pod\u2019s IP is private. The source IP of outbound packets is\nchanged to the host worker node\u2019s IP address.\n Building a proper Kubernetes cluster involves setting up the networking according\nto these requirements. There are various methods and technologies available to do\nthis, each with its own benefits or drawbacks in a given scenario. Because of this, we\u2019re\nnot going to go into specific technologies. Instead, let\u2019s explain how inter-pod net-\nworking works in general. \n11.4.2 Diving deeper into how networking works\nIn section 11.3, we saw that a pod\u2019s IP address and network namespace are set up and\nheld by the infrastructure container (the pause container). The pod\u2019s containers then\nuse its network namespace. A pod\u2019s network interface is thus whatever is set up in the\ninfrastructure container. Let\u2019s see how the interface is created and how it\u2019s connected\nto the interfaces in all the other pods. Look at figure 11.15. We\u2019ll discuss it next.\nENABLING COMMUNICATION BETWEEN PODS ON THE SAME NODE\nBefore the infrastructure container is started, a virtual Ethernet interface pair (a veth\npair) is created for the container. One interface of the pair remains in the host\u2019s\nnamespace (you\u2019ll see it listed as vethXXX when you run ifconfig on the node),\nwhereas the other is moved into the container\u2019s network namespace and renamed\neth0. The two virtual interfaces are like two ends of a pipe (or like two network\ndevices connected by an Ethernet cable)\u2014what goes in on one side comes out on the\nother, and vice-versa. \nNode\nPod A\neth0\n10.1.1.1\nveth123\nPod B\neth0\n10.1.1.2\nveth234\nBridge\n10.1.1.0/24\nThis is pod A\u2019s\nveth pair.\nThis is pod B\u2019s\nveth pair.\nFigure 11.15\nPods on a node are \nconnected to the same bridge through \nvirtual Ethernet interface pairs.\n \n"}, {"color": "green", "id": "text_280", "label": "337\nInter-pod networking\n The interface in the host\u2019s network namespace is attached to a network bridge that\nthe container runtime is configured to use. The eth0 interface in the container is\nassigned an IP address from the bridge\u2019s address range. Anything that an application\nrunning inside the container sends to the eth0 network interface (the one in the con-\ntainer\u2019s namespace), comes out at the other veth interface in the host\u2019s namespace\nand is sent to the bridge. This means it can be received by any network interface that\u2019s\nconnected to the bridge. \n If pod A sends a network packet to pod B, the packet first goes through pod A\u2019s\nveth pair to the bridge and then through pod B\u2019s veth pair. All containers on a node\nare connected to the same bridge, which means they can all communicate with each\nother. But to enable communication between containers running on different nodes,\nthe bridges on those nodes need to be connected somehow. \nENABLING COMMUNICATION BETWEEN PODS ON DIFFERENT NODES\nYou have many ways to connect bridges on different nodes. This can be done with\noverlay or underlay networks or by regular layer 3 routing, which we\u2019ll look at next.\n You know pod IP addresses must be unique across the whole cluster, so the bridges\nacross the nodes must use non-overlapping address ranges to prevent pods on differ-\nent nodes from getting the same IP. In the example shown in figure 11.16, the bridge\non node A is using the 10.1.1.0/24 IP range and the bridge on node B is using\n10.1.2.0/24, which ensures no IP address conflicts exist.\n Figure 11.16 shows that to enable communication between pods across two nodes\nwith plain layer 3 networking, the node\u2019s physical network interface needs to be con-\nnected to the bridge as well. Routing tables on node A need to be configured so all\npackets destined for 10.1.2.0/24 are routed to node B, whereas node B\u2019s routing\ntables need to be configured so packets sent to 10.1.1.0/24 are routed to node A.\n With this type of setup, when a packet is sent by a container on one of the nodes\nto a container on the other node, the packet first goes through the veth pair, then\nNode A\nPod A\nNetwork\neth0\n10.1.1.1\nveth123\nPod B\neth0\n10.1.1.2\nveth234\nBridge\n10.1.1.0/24\neth0\n10.100.0.1\nNode B\nPod C\neth0\n10.1.2.1\nveth345\nPod D\neth0\n10.1.2.2\nveth456\nBridge\n10.1.2.0/24\neth0\n10.100.0.2\nFigure 11.16\nFor pods on different nodes to communicate, the bridges need to be connected \nsomehow.\n \n", "shape": "dot", "size": 10, "title": "337\nInter-pod networking\n The interface in the host\u2019s network namespace is attached to a network bridge that\nthe container runtime is configured to use. The eth0 interface in the container is\nassigned an IP address from the bridge\u2019s address range. Anything that an application\nrunning inside the container sends to the eth0 network interface (the one in the con-\ntainer\u2019s namespace), comes out at the other veth interface in the host\u2019s namespace\nand is sent to the bridge. This means it can be received by any network interface that\u2019s\nconnected to the bridge. \n If pod A sends a network packet to pod B, the packet first goes through pod A\u2019s\nveth pair to the bridge and then through pod B\u2019s veth pair. All containers on a node\nare connected to the same bridge, which means they can all communicate with each\nother. But to enable communication between containers running on different nodes,\nthe bridges on those nodes need to be connected somehow. \nENABLING COMMUNICATION BETWEEN PODS ON DIFFERENT NODES\nYou have many ways to connect bridges on different nodes. This can be done with\noverlay or underlay networks or by regular layer 3 routing, which we\u2019ll look at next.\n You know pod IP addresses must be unique across the whole cluster, so the bridges\nacross the nodes must use non-overlapping address ranges to prevent pods on differ-\nent nodes from getting the same IP. In the example shown in figure 11.16, the bridge\non node A is using the 10.1.1.0/24 IP range and the bridge on node B is using\n10.1.2.0/24, which ensures no IP address conflicts exist.\n Figure 11.16 shows that to enable communication between pods across two nodes\nwith plain layer 3 networking, the node\u2019s physical network interface needs to be con-\nnected to the bridge as well. Routing tables on node A need to be configured so all\npackets destined for 10.1.2.0/24 are routed to node B, whereas node B\u2019s routing\ntables need to be configured so packets sent to 10.1.1.0/24 are routed to node A.\n With this type of setup, when a packet is sent by a container on one of the nodes\nto a container on the other node, the packet first goes through the veth pair, then\nNode A\nPod A\nNetwork\neth0\n10.1.1.1\nveth123\nPod B\neth0\n10.1.1.2\nveth234\nBridge\n10.1.1.0/24\neth0\n10.100.0.1\nNode B\nPod C\neth0\n10.1.2.1\nveth345\nPod D\neth0\n10.1.2.2\nveth456\nBridge\n10.1.2.0/24\neth0\n10.100.0.2\nFigure 11.16\nFor pods on different nodes to communicate, the bridges need to be connected \nsomehow.\n \n"}, {"color": "green", "id": "text_281", "label": "338\nCHAPTER 11\nUnderstanding Kubernetes internals\nthrough the bridge to the node\u2019s physical adapter, then over the wire to the other\nnode\u2019s physical adapter, through the other node\u2019s bridge, and finally through the veth\npair of the destination container.\n This works only when nodes are connected to the same network switch, without\nany routers in between; otherwise those routers would drop the packets because\nthey refer to pod IPs, which are private. Sure, the routers in between could be con-\nfigured to route packets between the nodes, but this becomes increasingly difficult\nand error-prone as the number of routers between the nodes increases. Because of\nthis, it\u2019s easier to use a Software Defined Network (SDN), which makes the nodes\nappear as though they\u2019re connected to the same network switch, regardless of the\nactual underlying network topology, no matter how complex it is. Packets sent\nfrom the pod are encapsulated and sent over the network to the node running the\nother pod, where they are de-encapsulated and delivered to the pod in their origi-\nnal form.\n11.4.3 Introducing the Container Network Interface\nTo make it easier to connect containers into a network, a project called Container\nNetwork Interface (CNI) was started. The CNI allows Kubernetes to be configured to\nuse any CNI plugin that\u2019s out there. These plugins include\n\uf0a1Calico\n\uf0a1Flannel\n\uf0a1Romana\n\uf0a1Weave Net \n\uf0a1And others\nWe\u2019re not going to go into the details of these plugins; if you want to learn more about\nthem, refer to https:/\n/kubernetes.io/docs/concepts/cluster-administration/addons/.\n Installing a network plugin isn\u2019t difficult. You only need to deploy a YAML con-\ntaining a DaemonSet and a few other supporting resources. This YAML is provided\non each plugin\u2019s project page. As you can imagine, the DaemonSet is used to deploy\na network agent on all cluster nodes. It then ties into the CNI interface on the node,\nbut be aware that the Kubelet needs to be started with --network-plugin=cni to\nuse CNI. \n11.5\nHow services are implemented\nIn chapter 5 you learned about Services, which allow exposing a set of pods at a long-\nlived, stable IP address and port. In order to focus on what Services are meant for and\nhow they can be used, we intentionally didn\u2019t go into how they work. But to truly\nunderstand Services and have a better feel for where to look when things don\u2019t behave\nthe way you expect, you need to understand how they are implemented. \n \n", "shape": "dot", "size": 10, "title": "338\nCHAPTER 11\nUnderstanding Kubernetes internals\nthrough the bridge to the node\u2019s physical adapter, then over the wire to the other\nnode\u2019s physical adapter, through the other node\u2019s bridge, and finally through the veth\npair of the destination container.\n This works only when nodes are connected to the same network switch, without\nany routers in between; otherwise those routers would drop the packets because\nthey refer to pod IPs, which are private. Sure, the routers in between could be con-\nfigured to route packets between the nodes, but this becomes increasingly difficult\nand error-prone as the number of routers between the nodes increases. Because of\nthis, it\u2019s easier to use a Software Defined Network (SDN), which makes the nodes\nappear as though they\u2019re connected to the same network switch, regardless of the\nactual underlying network topology, no matter how complex it is. Packets sent\nfrom the pod are encapsulated and sent over the network to the node running the\nother pod, where they are de-encapsulated and delivered to the pod in their origi-\nnal form.\n11.4.3 Introducing the Container Network Interface\nTo make it easier to connect containers into a network, a project called Container\nNetwork Interface (CNI) was started. The CNI allows Kubernetes to be configured to\nuse any CNI plugin that\u2019s out there. These plugins include\n\uf0a1Calico\n\uf0a1Flannel\n\uf0a1Romana\n\uf0a1Weave Net \n\uf0a1And others\nWe\u2019re not going to go into the details of these plugins; if you want to learn more about\nthem, refer to https:/\n/kubernetes.io/docs/concepts/cluster-administration/addons/.\n Installing a network plugin isn\u2019t difficult. You only need to deploy a YAML con-\ntaining a DaemonSet and a few other supporting resources. This YAML is provided\non each plugin\u2019s project page. As you can imagine, the DaemonSet is used to deploy\na network agent on all cluster nodes. It then ties into the CNI interface on the node,\nbut be aware that the Kubelet needs to be started with --network-plugin=cni to\nuse CNI. \n11.5\nHow services are implemented\nIn chapter 5 you learned about Services, which allow exposing a set of pods at a long-\nlived, stable IP address and port. In order to focus on what Services are meant for and\nhow they can be used, we intentionally didn\u2019t go into how they work. But to truly\nunderstand Services and have a better feel for where to look when things don\u2019t behave\nthe way you expect, you need to understand how they are implemented. \n \n"}, {"color": "green", "id": "text_282", "label": "339\nHow services are implemented\n11.5.1 Introducing the kube-proxy\nEverything related to Services is handled by the kube-proxy process running on each\nnode. Initially, the kube-proxy was an actual proxy waiting for connections and for\neach incoming connection, opening a new connection to one of the pods. This was\ncalled the userspace proxy mode. Later, a better-performing iptables proxy mode\nreplaced it. This is now the default, but you can still configure Kubernetes to use the\nold mode if you want.\n Before we continue, let\u2019s quickly review a few things about Services, which are rele-\nvant for understanding the next few paragraphs.\n We\u2019ve learned that each Service gets its own stable IP address and port. Clients\n(usually pods) use the service by connecting to this IP address and port. The IP\naddress is virtual\u2014it\u2019s not assigned to any network interfaces and is never listed as\neither the source or the destination IP address in a network packet when the packet\nleaves the node. A key detail of Services is that they consist of an IP and port pair (or\nmultiple IP and port pairs in the case of multi-port Services), so the service IP by itself\ndoesn\u2019t represent anything. That\u2019s why you can\u2019t ping them. \n11.5.2 How kube-proxy uses iptables\nWhen a service is created in the API server, the virtual IP address is assigned to it\nimmediately. Soon afterward, the API server notifies all kube-proxy agents running on\nthe worker nodes that a new Service has been created. Then, each kube-proxy makes\nthat service addressable on the node it\u2019s running on. It does this by setting up a few\niptables rules, which make sure each packet destined for the service IP/port pair is\nintercepted and its destination address modified, so the packet is redirected to one of\nthe pods backing the service. \n Besides watching the API server for changes to Services, kube-proxy also watches\nfor changes to Endpoints objects. We talked about them in chapter 5, but let me\nrefresh your memory, as it\u2019s easy to forget they even exist, because you rarely create\nthem manually. An Endpoints object holds the IP/port pairs of all the pods that back\nthe service (an IP/port pair can also point to something other than a pod). That\u2019s\nwhy the kube-proxy must also watch all Endpoints objects. After all, an Endpoints\nobject changes every time a new backing pod is created or deleted, and when the\npod\u2019s readiness status changes or the pod\u2019s labels change and it falls in or out of scope\nof the service. \n Now let\u2019s see how kube-proxy enables clients to connect to those pods through the\nService. This is shown in figure 11.17.\n The figure shows what the kube-proxy does and how a packet sent by a client pod\nreaches one of the pods backing the Service. Let\u2019s examine what happens to the\npacket when it\u2019s sent by the client pod (pod A in the figure). \n The packet\u2019s destination is initially set to the IP and port of the Service (in the\nexample, the Service is at 172.30.0.1:80). Before being sent to the network, the\n \n", "shape": "dot", "size": 10, "title": "339\nHow services are implemented\n11.5.1 Introducing the kube-proxy\nEverything related to Services is handled by the kube-proxy process running on each\nnode. Initially, the kube-proxy was an actual proxy waiting for connections and for\neach incoming connection, opening a new connection to one of the pods. This was\ncalled the userspace proxy mode. Later, a better-performing iptables proxy mode\nreplaced it. This is now the default, but you can still configure Kubernetes to use the\nold mode if you want.\n Before we continue, let\u2019s quickly review a few things about Services, which are rele-\nvant for understanding the next few paragraphs.\n We\u2019ve learned that each Service gets its own stable IP address and port. Clients\n(usually pods) use the service by connecting to this IP address and port. The IP\naddress is virtual\u2014it\u2019s not assigned to any network interfaces and is never listed as\neither the source or the destination IP address in a network packet when the packet\nleaves the node. A key detail of Services is that they consist of an IP and port pair (or\nmultiple IP and port pairs in the case of multi-port Services), so the service IP by itself\ndoesn\u2019t represent anything. That\u2019s why you can\u2019t ping them. \n11.5.2 How kube-proxy uses iptables\nWhen a service is created in the API server, the virtual IP address is assigned to it\nimmediately. Soon afterward, the API server notifies all kube-proxy agents running on\nthe worker nodes that a new Service has been created. Then, each kube-proxy makes\nthat service addressable on the node it\u2019s running on. It does this by setting up a few\niptables rules, which make sure each packet destined for the service IP/port pair is\nintercepted and its destination address modified, so the packet is redirected to one of\nthe pods backing the service. \n Besides watching the API server for changes to Services, kube-proxy also watches\nfor changes to Endpoints objects. We talked about them in chapter 5, but let me\nrefresh your memory, as it\u2019s easy to forget they even exist, because you rarely create\nthem manually. An Endpoints object holds the IP/port pairs of all the pods that back\nthe service (an IP/port pair can also point to something other than a pod). That\u2019s\nwhy the kube-proxy must also watch all Endpoints objects. After all, an Endpoints\nobject changes every time a new backing pod is created or deleted, and when the\npod\u2019s readiness status changes or the pod\u2019s labels change and it falls in or out of scope\nof the service. \n Now let\u2019s see how kube-proxy enables clients to connect to those pods through the\nService. This is shown in figure 11.17.\n The figure shows what the kube-proxy does and how a packet sent by a client pod\nreaches one of the pods backing the Service. Let\u2019s examine what happens to the\npacket when it\u2019s sent by the client pod (pod A in the figure). \n The packet\u2019s destination is initially set to the IP and port of the Service (in the\nexample, the Service is at 172.30.0.1:80). Before being sent to the network, the\n \n"}, {"color": "green", "id": "text_283", "label": "340\nCHAPTER 11\nUnderstanding Kubernetes internals\npacket is first handled by node A\u2019s kernel according to the iptables rules set up on\nthe node. \n The kernel checks if the packet matches any of those iptables rules. One of them\nsays that if any packet has the destination IP equal to 172.30.0.1 and destination port\nequal to 80, the packet\u2019s destination IP and port should be replaced with the IP and\nport of a randomly selected pod. \n The packet in the example matches that rule and so its destination IP/port is\nchanged. In the example, pod B2 was randomly selected, so the packet\u2019s destination\nIP is changed to 10.1.2.1 (pod B2\u2019s IP) and the port to 8080 (the target port specified\nin the Service spec). From here on, it\u2019s exactly as if the client pod had sent the packet\nto pod B directly instead of through the service. \n It\u2019s slightly more complicated than that, but that\u2019s the most important part you\nneed to understand.\n \nNode A\nNode B\nAPI server\nPod A\nPod B1\nPod B2\nPod B3\nPacket X\nSource:\n10.1.1.1\nDestination:\n172.30.0.1:80\n10.1.2.1:8080\niptables\nService B\n172.30.0.1:80\nCon\ufb01gures\niptables\nPacket X\nSource:\n10.1.1.1\nDestination:\n172.30.0.1:80\nkube-proxy\nEndpoints B\nPod A\nIP: 10.1.1.1\nPod B1\nIP: 10.1.1.2\nPod B2\nIP: 10.1.2.1\nPod B3\nIP: 10.1.2.2\nWatches for changes to\nservices and endpoints\nFigure 11.17\nNetwork packets sent to a Service\u2019s virtual IP/port pair are \nmodified and redirected to a randomly selected backend pod.\n \n", "shape": "dot", "size": 10, "title": "340\nCHAPTER 11\nUnderstanding Kubernetes internals\npacket is first handled by node A\u2019s kernel according to the iptables rules set up on\nthe node. \n The kernel checks if the packet matches any of those iptables rules. One of them\nsays that if any packet has the destination IP equal to 172.30.0.1 and destination port\nequal to 80, the packet\u2019s destination IP and port should be replaced with the IP and\nport of a randomly selected pod. \n The packet in the example matches that rule and so its destination IP/port is\nchanged. In the example, pod B2 was randomly selected, so the packet\u2019s destination\nIP is changed to 10.1.2.1 (pod B2\u2019s IP) and the port to 8080 (the target port specified\nin the Service spec). From here on, it\u2019s exactly as if the client pod had sent the packet\nto pod B directly instead of through the service. \n It\u2019s slightly more complicated than that, but that\u2019s the most important part you\nneed to understand.\n \nNode A\nNode B\nAPI server\nPod A\nPod B1\nPod B2\nPod B3\nPacket X\nSource:\n10.1.1.1\nDestination:\n172.30.0.1:80\n10.1.2.1:8080\niptables\nService B\n172.30.0.1:80\nCon\ufb01gures\niptables\nPacket X\nSource:\n10.1.1.1\nDestination:\n172.30.0.1:80\nkube-proxy\nEndpoints B\nPod A\nIP: 10.1.1.1\nPod B1\nIP: 10.1.1.2\nPod B2\nIP: 10.1.2.1\nPod B3\nIP: 10.1.2.2\nWatches for changes to\nservices and endpoints\nFigure 11.17\nNetwork packets sent to a Service\u2019s virtual IP/port pair are \nmodified and redirected to a randomly selected backend pod.\n \n"}, {"color": "green", "id": "text_284", "label": "341\nRunning highly available clusters\n11.6\nRunning highly available clusters\nOne of the reasons for running apps inside Kubernetes is to keep them running with-\nout interruption with no or limited manual intervention in case of infrastructure\nfailures. For running services without interruption it\u2019s not only the apps that need to\nbe up all the time, but also the Kubernetes Control Plane components. We\u2019ll look at\nwhat\u2019s involved in achieving high availability next.\n11.6.1 Making your apps highly available\nWhen running apps in Kubernetes, the various controllers make sure your app keeps\nrunning smoothly and at the specified scale even when nodes fail. To ensure your app\nis highly available, you only need to run them through a Deployment resource and\nconfigure an appropriate number of replicas; everything else is taken care of by\nKubernetes. \nRUNNING MULTIPLE INSTANCES TO REDUCE THE LIKELIHOOD OF DOWNTIME\nThis requires your apps to be horizontally scalable, but even if that\u2019s not the case in\nyour app, you should still use a Deployment with its replica count set to one. If the\nreplica becomes unavailable, it will be replaced with a new one quickly, although that\ndoesn\u2019t happen instantaneously. It takes time for all the involved controllers to notice\nthat a node has failed, create the new pod replica, and start the pod\u2019s containers.\nThere will inevitably be a short period of downtime in between. \nUSING LEADER-ELECTION FOR NON-HORIZONTALLY SCALABLE APPS\nTo avoid the downtime, you need to run additional inactive replicas along with the\nactive one and use a fast-acting lease or leader-election mechanism to make sure only\none is active. In case you\u2019re unfamiliar with leader election, it\u2019s a way for multiple app\ninstances running in a distributed environment to come to an agreement on which is\nthe leader. That leader is either the only one performing tasks, while all others are\nwaiting for the leader to fail and then becoming leaders themselves, or they can all be\nactive, with the leader being the only instance performing writes, while all the others\nare providing read-only access to their data, for example. This ensures two instances\nare never doing the same job, if that would lead to unpredictable system behavior due\nto race conditions.\n The mechanism doesn\u2019t need to be incorporated into the app itself. You can use a\nsidecar container that performs all the leader-election operations and signals the\nmain container when it should become active. You\u2019ll find an example of leader elec-\ntion in Kubernetes at https:/\n/github.com/kubernetes/contrib/tree/master/election.\n Ensuring your apps are highly available is relatively simple, because Kubernetes\ntakes care of almost everything. But what if Kubernetes itself fails? What if the servers\nrunning the Kubernetes Control Plane components go down? How are those compo-\nnents made highly available?\n \n", "shape": "dot", "size": 10, "title": "341\nRunning highly available clusters\n11.6\nRunning highly available clusters\nOne of the reasons for running apps inside Kubernetes is to keep them running with-\nout interruption with no or limited manual intervention in case of infrastructure\nfailures. For running services without interruption it\u2019s not only the apps that need to\nbe up all the time, but also the Kubernetes Control Plane components. We\u2019ll look at\nwhat\u2019s involved in achieving high availability next.\n11.6.1 Making your apps highly available\nWhen running apps in Kubernetes, the various controllers make sure your app keeps\nrunning smoothly and at the specified scale even when nodes fail. To ensure your app\nis highly available, you only need to run them through a Deployment resource and\nconfigure an appropriate number of replicas; everything else is taken care of by\nKubernetes. \nRUNNING MULTIPLE INSTANCES TO REDUCE THE LIKELIHOOD OF DOWNTIME\nThis requires your apps to be horizontally scalable, but even if that\u2019s not the case in\nyour app, you should still use a Deployment with its replica count set to one. If the\nreplica becomes unavailable, it will be replaced with a new one quickly, although that\ndoesn\u2019t happen instantaneously. It takes time for all the involved controllers to notice\nthat a node has failed, create the new pod replica, and start the pod\u2019s containers.\nThere will inevitably be a short period of downtime in between. \nUSING LEADER-ELECTION FOR NON-HORIZONTALLY SCALABLE APPS\nTo avoid the downtime, you need to run additional inactive replicas along with the\nactive one and use a fast-acting lease or leader-election mechanism to make sure only\none is active. In case you\u2019re unfamiliar with leader election, it\u2019s a way for multiple app\ninstances running in a distributed environment to come to an agreement on which is\nthe leader. That leader is either the only one performing tasks, while all others are\nwaiting for the leader to fail and then becoming leaders themselves, or they can all be\nactive, with the leader being the only instance performing writes, while all the others\nare providing read-only access to their data, for example. This ensures two instances\nare never doing the same job, if that would lead to unpredictable system behavior due\nto race conditions.\n The mechanism doesn\u2019t need to be incorporated into the app itself. You can use a\nsidecar container that performs all the leader-election operations and signals the\nmain container when it should become active. You\u2019ll find an example of leader elec-\ntion in Kubernetes at https:/\n/github.com/kubernetes/contrib/tree/master/election.\n Ensuring your apps are highly available is relatively simple, because Kubernetes\ntakes care of almost everything. But what if Kubernetes itself fails? What if the servers\nrunning the Kubernetes Control Plane components go down? How are those compo-\nnents made highly available?\n \n"}, {"color": "green", "id": "text_285", "label": "342\nCHAPTER 11\nUnderstanding Kubernetes internals\n11.6.2 Making Kubernetes Control Plane components highly available\nIn the beginning of this chapter, you learned about the few components that make up\na Kubernetes Control Plane. To make Kubernetes highly available, you need to run\nmultiple master nodes, which run multiple instances of the following components:\n\uf0a1etcd, which is the distributed data store where all the API objects are kept\n\uf0a1API server\n\uf0a1Controller Manager, which is the process in which all the controllers run\n\uf0a1Scheduler\nWithout going into the actual details of how to install and run these components, let\u2019s\nsee what\u2019s involved in making each of these components highly available. Figure 11.18\nshows an overview of a highly available cluster.\nRUNNING AN ETCD CLUSTER\nBecause etcd was designed as a distributed system, one of its key features is the ability\nto run multiple etcd instances, so making it highly available is no big deal. All you\nneed to do is run it on an appropriate number of machines (three, five, or seven, as\nexplained earlier in the chapter) and make them aware of each other. You do this by\nincluding the list of all the other instances in every instance\u2019s configuration. For\nexample, when starting an instance, you specify the IPs and ports where the other etcd\ninstances can be reached. \n etcd will replicate data across all its instances, so a failure of one of the nodes when\nrunning a three-machine cluster will still allow the cluster to accept both read and\nwrite operations. To increase the fault tolerance to more than a single node, you need\nto run five or seven etcd nodes, which would allow the cluster to handle two or three\nNode 1\nKubelet\nNode 2\nKubelet\nNode 3\nKubelet\nNode 4\nKubelet\nNode 5\nKubelet\n...\nNode N\nKubelet\nLoad\nbalancer\nMaster 3\netcd\nAPI server\nScheduler\nController\nManager\n[standing-by]\n[standing-by]\nMaster 2\netcd\nAPI server\nScheduler\nController\nManager\n[standing-by]\n[standing-by]\nMaster 1\netcd\nAPI server\nScheduler\nController\nManager\n[active]\n[active]\nFigure 11.18\nA highly-available cluster with three master nodes\n \n", "shape": "dot", "size": 10, "title": "342\nCHAPTER 11\nUnderstanding Kubernetes internals\n11.6.2 Making Kubernetes Control Plane components highly available\nIn the beginning of this chapter, you learned about the few components that make up\na Kubernetes Control Plane. To make Kubernetes highly available, you need to run\nmultiple master nodes, which run multiple instances of the following components:\n\uf0a1etcd, which is the distributed data store where all the API objects are kept\n\uf0a1API server\n\uf0a1Controller Manager, which is the process in which all the controllers run\n\uf0a1Scheduler\nWithout going into the actual details of how to install and run these components, let\u2019s\nsee what\u2019s involved in making each of these components highly available. Figure 11.18\nshows an overview of a highly available cluster.\nRUNNING AN ETCD CLUSTER\nBecause etcd was designed as a distributed system, one of its key features is the ability\nto run multiple etcd instances, so making it highly available is no big deal. All you\nneed to do is run it on an appropriate number of machines (three, five, or seven, as\nexplained earlier in the chapter) and make them aware of each other. You do this by\nincluding the list of all the other instances in every instance\u2019s configuration. For\nexample, when starting an instance, you specify the IPs and ports where the other etcd\ninstances can be reached. \n etcd will replicate data across all its instances, so a failure of one of the nodes when\nrunning a three-machine cluster will still allow the cluster to accept both read and\nwrite operations. To increase the fault tolerance to more than a single node, you need\nto run five or seven etcd nodes, which would allow the cluster to handle two or three\nNode 1\nKubelet\nNode 2\nKubelet\nNode 3\nKubelet\nNode 4\nKubelet\nNode 5\nKubelet\n...\nNode N\nKubelet\nLoad\nbalancer\nMaster 3\netcd\nAPI server\nScheduler\nController\nManager\n[standing-by]\n[standing-by]\nMaster 2\netcd\nAPI server\nScheduler\nController\nManager\n[standing-by]\n[standing-by]\nMaster 1\netcd\nAPI server\nScheduler\nController\nManager\n[active]\n[active]\nFigure 11.18\nA highly-available cluster with three master nodes\n \n"}, {"color": "green", "id": "text_286", "label": "343\nRunning highly available clusters\nnode failures, respectively. Having more than seven etcd instances is almost never nec-\nessary and begins impacting performance.\nRUNNING MULTIPLE INSTANCES OF THE API SERVER\nMaking the API server highly available is even simpler. Because the API server is (almost\ncompletely) stateless (all the data is stored in etcd, but the API server does cache it), you\ncan run as many API servers as you need, and they don\u2019t need to be aware of each other\nat all. Usually, one API server is collocated with every etcd instance. By doing this, the\netcd instances don\u2019t need any kind of load balancer in front of them, because every API\nserver instance only talks to the local etcd instance. \n The API servers, on the other hand, do need to be fronted by a load balancer, so\nclients (kubectl, but also the Controller Manager, Scheduler, and all the Kubelets)\nalways connect only to the healthy API server instances. \nENSURING HIGH AVAILABILITY OF THE CONTROLLERS AND THE SCHEDULER\nCompared to the API server, where multiple replicas can run simultaneously, run-\nning multiple instances of the Controller Manager or the Scheduler isn\u2019t as simple.\nBecause controllers and the Scheduler all actively watch the cluster state and act when\nit changes, possibly modifying the cluster state further (for example, when the desired\nreplica count on a ReplicaSet is increased by one, the ReplicaSet controller creates an\nadditional pod), running multiple instances of each of those components would\nresult in all of them performing the same action. They\u2019d be racing each other, which\ncould cause undesired effects (creating two new pods instead of one, as mentioned in\nthe previous example).\n For this reason, when running multiple instances of these components, only one\ninstance may be active at any given time. Luckily, this is all taken care of by the compo-\nnents themselves (this is controlled with the --leader-elect option, which defaults to\ntrue). Each individual component will only be active when it\u2019s the elected leader. Only\nthe leader performs actual work, whereas all other instances are standing by and waiting\nfor the current leader to fail. When it does, the remaining instances elect a new leader,\nwhich then takes over the work. This mechanism ensures that two components are never\noperating at the same time and doing the same work (see figure 11.19).\nMaster 3\nScheduler\nController\nManager\n[standing-by]\n[standing-by]\nMaster 1\nScheduler\nController\nManager\n[active]\n[active]\nMaster 2\nScheduler\nController\nManager\n[standing-by]\n[standing-by]\nOnly the controllers in\nthis Controller Manager\nare reacting to API\nresources being created,\nupdated, and deleted.\nThese Controller Managers\nand Schedulers aren\u2019t doing\nanything except waiting to\nbecome leaders.\nOnly this Scheduler\nis scheduling pods.\nFigure 11.19\nOnly a single Controller Manager and a single Scheduler are active; others are standing by.\n \n", "shape": "dot", "size": 10, "title": "343\nRunning highly available clusters\nnode failures, respectively. Having more than seven etcd instances is almost never nec-\nessary and begins impacting performance.\nRUNNING MULTIPLE INSTANCES OF THE API SERVER\nMaking the API server highly available is even simpler. Because the API server is (almost\ncompletely) stateless (all the data is stored in etcd, but the API server does cache it), you\ncan run as many API servers as you need, and they don\u2019t need to be aware of each other\nat all. Usually, one API server is collocated with every etcd instance. By doing this, the\netcd instances don\u2019t need any kind of load balancer in front of them, because every API\nserver instance only talks to the local etcd instance. \n The API servers, on the other hand, do need to be fronted by a load balancer, so\nclients (kubectl, but also the Controller Manager, Scheduler, and all the Kubelets)\nalways connect only to the healthy API server instances. \nENSURING HIGH AVAILABILITY OF THE CONTROLLERS AND THE SCHEDULER\nCompared to the API server, where multiple replicas can run simultaneously, run-\nning multiple instances of the Controller Manager or the Scheduler isn\u2019t as simple.\nBecause controllers and the Scheduler all actively watch the cluster state and act when\nit changes, possibly modifying the cluster state further (for example, when the desired\nreplica count on a ReplicaSet is increased by one, the ReplicaSet controller creates an\nadditional pod), running multiple instances of each of those components would\nresult in all of them performing the same action. They\u2019d be racing each other, which\ncould cause undesired effects (creating two new pods instead of one, as mentioned in\nthe previous example).\n For this reason, when running multiple instances of these components, only one\ninstance may be active at any given time. Luckily, this is all taken care of by the compo-\nnents themselves (this is controlled with the --leader-elect option, which defaults to\ntrue). Each individual component will only be active when it\u2019s the elected leader. Only\nthe leader performs actual work, whereas all other instances are standing by and waiting\nfor the current leader to fail. When it does, the remaining instances elect a new leader,\nwhich then takes over the work. This mechanism ensures that two components are never\noperating at the same time and doing the same work (see figure 11.19).\nMaster 3\nScheduler\nController\nManager\n[standing-by]\n[standing-by]\nMaster 1\nScheduler\nController\nManager\n[active]\n[active]\nMaster 2\nScheduler\nController\nManager\n[standing-by]\n[standing-by]\nOnly the controllers in\nthis Controller Manager\nare reacting to API\nresources being created,\nupdated, and deleted.\nThese Controller Managers\nand Schedulers aren\u2019t doing\nanything except waiting to\nbecome leaders.\nOnly this Scheduler\nis scheduling pods.\nFigure 11.19\nOnly a single Controller Manager and a single Scheduler are active; others are standing by.\n \n"}, {"color": "green", "id": "text_287", "label": "344\nCHAPTER 11\nUnderstanding Kubernetes internals\nThe Controller Manager and Scheduler can run collocated with the API server and\netcd, or they can run on separate machines. When collocated, they can talk to the\nlocal API server directly; otherwise they connect to the API servers through the load\nbalancer.\nUNDERSTANDING THE LEADER ELECTION MECHANISM USED IN CONTROL PLANE COMPONENTS\nWhat I find most interesting here is that these components don\u2019t need to talk to each\nother directly to elect a leader. The leader election mechanism works purely by creat-\ning a resource in the API server. And it\u2019s not even a special kind of resource\u2014the End-\npoints resource is used to achieve this (abused is probably a more appropriate term).\n There\u2019s nothing special about using an Endpoints object to do this. It\u2019s used\nbecause it has no side effects as long as no Service with the same name exists. Any\nother resource could be used (in fact, the leader election mechanism will soon use\nConfigMaps instead of Endpoints). \n I\u2019m sure you\u2019re interested in how a resource can be used for this purpose. Let\u2019s\ntake the Scheduler, for example. All instances of the Scheduler try to create (and later\nupdate) an Endpoints resource called kube-scheduler. You\u2019ll find it in the kube-\nsystem namespace, as the following listing shows.\n$ kubectl get endpoints kube-scheduler -n kube-system -o yaml\napiVersion: v1\nkind: Endpoints\nmetadata:\n  annotations:\n    control-plane.alpha.kubernetes.io/leader: \u0027{\"holderIdentity\":\n      \u27a5 \"minikube\",\"leaseDurationSeconds\":15,\"acquireTime\":\n      \u27a5 \"2017-05-27T18:54:53Z\",\"renewTime\":\"2017-05-28T13:07:49Z\",\n      \u27a5 \"leaderTransitions\":0}\u0027\n  creationTimestamp: 2017-05-27T18:54:53Z\n  name: kube-scheduler\n  namespace: kube-system\n  resourceVersion: \"654059\"\n  selfLink: /api/v1/namespaces/kube-system/endpoints/kube-scheduler\n  uid: f847bd14-430d-11e7-9720-080027f8fa4e\nsubsets: []\nThe control-plane.alpha.kubernetes.io/leader annotation is the important part.\nAs you can see, it contains a field called holderIdentity, which holds the name of the\ncurrent leader. The first instance that succeeds in putting its name there becomes\nthe leader. Instances race each other to do that, but there\u2019s always only one winner.\n Remember the optimistic concurrency we explained earlier? That\u2019s what ensures\nthat if multiple instances try to write their name into the resource only one of them\nsucceeds. Based on whether the write succeeded or not, each instance knows whether\nit is or it isn\u2019t the leader. \n Once becoming the leader, it must periodically update the resource (every two sec-\nonds by default), so all other instances know that it\u2019s still alive. When the leader fails,\nListing 11.11\nThe kube-scheduler Endpoints resource used for leader-election\n \n", "shape": "dot", "size": 10, "title": "344\nCHAPTER 11\nUnderstanding Kubernetes internals\nThe Controller Manager and Scheduler can run collocated with the API server and\netcd, or they can run on separate machines. When collocated, they can talk to the\nlocal API server directly; otherwise they connect to the API servers through the load\nbalancer.\nUNDERSTANDING THE LEADER ELECTION MECHANISM USED IN CONTROL PLANE COMPONENTS\nWhat I find most interesting here is that these components don\u2019t need to talk to each\nother directly to elect a leader. The leader election mechanism works purely by creat-\ning a resource in the API server. And it\u2019s not even a special kind of resource\u2014the End-\npoints resource is used to achieve this (abused is probably a more appropriate term).\n There\u2019s nothing special about using an Endpoints object to do this. It\u2019s used\nbecause it has no side effects as long as no Service with the same name exists. Any\nother resource could be used (in fact, the leader election mechanism will soon use\nConfigMaps instead of Endpoints). \n I\u2019m sure you\u2019re interested in how a resource can be used for this purpose. Let\u2019s\ntake the Scheduler, for example. All instances of the Scheduler try to create (and later\nupdate) an Endpoints resource called kube-scheduler. You\u2019ll find it in the kube-\nsystem namespace, as the following listing shows.\n$ kubectl get endpoints kube-scheduler -n kube-system -o yaml\napiVersion: v1\nkind: Endpoints\nmetadata:\n  annotations:\n    control-plane.alpha.kubernetes.io/leader: \u0027{\"holderIdentity\":\n      \u27a5 \"minikube\",\"leaseDurationSeconds\":15,\"acquireTime\":\n      \u27a5 \"2017-05-27T18:54:53Z\",\"renewTime\":\"2017-05-28T13:07:49Z\",\n      \u27a5 \"leaderTransitions\":0}\u0027\n  creationTimestamp: 2017-05-27T18:54:53Z\n  name: kube-scheduler\n  namespace: kube-system\n  resourceVersion: \"654059\"\n  selfLink: /api/v1/namespaces/kube-system/endpoints/kube-scheduler\n  uid: f847bd14-430d-11e7-9720-080027f8fa4e\nsubsets: []\nThe control-plane.alpha.kubernetes.io/leader annotation is the important part.\nAs you can see, it contains a field called holderIdentity, which holds the name of the\ncurrent leader. The first instance that succeeds in putting its name there becomes\nthe leader. Instances race each other to do that, but there\u2019s always only one winner.\n Remember the optimistic concurrency we explained earlier? That\u2019s what ensures\nthat if multiple instances try to write their name into the resource only one of them\nsucceeds. Based on whether the write succeeded or not, each instance knows whether\nit is or it isn\u2019t the leader. \n Once becoming the leader, it must periodically update the resource (every two sec-\nonds by default), so all other instances know that it\u2019s still alive. When the leader fails,\nListing 11.11\nThe kube-scheduler Endpoints resource used for leader-election\n \n"}, {"color": "green", "id": "text_288", "label": "345\nSummary\nother instances see that the resource hasn\u2019t been updated for a while, and try to become\nthe leader by writing their own name to the resource. Simple, right?\n11.7\nSummary\nHopefully, this has been an interesting chapter that has improved your knowledge of\nthe inner workings of Kubernetes. This chapter has shown you\n\uf0a1What components make up a Kubernetes cluster and what each component is\nresponsible for\n\uf0a1How the API server, Scheduler, various controllers running in the Controller\nManager, and the Kubelet work together to bring a pod to life\n\uf0a1How the infrastructure container binds together all the containers of a pod\n\uf0a1How pods communicate with other pods running on the same node through\nthe network bridge, and how those bridges on different nodes are connected,\nso pods running on different nodes can talk to each other\n\uf0a1How the kube-proxy performs load balancing across pods in the same service by\nconfiguring iptables rules on the node\n\uf0a1How multiple instances of each component of the Control Plane can be run to\nmake the cluster highly available\nNext, we\u2019ll look at how to secure the API server and, by extension, the cluster as a whole.\n \n", "shape": "dot", "size": 10, "title": "345\nSummary\nother instances see that the resource hasn\u2019t been updated for a while, and try to become\nthe leader by writing their own name to the resource. Simple, right?\n11.7\nSummary\nHopefully, this has been an interesting chapter that has improved your knowledge of\nthe inner workings of Kubernetes. This chapter has shown you\n\uf0a1What components make up a Kubernetes cluster and what each component is\nresponsible for\n\uf0a1How the API server, Scheduler, various controllers running in the Controller\nManager, and the Kubelet work together to bring a pod to life\n\uf0a1How the infrastructure container binds together all the containers of a pod\n\uf0a1How pods communicate with other pods running on the same node through\nthe network bridge, and how those bridges on different nodes are connected,\nso pods running on different nodes can talk to each other\n\uf0a1How the kube-proxy performs load balancing across pods in the same service by\nconfiguring iptables rules on the node\n\uf0a1How multiple instances of each component of the Control Plane can be run to\nmake the cluster highly available\nNext, we\u2019ll look at how to secure the API server and, by extension, the cluster as a whole.\n \n"}, {"color": "green", "id": "text_289", "label": "346\nSecuring the\nKubernetes API server\nIn chapter 8 you learned how applications running in pods can talk to the API\nserver to retrieve or change the state of resources deployed in the cluster. To\nauthenticate with the API server, you used the ServiceAccount token mounted into\nthe pod. In this chapter, you\u2019ll learn what ServiceAccounts are and how to config-\nure their permissions, as well as permissions for other subjects using the cluster. \n12.1\nUnderstanding authentication\nIn the previous chapter, we said the API server can be configured with one or more\nauthentication plugins (and the same is true for authorization plugins). When a\nrequest is received by the API server, it goes through the list of authentication\nThis chapter covers\n\uf0a1Understanding authentication\n\uf0a1What ServiceAccounts are and why they\u2019re used\n\uf0a1Understanding the role-based access control \n(RBAC) plugin\n\uf0a1Using Roles and RoleBindings\n\uf0a1Using ClusterRoles and ClusterRoleBindings\n\uf0a1Understanding the default roles and bindings\n \n", "shape": "dot", "size": 10, "title": "346\nSecuring the\nKubernetes API server\nIn chapter 8 you learned how applications running in pods can talk to the API\nserver to retrieve or change the state of resources deployed in the cluster. To\nauthenticate with the API server, you used the ServiceAccount token mounted into\nthe pod. In this chapter, you\u2019ll learn what ServiceAccounts are and how to config-\nure their permissions, as well as permissions for other subjects using the cluster. \n12.1\nUnderstanding authentication\nIn the previous chapter, we said the API server can be configured with one or more\nauthentication plugins (and the same is true for authorization plugins). When a\nrequest is received by the API server, it goes through the list of authentication\nThis chapter covers\n\uf0a1Understanding authentication\n\uf0a1What ServiceAccounts are and why they\u2019re used\n\uf0a1Understanding the role-based access control \n(RBAC) plugin\n\uf0a1Using Roles and RoleBindings\n\uf0a1Using ClusterRoles and ClusterRoleBindings\n\uf0a1Understanding the default roles and bindings\n \n"}, {"color": "green", "id": "text_290", "label": "347\nUnderstanding authentication\nplugins, so they can each examine the request and try to determine who\u2019s sending the\nrequest. The first plugin that can extract that information from the request returns\nthe username, user ID, and the groups the client belongs to back to the API server\ncore. The API server stops invoking the remaining authentication plugins and contin-\nues onto the authorization phase. \n Several authentication plugins are available. They obtain the identity of the client\nusing the following methods:\n\uf0a1From the client certificate\n\uf0a1From an authentication token passed in an HTTP header\n\uf0a1Basic HTTP authentication\n\uf0a1Others\nThe authentication plugins are enabled through command-line options when starting\nthe API server. \n12.1.1 Users and groups\nAn authentication plugin returns the username and group(s) of the authenticated\nuser. Kubernetes doesn\u2019t store that information anywhere; it uses it to verify whether\nthe user is authorized to perform an action or not.\nUNDERSTANDING USERS\nKubernetes distinguishes between two kinds of clients connecting to the API server:\n\uf0a1Actual humans (users)\n\uf0a1Pods (more specifically, applications running inside them)\nBoth these types of clients are authenticated using the aforementioned authentication\nplugins. Users are meant to be managed by an external system, such as a Single Sign\nOn (SSO) system, but the pods use a mechanism called service accounts, which are cre-\nated and stored in the cluster as ServiceAccount resources. In contrast, no resource\nrepresents user accounts, which means you can\u2019t create, update, or delete users through\nthe API server. \n We won\u2019t go into any details of how to manage users, but we will explore Service-\nAccounts in detail, because they\u2019re essential for running pods. For more informa-\ntion on how to configure the cluster for authentication of human users, cluster\nadministrators should refer to the Kubernetes Cluster Administrator guide at http:/\n/\nkubernetes.io/docs/admin.\nUNDERSTANDING GROUPS\nBoth human users and ServiceAccounts can belong to one or more groups. We\u2019ve said\nthat the authentication plugin returns groups along with the username and user ID.\nGroups are used to grant permissions to several users at once, instead of having to\ngrant them to individual users. \n \n", "shape": "dot", "size": 10, "title": "347\nUnderstanding authentication\nplugins, so they can each examine the request and try to determine who\u2019s sending the\nrequest. The first plugin that can extract that information from the request returns\nthe username, user ID, and the groups the client belongs to back to the API server\ncore. The API server stops invoking the remaining authentication plugins and contin-\nues onto the authorization phase. \n Several authentication plugins are available. They obtain the identity of the client\nusing the following methods:\n\uf0a1From the client certificate\n\uf0a1From an authentication token passed in an HTTP header\n\uf0a1Basic HTTP authentication\n\uf0a1Others\nThe authentication plugins are enabled through command-line options when starting\nthe API server. \n12.1.1 Users and groups\nAn authentication plugin returns the username and group(s) of the authenticated\nuser. Kubernetes doesn\u2019t store that information anywhere; it uses it to verify whether\nthe user is authorized to perform an action or not.\nUNDERSTANDING USERS\nKubernetes distinguishes between two kinds of clients connecting to the API server:\n\uf0a1Actual humans (users)\n\uf0a1Pods (more specifically, applications running inside them)\nBoth these types of clients are authenticated using the aforementioned authentication\nplugins. Users are meant to be managed by an external system, such as a Single Sign\nOn (SSO) system, but the pods use a mechanism called service accounts, which are cre-\nated and stored in the cluster as ServiceAccount resources. In contrast, no resource\nrepresents user accounts, which means you can\u2019t create, update, or delete users through\nthe API server. \n We won\u2019t go into any details of how to manage users, but we will explore Service-\nAccounts in detail, because they\u2019re essential for running pods. For more informa-\ntion on how to configure the cluster for authentication of human users, cluster\nadministrators should refer to the Kubernetes Cluster Administrator guide at http:/\n/\nkubernetes.io/docs/admin.\nUNDERSTANDING GROUPS\nBoth human users and ServiceAccounts can belong to one or more groups. We\u2019ve said\nthat the authentication plugin returns groups along with the username and user ID.\nGroups are used to grant permissions to several users at once, instead of having to\ngrant them to individual users. \n \n"}, {"color": "green", "id": "text_291", "label": "348\nCHAPTER 12\nSecuring the Kubernetes API server\n Groups returned by the plugin are nothing but strings, representing arbitrary\ngroup names, but built-in groups have special meaning:\n\uf0a1The system:unauthenticated group is used for requests where none of the\nauthentication plugins could authenticate the client.\n\uf0a1The system:authenticated group is automatically assigned to a user who was\nauthenticated successfully.\n\uf0a1The system:serviceaccounts group encompasses all ServiceAccounts in the\nsystem.\n\uf0a1The system:serviceaccounts:\u003cnamespace\u003e includes all ServiceAccounts in a\nspecific namespace.\n12.1.2 Introducing ServiceAccounts\nLet\u2019s explore ServiceAccounts up close. You\u2019ve already learned that the API server\nrequires clients to authenticate themselves before they\u2019re allowed to perform opera-\ntions on the server. And you\u2019ve already seen how pods can authenticate by sending the\ncontents of the file/var/run/secrets/kubernetes.io/serviceaccount/token, which\nis mounted into each container\u2019s filesystem through a secret volume.\n But what exactly does that file represent? Every pod is associated with a Service-\nAccount, which represents the identity of the app running in the pod. The token file\nholds the ServiceAccount\u2019s authentication token. When an app uses this token to con-\nnect to the API server, the authentication plugin authenticates the ServiceAccount\nand passes the ServiceAccount\u2019s username back to the API server core. Service-\nAccount usernames are formatted like this:\nsystem:serviceaccount:\u003cnamespace\u003e:\u003cservice account name\u003e\nThe API server passes this username to the configured authorization plugins, which\ndetermine whether the action the app is trying to perform is allowed to be performed\nby the ServiceAccount.\n ServiceAccounts are nothing more than a way for an application running inside a\npod to authenticate itself with the API server. As already mentioned, applications do\nthat by passing the ServiceAccount\u2019s token in the request.\nUNDERSTANDING THE SERVICEACCOUNT RESOURCE\nServiceAccounts are resources just like Pods, Secrets, ConfigMaps, and so on, and are\nscoped to individual namespaces. A default ServiceAccount is automatically created\nfor each namespace (that\u2019s the one your pods have used all along). \n You can list ServiceAccounts like you do other resources:\n$ kubectl get sa\nNAME      SECRETS   AGE\ndefault   1         1d\nNOTE\nThe shorthand for serviceaccount is sa.\n \n", "shape": "dot", "size": 10, "title": "348\nCHAPTER 12\nSecuring the Kubernetes API server\n Groups returned by the plugin are nothing but strings, representing arbitrary\ngroup names, but built-in groups have special meaning:\n\uf0a1The system:unauthenticated group is used for requests where none of the\nauthentication plugins could authenticate the client.\n\uf0a1The system:authenticated group is automatically assigned to a user who was\nauthenticated successfully.\n\uf0a1The system:serviceaccounts group encompasses all ServiceAccounts in the\nsystem.\n\uf0a1The system:serviceaccounts:\u003cnamespace\u003e includes all ServiceAccounts in a\nspecific namespace.\n12.1.2 Introducing ServiceAccounts\nLet\u2019s explore ServiceAccounts up close. You\u2019ve already learned that the API server\nrequires clients to authenticate themselves before they\u2019re allowed to perform opera-\ntions on the server. And you\u2019ve already seen how pods can authenticate by sending the\ncontents of the file/var/run/secrets/kubernetes.io/serviceaccount/token, which\nis mounted into each container\u2019s filesystem through a secret volume.\n But what exactly does that file represent? Every pod is associated with a Service-\nAccount, which represents the identity of the app running in the pod. The token file\nholds the ServiceAccount\u2019s authentication token. When an app uses this token to con-\nnect to the API server, the authentication plugin authenticates the ServiceAccount\nand passes the ServiceAccount\u2019s username back to the API server core. Service-\nAccount usernames are formatted like this:\nsystem:serviceaccount:\u003cnamespace\u003e:\u003cservice account name\u003e\nThe API server passes this username to the configured authorization plugins, which\ndetermine whether the action the app is trying to perform is allowed to be performed\nby the ServiceAccount.\n ServiceAccounts are nothing more than a way for an application running inside a\npod to authenticate itself with the API server. As already mentioned, applications do\nthat by passing the ServiceAccount\u2019s token in the request.\nUNDERSTANDING THE SERVICEACCOUNT RESOURCE\nServiceAccounts are resources just like Pods, Secrets, ConfigMaps, and so on, and are\nscoped to individual namespaces. A default ServiceAccount is automatically created\nfor each namespace (that\u2019s the one your pods have used all along). \n You can list ServiceAccounts like you do other resources:\n$ kubectl get sa\nNAME      SECRETS   AGE\ndefault   1         1d\nNOTE\nThe shorthand for serviceaccount is sa.\n \n"}, {"color": "green", "id": "text_292", "label": "349\nUnderstanding authentication\nAs you can see, the current namespace only contains the default ServiceAccount. Addi-\ntional ServiceAccounts can be added when required. Each pod is associated with exactly\none ServiceAccount, but multiple pods can use the same ServiceAccount. As you can\nsee in figure 12.1, a pod can only use a ServiceAccount from the same namespace.\nUNDERSTANDING HOW SERVICEACCOUNTS TIE INTO AUTHORIZATION\nYou can assign a ServiceAccount to a pod by specifying the account\u2019s name in the pod\nmanifest. If you don\u2019t assign it explicitly, the pod will use the default ServiceAccount\nin the namespace.\n By assigning different ServiceAccounts to pods, you can control which resources\neach pod has access to. When a request bearing the authentication token is received\nby the API server, the server uses the token to authenticate the client sending the\nrequest and then determines whether or not the related ServiceAccount is allowed to\nperform the requested operation. The API server obtains this information from the\nsystem-wide authorization plugin configured by the cluster administrator. One of\nthe available authorization plugins is the role-based access control (RBAC) plugin,\nwhich is discussed later in this chapter. From Kubernetes version 1.6 on, the RBAC\nplugin is the plugin most clusters should use.\n12.1.3 Creating ServiceAccounts\nWe\u2019ve said every namespace contains its own default ServiceAccount, but additional\nones can be created if necessary. But why should you bother with creating Service-\nAccounts instead of using the default one for all your pods? \n The obvious reason is cluster security. Pods that don\u2019t need to read any cluster\nmetadata should run under a constrained account that doesn\u2019t allow them to retrieve\nor modify any resources deployed in the cluster. Pods that need to retrieve resource\nmetadata should run under a ServiceAccount that only allows reading those objects\u2019\nmetadata, whereas pods that need to modify those objects should run under their own\nServiceAccount allowing modifications of API objects. \nPod\nNamespace: foo\nService-\nAccount:\ndefault\nPod\nPod\nNamespace: baz\nPod\nNamespace: bar\nPod\nPod\nNot possible\nService-\nAccount:\ndefault\nAnother\nService-\nAccount\nMultiple pods using the\nsame ServiceAccount\nFigure 12.1\nEach pod is associated with a single ServiceAccount in the pod\u2019s namespace.\n \n", "shape": "dot", "size": 10, "title": "349\nUnderstanding authentication\nAs you can see, the current namespace only contains the default ServiceAccount. Addi-\ntional ServiceAccounts can be added when required. Each pod is associated with exactly\none ServiceAccount, but multiple pods can use the same ServiceAccount. As you can\nsee in figure 12.1, a pod can only use a ServiceAccount from the same namespace.\nUNDERSTANDING HOW SERVICEACCOUNTS TIE INTO AUTHORIZATION\nYou can assign a ServiceAccount to a pod by specifying the account\u2019s name in the pod\nmanifest. If you don\u2019t assign it explicitly, the pod will use the default ServiceAccount\nin the namespace.\n By assigning different ServiceAccounts to pods, you can control which resources\neach pod has access to. When a request bearing the authentication token is received\nby the API server, the server uses the token to authenticate the client sending the\nrequest and then determines whether or not the related ServiceAccount is allowed to\nperform the requested operation. The API server obtains this information from the\nsystem-wide authorization plugin configured by the cluster administrator. One of\nthe available authorization plugins is the role-based access control (RBAC) plugin,\nwhich is discussed later in this chapter. From Kubernetes version 1.6 on, the RBAC\nplugin is the plugin most clusters should use.\n12.1.3 Creating ServiceAccounts\nWe\u2019ve said every namespace contains its own default ServiceAccount, but additional\nones can be created if necessary. But why should you bother with creating Service-\nAccounts instead of using the default one for all your pods? \n The obvious reason is cluster security. Pods that don\u2019t need to read any cluster\nmetadata should run under a constrained account that doesn\u2019t allow them to retrieve\nor modify any resources deployed in the cluster. Pods that need to retrieve resource\nmetadata should run under a ServiceAccount that only allows reading those objects\u2019\nmetadata, whereas pods that need to modify those objects should run under their own\nServiceAccount allowing modifications of API objects. \nPod\nNamespace: foo\nService-\nAccount:\ndefault\nPod\nPod\nNamespace: baz\nPod\nNamespace: bar\nPod\nPod\nNot possible\nService-\nAccount:\ndefault\nAnother\nService-\nAccount\nMultiple pods using the\nsame ServiceAccount\nFigure 12.1\nEach pod is associated with a single ServiceAccount in the pod\u2019s namespace.\n \n"}, {"color": "green", "id": "text_293", "label": "350\nCHAPTER 12\nSecuring the Kubernetes API server\n Let\u2019s see how you can create additional ServiceAccounts, how they relate to Secrets,\nand how you can assign them to your pods.\nCREATING A SERVICEACCOUNT\nCreating a ServiceAccount is incredibly easy, thanks to the dedicated kubectl create\nserviceaccount command. Let\u2019s create a new ServiceAccount called foo:\n$ kubectl create serviceaccount foo\nserviceaccount \"foo\" created\nNow, you can inspect the ServiceAccount with the describe command, as shown in\nthe following listing.\n$ kubectl describe sa foo\nName:               foo\nNamespace:          default\nLabels:             \u003cnone\u003e\nImage pull secrets: \u003cnone\u003e             \nMountable secrets:  foo-token-qzq7j    \nTokens:             foo-token-qzq7j    \nYou can see that a custom token Secret has been created and associated with the\nServiceAccount. If you look at the Secret\u2019s data with kubectl describe secret foo-\ntoken-qzq7j, you\u2019ll see it contains the same items (the CA certificate, namespace, and\ntoken) as the default ServiceAccount\u2019s token does (the token itself will obviously be\ndifferent), as shown in the following listing.\n$ kubectl describe secret foo-token-qzq7j\n...\nca.crt:         1066 bytes\nnamespace:      7 bytes\ntoken:          eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9...\nNOTE\nYou\u2019ve probably heard of JSON Web Tokens (JWT). The authentica-\ntion tokens used in ServiceAccounts are JWT tokens.\nUNDERSTANDING A SERVICEACCOUNT\u2019S MOUNTABLE SECRETS\nThe token is shown in the Mountable secrets list when you inspect a ServiceAccount\nwith kubectl describe. Let me explain what that list represents. In chapter 7 you\nlearned how to create Secrets and mount them inside a pod. By default, a pod can\nmount any Secret it wants. But the pod\u2019s ServiceAccount can be configured to only\nListing 12.1\nInspecting a ServiceAccount with kubectl describe\nListing 12.2\nInspecting the custom ServiceAccount\u2019s Secret\nThese will be added \nautomatically to all pods \nusing this ServiceAccount.\nPods using this ServiceAccount \ncan only mount these Secrets if \nmountable Secrets are enforced.\nAuthentication token(s). \nThe first one is mounted \ninside the container.\n \n", "shape": "dot", "size": 10, "title": "350\nCHAPTER 12\nSecuring the Kubernetes API server\n Let\u2019s see how you can create additional ServiceAccounts, how they relate to Secrets,\nand how you can assign them to your pods.\nCREATING A SERVICEACCOUNT\nCreating a ServiceAccount is incredibly easy, thanks to the dedicated kubectl create\nserviceaccount command. Let\u2019s create a new ServiceAccount called foo:\n$ kubectl create serviceaccount foo\nserviceaccount \"foo\" created\nNow, you can inspect the ServiceAccount with the describe command, as shown in\nthe following listing.\n$ kubectl describe sa foo\nName:               foo\nNamespace:          default\nLabels:             \u003cnone\u003e\nImage pull secrets: \u003cnone\u003e             \nMountable secrets:  foo-token-qzq7j    \nTokens:             foo-token-qzq7j    \nYou can see that a custom token Secret has been created and associated with the\nServiceAccount. If you look at the Secret\u2019s data with kubectl describe secret foo-\ntoken-qzq7j, you\u2019ll see it contains the same items (the CA certificate, namespace, and\ntoken) as the default ServiceAccount\u2019s token does (the token itself will obviously be\ndifferent), as shown in the following listing.\n$ kubectl describe secret foo-token-qzq7j\n...\nca.crt:         1066 bytes\nnamespace:      7 bytes\ntoken:          eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9...\nNOTE\nYou\u2019ve probably heard of JSON Web Tokens (JWT). The authentica-\ntion tokens used in ServiceAccounts are JWT tokens.\nUNDERSTANDING A SERVICEACCOUNT\u2019S MOUNTABLE SECRETS\nThe token is shown in the Mountable secrets list when you inspect a ServiceAccount\nwith kubectl describe. Let me explain what that list represents. In chapter 7 you\nlearned how to create Secrets and mount them inside a pod. By default, a pod can\nmount any Secret it wants. But the pod\u2019s ServiceAccount can be configured to only\nListing 12.1\nInspecting a ServiceAccount with kubectl describe\nListing 12.2\nInspecting the custom ServiceAccount\u2019s Secret\nThese will be added \nautomatically to all pods \nusing this ServiceAccount.\nPods using this ServiceAccount \ncan only mount these Secrets if \nmountable Secrets are enforced.\nAuthentication token(s). \nThe first one is mounted \ninside the container.\n \n"}, {"color": "green", "id": "text_294", "label": "351\nUnderstanding authentication\nallow the pod to mount Secrets that are listed as mountable Secrets on the Service-\nAccount. To enable this feature, the ServiceAccount must contain the following anno-\ntation: kubernetes.io/enforce-mountable-secrets=\"true\". \n If the ServiceAccount is annotated with this annotation, any pods using it can mount\nonly the ServiceAccount\u2019s mountable Secrets\u2014they can\u2019t use any other Secret.\nUNDERSTANDING A SERVICEACCOUNT\u2019S IMAGE PULL SECRETS\nA ServiceAccount can also contain a list of image pull Secrets, which we examined in\nchapter 7. In case you don\u2019t remember, they are Secrets that hold the credentials for\npulling container images from a private image repository. \n The following listing shows an example of a ServiceAccount definition, which\nincludes the image pull Secret you created in chapter 7.\napiVersion: v1\nkind: ServiceAccount\nmetadata:\n  name: my-service-account\nimagePullSecrets:\n- name: my-dockerhub-secret\nA ServiceAccount\u2019s image pull Secrets behave slightly differently than its mountable\nSecrets. Unlike mountable Secrets, they don\u2019t determine which image pull Secrets a\npod can use, but which ones are added automatically to all pods using the Service-\nAccount. Adding image pull Secrets to a ServiceAccount saves you from having to add\nthem to each pod individually. \n12.1.4 Assigning a ServiceAccount to a pod\nAfter you create additional ServiceAccounts, you need to assign them to pods. This is\ndone by setting the name of the ServiceAccount in the spec.serviceAccountName\nfield in the pod definition. \nNOTE\nA pod\u2019s ServiceAccount must be set when creating the pod. It can\u2019t be\nchanged later. \nCREATING A POD WHICH USES A CUSTOM SERVICEACCOUNT\nIn chapter 8 you deployed a pod that ran a container based on the tutum/curl image\nand an ambassador container alongside it. You used it to explore the API server\u2019s\nREST interface. The ambassador container ran the kubectl proxy process, which\nused the pod\u2019s ServiceAccount\u2019s token to authenticate with the API server. \n You can now modify the pod so it uses the foo ServiceAccount you created minutes\nago. The next listing shows the pod definition.\n \n \nListing 12.3\nServiceAccount with an image pull Secret: sa-image-pull-secrets.yaml\n \n", "shape": "dot", "size": 10, "title": "351\nUnderstanding authentication\nallow the pod to mount Secrets that are listed as mountable Secrets on the Service-\nAccount. To enable this feature, the ServiceAccount must contain the following anno-\ntation: kubernetes.io/enforce-mountable-secrets=\"true\". \n If the ServiceAccount is annotated with this annotation, any pods using it can mount\nonly the ServiceAccount\u2019s mountable Secrets\u2014they can\u2019t use any other Secret.\nUNDERSTANDING A SERVICEACCOUNT\u2019S IMAGE PULL SECRETS\nA ServiceAccount can also contain a list of image pull Secrets, which we examined in\nchapter 7. In case you don\u2019t remember, they are Secrets that hold the credentials for\npulling container images from a private image repository. \n The following listing shows an example of a ServiceAccount definition, which\nincludes the image pull Secret you created in chapter 7.\napiVersion: v1\nkind: ServiceAccount\nmetadata:\n  name: my-service-account\nimagePullSecrets:\n- name: my-dockerhub-secret\nA ServiceAccount\u2019s image pull Secrets behave slightly differently than its mountable\nSecrets. Unlike mountable Secrets, they don\u2019t determine which image pull Secrets a\npod can use, but which ones are added automatically to all pods using the Service-\nAccount. Adding image pull Secrets to a ServiceAccount saves you from having to add\nthem to each pod individually. \n12.1.4 Assigning a ServiceAccount to a pod\nAfter you create additional ServiceAccounts, you need to assign them to pods. This is\ndone by setting the name of the ServiceAccount in the spec.serviceAccountName\nfield in the pod definition. \nNOTE\nA pod\u2019s ServiceAccount must be set when creating the pod. It can\u2019t be\nchanged later. \nCREATING A POD WHICH USES A CUSTOM SERVICEACCOUNT\nIn chapter 8 you deployed a pod that ran a container based on the tutum/curl image\nand an ambassador container alongside it. You used it to explore the API server\u2019s\nREST interface. The ambassador container ran the kubectl proxy process, which\nused the pod\u2019s ServiceAccount\u2019s token to authenticate with the API server. \n You can now modify the pod so it uses the foo ServiceAccount you created minutes\nago. The next listing shows the pod definition.\n \n \nListing 12.3\nServiceAccount with an image pull Secret: sa-image-pull-secrets.yaml\n \n"}, {"color": "green", "id": "text_295", "label": "352\nCHAPTER 12\nSecuring the Kubernetes API server\napiVersion: v1\nkind: Pod\nmetadata:\n  name: curl-custom-sa\nspec:\n  serviceAccountName: foo           \n  containers:\n  - name: main\n    image: tutum/curl\n    command: [\"sleep\", \"9999999\"]\n  - name: ambassador                  \n    image: luksa/kubectl-proxy:1.6.2\nTo confirm that the custom ServiceAccount\u2019s token is mounted into the two contain-\ners, you can print the contents of the token as shown in the following listing.\n$ kubectl exec -it curl-custom-sa -c main \n\u27a5 cat /var/run/secrets/kubernetes.io/serviceaccount/token\neyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9...\nYou can see the token is the one from the foo ServiceAccount by comparing the token\nstring in listing 12.5 with the one in listing 12.2. \nUSING THE CUSTOM SERVICEACCOUNT\u2019S TOKEN TO TALK TO THE API SERVER\nLet\u2019s see if you can talk to the API server using this token. As mentioned previously,\nthe ambassador container uses the token when talking to the server, so you can test\nthe token by going through the ambassador, which listens on localhost:8001, as\nshown in the following listing.\n$ kubectl exec -it curl-custom-sa -c main curl localhost:8001/api/v1/pods\n{\n  \"kind\": \"PodList\",\n  \"apiVersion\": \"v1\",\n  \"metadata\": {\n    \"selfLink\": \"/api/v1/pods\",\n    \"resourceVersion\": \"433895\"\n  },\n  \"items\": [\n  ...\nOkay, you got back a proper response from the server, which means the custom\nServiceAccount is allowed to list pods. This may be because your cluster doesn\u2019t use\nthe RBAC authorization plugin, or you gave all ServiceAccounts full permissions, as\ninstructed in chapter 8. \nListing 12.4\nPod using a non-default ServiceAccount: curl-custom-sa.yaml\nListing 12.5\nInspecting the token mounted into the pod\u2019s container(s)\nListing 12.6\nTalking to the API server with a custom ServiceAccount\nThis pod uses the \nfoo ServiceAccount \ninstead of the default.\n \n", "shape": "dot", "size": 10, "title": "352\nCHAPTER 12\nSecuring the Kubernetes API server\napiVersion: v1\nkind: Pod\nmetadata:\n  name: curl-custom-sa\nspec:\n  serviceAccountName: foo           \n  containers:\n  - name: main\n    image: tutum/curl\n    command: [\"sleep\", \"9999999\"]\n  - name: ambassador                  \n    image: luksa/kubectl-proxy:1.6.2\nTo confirm that the custom ServiceAccount\u2019s token is mounted into the two contain-\ners, you can print the contents of the token as shown in the following listing.\n$ kubectl exec -it curl-custom-sa -c main \n\u27a5 cat /var/run/secrets/kubernetes.io/serviceaccount/token\neyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9...\nYou can see the token is the one from the foo ServiceAccount by comparing the token\nstring in listing 12.5 with the one in listing 12.2. \nUSING THE CUSTOM SERVICEACCOUNT\u2019S TOKEN TO TALK TO THE API SERVER\nLet\u2019s see if you can talk to the API server using this token. As mentioned previously,\nthe ambassador container uses the token when talking to the server, so you can test\nthe token by going through the ambassador, which listens on localhost:8001, as\nshown in the following listing.\n$ kubectl exec -it curl-custom-sa -c main curl localhost:8001/api/v1/pods\n{\n  \"kind\": \"PodList\",\n  \"apiVersion\": \"v1\",\n  \"metadata\": {\n    \"selfLink\": \"/api/v1/pods\",\n    \"resourceVersion\": \"433895\"\n  },\n  \"items\": [\n  ...\nOkay, you got back a proper response from the server, which means the custom\nServiceAccount is allowed to list pods. This may be because your cluster doesn\u2019t use\nthe RBAC authorization plugin, or you gave all ServiceAccounts full permissions, as\ninstructed in chapter 8. \nListing 12.4\nPod using a non-default ServiceAccount: curl-custom-sa.yaml\nListing 12.5\nInspecting the token mounted into the pod\u2019s container(s)\nListing 12.6\nTalking to the API server with a custom ServiceAccount\nThis pod uses the \nfoo ServiceAccount \ninstead of the default.\n \n"}, {"color": "green", "id": "text_296", "label": "353\nSecuring the cluster with role-based access control\n When your cluster isn\u2019t using proper authorization, creating and using additional\nServiceAccounts doesn\u2019t make much sense, since even the default ServiceAccount is\nallowed to do anything. The only reason to use ServiceAccounts in that case is to\nenforce mountable Secrets or to provide image pull Secrets through the Service-\nAccount, as explained earlier. \n But creating additional ServiceAccounts is practically a must when you use the\nRBAC authorization plugin, which we\u2019ll explore next.\n12.2\nSecuring the cluster with role-based access control\nStarting with Kubernetes version 1.6.0, cluster security was ramped up considerably. In\nearlier versions, if you managed to acquire the authentication token from one of the\npods, you could use it to do anything you want in the cluster. If you google around,\nyou\u2019ll find demos showing how a path traversal (or directory traversal) attack (where clients\ncan retrieve files located outside of the web server\u2019s web root directory) can be used to\nget the token and use it to run your malicious pods in an insecure Kubernetes cluster.\n But in version 1.8.0, the RBAC authorization plugin graduated to GA (General\nAvailability) and is now enabled by default on many clusters (for example, when\ndeploying a cluster with kubadm, as described in appendix B). RBAC prevents unau-\nthorized users from viewing or modifying the cluster state. The default Service-\nAccount isn\u2019t allowed to view cluster state, let alone modify it in any way, unless you\ngrant it additional privileges. To write apps that communicate with the Kubernetes\nAPI server (as described in chapter 8), you need to understand how to manage\nauthorization through RBAC-specific resources.\nNOTE\nIn addition to RBAC, Kubernetes also includes other authorization\nplugins, such as the Attribute-based access control (ABAC) plugin, a Web-\nHook plugin and custom plugin implementations. RBAC is the standard,\nthough.\n12.2.1 Introducing the RBAC authorization plugin\nThe Kubernetes API server can be configured to use an authorization plugin to check\nwhether an action is allowed to be performed by the user requesting the action. Because\nthe API server exposes a REST interface, users perform actions by sending HTTP\nrequests to the server. Users authenticate themselves by including credentials in the\nrequest (an authentication token, username and password, or a client certificate).\nUNDERSTANDING ACTIONS\nBut what actions are there? As you know, REST clients send GET, POST, PUT, DELETE,\nand other types of HTTP requests to specific URL paths, which represent specific\nREST resources. In Kubernetes, those resources are Pods, Services, Secrets, and so on.\nHere are a few examples of actions in Kubernetes:\n\uf0a1Get Pods\n\uf0a1Create Services\n \n", "shape": "dot", "size": 10, "title": "353\nSecuring the cluster with role-based access control\n When your cluster isn\u2019t using proper authorization, creating and using additional\nServiceAccounts doesn\u2019t make much sense, since even the default ServiceAccount is\nallowed to do anything. The only reason to use ServiceAccounts in that case is to\nenforce mountable Secrets or to provide image pull Secrets through the Service-\nAccount, as explained earlier. \n But creating additional ServiceAccounts is practically a must when you use the\nRBAC authorization plugin, which we\u2019ll explore next.\n12.2\nSecuring the cluster with role-based access control\nStarting with Kubernetes version 1.6.0, cluster security was ramped up considerably. In\nearlier versions, if you managed to acquire the authentication token from one of the\npods, you could use it to do anything you want in the cluster. If you google around,\nyou\u2019ll find demos showing how a path traversal (or directory traversal) attack (where clients\ncan retrieve files located outside of the web server\u2019s web root directory) can be used to\nget the token and use it to run your malicious pods in an insecure Kubernetes cluster.\n But in version 1.8.0, the RBAC authorization plugin graduated to GA (General\nAvailability) and is now enabled by default on many clusters (for example, when\ndeploying a cluster with kubadm, as described in appendix B). RBAC prevents unau-\nthorized users from viewing or modifying the cluster state. The default Service-\nAccount isn\u2019t allowed to view cluster state, let alone modify it in any way, unless you\ngrant it additional privileges. To write apps that communicate with the Kubernetes\nAPI server (as described in chapter 8), you need to understand how to manage\nauthorization through RBAC-specific resources.\nNOTE\nIn addition to RBAC, Kubernetes also includes other authorization\nplugins, such as the Attribute-based access control (ABAC) plugin, a Web-\nHook plugin and custom plugin implementations. RBAC is the standard,\nthough.\n12.2.1 Introducing the RBAC authorization plugin\nThe Kubernetes API server can be configured to use an authorization plugin to check\nwhether an action is allowed to be performed by the user requesting the action. Because\nthe API server exposes a REST interface, users perform actions by sending HTTP\nrequests to the server. Users authenticate themselves by including credentials in the\nrequest (an authentication token, username and password, or a client certificate).\nUNDERSTANDING ACTIONS\nBut what actions are there? As you know, REST clients send GET, POST, PUT, DELETE,\nand other types of HTTP requests to specific URL paths, which represent specific\nREST resources. In Kubernetes, those resources are Pods, Services, Secrets, and so on.\nHere are a few examples of actions in Kubernetes:\n\uf0a1Get Pods\n\uf0a1Create Services\n \n"}, {"color": "green", "id": "text_297", "label": "354\nCHAPTER 12\nSecuring the Kubernetes API server\n\uf0a1Update Secrets\n\uf0a1And so on\nThe verbs in those examples (get, create, update) map to HTTP methods (GET, POST,\nPUT) performed by the client (the complete mapping is shown in table 12.1). The\nnouns (Pods, Service, Secrets) obviously map to Kubernetes resources. \n An authorization plugin such as RBAC, which runs inside the API server, deter-\nmines whether a client is allowed to perform the requested verb on the requested\nresource or not.\nNOTE\nThe additional verb use is used for PodSecurityPolicy resources, which\nare explained in the next chapter.\nBesides applying security permissions to whole resource types, RBAC rules can also\napply to specific instances of a resource (for example, a Service called myservice).\nAnd later you\u2019ll see that permissions can also apply to non-resource URL paths,\nbecause not every path the API server exposes maps to a resource (such as the /api\npath itself or the server health information at /healthz). \nUNDERSTANDING THE RBAC PLUGIN\nThe RBAC authorization plugin, as the name suggests, uses user roles as the key factor\nin determining whether the user may perform the action or not. A subject (which may\nbe a human, a ServiceAccount, or a group of users or ServiceAccounts) is associated\nwith one or more roles and each role is allowed to perform certain verbs on certain\nresources. \n If a user has multiple roles, they may do anything that any of their roles allows\nthem to do. If none of the user\u2019s roles contains a permission to, for example, update\nSecrets, the API server will prevent the user from performing PUT or PATCH requests\non Secrets.\n Managing authorization through the RBAC plugin is simple. It\u2019s all done by creat-\ning four RBAC-specific Kubernetes resources, which we\u2019ll look at next.\nTable 12.1\nMapping HTTP methods to authorization verbs\nHTTP method\nVerb for single resource\nVerb for collection\nGET, HEAD\nget (and watch for watching)\nlist (and watch)\nPOST\ncreate\nn/a\nPUT\nupdate\nn/a\nPATCH\npatch\nn/a\nDELETE\ndelete\ndeletecollection\n \n", "shape": "dot", "size": 10, "title": "354\nCHAPTER 12\nSecuring the Kubernetes API server\n\uf0a1Update Secrets\n\uf0a1And so on\nThe verbs in those examples (get, create, update) map to HTTP methods (GET, POST,\nPUT) performed by the client (the complete mapping is shown in table 12.1). The\nnouns (Pods, Service, Secrets) obviously map to Kubernetes resources. \n An authorization plugin such as RBAC, which runs inside the API server, deter-\nmines whether a client is allowed to perform the requested verb on the requested\nresource or not.\nNOTE\nThe additional verb use is used for PodSecurityPolicy resources, which\nare explained in the next chapter.\nBesides applying security permissions to whole resource types, RBAC rules can also\napply to specific instances of a resource (for example, a Service called myservice).\nAnd later you\u2019ll see that permissions can also apply to non-resource URL paths,\nbecause not every path the API server exposes maps to a resource (such as the /api\npath itself or the server health information at /healthz). \nUNDERSTANDING THE RBAC PLUGIN\nThe RBAC authorization plugin, as the name suggests, uses user roles as the key factor\nin determining whether the user may perform the action or not. A subject (which may\nbe a human, a ServiceAccount, or a group of users or ServiceAccounts) is associated\nwith one or more roles and each role is allowed to perform certain verbs on certain\nresources. \n If a user has multiple roles, they may do anything that any of their roles allows\nthem to do. If none of the user\u2019s roles contains a permission to, for example, update\nSecrets, the API server will prevent the user from performing PUT or PATCH requests\non Secrets.\n Managing authorization through the RBAC plugin is simple. It\u2019s all done by creat-\ning four RBAC-specific Kubernetes resources, which we\u2019ll look at next.\nTable 12.1\nMapping HTTP methods to authorization verbs\nHTTP method\nVerb for single resource\nVerb for collection\nGET, HEAD\nget (and watch for watching)\nlist (and watch)\nPOST\ncreate\nn/a\nPUT\nupdate\nn/a\nPATCH\npatch\nn/a\nDELETE\ndelete\ndeletecollection\n \n"}, {"color": "green", "id": "text_298", "label": "355\nSecuring the cluster with role-based access control\n12.2.2 Introducing RBAC resources\nThe RBAC authorization rules are configured through four resources, which can be\ngrouped into two groups:\n\uf0a1Roles and ClusterRoles, which specify which verbs can be performed on which\nresources.\n\uf0a1RoleBindings and ClusterRoleBindings, which bind the above roles to specific\nusers, groups, or ServiceAccounts.\nRoles define what can be done, while bindings define who can do it (this is shown in\nfigure 12.2).\nThe distinction between a Role and a ClusterRole, or between a RoleBinding and a\nClusterRoleBinding, is that the Role and RoleBinding are namespaced resources,\nwhereas the ClusterRole and ClusterRoleBinding are cluster-level resources (not\nnamespaced). This is depicted in figure 12.3.\n As you can see from the figure, multiple RoleBindings can exist in a single name-\nspace (this is also true for Roles). Likewise, multiple ClusterRoleBindings and Cluster-\nRoles can be created. Another thing shown in the figure is that although RoleBindings\nare namespaced, they can also reference ClusterRoles, which aren\u2019t. \n The best way to learn about these four resources and what their effects are is by try-\ning them out in a hands-on exercise. You\u2019ll do that now.\n \n \n \n \nWhat?\nRole\nBinding\nSome\nresources\nOther\nresources\nRole\nDoesn\u2019t allow\ndoing anything\nwith other resources\nUser A\nWho?\nAdmins group\nAllows users\nto access\nService-\nAccount:\nx\nFigure 12.2\nRoles grant permissions, whereas RoleBindings bind Roles to subjects.\n \n", "shape": "dot", "size": 10, "title": "355\nSecuring the cluster with role-based access control\n12.2.2 Introducing RBAC resources\nThe RBAC authorization rules are configured through four resources, which can be\ngrouped into two groups:\n\uf0a1Roles and ClusterRoles, which specify which verbs can be performed on which\nresources.\n\uf0a1RoleBindings and ClusterRoleBindings, which bind the above roles to specific\nusers, groups, or ServiceAccounts.\nRoles define what can be done, while bindings define who can do it (this is shown in\nfigure 12.2).\nThe distinction between a Role and a ClusterRole, or between a RoleBinding and a\nClusterRoleBinding, is that the Role and RoleBinding are namespaced resources,\nwhereas the ClusterRole and ClusterRoleBinding are cluster-level resources (not\nnamespaced). This is depicted in figure 12.3.\n As you can see from the figure, multiple RoleBindings can exist in a single name-\nspace (this is also true for Roles). Likewise, multiple ClusterRoleBindings and Cluster-\nRoles can be created. Another thing shown in the figure is that although RoleBindings\nare namespaced, they can also reference ClusterRoles, which aren\u2019t. \n The best way to learn about these four resources and what their effects are is by try-\ning them out in a hands-on exercise. You\u2019ll do that now.\n \n \n \n \nWhat?\nRole\nBinding\nSome\nresources\nOther\nresources\nRole\nDoesn\u2019t allow\ndoing anything\nwith other resources\nUser A\nWho?\nAdmins group\nAllows users\nto access\nService-\nAccount:\nx\nFigure 12.2\nRoles grant permissions, whereas RoleBindings bind Roles to subjects.\n \n"}, {"color": "green", "id": "text_299", "label": "356\nCHAPTER 12\nSecuring the Kubernetes API server\nSETTING UP YOUR EXERCISE\nBefore you can explore how RBAC resources affect what you can do through the API\nserver, you need to make sure RBAC is enabled in your cluster. First, ensure you\u2019re\nusing at least version 1.6 of Kubernetes and that the RBAC plugin is the only config-\nured authorization plugin. There can be multiple plugins enabled in parallel and if\none of them allows an action to be performed, the action is allowed.\nNOTE\nIf you\u2019re using GKE 1.6 or 1.7, you need to explicitly disable legacy autho-\nrization by creating the cluster with the --no-enable-legacy-authorization\noption. If you\u2019re using Minikube, you also may need to enable RBAC by start-\ning Minikube with --extra-config=apiserver.Authorization.Mode=RBAC\nIf you followed the instructions on how to disable RBAC in chapter 8, now\u2019s the time\nto re-enable it by running the following command:\n$ kubectl delete clusterrolebinding permissive-binding\nTo try out RBAC, you\u2019ll run a pod through which you\u2019ll try to talk to the API server,\nthe way you did in chapter 8. But this time you\u2019ll run two pods in different namespaces\nto see how per-namespace security behaves.\n In the examples in chapter 8, you ran two containers to demonstrate how an appli-\ncation in one container uses the other container to talk to the API server. This time,\nyou\u2019ll run a single container (based on the kubectl-proxy image) and use kubectl\nexec to run curl inside that container directly. The proxy will take care of authentica-\ntion and HTTPS, so you can focus on the authorization aspect of API server security.\nNamespace C\nNamespaced\nresources\nCluster-level\nresources\nRoleBinding\nRoleBinding\nRole\nNamespace B\nNamespaced\nresources\nRoleBinding\nRole\nNamespace A\nNamespaced\nresources\nRoleBinding\nRole\nCluster scope (resources that aren\u2019t namespaced)\nClusterRoleBinding\nClusterRole\nFigure 12.3\nRoles and RoleBindings are namespaced; ClusterRoles and ClusterRoleBindings aren\u2019t.\n \n", "shape": "dot", "size": 10, "title": "356\nCHAPTER 12\nSecuring the Kubernetes API server\nSETTING UP YOUR EXERCISE\nBefore you can explore how RBAC resources affect what you can do through the API\nserver, you need to make sure RBAC is enabled in your cluster. First, ensure you\u2019re\nusing at least version 1.6 of Kubernetes and that the RBAC plugin is the only config-\nured authorization plugin. There can be multiple plugins enabled in parallel and if\none of them allows an action to be performed, the action is allowed.\nNOTE\nIf you\u2019re using GKE 1.6 or 1.7, you need to explicitly disable legacy autho-\nrization by creating the cluster with the --no-enable-legacy-authorization\noption. If you\u2019re using Minikube, you also may need to enable RBAC by start-\ning Minikube with --extra-config=apiserver.Authorization.Mode=RBAC\nIf you followed the instructions on how to disable RBAC in chapter 8, now\u2019s the time\nto re-enable it by running the following command:\n$ kubectl delete clusterrolebinding permissive-binding\nTo try out RBAC, you\u2019ll run a pod through which you\u2019ll try to talk to the API server,\nthe way you did in chapter 8. But this time you\u2019ll run two pods in different namespaces\nto see how per-namespace security behaves.\n In the examples in chapter 8, you ran two containers to demonstrate how an appli-\ncation in one container uses the other container to talk to the API server. This time,\nyou\u2019ll run a single container (based on the kubectl-proxy image) and use kubectl\nexec to run curl inside that container directly. The proxy will take care of authentica-\ntion and HTTPS, so you can focus on the authorization aspect of API server security.\nNamespace C\nNamespaced\nresources\nCluster-level\nresources\nRoleBinding\nRoleBinding\nRole\nNamespace B\nNamespaced\nresources\nRoleBinding\nRole\nNamespace A\nNamespaced\nresources\nRoleBinding\nRole\nCluster scope (resources that aren\u2019t namespaced)\nClusterRoleBinding\nClusterRole\nFigure 12.3\nRoles and RoleBindings are namespaced; ClusterRoles and ClusterRoleBindings aren\u2019t.\n \n"}, {"color": "green", "id": "text_300", "label": "357\nSecuring the cluster with role-based access control\nCREATING THE NAMESPACES AND RUNNING THE PODS\nYou\u2019re going to create one pod in namespace foo and the other one in namespace\nbar, as shown in the following listing.\n$ kubectl create ns foo\nnamespace \"foo\" created\n$ kubectl run test --image=luksa/kubectl-proxy -n foo\ndeployment \"test\" created\n$ kubectl create ns bar\nnamespace \"bar\" created\n$ kubectl run test --image=luksa/kubectl-proxy -n bar\ndeployment \"test\" created\nNow open two terminals and use kubectl exec to run a shell inside each of the two\npods (one in each terminal). For example, to run the shell in the pod in namespace\nfoo, first get the name of the pod:\n$ kubectl get po -n foo\nNAME                   READY     STATUS    RESTARTS   AGE\ntest-145485760-ttq36   1/1       Running   0          1m\nThen use the name in the kubectl exec command:\n$ kubectl exec -it test-145485760-ttq36 -n foo sh\n/ #\nDo the same in the other terminal, but for the pod in the bar namespace.\nLISTING SERVICES FROM YOUR PODS\nTo verify that RBAC is enabled and preventing the pod from reading cluster state, use\ncurl to list Services in the foo namespace:\n/ # curl localhost:8001/api/v1/namespaces/foo/services\nUser \"system:serviceaccount:foo:default\" cannot list services in the \nnamespace \"foo\".\nYou\u2019re connecting to localhost:8001, which is where the kubectl proxy process is\nlistening (as explained in chapter 8). The process received your request and sent it to\nthe API server while authenticating as the default ServiceAccount in the foo name-\nspace (as evident from the API server\u2019s response). \n The API server responded that the ServiceAccount isn\u2019t allowed to list Services in\nthe foo namespace, even though the pod is running in that same namespace. You\u2019re\nseeing RBAC in action. The default permissions for a ServiceAccount don\u2019t allow it to\nlist or modify any resources. Now, let\u2019s learn how to allow the ServiceAccount to do\nthat. First, you\u2019ll need to create a Role resource.\nListing 12.7\nRunning test pods in different namespaces\n \n", "shape": "dot", "size": 10, "title": "357\nSecuring the cluster with role-based access control\nCREATING THE NAMESPACES AND RUNNING THE PODS\nYou\u2019re going to create one pod in namespace foo and the other one in namespace\nbar, as shown in the following listing.\n$ kubectl create ns foo\nnamespace \"foo\" created\n$ kubectl run test --image=luksa/kubectl-proxy -n foo\ndeployment \"test\" created\n$ kubectl create ns bar\nnamespace \"bar\" created\n$ kubectl run test --image=luksa/kubectl-proxy -n bar\ndeployment \"test\" created\nNow open two terminals and use kubectl exec to run a shell inside each of the two\npods (one in each terminal). For example, to run the shell in the pod in namespace\nfoo, first get the name of the pod:\n$ kubectl get po -n foo\nNAME                   READY     STATUS    RESTARTS   AGE\ntest-145485760-ttq36   1/1       Running   0          1m\nThen use the name in the kubectl exec command:\n$ kubectl exec -it test-145485760-ttq36 -n foo sh\n/ #\nDo the same in the other terminal, but for the pod in the bar namespace.\nLISTING SERVICES FROM YOUR PODS\nTo verify that RBAC is enabled and preventing the pod from reading cluster state, use\ncurl to list Services in the foo namespace:\n/ # curl localhost:8001/api/v1/namespaces/foo/services\nUser \"system:serviceaccount:foo:default\" cannot list services in the \nnamespace \"foo\".\nYou\u2019re connecting to localhost:8001, which is where the kubectl proxy process is\nlistening (as explained in chapter 8). The process received your request and sent it to\nthe API server while authenticating as the default ServiceAccount in the foo name-\nspace (as evident from the API server\u2019s response). \n The API server responded that the ServiceAccount isn\u2019t allowed to list Services in\nthe foo namespace, even though the pod is running in that same namespace. You\u2019re\nseeing RBAC in action. The default permissions for a ServiceAccount don\u2019t allow it to\nlist or modify any resources. Now, let\u2019s learn how to allow the ServiceAccount to do\nthat. First, you\u2019ll need to create a Role resource.\nListing 12.7\nRunning test pods in different namespaces\n \n"}, {"color": "green", "id": "text_301", "label": "358\nCHAPTER 12\nSecuring the Kubernetes API server\n12.2.3 Using Roles and RoleBindings\nA Role resource defines what actions can be taken on which resources (or, as\nexplained earlier, which types of HTTP requests can be performed on which RESTful\nresources). The following listing defines a Role, which allows users to get and list\nServices in the foo namespace.\napiVersion: rbac.authorization.k8s.io/v1\nkind: Role\nmetadata:\n  namespace: foo            \n  name: service-reader\nrules:\n- apiGroups: [\"\"]            \n  verbs: [\"get\", \"list\"]     \n  resources: [\"services\"]   \nWARNING\nThe plural form must be used when specifying resources.\nThis Role resource will be created in the foo namespace. In chapter 8, you learned that\neach resource type belongs to an API group, which you specify in the apiVersion field\n(along with the version) in the resource\u2019s manifest. In a Role definition, you need to spec-\nify the apiGroup for the resources listed in each rule included in the definition. If you\u2019re\nallowing access to resources belonging to different API groups, you use multiple rules.\nNOTE\nIn the example, you\u2019re allowing access to all Service resources, but you\ncould also limit access only to specific Service instances by specifying their\nnames through an additional resourceNames field.\nFigure 12.4 shows the Role, its verbs and resources, and the namespace it will be cre-\nated in.\nListing 12.8\nA definition of a Role: service-reader.yaml\nRoles are namespaced (if namespace is \nomitted, the current namespace is used).\nServices are resources in the core apiGroup, \nwhich has no name \u2013 hence the \"\".\nGetting individual Services (by name) \nand listing all of them is allowed.\nThis rule pertains to services \n(plural name must be used!).\nAllows getting\nAllows listing\nServices\nRole:\nservice-reader\nServices\nNamespace: foo\nNamespace: bar\nDoes not allow users to\nget or list Services in\nother namespaces\nFigure 12.4\nThe service-reader Role allows getting and listing Services in the foo namespace.\n \n", "shape": "dot", "size": 10, "title": "358\nCHAPTER 12\nSecuring the Kubernetes API server\n12.2.3 Using Roles and RoleBindings\nA Role resource defines what actions can be taken on which resources (or, as\nexplained earlier, which types of HTTP requests can be performed on which RESTful\nresources). The following listing defines a Role, which allows users to get and list\nServices in the foo namespace.\napiVersion: rbac.authorization.k8s.io/v1\nkind: Role\nmetadata:\n  namespace: foo            \n  name: service-reader\nrules:\n- apiGroups: [\"\"]            \n  verbs: [\"get\", \"list\"]     \n  resources: [\"services\"]   \nWARNING\nThe plural form must be used when specifying resources.\nThis Role resource will be created in the foo namespace. In chapter 8, you learned that\neach resource type belongs to an API group, which you specify in the apiVersion field\n(along with the version) in the resource\u2019s manifest. In a Role definition, you need to spec-\nify the apiGroup for the resources listed in each rule included in the definition. If you\u2019re\nallowing access to resources belonging to different API groups, you use multiple rules.\nNOTE\nIn the example, you\u2019re allowing access to all Service resources, but you\ncould also limit access only to specific Service instances by specifying their\nnames through an additional resourceNames field.\nFigure 12.4 shows the Role, its verbs and resources, and the namespace it will be cre-\nated in.\nListing 12.8\nA definition of a Role: service-reader.yaml\nRoles are namespaced (if namespace is \nomitted, the current namespace is used).\nServices are resources in the core apiGroup, \nwhich has no name \u2013 hence the \"\".\nGetting individual Services (by name) \nand listing all of them is allowed.\nThis rule pertains to services \n(plural name must be used!).\nAllows getting\nAllows listing\nServices\nRole:\nservice-reader\nServices\nNamespace: foo\nNamespace: bar\nDoes not allow users to\nget or list Services in\nother namespaces\nFigure 12.4\nThe service-reader Role allows getting and listing Services in the foo namespace.\n \n"}, {"color": "green", "id": "text_302", "label": "359\nSecuring the cluster with role-based access control\nCREATING A ROLE\nCreate the previous Role in the foo namespace now:\n$ kubectl create -f service-reader.yaml -n foo\nrole \"service-reader\" created\nNOTE\nThe -n option is shorthand for --namespace.\nNote that if you\u2019re using GKE, the previous command may fail because you don\u2019t have\ncluster-admin rights. To grant the rights, run the following command:\n$ kubectl create clusterrolebinding cluster-admin-binding \n\u27a5 --clusterrole=cluster-admin --user=your.email@address.com\nInstead of creating the service-reader Role from a YAML file, you could also create\nit with the special kubectl create role command. Let\u2019s use this method to create the\nRole in the bar namespace:\n$ kubectl create role service-reader --verb=get --verb=list \n\u27a5 --resource=services -n bar\nrole \"service-reader\" created\nThese two Roles will allow you to list Services in the foo and bar namespaces from\nwithin your two pods (running in the foo and bar namespace, respectively). But cre-\nating the two Roles isn\u2019t enough (you can check by executing the curl command\nagain). You need to bind each of the Roles to the ServiceAccounts in their respec-\ntive namespaces. \nBINDING A ROLE TO A SERVICEACCOUNT\nA Role defines what actions can be performed, but it doesn\u2019t specify who can perform\nthem. To do that, you must bind the Role to a subject, which can be a user, a Service-\nAccount, or a group (of users or ServiceAccounts).\n Binding Roles to subjects is achieved by creating a RoleBinding resource. To bind\nthe Role to the default ServiceAccount, run the following command:\n$ kubectl create rolebinding test --role=service-reader \n\u27a5 --serviceaccount=foo:default -n foo\nrolebinding \"test\" created\nThe command should be self-explanatory. You\u2019re creating a RoleBinding, which binds\nthe service-reader Role to the default ServiceAccount in namespace foo. You\u2019re cre-\nating the RoleBinding in namespace foo. The RoleBinding and the referenced Service-\nAccount and Role are shown in figure 12.5.\nNOTE\nTo bind a Role to a user instead of a ServiceAccount, use the --user\nargument to specify the username. To bind it to a group, use --group.\n \n", "shape": "dot", "size": 10, "title": "359\nSecuring the cluster with role-based access control\nCREATING A ROLE\nCreate the previous Role in the foo namespace now:\n$ kubectl create -f service-reader.yaml -n foo\nrole \"service-reader\" created\nNOTE\nThe -n option is shorthand for --namespace.\nNote that if you\u2019re using GKE, the previous command may fail because you don\u2019t have\ncluster-admin rights. To grant the rights, run the following command:\n$ kubectl create clusterrolebinding cluster-admin-binding \n\u27a5 --clusterrole=cluster-admin --user=your.email@address.com\nInstead of creating the service-reader Role from a YAML file, you could also create\nit with the special kubectl create role command. Let\u2019s use this method to create the\nRole in the bar namespace:\n$ kubectl create role service-reader --verb=get --verb=list \n\u27a5 --resource=services -n bar\nrole \"service-reader\" created\nThese two Roles will allow you to list Services in the foo and bar namespaces from\nwithin your two pods (running in the foo and bar namespace, respectively). But cre-\nating the two Roles isn\u2019t enough (you can check by executing the curl command\nagain). You need to bind each of the Roles to the ServiceAccounts in their respec-\ntive namespaces. \nBINDING A ROLE TO A SERVICEACCOUNT\nA Role defines what actions can be performed, but it doesn\u2019t specify who can perform\nthem. To do that, you must bind the Role to a subject, which can be a user, a Service-\nAccount, or a group (of users or ServiceAccounts).\n Binding Roles to subjects is achieved by creating a RoleBinding resource. To bind\nthe Role to the default ServiceAccount, run the following command:\n$ kubectl create rolebinding test --role=service-reader \n\u27a5 --serviceaccount=foo:default -n foo\nrolebinding \"test\" created\nThe command should be self-explanatory. You\u2019re creating a RoleBinding, which binds\nthe service-reader Role to the default ServiceAccount in namespace foo. You\u2019re cre-\nating the RoleBinding in namespace foo. The RoleBinding and the referenced Service-\nAccount and Role are shown in figure 12.5.\nNOTE\nTo bind a Role to a user instead of a ServiceAccount, use the --user\nargument to specify the username. To bind it to a group, use --group.\n \n"}, {"color": "green", "id": "text_303", "label": "360\nCHAPTER 12\nSecuring the Kubernetes API server\nThe following listing shows the YAML of the RoleBinding you created.\n$ kubectl get rolebinding test -n foo -o yaml\napiVersion: rbac.authorization.k8s.io/v1\nkind: RoleBinding\nmetadata:\n  name: test\n  namespace: foo\n  ...\nroleRef:\n  apiGroup: rbac.authorization.k8s.io\n  kind: Role                         \n  name: service-reader               \nsubjects:\n- kind: ServiceAccount       \n  name: default              \n  namespace: foo             \nAs you can see, a RoleBinding always references a single Role (as evident from the\nroleRef property), but can bind the Role to multiple subjects (for example, one or\nmore ServiceAccounts and any number of users or groups). Because this RoleBinding\nbinds the Role to the ServiceAccount the pod in namespace foo is running under, you\ncan now list Services from within that pod.\n/ # curl localhost:8001/api/v1/namespaces/foo/services\n{\n  \"kind\": \"ServiceList\",\n  \"apiVersion\": \"v1\",\n  \"metadata\": {\n    \"selfLink\": \"/api/v1/namespaces/foo/services\",\nListing 12.9\nA RoleBinding referencing a Role\nListing 12.10\nGetting Services from the API server\nNamespace: foo\nRole:\nservice-reader\nGet, list\nDefault ServiceAccount\nis allowed to get and list\nservices in this namespace\nServices\nRoleBinding:\ntest\nService-\nAccount:\ndefault\nFigure 12.5\nThe test RoleBinding binds the default ServiceAccount with the \nservice-reader Role.\nThis RoleBinding references \nthe service-reader Role.\nAnd binds it to the \ndefault ServiceAccount \nin the foo namespace.\n \n", "shape": "dot", "size": 10, "title": "360\nCHAPTER 12\nSecuring the Kubernetes API server\nThe following listing shows the YAML of the RoleBinding you created.\n$ kubectl get rolebinding test -n foo -o yaml\napiVersion: rbac.authorization.k8s.io/v1\nkind: RoleBinding\nmetadata:\n  name: test\n  namespace: foo\n  ...\nroleRef:\n  apiGroup: rbac.authorization.k8s.io\n  kind: Role                         \n  name: service-reader               \nsubjects:\n- kind: ServiceAccount       \n  name: default              \n  namespace: foo             \nAs you can see, a RoleBinding always references a single Role (as evident from the\nroleRef property), but can bind the Role to multiple subjects (for example, one or\nmore ServiceAccounts and any number of users or groups). Because this RoleBinding\nbinds the Role to the ServiceAccount the pod in namespace foo is running under, you\ncan now list Services from within that pod.\n/ # curl localhost:8001/api/v1/namespaces/foo/services\n{\n  \"kind\": \"ServiceList\",\n  \"apiVersion\": \"v1\",\n  \"metadata\": {\n    \"selfLink\": \"/api/v1/namespaces/foo/services\",\nListing 12.9\nA RoleBinding referencing a Role\nListing 12.10\nGetting Services from the API server\nNamespace: foo\nRole:\nservice-reader\nGet, list\nDefault ServiceAccount\nis allowed to get and list\nservices in this namespace\nServices\nRoleBinding:\ntest\nService-\nAccount:\ndefault\nFigure 12.5\nThe test RoleBinding binds the default ServiceAccount with the \nservice-reader Role.\nThis RoleBinding references \nthe service-reader Role.\nAnd binds it to the \ndefault ServiceAccount \nin the foo namespace.\n \n"}, {"color": "green", "id": "text_304", "label": "361\nSecuring the cluster with role-based access control\n    \"resourceVersion\": \"24906\"\n  },\n  \"items\": []     \n}\nINCLUDING SERVICEACCOUNTS FROM OTHER NAMESPACES IN A ROLEBINDING\nThe pod in namespace bar can\u2019t list the Services in its own namespace, and obviously\nalso not those in the foo namespace. But you can edit your RoleBinding in the foo\nnamespace and add the other pod\u2019s ServiceAccount, even though it\u2019s in a different\nnamespace. Run the following command:\n$ kubectl edit rolebinding test -n foo\nThen add the following lines to the list of subjects, as shown in the following listing.\nsubjects:\n- kind: ServiceAccount\n  name: default          \n  namespace: bar         \nNow you can also list Services in the foo namespace from inside the pod running in\nthe bar namespace. Run the same command as in listing 12.10, but do it in the other\nterminal, where you\u2019re running the shell in the other pod.\n Before moving on to ClusterRoles and ClusterRoleBindings, let\u2019s summarize\nwhat RBAC resources you currently have. You have a RoleBinding in namespace\nfoo, which references the service-reader Role (also in the foo namespace) and\nbinds the default ServiceAccounts in both the foo and the bar namespaces, as\ndepicted in figure 12.6.\nListing 12.11\nReferencing a ServiceAccount from another namespace\nThe list of items is empty, \nbecause no Services exist.\nYou\u2019re referencing the default \nServiceAccount in the bar namespace.\nNamespace: foo\nRole:\nservice-reader\nGet, list\nBoth ServiceAccounts are\nallowed to get and list Services\nin the foo namespace\nServices\nNamespace: bar\nRoleBinding:\ntest\nService-\nAccount:\ndefault\nService-\nAccount:\ndefault\nFigure 12.6\nA RoleBinding binding ServiceAccounts from different namespaces to the same Role.\n \n", "shape": "dot", "size": 10, "title": "361\nSecuring the cluster with role-based access control\n    \"resourceVersion\": \"24906\"\n  },\n  \"items\": []     \n}\nINCLUDING SERVICEACCOUNTS FROM OTHER NAMESPACES IN A ROLEBINDING\nThe pod in namespace bar can\u2019t list the Services in its own namespace, and obviously\nalso not those in the foo namespace. But you can edit your RoleBinding in the foo\nnamespace and add the other pod\u2019s ServiceAccount, even though it\u2019s in a different\nnamespace. Run the following command:\n$ kubectl edit rolebinding test -n foo\nThen add the following lines to the list of subjects, as shown in the following listing.\nsubjects:\n- kind: ServiceAccount\n  name: default          \n  namespace: bar         \nNow you can also list Services in the foo namespace from inside the pod running in\nthe bar namespace. Run the same command as in listing 12.10, but do it in the other\nterminal, where you\u2019re running the shell in the other pod.\n Before moving on to ClusterRoles and ClusterRoleBindings, let\u2019s summarize\nwhat RBAC resources you currently have. You have a RoleBinding in namespace\nfoo, which references the service-reader Role (also in the foo namespace) and\nbinds the default ServiceAccounts in both the foo and the bar namespaces, as\ndepicted in figure 12.6.\nListing 12.11\nReferencing a ServiceAccount from another namespace\nThe list of items is empty, \nbecause no Services exist.\nYou\u2019re referencing the default \nServiceAccount in the bar namespace.\nNamespace: foo\nRole:\nservice-reader\nGet, list\nBoth ServiceAccounts are\nallowed to get and list Services\nin the foo namespace\nServices\nNamespace: bar\nRoleBinding:\ntest\nService-\nAccount:\ndefault\nService-\nAccount:\ndefault\nFigure 12.6\nA RoleBinding binding ServiceAccounts from different namespaces to the same Role.\n \n"}, {"color": "green", "id": "text_305", "label": "362\nCHAPTER 12\nSecuring the Kubernetes API server\n12.2.4 Using ClusterRoles and ClusterRoleBindings\nRoles and RoleBindings are namespaced resources, meaning they reside in and apply\nto resources in a single namespace, but, as we saw, RoleBindings can refer to Service-\nAccounts from other namespaces, too. \n In addition to these namespaced resources, two cluster-level RBAC resources also\nexist: ClusterRole and ClusterRoleBinding. They\u2019re not namespaced. Let\u2019s see why\nyou need them.\n A regular Role only allows access to resources in the same namespace the Role is\nin. If you want to allow someone access to resources across different namespaces, you\nhave to create a Role and RoleBinding in every one of those namespaces. If you want\nto extend this to all namespaces (this is something a cluster administrator would prob-\nably need), you need to create the same Role and RoleBinding in each namespace.\nWhen creating an additional namespace, you have to remember to create the two\nresources there as well. \n As you\u2019ve learned throughout the book, certain resources aren\u2019t namespaced at\nall (this includes Nodes, PersistentVolumes, Namespaces, and so on). We\u2019ve also\nmentioned the API server exposes some URL paths that don\u2019t represent resources\n(/healthz for example). Regular Roles can\u2019t grant access to those resources or non-\nresource URLs, but ClusterRoles can.\n A ClusterRole is a cluster-level resource for allowing access to non-namespaced\nresources or non-resource URLs or used as a common role to be bound inside individ-\nual namespaces, saving you from having to redefine the same role in each of them.\nALLOWING ACCESS TO CLUSTER-LEVEL RESOURCES\nAs mentioned, a ClusterRole can be used to allow access to cluster-level resources.\nLet\u2019s look at how to allow your pod to list PersistentVolumes in your cluster. First,\nyou\u2019ll create a ClusterRole called pv-reader:\n$ kubectl create clusterrole pv-reader --verb=get,list \n\u27a5 --resource=persistentvolumes\nclusterrole \"pv-reader\" created\nThe ClusterRole\u2019s YAML is shown in the following listing.\n$ kubectl get clusterrole pv-reader -o yaml\napiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRole\nmetadata:                                       \n  name: pv-reader                               \n  resourceVersion: \"39932\"                      \n  selfLink: ...                                 \n  uid: e9ac1099-30e2-11e7-955c-080027e6b159     \nListing 12.12\nA ClusterRole definition\nClusterRoles aren\u2019t \nnamespaced, hence \nno namespace field.\n \n", "shape": "dot", "size": 10, "title": "362\nCHAPTER 12\nSecuring the Kubernetes API server\n12.2.4 Using ClusterRoles and ClusterRoleBindings\nRoles and RoleBindings are namespaced resources, meaning they reside in and apply\nto resources in a single namespace, but, as we saw, RoleBindings can refer to Service-\nAccounts from other namespaces, too. \n In addition to these namespaced resources, two cluster-level RBAC resources also\nexist: ClusterRole and ClusterRoleBinding. They\u2019re not namespaced. Let\u2019s see why\nyou need them.\n A regular Role only allows access to resources in the same namespace the Role is\nin. If you want to allow someone access to resources across different namespaces, you\nhave to create a Role and RoleBinding in every one of those namespaces. If you want\nto extend this to all namespaces (this is something a cluster administrator would prob-\nably need), you need to create the same Role and RoleBinding in each namespace.\nWhen creating an additional namespace, you have to remember to create the two\nresources there as well. \n As you\u2019ve learned throughout the book, certain resources aren\u2019t namespaced at\nall (this includes Nodes, PersistentVolumes, Namespaces, and so on). We\u2019ve also\nmentioned the API server exposes some URL paths that don\u2019t represent resources\n(/healthz for example). Regular Roles can\u2019t grant access to those resources or non-\nresource URLs, but ClusterRoles can.\n A ClusterRole is a cluster-level resource for allowing access to non-namespaced\nresources or non-resource URLs or used as a common role to be bound inside individ-\nual namespaces, saving you from having to redefine the same role in each of them.\nALLOWING ACCESS TO CLUSTER-LEVEL RESOURCES\nAs mentioned, a ClusterRole can be used to allow access to cluster-level resources.\nLet\u2019s look at how to allow your pod to list PersistentVolumes in your cluster. First,\nyou\u2019ll create a ClusterRole called pv-reader:\n$ kubectl create clusterrole pv-reader --verb=get,list \n\u27a5 --resource=persistentvolumes\nclusterrole \"pv-reader\" created\nThe ClusterRole\u2019s YAML is shown in the following listing.\n$ kubectl get clusterrole pv-reader -o yaml\napiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRole\nmetadata:                                       \n  name: pv-reader                               \n  resourceVersion: \"39932\"                      \n  selfLink: ...                                 \n  uid: e9ac1099-30e2-11e7-955c-080027e6b159     \nListing 12.12\nA ClusterRole definition\nClusterRoles aren\u2019t \nnamespaced, hence \nno namespace field.\n \n"}, {"color": "green", "id": "text_306", "label": "363\nSecuring the cluster with role-based access control\nrules:\n- apiGroups:                      \n  - \"\"                            \n  resources:                      \n  - persistentvolumes             \n  verbs:                          \n  - get                           \n  - list                          \nBefore you bind this ClusterRole to your pod\u2019s ServiceAccount, verify whether the pod\ncan list PersistentVolumes. Run the following command in the first terminal, where\nyou\u2019re running the shell inside the pod in the foo namespace:\n/ # curl localhost:8001/api/v1/persistentvolumes\nUser \"system:serviceaccount:foo:default\" cannot list persistentvolumes at the \ncluster scope.\nNOTE\nThe URL contains no namespace, because PersistentVolumes aren\u2019t\nnamespaced. \nAs expected, the default ServiceAccount can\u2019t list PersistentVolumes. You need to\nbind the ClusterRole to your ServiceAccount to allow it to do that. ClusterRoles can\nbe bound to subjects with regular RoleBindings, so you\u2019ll create a RoleBinding now:\n$ kubectl create rolebinding pv-test --clusterrole=pv-reader \n\u27a5 --serviceaccount=foo:default -n foo\nrolebinding \"pv-test\" created\nCan you list PersistentVolumes now?\n/ # curl localhost:8001/api/v1/persistentvolumes\nUser \"system:serviceaccount:foo:default\" cannot list persistentvolumes at the \ncluster scope.\nHmm, that\u2019s strange. Let\u2019s examine the RoleBinding\u2019s YAML in the following listing.\nCan you tell what (if anything) is wrong with it?\n$ kubectl get rolebindings pv-test -o yaml\napiVersion: rbac.authorization.k8s.io/v1\nkind: RoleBinding\nmetadata:\n  name: pv-test\n  namespace: foo\n  ...\nroleRef:\n  apiGroup: rbac.authorization.k8s.io\n  kind: ClusterRole              \n  name: pv-reader                \nListing 12.13\nA RoleBinding referencing a ClusterRole\nIn this case, the \nrules are exactly \nlike those in a \nregular Role.\nThe binding references the \npv-reader ClusterRole.\n \n", "shape": "dot", "size": 10, "title": "363\nSecuring the cluster with role-based access control\nrules:\n- apiGroups:                      \n  - \"\"                            \n  resources:                      \n  - persistentvolumes             \n  verbs:                          \n  - get                           \n  - list                          \nBefore you bind this ClusterRole to your pod\u2019s ServiceAccount, verify whether the pod\ncan list PersistentVolumes. Run the following command in the first terminal, where\nyou\u2019re running the shell inside the pod in the foo namespace:\n/ # curl localhost:8001/api/v1/persistentvolumes\nUser \"system:serviceaccount:foo:default\" cannot list persistentvolumes at the \ncluster scope.\nNOTE\nThe URL contains no namespace, because PersistentVolumes aren\u2019t\nnamespaced. \nAs expected, the default ServiceAccount can\u2019t list PersistentVolumes. You need to\nbind the ClusterRole to your ServiceAccount to allow it to do that. ClusterRoles can\nbe bound to subjects with regular RoleBindings, so you\u2019ll create a RoleBinding now:\n$ kubectl create rolebinding pv-test --clusterrole=pv-reader \n\u27a5 --serviceaccount=foo:default -n foo\nrolebinding \"pv-test\" created\nCan you list PersistentVolumes now?\n/ # curl localhost:8001/api/v1/persistentvolumes\nUser \"system:serviceaccount:foo:default\" cannot list persistentvolumes at the \ncluster scope.\nHmm, that\u2019s strange. Let\u2019s examine the RoleBinding\u2019s YAML in the following listing.\nCan you tell what (if anything) is wrong with it?\n$ kubectl get rolebindings pv-test -o yaml\napiVersion: rbac.authorization.k8s.io/v1\nkind: RoleBinding\nmetadata:\n  name: pv-test\n  namespace: foo\n  ...\nroleRef:\n  apiGroup: rbac.authorization.k8s.io\n  kind: ClusterRole              \n  name: pv-reader                \nListing 12.13\nA RoleBinding referencing a ClusterRole\nIn this case, the \nrules are exactly \nlike those in a \nregular Role.\nThe binding references the \npv-reader ClusterRole.\n \n"}, {"color": "green", "id": "text_307", "label": "364\nCHAPTER 12\nSecuring the Kubernetes API server\nsubjects:\n- kind: ServiceAccount          \n  name: default                 \n  namespace: foo                \nThe YAML looks perfectly fine. You\u2019re referencing the correct ClusterRole and the\ncorrect ServiceAccount, as shown in figure 12.7, so what\u2019s wrong?\nAlthough you can create a RoleBinding and have it reference a ClusterRole when you\nwant to enable access to namespaced resources, you can\u2019t use the same approach for\ncluster-level (non-namespaced) resources. To grant access to cluster-level resources,\nyou must always use a ClusterRoleBinding.\n Luckily, creating a ClusterRoleBinding isn\u2019t that different from creating a Role-\nBinding, but you\u2019ll clean up and delete the RoleBinding first:\n$ kubectl delete rolebinding pv-test\nrolebinding \"pv-test\" deleted\nNow create the ClusterRoleBinding:\n$ kubectl create clusterrolebinding pv-test --clusterrole=pv-reader \n\u27a5 --serviceaccount=foo:default\nclusterrolebinding \"pv-test\" created\nAs you can see, you replaced rolebinding with clusterrolebinding in the command\nand didn\u2019t (need to) specify the namespace. Figure 12.8 shows what you have now.\n Let\u2019s see if you can list PersistentVolumes now:\n/ # curl localhost:8001/api/v1/persistentvolumes\n{\n  \"kind\": \"PersistentVolumeList\",\n  \"apiVersion\": \"v1\",\n...\nThe bound subject is the \ndefault ServiceAccount in \nthe foo namespace.\nNamespace: foo\nCluster-level resources\nClusterRole:\npv-reader\nGet, list\nPersistent\nVolumes\nRoleBinding:\npv-test\nDefault ServiceAccount\nis unable to get and list\nPersistentVolumes\nService-\nAccount:\ndefault\nFigure 12.7\nA RoleBinding referencing a ClusterRole doesn\u2019t grant access to cluster-\nlevel resources.\n \n", "shape": "dot", "size": 10, "title": "364\nCHAPTER 12\nSecuring the Kubernetes API server\nsubjects:\n- kind: ServiceAccount          \n  name: default                 \n  namespace: foo                \nThe YAML looks perfectly fine. You\u2019re referencing the correct ClusterRole and the\ncorrect ServiceAccount, as shown in figure 12.7, so what\u2019s wrong?\nAlthough you can create a RoleBinding and have it reference a ClusterRole when you\nwant to enable access to namespaced resources, you can\u2019t use the same approach for\ncluster-level (non-namespaced) resources. To grant access to cluster-level resources,\nyou must always use a ClusterRoleBinding.\n Luckily, creating a ClusterRoleBinding isn\u2019t that different from creating a Role-\nBinding, but you\u2019ll clean up and delete the RoleBinding first:\n$ kubectl delete rolebinding pv-test\nrolebinding \"pv-test\" deleted\nNow create the ClusterRoleBinding:\n$ kubectl create clusterrolebinding pv-test --clusterrole=pv-reader \n\u27a5 --serviceaccount=foo:default\nclusterrolebinding \"pv-test\" created\nAs you can see, you replaced rolebinding with clusterrolebinding in the command\nand didn\u2019t (need to) specify the namespace. Figure 12.8 shows what you have now.\n Let\u2019s see if you can list PersistentVolumes now:\n/ # curl localhost:8001/api/v1/persistentvolumes\n{\n  \"kind\": \"PersistentVolumeList\",\n  \"apiVersion\": \"v1\",\n...\nThe bound subject is the \ndefault ServiceAccount in \nthe foo namespace.\nNamespace: foo\nCluster-level resources\nClusterRole:\npv-reader\nGet, list\nPersistent\nVolumes\nRoleBinding:\npv-test\nDefault ServiceAccount\nis unable to get and list\nPersistentVolumes\nService-\nAccount:\ndefault\nFigure 12.7\nA RoleBinding referencing a ClusterRole doesn\u2019t grant access to cluster-\nlevel resources.\n \n"}, {"color": "green", "id": "text_308", "label": "365\nSecuring the cluster with role-based access control\nYou can! It turns out you must use a ClusterRole and a ClusterRoleBinding when\ngranting access to cluster-level resources.\nTIP\nRemember that a RoleBinding can\u2019t grant access to cluster-level resources,\neven if it references a ClusterRoleBinding.\nALLOWING ACCESS TO NON-RESOURCE URLS\nWe\u2019ve mentioned that the API server also exposes non-resource URLs. Access to these\nURLs must also be granted explicitly; otherwise the API server will reject the client\u2019s\nrequest. Usually, this is done for you automatically through the system:discovery\nClusterRole and the identically named ClusterRoleBinding, which appear among\nother predefined ClusterRoles and ClusterRoleBindings (we\u2019ll explore them in sec-\ntion 12.2.5). \n Let\u2019s inspect the system:discovery ClusterRole shown in the following listing.\n$ kubectl get clusterrole system:discovery -o yaml\napiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRole\nmetadata:\n  name: system:discovery\n  ...\nrules:\n- nonResourceURLs:      \n  - /api                \n  - /api/*              \n  - /apis               \n  - /apis/*             \n  - /healthz            \n  - /swaggerapi         \n  - /swaggerapi/*       \n  - /version            \nListing 12.14\nThe default system:discovery ClusterRole\nNamespace: foo\nCluster-level resources\nClusterRole:\npv-reader\nGet, list\nPersistent\nVolumes\nClusterRoleBinding:\npv-test\nDefault ServiceAccount in\nfoo namespace is now allowed\nto get and list PersistentVolumes\nService-\nAccount:\ndefault\nFigure 12.8\nA ClusterRoleBinding and ClusterRole must be used to grant access to cluster-\nlevel resources.\nInstead of referring \nto resources, this rule \nrefers to non-resource \nURLs.\n \n", "shape": "dot", "size": 10, "title": "365\nSecuring the cluster with role-based access control\nYou can! It turns out you must use a ClusterRole and a ClusterRoleBinding when\ngranting access to cluster-level resources.\nTIP\nRemember that a RoleBinding can\u2019t grant access to cluster-level resources,\neven if it references a ClusterRoleBinding.\nALLOWING ACCESS TO NON-RESOURCE URLS\nWe\u2019ve mentioned that the API server also exposes non-resource URLs. Access to these\nURLs must also be granted explicitly; otherwise the API server will reject the client\u2019s\nrequest. Usually, this is done for you automatically through the system:discovery\nClusterRole and the identically named ClusterRoleBinding, which appear among\nother predefined ClusterRoles and ClusterRoleBindings (we\u2019ll explore them in sec-\ntion 12.2.5). \n Let\u2019s inspect the system:discovery ClusterRole shown in the following listing.\n$ kubectl get clusterrole system:discovery -o yaml\napiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRole\nmetadata:\n  name: system:discovery\n  ...\nrules:\n- nonResourceURLs:      \n  - /api                \n  - /api/*              \n  - /apis               \n  - /apis/*             \n  - /healthz            \n  - /swaggerapi         \n  - /swaggerapi/*       \n  - /version            \nListing 12.14\nThe default system:discovery ClusterRole\nNamespace: foo\nCluster-level resources\nClusterRole:\npv-reader\nGet, list\nPersistent\nVolumes\nClusterRoleBinding:\npv-test\nDefault ServiceAccount in\nfoo namespace is now allowed\nto get and list PersistentVolumes\nService-\nAccount:\ndefault\nFigure 12.8\nA ClusterRoleBinding and ClusterRole must be used to grant access to cluster-\nlevel resources.\nInstead of referring \nto resources, this rule \nrefers to non-resource \nURLs.\n \n"}, {"color": "green", "id": "text_309", "label": "366\nCHAPTER 12\nSecuring the Kubernetes API server\n  verbs:             \n  - get              \nYou can see this ClusterRole refers to URLs instead of resources (field nonResource-\nURLs is used instead of the resources field). The verbs field only allows the GET HTTP\nmethod to be used on these URLs.\nNOTE\nFor non-resource URLs, plain HTTP verbs such as post, put, and\npatch are used instead of create or update. The verbs need to be specified in\nlowercase.\nAs with cluster-level resources, ClusterRoles for non-resource URLs must be bound\nwith a ClusterRoleBinding. Binding them with a RoleBinding won\u2019t have any effect.\nThe system:discovery ClusterRole has a corresponding system:discovery Cluster-\nRoleBinding, so let\u2019s see what\u2019s in it by examining the following listing.\n$ kubectl get clusterrolebinding system:discovery -o yaml\napiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRoleBinding\nmetadata:\n  name: system:discovery\n  ...\nroleRef:\n  apiGroup: rbac.authorization.k8s.io\n  kind: ClusterRole                           \n  name: system:discovery                      \nsubjects:\n- apiGroup: rbac.authorization.k8s.io\n  kind: Group                                 \n  name: system:authenticated                  \n- apiGroup: rbac.authorization.k8s.io\n  kind: Group                                 \n  name: system:unauthenticated                \nThe YAML shows the ClusterRoleBinding refers to the system:discovery ClusterRole,\nas expected. It\u2019s bound to two groups, system:authenticated and system:unauthenti-\ncated, which makes it bound to all users. This means absolutely everyone can access\nthe URLs listed in the ClusterRole. \nNOTE\nGroups are in the domain of the authentication plugin. When a\nrequest is received by the API server, it calls the authentication plugin to\nobtain the list of groups the user belongs to. This information is then used\nin authorization.\nYou can confirm this by accessing the /api URL path from inside the pod (through\nthe kubectl proxy, which means you\u2019ll be authenticated as the pod\u2019s ServiceAccount)\nListing 12.15\nThe default system:discovery ClusterRoleBinding\nOnly the HTTP GET method \nis allowed for these URLs.\nThis ClusterRoleBinding references \nthe system:discovery ClusterRole.\nIt binds the ClusterRole \nto all authenticated and \nunauthenticated users \n(that is, everyone).\n \n", "shape": "dot", "size": 10, "title": "366\nCHAPTER 12\nSecuring the Kubernetes API server\n  verbs:             \n  - get              \nYou can see this ClusterRole refers to URLs instead of resources (field nonResource-\nURLs is used instead of the resources field). The verbs field only allows the GET HTTP\nmethod to be used on these URLs.\nNOTE\nFor non-resource URLs, plain HTTP verbs such as post, put, and\npatch are used instead of create or update. The verbs need to be specified in\nlowercase.\nAs with cluster-level resources, ClusterRoles for non-resource URLs must be bound\nwith a ClusterRoleBinding. Binding them with a RoleBinding won\u2019t have any effect.\nThe system:discovery ClusterRole has a corresponding system:discovery Cluster-\nRoleBinding, so let\u2019s see what\u2019s in it by examining the following listing.\n$ kubectl get clusterrolebinding system:discovery -o yaml\napiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRoleBinding\nmetadata:\n  name: system:discovery\n  ...\nroleRef:\n  apiGroup: rbac.authorization.k8s.io\n  kind: ClusterRole                           \n  name: system:discovery                      \nsubjects:\n- apiGroup: rbac.authorization.k8s.io\n  kind: Group                                 \n  name: system:authenticated                  \n- apiGroup: rbac.authorization.k8s.io\n  kind: Group                                 \n  name: system:unauthenticated                \nThe YAML shows the ClusterRoleBinding refers to the system:discovery ClusterRole,\nas expected. It\u2019s bound to two groups, system:authenticated and system:unauthenti-\ncated, which makes it bound to all users. This means absolutely everyone can access\nthe URLs listed in the ClusterRole. \nNOTE\nGroups are in the domain of the authentication plugin. When a\nrequest is received by the API server, it calls the authentication plugin to\nobtain the list of groups the user belongs to. This information is then used\nin authorization.\nYou can confirm this by accessing the /api URL path from inside the pod (through\nthe kubectl proxy, which means you\u2019ll be authenticated as the pod\u2019s ServiceAccount)\nListing 12.15\nThe default system:discovery ClusterRoleBinding\nOnly the HTTP GET method \nis allowed for these URLs.\nThis ClusterRoleBinding references \nthe system:discovery ClusterRole.\nIt binds the ClusterRole \nto all authenticated and \nunauthenticated users \n(that is, everyone).\n \n"}, {"color": "green", "id": "text_310", "label": "367\nSecuring the cluster with role-based access control\nand from your local machine, without specifying any authentication tokens (making\nyou an unauthenticated user):\n$ curl https://$(minikube ip):8443/api -k\n{\n  \"kind\": \"APIVersions\",\n  \"versions\": [\n  ...\nYou\u2019ve now used ClusterRoles and ClusterRoleBindings to grant access to cluster-level\nresources and non-resource URLs. Now let\u2019s look at how ClusterRoles can be used\nwith namespaced RoleBindings to grant access to namespaced resources in the Role-\nBinding\u2019s namespace.\nUSING CLUSTERROLES TO GRANT ACCESS TO RESOURCES IN SPECIFIC NAMESPACES\nClusterRoles don\u2019t always need to be bound with cluster-level ClusterRoleBindings.\nThey can also be bound with regular, namespaced RoleBindings. You\u2019ve already\nstarted looking at predefined ClusterRoles, so let\u2019s look at another one called view,\nwhich is shown in the following listing.\n$ kubectl get clusterrole view -o yaml\napiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRole\nmetadata:\n  name: view\n  ...\nrules:\n- apiGroups:\n  - \"\"\n  resources:                           \n  - configmaps                         \n  - endpoints                          \n  - persistentvolumeclaims             \n  - pods                               \n  - replicationcontrollers             \n  - replicationcontrollers/scale       \n  - serviceaccounts                    \n  - services                           \n  verbs:                \n  - get                 \n  - list                \n  - watch               \n...\nThis ClusterRole has many rules. Only the first one is shown in the listing. The rule\nallows getting, listing, and watching resources like ConfigMaps, Endpoints, Persistent-\nVolumeClaims, and so on. These are namespaced resources, even though you\u2019re\nlooking at a ClusterRole (not a regular, namespaced Role). What exactly does this\nClusterRole do?\nListing 12.16\nThe default view ClusterRole\nThis rule applies to \nthese resources (note: \nthey\u2019re all namespaced \nresources).\nAs the ClusterRole\u2019s name \nsuggests, it only allows \nreading, not writing the \nresources listed. \n \n", "shape": "dot", "size": 10, "title": "367\nSecuring the cluster with role-based access control\nand from your local machine, without specifying any authentication tokens (making\nyou an unauthenticated user):\n$ curl https://$(minikube ip):8443/api -k\n{\n  \"kind\": \"APIVersions\",\n  \"versions\": [\n  ...\nYou\u2019ve now used ClusterRoles and ClusterRoleBindings to grant access to cluster-level\nresources and non-resource URLs. Now let\u2019s look at how ClusterRoles can be used\nwith namespaced RoleBindings to grant access to namespaced resources in the Role-\nBinding\u2019s namespace.\nUSING CLUSTERROLES TO GRANT ACCESS TO RESOURCES IN SPECIFIC NAMESPACES\nClusterRoles don\u2019t always need to be bound with cluster-level ClusterRoleBindings.\nThey can also be bound with regular, namespaced RoleBindings. You\u2019ve already\nstarted looking at predefined ClusterRoles, so let\u2019s look at another one called view,\nwhich is shown in the following listing.\n$ kubectl get clusterrole view -o yaml\napiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRole\nmetadata:\n  name: view\n  ...\nrules:\n- apiGroups:\n  - \"\"\n  resources:                           \n  - configmaps                         \n  - endpoints                          \n  - persistentvolumeclaims             \n  - pods                               \n  - replicationcontrollers             \n  - replicationcontrollers/scale       \n  - serviceaccounts                    \n  - services                           \n  verbs:                \n  - get                 \n  - list                \n  - watch               \n...\nThis ClusterRole has many rules. Only the first one is shown in the listing. The rule\nallows getting, listing, and watching resources like ConfigMaps, Endpoints, Persistent-\nVolumeClaims, and so on. These are namespaced resources, even though you\u2019re\nlooking at a ClusterRole (not a regular, namespaced Role). What exactly does this\nClusterRole do?\nListing 12.16\nThe default view ClusterRole\nThis rule applies to \nthese resources (note: \nthey\u2019re all namespaced \nresources).\nAs the ClusterRole\u2019s name \nsuggests, it only allows \nreading, not writing the \nresources listed. \n \n"}, {"color": "green", "id": "text_311", "label": "368\nCHAPTER 12\nSecuring the Kubernetes API server\n It depends whether it\u2019s bound with a ClusterRoleBinding or a RoleBinding (it can\nbe bound with either). If you create a ClusterRoleBinding and reference the Cluster-\nRole in it, the subjects listed in the binding can view the specified resources across all\nnamespaces. If, on the other hand, you create a RoleBinding, the subjects listed in the\nbinding can only view resources in the namespace of the RoleBinding. You\u2019ll try both\noptions now.\n You\u2019ll see how the two options affect your test pod\u2019s ability to list pods. First, let\u2019s\nsee what happens before any bindings are in place:\n/ # curl localhost:8001/api/v1/pods\nUser \"system:serviceaccount:foo:default\" cannot list pods at the cluster \nscope./ #\n/ # curl localhost:8001/api/v1/namespaces/foo/pods\nUser \"system:serviceaccount:foo:default\" cannot list pods in the namespace \n\"foo\".\nWith the first command, you\u2019re trying to list pods across all namespaces. With the sec-\nond, you\u2019re trying to list pods in the foo namespace. The server doesn\u2019t allow you to\ndo either.\n Now, let\u2019s see what happens when you create a ClusterRoleBinding and bind it to\nthe pod\u2019s ServiceAccount:\n$ kubectl create clusterrolebinding view-test --clusterrole=view \n\u27a5 --serviceaccount=foo:default\nclusterrolebinding \"view-test\" created\nCan the pod now list pods in the foo namespace?\n/ # curl localhost:8001/api/v1/namespaces/foo/pods\n{\n  \"kind\": \"PodList\",\n  \"apiVersion\": \"v1\",\n  ...\nIt can! Because you created a ClusterRoleBinding, it applies across all namespaces.\nThe pod in namespace foo can list pods in the bar namespace as well:\n/ # curl localhost:8001/api/v1/namespaces/bar/pods\n{\n  \"kind\": \"PodList\",\n  \"apiVersion\": \"v1\",\n  ...\nOkay, the pod is allowed to list pods in a different namespace. It can also retrieve pods\nacross all namespaces by hitting the /api/v1/pods URL path:\n/ # curl localhost:8001/api/v1/pods\n{\n  \"kind\": \"PodList\",\n  \"apiVersion\": \"v1\",\n  ...\n \n", "shape": "dot", "size": 10, "title": "368\nCHAPTER 12\nSecuring the Kubernetes API server\n It depends whether it\u2019s bound with a ClusterRoleBinding or a RoleBinding (it can\nbe bound with either). If you create a ClusterRoleBinding and reference the Cluster-\nRole in it, the subjects listed in the binding can view the specified resources across all\nnamespaces. If, on the other hand, you create a RoleBinding, the subjects listed in the\nbinding can only view resources in the namespace of the RoleBinding. You\u2019ll try both\noptions now.\n You\u2019ll see how the two options affect your test pod\u2019s ability to list pods. First, let\u2019s\nsee what happens before any bindings are in place:\n/ # curl localhost:8001/api/v1/pods\nUser \"system:serviceaccount:foo:default\" cannot list pods at the cluster \nscope./ #\n/ # curl localhost:8001/api/v1/namespaces/foo/pods\nUser \"system:serviceaccount:foo:default\" cannot list pods in the namespace \n\"foo\".\nWith the first command, you\u2019re trying to list pods across all namespaces. With the sec-\nond, you\u2019re trying to list pods in the foo namespace. The server doesn\u2019t allow you to\ndo either.\n Now, let\u2019s see what happens when you create a ClusterRoleBinding and bind it to\nthe pod\u2019s ServiceAccount:\n$ kubectl create clusterrolebinding view-test --clusterrole=view \n\u27a5 --serviceaccount=foo:default\nclusterrolebinding \"view-test\" created\nCan the pod now list pods in the foo namespace?\n/ # curl localhost:8001/api/v1/namespaces/foo/pods\n{\n  \"kind\": \"PodList\",\n  \"apiVersion\": \"v1\",\n  ...\nIt can! Because you created a ClusterRoleBinding, it applies across all namespaces.\nThe pod in namespace foo can list pods in the bar namespace as well:\n/ # curl localhost:8001/api/v1/namespaces/bar/pods\n{\n  \"kind\": \"PodList\",\n  \"apiVersion\": \"v1\",\n  ...\nOkay, the pod is allowed to list pods in a different namespace. It can also retrieve pods\nacross all namespaces by hitting the /api/v1/pods URL path:\n/ # curl localhost:8001/api/v1/pods\n{\n  \"kind\": \"PodList\",\n  \"apiVersion\": \"v1\",\n  ...\n \n"}, {"color": "green", "id": "text_312", "label": "369\nSecuring the cluster with role-based access control\nAs expected, the pod can get a list of all the pods in the cluster. To summarize, com-\nbining a ClusterRoleBinding with a ClusterRole referring to namespaced resources\nallows the pod to access namespaced resources in any namespace, as shown in fig-\nure 12.9.\nNow, let\u2019s see what happens if you replace the ClusterRoleBinding with a RoleBinding.\nFirst, delete the ClusterRoleBinding:\n$ kubectl delete clusterrolebinding view-test\nclusterrolebinding \"view-test\" deleted\nNext create a RoleBinding instead. Because a RoleBinding is namespaced, you need\nto specify the namespace you want to create it in. Create it in the foo namespace:\n$ kubectl create rolebinding view-test --clusterrole=view \n\u27a5 --serviceaccount=foo:default -n foo\nrolebinding \"view-test\" created\nYou now have a RoleBinding in the foo namespace, binding the default Service-\nAccount in that same namespace with the view ClusterRole. What can your pod\naccess now?\n/ # curl localhost:8001/api/v1/namespaces/foo/pods\n{\n  \"kind\": \"PodList\",\n  \"apiVersion\": \"v1\",\n  ...\nNamespace: foo\nCluster-level\nresources\nNamespace: bar\nPods\nPods\nDefault\nServiceAccount\nin foo namespace\nis allowed to\nview pods in\nany namespace\nClusterRole:\nview\nAllows getting,\nlisting, watching\nClusterRoleBinding:\nview-test\nPods,\nServices,\nEndpoints,\nCon\ufb01gMaps,\n\u2026\nService-\nAccount:\ndefault\nFigure 12.9\nA ClusterRoleBinding and ClusterRole grants permission to resources across all \nnamespaces.\n \n", "shape": "dot", "size": 10, "title": "369\nSecuring the cluster with role-based access control\nAs expected, the pod can get a list of all the pods in the cluster. To summarize, com-\nbining a ClusterRoleBinding with a ClusterRole referring to namespaced resources\nallows the pod to access namespaced resources in any namespace, as shown in fig-\nure 12.9.\nNow, let\u2019s see what happens if you replace the ClusterRoleBinding with a RoleBinding.\nFirst, delete the ClusterRoleBinding:\n$ kubectl delete clusterrolebinding view-test\nclusterrolebinding \"view-test\" deleted\nNext create a RoleBinding instead. Because a RoleBinding is namespaced, you need\nto specify the namespace you want to create it in. Create it in the foo namespace:\n$ kubectl create rolebinding view-test --clusterrole=view \n\u27a5 --serviceaccount=foo:default -n foo\nrolebinding \"view-test\" created\nYou now have a RoleBinding in the foo namespace, binding the default Service-\nAccount in that same namespace with the view ClusterRole. What can your pod\naccess now?\n/ # curl localhost:8001/api/v1/namespaces/foo/pods\n{\n  \"kind\": \"PodList\",\n  \"apiVersion\": \"v1\",\n  ...\nNamespace: foo\nCluster-level\nresources\nNamespace: bar\nPods\nPods\nDefault\nServiceAccount\nin foo namespace\nis allowed to\nview pods in\nany namespace\nClusterRole:\nview\nAllows getting,\nlisting, watching\nClusterRoleBinding:\nview-test\nPods,\nServices,\nEndpoints,\nCon\ufb01gMaps,\n\u2026\nService-\nAccount:\ndefault\nFigure 12.9\nA ClusterRoleBinding and ClusterRole grants permission to resources across all \nnamespaces.\n \n"}, {"color": "green", "id": "text_313", "label": "370\nCHAPTER 12\nSecuring the Kubernetes API server\n/ # curl localhost:8001/api/v1/namespaces/bar/pods\nUser \"system:serviceaccount:foo:default\" cannot list pods in the namespace \n\"bar\".\n/ # curl localhost:8001/api/v1/pods\nUser \"system:serviceaccount:foo:default\" cannot list pods at the cluster \nscope.\nAs you can see, your pod can list pods in the foo namespace, but not in any other spe-\ncific namespace or across all namespaces. This is visualized in figure 12.10.\nSUMMARIZING ROLE, CLUSTERROLE, ROLEBINDING, AND CLUSTERROLEBINDING COMBINATIONS\nWe\u2019ve covered many different combinations and it may be hard for you to remember\nwhen to use each one. Let\u2019s see if we can make sense of all these combinations by cat-\negorizing them per specific use case. Refer to table 12.2.\nTable 12.2\nWhen to use specific combinations of role and binding types\nFor accessing\nRole type to use\nBinding type to use\nCluster-level resources (Nodes, PersistentVolumes, ...)\nClusterRole\nClusterRoleBinding\nNon-resource URLs (/api, /healthz, ...)\nClusterRole\nClusterRoleBinding\nNamespaced resources in any namespace (and \nacross all namespaces)\nClusterRole\nClusterRoleBinding\nNamespaced resources in a specific namespace (reus-\ning the same ClusterRole in multiple namespaces)\nClusterRole\nRoleBinding\nNamespaced resources in a specific namespace \n(Role must be defined in each namespace)\nRole\nRoleBinding\nNamespace: foo\nCluster-level resources\nNamespace: bar\nPods\nPods\nClusterRole:\nview\nAllows getting,\nlisting, watching\nRoleBinding:\nview-test\nPods,\nServices,\nEndpoints,\nCon\ufb01gMaps,\n\u2026\nDefault ServiceAccount in\nfoo namespace is only allowed\nto view pods in namespace foo,\ndespite using a ClusterRole\nService-\nAccount:\ndefault\nFigure 12.10\nA RoleBinding referring to a ClusterRole only grants access to resources inside the \nRoleBinding\u2019s namespace.\n \n", "shape": "dot", "size": 10, "title": "370\nCHAPTER 12\nSecuring the Kubernetes API server\n/ # curl localhost:8001/api/v1/namespaces/bar/pods\nUser \"system:serviceaccount:foo:default\" cannot list pods in the namespace \n\"bar\".\n/ # curl localhost:8001/api/v1/pods\nUser \"system:serviceaccount:foo:default\" cannot list pods at the cluster \nscope.\nAs you can see, your pod can list pods in the foo namespace, but not in any other spe-\ncific namespace or across all namespaces. This is visualized in figure 12.10.\nSUMMARIZING ROLE, CLUSTERROLE, ROLEBINDING, AND CLUSTERROLEBINDING COMBINATIONS\nWe\u2019ve covered many different combinations and it may be hard for you to remember\nwhen to use each one. Let\u2019s see if we can make sense of all these combinations by cat-\negorizing them per specific use case. Refer to table 12.2.\nTable 12.2\nWhen to use specific combinations of role and binding types\nFor accessing\nRole type to use\nBinding type to use\nCluster-level resources (Nodes, PersistentVolumes, ...)\nClusterRole\nClusterRoleBinding\nNon-resource URLs (/api, /healthz, ...)\nClusterRole\nClusterRoleBinding\nNamespaced resources in any namespace (and \nacross all namespaces)\nClusterRole\nClusterRoleBinding\nNamespaced resources in a specific namespace (reus-\ning the same ClusterRole in multiple namespaces)\nClusterRole\nRoleBinding\nNamespaced resources in a specific namespace \n(Role must be defined in each namespace)\nRole\nRoleBinding\nNamespace: foo\nCluster-level resources\nNamespace: bar\nPods\nPods\nClusterRole:\nview\nAllows getting,\nlisting, watching\nRoleBinding:\nview-test\nPods,\nServices,\nEndpoints,\nCon\ufb01gMaps,\n\u2026\nDefault ServiceAccount in\nfoo namespace is only allowed\nto view pods in namespace foo,\ndespite using a ClusterRole\nService-\nAccount:\ndefault\nFigure 12.10\nA RoleBinding referring to a ClusterRole only grants access to resources inside the \nRoleBinding\u2019s namespace.\n \n"}, {"color": "green", "id": "text_314", "label": "371\nSecuring the cluster with role-based access control\nHopefully, the relationships between the four RBAC resources are much clearer\nnow. Don\u2019t worry if you still feel like you don\u2019t yet grasp everything. Things may\nclear up as we explore the pre-configured ClusterRoles and ClusterRoleBindings in\nthe next section.\n12.2.5 Understanding default ClusterRoles and ClusterRoleBindings\nKubernetes comes with a default set of ClusterRoles and ClusterRoleBindings, which\nare updated every time the API server starts. This ensures all the default roles and\nbindings are recreated if you mistakenly delete them or if a newer version of Kuberne-\ntes uses a different configuration of cluster roles and bindings.\n You can see the default cluster roles and bindings in the following listing.\n$ kubectl get clusterrolebindings\nNAME                                           AGE\ncluster-admin                                  1d\nsystem:basic-user                              1d\nsystem:controller:attachdetach-controller      1d\n...\nsystem:controller:ttl-controller               1d\nsystem:discovery                               1d\nsystem:kube-controller-manager                 1d\nsystem:kube-dns                                1d\nsystem:kube-scheduler                          1d\nsystem:node                                    1d\nsystem:node-proxier                            1d\n$ kubectl get clusterroles\nNAME                                           AGE\nadmin                                          1d\ncluster-admin                                  1d\nedit                                           1d\nsystem:auth-delegator                          1d\nsystem:basic-user                              1d\nsystem:controller:attachdetach-controller      1d\n...\nsystem:controller:ttl-controller               1d\nsystem:discovery                               1d\nsystem:heapster                                1d\nsystem:kube-aggregator                         1d\nsystem:kube-controller-manager                 1d\nsystem:kube-dns                                1d\nsystem:kube-scheduler                          1d\nsystem:node                                    1d\nsystem:node-bootstrapper                       1d\nsystem:node-problem-detector                   1d\nsystem:node-proxier                            1d\nsystem:persistent-volume-provisioner           1d\nview                                           1d\nListing 12.17\nListing all ClusterRoleBindings and ClusterRoles\n \n", "shape": "dot", "size": 10, "title": "371\nSecuring the cluster with role-based access control\nHopefully, the relationships between the four RBAC resources are much clearer\nnow. Don\u2019t worry if you still feel like you don\u2019t yet grasp everything. Things may\nclear up as we explore the pre-configured ClusterRoles and ClusterRoleBindings in\nthe next section.\n12.2.5 Understanding default ClusterRoles and ClusterRoleBindings\nKubernetes comes with a default set of ClusterRoles and ClusterRoleBindings, which\nare updated every time the API server starts. This ensures all the default roles and\nbindings are recreated if you mistakenly delete them or if a newer version of Kuberne-\ntes uses a different configuration of cluster roles and bindings.\n You can see the default cluster roles and bindings in the following listing.\n$ kubectl get clusterrolebindings\nNAME                                           AGE\ncluster-admin                                  1d\nsystem:basic-user                              1d\nsystem:controller:attachdetach-controller      1d\n...\nsystem:controller:ttl-controller               1d\nsystem:discovery                               1d\nsystem:kube-controller-manager                 1d\nsystem:kube-dns                                1d\nsystem:kube-scheduler                          1d\nsystem:node                                    1d\nsystem:node-proxier                            1d\n$ kubectl get clusterroles\nNAME                                           AGE\nadmin                                          1d\ncluster-admin                                  1d\nedit                                           1d\nsystem:auth-delegator                          1d\nsystem:basic-user                              1d\nsystem:controller:attachdetach-controller      1d\n...\nsystem:controller:ttl-controller               1d\nsystem:discovery                               1d\nsystem:heapster                                1d\nsystem:kube-aggregator                         1d\nsystem:kube-controller-manager                 1d\nsystem:kube-dns                                1d\nsystem:kube-scheduler                          1d\nsystem:node                                    1d\nsystem:node-bootstrapper                       1d\nsystem:node-problem-detector                   1d\nsystem:node-proxier                            1d\nsystem:persistent-volume-provisioner           1d\nview                                           1d\nListing 12.17\nListing all ClusterRoleBindings and ClusterRoles\n \n"}, {"color": "green", "id": "text_315", "label": "372\nCHAPTER 12\nSecuring the Kubernetes API server\nThe most important roles are the view, edit, admin, and cluster-admin ClusterRoles.\nThey\u2019re meant to be bound to ServiceAccounts used by user-defined pods.\nALLOWING READ-ONLY ACCESS TO RESOURCES WITH THE VIEW CLUSTERROLE\nYou already used the default view ClusterRole in the previous example. It allows read-\ning most resources in a namespace, except for Roles, RoleBindings, and Secrets. You\u2019re\nprobably wondering, why not Secrets? Because one of those Secrets might include an\nauthentication token with greater privileges than those defined in the view Cluster-\nRole and could allow the user to masquerade as a different user to gain additional\nprivileges (privilege escalation). \nALLOWING MODIFYING RESOURCES WITH THE EDIT CLUSTERROLE\nNext is the edit ClusterRole, which allows you to modify resources in a namespace,\nbut also allows both reading and modifying Secrets. It doesn\u2019t, however, allow viewing\nor modifying Roles or RoleBindings\u2014again, this is to prevent privilege escalation.\nGRANTING FULL CONTROL OF A NAMESPACE WITH THE ADMIN CLUSTERROLE\nComplete control of the resources in a namespace is granted in the admin Cluster-\nRole. Subjects with this ClusterRole can read and modify any resource in the name-\nspace, except ResourceQuotas (we\u2019ll learn what those are in chapter 14) and the\nNamespace resource itself. The main difference between the edit and the admin Cluster-\nRoles is in the ability to view and modify Roles and RoleBindings in the namespace.\nNOTE\nTo prevent privilege escalation, the API server only allows users to cre-\nate and update Roles if they already have all the permissions listed in that\nRole (and for the same scope). \nALLOWING COMPLETE CONTROL WITH THE CLUSTER-ADMIN CLUSTERROLE \nComplete control of the Kubernetes cluster can be given by assigning the cluster-\nadmin ClusterRole to a subject. As you\u2019ve seen before, the admin ClusterRole doesn\u2019t\nallow users to modify the namespace\u2019s ResourceQuota objects or the Namespace\nresource itself. If you want to allow a user to do that, you need to create a RoleBinding\nthat references the cluster-admin ClusterRole. This gives the user included in the\nRoleBinding complete control over all aspects of the namespace in which the Role-\nBinding is created.\n If you\u2019ve paid attention, you probably already know how to give users complete\ncontrol of all the namespaces in the cluster. Yes, by referencing the cluster-admin\nClusterRole in a ClusterRoleBinding instead of a RoleBinding.\nUNDERSTANDING THE OTHER DEFAULT CLUSTERROLES\nThe list of default ClusterRoles includes a large number of other ClusterRoles, which\nstart with the system: prefix. These are meant to be used by the various Kubernetes\ncomponents. Among them, you\u2019ll find roles such as system:kube-scheduler, which\nis obviously used by the Scheduler, system:node, which is used by the Kubelets, and\nso on. \n \n", "shape": "dot", "size": 10, "title": "372\nCHAPTER 12\nSecuring the Kubernetes API server\nThe most important roles are the view, edit, admin, and cluster-admin ClusterRoles.\nThey\u2019re meant to be bound to ServiceAccounts used by user-defined pods.\nALLOWING READ-ONLY ACCESS TO RESOURCES WITH THE VIEW CLUSTERROLE\nYou already used the default view ClusterRole in the previous example. It allows read-\ning most resources in a namespace, except for Roles, RoleBindings, and Secrets. You\u2019re\nprobably wondering, why not Secrets? Because one of those Secrets might include an\nauthentication token with greater privileges than those defined in the view Cluster-\nRole and could allow the user to masquerade as a different user to gain additional\nprivileges (privilege escalation). \nALLOWING MODIFYING RESOURCES WITH THE EDIT CLUSTERROLE\nNext is the edit ClusterRole, which allows you to modify resources in a namespace,\nbut also allows both reading and modifying Secrets. It doesn\u2019t, however, allow viewing\nor modifying Roles or RoleBindings\u2014again, this is to prevent privilege escalation.\nGRANTING FULL CONTROL OF A NAMESPACE WITH THE ADMIN CLUSTERROLE\nComplete control of the resources in a namespace is granted in the admin Cluster-\nRole. Subjects with this ClusterRole can read and modify any resource in the name-\nspace, except ResourceQuotas (we\u2019ll learn what those are in chapter 14) and the\nNamespace resource itself. The main difference between the edit and the admin Cluster-\nRoles is in the ability to view and modify Roles and RoleBindings in the namespace.\nNOTE\nTo prevent privilege escalation, the API server only allows users to cre-\nate and update Roles if they already have all the permissions listed in that\nRole (and for the same scope). \nALLOWING COMPLETE CONTROL WITH THE CLUSTER-ADMIN CLUSTERROLE \nComplete control of the Kubernetes cluster can be given by assigning the cluster-\nadmin ClusterRole to a subject. As you\u2019ve seen before, the admin ClusterRole doesn\u2019t\nallow users to modify the namespace\u2019s ResourceQuota objects or the Namespace\nresource itself. If you want to allow a user to do that, you need to create a RoleBinding\nthat references the cluster-admin ClusterRole. This gives the user included in the\nRoleBinding complete control over all aspects of the namespace in which the Role-\nBinding is created.\n If you\u2019ve paid attention, you probably already know how to give users complete\ncontrol of all the namespaces in the cluster. Yes, by referencing the cluster-admin\nClusterRole in a ClusterRoleBinding instead of a RoleBinding.\nUNDERSTANDING THE OTHER DEFAULT CLUSTERROLES\nThe list of default ClusterRoles includes a large number of other ClusterRoles, which\nstart with the system: prefix. These are meant to be used by the various Kubernetes\ncomponents. Among them, you\u2019ll find roles such as system:kube-scheduler, which\nis obviously used by the Scheduler, system:node, which is used by the Kubelets, and\nso on. \n \n"}, {"color": "green", "id": "text_316", "label": "373\nSummary\n Although the Controller Manager runs as a single pod, each controller running\ninside it can use a separate ClusterRole and ClusterRoleBinding (they\u2019re prefixed\nwith system: controller:). \n Each of these system ClusterRoles has a matching ClusterRoleBinding, which binds\nit to the user the system component authenticates as. The system:kube-scheduler\nClusterRoleBinding, for example, assigns the identically named ClusterRole to the\nsystem:kube-scheduler user, which is the username the scheduler Authenticates as. \n12.2.6 Granting authorization permissions wisely\nBy default, the default ServiceAccount in a namespace has no permissions other than\nthose of an unauthenticated user (as you may remember from one of the previous\nexamples, the system:discovery ClusterRole and associated binding allow anyone to\nmake GET requests on a few non-resource URLs). Therefore, pods, by default, can\u2019t\neven view cluster state. It\u2019s up to you to grant them appropriate permissions to do that. \n Obviously, giving all your ServiceAccounts the cluster-admin ClusterRole is a\nbad idea. As is always the case with security, it\u2019s best to give everyone only the permis-\nsions they need to do their job and not a single permission more (principle of least\nprivilege).\nCREATING SPECIFIC SERVICEACCOUNTS FOR EACH POD\nIt\u2019s a good idea to create a specific ServiceAccount for each pod (or a set of pod rep-\nlicas) and then associate it with a tailor-made Role (or a ClusterRole) through a\nRoleBinding (not a ClusterRoleBinding, because that would give the pod access to\nresources in other namespaces, which is probably not what you want). \n If one of your pods (the application running within it) only needs to read pods,\nwhile the other also needs to modify them, then create two different ServiceAccounts\nand make those pods use them by specifying the serviceAccountName property in the\npod spec, as you learned in the first part of this chapter. Don\u2019t add all the necessary\npermissions required by both pods to the default ServiceAccount in the namespace. \nEXPECTING YOUR APPS TO BE COMPROMISED\nYour aim is to reduce the possibility of an intruder getting hold of your cluster. Today\u2019s\ncomplex apps contain many vulnerabilities. You should expect unwanted persons to\neventually get their hands on the ServiceAccount\u2019s authentication token, so you should\nalways constrain the ServiceAccount to prevent them from doing any real damage.\n12.3\nSummary\nThis chapter has given you a foundation on how to secure the Kubernetes API server.\nYou learned the following:\n\uf0a1Clients of the API server include both human users and applications running\nin pods.\n\uf0a1Applications in pods are associated with a ServiceAccount. \n\uf0a1Both users and ServiceAccounts are associated with groups.\n \n", "shape": "dot", "size": 10, "title": "373\nSummary\n Although the Controller Manager runs as a single pod, each controller running\ninside it can use a separate ClusterRole and ClusterRoleBinding (they\u2019re prefixed\nwith system: controller:). \n Each of these system ClusterRoles has a matching ClusterRoleBinding, which binds\nit to the user the system component authenticates as. The system:kube-scheduler\nClusterRoleBinding, for example, assigns the identically named ClusterRole to the\nsystem:kube-scheduler user, which is the username the scheduler Authenticates as. \n12.2.6 Granting authorization permissions wisely\nBy default, the default ServiceAccount in a namespace has no permissions other than\nthose of an unauthenticated user (as you may remember from one of the previous\nexamples, the system:discovery ClusterRole and associated binding allow anyone to\nmake GET requests on a few non-resource URLs). Therefore, pods, by default, can\u2019t\neven view cluster state. It\u2019s up to you to grant them appropriate permissions to do that. \n Obviously, giving all your ServiceAccounts the cluster-admin ClusterRole is a\nbad idea. As is always the case with security, it\u2019s best to give everyone only the permis-\nsions they need to do their job and not a single permission more (principle of least\nprivilege).\nCREATING SPECIFIC SERVICEACCOUNTS FOR EACH POD\nIt\u2019s a good idea to create a specific ServiceAccount for each pod (or a set of pod rep-\nlicas) and then associate it with a tailor-made Role (or a ClusterRole) through a\nRoleBinding (not a ClusterRoleBinding, because that would give the pod access to\nresources in other namespaces, which is probably not what you want). \n If one of your pods (the application running within it) only needs to read pods,\nwhile the other also needs to modify them, then create two different ServiceAccounts\nand make those pods use them by specifying the serviceAccountName property in the\npod spec, as you learned in the first part of this chapter. Don\u2019t add all the necessary\npermissions required by both pods to the default ServiceAccount in the namespace. \nEXPECTING YOUR APPS TO BE COMPROMISED\nYour aim is to reduce the possibility of an intruder getting hold of your cluster. Today\u2019s\ncomplex apps contain many vulnerabilities. You should expect unwanted persons to\neventually get their hands on the ServiceAccount\u2019s authentication token, so you should\nalways constrain the ServiceAccount to prevent them from doing any real damage.\n12.3\nSummary\nThis chapter has given you a foundation on how to secure the Kubernetes API server.\nYou learned the following:\n\uf0a1Clients of the API server include both human users and applications running\nin pods.\n\uf0a1Applications in pods are associated with a ServiceAccount. \n\uf0a1Both users and ServiceAccounts are associated with groups.\n \n"}, {"color": "green", "id": "text_317", "label": "374\nCHAPTER 12\nSecuring the Kubernetes API server\n\uf0a1By default, pods run under the default ServiceAccount, which is created for\neach namespace automatically.\n\uf0a1Additional ServiceAccounts can be created manually and associated with a pod.\n\uf0a1ServiceAccounts can be configured to allow mounting only a constrained list of\nSecrets in a given pod.\n\uf0a1A ServiceAccount can also be used to attach image pull Secrets to pods, so you\ndon\u2019t need to specify the Secrets in every pod.\n\uf0a1Roles and ClusterRoles define what actions can be performed on which resources.\n\uf0a1RoleBindings and ClusterRoleBindings bind Roles and ClusterRoles to users,\ngroups, and ServiceAccounts.\n\uf0a1Each cluster comes with default ClusterRoles and ClusterRoleBindings.\nIn the next chapter, you\u2019ll learn how to protect the cluster nodes from pods and how\nto isolate pods from each other by securing the network.\n \n", "shape": "dot", "size": 10, "title": "374\nCHAPTER 12\nSecuring the Kubernetes API server\n\uf0a1By default, pods run under the default ServiceAccount, which is created for\neach namespace automatically.\n\uf0a1Additional ServiceAccounts can be created manually and associated with a pod.\n\uf0a1ServiceAccounts can be configured to allow mounting only a constrained list of\nSecrets in a given pod.\n\uf0a1A ServiceAccount can also be used to attach image pull Secrets to pods, so you\ndon\u2019t need to specify the Secrets in every pod.\n\uf0a1Roles and ClusterRoles define what actions can be performed on which resources.\n\uf0a1RoleBindings and ClusterRoleBindings bind Roles and ClusterRoles to users,\ngroups, and ServiceAccounts.\n\uf0a1Each cluster comes with default ClusterRoles and ClusterRoleBindings.\nIn the next chapter, you\u2019ll learn how to protect the cluster nodes from pods and how\nto isolate pods from each other by securing the network.\n \n"}, {"color": "green", "id": "text_318", "label": "375\nSecuring cluster nodes\nand the network\nIn the previous chapter, we talked about securing the API server. If an attacker\ngets access to the API server, they can run whatever they like by packaging their\ncode into a container image and running it in a pod. But can they do any real\ndamage? Aren\u2019t containers isolated from other containers and from the node\nthey\u2019re running on? \n Not necessarily. In this chapter, you\u2019ll learn how to allow pods to access the\nresources of the node they\u2019re running on. You\u2019ll also learn how to configure the\ncluster so users aren\u2019t able to do whatever they want with their pods. Then, in\nThis chapter covers\n\uf0a1Using the node\u2019s default Linux namespaces \nin pods\n\uf0a1Running containers as different users\n\uf0a1Running privileged containers\n\uf0a1Adding or dropping a container\u2019s kernel \ncapabilities\n\uf0a1Defining security policies to limit what pods can do\n\uf0a1Securing the pod network\n \n", "shape": "dot", "size": 10, "title": "375\nSecuring cluster nodes\nand the network\nIn the previous chapter, we talked about securing the API server. If an attacker\ngets access to the API server, they can run whatever they like by packaging their\ncode into a container image and running it in a pod. But can they do any real\ndamage? Aren\u2019t containers isolated from other containers and from the node\nthey\u2019re running on? \n Not necessarily. In this chapter, you\u2019ll learn how to allow pods to access the\nresources of the node they\u2019re running on. You\u2019ll also learn how to configure the\ncluster so users aren\u2019t able to do whatever they want with their pods. Then, in\nThis chapter covers\n\uf0a1Using the node\u2019s default Linux namespaces \nin pods\n\uf0a1Running containers as different users\n\uf0a1Running privileged containers\n\uf0a1Adding or dropping a container\u2019s kernel \ncapabilities\n\uf0a1Defining security policies to limit what pods can do\n\uf0a1Securing the pod network\n \n"}, {"color": "green", "id": "text_319", "label": "376\nCHAPTER 13\nSecuring cluster nodes and the network\nthe last part of the chapter, you\u2019ll also learn how to secure the network the pods use\nto communicate.\n13.1\nUsing the host node\u2019s namespaces in a pod\nContainers in a pod usually run under separate Linux namespaces, which isolate\ntheir processes from processes running in other containers or in the node\u2019s default\nnamespaces. \n For example, we learned that each pod gets its own IP and port space, because it\nuses its own network namespace. Likewise, each pod has its own process tree, because\nit has its own PID namespace, and it also uses its own IPC namespace, allowing only\nprocesses in the same pod to communicate with each other through the Inter-Process\nCommunication mechanism (IPC).\n13.1.1 Using the node\u2019s network namespace in a pod\nCertain pods (usually system pods) need to operate in the host\u2019s default namespaces,\nallowing them to see and manipulate node-level resources and devices. For example, a\npod may need to use the node\u2019s network adapters instead of its own virtual network\nadapters. This can be achieved by setting the hostNetwork property in the pod spec\nto true.\n In that case, the pod gets to use the node\u2019s network interfaces instead of having its\nown set, as shown in figure 13.1. This means the pod doesn\u2019t get its own IP address and\nif it runs a process that binds to a port, the process will be bound to the node\u2019s port.\nYou can try running such a pod. The next listing shows an example pod manifest.\napiVersion: v1\nkind: Pod\nmetadata:\n  name: pod-with-host-network\nListing 13.1\nA pod using the node\u2019s network namespace: pod-with-host-network.yaml\nNode\nPod A\nPod\u2019s own network\nnamespace\neth0\nlo\neth0\ndocker0\nlo\neth1\nNode\u2019s default network\nnamespace\nPod B\nhostNetwork: true\nFigure 13.1\nA pod \nwith hostNetwork: \ntrue uses the node\u2019s \nnetwork interfaces \ninstead of its own.\n \n", "shape": "dot", "size": 10, "title": "376\nCHAPTER 13\nSecuring cluster nodes and the network\nthe last part of the chapter, you\u2019ll also learn how to secure the network the pods use\nto communicate.\n13.1\nUsing the host node\u2019s namespaces in a pod\nContainers in a pod usually run under separate Linux namespaces, which isolate\ntheir processes from processes running in other containers or in the node\u2019s default\nnamespaces. \n For example, we learned that each pod gets its own IP and port space, because it\nuses its own network namespace. Likewise, each pod has its own process tree, because\nit has its own PID namespace, and it also uses its own IPC namespace, allowing only\nprocesses in the same pod to communicate with each other through the Inter-Process\nCommunication mechanism (IPC).\n13.1.1 Using the node\u2019s network namespace in a pod\nCertain pods (usually system pods) need to operate in the host\u2019s default namespaces,\nallowing them to see and manipulate node-level resources and devices. For example, a\npod may need to use the node\u2019s network adapters instead of its own virtual network\nadapters. This can be achieved by setting the hostNetwork property in the pod spec\nto true.\n In that case, the pod gets to use the node\u2019s network interfaces instead of having its\nown set, as shown in figure 13.1. This means the pod doesn\u2019t get its own IP address and\nif it runs a process that binds to a port, the process will be bound to the node\u2019s port.\nYou can try running such a pod. The next listing shows an example pod manifest.\napiVersion: v1\nkind: Pod\nmetadata:\n  name: pod-with-host-network\nListing 13.1\nA pod using the node\u2019s network namespace: pod-with-host-network.yaml\nNode\nPod A\nPod\u2019s own network\nnamespace\neth0\nlo\neth0\ndocker0\nlo\neth1\nNode\u2019s default network\nnamespace\nPod B\nhostNetwork: true\nFigure 13.1\nA pod \nwith hostNetwork: \ntrue uses the node\u2019s \nnetwork interfaces \ninstead of its own.\n \n"}, {"color": "green", "id": "text_320", "label": "377\nUsing the host node\u2019s namespaces in a pod\nspec:\n  hostNetwork: true              \n  containers:\n  - name: main\n    image: alpine\n    command: [\"/bin/sleep\", \"999999\"]\nAfter you run the pod, you can use the following command to see that it\u2019s indeed using\nthe host\u2019s network namespace (it sees all the host\u2019s network adapters, for example).\n$ kubectl exec pod-with-host-network ifconfig\ndocker0   Link encap:Ethernet  HWaddr 02:42:14:08:23:47\n          inet addr:172.17.0.1  Bcast:0.0.0.0  Mask:255.255.0.0\n          ...\neth0      Link encap:Ethernet  HWaddr 08:00:27:F8:FA:4E\n          inet addr:10.0.2.15  Bcast:10.0.2.255  Mask:255.255.255.0\n          ...\nlo        Link encap:Local Loopback\n          inet addr:127.0.0.1  Mask:255.0.0.0\n          ...\nveth1178d4f Link encap:Ethernet  HWaddr 1E:03:8D:D6:E1:2C\n          inet6 addr: fe80::1c03:8dff:fed6:e12c/64 Scope:Link\n          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1\n...\nWhen the Kubernetes Control Plane components are deployed as pods (such as when\nyou deploy your cluster with kubeadm, as explained in appendix B), you\u2019ll find that\nthose pods use the hostNetwork option, effectively making them behave as if they\nweren\u2019t running inside a pod.\n13.1.2 Binding to a host port without using the host\u2019s network \nnamespace\nA related feature allows pods to bind to a port in the node\u2019s default namespace, but\nstill have their own network namespace. This is done by using the hostPort property\nin one of the container\u2019s ports defined in the spec.containers.ports field.\n Don\u2019t confuse pods using hostPort with pods exposed through a NodePort service.\nThey\u2019re two different things, as explained in figure 13.2.\n The first thing you\u2019ll notice in the figure is that when a pod is using a hostPort, a\nconnection to the node\u2019s port is forwarded directly to the pod running on that node,\nwhereas with a NodePort service, a connection to the node\u2019s port is forwarded to a\nrandomly selected pod (possibly on another node). The other difference is that with\npods using a hostPort, the node\u2019s port is only bound on nodes that run such pods,\nwhereas NodePort services bind the port on all nodes, even on those that don\u2019t run\nsuch a pod (as on node 3 in the figure).\nListing 13.2\nNetwork interfaces in a pod using the host\u2019s network namespace\nUsing the host node\u2019s \nnetwork namespace\n \n", "shape": "dot", "size": 10, "title": "377\nUsing the host node\u2019s namespaces in a pod\nspec:\n  hostNetwork: true              \n  containers:\n  - name: main\n    image: alpine\n    command: [\"/bin/sleep\", \"999999\"]\nAfter you run the pod, you can use the following command to see that it\u2019s indeed using\nthe host\u2019s network namespace (it sees all the host\u2019s network adapters, for example).\n$ kubectl exec pod-with-host-network ifconfig\ndocker0   Link encap:Ethernet  HWaddr 02:42:14:08:23:47\n          inet addr:172.17.0.1  Bcast:0.0.0.0  Mask:255.255.0.0\n          ...\neth0      Link encap:Ethernet  HWaddr 08:00:27:F8:FA:4E\n          inet addr:10.0.2.15  Bcast:10.0.2.255  Mask:255.255.255.0\n          ...\nlo        Link encap:Local Loopback\n          inet addr:127.0.0.1  Mask:255.0.0.0\n          ...\nveth1178d4f Link encap:Ethernet  HWaddr 1E:03:8D:D6:E1:2C\n          inet6 addr: fe80::1c03:8dff:fed6:e12c/64 Scope:Link\n          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1\n...\nWhen the Kubernetes Control Plane components are deployed as pods (such as when\nyou deploy your cluster with kubeadm, as explained in appendix B), you\u2019ll find that\nthose pods use the hostNetwork option, effectively making them behave as if they\nweren\u2019t running inside a pod.\n13.1.2 Binding to a host port without using the host\u2019s network \nnamespace\nA related feature allows pods to bind to a port in the node\u2019s default namespace, but\nstill have their own network namespace. This is done by using the hostPort property\nin one of the container\u2019s ports defined in the spec.containers.ports field.\n Don\u2019t confuse pods using hostPort with pods exposed through a NodePort service.\nThey\u2019re two different things, as explained in figure 13.2.\n The first thing you\u2019ll notice in the figure is that when a pod is using a hostPort, a\nconnection to the node\u2019s port is forwarded directly to the pod running on that node,\nwhereas with a NodePort service, a connection to the node\u2019s port is forwarded to a\nrandomly selected pod (possibly on another node). The other difference is that with\npods using a hostPort, the node\u2019s port is only bound on nodes that run such pods,\nwhereas NodePort services bind the port on all nodes, even on those that don\u2019t run\nsuch a pod (as on node 3 in the figure).\nListing 13.2\nNetwork interfaces in a pod using the host\u2019s network namespace\nUsing the host node\u2019s \nnetwork namespace\n \n"}, {"color": "green", "id": "text_321", "label": "378\nCHAPTER 13\nSecuring cluster nodes and the network\nIt\u2019s important to understand that if a pod is using a specific host port, only one\ninstance of the pod can be scheduled to each node, because two processes can\u2019t bind\nto the same host port. The Scheduler takes this into account when scheduling pods, so\nit doesn\u2019t schedule multiple pods to the same node, as shown in figure 13.3. If you\nhave three nodes and want to deploy four pod replicas, only three will be scheduled\n(one pod will remain Pending).\nNode 1\nPod 1\nTwo pods using\nhostPort\nPort\n8080\nPort\n9000\nNode 2\nPod 2\nPort\n8080\nPort\n9000\nNode 3\nNode 1\nPod 1\nTwo pods under\nthe same\nNodePort\nservice\nPort\n8080\nNode 2\nPod 2\nPort\n8080\nNode 3\nPort\n88\nPort\n88\nPort\n88\nService\n(\n)\niptables\nService\n(\n)\niptables\nService\n(\n)\niptables\nFigure 13.2\nDifference between pods using a hostPort and pods behind a NodePort service.\nNode 1\nPod 1\nPort\n8080\nHost\nport\n9000\nHost\nport\n9000\nPod 2\nPort\n8080\nNode 2\nPod 3\nPort\n8080\nHost\nport\n9000\nNode 3\nPod 4\nPort\n8080\nCannot be scheduled to the same\nnode, because the port is already bound\nOnly a single\nreplica per node\nFigure 13.3\nIf a host port is used, only a single pod instance can be scheduled to a node.\n \n", "shape": "dot", "size": 10, "title": "378\nCHAPTER 13\nSecuring cluster nodes and the network\nIt\u2019s important to understand that if a pod is using a specific host port, only one\ninstance of the pod can be scheduled to each node, because two processes can\u2019t bind\nto the same host port. The Scheduler takes this into account when scheduling pods, so\nit doesn\u2019t schedule multiple pods to the same node, as shown in figure 13.3. If you\nhave three nodes and want to deploy four pod replicas, only three will be scheduled\n(one pod will remain Pending).\nNode 1\nPod 1\nTwo pods using\nhostPort\nPort\n8080\nPort\n9000\nNode 2\nPod 2\nPort\n8080\nPort\n9000\nNode 3\nNode 1\nPod 1\nTwo pods under\nthe same\nNodePort\nservice\nPort\n8080\nNode 2\nPod 2\nPort\n8080\nNode 3\nPort\n88\nPort\n88\nPort\n88\nService\n(\n)\niptables\nService\n(\n)\niptables\nService\n(\n)\niptables\nFigure 13.2\nDifference between pods using a hostPort and pods behind a NodePort service.\nNode 1\nPod 1\nPort\n8080\nHost\nport\n9000\nHost\nport\n9000\nPod 2\nPort\n8080\nNode 2\nPod 3\nPort\n8080\nHost\nport\n9000\nNode 3\nPod 4\nPort\n8080\nCannot be scheduled to the same\nnode, because the port is already bound\nOnly a single\nreplica per node\nFigure 13.3\nIf a host port is used, only a single pod instance can be scheduled to a node.\n \n"}, {"color": "green", "id": "text_322", "label": "379\nUsing the host node\u2019s namespaces in a pod\nLet\u2019s see how to define the hostPort in a pod\u2019s YAML definition. The following listing\nshows the YAML to run your kubia pod and bind it to the node\u2019s port 9000.\napiVersion: v1\nkind: Pod\nmetadata:\n  name: kubia-hostport\nspec:\n  containers:\n  - image: luksa/kubia\n    name: kubia\n    ports:\n    - containerPort: 8080    \n      hostPort: 9000        \n      protocol: TCP\nAfter you create this pod, you can access it through port 9000 of the node it\u2019s sched-\nuled to. If you have multiple nodes, you\u2019ll see you can\u2019t access the pod through that\nport on the other nodes. \nNOTE\nIf you\u2019re trying this on GKE, you need to configure the firewall prop-\nerly using gcloud compute firewall-rules, the way you did in chapter 5.\nThe hostPort feature is primarily used for exposing system services, which are\ndeployed to every node using DaemonSets. Initially, people also used it to ensure two\nreplicas of the same pod were never scheduled to the same node, but now you have a\nbetter way of achieving this\u2014it\u2019s explained in chapter 16.\n13.1.3 Using the node\u2019s PID and IPC namespaces\nSimilar to the hostNetwork option are the hostPID and hostIPC pod spec properties.\nWhen you set them to true, the pod\u2019s containers will use the node\u2019s PID and IPC\nnamespaces, allowing processes running in the containers to see all the other pro-\ncesses on the node or communicate with them through IPC, respectively. See the fol-\nlowing listing for an example.\napiVersion: v1\nkind: Pod\nmetadata:\n  name: pod-with-host-pid-and-ipc\nspec:\n  hostPID: true                    \n  hostIPC: true                     \n  containers:\n  - name: main\n    image: alpine\n    command: [\"/bin/sleep\", \"999999\"]\nListing 13.3\nBinding a pod to a port in the node\u2019s port space: kubia-hostport.yaml\nListing 13.4\nUsing the host\u2019s PID and IPC namespaces: pod-with-host-pid-and-ipc.yaml\nThe container can be \nreached on port 8080 \nof the pod\u2019s IP.\nIt can also be reached \non port 9000 of the \nnode it\u2019s deployed on.\nYou want the pod to \nuse the host\u2019s PID \nnamespace.\nYou also want the \npod to use the host\u2019s \nIPC namespace.\n \n", "shape": "dot", "size": 10, "title": "379\nUsing the host node\u2019s namespaces in a pod\nLet\u2019s see how to define the hostPort in a pod\u2019s YAML definition. The following listing\nshows the YAML to run your kubia pod and bind it to the node\u2019s port 9000.\napiVersion: v1\nkind: Pod\nmetadata:\n  name: kubia-hostport\nspec:\n  containers:\n  - image: luksa/kubia\n    name: kubia\n    ports:\n    - containerPort: 8080    \n      hostPort: 9000        \n      protocol: TCP\nAfter you create this pod, you can access it through port 9000 of the node it\u2019s sched-\nuled to. If you have multiple nodes, you\u2019ll see you can\u2019t access the pod through that\nport on the other nodes. \nNOTE\nIf you\u2019re trying this on GKE, you need to configure the firewall prop-\nerly using gcloud compute firewall-rules, the way you did in chapter 5.\nThe hostPort feature is primarily used for exposing system services, which are\ndeployed to every node using DaemonSets. Initially, people also used it to ensure two\nreplicas of the same pod were never scheduled to the same node, but now you have a\nbetter way of achieving this\u2014it\u2019s explained in chapter 16.\n13.1.3 Using the node\u2019s PID and IPC namespaces\nSimilar to the hostNetwork option are the hostPID and hostIPC pod spec properties.\nWhen you set them to true, the pod\u2019s containers will use the node\u2019s PID and IPC\nnamespaces, allowing processes running in the containers to see all the other pro-\ncesses on the node or communicate with them through IPC, respectively. See the fol-\nlowing listing for an example.\napiVersion: v1\nkind: Pod\nmetadata:\n  name: pod-with-host-pid-and-ipc\nspec:\n  hostPID: true                    \n  hostIPC: true                     \n  containers:\n  - name: main\n    image: alpine\n    command: [\"/bin/sleep\", \"999999\"]\nListing 13.3\nBinding a pod to a port in the node\u2019s port space: kubia-hostport.yaml\nListing 13.4\nUsing the host\u2019s PID and IPC namespaces: pod-with-host-pid-and-ipc.yaml\nThe container can be \nreached on port 8080 \nof the pod\u2019s IP.\nIt can also be reached \non port 9000 of the \nnode it\u2019s deployed on.\nYou want the pod to \nuse the host\u2019s PID \nnamespace.\nYou also want the \npod to use the host\u2019s \nIPC namespace.\n \n"}, {"color": "green", "id": "text_323", "label": "380\nCHAPTER 13\nSecuring cluster nodes and the network\nYou\u2019ll remember that pods usually see only their own processes, but if you run this pod\nand then list the processes from within its container, you\u2019ll see all the processes run-\nning on the host node, not only the ones running in the container, as shown in the\nfollowing listing.\n$ kubectl exec pod-with-host-pid-and-ipc ps aux\nPID   USER     TIME   COMMAND\n    1 root       0:01 /usr/lib/systemd/systemd --switched-root --system ...\n    2 root       0:00 [kthreadd]\n    3 root       0:00 [ksoftirqd/0]\n    5 root       0:00 [kworker/0:0H]\n    6 root       0:00 [kworker/u2:0]\n    7 root       0:00 [migration/0]\n    8 root       0:00 [rcu_bh]\n    9 root       0:00 [rcu_sched]\n   10 root       0:00 [watchdog/0]\n...\nBy setting the hostIPC property to true, processes in the pod\u2019s containers can also\ncommunicate with all the other processes running on the node, through Inter-Process\nCommunication.\n13.2\nConfiguring the container\u2019s security context\nBesides allowing the pod to use the host\u2019s Linux namespaces, other security-related\nfeatures can also be configured on the pod and its container through the security-\nContext properties, which can be specified under the pod spec directly and inside the\nspec of individual containers.\nUNDERSTANDING WHAT\u2019S CONFIGURABLE IN THE SECURITY CONTEXT\nConfiguring the security context allows you to do various things:\n\uf0a1Specify the user (the user\u2019s ID) under which the process in the container will run.\n\uf0a1Prevent the container from running as root (the default user a container runs\nas is usually defined in the container image itself, so you may want to prevent\ncontainers from running as root).\n\uf0a1Run the container in privileged mode, giving it full access to the node\u2019s kernel.\n\uf0a1Configure fine-grained privileges, by adding or dropping capabilities\u2014in con-\ntrast to giving the container all possible permissions by running it in privi-\nleged mode.\n\uf0a1Set SELinux (Security Enhanced Linux) options to strongly lock down a\ncontainer.\n\uf0a1Prevent the process from writing to the container\u2019s filesystem.\nWe\u2019ll explore these options next. \nListing 13.5\nProcesses visible in a pod with hostPID: true\n \n", "shape": "dot", "size": 10, "title": "380\nCHAPTER 13\nSecuring cluster nodes and the network\nYou\u2019ll remember that pods usually see only their own processes, but if you run this pod\nand then list the processes from within its container, you\u2019ll see all the processes run-\nning on the host node, not only the ones running in the container, as shown in the\nfollowing listing.\n$ kubectl exec pod-with-host-pid-and-ipc ps aux\nPID   USER     TIME   COMMAND\n    1 root       0:01 /usr/lib/systemd/systemd --switched-root --system ...\n    2 root       0:00 [kthreadd]\n    3 root       0:00 [ksoftirqd/0]\n    5 root       0:00 [kworker/0:0H]\n    6 root       0:00 [kworker/u2:0]\n    7 root       0:00 [migration/0]\n    8 root       0:00 [rcu_bh]\n    9 root       0:00 [rcu_sched]\n   10 root       0:00 [watchdog/0]\n...\nBy setting the hostIPC property to true, processes in the pod\u2019s containers can also\ncommunicate with all the other processes running on the node, through Inter-Process\nCommunication.\n13.2\nConfiguring the container\u2019s security context\nBesides allowing the pod to use the host\u2019s Linux namespaces, other security-related\nfeatures can also be configured on the pod and its container through the security-\nContext properties, which can be specified under the pod spec directly and inside the\nspec of individual containers.\nUNDERSTANDING WHAT\u2019S CONFIGURABLE IN THE SECURITY CONTEXT\nConfiguring the security context allows you to do various things:\n\uf0a1Specify the user (the user\u2019s ID) under which the process in the container will run.\n\uf0a1Prevent the container from running as root (the default user a container runs\nas is usually defined in the container image itself, so you may want to prevent\ncontainers from running as root).\n\uf0a1Run the container in privileged mode, giving it full access to the node\u2019s kernel.\n\uf0a1Configure fine-grained privileges, by adding or dropping capabilities\u2014in con-\ntrast to giving the container all possible permissions by running it in privi-\nleged mode.\n\uf0a1Set SELinux (Security Enhanced Linux) options to strongly lock down a\ncontainer.\n\uf0a1Prevent the process from writing to the container\u2019s filesystem.\nWe\u2019ll explore these options next. \nListing 13.5\nProcesses visible in a pod with hostPID: true\n \n"}, {"color": "green", "id": "text_324", "label": "381\nConfiguring the container\u2019s security context\nRUNNING A POD WITHOUT SPECIFYING A SECURITY CONTEXT\nFirst, run a pod with the default security context options (by not specifying them at\nall), so you can see how it behaves compared to pods with a custom security context:\n$ kubectl run pod-with-defaults --image alpine --restart Never \n\u27a5  -- /bin/sleep 999999\npod \"pod-with-defaults\" created\nLet\u2019s see what user and group ID the container is running as, and which groups it\nbelongs to. You can see this by running the id command inside the container:\n$ kubectl exec pod-with-defaults id\nuid=0(root) gid=0(root) groups=0(root), 1(bin), 2(daemon), 3(sys), 4(adm), \n6(disk), 10(wheel), 11(floppy), 20(dialout), 26(tape), 27(video)\nThe container is running as user ID (uid) 0, which is root, and group ID (gid) 0 (also\nroot). It\u2019s also a member of multiple other groups. \nNOTE\nWhat user the container runs as is specified in the container image. In\na Dockerfile, this is done using the USER directive. If omitted, the container\nruns as root.\nNow, you\u2019ll run a pod where the container runs as a different user.\n13.2.1 Running a container as a specific user\nTo run a pod under a different user ID than the one that\u2019s baked into the container\nimage, you\u2019ll need to set the pod\u2019s securityContext.runAsUser property. You\u2019ll\nmake the container run as user guest, whose user ID in the alpine container image is\n405, as shown in the following listing.\napiVersion: v1\nkind: Pod\nmetadata:\n  name: pod-as-user-guest\nspec:\n  containers:\n  - name: main\n    image: alpine\n    command: [\"/bin/sleep\", \"999999\"]\n    securityContext:\n      runAsUser: 405      \nNow, to see the effect of the runAsUser property, run the id command in this new\npod, the way you did before:\n$ kubectl exec pod-as-user-guest id\nuid=405(guest) gid=100(users)\nListing 13.6\nRunning containers as a specific user: pod-as-user-guest.yaml\nYou need to specify a user ID, not \na username (id 405 corresponds \nto the guest user).\n \n", "shape": "dot", "size": 10, "title": "381\nConfiguring the container\u2019s security context\nRUNNING A POD WITHOUT SPECIFYING A SECURITY CONTEXT\nFirst, run a pod with the default security context options (by not specifying them at\nall), so you can see how it behaves compared to pods with a custom security context:\n$ kubectl run pod-with-defaults --image alpine --restart Never \n\u27a5  -- /bin/sleep 999999\npod \"pod-with-defaults\" created\nLet\u2019s see what user and group ID the container is running as, and which groups it\nbelongs to. You can see this by running the id command inside the container:\n$ kubectl exec pod-with-defaults id\nuid=0(root) gid=0(root) groups=0(root), 1(bin), 2(daemon), 3(sys), 4(adm), \n6(disk), 10(wheel), 11(floppy), 20(dialout), 26(tape), 27(video)\nThe container is running as user ID (uid) 0, which is root, and group ID (gid) 0 (also\nroot). It\u2019s also a member of multiple other groups. \nNOTE\nWhat user the container runs as is specified in the container image. In\na Dockerfile, this is done using the USER directive. If omitted, the container\nruns as root.\nNow, you\u2019ll run a pod where the container runs as a different user.\n13.2.1 Running a container as a specific user\nTo run a pod under a different user ID than the one that\u2019s baked into the container\nimage, you\u2019ll need to set the pod\u2019s securityContext.runAsUser property. You\u2019ll\nmake the container run as user guest, whose user ID in the alpine container image is\n405, as shown in the following listing.\napiVersion: v1\nkind: Pod\nmetadata:\n  name: pod-as-user-guest\nspec:\n  containers:\n  - name: main\n    image: alpine\n    command: [\"/bin/sleep\", \"999999\"]\n    securityContext:\n      runAsUser: 405      \nNow, to see the effect of the runAsUser property, run the id command in this new\npod, the way you did before:\n$ kubectl exec pod-as-user-guest id\nuid=405(guest) gid=100(users)\nListing 13.6\nRunning containers as a specific user: pod-as-user-guest.yaml\nYou need to specify a user ID, not \na username (id 405 corresponds \nto the guest user).\n \n"}, {"color": "green", "id": "text_325", "label": "382\nCHAPTER 13\nSecuring cluster nodes and the network\nAs requested, the container is running as the guest user. \n13.2.2 Preventing a container from running as root\nWhat if you don\u2019t care what user the container runs as, but you still want to prevent it\nfrom running as root? \n Imagine having a pod deployed with a container image that was built with a USER\ndaemon directive in the Dockerfile, which makes the container run under the daemon\nuser. What if an attacker gets access to your image registry and pushes a different\nimage under the same tag? The attacker\u2019s image is configured to run as the root user.\nWhen Kubernetes schedules a new instance of your pod, the Kubelet will download\nthe attacker\u2019s image and run whatever code they put into it. \n Although containers are mostly isolated from the host system, running their pro-\ncesses as root is still considered a bad practice. For example, when a host directory is\nmounted into the container, if the process running in the container is running as\nroot, it has full access to the mounted directory, whereas if it\u2019s running as non-root,\nit won\u2019t. \n To prevent the attack scenario described previously, you can specify that the pod\u2019s\ncontainer needs to run as a non-root user, as shown in the following listing.\napiVersion: v1\nkind: Pod\nmetadata:\n  name: pod-run-as-non-root\nspec:\n  containers:\n  - name: main\n    image: alpine\n    command: [\"/bin/sleep\", \"999999\"]\n    securityContext:                   \n      runAsNonRoot: true               \nIf you deploy this pod, it gets scheduled, but is not allowed to run:\n$ kubectl get po pod-run-as-non-root\nNAME                 READY  STATUS                                                  \npod-run-as-non-root  0/1    container has runAsNonRoot and image will run \n                            \u27a5  as root\nNow, if anyone tampers with your container images, they won\u2019t get far.\n13.2.3 Running pods in privileged mode\nSometimes pods need to do everything that the node they\u2019re running on can do, such\nas use protected system devices or other kernel features, which aren\u2019t accessible to\nregular containers. \nListing 13.7\nPreventing containers from running as root: pod-run-as-non-root.yaml\nThis container will only \nbe allowed to run as a \nnon-root user.\n \n", "shape": "dot", "size": 10, "title": "382\nCHAPTER 13\nSecuring cluster nodes and the network\nAs requested, the container is running as the guest user. \n13.2.2 Preventing a container from running as root\nWhat if you don\u2019t care what user the container runs as, but you still want to prevent it\nfrom running as root? \n Imagine having a pod deployed with a container image that was built with a USER\ndaemon directive in the Dockerfile, which makes the container run under the daemon\nuser. What if an attacker gets access to your image registry and pushes a different\nimage under the same tag? The attacker\u2019s image is configured to run as the root user.\nWhen Kubernetes schedules a new instance of your pod, the Kubelet will download\nthe attacker\u2019s image and run whatever code they put into it. \n Although containers are mostly isolated from the host system, running their pro-\ncesses as root is still considered a bad practice. For example, when a host directory is\nmounted into the container, if the process running in the container is running as\nroot, it has full access to the mounted directory, whereas if it\u2019s running as non-root,\nit won\u2019t. \n To prevent the attack scenario described previously, you can specify that the pod\u2019s\ncontainer needs to run as a non-root user, as shown in the following listing.\napiVersion: v1\nkind: Pod\nmetadata:\n  name: pod-run-as-non-root\nspec:\n  containers:\n  - name: main\n    image: alpine\n    command: [\"/bin/sleep\", \"999999\"]\n    securityContext:                   \n      runAsNonRoot: true               \nIf you deploy this pod, it gets scheduled, but is not allowed to run:\n$ kubectl get po pod-run-as-non-root\nNAME                 READY  STATUS                                                  \npod-run-as-non-root  0/1    container has runAsNonRoot and image will run \n                            \u27a5  as root\nNow, if anyone tampers with your container images, they won\u2019t get far.\n13.2.3 Running pods in privileged mode\nSometimes pods need to do everything that the node they\u2019re running on can do, such\nas use protected system devices or other kernel features, which aren\u2019t accessible to\nregular containers. \nListing 13.7\nPreventing containers from running as root: pod-run-as-non-root.yaml\nThis container will only \nbe allowed to run as a \nnon-root user.\n \n"}, {"color": "green", "id": "text_326", "label": "383\nConfiguring the container\u2019s security context\n An example of such a pod is the kube-proxy pod, which needs to modify the node\u2019s\niptables rules to make services work, as was explained in chapter 11. If you follow the\ninstructions in appendix B and deploy a cluster with kubeadm, you\u2019ll see every cluster\nnode runs a kube-proxy pod and you can examine its YAML specification to see all the\nspecial features it\u2019s using. \n To get full access to the node\u2019s kernel, the pod\u2019s container runs in privileged\nmode. This is achieved by setting the privileged property in the container\u2019s security-\nContext property to true. You\u2019ll create a privileged pod from the YAML in the follow-\ning listing.\napiVersion: v1\nkind: Pod\nmetadata:\n  name: pod-privileged\nspec:\n  containers:\n  - name: main\n    image: alpine\n    command: [\"/bin/sleep\", \"999999\"]\n    securityContext:\n      privileged: true     \nGo ahead and deploy this pod, so you can compare it with the non-privileged pod you\nran earlier. \n If you\u2019re familiar with Linux, you may know it has a special file directory called /dev,\nwhich contains device files for all the devices on the system. These aren\u2019t regular files on\ndisk, but are special files used to communicate with devices. Let\u2019s see what devices are\nvisible in the non-privileged container you deployed earlier (the pod-with-defaults\npod), by listing files in its /dev directory, as shown in the following listing.\n$ kubectl exec -it pod-with-defaults ls /dev\ncore             null             stderr           urandom\nfd               ptmx             stdin            zero\nfull             pts              stdout\nfuse             random           termination-log\nmqueue           shm              tty\nThe listing shows all the devices. The list is fairly short. Now, compare this with the fol-\nlowing listing, which shows the device files your privileged pod can see.\n$ kubectl exec -it pod-privileged ls /dev\nautofs              snd                 tty46\nbsg                 sr0                 tty47\nListing 13.8\nA pod with a privileged container: pod-privileged.yaml\nListing 13.9\nList of available devices in a non-privileged pod\nListing 13.10\nList of available devices in a privileged pod\nThis container will \nrun in privileged \nmode\n \n", "shape": "dot", "size": 10, "title": "383\nConfiguring the container\u2019s security context\n An example of such a pod is the kube-proxy pod, which needs to modify the node\u2019s\niptables rules to make services work, as was explained in chapter 11. If you follow the\ninstructions in appendix B and deploy a cluster with kubeadm, you\u2019ll see every cluster\nnode runs a kube-proxy pod and you can examine its YAML specification to see all the\nspecial features it\u2019s using. \n To get full access to the node\u2019s kernel, the pod\u2019s container runs in privileged\nmode. This is achieved by setting the privileged property in the container\u2019s security-\nContext property to true. You\u2019ll create a privileged pod from the YAML in the follow-\ning listing.\napiVersion: v1\nkind: Pod\nmetadata:\n  name: pod-privileged\nspec:\n  containers:\n  - name: main\n    image: alpine\n    command: [\"/bin/sleep\", \"999999\"]\n    securityContext:\n      privileged: true     \nGo ahead and deploy this pod, so you can compare it with the non-privileged pod you\nran earlier. \n If you\u2019re familiar with Linux, you may know it has a special file directory called /dev,\nwhich contains device files for all the devices on the system. These aren\u2019t regular files on\ndisk, but are special files used to communicate with devices. Let\u2019s see what devices are\nvisible in the non-privileged container you deployed earlier (the pod-with-defaults\npod), by listing files in its /dev directory, as shown in the following listing.\n$ kubectl exec -it pod-with-defaults ls /dev\ncore             null             stderr           urandom\nfd               ptmx             stdin            zero\nfull             pts              stdout\nfuse             random           termination-log\nmqueue           shm              tty\nThe listing shows all the devices. The list is fairly short. Now, compare this with the fol-\nlowing listing, which shows the device files your privileged pod can see.\n$ kubectl exec -it pod-privileged ls /dev\nautofs              snd                 tty46\nbsg                 sr0                 tty47\nListing 13.8\nA pod with a privileged container: pod-privileged.yaml\nListing 13.9\nList of available devices in a non-privileged pod\nListing 13.10\nList of available devices in a privileged pod\nThis container will \nrun in privileged \nmode\n \n"}, {"color": "green", "id": "text_327", "label": "384\nCHAPTER 13\nSecuring cluster nodes and the network\nbtrfs-control       stderr              tty48\ncore                stdin               tty49\ncpu                 stdout              tty5\ncpu_dma_latency     termination-log     tty50\nfd                  tty                 tty51\nfull                tty0                tty52\nfuse                tty1                tty53\nhpet                tty10               tty54\nhwrng               tty11               tty55\n...                 ...                 ...\nI haven\u2019t included the whole list, because it\u2019s too long for the book, but it\u2019s evident\nthat the device list is much longer than before. In fact, the privileged container sees\nall the host node\u2019s devices. This means it can use any device freely. \n For example, I had to use privileged mode like this when I wanted a pod running\non a Raspberry Pi to control LEDs connected it.\n13.2.4 Adding individual kernel capabilities to a container\nIn the previous section, you saw one way of giving a container unlimited power. In the\nold days, traditional UNIX implementations only distinguished between privileged\nand unprivileged processes, but for many years, Linux has supported a much more\nfine-grained permission system through kernel capabilities.\n Instead of making a container privileged and giving it unlimited permissions, a\nmuch safer method (from a security perspective) is to give it access only to the kernel\nfeatures it really requires. Kubernetes allows you to add capabilities to each container\nor drop part of them, which allows you to fine-tune the container\u2019s permissions and\nlimit the impact of a potential intrusion by an attacker.\n For example, a container usually isn\u2019t allowed to change the system time (the hard-\nware clock\u2019s time). You can confirm this by trying to set the time in your pod-with-\ndefaults pod:\n$ kubectl exec -it pod-with-defaults -- date +%T -s \"12:00:00\"\ndate: can\u0027t set date: Operation not permitted\nIf you want to allow the container to change the system time, you can add a capabil-\nity called CAP_SYS_TIME to the container\u2019s capabilities list, as shown in the follow-\ning listing.\napiVersion: v1\nkind: Pod\nmetadata:\n  name: pod-add-settime-capability\nspec:\n  containers:\n  - name: main\n    image: alpine\nListing 13.11\nAdding the CAP_SYS_TIME capability: pod-add-settime-capability.yaml\n \n", "shape": "dot", "size": 10, "title": "384\nCHAPTER 13\nSecuring cluster nodes and the network\nbtrfs-control       stderr              tty48\ncore                stdin               tty49\ncpu                 stdout              tty5\ncpu_dma_latency     termination-log     tty50\nfd                  tty                 tty51\nfull                tty0                tty52\nfuse                tty1                tty53\nhpet                tty10               tty54\nhwrng               tty11               tty55\n...                 ...                 ...\nI haven\u2019t included the whole list, because it\u2019s too long for the book, but it\u2019s evident\nthat the device list is much longer than before. In fact, the privileged container sees\nall the host node\u2019s devices. This means it can use any device freely. \n For example, I had to use privileged mode like this when I wanted a pod running\non a Raspberry Pi to control LEDs connected it.\n13.2.4 Adding individual kernel capabilities to a container\nIn the previous section, you saw one way of giving a container unlimited power. In the\nold days, traditional UNIX implementations only distinguished between privileged\nand unprivileged processes, but for many years, Linux has supported a much more\nfine-grained permission system through kernel capabilities.\n Instead of making a container privileged and giving it unlimited permissions, a\nmuch safer method (from a security perspective) is to give it access only to the kernel\nfeatures it really requires. Kubernetes allows you to add capabilities to each container\nor drop part of them, which allows you to fine-tune the container\u2019s permissions and\nlimit the impact of a potential intrusion by an attacker.\n For example, a container usually isn\u2019t allowed to change the system time (the hard-\nware clock\u2019s time). You can confirm this by trying to set the time in your pod-with-\ndefaults pod:\n$ kubectl exec -it pod-with-defaults -- date +%T -s \"12:00:00\"\ndate: can\u0027t set date: Operation not permitted\nIf you want to allow the container to change the system time, you can add a capabil-\nity called CAP_SYS_TIME to the container\u2019s capabilities list, as shown in the follow-\ning listing.\napiVersion: v1\nkind: Pod\nmetadata:\n  name: pod-add-settime-capability\nspec:\n  containers:\n  - name: main\n    image: alpine\nListing 13.11\nAdding the CAP_SYS_TIME capability: pod-add-settime-capability.yaml\n \n"}, {"color": "green", "id": "text_328", "label": "385\nConfiguring the container\u2019s security context\n    command: [\"/bin/sleep\", \"999999\"]\n    securityContext:                     \n      capabilities:                      \n        add:                  \n        - SYS_TIME            \nNOTE\nLinux kernel capabilities are usually prefixed with CAP_. But when\nspecifying them in a pod spec, you must leave out the prefix.\nIf you run the same command in this new pod\u2019s container, the system time is changed\nsuccessfully:\n$ kubectl exec -it pod-add-settime-capability -- date +%T -s \"12:00:00\"\n12:00:00\n$ kubectl exec -it pod-add-settime-capability -- date\nSun May  7 12:00:03 UTC 2017\nWARNING\nIf you try this yourself, be aware that it may cause your worker\nnode to become unusable. In Minikube, although the system time was auto-\nmatically reset back by the Network Time Protocol (NTP) daemon, I had to\nreboot the VM to schedule new pods. \nYou can confirm the node\u2019s time has been changed by checking the time on the node\nrunning the pod. In my case, I\u2019m using Minikube, so I have only one node and I can\nget its time like this:\n$ minikube ssh date\nSun May  7 12:00:07 UTC 2017\nAdding capabilities like this is a much better way than giving a container full privileges\nwith privileged: true. Admittedly, it does require you to know and understand what\neach capability does.\nTIP\nYou\u2019ll find the list of Linux kernel capabilities in the Linux man pages.\n13.2.5 Dropping capabilities from a container\nYou\u2019ve seen how to add capabilities, but you can also drop capabilities that may oth-\nerwise be available to the container. For example, the default capabilities given to a\ncontainer include the CAP_CHOWN capability, which allows processes to change the\nownership of files in the filesystem. \n You can see that\u2019s the case by changing the ownership of the /tmp directory in\nyour pod-with-defaults pod to the guest user, for example:\n$ kubectl exec pod-with-defaults chown guest /tmp\n$ kubectl exec pod-with-defaults -- ls -la / | grep tmp\ndrwxrwxrwt    2 guest    root             6 May 25 15:18 tmp\nCapabilities are added or dropped \nunder the securityContext property.\nYou\u2019re adding the \nSYS_TIME capability.\n \n", "shape": "dot", "size": 10, "title": "385\nConfiguring the container\u2019s security context\n    command: [\"/bin/sleep\", \"999999\"]\n    securityContext:                     \n      capabilities:                      \n        add:                  \n        - SYS_TIME            \nNOTE\nLinux kernel capabilities are usually prefixed with CAP_. But when\nspecifying them in a pod spec, you must leave out the prefix.\nIf you run the same command in this new pod\u2019s container, the system time is changed\nsuccessfully:\n$ kubectl exec -it pod-add-settime-capability -- date +%T -s \"12:00:00\"\n12:00:00\n$ kubectl exec -it pod-add-settime-capability -- date\nSun May  7 12:00:03 UTC 2017\nWARNING\nIf you try this yourself, be aware that it may cause your worker\nnode to become unusable. In Minikube, although the system time was auto-\nmatically reset back by the Network Time Protocol (NTP) daemon, I had to\nreboot the VM to schedule new pods. \nYou can confirm the node\u2019s time has been changed by checking the time on the node\nrunning the pod. In my case, I\u2019m using Minikube, so I have only one node and I can\nget its time like this:\n$ minikube ssh date\nSun May  7 12:00:07 UTC 2017\nAdding capabilities like this is a much better way than giving a container full privileges\nwith privileged: true. Admittedly, it does require you to know and understand what\neach capability does.\nTIP\nYou\u2019ll find the list of Linux kernel capabilities in the Linux man pages.\n13.2.5 Dropping capabilities from a container\nYou\u2019ve seen how to add capabilities, but you can also drop capabilities that may oth-\nerwise be available to the container. For example, the default capabilities given to a\ncontainer include the CAP_CHOWN capability, which allows processes to change the\nownership of files in the filesystem. \n You can see that\u2019s the case by changing the ownership of the /tmp directory in\nyour pod-with-defaults pod to the guest user, for example:\n$ kubectl exec pod-with-defaults chown guest /tmp\n$ kubectl exec pod-with-defaults -- ls -la / | grep tmp\ndrwxrwxrwt    2 guest    root             6 May 25 15:18 tmp\nCapabilities are added or dropped \nunder the securityContext property.\nYou\u2019re adding the \nSYS_TIME capability.\n \n"}, {"color": "green", "id": "text_329", "label": "386\nCHAPTER 13\nSecuring cluster nodes and the network\nTo prevent the container from doing that, you need to drop the capability by listing it\nunder the container\u2019s securityContext.capabilities.drop property, as shown in\nthe following listing.\napiVersion: v1\nkind: Pod\nmetadata:\n  name: pod-drop-chown-capability\nspec:\n  containers:\n  - name: main\n    image: alpine\n    command: [\"/bin/sleep\", \"999999\"]\n    securityContext:\n      capabilities:\n        drop:                   \n        - CHOWN                 \nBy dropping the CHOWN capability, you\u2019re not allowed to change the owner of the /tmp\ndirectory in this pod:\n$ kubectl exec pod-drop-chown-capability chown guest /tmp\nchown: /tmp: Operation not permitted\nYou\u2019re almost done exploring the container\u2019s security context options. Let\u2019s look at\none more.\n13.2.6 Preventing processes from writing to the container\u2019s filesystem\nYou may want to prevent the processes running in the container from writing to the\ncontainer\u2019s filesystem, and only allow them to write to mounted volumes. You\u2019d want\nto do that mostly for security reasons. \n Let\u2019s imagine you\u2019re running a PHP application with a hidden vulnerability, allow-\ning an attacker to write to the filesystem. The PHP files are added to the container\nimage at build time and are served from the container\u2019s filesystem. Because of the vul-\nnerability, the attacker can modify those files and inject them with malicious code. \n These types of attacks can be thwarted by preventing the container from writing to\nits filesystem, where the app\u2019s executable code is normally stored. This is done by set-\nting the container\u2019s securityContext.readOnlyRootFilesystem property to true, as\nshown in the following listing.\napiVersion: v1\nkind: Pod\nmetadata:\n  name: pod-with-readonly-filesystem\nListing 13.12\nDropping a capability from a container: pod-drop-chown-capability.yaml\nListing 13.13\nA container with a read-only filesystem: pod-with-readonly-filesystem.yaml\nYou\u2019re not allowing this container \nto change file ownership.\n \n", "shape": "dot", "size": 10, "title": "386\nCHAPTER 13\nSecuring cluster nodes and the network\nTo prevent the container from doing that, you need to drop the capability by listing it\nunder the container\u2019s securityContext.capabilities.drop property, as shown in\nthe following listing.\napiVersion: v1\nkind: Pod\nmetadata:\n  name: pod-drop-chown-capability\nspec:\n  containers:\n  - name: main\n    image: alpine\n    command: [\"/bin/sleep\", \"999999\"]\n    securityContext:\n      capabilities:\n        drop:                   \n        - CHOWN                 \nBy dropping the CHOWN capability, you\u2019re not allowed to change the owner of the /tmp\ndirectory in this pod:\n$ kubectl exec pod-drop-chown-capability chown guest /tmp\nchown: /tmp: Operation not permitted\nYou\u2019re almost done exploring the container\u2019s security context options. Let\u2019s look at\none more.\n13.2.6 Preventing processes from writing to the container\u2019s filesystem\nYou may want to prevent the processes running in the container from writing to the\ncontainer\u2019s filesystem, and only allow them to write to mounted volumes. You\u2019d want\nto do that mostly for security reasons. \n Let\u2019s imagine you\u2019re running a PHP application with a hidden vulnerability, allow-\ning an attacker to write to the filesystem. The PHP files are added to the container\nimage at build time and are served from the container\u2019s filesystem. Because of the vul-\nnerability, the attacker can modify those files and inject them with malicious code. \n These types of attacks can be thwarted by preventing the container from writing to\nits filesystem, where the app\u2019s executable code is normally stored. This is done by set-\nting the container\u2019s securityContext.readOnlyRootFilesystem property to true, as\nshown in the following listing.\napiVersion: v1\nkind: Pod\nmetadata:\n  name: pod-with-readonly-filesystem\nListing 13.12\nDropping a capability from a container: pod-drop-chown-capability.yaml\nListing 13.13\nA container with a read-only filesystem: pod-with-readonly-filesystem.yaml\nYou\u2019re not allowing this container \nto change file ownership.\n \n"}, {"color": "green", "id": "text_330", "label": "387\nConfiguring the container\u2019s security context\nspec:\n  containers:\n  - name: main\n    image: alpine\n    command: [\"/bin/sleep\", \"999999\"]\n    securityContext:                      \n      readOnlyRootFilesystem: true        \n    volumeMounts:                      \n    - name: my-volume                  \n      mountPath: /volume               \n      readOnly: false                  \n  volumes:\n  - name: my-volume\n    emptyDir:\nWhen you deploy this pod, the container is running as root, which has write permis-\nsions to the / directory, but trying to write a file there fails:\n$ kubectl exec -it pod-with-readonly-filesystem touch /new-file\ntouch: /new-file: Read-only file system\nOn the other hand, writing to the mounted volume is allowed:\n$ kubectl exec -it pod-with-readonly-filesystem touch /volume/newfile\n$ kubectl exec -it pod-with-readonly-filesystem -- ls -la /volume/newfile\n-rw-r--r--    1 root     root       0 May  7 19:11 /mountedVolume/newfile\nAs shown in the example, when you make the container\u2019s filesystem read-only, you\u2019ll\nprobably want to mount a volume in every directory the application writes to (for\nexample, logs, on-disk caches, and so on).\nTIP\nTo increase security, when running pods in production, set their con-\ntainer\u2019s readOnlyRootFilesystem property to true.\nSETTING SECURITY CONTEXT OPTIONS AT THE POD LEVEL\nIn all these examples, you\u2019ve set the security context of an individual container. Sev-\neral of these options can also be set at the pod level (through the pod.spec.security-\nContext property). They serve as a default for all the pod\u2019s containers but can be\noverridden at the container level. The pod-level security context also allows you to set\nadditional properties, which we\u2019ll explain next.\n13.2.7 Sharing volumes when containers run as different users\nIn chapter 6, we explained how volumes are used to share data between the pod\u2019s\ncontainers. You had no trouble writing files in one container and reading them in\nthe other. \n But this was only because both containers were running as root, giving them full\naccess to all the files in the volume. Now imagine using the runAsUser option we\nexplained earlier. You may need to run the two containers as two different users (per-\nhaps you\u2019re using two third-party container images, where each one runs its process\nThis container\u2019s filesystem \ncan\u2019t be written to...\n...but writing to /volume is \nallowed, becase a volume \nis mounted there.\n \n", "shape": "dot", "size": 10, "title": "387\nConfiguring the container\u2019s security context\nspec:\n  containers:\n  - name: main\n    image: alpine\n    command: [\"/bin/sleep\", \"999999\"]\n    securityContext:                      \n      readOnlyRootFilesystem: true        \n    volumeMounts:                      \n    - name: my-volume                  \n      mountPath: /volume               \n      readOnly: false                  \n  volumes:\n  - name: my-volume\n    emptyDir:\nWhen you deploy this pod, the container is running as root, which has write permis-\nsions to the / directory, but trying to write a file there fails:\n$ kubectl exec -it pod-with-readonly-filesystem touch /new-file\ntouch: /new-file: Read-only file system\nOn the other hand, writing to the mounted volume is allowed:\n$ kubectl exec -it pod-with-readonly-filesystem touch /volume/newfile\n$ kubectl exec -it pod-with-readonly-filesystem -- ls -la /volume/newfile\n-rw-r--r--    1 root     root       0 May  7 19:11 /mountedVolume/newfile\nAs shown in the example, when you make the container\u2019s filesystem read-only, you\u2019ll\nprobably want to mount a volume in every directory the application writes to (for\nexample, logs, on-disk caches, and so on).\nTIP\nTo increase security, when running pods in production, set their con-\ntainer\u2019s readOnlyRootFilesystem property to true.\nSETTING SECURITY CONTEXT OPTIONS AT THE POD LEVEL\nIn all these examples, you\u2019ve set the security context of an individual container. Sev-\neral of these options can also be set at the pod level (through the pod.spec.security-\nContext property). They serve as a default for all the pod\u2019s containers but can be\noverridden at the container level. The pod-level security context also allows you to set\nadditional properties, which we\u2019ll explain next.\n13.2.7 Sharing volumes when containers run as different users\nIn chapter 6, we explained how volumes are used to share data between the pod\u2019s\ncontainers. You had no trouble writing files in one container and reading them in\nthe other. \n But this was only because both containers were running as root, giving them full\naccess to all the files in the volume. Now imagine using the runAsUser option we\nexplained earlier. You may need to run the two containers as two different users (per-\nhaps you\u2019re using two third-party container images, where each one runs its process\nThis container\u2019s filesystem \ncan\u2019t be written to...\n...but writing to /volume is \nallowed, becase a volume \nis mounted there.\n \n"}, {"color": "green", "id": "text_331", "label": "388\nCHAPTER 13\nSecuring cluster nodes and the network\nunder its own specific user). If those two containers use a volume to share files, they\nmay not necessarily be able to read or write files of one another. \n That\u2019s why Kubernetes allows you to specify supplemental groups for all the pods\nrunning in the container, allowing them to share files, regardless of the user IDs\nthey\u2019re running as. This is done using the following two properties:\n\uf0a1\nfsGroup\n\uf0a1\nsupplementalGroups\nWhat they do is best explained in an example, so let\u2019s see how to use them in a pod\nand then see what their effect is. The next listing describes a pod with two containers\nsharing the same volume.\napiVersion: v1\nkind: Pod\nmetadata:\n  name: pod-with-shared-volume-fsgroup\nspec:\n  securityContext:                       \n    fsGroup: 555                         \n    supplementalGroups: [666, 777]       \n  containers:\n  - name: first\n    image: alpine\n    command: [\"/bin/sleep\", \"999999\"]\n    securityContext:                     \n      runAsUser: 1111                    \n    volumeMounts:                               \n    - name: shared-volume                       \n      mountPath: /volume\n      readOnly: false\n  - name: second\n    image: alpine\n    command: [\"/bin/sleep\", \"999999\"]\n    securityContext:                     \n      runAsUser: 2222                    \n    volumeMounts:                               \n    - name: shared-volume                       \n      mountPath: /volume\n      readOnly: false\n  volumes:                                      \n  - name: shared-volume                         \n    emptyDir:\nAfter you create this pod, run a shell in its first container and see what user and group\nIDs the container is running as:\n$ kubectl exec -it pod-with-shared-volume-fsgroup -c first sh\n/ $ id\nuid=1111 gid=0(root) groups=555,666,777\nListing 13.14\nfsGroup \u0026 supplementalGroups: pod-with-shared-volume-fsgroup.yaml\nThe fsGroup and supplementalGroups \nare defined in the security context at \nthe pod level.\nThe first container \nruns as user ID 1111.\nBoth containers \nuse the same \nvolume\nThe second\ncontainer\nruns as user\nID 2222.\n \n", "shape": "dot", "size": 10, "title": "388\nCHAPTER 13\nSecuring cluster nodes and the network\nunder its own specific user). If those two containers use a volume to share files, they\nmay not necessarily be able to read or write files of one another. \n That\u2019s why Kubernetes allows you to specify supplemental groups for all the pods\nrunning in the container, allowing them to share files, regardless of the user IDs\nthey\u2019re running as. This is done using the following two properties:\n\uf0a1\nfsGroup\n\uf0a1\nsupplementalGroups\nWhat they do is best explained in an example, so let\u2019s see how to use them in a pod\nand then see what their effect is. The next listing describes a pod with two containers\nsharing the same volume.\napiVersion: v1\nkind: Pod\nmetadata:\n  name: pod-with-shared-volume-fsgroup\nspec:\n  securityContext:                       \n    fsGroup: 555                         \n    supplementalGroups: [666, 777]       \n  containers:\n  - name: first\n    image: alpine\n    command: [\"/bin/sleep\", \"999999\"]\n    securityContext:                     \n      runAsUser: 1111                    \n    volumeMounts:                               \n    - name: shared-volume                       \n      mountPath: /volume\n      readOnly: false\n  - name: second\n    image: alpine\n    command: [\"/bin/sleep\", \"999999\"]\n    securityContext:                     \n      runAsUser: 2222                    \n    volumeMounts:                               \n    - name: shared-volume                       \n      mountPath: /volume\n      readOnly: false\n  volumes:                                      \n  - name: shared-volume                         \n    emptyDir:\nAfter you create this pod, run a shell in its first container and see what user and group\nIDs the container is running as:\n$ kubectl exec -it pod-with-shared-volume-fsgroup -c first sh\n/ $ id\nuid=1111 gid=0(root) groups=555,666,777\nListing 13.14\nfsGroup \u0026 supplementalGroups: pod-with-shared-volume-fsgroup.yaml\nThe fsGroup and supplementalGroups \nare defined in the security context at \nthe pod level.\nThe first container \nruns as user ID 1111.\nBoth containers \nuse the same \nvolume\nThe second\ncontainer\nruns as user\nID 2222.\n \n"}, {"color": "green", "id": "text_332", "label": "389\nRestricting the use of security-related features in pods\nThe id command shows the container is running with user ID 1111, as specified in the\npod definition. The effective group ID is 0(root), but group IDs 555, 666, and 777 are\nalso associated with the user. \n In the pod definition, you set fsGroup to 555. Because of this, the mounted volume\nwill be owned by group ID 555, as shown here:\n/ $ ls -l / | grep volume\ndrwxrwsrwx    2 root     555              6 May 29 12:23 volume\nIf you create a file in the mounted volume\u2019s directory, the file is owned by user ID\n1111 (that\u2019s the user ID the container is running as) and by group ID 555:\n/ $ echo foo \u003e /volume/foo\n/ $ ls -l /volume\ntotal 4\n-rw-r--r--    1 1111     555              4 May 29 12:25 foo\nThis is different from how ownership is otherwise set up for newly created files. Usu-\nally, the user\u2019s effective group ID, which is 0 in your case, is used when a user creates\nfiles. You can see this by creating a file in the container\u2019s filesystem instead of in the\nvolume:\n/ $ echo foo \u003e /tmp/foo\n/ $ ls -l /tmp\ntotal 4\n-rw-r--r--    1 1111     root             4 May 29 12:41 foo\nAs you can see, the fsGroup security context property is used when the process cre-\nates files in a volume (but this depends on the volume plugin used), whereas the\nsupplementalGroups property defines a list of additional group IDs the user is asso-\nciated with. \n This concludes this section about the configuration of the container\u2019s security con-\ntext. Next, we\u2019ll see how a cluster administrator can restrict users from doing so.\n13.3\nRestricting the use of security-related features in pods\nThe examples in the previous sections have shown how a person deploying pods can\ndo whatever they want on any cluster node, by deploying a privileged pod to the\nnode, for example. Obviously, a mechanism must prevent users from doing part or\nall of what\u2019s been explained. The cluster admin can restrict the use of the previously\ndescribed security-related features by creating one or more PodSecurityPolicy\nresources.\n13.3.1 Introducing the PodSecurityPolicy resource\nPodSecurityPolicy is a cluster-level (non-namespaced) resource, which defines what\nsecurity-related features users can or can\u2019t use in their pods. The job of upholding\nthe policies configured in PodSecurityPolicy resources is performed by the\n \n", "shape": "dot", "size": 10, "title": "389\nRestricting the use of security-related features in pods\nThe id command shows the container is running with user ID 1111, as specified in the\npod definition. The effective group ID is 0(root), but group IDs 555, 666, and 777 are\nalso associated with the user. \n In the pod definition, you set fsGroup to 555. Because of this, the mounted volume\nwill be owned by group ID 555, as shown here:\n/ $ ls -l / | grep volume\ndrwxrwsrwx    2 root     555              6 May 29 12:23 volume\nIf you create a file in the mounted volume\u2019s directory, the file is owned by user ID\n1111 (that\u2019s the user ID the container is running as) and by group ID 555:\n/ $ echo foo \u003e /volume/foo\n/ $ ls -l /volume\ntotal 4\n-rw-r--r--    1 1111     555              4 May 29 12:25 foo\nThis is different from how ownership is otherwise set up for newly created files. Usu-\nally, the user\u2019s effective group ID, which is 0 in your case, is used when a user creates\nfiles. You can see this by creating a file in the container\u2019s filesystem instead of in the\nvolume:\n/ $ echo foo \u003e /tmp/foo\n/ $ ls -l /tmp\ntotal 4\n-rw-r--r--    1 1111     root             4 May 29 12:41 foo\nAs you can see, the fsGroup security context property is used when the process cre-\nates files in a volume (but this depends on the volume plugin used), whereas the\nsupplementalGroups property defines a list of additional group IDs the user is asso-\nciated with. \n This concludes this section about the configuration of the container\u2019s security con-\ntext. Next, we\u2019ll see how a cluster administrator can restrict users from doing so.\n13.3\nRestricting the use of security-related features in pods\nThe examples in the previous sections have shown how a person deploying pods can\ndo whatever they want on any cluster node, by deploying a privileged pod to the\nnode, for example. Obviously, a mechanism must prevent users from doing part or\nall of what\u2019s been explained. The cluster admin can restrict the use of the previously\ndescribed security-related features by creating one or more PodSecurityPolicy\nresources.\n13.3.1 Introducing the PodSecurityPolicy resource\nPodSecurityPolicy is a cluster-level (non-namespaced) resource, which defines what\nsecurity-related features users can or can\u2019t use in their pods. The job of upholding\nthe policies configured in PodSecurityPolicy resources is performed by the\n \n"}, {"color": "green", "id": "text_333", "label": "390\nCHAPTER 13\nSecuring cluster nodes and the network\nPodSecurityPolicy admission control plugin running in the API server (we explained\nadmission control plugins in chapter 11).\nNOTE\nThe PodSecurityPolicy admission control plugin may not be enabled\nin your cluster. Before running the following examples, ensure it\u2019s enabled. If\nyou\u2019re using Minikube, refer to the next sidebar.\nWhen someone posts a pod resource to the API server, the PodSecurityPolicy admis-\nsion control plugin validates the pod definition against the configured PodSecurity-\nPolicies. If the pod conforms to the cluster\u2019s policies, it\u2019s accepted and stored into\netcd; otherwise it\u2019s rejected immediately. The plugin may also modify the pod\nresource according to defaults configured in the policy.\nUNDERSTANDING WHAT A PODSECURITYPOLICY CAN DO\nA PodSecurityPolicy resource defines things like the following:\n\uf0a1Whether a pod can use the host\u2019s IPC, PID, or Network namespaces\n\uf0a1Which host ports a pod can bind to\n\uf0a1What user IDs a container can run as\n\uf0a1Whether a pod with privileged containers can be created\nEnabling RBAC and PodSecurityPolicy admission control in Minikube\nI\u2019m using Minikube version v0.19.0 to run these examples. That version doesn\u2019t\nenable either the PodSecurityPolicy admission control plugin or RBAC authorization,\nwhich is required in part of the exercises. One exercise also requires authenticating\nas a different user, so you\u2019ll also need to enable the basic authentication plugin\nwhere users are defined in a file.\nTo run Minikube with all these plugins enabled, you may need to use this (or a similar)\ncommand, depending on the version you\u2019re using: \n$ minikube start --extra-config apiserver.Authentication.PasswordFile.\n\u27a5 BasicAuthFile=/etc/kubernetes/passwd --extra-config=apiserver.\n\u27a5 Authorization.Mode=RBAC --extra-config=apiserver.GenericServerRun\n\u27a5 Options.AdmissionControl=NamespaceLifecycle,LimitRanger,Service\n\u27a5 Account,PersistentVolumeLabel,DefaultStorageClass,ResourceQuota,\n\u27a5 DefaultTolerationSeconds,PodSecurityPolicy\nThe API server won\u2019t start up until you create the password file you specified in the\ncommand line options. This is how to create the file:\n$ cat \u003c\u003cEOF | minikube ssh sudo tee /etc/kubernetes/passwd\npassword,alice,1000,basic-user\npassword,bob,2000,privileged-user\nEOF\nYou\u2019ll find a shell script that runs both commands in the book\u2019s code archive in\nChapter13/minikube-with-rbac-and-psp-enabled.sh.\n \n", "shape": "dot", "size": 10, "title": "390\nCHAPTER 13\nSecuring cluster nodes and the network\nPodSecurityPolicy admission control plugin running in the API server (we explained\nadmission control plugins in chapter 11).\nNOTE\nThe PodSecurityPolicy admission control plugin may not be enabled\nin your cluster. Before running the following examples, ensure it\u2019s enabled. If\nyou\u2019re using Minikube, refer to the next sidebar.\nWhen someone posts a pod resource to the API server, the PodSecurityPolicy admis-\nsion control plugin validates the pod definition against the configured PodSecurity-\nPolicies. If the pod conforms to the cluster\u2019s policies, it\u2019s accepted and stored into\netcd; otherwise it\u2019s rejected immediately. The plugin may also modify the pod\nresource according to defaults configured in the policy.\nUNDERSTANDING WHAT A PODSECURITYPOLICY CAN DO\nA PodSecurityPolicy resource defines things like the following:\n\uf0a1Whether a pod can use the host\u2019s IPC, PID, or Network namespaces\n\uf0a1Which host ports a pod can bind to\n\uf0a1What user IDs a container can run as\n\uf0a1Whether a pod with privileged containers can be created\nEnabling RBAC and PodSecurityPolicy admission control in Minikube\nI\u2019m using Minikube version v0.19.0 to run these examples. That version doesn\u2019t\nenable either the PodSecurityPolicy admission control plugin or RBAC authorization,\nwhich is required in part of the exercises. One exercise also requires authenticating\nas a different user, so you\u2019ll also need to enable the basic authentication plugin\nwhere users are defined in a file.\nTo run Minikube with all these plugins enabled, you may need to use this (or a similar)\ncommand, depending on the version you\u2019re using: \n$ minikube start --extra-config apiserver.Authentication.PasswordFile.\n\u27a5 BasicAuthFile=/etc/kubernetes/passwd --extra-config=apiserver.\n\u27a5 Authorization.Mode=RBAC --extra-config=apiserver.GenericServerRun\n\u27a5 Options.AdmissionControl=NamespaceLifecycle,LimitRanger,Service\n\u27a5 Account,PersistentVolumeLabel,DefaultStorageClass,ResourceQuota,\n\u27a5 DefaultTolerationSeconds,PodSecurityPolicy\nThe API server won\u2019t start up until you create the password file you specified in the\ncommand line options. This is how to create the file:\n$ cat \u003c\u003cEOF | minikube ssh sudo tee /etc/kubernetes/passwd\npassword,alice,1000,basic-user\npassword,bob,2000,privileged-user\nEOF\nYou\u2019ll find a shell script that runs both commands in the book\u2019s code archive in\nChapter13/minikube-with-rbac-and-psp-enabled.sh.\n \n"}, {"color": "green", "id": "text_334", "label": "391\nRestricting the use of security-related features in pods\n\uf0a1Which kernel capabilities are allowed, which are added by default and which are\nalways dropped\n\uf0a1What SELinux labels a container can use\n\uf0a1Whether a container can use a writable root filesystem or not\n\uf0a1Which filesystem groups the container can run as\n\uf0a1Which volume types a pod can use\nIf you\u2019ve read this chapter up to this point, everything but the last item in the previous\nlist should be familiar. The last item should also be fairly clear. \nEXAMINING A SAMPLE PODSECURITYPOLICY\nThe following listing shows a sample PodSecurityPolicy, which prevents pods from\nusing the host\u2019s IPC, PID, and Network namespaces, and prevents running privileged\ncontainers and the use of most host ports (except ports from 10000-11000 and 13000-\n14000). The policy doesn\u2019t set any constraints on what users, groups, or SELinux\ngroups the container can run as.\napiVersion: extensions/v1beta1\nkind: PodSecurityPolicy\nmetadata:\n  name: default\nspec:\n  hostIPC: false                 \n  hostPID: false                 \n  hostNetwork: false             \n  hostPorts:                         \n  - min: 10000                       \n    max: 11000                       \n  - min: 13000                       \n    max: 14000                       \n  privileged: false              \n  readOnlyRootFilesystem: true   \n  runAsUser:                      \n    rule: RunAsAny                \n  fsGroup:                        \n    rule: RunAsAny                \n  supplementalGroups:             \n    rule: RunAsAny                \n  seLinux:                      \n    rule: RunAsAny              \n  volumes:                  \n  - \u0027*\u0027                     \nMost of the options specified in the example should be self-explanatory, especially if\nyou\u2019ve read the previous sections. After this PodSecurityPolicy resource is posted to\nListing 13.15\nAn example PodSecurityPolicy: pod-security-policy.yaml\nContainers aren\u2019t \nallowed to use the \nhost\u2019s IPC, PID, or \nnetwork namespace.\nThey can only bind to host ports \n10000 to 11000 (inclusive) or \nhost ports 13000 to 14000.\nContainers cannot run \nin privileged mode.\nContainers are forced to run \nwith a read-only root filesystem.\nContainers can \nrun as any user \nand any group.\nThey can also use any \nSELinux groups they want.\nAll volume types can \nbe used in pods.\n \n", "shape": "dot", "size": 10, "title": "391\nRestricting the use of security-related features in pods\n\uf0a1Which kernel capabilities are allowed, which are added by default and which are\nalways dropped\n\uf0a1What SELinux labels a container can use\n\uf0a1Whether a container can use a writable root filesystem or not\n\uf0a1Which filesystem groups the container can run as\n\uf0a1Which volume types a pod can use\nIf you\u2019ve read this chapter up to this point, everything but the last item in the previous\nlist should be familiar. The last item should also be fairly clear. \nEXAMINING A SAMPLE PODSECURITYPOLICY\nThe following listing shows a sample PodSecurityPolicy, which prevents pods from\nusing the host\u2019s IPC, PID, and Network namespaces, and prevents running privileged\ncontainers and the use of most host ports (except ports from 10000-11000 and 13000-\n14000). The policy doesn\u2019t set any constraints on what users, groups, or SELinux\ngroups the container can run as.\napiVersion: extensions/v1beta1\nkind: PodSecurityPolicy\nmetadata:\n  name: default\nspec:\n  hostIPC: false                 \n  hostPID: false                 \n  hostNetwork: false             \n  hostPorts:                         \n  - min: 10000                       \n    max: 11000                       \n  - min: 13000                       \n    max: 14000                       \n  privileged: false              \n  readOnlyRootFilesystem: true   \n  runAsUser:                      \n    rule: RunAsAny                \n  fsGroup:                        \n    rule: RunAsAny                \n  supplementalGroups:             \n    rule: RunAsAny                \n  seLinux:                      \n    rule: RunAsAny              \n  volumes:                  \n  - \u0027*\u0027                     \nMost of the options specified in the example should be self-explanatory, especially if\nyou\u2019ve read the previous sections. After this PodSecurityPolicy resource is posted to\nListing 13.15\nAn example PodSecurityPolicy: pod-security-policy.yaml\nContainers aren\u2019t \nallowed to use the \nhost\u2019s IPC, PID, or \nnetwork namespace.\nThey can only bind to host ports \n10000 to 11000 (inclusive) or \nhost ports 13000 to 14000.\nContainers cannot run \nin privileged mode.\nContainers are forced to run \nwith a read-only root filesystem.\nContainers can \nrun as any user \nand any group.\nThey can also use any \nSELinux groups they want.\nAll volume types can \nbe used in pods.\n \n"}, {"color": "green", "id": "text_335", "label": "392\nCHAPTER 13\nSecuring cluster nodes and the network\nthe cluster, the API server will no longer allow you to deploy the privileged pod used\nearlier. For example\n$ kubectl create -f pod-privileged.yaml\nError from server (Forbidden): error when creating \"pod-privileged.yaml\":\npods \"pod-privileged\" is forbidden: unable to validate against any pod \nsecurity policy: [spec.containers[0].securityContext.privileged: Invalid \nvalue: true: Privileged containers are not allowed]\nLikewise, you can no longer deploy pods that want to use the host\u2019s PID, IPC, or Net-\nwork namespace. Also, because you set readOnlyRootFilesystem to true in the pol-\nicy, the container filesystems in all pods will be read-only (containers can only write\nto volumes).\n13.3.2 Understanding runAsUser, fsGroup, and supplementalGroups \npolicies\nThe policy in the previous example doesn\u2019t impose any limits on which users and\ngroups containers can run as, because you\u2019ve used the RunAsAny rule for the runAs-\nUser, fsGroup, and supplementalGroups fields. If you want to constrain the list of\nallowed user or group IDs, you change the rule to MustRunAs and specify the range of\nallowed IDs. \nUSING THE MUSTRUNAS RULE\nLet\u2019s look at an example. To only allow containers to run as user ID 2 and constrain the\ndefault filesystem group and supplemental group IDs to be anything from 2\u201310 or 20\u2013\n30 (all inclusive), you\u2019d include the following snippet in the PodSecurityPolicy resource.\n  runAsUser:\n    rule: MustRunAs\n    ranges:\n    - min: 2                \n      max: 2                \n  fsGroup:\n    rule: MustRunAs\n    ranges:\n    - min: 2                \n      max: 10               \n    - min: 20               \n      max: 30               \n  supplementalGroups:\n    rule: MustRunAs\n    ranges:\n    - min: 2                \n      max: 10               \n    - min: 20               \n      max: 30               \nListing 13.16\nSpecifying IDs containers must run as: psp-must-run-as.yaml\nAdd a single range with min equal \nto max to set one specific ID.\nMultiple ranges are \nsupported\u2014here, \ngroup IDs can be 2\u201310 \nor 20\u201330 (inclusive).\n \n", "shape": "dot", "size": 10, "title": "392\nCHAPTER 13\nSecuring cluster nodes and the network\nthe cluster, the API server will no longer allow you to deploy the privileged pod used\nearlier. For example\n$ kubectl create -f pod-privileged.yaml\nError from server (Forbidden): error when creating \"pod-privileged.yaml\":\npods \"pod-privileged\" is forbidden: unable to validate against any pod \nsecurity policy: [spec.containers[0].securityContext.privileged: Invalid \nvalue: true: Privileged containers are not allowed]\nLikewise, you can no longer deploy pods that want to use the host\u2019s PID, IPC, or Net-\nwork namespace. Also, because you set readOnlyRootFilesystem to true in the pol-\nicy, the container filesystems in all pods will be read-only (containers can only write\nto volumes).\n13.3.2 Understanding runAsUser, fsGroup, and supplementalGroups \npolicies\nThe policy in the previous example doesn\u2019t impose any limits on which users and\ngroups containers can run as, because you\u2019ve used the RunAsAny rule for the runAs-\nUser, fsGroup, and supplementalGroups fields. If you want to constrain the list of\nallowed user or group IDs, you change the rule to MustRunAs and specify the range of\nallowed IDs. \nUSING THE MUSTRUNAS RULE\nLet\u2019s look at an example. To only allow containers to run as user ID 2 and constrain the\ndefault filesystem group and supplemental group IDs to be anything from 2\u201310 or 20\u2013\n30 (all inclusive), you\u2019d include the following snippet in the PodSecurityPolicy resource.\n  runAsUser:\n    rule: MustRunAs\n    ranges:\n    - min: 2                \n      max: 2                \n  fsGroup:\n    rule: MustRunAs\n    ranges:\n    - min: 2                \n      max: 10               \n    - min: 20               \n      max: 30               \n  supplementalGroups:\n    rule: MustRunAs\n    ranges:\n    - min: 2                \n      max: 10               \n    - min: 20               \n      max: 30               \nListing 13.16\nSpecifying IDs containers must run as: psp-must-run-as.yaml\nAdd a single range with min equal \nto max to set one specific ID.\nMultiple ranges are \nsupported\u2014here, \ngroup IDs can be 2\u201310 \nor 20\u201330 (inclusive).\n \n"}, {"color": "green", "id": "text_336", "label": "393\nRestricting the use of security-related features in pods\nIf the pod spec tries to set either of those fields to a value outside of these ranges, the\npod will not be accepted by the API server. To try this, delete the previous PodSecurity-\nPolicy and create the new one from the psp-must-run-as.yaml file. \nNOTE\nChanging the policy has no effect on existing pods, because PodSecurity-\nPolicies are enforced only when creating or updating pods.\nDEPLOYING A POD WITH RUNASUSER OUTSIDE OF THE POLICY\u2019S RANGE\nIf you try deploying the pod-as-user-guest.yaml file from earlier, which says the con-\ntainer should run as user ID 405, the API server rejects the pod:\n$ kubectl create -f pod-as-user-guest.yaml\nError from server (Forbidden): error when creating \"pod-as-user-guest.yaml\"\n: pods \"pod-as-user-guest\" is forbidden: unable to validate against any pod \nsecurity policy: [securityContext.runAsUser: Invalid value: 405: UID on \ncontainer main does not match required range.  Found 405, allowed: [{2 2}]]\nOkay, that was obvious. But what happens if you deploy a pod without setting the runAs-\nUser property, but the user ID is baked into the container image (using the USER direc-\ntive in the Dockerfile)?\nDEPLOYING A POD WITH A CONTAINER IMAGE WITH AN OUT-OF-RANGE USER ID\nI\u2019ve created an alternative image for the Node.js app you\u2019ve used throughout the\nbook. The image is configured so that the container will run as user ID 5. The Docker-\nfile for the image is shown in the following listing.\nFROM node:7\nADD app.js /app.js\nUSER 5                         \nENTRYPOINT [\"node\", \"app.js\"]\nI pushed the image to Docker Hub as luksa/kubia-run-as-user-5. If I deploy a pod\nwith that image, the API server doesn\u2019t reject it:\n$ kubectl run run-as-5 --image luksa/kubia-run-as-user-5 --restart Never\npod \"run-as-5\" created\nUnlike before, the API server accepted the pod and the Kubelet has run its container.\nLet\u2019s see what user ID the container is running as:\n$ kubectl exec run-as-5 -- id\nuid=2(bin) gid=2(bin) groups=2(bin)\nAs you can see, the container is running as user ID 2, which is the ID you specified in\nthe PodSecurityPolicy. The PodSecurityPolicy can be used to override the user ID\nhardcoded into a container image.\nListing 13.17\nDockerfile with a USER directive: kubia-run-as-user-5/Dockerfile\nContainers run from \nthis image will run \nas user ID 5.\n \n", "shape": "dot", "size": 10, "title": "393\nRestricting the use of security-related features in pods\nIf the pod spec tries to set either of those fields to a value outside of these ranges, the\npod will not be accepted by the API server. To try this, delete the previous PodSecurity-\nPolicy and create the new one from the psp-must-run-as.yaml file. \nNOTE\nChanging the policy has no effect on existing pods, because PodSecurity-\nPolicies are enforced only when creating or updating pods.\nDEPLOYING A POD WITH RUNASUSER OUTSIDE OF THE POLICY\u2019S RANGE\nIf you try deploying the pod-as-user-guest.yaml file from earlier, which says the con-\ntainer should run as user ID 405, the API server rejects the pod:\n$ kubectl create -f pod-as-user-guest.yaml\nError from server (Forbidden): error when creating \"pod-as-user-guest.yaml\"\n: pods \"pod-as-user-guest\" is forbidden: unable to validate against any pod \nsecurity policy: [securityContext.runAsUser: Invalid value: 405: UID on \ncontainer main does not match required range.  Found 405, allowed: [{2 2}]]\nOkay, that was obvious. But what happens if you deploy a pod without setting the runAs-\nUser property, but the user ID is baked into the container image (using the USER direc-\ntive in the Dockerfile)?\nDEPLOYING A POD WITH A CONTAINER IMAGE WITH AN OUT-OF-RANGE USER ID\nI\u2019ve created an alternative image for the Node.js app you\u2019ve used throughout the\nbook. The image is configured so that the container will run as user ID 5. The Docker-\nfile for the image is shown in the following listing.\nFROM node:7\nADD app.js /app.js\nUSER 5                         \nENTRYPOINT [\"node\", \"app.js\"]\nI pushed the image to Docker Hub as luksa/kubia-run-as-user-5. If I deploy a pod\nwith that image, the API server doesn\u2019t reject it:\n$ kubectl run run-as-5 --image luksa/kubia-run-as-user-5 --restart Never\npod \"run-as-5\" created\nUnlike before, the API server accepted the pod and the Kubelet has run its container.\nLet\u2019s see what user ID the container is running as:\n$ kubectl exec run-as-5 -- id\nuid=2(bin) gid=2(bin) groups=2(bin)\nAs you can see, the container is running as user ID 2, which is the ID you specified in\nthe PodSecurityPolicy. The PodSecurityPolicy can be used to override the user ID\nhardcoded into a container image.\nListing 13.17\nDockerfile with a USER directive: kubia-run-as-user-5/Dockerfile\nContainers run from \nthis image will run \nas user ID 5.\n \n"}, {"color": "green", "id": "text_337", "label": "394\nCHAPTER 13\nSecuring cluster nodes and the network\nUSING THE MUSTRUNASNONROOT RULE IN THE RUNASUSER FIELD\nFor the runAsUser field an additional rule can be used: MustRunAsNonRoot. As the\nname suggests, it prevents users from deploying containers that run as root. Either the\ncontainer spec must specify a runAsUser field, which can\u2019t be zero (zero is the root\nuser\u2019s ID), or the container image itself must run as a non-zero user ID. We explained\nwhy this is a good thing earlier.\n13.3.3 Configuring allowed, default, and disallowed capabilities\nAs you learned, containers can run in privileged mode or not, and you can define a\nmore fine-grained permission configuration by adding or dropping Linux kernel\ncapabilities in each container. Three fields influence which capabilities containers can\nor cannot use:\n\uf0a1\nallowedCapabilities\n\uf0a1\ndefaultAddCapabilities\n\uf0a1\nrequiredDropCapabilities\nWe\u2019ll look at an example first, and then discuss what each of the three fields does. The\nfollowing listing shows a snippet of a PodSecurityPolicy resource defining three fields\nrelated to capabilities.\napiVersion: extensions/v1beta1 \nkind: PodSecurityPolicy\nspec:\n  allowedCapabilities:          \n  - SYS_TIME                    \n  defaultAddCapabilities:         \n  - CHOWN                         \n  requiredDropCapabilities:     \n  - SYS_ADMIN                   \n  - SYS_MODULE                  \n  ...\nNOTE\nThe SYS_ADMIN capability allows a range of administrative operations,\nand the SYS_MODULE capability allows loading and unloading of Linux kernel\nmodules.\nSPECIFYING WHICH CAPABILITIES CAN BE ADDED TO A CONTAINER\nThe allowedCapabilities field is used to specify which capabilities pod authors can\nadd in the securityContext.capabilities field in the container spec. In one of the\nprevious examples, you added the SYS_TIME capability to your container. If the Pod-\nSecurityPolicy admission control plugin had been enabled, you wouldn\u2019t have been\nable to add that capability, unless it was specified in the PodSecurityPolicy as shown\nin listing 13.18.\nListing 13.18\nSpecifying capabilities in a PodSecurityPolicy: psp-capabilities.yaml\nAllow containers to \nadd the SYS_TIME \ncapability.\nAutomatically add the CHOWN \ncapability to every container.\nRequire containers to \ndrop the SYS_ADMIN and \nSYS_MODULE capabilities.\n \n", "shape": "dot", "size": 10, "title": "394\nCHAPTER 13\nSecuring cluster nodes and the network\nUSING THE MUSTRUNASNONROOT RULE IN THE RUNASUSER FIELD\nFor the runAsUser field an additional rule can be used: MustRunAsNonRoot. As the\nname suggests, it prevents users from deploying containers that run as root. Either the\ncontainer spec must specify a runAsUser field, which can\u2019t be zero (zero is the root\nuser\u2019s ID), or the container image itself must run as a non-zero user ID. We explained\nwhy this is a good thing earlier.\n13.3.3 Configuring allowed, default, and disallowed capabilities\nAs you learned, containers can run in privileged mode or not, and you can define a\nmore fine-grained permission configuration by adding or dropping Linux kernel\ncapabilities in each container. Three fields influence which capabilities containers can\nor cannot use:\n\uf0a1\nallowedCapabilities\n\uf0a1\ndefaultAddCapabilities\n\uf0a1\nrequiredDropCapabilities\nWe\u2019ll look at an example first, and then discuss what each of the three fields does. The\nfollowing listing shows a snippet of a PodSecurityPolicy resource defining three fields\nrelated to capabilities.\napiVersion: extensions/v1beta1 \nkind: PodSecurityPolicy\nspec:\n  allowedCapabilities:          \n  - SYS_TIME                    \n  defaultAddCapabilities:         \n  - CHOWN                         \n  requiredDropCapabilities:     \n  - SYS_ADMIN                   \n  - SYS_MODULE                  \n  ...\nNOTE\nThe SYS_ADMIN capability allows a range of administrative operations,\nand the SYS_MODULE capability allows loading and unloading of Linux kernel\nmodules.\nSPECIFYING WHICH CAPABILITIES CAN BE ADDED TO A CONTAINER\nThe allowedCapabilities field is used to specify which capabilities pod authors can\nadd in the securityContext.capabilities field in the container spec. In one of the\nprevious examples, you added the SYS_TIME capability to your container. If the Pod-\nSecurityPolicy admission control plugin had been enabled, you wouldn\u2019t have been\nable to add that capability, unless it was specified in the PodSecurityPolicy as shown\nin listing 13.18.\nListing 13.18\nSpecifying capabilities in a PodSecurityPolicy: psp-capabilities.yaml\nAllow containers to \nadd the SYS_TIME \ncapability.\nAutomatically add the CHOWN \ncapability to every container.\nRequire containers to \ndrop the SYS_ADMIN and \nSYS_MODULE capabilities.\n \n"}, {"color": "green", "id": "text_338", "label": "395\nRestricting the use of security-related features in pods\nADDING CAPABILITIES TO ALL CONTAINERS\nAll capabilities listed under the defaultAddCapabilities field will be added to\nevery deployed pod\u2019s containers. If a user doesn\u2019t want certain containers to have\nthose capabilities, they need to explicitly drop them in the specs of those containers.\n The example in listing 13.18 enables the automatic addition of the CAP_CHOWN capa-\nbility to every container, thus allowing processes running in the container to change the\nownership of files in the container (with the chown command, for example).\nDROPPING CAPABILITIES FROM A CONTAINER\nThe final field in this example is requiredDropCapabilities. I must admit, this was a\nsomewhat strange name for me at first, but it\u2019s not that complicated. The capabilities\nlisted in this field are dropped automatically from every container (the PodSecurity-\nPolicy Admission Control plugin will add them to every container\u2019s security-\nContext.capabilities.drop field). \n If a user tries to create a pod where they explicitly add one of the capabilities listed\nin the policy\u2019s requiredDropCapabilities field, the pod is rejected:\n$ kubectl create -f pod-add-sysadmin-capability.yaml\nError from server (Forbidden): error when creating \"pod-add-sysadmin-\ncapability.yaml\": pods \"pod-add-sysadmin-capability\" is forbidden: unable \nto validate against any pod security policy: [capabilities.add: Invalid \nvalue: \"SYS_ADMIN\": capability may not be added]\n13.3.4 Constraining the types of volumes pods can use\nThe last thing a PodSecurityPolicy resource can do is define which volume types users\ncan add to their pods. At the minimum, a PodSecurityPolicy should allow using at\nleast the emptyDir, configMap, secret, downwardAPI, and the persistentVolume-\nClaim volumes. The pertinent part of such a PodSecurityPolicy resource is shown in\nthe following listing.\nkind: PodSecurityPolicy\nspec:\n  volumes:\n  - emptyDir\n  - configMap\n  - secret\n  - downwardAPI\n  - persistentVolumeClaim\nIf multiple PodSecurityPolicy resources are in place, pods can use any volume type\ndefined in any of the policies (the union of all volumes lists is used).\nListing 13.19\nA PSP snippet allowing the use of only certain volume types: \npsp-volumes.yaml\n \n", "shape": "dot", "size": 10, "title": "395\nRestricting the use of security-related features in pods\nADDING CAPABILITIES TO ALL CONTAINERS\nAll capabilities listed under the defaultAddCapabilities field will be added to\nevery deployed pod\u2019s containers. If a user doesn\u2019t want certain containers to have\nthose capabilities, they need to explicitly drop them in the specs of those containers.\n The example in listing 13.18 enables the automatic addition of the CAP_CHOWN capa-\nbility to every container, thus allowing processes running in the container to change the\nownership of files in the container (with the chown command, for example).\nDROPPING CAPABILITIES FROM A CONTAINER\nThe final field in this example is requiredDropCapabilities. I must admit, this was a\nsomewhat strange name for me at first, but it\u2019s not that complicated. The capabilities\nlisted in this field are dropped automatically from every container (the PodSecurity-\nPolicy Admission Control plugin will add them to every container\u2019s security-\nContext.capabilities.drop field). \n If a user tries to create a pod where they explicitly add one of the capabilities listed\nin the policy\u2019s requiredDropCapabilities field, the pod is rejected:\n$ kubectl create -f pod-add-sysadmin-capability.yaml\nError from server (Forbidden): error when creating \"pod-add-sysadmin-\ncapability.yaml\": pods \"pod-add-sysadmin-capability\" is forbidden: unable \nto validate against any pod security policy: [capabilities.add: Invalid \nvalue: \"SYS_ADMIN\": capability may not be added]\n13.3.4 Constraining the types of volumes pods can use\nThe last thing a PodSecurityPolicy resource can do is define which volume types users\ncan add to their pods. At the minimum, a PodSecurityPolicy should allow using at\nleast the emptyDir, configMap, secret, downwardAPI, and the persistentVolume-\nClaim volumes. The pertinent part of such a PodSecurityPolicy resource is shown in\nthe following listing.\nkind: PodSecurityPolicy\nspec:\n  volumes:\n  - emptyDir\n  - configMap\n  - secret\n  - downwardAPI\n  - persistentVolumeClaim\nIf multiple PodSecurityPolicy resources are in place, pods can use any volume type\ndefined in any of the policies (the union of all volumes lists is used).\nListing 13.19\nA PSP snippet allowing the use of only certain volume types: \npsp-volumes.yaml\n \n"}, {"color": "green", "id": "text_339", "label": "396\nCHAPTER 13\nSecuring cluster nodes and the network\n13.3.5 Assigning different PodSecurityPolicies to different users \nand groups\nWe mentioned that a PodSecurityPolicy is a cluster-level resource, which means it\ncan\u2019t be stored in and applied to a specific namespace. Does that mean it always\napplies across all namespaces? No, because that would make them relatively unus-\nable. After all, system pods must often be allowed to do things that regular pods\nshouldn\u2019t.\n Assigning different policies to different users is done through the RBAC mecha-\nnism described in the previous chapter. The idea is to create as many policies as you\nneed and make them available to individual users or groups by creating ClusterRole\nresources and pointing them to the individual policies by name. By binding those\nClusterRoles to specific users or groups with ClusterRoleBindings, when the Pod-\nSecurityPolicy Admission Control plugin needs to decide whether to admit a pod defi-\nnition or not, it will only consider the policies accessible to the user creating the pod. \n You\u2019ll see how to do this in the next exercise. You\u2019ll start by creating an additional\nPodSecurityPolicy.\nCREATING A PODSECURITYPOLICY ALLOWING PRIVILEGED CONTAINERS TO BE DEPLOYED\nYou\u2019ll create a special PodSecurityPolicy that will allow privileged users to create pods\nwith privileged containers. The following listing shows the policy\u2019s definition.\napiVersion: extensions/v1beta1\nkind: PodSecurityPolicy\nmetadata:\n  name: privileged          \nspec:\n  privileged: true        \n  runAsUser:\n    rule: RunAsAny\n  fsGroup:\n    rule: RunAsAny\n  supplementalGroups:\n    rule: RunAsAny\n  seLinux:\n    rule: RunAsAny\n  volumes:\n  - \u0027*\u0027\nAfter you post this policy to the API server, you have two policies in the cluster:\n$ kubectl get psp\nNAME         PRIV    CAPS   SELINUX    RUNASUSER   FSGROUP    ...  \ndefault      false   []     RunAsAny   RunAsAny    RunAsAny   ...\nprivileged   true    []     RunAsAny   RunAsAny    RunAsAny   ...\nNOTE\nThe shorthand for PodSecurityPolicy is psp.\nListing 13.20\nA PodSecurityPolicy for privileged users: psp-privileged.yaml\nThe name of this \npolicy is \"privileged.\u201d\nIt allows running \nprivileged containers.\n \n", "shape": "dot", "size": 10, "title": "396\nCHAPTER 13\nSecuring cluster nodes and the network\n13.3.5 Assigning different PodSecurityPolicies to different users \nand groups\nWe mentioned that a PodSecurityPolicy is a cluster-level resource, which means it\ncan\u2019t be stored in and applied to a specific namespace. Does that mean it always\napplies across all namespaces? No, because that would make them relatively unus-\nable. After all, system pods must often be allowed to do things that regular pods\nshouldn\u2019t.\n Assigning different policies to different users is done through the RBAC mecha-\nnism described in the previous chapter. The idea is to create as many policies as you\nneed and make them available to individual users or groups by creating ClusterRole\nresources and pointing them to the individual policies by name. By binding those\nClusterRoles to specific users or groups with ClusterRoleBindings, when the Pod-\nSecurityPolicy Admission Control plugin needs to decide whether to admit a pod defi-\nnition or not, it will only consider the policies accessible to the user creating the pod. \n You\u2019ll see how to do this in the next exercise. You\u2019ll start by creating an additional\nPodSecurityPolicy.\nCREATING A PODSECURITYPOLICY ALLOWING PRIVILEGED CONTAINERS TO BE DEPLOYED\nYou\u2019ll create a special PodSecurityPolicy that will allow privileged users to create pods\nwith privileged containers. The following listing shows the policy\u2019s definition.\napiVersion: extensions/v1beta1\nkind: PodSecurityPolicy\nmetadata:\n  name: privileged          \nspec:\n  privileged: true        \n  runAsUser:\n    rule: RunAsAny\n  fsGroup:\n    rule: RunAsAny\n  supplementalGroups:\n    rule: RunAsAny\n  seLinux:\n    rule: RunAsAny\n  volumes:\n  - \u0027*\u0027\nAfter you post this policy to the API server, you have two policies in the cluster:\n$ kubectl get psp\nNAME         PRIV    CAPS   SELINUX    RUNASUSER   FSGROUP    ...  \ndefault      false   []     RunAsAny   RunAsAny    RunAsAny   ...\nprivileged   true    []     RunAsAny   RunAsAny    RunAsAny   ...\nNOTE\nThe shorthand for PodSecurityPolicy is psp.\nListing 13.20\nA PodSecurityPolicy for privileged users: psp-privileged.yaml\nThe name of this \npolicy is \"privileged.\u201d\nIt allows running \nprivileged containers.\n \n"}, {"color": "green", "id": "text_340", "label": "397\nRestricting the use of security-related features in pods\nAs you can see in the PRIV column, the default policy doesn\u2019t allow running privi-\nleged containers, whereas the privileged policy does. Because you\u2019re currently\nlogged in as a cluster-admin, you can see all the policies. When creating pods, if any\npolicy allows you to deploy a pod with certain features, the API server will accept\nyour pod.\n Now imagine two additional users are using your cluster: Alice and Bob. You want\nAlice to only deploy restricted (non-privileged) pods, but you want to allow Bob to\nalso deploy privileged pods. You do this by making sure Alice can only use the default\nPodSecurityPolicy, while allowing Bob to use both.\nUSING RBAC TO ASSIGN DIFFERENT PODSECURITYPOLICIES TO DIFFERENT USERS\nIn the previous chapter, you used RBAC to grant users access to only certain resource\ntypes, but I mentioned that access can be granted to specific resource instances by ref-\nerencing them by name. That\u2019s what you\u2019ll use to make users use different Pod-\nSecurityPolicy resources.\n First, you\u2019ll create two ClusterRoles, each allowing the use of one of the policies.\nYou\u2019ll call the first one psp-default and in it allow the use of the default Pod-\nSecurityPolicy resource. You can use kubectl create clusterrole to do that:\n$ kubectl create clusterrole psp-default --verb=use \n\u27a5  --resource=podsecuritypolicies --resource-name=default\nclusterrole \"psp-default\" created\nNOTE\nYou\u2019re using the special verb use instead of get, list, watch, or similar.\nAs you can see, you\u2019re referring to a specific instance of a PodSecurityPolicy resource by\nusing the --resource-name option. Now, create another ClusterRole called psp-\nprivileged, pointing to the privileged policy:\n$ kubectl create clusterrole psp-privileged --verb=use\n\u27a5  --resource=podsecuritypolicies --resource-name=privileged\nclusterrole \"psp-privileged\" created\nNow, you need to bind these two policies to users. As you may remember from the pre-\nvious chapter, if you\u2019re binding a ClusterRole that grants access to cluster-level\nresources (which is what PodSecurityPolicy resources are), you need to use a Cluster-\nRoleBinding instead of a (namespaced) RoleBinding. \n You\u2019re going to bind the psp-default ClusterRole to all authenticated users, not\nonly to Alice. This is necessary because otherwise no one could create any pods,\nbecause the Admission Control plugin would complain that no policy is in place.\nAuthenticated users all belong to the system:authenticated group, so you\u2019ll bind\nthe ClusterRole to the group:\n$ kubectl create clusterrolebinding psp-all-users \n\u27a5 --clusterrole=psp-default --group=system:authenticated\nclusterrolebinding \"psp-all-users\" created\n \n", "shape": "dot", "size": 10, "title": "397\nRestricting the use of security-related features in pods\nAs you can see in the PRIV column, the default policy doesn\u2019t allow running privi-\nleged containers, whereas the privileged policy does. Because you\u2019re currently\nlogged in as a cluster-admin, you can see all the policies. When creating pods, if any\npolicy allows you to deploy a pod with certain features, the API server will accept\nyour pod.\n Now imagine two additional users are using your cluster: Alice and Bob. You want\nAlice to only deploy restricted (non-privileged) pods, but you want to allow Bob to\nalso deploy privileged pods. You do this by making sure Alice can only use the default\nPodSecurityPolicy, while allowing Bob to use both.\nUSING RBAC TO ASSIGN DIFFERENT PODSECURITYPOLICIES TO DIFFERENT USERS\nIn the previous chapter, you used RBAC to grant users access to only certain resource\ntypes, but I mentioned that access can be granted to specific resource instances by ref-\nerencing them by name. That\u2019s what you\u2019ll use to make users use different Pod-\nSecurityPolicy resources.\n First, you\u2019ll create two ClusterRoles, each allowing the use of one of the policies.\nYou\u2019ll call the first one psp-default and in it allow the use of the default Pod-\nSecurityPolicy resource. You can use kubectl create clusterrole to do that:\n$ kubectl create clusterrole psp-default --verb=use \n\u27a5  --resource=podsecuritypolicies --resource-name=default\nclusterrole \"psp-default\" created\nNOTE\nYou\u2019re using the special verb use instead of get, list, watch, or similar.\nAs you can see, you\u2019re referring to a specific instance of a PodSecurityPolicy resource by\nusing the --resource-name option. Now, create another ClusterRole called psp-\nprivileged, pointing to the privileged policy:\n$ kubectl create clusterrole psp-privileged --verb=use\n\u27a5  --resource=podsecuritypolicies --resource-name=privileged\nclusterrole \"psp-privileged\" created\nNow, you need to bind these two policies to users. As you may remember from the pre-\nvious chapter, if you\u2019re binding a ClusterRole that grants access to cluster-level\nresources (which is what PodSecurityPolicy resources are), you need to use a Cluster-\nRoleBinding instead of a (namespaced) RoleBinding. \n You\u2019re going to bind the psp-default ClusterRole to all authenticated users, not\nonly to Alice. This is necessary because otherwise no one could create any pods,\nbecause the Admission Control plugin would complain that no policy is in place.\nAuthenticated users all belong to the system:authenticated group, so you\u2019ll bind\nthe ClusterRole to the group:\n$ kubectl create clusterrolebinding psp-all-users \n\u27a5 --clusterrole=psp-default --group=system:authenticated\nclusterrolebinding \"psp-all-users\" created\n \n"}, {"color": "green", "id": "text_341", "label": "398\nCHAPTER 13\nSecuring cluster nodes and the network\nYou\u2019ll bind the psp-privileged ClusterRole only to Bob:\n$ kubectl create clusterrolebinding psp-bob \n\u27a5 --clusterrole=psp-privileged --user=bob\nclusterrolebinding \"psp-bob\" created\nAs an authenticated user, Alice should now have access to the default PodSecurity-\nPolicy, whereas Bob should have access to both the default and the privileged Pod-\nSecurityPolicies. Alice shouldn\u2019t be able to create privileged pods, whereas Bob\nshould. Let\u2019s see if that\u2019s true.\nCREATING ADDITIONAL USERS FOR KUBECTL\nBut how do you authenticate as Alice or Bob instead of whatever you\u2019re authenticated\nas currently? The book\u2019s appendix A explains how kubectl can be used with multiple\nclusters, but also with multiple contexts. A context includes the user credentials used\nfor talking to a cluster. Turn to appendix A to find out more. Here we\u2019ll show the bare\ncommands enabling you to use kubectl as Alice or Bob. \n First, you\u2019ll create two new users in kubectl\u2019s config with the following two\ncommands:\n$ kubectl config set-credentials alice --username=alice --password=password\nUser \"alice\" set.\n$ kubectl config set-credentials bob --username=bob --password=password\nUser \"bob\" set.\nIt should be obvious what the commands do. Because you\u2019re setting username and\npassword credentials, kubectl will use basic HTTP authentication for these two users\n(other authentication methods include tokens, client certificates, and so on).\nCREATING PODS AS A DIFFERENT USER\nYou can now try creating a privileged pod while authenticating as Alice. You can tell\nkubectl which user credentials to use by using the --user option:\n$ kubectl --user alice create -f pod-privileged.yaml\nError from server (Forbidden): error when creating \"pod-privileged.yaml\": \npods \"pod-privileged\" is forbidden: unable to validate against any pod \nsecurity policy: [spec.containers[0].securityContext.privileged: Invalid \nvalue: true: Privileged containers are not allowed]\nAs expected, the API server doesn\u2019t allow Alice to create privileged pods. Now, let\u2019s see\nif it allows Bob to do that:\n$ kubectl --user bob create -f pod-privileged.yaml\npod \"pod-privileged\" created\n \n", "shape": "dot", "size": 10, "title": "398\nCHAPTER 13\nSecuring cluster nodes and the network\nYou\u2019ll bind the psp-privileged ClusterRole only to Bob:\n$ kubectl create clusterrolebinding psp-bob \n\u27a5 --clusterrole=psp-privileged --user=bob\nclusterrolebinding \"psp-bob\" created\nAs an authenticated user, Alice should now have access to the default PodSecurity-\nPolicy, whereas Bob should have access to both the default and the privileged Pod-\nSecurityPolicies. Alice shouldn\u2019t be able to create privileged pods, whereas Bob\nshould. Let\u2019s see if that\u2019s true.\nCREATING ADDITIONAL USERS FOR KUBECTL\nBut how do you authenticate as Alice or Bob instead of whatever you\u2019re authenticated\nas currently? The book\u2019s appendix A explains how kubectl can be used with multiple\nclusters, but also with multiple contexts. A context includes the user credentials used\nfor talking to a cluster. Turn to appendix A to find out more. Here we\u2019ll show the bare\ncommands enabling you to use kubectl as Alice or Bob. \n First, you\u2019ll create two new users in kubectl\u2019s config with the following two\ncommands:\n$ kubectl config set-credentials alice --username=alice --password=password\nUser \"alice\" set.\n$ kubectl config set-credentials bob --username=bob --password=password\nUser \"bob\" set.\nIt should be obvious what the commands do. Because you\u2019re setting username and\npassword credentials, kubectl will use basic HTTP authentication for these two users\n(other authentication methods include tokens, client certificates, and so on).\nCREATING PODS AS A DIFFERENT USER\nYou can now try creating a privileged pod while authenticating as Alice. You can tell\nkubectl which user credentials to use by using the --user option:\n$ kubectl --user alice create -f pod-privileged.yaml\nError from server (Forbidden): error when creating \"pod-privileged.yaml\": \npods \"pod-privileged\" is forbidden: unable to validate against any pod \nsecurity policy: [spec.containers[0].securityContext.privileged: Invalid \nvalue: true: Privileged containers are not allowed]\nAs expected, the API server doesn\u2019t allow Alice to create privileged pods. Now, let\u2019s see\nif it allows Bob to do that:\n$ kubectl --user bob create -f pod-privileged.yaml\npod \"pod-privileged\" created\n \n"}, {"color": "green", "id": "text_342", "label": "399\nIsolating the pod network\nAnd there you go. You\u2019ve successfully used RBAC to make the Admission Control\nplugin use different PodSecurityPolicy resources for different users.\n13.4\nIsolating the pod network\nUp to now in this chapter, we\u2019ve explored many security-related configuration options\nthat apply to individual pods and their containers. In the remainder of this chapter,\nwe\u2019ll look at how the network between pods can be secured by limiting which pods can\ntalk to which pods.\n Whether this is configurable or not depends on which container networking\nplugin is used in the cluster. If the networking plugin supports it, you can configure\nnetwork isolation by creating NetworkPolicy resources. \n A NetworkPolicy applies to pods that match its label selector and specifies either\nwhich sources can access the matched pods or which destinations can be accessed\nfrom the matched pods. This is configured through ingress and egress rules, respec-\ntively. Both types of rules can match only the pods that match a pod selector, all\npods in a namespace whose labels match a namespace selector, or a network IP\nblock specified using Classless Inter-Domain Routing (CIDR) notation (for example,\n192.168.1.0/24). \n We\u2019ll look at both ingress and egress rules and all three matching options.\nNOTE\nIngress rules in a NetworkPolicy have nothing to do with the Ingress\nresource discussed in chapter 5.\n13.4.1 Enabling network isolation in a namespace\nBy default, pods in a given namespace can be accessed by anyone. First, you\u2019ll need\nto change that. You\u2019ll create a default-deny NetworkPolicy, which will prevent all\nclients from connecting to any pod in your namespace. The NetworkPolicy defini-\ntion is shown in the following listing.\napiVersion: networking.k8s.io/v1\nkind: NetworkPolicy\nmetadata:\n  name: default-deny\nspec:\n  podSelector:        \nWhen you create this NetworkPolicy in a certain namespace, no one can connect to\nany pod in that namespace. \n \n \n \nListing 13.21\nA default-deny NetworkPolicy: network-policy-default-deny.yaml\nEmpty pod selector \nmatches all pods in the \nsame namespace\n \n", "shape": "dot", "size": 10, "title": "399\nIsolating the pod network\nAnd there you go. You\u2019ve successfully used RBAC to make the Admission Control\nplugin use different PodSecurityPolicy resources for different users.\n13.4\nIsolating the pod network\nUp to now in this chapter, we\u2019ve explored many security-related configuration options\nthat apply to individual pods and their containers. In the remainder of this chapter,\nwe\u2019ll look at how the network between pods can be secured by limiting which pods can\ntalk to which pods.\n Whether this is configurable or not depends on which container networking\nplugin is used in the cluster. If the networking plugin supports it, you can configure\nnetwork isolation by creating NetworkPolicy resources. \n A NetworkPolicy applies to pods that match its label selector and specifies either\nwhich sources can access the matched pods or which destinations can be accessed\nfrom the matched pods. This is configured through ingress and egress rules, respec-\ntively. Both types of rules can match only the pods that match a pod selector, all\npods in a namespace whose labels match a namespace selector, or a network IP\nblock specified using Classless Inter-Domain Routing (CIDR) notation (for example,\n192.168.1.0/24). \n We\u2019ll look at both ingress and egress rules and all three matching options.\nNOTE\nIngress rules in a NetworkPolicy have nothing to do with the Ingress\nresource discussed in chapter 5.\n13.4.1 Enabling network isolation in a namespace\nBy default, pods in a given namespace can be accessed by anyone. First, you\u2019ll need\nto change that. You\u2019ll create a default-deny NetworkPolicy, which will prevent all\nclients from connecting to any pod in your namespace. The NetworkPolicy defini-\ntion is shown in the following listing.\napiVersion: networking.k8s.io/v1\nkind: NetworkPolicy\nmetadata:\n  name: default-deny\nspec:\n  podSelector:        \nWhen you create this NetworkPolicy in a certain namespace, no one can connect to\nany pod in that namespace. \n \n \n \nListing 13.21\nA default-deny NetworkPolicy: network-policy-default-deny.yaml\nEmpty pod selector \nmatches all pods in the \nsame namespace\n \n"}, {"color": "green", "id": "text_343", "label": "400\nCHAPTER 13\nSecuring cluster nodes and the network\nNOTE\nThe CNI plugin or other type of networking solution used in the clus-\nter must support NetworkPolicy, or else there will be no effect on inter-pod\nconnectivity.\n13.4.2 Allowing only some pods in the namespace to connect to \na server pod\nTo let clients connect to the pods in the namespace, you must now explicitly say who\ncan connect to the pods. By who I mean which pods. Let\u2019s explore how to do this\nthrough an example. \n Imagine having a PostgreSQL database pod running in namespace foo and a web-\nserver pod that uses the database. Other pods are also in the namespace, and you\ndon\u2019t want to allow them to connect to the database. To secure the network, you need\nto create the NetworkPolicy resource shown in the following listing in the same name-\nspace as the database pod.\napiVersion: networking.k8s.io/v1\nkind: NetworkPolicy\nmetadata:\n  name: postgres-netpolicy\nspec:\n  podSelector:                     \n    matchLabels:                   \n      app: database                \n  ingress:                           \n  - from:                            \n    - podSelector:                   \n        matchLabels:                 \n          app: webserver             \n    ports:                     \n    - port: 5432               \nThe example NetworkPolicy allows pods with the app=webserver label to connect to\npods with the app=database label, and only on port 5432. Other pods can\u2019t connect to\nthe database pods, and no one (not even the webserver pods) can connect to anything\nother than port 5432 of the database pods. This is shown in figure 13.4.\n Client pods usually connect to server pods through a Service instead of directly to\nthe pod, but that doesn\u2019t change anything. The NetworkPolicy is enforced when con-\nnecting through a Service, as well.\n \n \n \n \nListing 13.22\nA NetworkPolicy for the Postgres pod: network-policy-postgres.yaml\nThis policy secures \naccess to pods with \napp=database label.\nIt allows incoming connections \nonly from pods with the \napp=webserver label.\nConnections to this \nport are allowed.\n \n", "shape": "dot", "size": 10, "title": "400\nCHAPTER 13\nSecuring cluster nodes and the network\nNOTE\nThe CNI plugin or other type of networking solution used in the clus-\nter must support NetworkPolicy, or else there will be no effect on inter-pod\nconnectivity.\n13.4.2 Allowing only some pods in the namespace to connect to \na server pod\nTo let clients connect to the pods in the namespace, you must now explicitly say who\ncan connect to the pods. By who I mean which pods. Let\u2019s explore how to do this\nthrough an example. \n Imagine having a PostgreSQL database pod running in namespace foo and a web-\nserver pod that uses the database. Other pods are also in the namespace, and you\ndon\u2019t want to allow them to connect to the database. To secure the network, you need\nto create the NetworkPolicy resource shown in the following listing in the same name-\nspace as the database pod.\napiVersion: networking.k8s.io/v1\nkind: NetworkPolicy\nmetadata:\n  name: postgres-netpolicy\nspec:\n  podSelector:                     \n    matchLabels:                   \n      app: database                \n  ingress:                           \n  - from:                            \n    - podSelector:                   \n        matchLabels:                 \n          app: webserver             \n    ports:                     \n    - port: 5432               \nThe example NetworkPolicy allows pods with the app=webserver label to connect to\npods with the app=database label, and only on port 5432. Other pods can\u2019t connect to\nthe database pods, and no one (not even the webserver pods) can connect to anything\nother than port 5432 of the database pods. This is shown in figure 13.4.\n Client pods usually connect to server pods through a Service instead of directly to\nthe pod, but that doesn\u2019t change anything. The NetworkPolicy is enforced when con-\nnecting through a Service, as well.\n \n \n \n \nListing 13.22\nA NetworkPolicy for the Postgres pod: network-policy-postgres.yaml\nThis policy secures \naccess to pods with \napp=database label.\nIt allows incoming connections \nonly from pods with the \napp=webserver label.\nConnections to this \nport are allowed.\n \n"}, {"color": "green", "id": "text_344", "label": "401\nIsolating the pod network\n13.4.3 Isolating the network between Kubernetes namespaces\nNow let\u2019s look at another example, where multiple tenants are using the same Kuber-\nnetes cluster. Each tenant can use multiple namespaces, and each namespace has a\nlabel specifying the tenant it belongs to. For example, one of those tenants is Man-\nning. All their namespaces have been labeled with tenant: manning. In one of their\nnamespaces, they run a Shopping Cart microservice that needs to be available to all\npods running in any of their namespaces. Obviously, they don\u2019t want any other tenants\nto access their microservice.\n To secure their microservice, they create the NetworkPolicy resource shown in the\nfollowing listing.\napiVersion: networking.k8s.io/v1\nkind: NetworkPolicy\nmetadata:\n  name: shoppingcart-netpolicy\nspec:\n  podSelector:                       \n    matchLabels:                     \n      app: shopping-cart             \n  ingress:\n  - from:\n    - namespaceSelector:            \n        matchLabels:                \n          tenant: manning           \n    ports:\n    - port: 80\nListing 13.23\nNetworkPolicy for the shopping cart pod(s): network-policy-cart.yaml\napp: database\nPod:\ndatabase\nPort\n5432\nPort\n9876\napp: webserver\nPod:\nwebserver\nPod selector:\napp=webserver\nPod selector:\napp=database\napp: webserver\nPod:\nwebserver\nOther pods\nNetworkPolicy: postgres-netpolicy\nFigure 13.4\nA NetworkPolicy allowing only some pods to access other pods and only on a specific \nport\nThis policy applies to pods \nlabeled as microservice= \nshopping-cart.\nOnly pods running in namespaces \nlabeled as tenant=manning are \nallowed to access the microservice.\n \n", "shape": "dot", "size": 10, "title": "401\nIsolating the pod network\n13.4.3 Isolating the network between Kubernetes namespaces\nNow let\u2019s look at another example, where multiple tenants are using the same Kuber-\nnetes cluster. Each tenant can use multiple namespaces, and each namespace has a\nlabel specifying the tenant it belongs to. For example, one of those tenants is Man-\nning. All their namespaces have been labeled with tenant: manning. In one of their\nnamespaces, they run a Shopping Cart microservice that needs to be available to all\npods running in any of their namespaces. Obviously, they don\u2019t want any other tenants\nto access their microservice.\n To secure their microservice, they create the NetworkPolicy resource shown in the\nfollowing listing.\napiVersion: networking.k8s.io/v1\nkind: NetworkPolicy\nmetadata:\n  name: shoppingcart-netpolicy\nspec:\n  podSelector:                       \n    matchLabels:                     \n      app: shopping-cart             \n  ingress:\n  - from:\n    - namespaceSelector:            \n        matchLabels:                \n          tenant: manning           \n    ports:\n    - port: 80\nListing 13.23\nNetworkPolicy for the shopping cart pod(s): network-policy-cart.yaml\napp: database\nPod:\ndatabase\nPort\n5432\nPort\n9876\napp: webserver\nPod:\nwebserver\nPod selector:\napp=webserver\nPod selector:\napp=database\napp: webserver\nPod:\nwebserver\nOther pods\nNetworkPolicy: postgres-netpolicy\nFigure 13.4\nA NetworkPolicy allowing only some pods to access other pods and only on a specific \nport\nThis policy applies to pods \nlabeled as microservice= \nshopping-cart.\nOnly pods running in namespaces \nlabeled as tenant=manning are \nallowed to access the microservice.\n \n"}, {"color": "green", "id": "text_345", "label": "402\nCHAPTER 13\nSecuring cluster nodes and the network\nThis NetworkPolicy ensures only pods running in namespaces labeled as tenant:\nmanning can access their Shopping Cart microservice, as shown in figure 13.5.\nIf the shopping cart provider also wants to give access to other tenants (perhaps to\none of their partner companies), they can either create an additional NetworkPolicy\nresource or add an additional ingress rule to their existing NetworkPolicy.\nNOTE\nIn a multi-tenant Kubernetes cluster, tenants usually can\u2019t add labels\n(or annotations) to their namespaces themselves. If they could, they\u2019d be able\nto circumvent the namespaceSelector-based ingress rules.\n13.4.4 Isolating using CIDR notation\nInstead of specifying a pod- or namespace selector to define who can access the pods\ntargeted in the NetworkPolicy, you can also specify an IP block in CIDR notation. For\nexample, to allow the shopping-cart pods from the previous section to only be acces-\nsible from IPs in the 192.168.1.1 to .255 range, you\u2019d specify the ingress rule in the\nnext listing.\n  ingress:\n  - from:\n    - ipBlock:                    \n        cidr: 192.168.1.0/24      \nListing 13.24\nSpecifying an IP block in an ingress rule: network-policy-cidr.yaml\napp: shopping-cart\nPod:\nshopping-cart\nPort\n80\nNamespace selector:\ntenant=manning\nPod selector:\napp=shopping-cart\nOther pods\nPods\nNetworkPolicy:\nshoppingcart-netpolicy\nNamespace: manningA\nNamespace: ecommerce-ltd\nOther namespaces\ntenant: manning\nPods\nNamespace: manningB\ntenant: manning\nFigure 13.5\nA NetworkPolicy only allowing pods in namespaces matching a namespaceSelector to access a \nspecific pod.\nThis ingress rule only allows traffic from \nclients in the 192.168.1.0/24 IP block. \n \n", "shape": "dot", "size": 10, "title": "402\nCHAPTER 13\nSecuring cluster nodes and the network\nThis NetworkPolicy ensures only pods running in namespaces labeled as tenant:\nmanning can access their Shopping Cart microservice, as shown in figure 13.5.\nIf the shopping cart provider also wants to give access to other tenants (perhaps to\none of their partner companies), they can either create an additional NetworkPolicy\nresource or add an additional ingress rule to their existing NetworkPolicy.\nNOTE\nIn a multi-tenant Kubernetes cluster, tenants usually can\u2019t add labels\n(or annotations) to their namespaces themselves. If they could, they\u2019d be able\nto circumvent the namespaceSelector-based ingress rules.\n13.4.4 Isolating using CIDR notation\nInstead of specifying a pod- or namespace selector to define who can access the pods\ntargeted in the NetworkPolicy, you can also specify an IP block in CIDR notation. For\nexample, to allow the shopping-cart pods from the previous section to only be acces-\nsible from IPs in the 192.168.1.1 to .255 range, you\u2019d specify the ingress rule in the\nnext listing.\n  ingress:\n  - from:\n    - ipBlock:                    \n        cidr: 192.168.1.0/24      \nListing 13.24\nSpecifying an IP block in an ingress rule: network-policy-cidr.yaml\napp: shopping-cart\nPod:\nshopping-cart\nPort\n80\nNamespace selector:\ntenant=manning\nPod selector:\napp=shopping-cart\nOther pods\nPods\nNetworkPolicy:\nshoppingcart-netpolicy\nNamespace: manningA\nNamespace: ecommerce-ltd\nOther namespaces\ntenant: manning\nPods\nNamespace: manningB\ntenant: manning\nFigure 13.5\nA NetworkPolicy only allowing pods in namespaces matching a namespaceSelector to access a \nspecific pod.\nThis ingress rule only allows traffic from \nclients in the 192.168.1.0/24 IP block. \n \n"}, {"color": "green", "id": "text_346", "label": "403\nSummary\n13.4.5 Limiting the outbound traffic of a set of pods\nIn all previous examples, you\u2019ve been limiting the inbound traffic to the pods that\nmatch the NetworkPolicy\u2019s pod selector using ingress rules, but you can also limit\ntheir outbound traffic through egress rules. An example is shown in the next listing.\nspec:\n  podSelector:               \n    matchLabels:             \n      app: webserver         \n  egress:               \n  - to:                       \n    - podSelector:            \n        matchLabels:          \n          app: database       \nThe NetworkPolicy in the previous listing allows pods that have the app=webserver\nlabel to only access pods that have the app=database label and nothing else (neither\nother pods, nor any other IP, regardless of whether it\u2019s internal or external to the\ncluster).\n13.5\nSummary\nIn this chapter, you learned about securing cluster nodes from pods and pods from\nother pods. You learned that\n\uf0a1Pods can use the node\u2019s Linux namespaces instead of using their own.\n\uf0a1Containers can be configured to run as a different user and/or group than the\none defined in the container image.\n\uf0a1Containers can also run in privileged mode, allowing them to access the node\u2019s\ndevices that are otherwise not exposed to pods.\n\uf0a1Containers can be run as read-only, preventing processes from writing to the\ncontainer\u2019s filesystem (and only allowing them to write to mounted volumes).\n\uf0a1Cluster-level PodSecurityPolicy resources can be created to prevent users from\ncreating pods that could compromise a node.\n\uf0a1PodSecurityPolicy resources can be associated with specific users using RBAC\u2019s\nClusterRoles and ClusterRoleBindings.\n\uf0a1NetworkPolicy resources are used to limit a pod\u2019s inbound and/or outbound\ntraffic.\nIn the next chapter, you\u2019ll learn how computational resources available to pods can be\nconstrained and how a pod\u2019s quality of service is configured.\nListing 13.25\nUsing egress rules in a NetworkPolicy: network-policy-egress.yaml\nThis policy applies to pods with \nthe app=webserver label.\nIt limits\nthe pods\u2019\noutbound\ntraffic.\nWebserver pods may only \nconnect to pods with the \napp=database label.\n \n", "shape": "dot", "size": 10, "title": "403\nSummary\n13.4.5 Limiting the outbound traffic of a set of pods\nIn all previous examples, you\u2019ve been limiting the inbound traffic to the pods that\nmatch the NetworkPolicy\u2019s pod selector using ingress rules, but you can also limit\ntheir outbound traffic through egress rules. An example is shown in the next listing.\nspec:\n  podSelector:               \n    matchLabels:             \n      app: webserver         \n  egress:               \n  - to:                       \n    - podSelector:            \n        matchLabels:          \n          app: database       \nThe NetworkPolicy in the previous listing allows pods that have the app=webserver\nlabel to only access pods that have the app=database label and nothing else (neither\nother pods, nor any other IP, regardless of whether it\u2019s internal or external to the\ncluster).\n13.5\nSummary\nIn this chapter, you learned about securing cluster nodes from pods and pods from\nother pods. You learned that\n\uf0a1Pods can use the node\u2019s Linux namespaces instead of using their own.\n\uf0a1Containers can be configured to run as a different user and/or group than the\none defined in the container image.\n\uf0a1Containers can also run in privileged mode, allowing them to access the node\u2019s\ndevices that are otherwise not exposed to pods.\n\uf0a1Containers can be run as read-only, preventing processes from writing to the\ncontainer\u2019s filesystem (and only allowing them to write to mounted volumes).\n\uf0a1Cluster-level PodSecurityPolicy resources can be created to prevent users from\ncreating pods that could compromise a node.\n\uf0a1PodSecurityPolicy resources can be associated with specific users using RBAC\u2019s\nClusterRoles and ClusterRoleBindings.\n\uf0a1NetworkPolicy resources are used to limit a pod\u2019s inbound and/or outbound\ntraffic.\nIn the next chapter, you\u2019ll learn how computational resources available to pods can be\nconstrained and how a pod\u2019s quality of service is configured.\nListing 13.25\nUsing egress rules in a NetworkPolicy: network-policy-egress.yaml\nThis policy applies to pods with \nthe app=webserver label.\nIt limits\nthe pods\u2019\noutbound\ntraffic.\nWebserver pods may only \nconnect to pods with the \napp=database label.\n \n"}, {"color": "green", "id": "text_347", "label": "404\nManaging pods\u2019\n computational resources\nUp to now you\u2019ve created pods without caring about how much CPU and memory\nthey\u2019re allowed to consume. But as you\u2019ll see in this chapter, setting both how\nmuch a pod is expected to consume and the maximum amount it\u2019s allowed to con-\nsume is a vital part of any pod definition. Setting these two sets of parameters\nmakes sure that a pod takes only its fair share of the resources provided by the\nKubernetes cluster and also affects how pods are scheduled across the cluster.\nThis chapter covers\n\uf0a1Requesting CPU, memory, and other \ncomputational resources for containers\n\uf0a1Setting a hard limit for CPU and memory\n\uf0a1Understanding Quality of Service guarantees for \npods\n\uf0a1Setting default, min, and max resources for pods \nin a namespace\n\uf0a1Limiting the total amount of resources available \nin a namespace\n \n", "shape": "dot", "size": 10, "title": "404\nManaging pods\u2019\n computational resources\nUp to now you\u2019ve created pods without caring about how much CPU and memory\nthey\u2019re allowed to consume. But as you\u2019ll see in this chapter, setting both how\nmuch a pod is expected to consume and the maximum amount it\u2019s allowed to con-\nsume is a vital part of any pod definition. Setting these two sets of parameters\nmakes sure that a pod takes only its fair share of the resources provided by the\nKubernetes cluster and also affects how pods are scheduled across the cluster.\nThis chapter covers\n\uf0a1Requesting CPU, memory, and other \ncomputational resources for containers\n\uf0a1Setting a hard limit for CPU and memory\n\uf0a1Understanding Quality of Service guarantees for \npods\n\uf0a1Setting default, min, and max resources for pods \nin a namespace\n\uf0a1Limiting the total amount of resources available \nin a namespace\n \n"}, {"color": "green", "id": "text_348", "label": "405\nRequesting resources for a pod\u2019s containers\n14.1\nRequesting resources for a pod\u2019s containers\nWhen creating a pod, you can specify the amount of CPU and memory that a con-\ntainer needs (these are called requests) and a hard limit on what it may consume\n(known as limits). They\u2019re specified for each container individually, not for the pod as\na whole. The pod\u2019s resource requests and limits are the sum of the requests and lim-\nits of all its containers. \n14.1.1 Creating pods with resource requests\nLet\u2019s look at an example pod manifest, which has the CPU and memory requests spec-\nified for its single container, as shown in the following listing.\napiVersion: v1\nkind: Pod\nmetadata:\n  name: requests-pod\nspec:\n  containers:\n  - image: busybox\n    command: [\"dd\", \"if=/dev/zero\", \"of=/dev/null\"]\n    name: main              \n    resources:              \n      requests:             \n        cpu: 200m          \n        memory: 10Mi    \nIn the pod manifest, your single container requires one-fifth of a CPU core (200 mil-\nlicores) to run properly. Five such pods/containers can run sufficiently fast on a single\nCPU core. \n When you don\u2019t specify a request for CPU, you\u2019re saying you don\u2019t care how much\nCPU time the process running in your container is allotted. In the worst case, it may\nnot get any CPU time at all (this happens when a heavy demand by other processes\nexists on the CPU). Although this may be fine for low-priority batch jobs, which aren\u2019t\ntime-critical, it obviously isn\u2019t appropriate for containers handling user requests.\n In the pod spec, you\u2019re also requesting 10 mebibytes of memory for the container.\nBy doing that, you\u2019re saying that you expect the processes running inside the con-\ntainer to use at most 10 mebibytes of RAM. They might use less, but you\u2019re not expect-\ning them to use more than that in normal circumstances. Later in this chapter you\u2019ll\nsee what happens if they do.\n Now you\u2019ll run the pod. When the pod starts, you can take a quick look at the pro-\ncess\u2019 CPU consumption by running the top command inside the container, as shown\nin the following listing.\nListing 14.1\nA pod with resource requests: requests-pod.yaml\nYou\u2019re specifying resource \nrequests for the main container.\nThe container requests 200 \nmillicores (that is, 1/5 of a \nsingle CPU core\u2019s time).\nThe container also\nrequests 10 mebibytes\nof memory.\n \n", "shape": "dot", "size": 10, "title": "405\nRequesting resources for a pod\u2019s containers\n14.1\nRequesting resources for a pod\u2019s containers\nWhen creating a pod, you can specify the amount of CPU and memory that a con-\ntainer needs (these are called requests) and a hard limit on what it may consume\n(known as limits). They\u2019re specified for each container individually, not for the pod as\na whole. The pod\u2019s resource requests and limits are the sum of the requests and lim-\nits of all its containers. \n14.1.1 Creating pods with resource requests\nLet\u2019s look at an example pod manifest, which has the CPU and memory requests spec-\nified for its single container, as shown in the following listing.\napiVersion: v1\nkind: Pod\nmetadata:\n  name: requests-pod\nspec:\n  containers:\n  - image: busybox\n    command: [\"dd\", \"if=/dev/zero\", \"of=/dev/null\"]\n    name: main              \n    resources:              \n      requests:             \n        cpu: 200m          \n        memory: 10Mi    \nIn the pod manifest, your single container requires one-fifth of a CPU core (200 mil-\nlicores) to run properly. Five such pods/containers can run sufficiently fast on a single\nCPU core. \n When you don\u2019t specify a request for CPU, you\u2019re saying you don\u2019t care how much\nCPU time the process running in your container is allotted. In the worst case, it may\nnot get any CPU time at all (this happens when a heavy demand by other processes\nexists on the CPU). Although this may be fine for low-priority batch jobs, which aren\u2019t\ntime-critical, it obviously isn\u2019t appropriate for containers handling user requests.\n In the pod spec, you\u2019re also requesting 10 mebibytes of memory for the container.\nBy doing that, you\u2019re saying that you expect the processes running inside the con-\ntainer to use at most 10 mebibytes of RAM. They might use less, but you\u2019re not expect-\ning them to use more than that in normal circumstances. Later in this chapter you\u2019ll\nsee what happens if they do.\n Now you\u2019ll run the pod. When the pod starts, you can take a quick look at the pro-\ncess\u2019 CPU consumption by running the top command inside the container, as shown\nin the following listing.\nListing 14.1\nA pod with resource requests: requests-pod.yaml\nYou\u2019re specifying resource \nrequests for the main container.\nThe container requests 200 \nmillicores (that is, 1/5 of a \nsingle CPU core\u2019s time).\nThe container also\nrequests 10 mebibytes\nof memory.\n \n"}, {"color": "green", "id": "text_349", "label": "406\nCHAPTER 14\nManaging pods\u2019 computational resources\n$ kubectl exec -it requests-pod top\nMem: 1288116K used, 760368K free, 9196K shrd, 25748K buff, 814840K cached\nCPU:  9.1% usr 42.1% sys  0.0% nic 48.4% idle  0.0% io  0.0% irq  0.2% sirq\nLoad average: 0.79 0.52 0.29 2/481 10\n  PID  PPID USER     STAT   VSZ %VSZ CPU %CPU COMMAND\n    1     0 root     R     1192  0.0   1 50.2 dd if /dev/zero of /dev/null\n    7     0 root     R     1200  0.0   0  0.0 top\nThe dd command you\u2019re running in the container consumes as much CPU as it can,\nbut it only runs a single thread so it can only use a single core. The Minikube VM,\nwhich is where this example is running, has two CPU cores allotted to it. That\u2019s why\nthe process is shown consuming 50% of the whole CPU. \n Fifty percent of two cores is obviously one whole core, which means the container\nis using more than the 200 millicores you requested in the pod specification. This is\nexpected, because requests don\u2019t limit the amount of CPU a container can use. You\u2019d\nneed to specify a CPU limit to do that. You\u2019ll try that later, but first, let\u2019s see how spec-\nifying resource requests in a pod affects the scheduling of the pod.\n14.1.2 Understanding how resource requests affect scheduling\nBy specifying resource requests, you\u2019re specifying the minimum amount of resources\nyour pod needs. This information is what the Scheduler uses when scheduling the pod\nto a node. Each node has a certain amount of CPU and memory it can allocate to\npods. When scheduling a pod, the Scheduler will only consider nodes with enough\nunallocated resources to meet the pod\u2019s resource requirements. If the amount of\nunallocated CPU or memory is less than what the pod requests, Kubernetes will not\nschedule the pod to that node, because the node can\u2019t provide the minimum amount\nrequired by the pod.\nUNDERSTANDING HOW THE SCHEDULER DETERMINES IF A POD CAN FIT ON A NODE\nWhat\u2019s important and somewhat surprising here is that the Scheduler doesn\u2019t look at\nhow much of each individual resource is being used at the exact time of scheduling\nbut at the sum of resources requested by the existing pods deployed on the node.\nEven though existing pods may be using less than what they\u2019ve requested, scheduling\nanother pod based on actual resource consumption would break the guarantee given\nto the already deployed pods.\n This is visualized in figure 14.1. Three pods are deployed on the node. Together,\nthey\u2019ve requested 80% of the node\u2019s CPU and 60% of the node\u2019s memory. Pod D,\nshown at the bottom right of the figure, cannot be scheduled onto the node because it\nrequests 25% of the CPU, which is more than the 20% of unallocated CPU. The fact\nthat the three pods are currently using only 70% of the CPU makes no difference.\nListing 14.2\nExamining CPU and memory usage from within a container\n \n", "shape": "dot", "size": 10, "title": "406\nCHAPTER 14\nManaging pods\u2019 computational resources\n$ kubectl exec -it requests-pod top\nMem: 1288116K used, 760368K free, 9196K shrd, 25748K buff, 814840K cached\nCPU:  9.1% usr 42.1% sys  0.0% nic 48.4% idle  0.0% io  0.0% irq  0.2% sirq\nLoad average: 0.79 0.52 0.29 2/481 10\n  PID  PPID USER     STAT   VSZ %VSZ CPU %CPU COMMAND\n    1     0 root     R     1192  0.0   1 50.2 dd if /dev/zero of /dev/null\n    7     0 root     R     1200  0.0   0  0.0 top\nThe dd command you\u2019re running in the container consumes as much CPU as it can,\nbut it only runs a single thread so it can only use a single core. The Minikube VM,\nwhich is where this example is running, has two CPU cores allotted to it. That\u2019s why\nthe process is shown consuming 50% of the whole CPU. \n Fifty percent of two cores is obviously one whole core, which means the container\nis using more than the 200 millicores you requested in the pod specification. This is\nexpected, because requests don\u2019t limit the amount of CPU a container can use. You\u2019d\nneed to specify a CPU limit to do that. You\u2019ll try that later, but first, let\u2019s see how spec-\nifying resource requests in a pod affects the scheduling of the pod.\n14.1.2 Understanding how resource requests affect scheduling\nBy specifying resource requests, you\u2019re specifying the minimum amount of resources\nyour pod needs. This information is what the Scheduler uses when scheduling the pod\nto a node. Each node has a certain amount of CPU and memory it can allocate to\npods. When scheduling a pod, the Scheduler will only consider nodes with enough\nunallocated resources to meet the pod\u2019s resource requirements. If the amount of\nunallocated CPU or memory is less than what the pod requests, Kubernetes will not\nschedule the pod to that node, because the node can\u2019t provide the minimum amount\nrequired by the pod.\nUNDERSTANDING HOW THE SCHEDULER DETERMINES IF A POD CAN FIT ON A NODE\nWhat\u2019s important and somewhat surprising here is that the Scheduler doesn\u2019t look at\nhow much of each individual resource is being used at the exact time of scheduling\nbut at the sum of resources requested by the existing pods deployed on the node.\nEven though existing pods may be using less than what they\u2019ve requested, scheduling\nanother pod based on actual resource consumption would break the guarantee given\nto the already deployed pods.\n This is visualized in figure 14.1. Three pods are deployed on the node. Together,\nthey\u2019ve requested 80% of the node\u2019s CPU and 60% of the node\u2019s memory. Pod D,\nshown at the bottom right of the figure, cannot be scheduled onto the node because it\nrequests 25% of the CPU, which is more than the 20% of unallocated CPU. The fact\nthat the three pods are currently using only 70% of the CPU makes no difference.\nListing 14.2\nExamining CPU and memory usage from within a container\n \n"}, {"color": "green", "id": "text_350", "label": "407\nRequesting resources for a pod\u2019s containers\nUNDERSTANDING HOW THE SCHEDULER USES PODS\u2019 REQUESTS WHEN SELECTING THE BEST NODE \nFOR A POD\nYou may remember from chapter 11 that the Scheduler first filters the list of nodes to\nexclude those that the pod can\u2019t fit on and then prioritizes the remaining nodes per the\nconfigured prioritization functions. Among others, two prioritization functions rank\nnodes based on the amount of resources requested: LeastRequestedPriority and\nMostRequestedPriority. The first one prefers nodes with fewer requested resources\n(with a greater amount of unallocated resources), whereas the second one is the exact\nopposite\u2014it prefers nodes that have the most requested resources (a smaller amount of\nunallocated CPU and memory). But, as we\u2019ve discussed, they both consider the amount\nof requested resources, not the amount of resources actually consumed.\n The Scheduler is configured to use only one of those functions. You may wonder\nwhy anyone would want to use the MostRequestedPriority function. After all, if you\nhave a set of nodes, you usually want to spread CPU load evenly across them. However,\nthat\u2019s not the case when running on cloud infrastructure, where you can add and\nremove nodes whenever necessary. By configuring the Scheduler to use the Most-\nRequestedPriority function, you guarantee that Kubernetes will use the smallest pos-\nsible number of nodes while still providing each pod with the amount of CPU/memory\nit requests. By keeping pods tightly packed, certain nodes are left vacant and can be\nremoved. Because you\u2019re paying for individual nodes, this saves you money.\nINSPECTING A NODE\u2019S CAPACITY\nLet\u2019s see the Scheduler in action. You\u2019ll deploy another pod with four times the\namount of requested resources as before. But before you do that, let\u2019s see your node\u2019s\ncapacity. Because the Scheduler needs to know how much CPU and memory each\nnode has, the Kubelet reports this data to the API server, making it available through\nPod C\nNode\nPod A\nUnallocated\nCPU requests\nPod B\nPod A\nCurrently unused\nCPU usage\nPod B\nPod C\n0%\n100%\nPod A\nMemory requests\nPod B\nPod C\nPod A\nMemory usage\nPod B\nPod C\nCPU requests\nMemory requests\nUnallocated\nCurrently unused\nPod D\nPod D cannot be scheduled; its CPU\nrequests exceed unallocated CPU\nFigure 14.1\nThe Scheduler only cares about requests, not actual usage.\n \n", "shape": "dot", "size": 10, "title": "407\nRequesting resources for a pod\u2019s containers\nUNDERSTANDING HOW THE SCHEDULER USES PODS\u2019 REQUESTS WHEN SELECTING THE BEST NODE \nFOR A POD\nYou may remember from chapter 11 that the Scheduler first filters the list of nodes to\nexclude those that the pod can\u2019t fit on and then prioritizes the remaining nodes per the\nconfigured prioritization functions. Among others, two prioritization functions rank\nnodes based on the amount of resources requested: LeastRequestedPriority and\nMostRequestedPriority. The first one prefers nodes with fewer requested resources\n(with a greater amount of unallocated resources), whereas the second one is the exact\nopposite\u2014it prefers nodes that have the most requested resources (a smaller amount of\nunallocated CPU and memory). But, as we\u2019ve discussed, they both consider the amount\nof requested resources, not the amount of resources actually consumed.\n The Scheduler is configured to use only one of those functions. You may wonder\nwhy anyone would want to use the MostRequestedPriority function. After all, if you\nhave a set of nodes, you usually want to spread CPU load evenly across them. However,\nthat\u2019s not the case when running on cloud infrastructure, where you can add and\nremove nodes whenever necessary. By configuring the Scheduler to use the Most-\nRequestedPriority function, you guarantee that Kubernetes will use the smallest pos-\nsible number of nodes while still providing each pod with the amount of CPU/memory\nit requests. By keeping pods tightly packed, certain nodes are left vacant and can be\nremoved. Because you\u2019re paying for individual nodes, this saves you money.\nINSPECTING A NODE\u2019S CAPACITY\nLet\u2019s see the Scheduler in action. You\u2019ll deploy another pod with four times the\namount of requested resources as before. But before you do that, let\u2019s see your node\u2019s\ncapacity. Because the Scheduler needs to know how much CPU and memory each\nnode has, the Kubelet reports this data to the API server, making it available through\nPod C\nNode\nPod A\nUnallocated\nCPU requests\nPod B\nPod A\nCurrently unused\nCPU usage\nPod B\nPod C\n0%\n100%\nPod A\nMemory requests\nPod B\nPod C\nPod A\nMemory usage\nPod B\nPod C\nCPU requests\nMemory requests\nUnallocated\nCurrently unused\nPod D\nPod D cannot be scheduled; its CPU\nrequests exceed unallocated CPU\nFigure 14.1\nThe Scheduler only cares about requests, not actual usage.\n \n"}, {"color": "green", "id": "text_351", "label": "408\nCHAPTER 14\nManaging pods\u2019 computational resources\nthe Node resource. You can see it by using the kubectl describe command as in the\nfollowing listing.\n$ kubectl describe nodes\nName:       minikube\n...\nCapacity:                       \n  cpu:           2               \n  memory:        2048484Ki       \n  pods:          110             \nAllocatable:                       \n  cpu:           2                  \n  memory:        1946084Ki          \n  pods:          110                \n...\nThe output shows two sets of amounts related to the available resources on the node:\nthe node\u2019s capacity and allocatable resources. The capacity represents the total resources\nof a node, which may not all be available to pods. Certain resources may be reserved\nfor Kubernetes and/or system components. The Scheduler bases its decisions only on\nthe allocatable resource amounts.\n In the previous example, the node called minikube runs in a VM with two cores\nand has no CPU reserved, making the whole CPU allocatable to pods. Therefore,\nthe Scheduler should have no problem scheduling another pod requesting 800\nmillicores. \n Run the pod now. You can use the YAML file in the code archive, or run the pod\nwith the kubectl run command like this:\n$ kubectl run requests-pod-2 --image=busybox --restart Never\n\u27a5 --requests=\u0027cpu=800m,memory=20Mi\u0027 -- dd if=/dev/zero of=/dev/null\npod \"requests-pod-2\" created\nLet\u2019s see if it was scheduled:\n$ kubectl get po requests-pod-2\nNAME             READY     STATUS    RESTARTS   AGE\nrequests-pod-2   1/1       Running   0          3m\nOkay, the pod has been scheduled and is running. \nCREATING A POD THAT DOESN\u2019T FIT ON ANY NODE\nYou now have two pods deployed, which together have requested a total of 1,000 mil-\nlicores or exactly 1 core. You should therefore have another 1,000 millicores available\nfor additional pods, right? You can deploy another pod with a resource request of\n1,000 millicores. Use a similar command as before:\n$ kubectl run requests-pod-3 --image=busybox --restart Never\n\u27a5 --requests=\u0027cpu=1,memory=20Mi\u0027 -- dd if=/dev/zero of=/dev/null\npod \"requests-pod-2\" created\nListing 14.3\nA node\u2019s capacity and allocatable resources\nThe overall capacity \nof the node\nThe resources \nallocatable to pods\n \n", "shape": "dot", "size": 10, "title": "408\nCHAPTER 14\nManaging pods\u2019 computational resources\nthe Node resource. You can see it by using the kubectl describe command as in the\nfollowing listing.\n$ kubectl describe nodes\nName:       minikube\n...\nCapacity:                       \n  cpu:           2               \n  memory:        2048484Ki       \n  pods:          110             \nAllocatable:                       \n  cpu:           2                  \n  memory:        1946084Ki          \n  pods:          110                \n...\nThe output shows two sets of amounts related to the available resources on the node:\nthe node\u2019s capacity and allocatable resources. The capacity represents the total resources\nof a node, which may not all be available to pods. Certain resources may be reserved\nfor Kubernetes and/or system components. The Scheduler bases its decisions only on\nthe allocatable resource amounts.\n In the previous example, the node called minikube runs in a VM with two cores\nand has no CPU reserved, making the whole CPU allocatable to pods. Therefore,\nthe Scheduler should have no problem scheduling another pod requesting 800\nmillicores. \n Run the pod now. You can use the YAML file in the code archive, or run the pod\nwith the kubectl run command like this:\n$ kubectl run requests-pod-2 --image=busybox --restart Never\n\u27a5 --requests=\u0027cpu=800m,memory=20Mi\u0027 -- dd if=/dev/zero of=/dev/null\npod \"requests-pod-2\" created\nLet\u2019s see if it was scheduled:\n$ kubectl get po requests-pod-2\nNAME             READY     STATUS    RESTARTS   AGE\nrequests-pod-2   1/1       Running   0          3m\nOkay, the pod has been scheduled and is running. \nCREATING A POD THAT DOESN\u2019T FIT ON ANY NODE\nYou now have two pods deployed, which together have requested a total of 1,000 mil-\nlicores or exactly 1 core. You should therefore have another 1,000 millicores available\nfor additional pods, right? You can deploy another pod with a resource request of\n1,000 millicores. Use a similar command as before:\n$ kubectl run requests-pod-3 --image=busybox --restart Never\n\u27a5 --requests=\u0027cpu=1,memory=20Mi\u0027 -- dd if=/dev/zero of=/dev/null\npod \"requests-pod-2\" created\nListing 14.3\nA node\u2019s capacity and allocatable resources\nThe overall capacity \nof the node\nThe resources \nallocatable to pods\n \n"}, {"color": "green", "id": "text_352", "label": "409\nRequesting resources for a pod\u2019s containers\nNOTE\nThis time you\u2019re specifying the CPU request in whole cores (cpu=1)\ninstead of millicores (cpu=1000m).\nSo far, so good. The pod has been accepted by the API server (you\u2019ll remember from\nthe previous chapter that the API server can reject pods if they\u2019re invalid in any way).\nNow, check if the pod is running:\n$ kubectl get po requests-pod-3\nNAME             READY     STATUS    RESTARTS   AGE\nrequests-pod-3   0/1       Pending   0          4m\nEven if you wait a while, the pod is still stuck at Pending. You can see more informa-\ntion on why that\u2019s the case by using the kubectl describe command, as shown in\nthe following listing.\n$ kubectl describe po requests-pod-3\nName:       requests-pod-3\nNamespace:  default\nNode:       /                    \n...\nConditions:\n  Type           Status\n  PodScheduled   False           \n...\nEvents:\n... Warning  FailedScheduling    No nodes are available      \n                                 that match all of the       \n                                 following predicates::      \n                                 Insufficient cpu (1).       \nThe output shows that the pod hasn\u2019t been scheduled because it can\u2019t fit on any node\ndue to insufficient CPU on your single node. But why is that? The sum of the CPU\nrequests of all three pods equals 2,000 millicores or exactly two cores, which is exactly\nwhat your node can provide. What\u2019s wrong?\nDETERMINING WHY A POD ISN\u2019T BEING SCHEDULED\nYou can figure out why the pod isn\u2019t being scheduled by inspecting the node resource.\nUse the kubectl describe node command again and examine the output more\nclosely in the following listing.\n$ kubectl describe node\nName:                   minikube\n...\nNon-terminated Pods:    (7 in total)\n  Namespace    Name            CPU Requ.   CPU Lim.  Mem Req.    Mem Lim.\n  ---------    ----            ----------  --------  ---------   --------\n  default      requests-pod    200m (10%)  0 (0%)    10Mi (0%)   0 (0%)\nListing 14.4\nExamining why a pod is stuck at Pending with kubectl describe pod\nListing 14.5\nInspecting allocated resources on a node with kubectl describe node\nNo node is \nassociated \nwith the pod.\nThe pod hasn\u2019t \nbeen scheduled.\nScheduling has \nfailed because of \ninsufficient CPU.\n \n", "shape": "dot", "size": 10, "title": "409\nRequesting resources for a pod\u2019s containers\nNOTE\nThis time you\u2019re specifying the CPU request in whole cores (cpu=1)\ninstead of millicores (cpu=1000m).\nSo far, so good. The pod has been accepted by the API server (you\u2019ll remember from\nthe previous chapter that the API server can reject pods if they\u2019re invalid in any way).\nNow, check if the pod is running:\n$ kubectl get po requests-pod-3\nNAME             READY     STATUS    RESTARTS   AGE\nrequests-pod-3   0/1       Pending   0          4m\nEven if you wait a while, the pod is still stuck at Pending. You can see more informa-\ntion on why that\u2019s the case by using the kubectl describe command, as shown in\nthe following listing.\n$ kubectl describe po requests-pod-3\nName:       requests-pod-3\nNamespace:  default\nNode:       /                    \n...\nConditions:\n  Type           Status\n  PodScheduled   False           \n...\nEvents:\n... Warning  FailedScheduling    No nodes are available      \n                                 that match all of the       \n                                 following predicates::      \n                                 Insufficient cpu (1).       \nThe output shows that the pod hasn\u2019t been scheduled because it can\u2019t fit on any node\ndue to insufficient CPU on your single node. But why is that? The sum of the CPU\nrequests of all three pods equals 2,000 millicores or exactly two cores, which is exactly\nwhat your node can provide. What\u2019s wrong?\nDETERMINING WHY A POD ISN\u2019T BEING SCHEDULED\nYou can figure out why the pod isn\u2019t being scheduled by inspecting the node resource.\nUse the kubectl describe node command again and examine the output more\nclosely in the following listing.\n$ kubectl describe node\nName:                   minikube\n...\nNon-terminated Pods:    (7 in total)\n  Namespace    Name            CPU Requ.   CPU Lim.  Mem Req.    Mem Lim.\n  ---------    ----            ----------  --------  ---------   --------\n  default      requests-pod    200m (10%)  0 (0%)    10Mi (0%)   0 (0%)\nListing 14.4\nExamining why a pod is stuck at Pending with kubectl describe pod\nListing 14.5\nInspecting allocated resources on a node with kubectl describe node\nNo node is \nassociated \nwith the pod.\nThe pod hasn\u2019t \nbeen scheduled.\nScheduling has \nfailed because of \ninsufficient CPU.\n \n"}, {"color": "green", "id": "text_353", "label": "410\nCHAPTER 14\nManaging pods\u2019 computational resources\n  default      requests-pod-2  800m (40%)  0 (0%)    20Mi (1%)   0 (0%)\n  kube-system  dflt-http-b...  10m (0%)    10m (0%)  20Mi (1%)   20Mi (1%)\n  kube-system  kube-addon-...  5m (0%)     0 (0%)    50Mi (2%)   0 (0%)\n  kube-system  kube-dns-26...  260m (13%)  0 (0%)    110Mi (5%)  170Mi (8%)\n  kube-system  kubernetes-...  0 (0%)      0 (0%)    0 (0%)      0 (0%)\n  kube-system  nginx-ingre...  0 (0%)      0 (0%)    0 (0%)      0 (0%)\nAllocated resources:\n  (Total limits may be over 100 percent, i.e., overcommitted.)\n  CPU Requests  CPU Limits      Memory Requests Memory Limits\n  ------------  ----------      --------------- -------------\n  1275m (63%)   10m (0%)        210Mi (11%)     190Mi (9%)\nIf you look at the bottom left of the listing, you\u2019ll see a total of 1,275 millicores have\nbeen requested by the running pods, which is 275 millicores more than what you\nrequested for the first two pods you deployed. Something is eating up additional\nCPU resources. \n You can find the culprit in the list of pods in the previous listing. Three pods in the\nkube-system namespace have explicitly requested CPU resources. Those pods plus\nyour two pods leave only 725 millicores available for additional pods. Because your\nthird pod requested 1,000 millicores, the Scheduler won\u2019t schedule it to this node, as\nthat would make the node overcommitted. \nFREEING RESOURCES TO GET THE POD SCHEDULED\nThe pod will only be scheduled when an adequate amount of CPU is freed (when one\nof the first two pods is deleted, for example). If you delete your second pod, the\nScheduler will be notified of the deletion (through the watch mechanism described in\nchapter 11) and will schedule your third pod as soon as the second pod terminates.\nThis is shown in the following listing.\n$ kubectl delete po requests-pod-2\npod \"requests-pod-2\" deleted \n$ kubectl get po\nNAME             READY     STATUS        RESTARTS   AGE\nrequests-pod     1/1       Running       0          2h\nrequests-pod-2   1/1       Terminating   0          1h\nrequests-pod-3   0/1       Pending       0          1h\n$ kubectl get po\nNAME             READY     STATUS    RESTARTS   AGE\nrequests-pod     1/1       Running   0          2h\nrequests-pod-3   1/1       Running   0          1h\nIn all these examples, you\u2019ve specified a request for memory, but it hasn\u2019t played any\nrole in the scheduling because your node has more than enough allocatable memory to\naccommodate all your pods\u2019 requests. Both CPU and memory requests are treated the\nsame way by the Scheduler, but in contrast to memory requests, a pod\u2019s CPU requests\nalso play a role elsewhere\u2014while the pod is running. You\u2019ll learn about this next.\nListing 14.6\nPod is scheduled after deleting another pod\n \n", "shape": "dot", "size": 10, "title": "410\nCHAPTER 14\nManaging pods\u2019 computational resources\n  default      requests-pod-2  800m (40%)  0 (0%)    20Mi (1%)   0 (0%)\n  kube-system  dflt-http-b...  10m (0%)    10m (0%)  20Mi (1%)   20Mi (1%)\n  kube-system  kube-addon-...  5m (0%)     0 (0%)    50Mi (2%)   0 (0%)\n  kube-system  kube-dns-26...  260m (13%)  0 (0%)    110Mi (5%)  170Mi (8%)\n  kube-system  kubernetes-...  0 (0%)      0 (0%)    0 (0%)      0 (0%)\n  kube-system  nginx-ingre...  0 (0%)      0 (0%)    0 (0%)      0 (0%)\nAllocated resources:\n  (Total limits may be over 100 percent, i.e., overcommitted.)\n  CPU Requests  CPU Limits      Memory Requests Memory Limits\n  ------------  ----------      --------------- -------------\n  1275m (63%)   10m (0%)        210Mi (11%)     190Mi (9%)\nIf you look at the bottom left of the listing, you\u2019ll see a total of 1,275 millicores have\nbeen requested by the running pods, which is 275 millicores more than what you\nrequested for the first two pods you deployed. Something is eating up additional\nCPU resources. \n You can find the culprit in the list of pods in the previous listing. Three pods in the\nkube-system namespace have explicitly requested CPU resources. Those pods plus\nyour two pods leave only 725 millicores available for additional pods. Because your\nthird pod requested 1,000 millicores, the Scheduler won\u2019t schedule it to this node, as\nthat would make the node overcommitted. \nFREEING RESOURCES TO GET THE POD SCHEDULED\nThe pod will only be scheduled when an adequate amount of CPU is freed (when one\nof the first two pods is deleted, for example). If you delete your second pod, the\nScheduler will be notified of the deletion (through the watch mechanism described in\nchapter 11) and will schedule your third pod as soon as the second pod terminates.\nThis is shown in the following listing.\n$ kubectl delete po requests-pod-2\npod \"requests-pod-2\" deleted \n$ kubectl get po\nNAME             READY     STATUS        RESTARTS   AGE\nrequests-pod     1/1       Running       0          2h\nrequests-pod-2   1/1       Terminating   0          1h\nrequests-pod-3   0/1       Pending       0          1h\n$ kubectl get po\nNAME             READY     STATUS    RESTARTS   AGE\nrequests-pod     1/1       Running   0          2h\nrequests-pod-3   1/1       Running   0          1h\nIn all these examples, you\u2019ve specified a request for memory, but it hasn\u2019t played any\nrole in the scheduling because your node has more than enough allocatable memory to\naccommodate all your pods\u2019 requests. Both CPU and memory requests are treated the\nsame way by the Scheduler, but in contrast to memory requests, a pod\u2019s CPU requests\nalso play a role elsewhere\u2014while the pod is running. You\u2019ll learn about this next.\nListing 14.6\nPod is scheduled after deleting another pod\n \n"}, {"color": "green", "id": "text_354", "label": "411\nRequesting resources for a pod\u2019s containers\n14.1.3 Understanding how CPU requests affect CPU time sharing\nYou now have two pods running in your cluster (you can disregard the system pods\nright now, because they\u2019re mostly idle). One has requested 200 millicores and the\nother one five times as much. At the beginning of the chapter, we said Kubernetes dis-\ntinguishes between resource requests and limits. You haven\u2019t defined any limits yet, so\nthe two pods are in no way limited when it comes to how much CPU they can each\nconsume. If the process inside each pod consumes as much CPU time as it can, how\nmuch CPU time does each pod get? \n The CPU requests don\u2019t only affect scheduling\u2014they also determine how the\nremaining (unused) CPU time is distributed between pods. Because your first pod\nrequested 200 millicores of CPU and the other one 1,000 millicores, any unused CPU\nwill be split among the two pods in a 1 to 5 ratio, as shown in figure 14.2. If both pods\nconsume as much CPU as they can, the first pod will get one sixth or 16.7% of the\nCPU time and the other one the remaining five sixths or 83.3%.\nBut if one container wants to use up as much CPU as it can, while the other one is sit-\nting idle at a given moment, the first container will be allowed to use the whole CPU\ntime (minus the small amount of time used by the second container, if any). After all,\nit makes sense to use all the available CPU if no one else is using it, right? As soon as\nthe second container needs CPU time, it will get it and the first container will be throt-\ntled back.\n14.1.4 Defining and requesting custom resources\nKubernetes also allows you to add your own custom resources to a node and request\nthem in the pod\u2019s resource requests. Initially these were known as Opaque Integer\nResources, but were replaced with Extended Resources in Kubernetes version 1.8.\nPod A:\n200 m\nCPU\nrequests\nPod B: 1000 m\n800 m available\nCPU\nusage\n2000 m\n1000 m\n0 m\nPod A and B requests\nare in 1:5 ratio.\nAvailable CPU time is\ndistributed in same ratio.\nPod B: 1667 m\n133 m\n(1/6)\n667 m\n(5/6)\nPod A:\n333 m\nFigure 14.2\nUnused CPU time is distributed to containers based on their CPU requests.\n \n", "shape": "dot", "size": 10, "title": "411\nRequesting resources for a pod\u2019s containers\n14.1.3 Understanding how CPU requests affect CPU time sharing\nYou now have two pods running in your cluster (you can disregard the system pods\nright now, because they\u2019re mostly idle). One has requested 200 millicores and the\nother one five times as much. At the beginning of the chapter, we said Kubernetes dis-\ntinguishes between resource requests and limits. You haven\u2019t defined any limits yet, so\nthe two pods are in no way limited when it comes to how much CPU they can each\nconsume. If the process inside each pod consumes as much CPU time as it can, how\nmuch CPU time does each pod get? \n The CPU requests don\u2019t only affect scheduling\u2014they also determine how the\nremaining (unused) CPU time is distributed between pods. Because your first pod\nrequested 200 millicores of CPU and the other one 1,000 millicores, any unused CPU\nwill be split among the two pods in a 1 to 5 ratio, as shown in figure 14.2. If both pods\nconsume as much CPU as they can, the first pod will get one sixth or 16.7% of the\nCPU time and the other one the remaining five sixths or 83.3%.\nBut if one container wants to use up as much CPU as it can, while the other one is sit-\nting idle at a given moment, the first container will be allowed to use the whole CPU\ntime (minus the small amount of time used by the second container, if any). After all,\nit makes sense to use all the available CPU if no one else is using it, right? As soon as\nthe second container needs CPU time, it will get it and the first container will be throt-\ntled back.\n14.1.4 Defining and requesting custom resources\nKubernetes also allows you to add your own custom resources to a node and request\nthem in the pod\u2019s resource requests. Initially these were known as Opaque Integer\nResources, but were replaced with Extended Resources in Kubernetes version 1.8.\nPod A:\n200 m\nCPU\nrequests\nPod B: 1000 m\n800 m available\nCPU\nusage\n2000 m\n1000 m\n0 m\nPod A and B requests\nare in 1:5 ratio.\nAvailable CPU time is\ndistributed in same ratio.\nPod B: 1667 m\n133 m\n(1/6)\n667 m\n(5/6)\nPod A:\n333 m\nFigure 14.2\nUnused CPU time is distributed to containers based on their CPU requests.\n \n"}, {"color": "green", "id": "text_355", "label": "412\nCHAPTER 14\nManaging pods\u2019 computational resources\n First, you obviously need to make Kubernetes aware of your custom resource by\nadding it to the Node object\u2019s capacity field. This can be done by performing a\nPATCH HTTP request. The resource name can be anything, such as example.org/my-\nresource, as long as it doesn\u2019t start with the kubernetes.io domain. The quantity\nmust be an integer (for example, you can\u2019t set it to 100 millis, because 0.1 isn\u2019t an inte-\nger; but you can set it to 1000m or 2000m or, simply, 1 or 2). The value will be copied\nfrom the capacity to the allocatable field automatically.\n Then, when creating pods, you specify the same resource name and the requested\nquantity under the resources.requests field in the container spec or with --requests\nwhen using kubectl run like you did in previous examples. The Scheduler will make\nsure the pod is only deployed to a node that has the requested amount of the custom\nresource available. Every deployed pod obviously reduces the number of allocatable\nunits of the resource.\n An example of a custom resource could be the number of GPU units available on the\nnode. Pods requiring the use of a GPU specify that in their requests. The Scheduler then\nmakes sure the pod is only scheduled to nodes with at least one GPU still unallocated.\n14.2\nLimiting resources available to a container\nSetting resource requests for containers in a pod ensures each container gets the min-\nimum amount of resources it needs. Now let\u2019s see the other side of the coin\u2014the\nmaximum amount the container will be allowed to consume. \n14.2.1 Setting a hard limit for the amount of resources a container can use\nWe\u2019ve seen how containers are allowed to use up all the CPU if all the other processes\nare sitting idle. But you may want to prevent certain containers from using up more\nthan a specific amount of CPU. And you\u2019ll always want to limit the amount of memory\na container can consume. \n CPU is a compressible resource, which means the amount used by a container can\nbe throttled without affecting the process running in the container in an adverse way.\nMemory is obviously different\u2014it\u2019s incompressible. Once a process is given a chunk of\nmemory, that memory can\u2019t be taken away from it until it\u2019s released by the process\nitself. That\u2019s why you need to limit the maximum amount of memory a container can\nbe given. \n Without limiting memory, a container (or a pod) running on a worker node may\neat up all the available memory and affect all other pods on the node and any new\npods scheduled to the node (remember that new pods are scheduled to the node\nbased on the memory requests and not actual memory usage). A single malfunction-\ning or malicious pod can practically make the whole node unusable.\nCREATING A POD WITH RESOURCE LIMITS\nTo prevent this from happening, Kubernetes allows you to specify resource limits for\nevery container (along with, and virtually in the same way as, resource requests). The\nfollowing listing shows an example pod manifest with resource limits.\n \n", "shape": "dot", "size": 10, "title": "412\nCHAPTER 14\nManaging pods\u2019 computational resources\n First, you obviously need to make Kubernetes aware of your custom resource by\nadding it to the Node object\u2019s capacity field. This can be done by performing a\nPATCH HTTP request. The resource name can be anything, such as example.org/my-\nresource, as long as it doesn\u2019t start with the kubernetes.io domain. The quantity\nmust be an integer (for example, you can\u2019t set it to 100 millis, because 0.1 isn\u2019t an inte-\nger; but you can set it to 1000m or 2000m or, simply, 1 or 2). The value will be copied\nfrom the capacity to the allocatable field automatically.\n Then, when creating pods, you specify the same resource name and the requested\nquantity under the resources.requests field in the container spec or with --requests\nwhen using kubectl run like you did in previous examples. The Scheduler will make\nsure the pod is only deployed to a node that has the requested amount of the custom\nresource available. Every deployed pod obviously reduces the number of allocatable\nunits of the resource.\n An example of a custom resource could be the number of GPU units available on the\nnode. Pods requiring the use of a GPU specify that in their requests. The Scheduler then\nmakes sure the pod is only scheduled to nodes with at least one GPU still unallocated.\n14.2\nLimiting resources available to a container\nSetting resource requests for containers in a pod ensures each container gets the min-\nimum amount of resources it needs. Now let\u2019s see the other side of the coin\u2014the\nmaximum amount the container will be allowed to consume. \n14.2.1 Setting a hard limit for the amount of resources a container can use\nWe\u2019ve seen how containers are allowed to use up all the CPU if all the other processes\nare sitting idle. But you may want to prevent certain containers from using up more\nthan a specific amount of CPU. And you\u2019ll always want to limit the amount of memory\na container can consume. \n CPU is a compressible resource, which means the amount used by a container can\nbe throttled without affecting the process running in the container in an adverse way.\nMemory is obviously different\u2014it\u2019s incompressible. Once a process is given a chunk of\nmemory, that memory can\u2019t be taken away from it until it\u2019s released by the process\nitself. That\u2019s why you need to limit the maximum amount of memory a container can\nbe given. \n Without limiting memory, a container (or a pod) running on a worker node may\neat up all the available memory and affect all other pods on the node and any new\npods scheduled to the node (remember that new pods are scheduled to the node\nbased on the memory requests and not actual memory usage). A single malfunction-\ning or malicious pod can practically make the whole node unusable.\nCREATING A POD WITH RESOURCE LIMITS\nTo prevent this from happening, Kubernetes allows you to specify resource limits for\nevery container (along with, and virtually in the same way as, resource requests). The\nfollowing listing shows an example pod manifest with resource limits.\n \n"}, {"color": "green", "id": "text_356", "label": "413\nLimiting resources available to a container\napiVersion: v1\nkind: Pod\nmetadata:\n  name: limited-pod\nspec:\n  containers:\n  - image: busybox\n    command: [\"dd\", \"if=/dev/zero\", \"of=/dev/null\"]\n    name: main\n    resources:            \n      limits:             \n        cpu: 1             \n        memory: 20Mi       \nThis pod\u2019s container has resource limits configured for both CPU and memory. The\nprocess or processes running inside the container will not be allowed to consume\nmore than 1 CPU core and 20 mebibytes of memory. \nNOTE\nBecause you haven\u2019t specified any resource requests, they\u2019ll be set to\nthe same values as the resource limits.\nOVERCOMMITTING LIMITS\nUnlike resource requests, resource limits aren\u2019t constrained by the node\u2019s allocatable\nresource amounts. The sum of all limits of all the pods on a node is allowed to exceed\n100% of the node\u2019s capacity (figure 14.3). Restated, resource limits can be overcom-\nmitted. This has an important consequence\u2014when 100% of the node\u2019s resources are\nused up, certain containers will need to be killed.\nYou\u2019ll see how Kubernetes decides which containers to kill in section 14.3, but individ-\nual containers can be killed even if they try to use more than their resource limits\nspecify. You\u2019ll learn more about this next.\nListing 14.7\nA pod with a hard limit on CPU and memory: limited-pod.yaml\nSpecifying resource \nlimits for the container\nThis container will be \nallowed to use at \nmost 1 CPU core.\nThe container will be\nallowed to use up to 20\nmebibytes of memory.\nNode\n0%\n136%\n100%\nPod A\nMemory requests\nPod B\nPod C\nPod A\nMemory limits\nPod B\nUnallocated\nPod C\nFigure 14.3\nThe sum of resource limits of all pods on a node can exceed 100% of the node\u2019s \ncapacity.\n \n", "shape": "dot", "size": 10, "title": "413\nLimiting resources available to a container\napiVersion: v1\nkind: Pod\nmetadata:\n  name: limited-pod\nspec:\n  containers:\n  - image: busybox\n    command: [\"dd\", \"if=/dev/zero\", \"of=/dev/null\"]\n    name: main\n    resources:            \n      limits:             \n        cpu: 1             \n        memory: 20Mi       \nThis pod\u2019s container has resource limits configured for both CPU and memory. The\nprocess or processes running inside the container will not be allowed to consume\nmore than 1 CPU core and 20 mebibytes of memory. \nNOTE\nBecause you haven\u2019t specified any resource requests, they\u2019ll be set to\nthe same values as the resource limits.\nOVERCOMMITTING LIMITS\nUnlike resource requests, resource limits aren\u2019t constrained by the node\u2019s allocatable\nresource amounts. The sum of all limits of all the pods on a node is allowed to exceed\n100% of the node\u2019s capacity (figure 14.3). Restated, resource limits can be overcom-\nmitted. This has an important consequence\u2014when 100% of the node\u2019s resources are\nused up, certain containers will need to be killed.\nYou\u2019ll see how Kubernetes decides which containers to kill in section 14.3, but individ-\nual containers can be killed even if they try to use more than their resource limits\nspecify. You\u2019ll learn more about this next.\nListing 14.7\nA pod with a hard limit on CPU and memory: limited-pod.yaml\nSpecifying resource \nlimits for the container\nThis container will be \nallowed to use at \nmost 1 CPU core.\nThe container will be\nallowed to use up to 20\nmebibytes of memory.\nNode\n0%\n136%\n100%\nPod A\nMemory requests\nPod B\nPod C\nPod A\nMemory limits\nPod B\nUnallocated\nPod C\nFigure 14.3\nThe sum of resource limits of all pods on a node can exceed 100% of the node\u2019s \ncapacity.\n \n"}, {"color": "green", "id": "text_357", "label": "414\nCHAPTER 14\nManaging pods\u2019 computational resources\n14.2.2 Exceeding the limits\nWhat happens when a process running in a container tries to use a greater amount of\nresources than it\u2019s allowed to? \n You\u2019ve already learned that CPU is a compressible resource, and it\u2019s only natural\nfor a process to want to consume all of the CPU time when not waiting for an I/O\noperation. As you\u2019ve learned, a process\u2019 CPU usage is throttled, so when a CPU\nlimit is set for a container, the process isn\u2019t given more CPU time than the config-\nured limit. \n With memory, it\u2019s different. When a process tries to allocate memory over its\nlimit, the process is killed (it\u2019s said the container is OOMKilled, where OOM stands\nfor Out Of Memory). If the pod\u2019s restart policy is set to Always or OnFailure, the\nprocess is restarted immediately, so you may not even notice it getting killed. But if it\nkeeps going over the memory limit and getting killed, Kubernetes will begin restart-\ning it with increasing delays between restarts. You\u2019ll see a CrashLoopBackOff status\nin that case:\n$ kubectl get po\nNAME        READY     STATUS             RESTARTS   AGE\nmemoryhog   0/1       CrashLoopBackOff   3          1m\nThe CrashLoopBackOff status doesn\u2019t mean the Kubelet has given up. It means that\nafter each crash, the Kubelet is increasing the time period before restarting the con-\ntainer. After the first crash, it restarts the container immediately and then, if it crashes\nagain, waits for 10 seconds before restarting it again. On subsequent crashes, this\ndelay is then increased exponentially to 20, 40, 80, and 160 seconds, and finally lim-\nited to 300 seconds. Once the interval hits the 300-second limit, the Kubelet keeps\nrestarting the container indefinitely every five minutes until the pod either stops\ncrashing or is deleted. \n To examine why the container crashed, you can check the pod\u2019s log and/or use\nthe kubectl describe pod command, as shown in the following listing.\n$ kubectl describe pod\nName:       memoryhog\n...\nContainers:\n  main:\n    ...\n    State:          Terminated          \n      Reason:       OOMKilled           \n      Exit Code:    137\n      Started:      Tue, 27 Dec 2016 14:55:53 +0100\n      Finished:     Tue, 27 Dec 2016 14:55:58 +0100\n    Last State:     Terminated            \n      Reason:       OOMKilled             \n      Exit Code:    137\nListing 14.8\nInspecting why a container terminated with kubectl describe pod\nThe current container was \nkilled because it was out \nof memory (OOM).\nThe previous container \nwas also killed because \nit was  OOM\n \n", "shape": "dot", "size": 10, "title": "414\nCHAPTER 14\nManaging pods\u2019 computational resources\n14.2.2 Exceeding the limits\nWhat happens when a process running in a container tries to use a greater amount of\nresources than it\u2019s allowed to? \n You\u2019ve already learned that CPU is a compressible resource, and it\u2019s only natural\nfor a process to want to consume all of the CPU time when not waiting for an I/O\noperation. As you\u2019ve learned, a process\u2019 CPU usage is throttled, so when a CPU\nlimit is set for a container, the process isn\u2019t given more CPU time than the config-\nured limit. \n With memory, it\u2019s different. When a process tries to allocate memory over its\nlimit, the process is killed (it\u2019s said the container is OOMKilled, where OOM stands\nfor Out Of Memory). If the pod\u2019s restart policy is set to Always or OnFailure, the\nprocess is restarted immediately, so you may not even notice it getting killed. But if it\nkeeps going over the memory limit and getting killed, Kubernetes will begin restart-\ning it with increasing delays between restarts. You\u2019ll see a CrashLoopBackOff status\nin that case:\n$ kubectl get po\nNAME        READY     STATUS             RESTARTS   AGE\nmemoryhog   0/1       CrashLoopBackOff   3          1m\nThe CrashLoopBackOff status doesn\u2019t mean the Kubelet has given up. It means that\nafter each crash, the Kubelet is increasing the time period before restarting the con-\ntainer. After the first crash, it restarts the container immediately and then, if it crashes\nagain, waits for 10 seconds before restarting it again. On subsequent crashes, this\ndelay is then increased exponentially to 20, 40, 80, and 160 seconds, and finally lim-\nited to 300 seconds. Once the interval hits the 300-second limit, the Kubelet keeps\nrestarting the container indefinitely every five minutes until the pod either stops\ncrashing or is deleted. \n To examine why the container crashed, you can check the pod\u2019s log and/or use\nthe kubectl describe pod command, as shown in the following listing.\n$ kubectl describe pod\nName:       memoryhog\n...\nContainers:\n  main:\n    ...\n    State:          Terminated          \n      Reason:       OOMKilled           \n      Exit Code:    137\n      Started:      Tue, 27 Dec 2016 14:55:53 +0100\n      Finished:     Tue, 27 Dec 2016 14:55:58 +0100\n    Last State:     Terminated            \n      Reason:       OOMKilled             \n      Exit Code:    137\nListing 14.8\nInspecting why a container terminated with kubectl describe pod\nThe current container was \nkilled because it was out \nof memory (OOM).\nThe previous container \nwas also killed because \nit was  OOM\n \n"}, {"color": "green", "id": "text_358", "label": "415\nLimiting resources available to a container\n      Started:      Tue, 27 Dec 2016 14:55:37 +0100\n      Finished:     Tue, 27 Dec 2016 14:55:50 +0100\n    Ready:          False\n...\nThe OOMKilled status tells you that the container was killed because it was out of mem-\nory. In the previous listing, the container went over its memory limit and was killed\nimmediately. \n It\u2019s important not to set memory limits too low if you don\u2019t want your container to\nbe killed. But containers can get OOMKilled even if they aren\u2019t over their limit. You\u2019ll\nsee why in section 14.3.2, but first, let\u2019s discuss something that catches most users off-\nguard the first time they start specifying limits for their containers.\n14.2.3 Understanding how apps in containers see limits\nIf you haven\u2019t deployed the pod from listing 14.7, deploy it now:\n$ kubectl create -f limited-pod.yaml\npod \"limited-pod\" created\nNow, run the top command in the container, the way you did at the beginning of the\nchapter. The command\u2019s output is shown in the following listing.\n$ kubectl exec -it limited-pod top\nMem: 1450980K used, 597504K free, 22012K shrd, 65876K buff, 857552K cached\nCPU: 10.0% usr 40.0% sys  0.0% nic 50.0% idle  0.0% io  0.0% irq  0.0% sirq\nLoad average: 0.17 1.19 2.47 4/503 10\n  PID  PPID USER     STAT   VSZ %VSZ CPU %CPU COMMAND\n    1     0 root     R     1192  0.0   1 49.9 dd if /dev/zero of /dev/null\n    5     0 root     R     1196  0.0   0  0.0 top\nFirst, let me remind you that the pod\u2019s CPU limit is set to 1 core and its memory limit\nis set to 20 MiB. Now, examine the output of the top command closely. Is there any-\nthing that strikes you as odd?\n Look at the amount of used and free memory. Those numbers are nowhere near\nthe 20 MiB you set as the limit for the container. Similarly, you set the CPU limit to\none core and it seems like the main process is using only 50% of the available CPU\ntime, even though the dd command, when used like you\u2019re using it, usually uses all the\nCPU it has available. What\u2019s going on?\nUNDERSTANDING THAT CONTAINERS ALWAYS SEE THE NODE\u2019S MEMORY, NOT THE CONTAINER\u2019S\nThe top command shows the memory amounts of the whole node the container is\nrunning on. Even though you set a limit on how much memory is available to a con-\ntainer, the container will not be aware of this limit. \nListing 14.9\nRunning the top command in a CPU- and memory-limited container\n \n", "shape": "dot", "size": 10, "title": "415\nLimiting resources available to a container\n      Started:      Tue, 27 Dec 2016 14:55:37 +0100\n      Finished:     Tue, 27 Dec 2016 14:55:50 +0100\n    Ready:          False\n...\nThe OOMKilled status tells you that the container was killed because it was out of mem-\nory. In the previous listing, the container went over its memory limit and was killed\nimmediately. \n It\u2019s important not to set memory limits too low if you don\u2019t want your container to\nbe killed. But containers can get OOMKilled even if they aren\u2019t over their limit. You\u2019ll\nsee why in section 14.3.2, but first, let\u2019s discuss something that catches most users off-\nguard the first time they start specifying limits for their containers.\n14.2.3 Understanding how apps in containers see limits\nIf you haven\u2019t deployed the pod from listing 14.7, deploy it now:\n$ kubectl create -f limited-pod.yaml\npod \"limited-pod\" created\nNow, run the top command in the container, the way you did at the beginning of the\nchapter. The command\u2019s output is shown in the following listing.\n$ kubectl exec -it limited-pod top\nMem: 1450980K used, 597504K free, 22012K shrd, 65876K buff, 857552K cached\nCPU: 10.0% usr 40.0% sys  0.0% nic 50.0% idle  0.0% io  0.0% irq  0.0% sirq\nLoad average: 0.17 1.19 2.47 4/503 10\n  PID  PPID USER     STAT   VSZ %VSZ CPU %CPU COMMAND\n    1     0 root     R     1192  0.0   1 49.9 dd if /dev/zero of /dev/null\n    5     0 root     R     1196  0.0   0  0.0 top\nFirst, let me remind you that the pod\u2019s CPU limit is set to 1 core and its memory limit\nis set to 20 MiB. Now, examine the output of the top command closely. Is there any-\nthing that strikes you as odd?\n Look at the amount of used and free memory. Those numbers are nowhere near\nthe 20 MiB you set as the limit for the container. Similarly, you set the CPU limit to\none core and it seems like the main process is using only 50% of the available CPU\ntime, even though the dd command, when used like you\u2019re using it, usually uses all the\nCPU it has available. What\u2019s going on?\nUNDERSTANDING THAT CONTAINERS ALWAYS SEE THE NODE\u2019S MEMORY, NOT THE CONTAINER\u2019S\nThe top command shows the memory amounts of the whole node the container is\nrunning on. Even though you set a limit on how much memory is available to a con-\ntainer, the container will not be aware of this limit. \nListing 14.9\nRunning the top command in a CPU- and memory-limited container\n \n"}, {"color": "green", "id": "text_359", "label": "416\nCHAPTER 14\nManaging pods\u2019 computational resources\n This has an unfortunate effect on any application that looks up the amount of\nmemory available on the system and uses that information to decide how much mem-\nory it wants to reserve. \n The problem is visible when running Java apps, especially if you don\u2019t specify the\nmaximum heap size for the Java Virtual Machine with the -Xmx option. In that case,\nthe JVM will set the maximum heap size based on the host\u2019s total memory instead of\nthe memory available to the container. When you run your containerized Java apps in\na Kubernetes cluster on your laptop, the problem doesn\u2019t manifest itself, because the\ndifference between the memory limits you set for the pod and the total memory avail-\nable on your laptop is not that great. \n But when you deploy your pod onto a production system, where nodes have much\nmore physical memory, the JVM may go over the container\u2019s memory limit you config-\nured and will be OOMKilled. \n And if you think setting the -Xmx option properly solves the issue, you\u2019re wrong,\nunfortunately. The -Xmx option only constrains the heap size, but does nothing about\nthe JVM\u2019s off-heap memory. Luckily, new versions of Java alleviate that problem by tak-\ning the configured container limits into account.\nUNDERSTANDING THAT CONTAINERS ALSO SEE ALL THE NODE\u2019S CPU CORES\nExactly like with memory, containers will also see all the node\u2019s CPUs, regardless of\nthe CPU limits configured for the container. Setting a CPU limit to one core doesn\u2019t\nmagically only expose only one CPU core to the container. All the CPU limit does is\nconstrain the amount of CPU time the container can use. \n A container with a one-core CPU limit running on a 64-core CPU will get 1/64th\nof the overall CPU time. And even though its limit is set to one core, the container\u2019s\nprocesses will not run on only one core. At different points in time, its code may be\nexecuted on different cores.\n Nothing is wrong with this, right? While that\u2019s generally the case, at least one sce-\nnario exists where this situation is catastrophic.\n Certain applications look up the number of CPUs on the system to decide how\nmany worker threads they should run. Again, such an app will run fine on a develop-\nment laptop, but when deployed on a node with a much bigger number of cores, it\u2019s\ngoing to spin up too many threads, all competing for the (possibly) limited CPU time.\nAlso, each thread requires additional memory, causing the apps memory usage to sky-\nrocket. \n You may want to use the Downward API to pass the CPU limit to the container and\nuse it instead of relying on the number of CPUs your app can see on the system. You\ncan also tap into the cgroups system directly to get the configured CPU limit by read-\ning the following files:\n\uf0a1/sys/fs/cgroup/cpu/cpu.cfs_quota_us\n\uf0a1/sys/fs/cgroup/cpu/cpu.cfs_period_us\n \n", "shape": "dot", "size": 10, "title": "416\nCHAPTER 14\nManaging pods\u2019 computational resources\n This has an unfortunate effect on any application that looks up the amount of\nmemory available on the system and uses that information to decide how much mem-\nory it wants to reserve. \n The problem is visible when running Java apps, especially if you don\u2019t specify the\nmaximum heap size for the Java Virtual Machine with the -Xmx option. In that case,\nthe JVM will set the maximum heap size based on the host\u2019s total memory instead of\nthe memory available to the container. When you run your containerized Java apps in\na Kubernetes cluster on your laptop, the problem doesn\u2019t manifest itself, because the\ndifference between the memory limits you set for the pod and the total memory avail-\nable on your laptop is not that great. \n But when you deploy your pod onto a production system, where nodes have much\nmore physical memory, the JVM may go over the container\u2019s memory limit you config-\nured and will be OOMKilled. \n And if you think setting the -Xmx option properly solves the issue, you\u2019re wrong,\nunfortunately. The -Xmx option only constrains the heap size, but does nothing about\nthe JVM\u2019s off-heap memory. Luckily, new versions of Java alleviate that problem by tak-\ning the configured container limits into account.\nUNDERSTANDING THAT CONTAINERS ALSO SEE ALL THE NODE\u2019S CPU CORES\nExactly like with memory, containers will also see all the node\u2019s CPUs, regardless of\nthe CPU limits configured for the container. Setting a CPU limit to one core doesn\u2019t\nmagically only expose only one CPU core to the container. All the CPU limit does is\nconstrain the amount of CPU time the container can use. \n A container with a one-core CPU limit running on a 64-core CPU will get 1/64th\nof the overall CPU time. And even though its limit is set to one core, the container\u2019s\nprocesses will not run on only one core. At different points in time, its code may be\nexecuted on different cores.\n Nothing is wrong with this, right? While that\u2019s generally the case, at least one sce-\nnario exists where this situation is catastrophic.\n Certain applications look up the number of CPUs on the system to decide how\nmany worker threads they should run. Again, such an app will run fine on a develop-\nment laptop, but when deployed on a node with a much bigger number of cores, it\u2019s\ngoing to spin up too many threads, all competing for the (possibly) limited CPU time.\nAlso, each thread requires additional memory, causing the apps memory usage to sky-\nrocket. \n You may want to use the Downward API to pass the CPU limit to the container and\nuse it instead of relying on the number of CPUs your app can see on the system. You\ncan also tap into the cgroups system directly to get the configured CPU limit by read-\ning the following files:\n\uf0a1/sys/fs/cgroup/cpu/cpu.cfs_quota_us\n\uf0a1/sys/fs/cgroup/cpu/cpu.cfs_period_us\n \n"}, {"color": "green", "id": "text_360", "label": "417\nUnderstanding pod QoS classes\n14.3\nUnderstanding pod QoS classes\nWe\u2019ve already mentioned that resource limits can be overcommitted and that a\nnode can\u2019t necessarily provide all its pods the amount of resources specified in their\nresource limits. \n Imagine having two pods, where pod A is using, let\u2019s say, 90% of the node\u2019s mem-\nory and then pod B suddenly requires more memory than what it had been using up\nto that point and the node can\u2019t provide the required amount of memory. Which\ncontainer should be killed? Should it be pod B, because its request for memory can\u2019t\nbe satisfied, or should pod A be killed to free up memory, so it can be provided to\npod B? \n Obviously, it depends. Kubernetes can\u2019t make a proper decision on its own. You\nneed a way to specify which pods have priority in such cases. Kubernetes does this by\ncategorizing pods into three Quality of Service (QoS) classes:\n\uf0a1\nBestEffort (the lowest priority)\n\uf0a1\nBurstable\n\uf0a1\nGuaranteed (the highest)\n14.3.1 Defining the QoS class for a pod\nYou might expect these classes to be assignable to pods through a separate field in the\nmanifest, but they aren\u2019t. The QoS class is derived from the combination of resource\nrequests and limits for the pod\u2019s containers. Here\u2019s how.\nASSIGNING A POD TO THE BESTEFFORT CLASS\nThe lowest priority QoS class is the BestEffort class. It\u2019s assigned to pods that don\u2019t\nhave any requests or limits set at all (in any of their containers). This is the QoS class\nthat has been assigned to all the pods you created in previous chapters. Containers\nrunning in these pods have had no resource guarantees whatsoever. In the worst\ncase, they may get almost no CPU time at all and will be the first ones killed when\nmemory needs to be freed for other pods. But because a BestEffort pod has no\nmemory limits set, its containers may use as much memory as they want, if enough\nmemory is available.\nASSIGNING A POD TO THE GUARANTEED CLASS\nOn the other end of the spectrum is the Guaranteed QoS class. This class is given to\npods whose containers\u2019 requests are equal to the limits for all resources. For a pod\u2019s\nclass to be Guaranteed, three things need to be true:\n\uf0a1Requests and limits need to be set for both CPU and memory.\n\uf0a1They need to be set for each container.\n\uf0a1They need to be equal (the limit needs to match the request for each resource\nin each container).\nBecause a container\u2019s resource requests, if not set explicitly, default to the limits,\nspecifying the limits for all resources (for each container in the pod) is enough for\n \n", "shape": "dot", "size": 10, "title": "417\nUnderstanding pod QoS classes\n14.3\nUnderstanding pod QoS classes\nWe\u2019ve already mentioned that resource limits can be overcommitted and that a\nnode can\u2019t necessarily provide all its pods the amount of resources specified in their\nresource limits. \n Imagine having two pods, where pod A is using, let\u2019s say, 90% of the node\u2019s mem-\nory and then pod B suddenly requires more memory than what it had been using up\nto that point and the node can\u2019t provide the required amount of memory. Which\ncontainer should be killed? Should it be pod B, because its request for memory can\u2019t\nbe satisfied, or should pod A be killed to free up memory, so it can be provided to\npod B? \n Obviously, it depends. Kubernetes can\u2019t make a proper decision on its own. You\nneed a way to specify which pods have priority in such cases. Kubernetes does this by\ncategorizing pods into three Quality of Service (QoS) classes:\n\uf0a1\nBestEffort (the lowest priority)\n\uf0a1\nBurstable\n\uf0a1\nGuaranteed (the highest)\n14.3.1 Defining the QoS class for a pod\nYou might expect these classes to be assignable to pods through a separate field in the\nmanifest, but they aren\u2019t. The QoS class is derived from the combination of resource\nrequests and limits for the pod\u2019s containers. Here\u2019s how.\nASSIGNING A POD TO THE BESTEFFORT CLASS\nThe lowest priority QoS class is the BestEffort class. It\u2019s assigned to pods that don\u2019t\nhave any requests or limits set at all (in any of their containers). This is the QoS class\nthat has been assigned to all the pods you created in previous chapters. Containers\nrunning in these pods have had no resource guarantees whatsoever. In the worst\ncase, they may get almost no CPU time at all and will be the first ones killed when\nmemory needs to be freed for other pods. But because a BestEffort pod has no\nmemory limits set, its containers may use as much memory as they want, if enough\nmemory is available.\nASSIGNING A POD TO THE GUARANTEED CLASS\nOn the other end of the spectrum is the Guaranteed QoS class. This class is given to\npods whose containers\u2019 requests are equal to the limits for all resources. For a pod\u2019s\nclass to be Guaranteed, three things need to be true:\n\uf0a1Requests and limits need to be set for both CPU and memory.\n\uf0a1They need to be set for each container.\n\uf0a1They need to be equal (the limit needs to match the request for each resource\nin each container).\nBecause a container\u2019s resource requests, if not set explicitly, default to the limits,\nspecifying the limits for all resources (for each container in the pod) is enough for\n \n"}, {"color": "green", "id": "text_361", "label": "418\nCHAPTER 14\nManaging pods\u2019 computational resources\nthe pod to be Guaranteed. Containers in those pods get the requested amount of\nresources, but cannot consume additional ones (because their limits are no higher\nthan their requests). \nASSIGNING THE BURSTABLE QOS CLASS TO A POD\nIn between BestEffort and Guaranteed is the Burstable QoS class. All other pods\nfall into this class. This includes single-container pods where the container\u2019s limits\ndon\u2019t match its requests and all pods where at least one container has a resource\nrequest specified, but not the limit. It also includes pods where one container\u2019s\nrequests match their limits, but another container has no requests or limits specified.\nBurstable pods get the amount of resources they request, but are allowed to use addi-\ntional resources (up to the limit) if needed.\nUNDERSTANDING HOW THE RELATIONSHIP BETWEEN REQUESTS AND LIMITS DEFINES THE QOS CLASS\nAll three QoS classes and their relationships with requests and limits are shown in fig-\nure 14.4.\nThinking about what QoS class a pod has can make your head spin, because it involves\nmultiple containers, multiple resources, and all the possible relationships between\nrequests and limits. It\u2019s easier if you start by thinking about QoS at the container level\n(although QoS classes are a property of pods, not containers) and then derive the\npod\u2019s QoS class from the QoS classes of containers. \nFIGURING OUT A CONTAINER\u2019S QOS CLASS\nTable 14.1 shows the QoS class based on how resource requests and limits are\ndefined on a single container. For single-container pods, the QoS class applies to\nthe pod as well.\n \nBestEffort\nQoS\nRequests\nLimits\nBurstable\nQoS\nRequests\nLimits\nGuaranteed\nQoS\nRequests\nLimits\nRequests and\nlimits are not set\nRequests are\nbelow limits\nRequests\nequal limits\nFigure 14.4\nResource requests, limits and QoS classes\n \n", "shape": "dot", "size": 10, "title": "418\nCHAPTER 14\nManaging pods\u2019 computational resources\nthe pod to be Guaranteed. Containers in those pods get the requested amount of\nresources, but cannot consume additional ones (because their limits are no higher\nthan their requests). \nASSIGNING THE BURSTABLE QOS CLASS TO A POD\nIn between BestEffort and Guaranteed is the Burstable QoS class. All other pods\nfall into this class. This includes single-container pods where the container\u2019s limits\ndon\u2019t match its requests and all pods where at least one container has a resource\nrequest specified, but not the limit. It also includes pods where one container\u2019s\nrequests match their limits, but another container has no requests or limits specified.\nBurstable pods get the amount of resources they request, but are allowed to use addi-\ntional resources (up to the limit) if needed.\nUNDERSTANDING HOW THE RELATIONSHIP BETWEEN REQUESTS AND LIMITS DEFINES THE QOS CLASS\nAll three QoS classes and their relationships with requests and limits are shown in fig-\nure 14.4.\nThinking about what QoS class a pod has can make your head spin, because it involves\nmultiple containers, multiple resources, and all the possible relationships between\nrequests and limits. It\u2019s easier if you start by thinking about QoS at the container level\n(although QoS classes are a property of pods, not containers) and then derive the\npod\u2019s QoS class from the QoS classes of containers. \nFIGURING OUT A CONTAINER\u2019S QOS CLASS\nTable 14.1 shows the QoS class based on how resource requests and limits are\ndefined on a single container. For single-container pods, the QoS class applies to\nthe pod as well.\n \nBestEffort\nQoS\nRequests\nLimits\nBurstable\nQoS\nRequests\nLimits\nGuaranteed\nQoS\nRequests\nLimits\nRequests and\nlimits are not set\nRequests are\nbelow limits\nRequests\nequal limits\nFigure 14.4\nResource requests, limits and QoS classes\n \n"}, {"color": "green", "id": "text_362", "label": "419\nUnderstanding pod QoS classes\nNOTE\nIf only requests are set, but not limits, refer to the table rows where\nrequests are less than the limits. If only limits are set, requests default to the\nlimits, so refer to the rows where requests equal limits.\nFIGURING OUT THE QOS CLASS OF A POD WITH MULTIPLE CONTAINERS\nFor multi-container pods, if all the containers have the same QoS class, that\u2019s also the\npod\u2019s QoS class. If at least one container has a different class, the pod\u2019s QoS class is\nBurstable, regardless of what the container classes are. Table 14.2 shows how a two-\ncontainer pod\u2019s QoS class relates to the classes of its two containers. You can easily\nextend this to pods with more than two containers.\nNOTE\nA pod\u2019s QoS class is shown when running kubectl describe pod and\nin the pod\u2019s YAML/JSON manifest in the status.qosClass field.\nWe\u2019ve explained how QoS classes are determined, but we still need to look at how they\ndetermine which container gets killed in an overcommitted system.\nTable 14.1\nThe QoS class of a single-container pod based on resource requests and limits\nCPU requests vs. limits\nMemory requests vs. limits\nContainer QoS class\nNone set\nNone set\nBestEffort\nNone set\nRequests \u003c Limits\nBurstable\nNone set\nRequests = Limits\nBurstable\nRequests \u003c Limits\nNone set\nBurstable\nRequests \u003c Limits\nRequests \u003c Limits\nBurstable\nRequests \u003c Limits\nRequests = Limits\nBurstable\nRequests = Limits\nRequests = Limits\nGuaranteed\nTable 14.2\nA Pod\u2019s QoS class derived from the classes of its containers\nContainer 1 QoS class\nContainer 2 QoS class\nPod\u2019s QoS class\nBestEffort\nBestEffort\nBestEffort\nBestEffort\nBurstable\nBurstable\nBestEffort\nGuaranteed\nBurstable\nBurstable\nBurstable\nBurstable\nBurstable\nGuaranteed\nBurstable\nGuaranteed\nGuaranteed\nGuaranteed\n \n", "shape": "dot", "size": 10, "title": "419\nUnderstanding pod QoS classes\nNOTE\nIf only requests are set, but not limits, refer to the table rows where\nrequests are less than the limits. If only limits are set, requests default to the\nlimits, so refer to the rows where requests equal limits.\nFIGURING OUT THE QOS CLASS OF A POD WITH MULTIPLE CONTAINERS\nFor multi-container pods, if all the containers have the same QoS class, that\u2019s also the\npod\u2019s QoS class. If at least one container has a different class, the pod\u2019s QoS class is\nBurstable, regardless of what the container classes are. Table 14.2 shows how a two-\ncontainer pod\u2019s QoS class relates to the classes of its two containers. You can easily\nextend this to pods with more than two containers.\nNOTE\nA pod\u2019s QoS class is shown when running kubectl describe pod and\nin the pod\u2019s YAML/JSON manifest in the status.qosClass field.\nWe\u2019ve explained how QoS classes are determined, but we still need to look at how they\ndetermine which container gets killed in an overcommitted system.\nTable 14.1\nThe QoS class of a single-container pod based on resource requests and limits\nCPU requests vs. limits\nMemory requests vs. limits\nContainer QoS class\nNone set\nNone set\nBestEffort\nNone set\nRequests \u003c Limits\nBurstable\nNone set\nRequests = Limits\nBurstable\nRequests \u003c Limits\nNone set\nBurstable\nRequests \u003c Limits\nRequests \u003c Limits\nBurstable\nRequests \u003c Limits\nRequests = Limits\nBurstable\nRequests = Limits\nRequests = Limits\nGuaranteed\nTable 14.2\nA Pod\u2019s QoS class derived from the classes of its containers\nContainer 1 QoS class\nContainer 2 QoS class\nPod\u2019s QoS class\nBestEffort\nBestEffort\nBestEffort\nBestEffort\nBurstable\nBurstable\nBestEffort\nGuaranteed\nBurstable\nBurstable\nBurstable\nBurstable\nBurstable\nGuaranteed\nBurstable\nGuaranteed\nGuaranteed\nGuaranteed\n \n"}, {"color": "green", "id": "text_363", "label": "420\nCHAPTER 14\nManaging pods\u2019 computational resources\n14.3.2 Understanding which process gets killed when memory is low\nWhen the system is overcommitted, the QoS classes determine which container gets\nkilled first so the freed resources can be given to higher priority pods. First in line to\nget killed are pods in the BestEffort class, followed by Burstable pods, and finally\nGuaranteed pods, which only get killed if system processes need memory.\nUNDERSTANDING HOW QOS CLASSES LINE UP\nLet\u2019s look at the example shown in figure 14.5. Imagine having two single-container\npods, where the first one has the BestEffort QoS class, and the second one\u2019s is\nBurstable. When the node\u2019s whole memory is already maxed out and one of the pro-\ncesses on the node tries to allocate more memory, the system will need to kill one of\nthe processes (perhaps even the process trying to allocate additional memory) to\nhonor the allocation request. In this case, the process running in the BestEffort pod\nwill always be killed before the one in the Burstable pod.\nObviously, a BestEffort pod\u2019s process will also be killed before any Guaranteed pods\u2019\nprocesses are killed. Likewise, a Burstable pod\u2019s process will also be killed before that\nof a Guaranteed pod. But what happens if there are only two Burstable pods? Clearly,\nthe selection process needs to prefer one over the other.\nUNDERSTANDING HOW CONTAINERS WITH THE SAME QOS CLASS ARE HANDLED\nEach running process has an OutOfMemory (OOM) score. The system selects the\nprocess to kill by comparing OOM scores of all the running processes. When memory\nneeds to be freed, the process with the highest score gets killed.\n OOM scores are calculated from two things: the percentage of the available mem-\nory the process is consuming and a fixed OOM score adjustment, which is based on the\npod\u2019s QoS class and the container\u2019s requested memory. When two single-container pods\nexist, both in the Burstable class, the system will kill the one using more of its requested\nBestEffort\nQoS pod\nPod A\nFirst in line\nto be killed\nActual usage\nRequests\nLimits\nBurstable\nQoS pod\nPod B\nSecond in line\nto be killed\n90% used\nRequests\nLimits\nBurstable\nQoS pod\nPod C\nThird in line\nto be killed\n70% used\nRequests\nLimits\nGuaranteed\nQoS pod\nPod D\nLast to\nbe killed\n99% used\nRequests\nLimits\nFigure 14.5\nWhich pods get killed first\n \n", "shape": "dot", "size": 10, "title": "420\nCHAPTER 14\nManaging pods\u2019 computational resources\n14.3.2 Understanding which process gets killed when memory is low\nWhen the system is overcommitted, the QoS classes determine which container gets\nkilled first so the freed resources can be given to higher priority pods. First in line to\nget killed are pods in the BestEffort class, followed by Burstable pods, and finally\nGuaranteed pods, which only get killed if system processes need memory.\nUNDERSTANDING HOW QOS CLASSES LINE UP\nLet\u2019s look at the example shown in figure 14.5. Imagine having two single-container\npods, where the first one has the BestEffort QoS class, and the second one\u2019s is\nBurstable. When the node\u2019s whole memory is already maxed out and one of the pro-\ncesses on the node tries to allocate more memory, the system will need to kill one of\nthe processes (perhaps even the process trying to allocate additional memory) to\nhonor the allocation request. In this case, the process running in the BestEffort pod\nwill always be killed before the one in the Burstable pod.\nObviously, a BestEffort pod\u2019s process will also be killed before any Guaranteed pods\u2019\nprocesses are killed. Likewise, a Burstable pod\u2019s process will also be killed before that\nof a Guaranteed pod. But what happens if there are only two Burstable pods? Clearly,\nthe selection process needs to prefer one over the other.\nUNDERSTANDING HOW CONTAINERS WITH THE SAME QOS CLASS ARE HANDLED\nEach running process has an OutOfMemory (OOM) score. The system selects the\nprocess to kill by comparing OOM scores of all the running processes. When memory\nneeds to be freed, the process with the highest score gets killed.\n OOM scores are calculated from two things: the percentage of the available mem-\nory the process is consuming and a fixed OOM score adjustment, which is based on the\npod\u2019s QoS class and the container\u2019s requested memory. When two single-container pods\nexist, both in the Burstable class, the system will kill the one using more of its requested\nBestEffort\nQoS pod\nPod A\nFirst in line\nto be killed\nActual usage\nRequests\nLimits\nBurstable\nQoS pod\nPod B\nSecond in line\nto be killed\n90% used\nRequests\nLimits\nBurstable\nQoS pod\nPod C\nThird in line\nto be killed\n70% used\nRequests\nLimits\nGuaranteed\nQoS pod\nPod D\nLast to\nbe killed\n99% used\nRequests\nLimits\nFigure 14.5\nWhich pods get killed first\n \n"}, {"color": "green", "id": "text_364", "label": "421\nSetting default requests and limits for pods per namespace\nmemory than the other, percentage-wise. That\u2019s why in figure 14.5, pod B, using 90%\nof its requested memory, gets killed before pod C, which is only using 70%, even\nthough it\u2019s using more megabytes of memory than pod B. \n This shows you need to be mindful of not only the relationship between requests\nand limits, but also of requests and the expected actual memory consumption. \n14.4\nSetting default requests and limits for pods per \nnamespace\nWe\u2019ve looked at how resource requests and limits can be set for each individual con-\ntainer. If you don\u2019t set them, the container is at the mercy of all other containers that\ndo specify resource requests and limits. It\u2019s a good idea to set requests and limits on\nevery container.\n14.4.1 Introducing the LimitRange resource\nInstead of having to do this for every container, you can also do it by creating a Limit-\nRange resource. It allows you to specify (for each namespace) not only the minimum\nand maximum limit you can set on a container for each resource, but also the default\nresource requests for containers that don\u2019t specify requests explicitly, as depicted in\nfigure 14.6.\nAPI server\nValidation\nPod A\nmanifest\n- Requests\n- Limits\nPod A\nmanifest\n- Requests\n- Limits\nPod B\nmanifest\n- No\nrequests\nor limits\nPod B\nmanifest\n- No\nrequests\nor limits\nDefaulting\nRejected because\nrequests and limits are\noutside min/max values\nDefaults\napplied\nNamespace XYZ\nLimitRange\nPod B\nmanifest\n- Default\nrequests\n- Default\nlimits\nPod B\n- Default requests\n- Default limits\n- Min/max CPU\n- Min/max memory\n- Default requests\n- Default limits\nFigure 14.6\nA LimitRange is used for validation and defaulting pods.\n \n", "shape": "dot", "size": 10, "title": "421\nSetting default requests and limits for pods per namespace\nmemory than the other, percentage-wise. That\u2019s why in figure 14.5, pod B, using 90%\nof its requested memory, gets killed before pod C, which is only using 70%, even\nthough it\u2019s using more megabytes of memory than pod B. \n This shows you need to be mindful of not only the relationship between requests\nand limits, but also of requests and the expected actual memory consumption. \n14.4\nSetting default requests and limits for pods per \nnamespace\nWe\u2019ve looked at how resource requests and limits can be set for each individual con-\ntainer. If you don\u2019t set them, the container is at the mercy of all other containers that\ndo specify resource requests and limits. It\u2019s a good idea to set requests and limits on\nevery container.\n14.4.1 Introducing the LimitRange resource\nInstead of having to do this for every container, you can also do it by creating a Limit-\nRange resource. It allows you to specify (for each namespace) not only the minimum\nand maximum limit you can set on a container for each resource, but also the default\nresource requests for containers that don\u2019t specify requests explicitly, as depicted in\nfigure 14.6.\nAPI server\nValidation\nPod A\nmanifest\n- Requests\n- Limits\nPod A\nmanifest\n- Requests\n- Limits\nPod B\nmanifest\n- No\nrequests\nor limits\nPod B\nmanifest\n- No\nrequests\nor limits\nDefaulting\nRejected because\nrequests and limits are\noutside min/max values\nDefaults\napplied\nNamespace XYZ\nLimitRange\nPod B\nmanifest\n- Default\nrequests\n- Default\nlimits\nPod B\n- Default requests\n- Default limits\n- Min/max CPU\n- Min/max memory\n- Default requests\n- Default limits\nFigure 14.6\nA LimitRange is used for validation and defaulting pods.\n \n"}, {"color": "green", "id": "text_365", "label": "422\nCHAPTER 14\nManaging pods\u2019 computational resources\nLimitRange resources are used by the LimitRanger Admission Control plugin (we\nexplained what those plugins are in chapter 11). When a pod manifest is posted to the\nAPI server, the LimitRanger plugin validates the pod spec. If validation fails, the mani-\nfest is rejected immediately. Because of this, a great use-case for LimitRange objects is\nto prevent users from creating pods that are bigger than any node in the cluster. With-\nout such a LimitRange, the API server will gladly accept the pod, but then never\nschedule it. \n The limits specified in a LimitRange resource apply to each individual pod/con-\ntainer or other kind of object created in the same namespace as the LimitRange\nobject. They don\u2019t limit the total amount of resources available across all the pods in\nthe namespace. This is specified through ResourceQuota objects, which are explained\nin section 14.5. \n14.4.2 Creating a LimitRange object\nLet\u2019s look at a full example of a LimitRange and see what the individual properties do.\nThe following listing shows the full definition of a LimitRange resource.\napiVersion: v1\nkind: LimitRange\nmetadata:\n  name: example\nspec:\n  limits:\n  - type: Pod           \n    min:                         \n      cpu: 50m                   \n      memory: 5Mi                \n    max:                          \n      cpu: 1                      \n      memory: 1Gi                 \n  - type: Container             \n    defaultRequest:             \n      cpu: 100m                 \n      memory: 10Mi              \n    default:                      \n      cpu: 200m                   \n      memory: 100Mi               \n    min:                         \n      cpu: 50m                   \n      memory: 5Mi                \n    max:                         \n      cpu: 1                     \n      memory: 1Gi                \n    maxLimitRequestRatio:         \n      cpu: 4                      \n      memory: 10                  \nListing 14.10\nA LimitRange resource: limits.yaml\nSpecifies the \nlimits for a pod \nas a whole\nMinimum CPU and memory all the \npod\u2019s containers can request in total\nMaximum CPU and memory all the pod\u2019s \ncontainers can request (and limit)\nThe\ncontainer\nlimits are\nspecified\nbelow this\nline.\nDefault requests for CPU and memory \nthat will be applied to containers that \ndon\u2019t specify them explicitly\nDefault limits for containers \nthat don\u2019t specify them\nMinimum and maximum \nrequests/limits that a \ncontainer can have\nMaximum ratio between \nthe limit and request \nfor each resource\n \n", "shape": "dot", "size": 10, "title": "422\nCHAPTER 14\nManaging pods\u2019 computational resources\nLimitRange resources are used by the LimitRanger Admission Control plugin (we\nexplained what those plugins are in chapter 11). When a pod manifest is posted to the\nAPI server, the LimitRanger plugin validates the pod spec. If validation fails, the mani-\nfest is rejected immediately. Because of this, a great use-case for LimitRange objects is\nto prevent users from creating pods that are bigger than any node in the cluster. With-\nout such a LimitRange, the API server will gladly accept the pod, but then never\nschedule it. \n The limits specified in a LimitRange resource apply to each individual pod/con-\ntainer or other kind of object created in the same namespace as the LimitRange\nobject. They don\u2019t limit the total amount of resources available across all the pods in\nthe namespace. This is specified through ResourceQuota objects, which are explained\nin section 14.5. \n14.4.2 Creating a LimitRange object\nLet\u2019s look at a full example of a LimitRange and see what the individual properties do.\nThe following listing shows the full definition of a LimitRange resource.\napiVersion: v1\nkind: LimitRange\nmetadata:\n  name: example\nspec:\n  limits:\n  - type: Pod           \n    min:                         \n      cpu: 50m                   \n      memory: 5Mi                \n    max:                          \n      cpu: 1                      \n      memory: 1Gi                 \n  - type: Container             \n    defaultRequest:             \n      cpu: 100m                 \n      memory: 10Mi              \n    default:                      \n      cpu: 200m                   \n      memory: 100Mi               \n    min:                         \n      cpu: 50m                   \n      memory: 5Mi                \n    max:                         \n      cpu: 1                     \n      memory: 1Gi                \n    maxLimitRequestRatio:         \n      cpu: 4                      \n      memory: 10                  \nListing 14.10\nA LimitRange resource: limits.yaml\nSpecifies the \nlimits for a pod \nas a whole\nMinimum CPU and memory all the \npod\u2019s containers can request in total\nMaximum CPU and memory all the pod\u2019s \ncontainers can request (and limit)\nThe\ncontainer\nlimits are\nspecified\nbelow this\nline.\nDefault requests for CPU and memory \nthat will be applied to containers that \ndon\u2019t specify them explicitly\nDefault limits for containers \nthat don\u2019t specify them\nMinimum and maximum \nrequests/limits that a \ncontainer can have\nMaximum ratio between \nthe limit and request \nfor each resource\n \n"}, {"color": "green", "id": "text_366", "label": "423\nSetting default requests and limits for pods per namespace\n  - type: PersistentVolumeClaim      \n    min:                             \n      storage: 1Gi                   \n    max:                             \n      storage: 10Gi                  \nAs you can see from the previous example, the minimum and maximum limits for a\nwhole pod can be configured. They apply to the sum of all the pod\u2019s containers\u2019\nrequests and limits. \n Lower down, at the container level, you can set not only the minimum and maxi-\nmum, but also default resource requests (defaultRequest) and default limits\n(default) that will be applied to each container that doesn\u2019t specify them explicitly. \n Beside the min, max, and default values, you can even set the maximum ratio of\nlimits vs. requests. The previous listing sets the CPU maxLimitRequestRatio to 4,\nwhich means a container\u2019s CPU limits will not be allowed to be more than four times\ngreater than its CPU requests. A container requesting 200 millicores will not be\naccepted if its CPU limit is set to 801 millicores or higher. For memory, the maximum\nratio is set to 10.\n In chapter 6 we looked at PersistentVolumeClaims (PVC), which allow you to claim\na certain amount of persistent storage similarly to how a pod\u2019s containers claim CPU\nand memory. In the same way you\u2019re limiting the minimum and maximum amount of\nCPU a container can request, you should also limit the amount of storage a single\nPVC can request. A LimitRange object allows you to do that as well, as you can see at\nthe bottom of the example.\n The example shows a single LimitRange object containing limits for everything,\nbut you could also split them into multiple objects if you prefer to have them orga-\nnized per type (one for pod limits, another for container limits, and yet another for\nPVCs, for example). Limits from multiple LimitRange objects are all consolidated\nwhen validating a pod or PVC.\n Because the validation (and defaults) configured in a LimitRange object is per-\nformed by the API server when it receives a new pod or PVC manifest, if you modify\nthe limits afterwards, existing pods and PVCs will not be revalidated\u2014the new limits\nwill only apply to pods and PVCs created afterward. \n14.4.3 Enforcing the limits\nWith your limits in place, you can now try creating a pod that requests more CPU than\nallowed by the LimitRange. You\u2019ll find the YAML for the pod in the code archive. The\nnext listing only shows the part relevant to the discussion.\n    resources:\n      requests:\n        cpu: 2\nListing 14.11\nA pod with CPU requests greater than the limit: limits-pod-too-big.yaml\nA LimitRange can also set \nthe minimum and maximum \namount of storage a PVC \ncan request.\n \n", "shape": "dot", "size": 10, "title": "423\nSetting default requests and limits for pods per namespace\n  - type: PersistentVolumeClaim      \n    min:                             \n      storage: 1Gi                   \n    max:                             \n      storage: 10Gi                  \nAs you can see from the previous example, the minimum and maximum limits for a\nwhole pod can be configured. They apply to the sum of all the pod\u2019s containers\u2019\nrequests and limits. \n Lower down, at the container level, you can set not only the minimum and maxi-\nmum, but also default resource requests (defaultRequest) and default limits\n(default) that will be applied to each container that doesn\u2019t specify them explicitly. \n Beside the min, max, and default values, you can even set the maximum ratio of\nlimits vs. requests. The previous listing sets the CPU maxLimitRequestRatio to 4,\nwhich means a container\u2019s CPU limits will not be allowed to be more than four times\ngreater than its CPU requests. A container requesting 200 millicores will not be\naccepted if its CPU limit is set to 801 millicores or higher. For memory, the maximum\nratio is set to 10.\n In chapter 6 we looked at PersistentVolumeClaims (PVC), which allow you to claim\na certain amount of persistent storage similarly to how a pod\u2019s containers claim CPU\nand memory. In the same way you\u2019re limiting the minimum and maximum amount of\nCPU a container can request, you should also limit the amount of storage a single\nPVC can request. A LimitRange object allows you to do that as well, as you can see at\nthe bottom of the example.\n The example shows a single LimitRange object containing limits for everything,\nbut you could also split them into multiple objects if you prefer to have them orga-\nnized per type (one for pod limits, another for container limits, and yet another for\nPVCs, for example). Limits from multiple LimitRange objects are all consolidated\nwhen validating a pod or PVC.\n Because the validation (and defaults) configured in a LimitRange object is per-\nformed by the API server when it receives a new pod or PVC manifest, if you modify\nthe limits afterwards, existing pods and PVCs will not be revalidated\u2014the new limits\nwill only apply to pods and PVCs created afterward. \n14.4.3 Enforcing the limits\nWith your limits in place, you can now try creating a pod that requests more CPU than\nallowed by the LimitRange. You\u2019ll find the YAML for the pod in the code archive. The\nnext listing only shows the part relevant to the discussion.\n    resources:\n      requests:\n        cpu: 2\nListing 14.11\nA pod with CPU requests greater than the limit: limits-pod-too-big.yaml\nA LimitRange can also set \nthe minimum and maximum \namount of storage a PVC \ncan request.\n \n"}, {"color": "green", "id": "text_367", "label": "424\nCHAPTER 14\nManaging pods\u2019 computational resources\nThe pod\u2019s single container is requesting two CPUs, which is more than the maximum\nyou set in the LimitRange earlier. Creating the pod yields the following result:\n$ kubectl create -f limits-pod-too-big.yaml \nError from server (Forbidden): error when creating \"limits-pod-too-big.yaml\": \npods \"too-big\" is forbidden: [\n  maximum cpu usage per Pod is 1, but request is 2., \n  maximum cpu usage per Container is 1, but request is 2.]\nI\u2019ve modified the output slightly to make it more legible. The nice thing about the\nerror message from the server is that it lists all the reasons why the pod was rejected,\nnot only the first one it encountered. As you can see, the pod was rejected for two rea-\nsons: you requested two CPUs for the container, but the maximum CPU limit for a\ncontainer is one. Likewise, the pod as a whole requested two CPUs, but the maximum\nis one CPU (if this was a multi-container pod, even if each individual container\nrequested less than the maximum amount of CPU, together they\u2019d still need to\nrequest less than two CPUs to pass the maximum CPU for pods). \n14.4.4 Applying default resource requests and limits\nNow let\u2019s also see how default resource requests and limits are set on containers that\ndon\u2019t specify them. Deploy the kubia-manual pod from chapter 3 again:\n$ kubectl create -f ../Chapter03/kubia-manual.yaml\npod \"kubia-manual\" created\nBefore you set up your LimitRange object, all your pods were created without any\nresource requests or limits, but now the defaults are applied automatically when creat-\ning the pod. You can confirm this by describing the kubia-manual pod, as shown in\nthe following listing.\n$ kubectl describe po kubia-manual\nName:           kubia-manual\n...\nContainers:\n  kubia:\n    Limits:\n      cpu:      200m\n      memory:   100Mi\n    Requests:\n      cpu:      100m\n      memory:   10Mi\nThe container\u2019s requests and limits match the ones you specified in the LimitRange\nobject. If you used a different LimitRange specification in another namespace, pods\ncreated in that namespace would obviously have different requests and limits. This\nallows admins to configure default, min, and max resources for pods per namespace.\nListing 14.12\nInspecting limits that were applied to a pod automatically\n \n", "shape": "dot", "size": 10, "title": "424\nCHAPTER 14\nManaging pods\u2019 computational resources\nThe pod\u2019s single container is requesting two CPUs, which is more than the maximum\nyou set in the LimitRange earlier. Creating the pod yields the following result:\n$ kubectl create -f limits-pod-too-big.yaml \nError from server (Forbidden): error when creating \"limits-pod-too-big.yaml\": \npods \"too-big\" is forbidden: [\n  maximum cpu usage per Pod is 1, but request is 2., \n  maximum cpu usage per Container is 1, but request is 2.]\nI\u2019ve modified the output slightly to make it more legible. The nice thing about the\nerror message from the server is that it lists all the reasons why the pod was rejected,\nnot only the first one it encountered. As you can see, the pod was rejected for two rea-\nsons: you requested two CPUs for the container, but the maximum CPU limit for a\ncontainer is one. Likewise, the pod as a whole requested two CPUs, but the maximum\nis one CPU (if this was a multi-container pod, even if each individual container\nrequested less than the maximum amount of CPU, together they\u2019d still need to\nrequest less than two CPUs to pass the maximum CPU for pods). \n14.4.4 Applying default resource requests and limits\nNow let\u2019s also see how default resource requests and limits are set on containers that\ndon\u2019t specify them. Deploy the kubia-manual pod from chapter 3 again:\n$ kubectl create -f ../Chapter03/kubia-manual.yaml\npod \"kubia-manual\" created\nBefore you set up your LimitRange object, all your pods were created without any\nresource requests or limits, but now the defaults are applied automatically when creat-\ning the pod. You can confirm this by describing the kubia-manual pod, as shown in\nthe following listing.\n$ kubectl describe po kubia-manual\nName:           kubia-manual\n...\nContainers:\n  kubia:\n    Limits:\n      cpu:      200m\n      memory:   100Mi\n    Requests:\n      cpu:      100m\n      memory:   10Mi\nThe container\u2019s requests and limits match the ones you specified in the LimitRange\nobject. If you used a different LimitRange specification in another namespace, pods\ncreated in that namespace would obviously have different requests and limits. This\nallows admins to configure default, min, and max resources for pods per namespace.\nListing 14.12\nInspecting limits that were applied to a pod automatically\n \n"}, {"color": "green", "id": "text_368", "label": "425\nLimiting the total resources available in a namespace\nIf namespaces are used to separate different teams or to separate development, QA,\nstaging, and production pods running in the same Kubernetes cluster, using a differ-\nent LimitRange in each namespace ensures large pods can only be created in certain\nnamespaces, whereas others are constrained to smaller pods.\n But remember, the limits configured in a LimitRange only apply to each individual\npod/container. It\u2019s still possible to create many pods and eat up all the resources avail-\nable in the cluster. LimitRanges don\u2019t provide any protection from that. A Resource-\nQuota object, on the other hand, does. You\u2019ll learn about them next.\n14.5\nLimiting the total resources available in a namespace\nAs you\u2019ve seen, LimitRanges only apply to individual pods, but cluster admins also\nneed a way to limit the total amount of resources available in a namespace. This is\nachieved by creating a ResourceQuota object. \n14.5.1 Introducing the ResourceQuota object\nIn chapter 10 we said that several Admission Control plugins running inside the API\nserver verify whether the pod may be created or not. In the previous section, I said\nthat the LimitRanger plugin enforces the policies configured in LimitRange resources.\nSimilarly, the ResourceQuota Admission Control plugin checks whether the pod\nbeing created would cause the configured ResourceQuota to be exceeded. If that\u2019s\nthe case, the pod\u2019s creation is rejected. Because resource quotas are enforced at pod\ncreation time, a ResourceQuota object only affects pods created after the Resource-\nQuota object is created\u2014creating it has no effect on existing pods.\n A ResourceQuota limits the amount of computational resources the pods and the\namount of storage PersistentVolumeClaims in a namespace can consume. It can also\nlimit the number of pods, claims, and other API objects users are allowed to create\ninside the namespace. Because you\u2019ve mostly dealt with CPU and memory so far, let\u2019s\nstart by looking at how to specify quotas for them.\nCREATING A RESOURCEQUOTA FOR CPU AND MEMORY\nThe overall CPU and memory all the pods in a namespace are allowed to consume is\ndefined by creating a ResourceQuota object as shown in the following listing.\napiVersion: v1\nkind: ResourceQuota\nmetadata:\n  name: cpu-and-mem\nspec:\n  hard:\n    requests.cpu: 400m\n    requests.memory: 200Mi\n    limits.cpu: 600m\n    limits.memory: 500Mi\nListing 14.13\nA ResourceQuota resource for CPU and memory: quota-cpu-memory.yaml\n \n", "shape": "dot", "size": 10, "title": "425\nLimiting the total resources available in a namespace\nIf namespaces are used to separate different teams or to separate development, QA,\nstaging, and production pods running in the same Kubernetes cluster, using a differ-\nent LimitRange in each namespace ensures large pods can only be created in certain\nnamespaces, whereas others are constrained to smaller pods.\n But remember, the limits configured in a LimitRange only apply to each individual\npod/container. It\u2019s still possible to create many pods and eat up all the resources avail-\nable in the cluster. LimitRanges don\u2019t provide any protection from that. A Resource-\nQuota object, on the other hand, does. You\u2019ll learn about them next.\n14.5\nLimiting the total resources available in a namespace\nAs you\u2019ve seen, LimitRanges only apply to individual pods, but cluster admins also\nneed a way to limit the total amount of resources available in a namespace. This is\nachieved by creating a ResourceQuota object. \n14.5.1 Introducing the ResourceQuota object\nIn chapter 10 we said that several Admission Control plugins running inside the API\nserver verify whether the pod may be created or not. In the previous section, I said\nthat the LimitRanger plugin enforces the policies configured in LimitRange resources.\nSimilarly, the ResourceQuota Admission Control plugin checks whether the pod\nbeing created would cause the configured ResourceQuota to be exceeded. If that\u2019s\nthe case, the pod\u2019s creation is rejected. Because resource quotas are enforced at pod\ncreation time, a ResourceQuota object only affects pods created after the Resource-\nQuota object is created\u2014creating it has no effect on existing pods.\n A ResourceQuota limits the amount of computational resources the pods and the\namount of storage PersistentVolumeClaims in a namespace can consume. It can also\nlimit the number of pods, claims, and other API objects users are allowed to create\ninside the namespace. Because you\u2019ve mostly dealt with CPU and memory so far, let\u2019s\nstart by looking at how to specify quotas for them.\nCREATING A RESOURCEQUOTA FOR CPU AND MEMORY\nThe overall CPU and memory all the pods in a namespace are allowed to consume is\ndefined by creating a ResourceQuota object as shown in the following listing.\napiVersion: v1\nkind: ResourceQuota\nmetadata:\n  name: cpu-and-mem\nspec:\n  hard:\n    requests.cpu: 400m\n    requests.memory: 200Mi\n    limits.cpu: 600m\n    limits.memory: 500Mi\nListing 14.13\nA ResourceQuota resource for CPU and memory: quota-cpu-memory.yaml\n \n"}, {"color": "green", "id": "text_369", "label": "426\nCHAPTER 14\nManaging pods\u2019 computational resources\nInstead of defining a single total for each resource, you define separate totals for\nrequests and limits for both CPU and memory. You\u2019ll notice the structure is a bit dif-\nferent, compared to that of a LimitRange. Here, both the requests and the limits for\nall resources are defined in a single place. \n This ResourceQuota sets the maximum amount of CPU pods in the namespace\ncan request to 400 millicores. The maximum total CPU limits in the namespace are\nset to 600 millicores. For memory, the maximum total requests are set to 200 MiB,\nwhereas the limits are set to 500 MiB.\n A ResourceQuota object applies to the namespace it\u2019s created in, like a Limit-\nRange, but it applies to all the pods\u2019 resource requests and limits in total and not to\neach individual pod or container separately, as shown in figure 14.7.\nINSPECTING THE QUOTA AND QUOTA USAGE\nAfter you post the ResourceQuota object to the API server, you can use the kubectl\ndescribe command to see how much of the quota is already used up, as shown in\nthe following listing.\n$ kubectl describe quota\nName:           cpu-and-mem\nNamespace:      default\nResource        Used   Hard\n--------        ----   ----\nlimits.cpu      200m   600m\nlimits.memory   100Mi  500Mi\nrequests.cpu    100m   400m\nrequests.memory 10Mi   200Mi\nI only have the kubia-manual pod running, so the Used column matches its resource\nrequests and limits. When I run additional pods, their requests and limits are added to\nthe used amounts.\nListing 14.14\nInspecting the ResourceQuota with kubectl describe quota\nLimitRange\nResourceQuota\nNamespace: FOO\nPod A\nPod B\nPod C\nLimitRange\nResourceQuota\nNamespace: BAR\nPod D\nPod E\nPod F\nFigure 14.7\nLimitRanges apply to individual pods; ResourceQuotas apply to all pods in the \nnamespace.\n \n", "shape": "dot", "size": 10, "title": "426\nCHAPTER 14\nManaging pods\u2019 computational resources\nInstead of defining a single total for each resource, you define separate totals for\nrequests and limits for both CPU and memory. You\u2019ll notice the structure is a bit dif-\nferent, compared to that of a LimitRange. Here, both the requests and the limits for\nall resources are defined in a single place. \n This ResourceQuota sets the maximum amount of CPU pods in the namespace\ncan request to 400 millicores. The maximum total CPU limits in the namespace are\nset to 600 millicores. For memory, the maximum total requests are set to 200 MiB,\nwhereas the limits are set to 500 MiB.\n A ResourceQuota object applies to the namespace it\u2019s created in, like a Limit-\nRange, but it applies to all the pods\u2019 resource requests and limits in total and not to\neach individual pod or container separately, as shown in figure 14.7.\nINSPECTING THE QUOTA AND QUOTA USAGE\nAfter you post the ResourceQuota object to the API server, you can use the kubectl\ndescribe command to see how much of the quota is already used up, as shown in\nthe following listing.\n$ kubectl describe quota\nName:           cpu-and-mem\nNamespace:      default\nResource        Used   Hard\n--------        ----   ----\nlimits.cpu      200m   600m\nlimits.memory   100Mi  500Mi\nrequests.cpu    100m   400m\nrequests.memory 10Mi   200Mi\nI only have the kubia-manual pod running, so the Used column matches its resource\nrequests and limits. When I run additional pods, their requests and limits are added to\nthe used amounts.\nListing 14.14\nInspecting the ResourceQuota with kubectl describe quota\nLimitRange\nResourceQuota\nNamespace: FOO\nPod A\nPod B\nPod C\nLimitRange\nResourceQuota\nNamespace: BAR\nPod D\nPod E\nPod F\nFigure 14.7\nLimitRanges apply to individual pods; ResourceQuotas apply to all pods in the \nnamespace.\n \n"}, {"color": "green", "id": "text_370", "label": "427\nLimiting the total resources available in a namespace\nCREATING A LIMITRANGE ALONG WITH A RESOURCEQUOTA\nOne caveat when creating a ResourceQuota is that you will also want to create a Limit-\nRange object alongside it. In your case, you have a LimitRange configured from the\nprevious section, but if you didn\u2019t have one, you couldn\u2019t run the kubia-manual pod,\nbecause it doesn\u2019t specify any resource requests or limits. Here\u2019s what would happen\nin that case:\n$ kubectl create -f ../Chapter03/kubia-manual.yaml\nError from server (Forbidden): error when creating \"../Chapter03/kubia-\nmanual.yaml\": pods \"kubia-manual\" is forbidden: failed quota: cpu-and-\nmem: must specify limits.cpu,limits.memory,requests.cpu,requests.memory\nWhen a quota for a specific resource (CPU or memory) is configured (request or\nlimit), pods need to have the request or limit (respectively) set for that same resource;\notherwise the API server will not accept the pod. That\u2019s why having a LimitRange with\ndefaults for those resources can make life a bit easier for people creating pods.\n14.5.2 Specifying a quota for persistent storage\nA ResourceQuota object can also limit the amount of persistent storage that can be\nclaimed in the namespace, as shown in the following listing.\napiVersion: v1\nkind: ResourceQuota\nmetadata:\n  name: storage\nspec:\n  hard:\n    requests.storage: 500Gi                               \n    ssd.storageclass.storage.k8s.io/requests.storage: 300Gi     \n    standard.storageclass.storage.k8s.io/requests.storage: 1Ti\nIn this example, the amount of storage all PersistentVolumeClaims in a namespace\ncan request is limited to 500 GiB (by the requests.storage entry in the Resource-\nQuota object). But as you\u2019ll remember from chapter 6, PersistentVolumeClaims can\nrequest a dynamically provisioned PersistentVolume of a specific StorageClass. That\u2019s\nwhy Kubernetes also makes it possible to define storage quotas for each StorageClass\nindividually. The previous example limits the total amount of claimable SSD storage\n(designated by the ssd StorageClass) to 300 GiB. The less-performant HDD storage\n(StorageClass standard) is limited to 1 TiB.\n14.5.3 Limiting the number of objects that can be created\nA ResourceQuota can also be configured to limit the number of Pods, Replication-\nControllers, Services, and other objects inside a single namespace. This allows the\ncluster admin to limit the number of objects users can create based on their payment\nListing 14.15\nA ResourceQuota for storage: quota-storage.yaml\nThe amount of \nstorage claimable \noverall\nThe amount \nof claimable \nstorage in \nStorageClass ssd\n \n", "shape": "dot", "size": 10, "title": "427\nLimiting the total resources available in a namespace\nCREATING A LIMITRANGE ALONG WITH A RESOURCEQUOTA\nOne caveat when creating a ResourceQuota is that you will also want to create a Limit-\nRange object alongside it. In your case, you have a LimitRange configured from the\nprevious section, but if you didn\u2019t have one, you couldn\u2019t run the kubia-manual pod,\nbecause it doesn\u2019t specify any resource requests or limits. Here\u2019s what would happen\nin that case:\n$ kubectl create -f ../Chapter03/kubia-manual.yaml\nError from server (Forbidden): error when creating \"../Chapter03/kubia-\nmanual.yaml\": pods \"kubia-manual\" is forbidden: failed quota: cpu-and-\nmem: must specify limits.cpu,limits.memory,requests.cpu,requests.memory\nWhen a quota for a specific resource (CPU or memory) is configured (request or\nlimit), pods need to have the request or limit (respectively) set for that same resource;\notherwise the API server will not accept the pod. That\u2019s why having a LimitRange with\ndefaults for those resources can make life a bit easier for people creating pods.\n14.5.2 Specifying a quota for persistent storage\nA ResourceQuota object can also limit the amount of persistent storage that can be\nclaimed in the namespace, as shown in the following listing.\napiVersion: v1\nkind: ResourceQuota\nmetadata:\n  name: storage\nspec:\n  hard:\n    requests.storage: 500Gi                               \n    ssd.storageclass.storage.k8s.io/requests.storage: 300Gi     \n    standard.storageclass.storage.k8s.io/requests.storage: 1Ti\nIn this example, the amount of storage all PersistentVolumeClaims in a namespace\ncan request is limited to 500 GiB (by the requests.storage entry in the Resource-\nQuota object). But as you\u2019ll remember from chapter 6, PersistentVolumeClaims can\nrequest a dynamically provisioned PersistentVolume of a specific StorageClass. That\u2019s\nwhy Kubernetes also makes it possible to define storage quotas for each StorageClass\nindividually. The previous example limits the total amount of claimable SSD storage\n(designated by the ssd StorageClass) to 300 GiB. The less-performant HDD storage\n(StorageClass standard) is limited to 1 TiB.\n14.5.3 Limiting the number of objects that can be created\nA ResourceQuota can also be configured to limit the number of Pods, Replication-\nControllers, Services, and other objects inside a single namespace. This allows the\ncluster admin to limit the number of objects users can create based on their payment\nListing 14.15\nA ResourceQuota for storage: quota-storage.yaml\nThe amount of \nstorage claimable \noverall\nThe amount \nof claimable \nstorage in \nStorageClass ssd\n \n"}, {"color": "green", "id": "text_371", "label": "428\nCHAPTER 14\nManaging pods\u2019 computational resources\nplan, for example, and can also limit the number of public IPs or node ports Ser-\nvices can use. \n The following listing shows what a ResourceQuota object that limits the number of\nobjects may look like.\napiVersion: v1\nkind: ResourceQuota\nmetadata:\n  name: objects\nspec:\n  hard:\n    pods: 10                        \n    replicationcontrollers: 5       \n    secrets: 10                     \n    configmaps: 10                  \n    persistentvolumeclaims: 4       \n    services: 5                      \n    services.loadbalancers: 1        \n    services.nodeports: 2            \n    ssd.storageclass.storage.k8s.io/persistentvolumeclaims: 2   \nThe ResourceQuota in this listing allows users to create at most 10 Pods in the name-\nspace, regardless if they\u2019re created manually or by a ReplicationController, Replica-\nSet, DaemonSet, Job, and so on. It also limits the number of ReplicationControllers to\nfive. A maximum of five Services can be created, of which only one can be a LoadBal-\nancer-type Service, and only two can be NodePort Services. Similar to how the maxi-\nmum amount of requested storage can be specified per StorageClass, the number of\nPersistentVolumeClaims can also be limited per StorageClass.\n Object count quotas can currently be set for the following objects: \n\uf0a1Pods\n\uf0a1ReplicationControllers \n\uf0a1Secrets\n\uf0a1ConfigMaps\n\uf0a1PersistentVolumeClaims\n\uf0a1Services (in general), and for two specific types of Services, such as Load-\nBalancer Services (services.loadbalancers) and NodePort Services (ser-\nvices.nodeports) \nFinally, you can even set an object count quota for ResourceQuota objects themselves.\nThe number of other objects, such as ReplicaSets, Jobs, Deployments, Ingresses, and\nso on, cannot be limited yet (but this may have changed since the book was published,\nso please check the documentation for up-to-date information).\nListing 14.16\nA ResourceQuota for max number of resources: quota-object-count.yaml\nOnly 10 Pods, 5 ReplicationControllers, \n10 Secrets, 10 ConfigMaps, and \n4 PersistentVolumeClaims can be \ncreated in the namespace.\nFive Services overall can be created, \nof which at most one can be a \nLoadBalancer Service and at most \ntwo can be NodePort Services.\nOnly two PVCs can claim storage\nwith the ssd StorageClass.\n \n", "shape": "dot", "size": 10, "title": "428\nCHAPTER 14\nManaging pods\u2019 computational resources\nplan, for example, and can also limit the number of public IPs or node ports Ser-\nvices can use. \n The following listing shows what a ResourceQuota object that limits the number of\nobjects may look like.\napiVersion: v1\nkind: ResourceQuota\nmetadata:\n  name: objects\nspec:\n  hard:\n    pods: 10                        \n    replicationcontrollers: 5       \n    secrets: 10                     \n    configmaps: 10                  \n    persistentvolumeclaims: 4       \n    services: 5                      \n    services.loadbalancers: 1        \n    services.nodeports: 2            \n    ssd.storageclass.storage.k8s.io/persistentvolumeclaims: 2   \nThe ResourceQuota in this listing allows users to create at most 10 Pods in the name-\nspace, regardless if they\u2019re created manually or by a ReplicationController, Replica-\nSet, DaemonSet, Job, and so on. It also limits the number of ReplicationControllers to\nfive. A maximum of five Services can be created, of which only one can be a LoadBal-\nancer-type Service, and only two can be NodePort Services. Similar to how the maxi-\nmum amount of requested storage can be specified per StorageClass, the number of\nPersistentVolumeClaims can also be limited per StorageClass.\n Object count quotas can currently be set for the following objects: \n\uf0a1Pods\n\uf0a1ReplicationControllers \n\uf0a1Secrets\n\uf0a1ConfigMaps\n\uf0a1PersistentVolumeClaims\n\uf0a1Services (in general), and for two specific types of Services, such as Load-\nBalancer Services (services.loadbalancers) and NodePort Services (ser-\nvices.nodeports) \nFinally, you can even set an object count quota for ResourceQuota objects themselves.\nThe number of other objects, such as ReplicaSets, Jobs, Deployments, Ingresses, and\nso on, cannot be limited yet (but this may have changed since the book was published,\nso please check the documentation for up-to-date information).\nListing 14.16\nA ResourceQuota for max number of resources: quota-object-count.yaml\nOnly 10 Pods, 5 ReplicationControllers, \n10 Secrets, 10 ConfigMaps, and \n4 PersistentVolumeClaims can be \ncreated in the namespace.\nFive Services overall can be created, \nof which at most one can be a \nLoadBalancer Service and at most \ntwo can be NodePort Services.\nOnly two PVCs can claim storage\nwith the ssd StorageClass.\n \n"}, {"color": "green", "id": "text_372", "label": "429\nLimiting the total resources available in a namespace\n14.5.4 Specifying quotas for specific pod states and/or QoS classes\nThe quotas you\u2019ve created so far have applied to all pods, regardless of their current\nstate and QoS class. But quotas can also be limited to a set of quota scopes. Four scopes are\ncurrently available: BestEffort, NotBestEffort, Terminating, and NotTerminating. \n The BestEffort and NotBestEffort scopes determine whether the quota applies\nto pods with the BestEffort QoS class or with one of the other two classes (that is,\nBurstable and Guaranteed). \n The other two scopes (Terminating and NotTerminating) don\u2019t apply to pods\nthat are (or aren\u2019t) in the process of shutting down, as the name might lead you to\nbelieve. We haven\u2019t talked about this, but you can specify how long each pod is\nallowed to run before it\u2019s terminated and marked as Failed. This is done by setting\nthe activeDeadlineSeconds field in the pod spec. This property defines the number\nof seconds a pod is allowed to be active on the node relative to its start time before it\u2019s\nmarked as Failed and then terminated. The Terminating quota scope applies to pods\nthat have the activeDeadlineSeconds set, whereas the NotTerminating applies to\nthose that don\u2019t. \n When creating a ResourceQuota, you can specify the scopes that it applies to. A\npod must match all the specified scopes for the quota to apply to it. Additionally, what\na quota can limit depends on the quota\u2019s scope. BestEffort scope can only limit the\nnumber of pods, whereas the other three scopes can limit the number of pods,\nCPU/memory requests, and CPU/memory limits. \n If, for example, you want the quota to apply only to BestEffort, NotTerminating\npods, you can create the ResourceQuota object shown in the following listing.\napiVersion: v1\nkind: ResourceQuota\nmetadata:\n  name: besteffort-notterminating-pods\nspec:\n  scopes:                 \n  - BestEffort            \n  - NotTerminating        \n  hard: \n    pods: 4          \nThis quota ensures that at most four pods exist with the BestEffort QoS class,\nwhich don\u2019t have an active deadline. If the quota was targeting NotBestEffort pods\ninstead, you could also specify requests.cpu, requests.memory, limits.cpu, and\nlimits.memory.\nNOTE\nBefore you move on to the next section of this chapter, please delete\nall the ResourceQuota and LimitRange resources you created. You won\u2019t\nListing 14.17\nResourceQuota for BestEffort/NotTerminating pods: \nquota-scoped.yaml\nThis quota only applies to pods \nthat have the BestEffort QoS and \ndon\u2019t have an active deadline set.\nOnly four such \npods can exist.\n \n", "shape": "dot", "size": 10, "title": "429\nLimiting the total resources available in a namespace\n14.5.4 Specifying quotas for specific pod states and/or QoS classes\nThe quotas you\u2019ve created so far have applied to all pods, regardless of their current\nstate and QoS class. But quotas can also be limited to a set of quota scopes. Four scopes are\ncurrently available: BestEffort, NotBestEffort, Terminating, and NotTerminating. \n The BestEffort and NotBestEffort scopes determine whether the quota applies\nto pods with the BestEffort QoS class or with one of the other two classes (that is,\nBurstable and Guaranteed). \n The other two scopes (Terminating and NotTerminating) don\u2019t apply to pods\nthat are (or aren\u2019t) in the process of shutting down, as the name might lead you to\nbelieve. We haven\u2019t talked about this, but you can specify how long each pod is\nallowed to run before it\u2019s terminated and marked as Failed. This is done by setting\nthe activeDeadlineSeconds field in the pod spec. This property defines the number\nof seconds a pod is allowed to be active on the node relative to its start time before it\u2019s\nmarked as Failed and then terminated. The Terminating quota scope applies to pods\nthat have the activeDeadlineSeconds set, whereas the NotTerminating applies to\nthose that don\u2019t. \n When creating a ResourceQuota, you can specify the scopes that it applies to. A\npod must match all the specified scopes for the quota to apply to it. Additionally, what\na quota can limit depends on the quota\u2019s scope. BestEffort scope can only limit the\nnumber of pods, whereas the other three scopes can limit the number of pods,\nCPU/memory requests, and CPU/memory limits. \n If, for example, you want the quota to apply only to BestEffort, NotTerminating\npods, you can create the ResourceQuota object shown in the following listing.\napiVersion: v1\nkind: ResourceQuota\nmetadata:\n  name: besteffort-notterminating-pods\nspec:\n  scopes:                 \n  - BestEffort            \n  - NotTerminating        \n  hard: \n    pods: 4          \nThis quota ensures that at most four pods exist with the BestEffort QoS class,\nwhich don\u2019t have an active deadline. If the quota was targeting NotBestEffort pods\ninstead, you could also specify requests.cpu, requests.memory, limits.cpu, and\nlimits.memory.\nNOTE\nBefore you move on to the next section of this chapter, please delete\nall the ResourceQuota and LimitRange resources you created. You won\u2019t\nListing 14.17\nResourceQuota for BestEffort/NotTerminating pods: \nquota-scoped.yaml\nThis quota only applies to pods \nthat have the BestEffort QoS and \ndon\u2019t have an active deadline set.\nOnly four such \npods can exist.\n \n"}, {"color": "green", "id": "text_373", "label": "430\nCHAPTER 14\nManaging pods\u2019 computational resources\nneed them anymore and they may interfere with examples in the following\nchapters.\n14.6\nMonitoring pod resource usage\nProperly setting resource requests and limits is crucial for getting the most out of your\nKubernetes cluster. If requests are set too high, your cluster nodes will be underuti-\nlized and you\u2019ll be throwing money away. If you set them too low, your apps will be\nCPU-starved or even killed by the OOM Killer. How do you find the sweet spot for\nrequests and limits?\n You find it by monitoring the actual resource usage of your containers under the\nexpected load levels. Once the application is exposed to the public, you should keep\nmonitoring it and adjust the resource requests and limits if required.\n14.6.1 Collecting and retrieving actual resource usages\nHow does one monitor apps running in Kubernetes? Luckily, the Kubelet itself\nalready contains an agent called cAdvisor, which performs the basic collection of\nresource consumption data for both individual containers running on the node and\nthe node as a whole. Gathering those statistics centrally for the whole cluster requires\nyou to run an additional component called Heapster. \n Heapster runs as a pod on one of the nodes and is exposed through a regular\nKubernetes Service, making it accessible at a stable IP address. It collects the data\nfrom all cAdvisors in the cluster and exposes it in a single location. Figure 14.8\nshows the flow of the metrics data from the pods, through cAdvisor and finally into\nHeapster.\nKubelet\ncAdvisor\nNode 1\nPod\nPod\nKubelet\ncAdvisor\nNode 2\nPod\nKubelet\ncAdvisor\nNode X\nPod\nHeapster\nEach cAdvisor collects metrics from\ncontainers running on its node.\nHeapster runs on one of the nodes as a\npod and collects metrics from all nodes.\nFigure 14.8\nThe flow of metrics data into Heapster\n \n", "shape": "dot", "size": 10, "title": "430\nCHAPTER 14\nManaging pods\u2019 computational resources\nneed them anymore and they may interfere with examples in the following\nchapters.\n14.6\nMonitoring pod resource usage\nProperly setting resource requests and limits is crucial for getting the most out of your\nKubernetes cluster. If requests are set too high, your cluster nodes will be underuti-\nlized and you\u2019ll be throwing money away. If you set them too low, your apps will be\nCPU-starved or even killed by the OOM Killer. How do you find the sweet spot for\nrequests and limits?\n You find it by monitoring the actual resource usage of your containers under the\nexpected load levels. Once the application is exposed to the public, you should keep\nmonitoring it and adjust the resource requests and limits if required.\n14.6.1 Collecting and retrieving actual resource usages\nHow does one monitor apps running in Kubernetes? Luckily, the Kubelet itself\nalready contains an agent called cAdvisor, which performs the basic collection of\nresource consumption data for both individual containers running on the node and\nthe node as a whole. Gathering those statistics centrally for the whole cluster requires\nyou to run an additional component called Heapster. \n Heapster runs as a pod on one of the nodes and is exposed through a regular\nKubernetes Service, making it accessible at a stable IP address. It collects the data\nfrom all cAdvisors in the cluster and exposes it in a single location. Figure 14.8\nshows the flow of the metrics data from the pods, through cAdvisor and finally into\nHeapster.\nKubelet\ncAdvisor\nNode 1\nPod\nPod\nKubelet\ncAdvisor\nNode 2\nPod\nKubelet\ncAdvisor\nNode X\nPod\nHeapster\nEach cAdvisor collects metrics from\ncontainers running on its node.\nHeapster runs on one of the nodes as a\npod and collects metrics from all nodes.\nFigure 14.8\nThe flow of metrics data into Heapster\n \n"}, {"color": "green", "id": "text_374", "label": "431\nMonitoring pod resource usage\nThe arrows in the figure show how the metrics data flows. They don\u2019t show which com-\nponent connects to which to get the data. The pods (or the containers running\ntherein) don\u2019t know anything about cAdvisor, and cAdvisor doesn\u2019t know anything\nabout Heapster. It\u2019s Heapster that connects to all the cAdvisors, and it\u2019s the cAdvisors\nthat collect the container and node usage data without having to talk to the processes\nrunning inside the pods\u2019 containers.\nENABLING HEAPSTER\nIf you\u2019re running a cluster in Google Kubernetes Engine, Heapster is enabled by\ndefault. If you\u2019re using Minikube, it\u2019s available as an add-on and can be enabled with\nthe following command:\n$ minikube addons enable heapster\nheapster was successfully enabled\nTo run Heapster manually in other types of Kubernetes clusters, you can refer to\ninstructions located at https:/\n/github.com/kubernetes/heapster. \n After enabling Heapster, you\u2019ll need to wait a few minutes for it to collect metrics\nbefore you can see resource usage statistics for your cluster, so be patient. \nDISPLAYING CPU AND MEMORY USAGE FOR CLUSTER NODES\nRunning Heapster in your cluster makes it possible to obtain resource usages for\nnodes and individual pods through the kubectl top command. To see how much\nCPU and memory is being used on your nodes, you can run the command shown in\nthe following listing.\n$ kubectl top node\nNAME       CPU(cores)   CPU%      MEMORY(bytes)   MEMORY%\nminikube   170m         8%        556Mi           27%\nThis shows the actual, current CPU and memory usage of all the pods running on the\nnode, unlike the kubectl describe node command, which shows the amount of CPU\nand memory requests and limits instead of actual runtime usage data. \nDISPLAYING CPU AND MEMORY USAGE FOR INDIVIDUAL PODS\nTo see how much each individual pod is using, you can use the kubectl top pod com-\nmand, as shown in the following listing.\n$ kubectl top pod --all-namespaces\nNAMESPACE      NAME                             CPU(cores)   MEMORY(bytes)\nkube-system    influxdb-grafana-2r2w9           1m           32Mi\nkube-system    heapster-40j6d                   0m           18Mi\nListing 14.18\nActual CPU and memory usage of nodes\nListing 14.19\nActual CPU and memory usages of pods\n \n", "shape": "dot", "size": 10, "title": "431\nMonitoring pod resource usage\nThe arrows in the figure show how the metrics data flows. They don\u2019t show which com-\nponent connects to which to get the data. The pods (or the containers running\ntherein) don\u2019t know anything about cAdvisor, and cAdvisor doesn\u2019t know anything\nabout Heapster. It\u2019s Heapster that connects to all the cAdvisors, and it\u2019s the cAdvisors\nthat collect the container and node usage data without having to talk to the processes\nrunning inside the pods\u2019 containers.\nENABLING HEAPSTER\nIf you\u2019re running a cluster in Google Kubernetes Engine, Heapster is enabled by\ndefault. If you\u2019re using Minikube, it\u2019s available as an add-on and can be enabled with\nthe following command:\n$ minikube addons enable heapster\nheapster was successfully enabled\nTo run Heapster manually in other types of Kubernetes clusters, you can refer to\ninstructions located at https:/\n/github.com/kubernetes/heapster. \n After enabling Heapster, you\u2019ll need to wait a few minutes for it to collect metrics\nbefore you can see resource usage statistics for your cluster, so be patient. \nDISPLAYING CPU AND MEMORY USAGE FOR CLUSTER NODES\nRunning Heapster in your cluster makes it possible to obtain resource usages for\nnodes and individual pods through the kubectl top command. To see how much\nCPU and memory is being used on your nodes, you can run the command shown in\nthe following listing.\n$ kubectl top node\nNAME       CPU(cores)   CPU%      MEMORY(bytes)   MEMORY%\nminikube   170m         8%        556Mi           27%\nThis shows the actual, current CPU and memory usage of all the pods running on the\nnode, unlike the kubectl describe node command, which shows the amount of CPU\nand memory requests and limits instead of actual runtime usage data. \nDISPLAYING CPU AND MEMORY USAGE FOR INDIVIDUAL PODS\nTo see how much each individual pod is using, you can use the kubectl top pod com-\nmand, as shown in the following listing.\n$ kubectl top pod --all-namespaces\nNAMESPACE      NAME                             CPU(cores)   MEMORY(bytes)\nkube-system    influxdb-grafana-2r2w9           1m           32Mi\nkube-system    heapster-40j6d                   0m           18Mi\nListing 14.18\nActual CPU and memory usage of nodes\nListing 14.19\nActual CPU and memory usages of pods\n \n"}, {"color": "green", "id": "text_375", "label": "432\nCHAPTER 14\nManaging pods\u2019 computational resources\ndefault        kubia-3773182134-63bmb           0m           9Mi\nkube-system    kube-dns-v20-z0hq6               1m           11Mi\nkube-system    kubernetes-dashboard-r53mc       0m           14Mi\nkube-system    kube-addon-manager-minikube      7m           33Mi\nThe outputs of both these commands are fairly simple, so you probably don\u2019t need me\nto explain them, but I do need to warn you about one thing. Sometimes the top pod\ncommand will refuse to show any metrics and instead print out an error like this:\n$ kubectl top pod\nW0312 22:12:58.021885   15126 top_pod.go:186] Metrics not available for pod \ndefault/kubia-3773182134-63bmb, age: 1h24m19.021873823s\nerror: Metrics not available for pod default/kubia-3773182134-63bmb, age: \n1h24m19.021873823s\nIf this happens, don\u2019t start looking for the cause of the error yet. Relax, wait a while,\nand rerun the command\u2014it may take a few minutes, but the metrics should appear\neventually. The kubectl top command gets the metrics from Heapster, which aggre-\ngates the data over a few minutes and doesn\u2019t expose it immediately. \nTIP\nTo see resource usages across individual containers instead of pods, you\ncan use the --containers option. \n14.6.2 Storing and analyzing historical resource consumption statistics\nThe top command only shows current resource usages\u2014it doesn\u2019t show you how\nmuch CPU or memory your pods consumed throughout the last hour, yesterday, or a\nweek ago, for example. In fact, both cAdvisor and Heapster only hold resource usage\ndata for a short window of time. If you want to analyze your pods\u2019 resource consump-\ntion over longer time periods, you\u2019ll need to run additional tools.\n When using Google Kubernetes Engine, you can monitor your cluster with Google\nCloud Monitoring, but when you\u2019re running your own local Kubernetes cluster\n(either through Minikube or other means), people usually use InfluxDB for storing\nstatistics data and Grafana for visualizing and analyzing them. \nINTRODUCING INFLUXDB AND GRAFANA\nInfluxDB is an open source time-series database ideal for storing application metrics\nand other monitoring data. Grafana, also open source, is an analytics and visualization\nsuite with a nice-looking web console that allows you to visualize the data stored in\nInfluxDB and discover how your application\u2019s resource usage behaves over time (an\nexample showing three Grafana charts is shown in figure 14.9).\n \n \n", "shape": "dot", "size": 10, "title": "432\nCHAPTER 14\nManaging pods\u2019 computational resources\ndefault        kubia-3773182134-63bmb           0m           9Mi\nkube-system    kube-dns-v20-z0hq6               1m           11Mi\nkube-system    kubernetes-dashboard-r53mc       0m           14Mi\nkube-system    kube-addon-manager-minikube      7m           33Mi\nThe outputs of both these commands are fairly simple, so you probably don\u2019t need me\nto explain them, but I do need to warn you about one thing. Sometimes the top pod\ncommand will refuse to show any metrics and instead print out an error like this:\n$ kubectl top pod\nW0312 22:12:58.021885   15126 top_pod.go:186] Metrics not available for pod \ndefault/kubia-3773182134-63bmb, age: 1h24m19.021873823s\nerror: Metrics not available for pod default/kubia-3773182134-63bmb, age: \n1h24m19.021873823s\nIf this happens, don\u2019t start looking for the cause of the error yet. Relax, wait a while,\nand rerun the command\u2014it may take a few minutes, but the metrics should appear\neventually. The kubectl top command gets the metrics from Heapster, which aggre-\ngates the data over a few minutes and doesn\u2019t expose it immediately. \nTIP\nTo see resource usages across individual containers instead of pods, you\ncan use the --containers option. \n14.6.2 Storing and analyzing historical resource consumption statistics\nThe top command only shows current resource usages\u2014it doesn\u2019t show you how\nmuch CPU or memory your pods consumed throughout the last hour, yesterday, or a\nweek ago, for example. In fact, both cAdvisor and Heapster only hold resource usage\ndata for a short window of time. If you want to analyze your pods\u2019 resource consump-\ntion over longer time periods, you\u2019ll need to run additional tools.\n When using Google Kubernetes Engine, you can monitor your cluster with Google\nCloud Monitoring, but when you\u2019re running your own local Kubernetes cluster\n(either through Minikube or other means), people usually use InfluxDB for storing\nstatistics data and Grafana for visualizing and analyzing them. \nINTRODUCING INFLUXDB AND GRAFANA\nInfluxDB is an open source time-series database ideal for storing application metrics\nand other monitoring data. Grafana, also open source, is an analytics and visualization\nsuite with a nice-looking web console that allows you to visualize the data stored in\nInfluxDB and discover how your application\u2019s resource usage behaves over time (an\nexample showing three Grafana charts is shown in figure 14.9).\n \n \n"}, {"color": "green", "id": "text_376", "label": "433\nMonitoring pod resource usage\nRUNNING INFLUXDB AND GRAFANA IN YOUR CLUSTER\nBoth InfluxDB and Grafana can run as pods. Deploying them is straightforward. All\nthe necessary manifests are available in the Heapster Git repository at http:/\n/github\n.com/kubernetes/heapster/tree/master/deploy/kube-config/influxdb.\n When using Minikube, you don\u2019t even need to deploy them manually, because\nthey\u2019re deployed along with Heapster when you enable the Heapster add-on.\nANALYZING RESOURCE USAGE WITH GRAFANA\nTo discover how much of each resource your pod requires over time, open the\nGrafana web console and explore the predefined dashboards. Generally, you can find\nout the URL of Grafana\u2019s web console with kubectl cluster-info:\n$ kubectl cluster-info\n...\nmonitoring-grafana is running at \nhttps://192.168.99.100:8443/api/v1/proxy/namespaces/kube-\nsystem/services/monitoring-grafana\nFigure 14.9\nGrafana dashboard showing CPU usage across the cluster\n \n", "shape": "dot", "size": 10, "title": "433\nMonitoring pod resource usage\nRUNNING INFLUXDB AND GRAFANA IN YOUR CLUSTER\nBoth InfluxDB and Grafana can run as pods. Deploying them is straightforward. All\nthe necessary manifests are available in the Heapster Git repository at http:/\n/github\n.com/kubernetes/heapster/tree/master/deploy/kube-config/influxdb.\n When using Minikube, you don\u2019t even need to deploy them manually, because\nthey\u2019re deployed along with Heapster when you enable the Heapster add-on.\nANALYZING RESOURCE USAGE WITH GRAFANA\nTo discover how much of each resource your pod requires over time, open the\nGrafana web console and explore the predefined dashboards. Generally, you can find\nout the URL of Grafana\u2019s web console with kubectl cluster-info:\n$ kubectl cluster-info\n...\nmonitoring-grafana is running at \nhttps://192.168.99.100:8443/api/v1/proxy/namespaces/kube-\nsystem/services/monitoring-grafana\nFigure 14.9\nGrafana dashboard showing CPU usage across the cluster\n \n"}, {"color": "green", "id": "text_377", "label": "434\nCHAPTER 14\nManaging pods\u2019 computational resources\nWhen using Minikube, Grafana\u2019s web console is exposed through a NodePort Service,\nso you can open it in your browser with the following command:\n$ minikube service monitoring-grafana -n kube-system\nOpening kubernetes service kube-system/monitoring-grafana in default \nbrowser...\nA new browser window or tab will open and show the Grafana Home screen. On the\nright-hand side, you\u2019ll see a list of dashboards containing two entries:\n\uf0a1Cluster\n\uf0a1Pods\nTo see the resource usage statistics of the nodes, open the Cluster dashboard. There\nyou\u2019ll see several charts showing the overall cluster usage, usage by node, and the\nindividual usage for CPU, memory, network, and filesystem. The charts will not only\nshow the actual usage, but also the requests and limits for those resources (where\nthey apply).\n If you then switch over to the Pods dashboard, you can examine the resource\nusages for each individual pod, again with both requests and limits shown alongside\nthe actual usage. \n Initially, the charts show the statistics for the last 30 minutes, but you can zoom out\nand see the data for much longer time periods: days, months, or even years.\nUSING THE INFORMATION SHOWN IN THE CHARTS\nBy looking at the charts, you can quickly see if the resource requests or limits you\u2019ve\nset for your pods need to be raised or whether they can be lowered to allow more pods\nto fit on your nodes. Let\u2019s look at an example. Figure 14.10 shows the CPU and mem-\nory charts for a pod.\n At the far right of the top chart, you can see the pod is using more CPU than was\nrequested in the pod\u2019s manifest. Although this isn\u2019t problematic when this is the only\npod running on the node, you should keep in mind that a pod is only guaranteed as\nmuch of a resource as it requests through resource requests. Your pod may be running\nfine now, but when other pods are deployed to the same node and start using the\nCPU, your pod\u2019s CPU time may be throttled. Because of this, to ensure the pod can\nuse as much CPU as it needs to at any time, you should raise the CPU resource request\nfor the pod\u2019s container.\n The bottom chart shows the pod\u2019s memory usage and request. Here the situation is\nthe exact opposite. The amount of memory the pod is using is well below what was\nrequested in the pod\u2019s spec. The requested memory is reserved for the pod and won\u2019t\nbe available to other pods. The unused memory is therefore wasted. You should\ndecrease the pod\u2019s memory request to make the memory available to other pods run-\nning on the node. \n \n", "shape": "dot", "size": 10, "title": "434\nCHAPTER 14\nManaging pods\u2019 computational resources\nWhen using Minikube, Grafana\u2019s web console is exposed through a NodePort Service,\nso you can open it in your browser with the following command:\n$ minikube service monitoring-grafana -n kube-system\nOpening kubernetes service kube-system/monitoring-grafana in default \nbrowser...\nA new browser window or tab will open and show the Grafana Home screen. On the\nright-hand side, you\u2019ll see a list of dashboards containing two entries:\n\uf0a1Cluster\n\uf0a1Pods\nTo see the resource usage statistics of the nodes, open the Cluster dashboard. There\nyou\u2019ll see several charts showing the overall cluster usage, usage by node, and the\nindividual usage for CPU, memory, network, and filesystem. The charts will not only\nshow the actual usage, but also the requests and limits for those resources (where\nthey apply).\n If you then switch over to the Pods dashboard, you can examine the resource\nusages for each individual pod, again with both requests and limits shown alongside\nthe actual usage. \n Initially, the charts show the statistics for the last 30 minutes, but you can zoom out\nand see the data for much longer time periods: days, months, or even years.\nUSING THE INFORMATION SHOWN IN THE CHARTS\nBy looking at the charts, you can quickly see if the resource requests or limits you\u2019ve\nset for your pods need to be raised or whether they can be lowered to allow more pods\nto fit on your nodes. Let\u2019s look at an example. Figure 14.10 shows the CPU and mem-\nory charts for a pod.\n At the far right of the top chart, you can see the pod is using more CPU than was\nrequested in the pod\u2019s manifest. Although this isn\u2019t problematic when this is the only\npod running on the node, you should keep in mind that a pod is only guaranteed as\nmuch of a resource as it requests through resource requests. Your pod may be running\nfine now, but when other pods are deployed to the same node and start using the\nCPU, your pod\u2019s CPU time may be throttled. Because of this, to ensure the pod can\nuse as much CPU as it needs to at any time, you should raise the CPU resource request\nfor the pod\u2019s container.\n The bottom chart shows the pod\u2019s memory usage and request. Here the situation is\nthe exact opposite. The amount of memory the pod is using is well below what was\nrequested in the pod\u2019s spec. The requested memory is reserved for the pod and won\u2019t\nbe available to other pods. The unused memory is therefore wasted. You should\ndecrease the pod\u2019s memory request to make the memory available to other pods run-\nning on the node. \n \n"}, {"color": "green", "id": "text_378", "label": "435\nSummary\n14.7\nSummary\nThis chapter has shown you that you need to consider your pod\u2019s resource usage and\nconfigure both the resource requests and the limits for your pod to keep everything\nrunning smoothly. The key takeaways from this chapter are\n\uf0a1Specifying resource requests helps Kubernetes schedule pods across the cluster.\n\uf0a1Specifying resource limits keeps pods from starving other pods of resources.\n\uf0a1Unused CPU time is allocated based on containers\u2019 CPU requests.\n\uf0a1Containers never get killed if they try to use too much CPU, but they are killed\nif they try to use too much memory.\n\uf0a1In an overcommitted system, containers also get killed to free memory for more\nimportant pods, based on the pods\u2019 QoS classes and actual memory usage.\nActual CPU usage is higher\nthan what was requested.\nThe application\u2019s CPU time\nwill be throttled when other\napps demand more CPU.\nYou should increase the\nCPU request.\nActual memory usage is well\nbelow requested memory.\nYou\u2019ve reserved too much\nmemory for this app. You\u2019re\nwasting memory, because it\nwon\u2019t ever be used by this\napp and also can\u2019t be used\nby other apps. You should\ndecrease the memory\nrequest.\nCPU request\nCPU usage\nMemory request\nMemory usage\nFigure 14.10\nCPU and memory usage chart for a pod\n \n", "shape": "dot", "size": 10, "title": "435\nSummary\n14.7\nSummary\nThis chapter has shown you that you need to consider your pod\u2019s resource usage and\nconfigure both the resource requests and the limits for your pod to keep everything\nrunning smoothly. The key takeaways from this chapter are\n\uf0a1Specifying resource requests helps Kubernetes schedule pods across the cluster.\n\uf0a1Specifying resource limits keeps pods from starving other pods of resources.\n\uf0a1Unused CPU time is allocated based on containers\u2019 CPU requests.\n\uf0a1Containers never get killed if they try to use too much CPU, but they are killed\nif they try to use too much memory.\n\uf0a1In an overcommitted system, containers also get killed to free memory for more\nimportant pods, based on the pods\u2019 QoS classes and actual memory usage.\nActual CPU usage is higher\nthan what was requested.\nThe application\u2019s CPU time\nwill be throttled when other\napps demand more CPU.\nYou should increase the\nCPU request.\nActual memory usage is well\nbelow requested memory.\nYou\u2019ve reserved too much\nmemory for this app. You\u2019re\nwasting memory, because it\nwon\u2019t ever be used by this\napp and also can\u2019t be used\nby other apps. You should\ndecrease the memory\nrequest.\nCPU request\nCPU usage\nMemory request\nMemory usage\nFigure 14.10\nCPU and memory usage chart for a pod\n \n"}, {"color": "green", "id": "text_379", "label": "436\nCHAPTER 14\nManaging pods\u2019 computational resources\n\uf0a1You can use LimitRange objects to define the minimum, maximum, and default\nresource requests and limits for individual pods.\n\uf0a1You can use ResourceQuota objects to limit the amount of resources available\nto all the pods in a namespace.\n\uf0a1To know how high to set a pod\u2019s resource requests and limits, you need to mon-\nitor how the pod uses resources over a long-enough time period.\nIn the next chapter, you\u2019ll see how these metrics can be used by Kubernetes to auto-\nmatically scale your pods.\n \n", "shape": "dot", "size": 10, "title": "436\nCHAPTER 14\nManaging pods\u2019 computational resources\n\uf0a1You can use LimitRange objects to define the minimum, maximum, and default\nresource requests and limits for individual pods.\n\uf0a1You can use ResourceQuota objects to limit the amount of resources available\nto all the pods in a namespace.\n\uf0a1To know how high to set a pod\u2019s resource requests and limits, you need to mon-\nitor how the pod uses resources over a long-enough time period.\nIn the next chapter, you\u2019ll see how these metrics can be used by Kubernetes to auto-\nmatically scale your pods.\n \n"}, {"color": "green", "id": "text_380", "label": "437\nAutomatic scaling\nof pods and cluster nodes\nApplications running in pods can be scaled out manually by increasing the\nreplicas field in the ReplicationController, ReplicaSet, Deployment, or other\nscalable resource. Pods can also be scaled vertically by increasing their container\u2019s\nresource requests and limits (though this can currently only be done at pod cre-\nation time, not while the pod is running). Although manual scaling is okay for\ntimes when you can anticipate load spikes in advance or when the load changes\ngradually over longer periods of time, requiring manual intervention to handle\nsudden, unpredictable traffic increases isn\u2019t ideal. \nThis chapter covers\n\uf0a1Configuring automatic horizontal scaling of pods \nbased on CPU utilization\n\uf0a1Configuring automatic horizontal scaling of pods \nbased on custom metrics\n\uf0a1Understanding why vertical scaling of pods isn\u2019t \npossible yet\n\uf0a1Understanding automatic horizontal scaling of \ncluster nodes\n \n", "shape": "dot", "size": 10, "title": "437\nAutomatic scaling\nof pods and cluster nodes\nApplications running in pods can be scaled out manually by increasing the\nreplicas field in the ReplicationController, ReplicaSet, Deployment, or other\nscalable resource. Pods can also be scaled vertically by increasing their container\u2019s\nresource requests and limits (though this can currently only be done at pod cre-\nation time, not while the pod is running). Although manual scaling is okay for\ntimes when you can anticipate load spikes in advance or when the load changes\ngradually over longer periods of time, requiring manual intervention to handle\nsudden, unpredictable traffic increases isn\u2019t ideal. \nThis chapter covers\n\uf0a1Configuring automatic horizontal scaling of pods \nbased on CPU utilization\n\uf0a1Configuring automatic horizontal scaling of pods \nbased on custom metrics\n\uf0a1Understanding why vertical scaling of pods isn\u2019t \npossible yet\n\uf0a1Understanding automatic horizontal scaling of \ncluster nodes\n \n"}, {"color": "green", "id": "text_381", "label": "438\nCHAPTER 15\nAutomatic scaling of pods and cluster nodes\n Luckily, Kubernetes can monitor your pods and scale them up automatically as\nsoon as it detects an increase in the CPU usage or some other metric. If running on a\ncloud infrastructure, it can even spin up additional nodes if the existing ones can\u2019t\naccept any more pods. This chapter will explain how to get Kubernetes to do both pod\nand node autoscaling.\n The autoscaling feature in Kubernetes was completely rewritten between the 1.6\nand the 1.7 version, so be aware you may find outdated information on this subject\nonline.\n15.1\nHorizontal pod autoscaling\nHorizontal pod autoscaling is the automatic scaling of the number of pod replicas man-\naged by a controller. It\u2019s performed by the Horizontal controller, which is enabled and\nconfigured by creating a HorizontalPodAutoscaler (HPA) resource. The controller\nperiodically checks pod metrics, calculates the number of replicas required to meet\nthe target metric value configured in the HorizontalPodAutoscaler resource, and\nadjusts the replicas field on the target resource (Deployment, ReplicaSet, Replication-\nController, or StatefulSet). \n15.1.1 Understanding the autoscaling process\nThe autoscaling process can be split into three steps:\n\uf0a1Obtain metrics of all the pods managed by the scaled resource object.\n\uf0a1Calculate the number of pods required to bring the metrics to (or close to) the\nspecified target value.\n\uf0a1Update the replicas field of the scaled resource.\nLet\u2019s examine all three steps next.\nOBTAINING POD METRICS\nThe Autoscaler doesn\u2019t perform the gathering of the pod metrics itself. It gets the\nmetrics from a different source. As we saw in the previous chapter, pod and node met-\nrics are collected by an agent called cAdvisor, which runs in the Kubelet on each node,\nand then aggregated by the cluster-wide component called Heapster. The horizontal\npod autoscaler controller gets the metrics of all the pods by querying Heapster\nthrough REST calls. The flow of metrics data is shown in figure 15.1 (although all the\nconnections are initiated in the opposite direction).\nThis implies that Heapster must be running in the cluster for autoscaling to work. If\nyou\u2019re using Minikube and were following along in the previous chapter, Heapster\nPod(s)\ncAdvisor(s)\nHorizontal Pod Autoscaler(s)\nHeapster\nFigure 15.1\nFlow of metrics from the pod(s) to the HorizontalPodAutoscaler(s)\n \n", "shape": "dot", "size": 10, "title": "438\nCHAPTER 15\nAutomatic scaling of pods and cluster nodes\n Luckily, Kubernetes can monitor your pods and scale them up automatically as\nsoon as it detects an increase in the CPU usage or some other metric. If running on a\ncloud infrastructure, it can even spin up additional nodes if the existing ones can\u2019t\naccept any more pods. This chapter will explain how to get Kubernetes to do both pod\nand node autoscaling.\n The autoscaling feature in Kubernetes was completely rewritten between the 1.6\nand the 1.7 version, so be aware you may find outdated information on this subject\nonline.\n15.1\nHorizontal pod autoscaling\nHorizontal pod autoscaling is the automatic scaling of the number of pod replicas man-\naged by a controller. It\u2019s performed by the Horizontal controller, which is enabled and\nconfigured by creating a HorizontalPodAutoscaler (HPA) resource. The controller\nperiodically checks pod metrics, calculates the number of replicas required to meet\nthe target metric value configured in the HorizontalPodAutoscaler resource, and\nadjusts the replicas field on the target resource (Deployment, ReplicaSet, Replication-\nController, or StatefulSet). \n15.1.1 Understanding the autoscaling process\nThe autoscaling process can be split into three steps:\n\uf0a1Obtain metrics of all the pods managed by the scaled resource object.\n\uf0a1Calculate the number of pods required to bring the metrics to (or close to) the\nspecified target value.\n\uf0a1Update the replicas field of the scaled resource.\nLet\u2019s examine all three steps next.\nOBTAINING POD METRICS\nThe Autoscaler doesn\u2019t perform the gathering of the pod metrics itself. It gets the\nmetrics from a different source. As we saw in the previous chapter, pod and node met-\nrics are collected by an agent called cAdvisor, which runs in the Kubelet on each node,\nand then aggregated by the cluster-wide component called Heapster. The horizontal\npod autoscaler controller gets the metrics of all the pods by querying Heapster\nthrough REST calls. The flow of metrics data is shown in figure 15.1 (although all the\nconnections are initiated in the opposite direction).\nThis implies that Heapster must be running in the cluster for autoscaling to work. If\nyou\u2019re using Minikube and were following along in the previous chapter, Heapster\nPod(s)\ncAdvisor(s)\nHorizontal Pod Autoscaler(s)\nHeapster\nFigure 15.1\nFlow of metrics from the pod(s) to the HorizontalPodAutoscaler(s)\n \n"}, {"color": "green", "id": "text_382", "label": "439\nHorizontal pod autoscaling\nshould already be enabled in your cluster. If not, make sure to enable the Heapster\nadd-on before trying out any autoscaling examples.\n Although you don\u2019t need to query Heapster directly, if you\u2019re interested in doing\nso, you\u2019ll find both the Heapster Pod and the Service it\u2019s exposed through in the\nkube-system namespace. \nCALCULATING THE REQUIRED NUMBER OF PODS\nOnce the Autoscaler has metrics for all the pods belonging to the resource the Auto-\nscaler is scaling (the Deployment, ReplicaSet, ReplicationController, or StatefulSet\nresource), it can use those metrics to figure out the required number of replicas. It\nneeds to find the number that will bring the average value of the metric across all\nthose replicas as close to the configured target value as possible. The input to this cal-\nculation is a set of pod metrics (possibly multiple metrics per pod) and the output is a\nsingle integer (the number of pod replicas). \n When the Autoscaler is configured to consider only a single metric, calculating the\nrequired replica count is simple. All it takes is summing up the metrics values of all\nthe pods, dividing that by the target value set on the HorizontalPodAutoscaler\nresource, and then rounding it up to the next-larger integer. The actual calculation is\na bit more involved than this, because it also makes sure the Autoscaler doesn\u2019t thrash\naround when the metric value is unstable and changes rapidly. \n When autoscaling is based on multiple pod metrics (for example, both CPU usage\nand Queries-Per-Second [QPS]), the calculation isn\u2019t that much more complicated.\nThe Autoscaler calculates the replica count for each metric individually and then\ntakes the highest value (for example, if four pods are required to achieve the target\nCPU usage, and three pods are required to achieve the target QPS, the Autoscaler will\nscale to four pods). Figure 15.2 shows this example.\nA look at changes related to how the Autoscaler obtains metrics\nPrior to Kubernetes version 1.6, the HorizontalPodAutoscaler obtained the metrics\nfrom Heapster directly. In version 1.8, the Autoscaler can get the metrics through an\naggregated version of the resource metrics API by starting the Controller Manager\nwith the --horizontal-pod-autoscaler-use-rest-clients=true flag. From ver-\nsion 1.9, this behavior will be enabled by default.\nThe core API server will not expose the metrics itself. From version 1.7, Kubernetes\nallows registering multiple API servers and making them appear as a single API\nserver. This allows it to expose metrics through one of those underlying API servers.\nWe\u2019ll explain API server aggregation in the last chapter. \nSelecting what metrics collector to use in their clusters will be up to cluster adminis-\ntrators. A simple translation layer is usually required to expose the metrics in the\nappropriate API paths and in the appropriate format.\n \n", "shape": "dot", "size": 10, "title": "439\nHorizontal pod autoscaling\nshould already be enabled in your cluster. If not, make sure to enable the Heapster\nadd-on before trying out any autoscaling examples.\n Although you don\u2019t need to query Heapster directly, if you\u2019re interested in doing\nso, you\u2019ll find both the Heapster Pod and the Service it\u2019s exposed through in the\nkube-system namespace. \nCALCULATING THE REQUIRED NUMBER OF PODS\nOnce the Autoscaler has metrics for all the pods belonging to the resource the Auto-\nscaler is scaling (the Deployment, ReplicaSet, ReplicationController, or StatefulSet\nresource), it can use those metrics to figure out the required number of replicas. It\nneeds to find the number that will bring the average value of the metric across all\nthose replicas as close to the configured target value as possible. The input to this cal-\nculation is a set of pod metrics (possibly multiple metrics per pod) and the output is a\nsingle integer (the number of pod replicas). \n When the Autoscaler is configured to consider only a single metric, calculating the\nrequired replica count is simple. All it takes is summing up the metrics values of all\nthe pods, dividing that by the target value set on the HorizontalPodAutoscaler\nresource, and then rounding it up to the next-larger integer. The actual calculation is\na bit more involved than this, because it also makes sure the Autoscaler doesn\u2019t thrash\naround when the metric value is unstable and changes rapidly. \n When autoscaling is based on multiple pod metrics (for example, both CPU usage\nand Queries-Per-Second [QPS]), the calculation isn\u2019t that much more complicated.\nThe Autoscaler calculates the replica count for each metric individually and then\ntakes the highest value (for example, if four pods are required to achieve the target\nCPU usage, and three pods are required to achieve the target QPS, the Autoscaler will\nscale to four pods). Figure 15.2 shows this example.\nA look at changes related to how the Autoscaler obtains metrics\nPrior to Kubernetes version 1.6, the HorizontalPodAutoscaler obtained the metrics\nfrom Heapster directly. In version 1.8, the Autoscaler can get the metrics through an\naggregated version of the resource metrics API by starting the Controller Manager\nwith the --horizontal-pod-autoscaler-use-rest-clients=true flag. From ver-\nsion 1.9, this behavior will be enabled by default.\nThe core API server will not expose the metrics itself. From version 1.7, Kubernetes\nallows registering multiple API servers and making them appear as a single API\nserver. This allows it to expose metrics through one of those underlying API servers.\nWe\u2019ll explain API server aggregation in the last chapter. \nSelecting what metrics collector to use in their clusters will be up to cluster adminis-\ntrators. A simple translation layer is usually required to expose the metrics in the\nappropriate API paths and in the appropriate format.\n \n"}, {"color": "green", "id": "text_383", "label": "440\nCHAPTER 15\nAutomatic scaling of pods and cluster nodes\nUPDATING THE DESIRED REPLICA COUNT ON THE SCALED RESOURCE\nThe final step of an autoscaling operation is updating the desired replica count field\non the scaled resource object (a ReplicaSet, for example) and then letting the Replica-\nSet controller take care of spinning up additional pods or deleting excess ones.\n The Autoscaler controller modifies the replicas field of the scaled resource\nthrough the Scale sub-resource. It enables the Autoscaler to do its work without know-\ning any details of the resource it\u2019s scaling, except for what\u2019s exposed through the Scale\nsub-resource (see figure 15.3).\nThis allows the Autoscaler to operate on any scalable resource, as long as the API\nserver exposes the Scale sub-resource for it. Currently, it\u2019s exposed for\n\uf0a1Deployments\n\uf0a1ReplicaSets\n\uf0a1ReplicationControllers\n\uf0a1StatefulSets\nThese are currently the only objects you can attach an Autoscaler to.\nPod 1\nCPU\nutilization\nQPS\nPod 2\nPod 3\nTarget\nCPU utilization\nTarget QPS\nReplicas: 4\nReplicas: 3\nReplicas: 4\n30\n12\n15\n20\n(15 + 30 + 12) / 20 = 57 / 20\n(60 + 90 + 50) / 50 = 200 / 50\nMax(4, 3)\n50%\n60%\n90%\n50%\nFigure 15.2\nCalculating the number of replicas from two metrics\nAutoscaler adjusts replicas (++ or --)\nHorizontal Pod Autoscaler\nDeployment, ReplicaSet,\nStatefulSet, or\nReplicationController\nScale\nsub-resource\nFigure 15.3\nThe Horizontal Pod Autoscaler modifies only on the Scale sub-resource.\n \n", "shape": "dot", "size": 10, "title": "440\nCHAPTER 15\nAutomatic scaling of pods and cluster nodes\nUPDATING THE DESIRED REPLICA COUNT ON THE SCALED RESOURCE\nThe final step of an autoscaling operation is updating the desired replica count field\non the scaled resource object (a ReplicaSet, for example) and then letting the Replica-\nSet controller take care of spinning up additional pods or deleting excess ones.\n The Autoscaler controller modifies the replicas field of the scaled resource\nthrough the Scale sub-resource. It enables the Autoscaler to do its work without know-\ning any details of the resource it\u2019s scaling, except for what\u2019s exposed through the Scale\nsub-resource (see figure 15.3).\nThis allows the Autoscaler to operate on any scalable resource, as long as the API\nserver exposes the Scale sub-resource for it. Currently, it\u2019s exposed for\n\uf0a1Deployments\n\uf0a1ReplicaSets\n\uf0a1ReplicationControllers\n\uf0a1StatefulSets\nThese are currently the only objects you can attach an Autoscaler to.\nPod 1\nCPU\nutilization\nQPS\nPod 2\nPod 3\nTarget\nCPU utilization\nTarget QPS\nReplicas: 4\nReplicas: 3\nReplicas: 4\n30\n12\n15\n20\n(15 + 30 + 12) / 20 = 57 / 20\n(60 + 90 + 50) / 50 = 200 / 50\nMax(4, 3)\n50%\n60%\n90%\n50%\nFigure 15.2\nCalculating the number of replicas from two metrics\nAutoscaler adjusts replicas (++ or --)\nHorizontal Pod Autoscaler\nDeployment, ReplicaSet,\nStatefulSet, or\nReplicationController\nScale\nsub-resource\nFigure 15.3\nThe Horizontal Pod Autoscaler modifies only on the Scale sub-resource.\n \n"}, {"color": "green", "id": "text_384", "label": "441\nHorizontal pod autoscaling\nUNDERSTANDING THE WHOLE AUTOSCALING PROCESS\nYou now understand the three steps involved in autoscaling, so let\u2019s visualize all the\ncomponents involved in the autoscaling process. They\u2019re shown in figure 15.4.\nThe arrows leading from the pods to the cAdvisors, which continue on to Heapster\nand finally to the Horizontal Pod Autoscaler, indicate the direction of the flow of met-\nrics data. It\u2019s important to be aware that each component gets the metrics from the\nother components periodically (that is, cAdvisor gets the metrics from the pods in a\ncontinuous loop; the same is also true for Heapster and for the HPA controller). The\nend effect is that it takes quite a while for the metrics data to be propagated and a res-\ncaling action to be performed. It isn\u2019t immediate. Keep this in mind when you observe\nthe Autoscaler in action next.\n15.1.2 Scaling based on CPU utilization\nPerhaps the most important metric you\u2019ll want to base autoscaling on is the amount of\nCPU consumed by the processes running inside your pods. Imagine having a few pods\nproviding a service. When their CPU usage reaches 100% it\u2019s obvious they can\u2019t cope\nwith the demand anymore and need to be scaled either up (vertical scaling\u2014increas-\ning the amount of CPU the pods can use) or out (horizontal scaling\u2014increasing the\nnumber of pods). Because we\u2019re talking about the horizontal pod autoscaler here,\nAutoscaler adjusts\nreplicas (++ or --)\nHeapster collects\nmetrics from all nodes\ncAdvisor collects metrics\nfrom all containers on a node\nDeployment\nReplicaSet\nAutoscaler collects\nmetrics from Heapster\nKubelet\ncAdvisor\nNode 1\nPod\nPod\nKubelet\ncAdvisor\nNode 2\nPod\nNode X\nHeapster\nHorizontal Pod\nAutoscaler\nFigure 15.4\nHow the autoscaler obtains metrics and rescales the target deployment \n \n", "shape": "dot", "size": 10, "title": "441\nHorizontal pod autoscaling\nUNDERSTANDING THE WHOLE AUTOSCALING PROCESS\nYou now understand the three steps involved in autoscaling, so let\u2019s visualize all the\ncomponents involved in the autoscaling process. They\u2019re shown in figure 15.4.\nThe arrows leading from the pods to the cAdvisors, which continue on to Heapster\nand finally to the Horizontal Pod Autoscaler, indicate the direction of the flow of met-\nrics data. It\u2019s important to be aware that each component gets the metrics from the\nother components periodically (that is, cAdvisor gets the metrics from the pods in a\ncontinuous loop; the same is also true for Heapster and for the HPA controller). The\nend effect is that it takes quite a while for the metrics data to be propagated and a res-\ncaling action to be performed. It isn\u2019t immediate. Keep this in mind when you observe\nthe Autoscaler in action next.\n15.1.2 Scaling based on CPU utilization\nPerhaps the most important metric you\u2019ll want to base autoscaling on is the amount of\nCPU consumed by the processes running inside your pods. Imagine having a few pods\nproviding a service. When their CPU usage reaches 100% it\u2019s obvious they can\u2019t cope\nwith the demand anymore and need to be scaled either up (vertical scaling\u2014increas-\ning the amount of CPU the pods can use) or out (horizontal scaling\u2014increasing the\nnumber of pods). Because we\u2019re talking about the horizontal pod autoscaler here,\nAutoscaler adjusts\nreplicas (++ or --)\nHeapster collects\nmetrics from all nodes\ncAdvisor collects metrics\nfrom all containers on a node\nDeployment\nReplicaSet\nAutoscaler collects\nmetrics from Heapster\nKubelet\ncAdvisor\nNode 1\nPod\nPod\nKubelet\ncAdvisor\nNode 2\nPod\nNode X\nHeapster\nHorizontal Pod\nAutoscaler\nFigure 15.4\nHow the autoscaler obtains metrics and rescales the target deployment \n \n"}, {"color": "green", "id": "text_385", "label": "442\nCHAPTER 15\nAutomatic scaling of pods and cluster nodes\nwe\u2019re only focusing on scaling out (increasing the number of pods). By doing that,\nthe average CPU usage should come down. \n Because CPU usage is usually unstable, it makes sense to scale out even before the\nCPU is completely swamped\u2014perhaps when the average CPU load across the pods\nreaches or exceeds 80%. But 80% of what, exactly?\nTIP\nAlways set the target CPU usage well below 100% (and definitely never\nabove 90%) to leave enough room for handling sudden load spikes.\nAs you may remember from the previous chapter, the process running inside a con-\ntainer is guaranteed the amount of CPU requested through the resource requests\nspecified for the container. But at times when no other processes need CPU, the pro-\ncess may use all the available CPU on the node. When someone says a pod is consum-\ning 80% of the CPU, it\u2019s not clear if they mean 80% of the node\u2019s CPU, 80% of the\npod\u2019s guaranteed CPU (the resource request), or 80% of the hard limit configured\nfor the pod through resource limits. \n As far as the Autoscaler is concerned, only the pod\u2019s guaranteed CPU amount (the\nCPU requests) is important when determining the CPU utilization of a pod. The Auto-\nscaler compares the pod\u2019s actual CPU consumption and its CPU requests, which\nmeans the pods you\u2019re autoscaling need to have CPU requests set (either directly or\nindirectly through a LimitRange object) for the Autoscaler to determine the CPU uti-\nlization percentage.\nCREATING A HORIZONTALPODAUTOSCALER BASED ON CPU USAGE\nLet\u2019s see how to create a HorizontalPodAutoscaler now and configure it to scale pods\nbased on their CPU utilization. You\u2019ll create a Deployment similar to the one in chap-\nter 9, but as we\u2019ve discussed, you\u2019ll need to make sure the pods created by the Deploy-\nment all have the CPU resource requests specified in order to make autoscaling\npossible. You\u2019ll have to add a CPU resource request to the Deployment\u2019s pod tem-\nplate, as shown in the following listing.\napiVersion: extensions/v1beta1\nkind: Deployment\nmetadata:\n  name: kubia\nspec:\n  replicas: 3                \n  template:\n    metadata:\n      name: kubia\n      labels:\n        app: kubia\n    spec:\n      containers:\n      - image: luksa/kubia:v1     \n        name: nodejs\nListing 15.1\nDeployment with CPU requests set: deployment.yaml\nManually setting the \n(initial) desired number \nof replicas to three\nRunning the \nkubia:v1 image\n \n", "shape": "dot", "size": 10, "title": "442\nCHAPTER 15\nAutomatic scaling of pods and cluster nodes\nwe\u2019re only focusing on scaling out (increasing the number of pods). By doing that,\nthe average CPU usage should come down. \n Because CPU usage is usually unstable, it makes sense to scale out even before the\nCPU is completely swamped\u2014perhaps when the average CPU load across the pods\nreaches or exceeds 80%. But 80% of what, exactly?\nTIP\nAlways set the target CPU usage well below 100% (and definitely never\nabove 90%) to leave enough room for handling sudden load spikes.\nAs you may remember from the previous chapter, the process running inside a con-\ntainer is guaranteed the amount of CPU requested through the resource requests\nspecified for the container. But at times when no other processes need CPU, the pro-\ncess may use all the available CPU on the node. When someone says a pod is consum-\ning 80% of the CPU, it\u2019s not clear if they mean 80% of the node\u2019s CPU, 80% of the\npod\u2019s guaranteed CPU (the resource request), or 80% of the hard limit configured\nfor the pod through resource limits. \n As far as the Autoscaler is concerned, only the pod\u2019s guaranteed CPU amount (the\nCPU requests) is important when determining the CPU utilization of a pod. The Auto-\nscaler compares the pod\u2019s actual CPU consumption and its CPU requests, which\nmeans the pods you\u2019re autoscaling need to have CPU requests set (either directly or\nindirectly through a LimitRange object) for the Autoscaler to determine the CPU uti-\nlization percentage.\nCREATING A HORIZONTALPODAUTOSCALER BASED ON CPU USAGE\nLet\u2019s see how to create a HorizontalPodAutoscaler now and configure it to scale pods\nbased on their CPU utilization. You\u2019ll create a Deployment similar to the one in chap-\nter 9, but as we\u2019ve discussed, you\u2019ll need to make sure the pods created by the Deploy-\nment all have the CPU resource requests specified in order to make autoscaling\npossible. You\u2019ll have to add a CPU resource request to the Deployment\u2019s pod tem-\nplate, as shown in the following listing.\napiVersion: extensions/v1beta1\nkind: Deployment\nmetadata:\n  name: kubia\nspec:\n  replicas: 3                \n  template:\n    metadata:\n      name: kubia\n      labels:\n        app: kubia\n    spec:\n      containers:\n      - image: luksa/kubia:v1     \n        name: nodejs\nListing 15.1\nDeployment with CPU requests set: deployment.yaml\nManually setting the \n(initial) desired number \nof replicas to three\nRunning the \nkubia:v1 image\n \n"}, {"color": "green", "id": "text_386", "label": "443\nHorizontal pod autoscaling\n        resources:              \n          requests:             \n            cpu: 100m           \nThis is a regular Deployment object\u2014it doesn\u2019t use autoscaling yet. It will run three\ninstances of the kubia NodeJS app, with each instance requesting 100 millicores\nof CPU. \n After creating the Deployment, to enable horizontal autoscaling of its pods, you\nneed to create a HorizontalPodAutoscaler (HPA) object and point it to the Deploy-\nment. You could prepare and post the YAML manifest for the HPA, but an easier way\nexists\u2014using the kubectl autoscale command:\n$ kubectl autoscale deployment kubia --cpu-percent=30 --min=1 --max=5\ndeployment \"kubia\" autoscaled\nThis creates the HPA object for you and sets the Deployment called kubia as the scal-\ning target. You\u2019re setting the target CPU utilization of the pods to 30% and specifying\nthe minimum and maximum number of replicas. The Autoscaler will constantly keep\nadjusting the number of replicas to keep their CPU utilization around 30%, but it will\nnever scale down to less than one or scale up to more than five replicas. \nTIP\nAlways make sure to autoscale Deployments instead of the underlying\nReplicaSets. This way, you ensure the desired replica count is preserved across\napplication updates (remember that a Deployment creates a new ReplicaSet\nfor each version). The same rule applies to manual scaling, as well.\nLet\u2019s look at the definition of the HorizontalPodAutoscaler resource to gain a better\nunderstanding of it. It\u2019s shown in the following listing.\n$ kubectl get hpa.v2beta1.autoscaling kubia -o yaml\napiVersion: autoscaling/v2beta1            \nkind: HorizontalPodAutoscaler              \nmetadata:\n  name: kubia               \n  ...\nspec:\n  maxReplicas: 5                   \n  metrics:                              \n  - resource:                           \n      name: cpu                         \n      targetAverageUtilization: 30      \n    type: Resource                      \n  minReplicas: 1                   \n  scaleTargetRef:                          \n    apiVersion: extensions/v1beta1         \n    kind: Deployment                       \n    name: kubia                            \nListing 15.2\nA HorizontalPodAutoscaler YAML definition\nRequesting 100 millicores \nof CPU per pod\nHPA resources are in the \nautoscaling API group.\nEach HPA has a name (it doesn\u2019t \nneed to match the name of the \nDeployment as in this case).\nThe\nminimum\nand\nmaximum\nnumber of\nreplicas\nyou\nspecified\nYou\u2019d like the Autoscaler to \nadjust the number of pods \nso they each utilize 30% of \nrequested CPU.\nThe target resource \nwhich this Autoscaler \nwill act upon\n \n", "shape": "dot", "size": 10, "title": "443\nHorizontal pod autoscaling\n        resources:              \n          requests:             \n            cpu: 100m           \nThis is a regular Deployment object\u2014it doesn\u2019t use autoscaling yet. It will run three\ninstances of the kubia NodeJS app, with each instance requesting 100 millicores\nof CPU. \n After creating the Deployment, to enable horizontal autoscaling of its pods, you\nneed to create a HorizontalPodAutoscaler (HPA) object and point it to the Deploy-\nment. You could prepare and post the YAML manifest for the HPA, but an easier way\nexists\u2014using the kubectl autoscale command:\n$ kubectl autoscale deployment kubia --cpu-percent=30 --min=1 --max=5\ndeployment \"kubia\" autoscaled\nThis creates the HPA object for you and sets the Deployment called kubia as the scal-\ning target. You\u2019re setting the target CPU utilization of the pods to 30% and specifying\nthe minimum and maximum number of replicas. The Autoscaler will constantly keep\nadjusting the number of replicas to keep their CPU utilization around 30%, but it will\nnever scale down to less than one or scale up to more than five replicas. \nTIP\nAlways make sure to autoscale Deployments instead of the underlying\nReplicaSets. This way, you ensure the desired replica count is preserved across\napplication updates (remember that a Deployment creates a new ReplicaSet\nfor each version). The same rule applies to manual scaling, as well.\nLet\u2019s look at the definition of the HorizontalPodAutoscaler resource to gain a better\nunderstanding of it. It\u2019s shown in the following listing.\n$ kubectl get hpa.v2beta1.autoscaling kubia -o yaml\napiVersion: autoscaling/v2beta1            \nkind: HorizontalPodAutoscaler              \nmetadata:\n  name: kubia               \n  ...\nspec:\n  maxReplicas: 5                   \n  metrics:                              \n  - resource:                           \n      name: cpu                         \n      targetAverageUtilization: 30      \n    type: Resource                      \n  minReplicas: 1                   \n  scaleTargetRef:                          \n    apiVersion: extensions/v1beta1         \n    kind: Deployment                       \n    name: kubia                            \nListing 15.2\nA HorizontalPodAutoscaler YAML definition\nRequesting 100 millicores \nof CPU per pod\nHPA resources are in the \nautoscaling API group.\nEach HPA has a name (it doesn\u2019t \nneed to match the name of the \nDeployment as in this case).\nThe\nminimum\nand\nmaximum\nnumber of\nreplicas\nyou\nspecified\nYou\u2019d like the Autoscaler to \nadjust the number of pods \nso they each utilize 30% of \nrequested CPU.\nThe target resource \nwhich this Autoscaler \nwill act upon\n \n"}, {"color": "green", "id": "text_387", "label": "444\nCHAPTER 15\nAutomatic scaling of pods and cluster nodes\nstatus:\n  currentMetrics: []        \n  currentReplicas: 3        \n  desiredReplicas: 0        \nNOTE\nMultiple versions of HPA resources exist: the new autoscaling/v2beta1\nand the old autoscaling/v1. You\u2019re requesting the new version here.\nSEEING THE FIRST AUTOMATIC RESCALE EVENT\nIt takes a while for cAdvisor to get the CPU metrics and for Heapster to collect them\nbefore the Autoscaler can take action. During that time, if you display the HPA resource\nwith kubectl get, the TARGETS column will show \u003cunknown\u003e:\n$ kubectl get hpa\nNAME      REFERENCE          TARGETS           MINPODS   MAXPODS   REPLICAS\nkubia     Deployment/kubia   \u003cunknown\u003e / 30%   1         5         0       \nBecause you\u2019re running three pods that are currently receiving no requests, which\nmeans their CPU usage should be close to zero, you should expect the Autoscaler to\nscale them down to a single pod, because even with a single pod, the CPU utilization\nwill still be below the 30% target. \n And sure enough, the autoscaler does exactly that. It soon scales the Deployment\ndown to a single replica:\n$ kubectl get deployment\nNAME      DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE\nkubia     1         1         1            1           23m\nRemember, the autoscaler only adjusts the desired replica count on the Deployment.\nThe Deployment controller then takes care of updating the desired replica count on\nthe ReplicaSet object, which then causes the ReplicaSet controller to delete two excess\npods, leaving one pod running.\n You can use kubectl describe to see more information on the HorizontalPod-\nAutoscaler and the operation of the underlying controller, as the following listing shows.\n$ kubectl describe hpa\nName:                             kubia\nNamespace:                        default\nLabels:                           \u003cnone\u003e\nAnnotations:                      \u003cnone\u003e\nCreationTimestamp:                Sat, 03 Jun 2017 12:59:57 +0200\nReference:                        Deployment/kubia\nMetrics:                          ( current / target )\n  resource cpu on pods  \n  (as a percentage of request):   0% (0) / 30%\nMin replicas:                     1\nMax replicas:                     5\nListing 15.3\nInspecting a HorizontalPodAutoscaler with kubectl describe\nThe current status \nof the Autoscaler\n \n", "shape": "dot", "size": 10, "title": "444\nCHAPTER 15\nAutomatic scaling of pods and cluster nodes\nstatus:\n  currentMetrics: []        \n  currentReplicas: 3        \n  desiredReplicas: 0        \nNOTE\nMultiple versions of HPA resources exist: the new autoscaling/v2beta1\nand the old autoscaling/v1. You\u2019re requesting the new version here.\nSEEING THE FIRST AUTOMATIC RESCALE EVENT\nIt takes a while for cAdvisor to get the CPU metrics and for Heapster to collect them\nbefore the Autoscaler can take action. During that time, if you display the HPA resource\nwith kubectl get, the TARGETS column will show \u003cunknown\u003e:\n$ kubectl get hpa\nNAME      REFERENCE          TARGETS           MINPODS   MAXPODS   REPLICAS\nkubia     Deployment/kubia   \u003cunknown\u003e / 30%   1         5         0       \nBecause you\u2019re running three pods that are currently receiving no requests, which\nmeans their CPU usage should be close to zero, you should expect the Autoscaler to\nscale them down to a single pod, because even with a single pod, the CPU utilization\nwill still be below the 30% target. \n And sure enough, the autoscaler does exactly that. It soon scales the Deployment\ndown to a single replica:\n$ kubectl get deployment\nNAME      DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE\nkubia     1         1         1            1           23m\nRemember, the autoscaler only adjusts the desired replica count on the Deployment.\nThe Deployment controller then takes care of updating the desired replica count on\nthe ReplicaSet object, which then causes the ReplicaSet controller to delete two excess\npods, leaving one pod running.\n You can use kubectl describe to see more information on the HorizontalPod-\nAutoscaler and the operation of the underlying controller, as the following listing shows.\n$ kubectl describe hpa\nName:                             kubia\nNamespace:                        default\nLabels:                           \u003cnone\u003e\nAnnotations:                      \u003cnone\u003e\nCreationTimestamp:                Sat, 03 Jun 2017 12:59:57 +0200\nReference:                        Deployment/kubia\nMetrics:                          ( current / target )\n  resource cpu on pods  \n  (as a percentage of request):   0% (0) / 30%\nMin replicas:                     1\nMax replicas:                     5\nListing 15.3\nInspecting a HorizontalPodAutoscaler with kubectl describe\nThe current status \nof the Autoscaler\n \n"}, {"color": "green", "id": "text_388", "label": "445\nHorizontal pod autoscaling\nEvents:\nFrom                        Reason              Message\n----                        ------              ---\nhorizontal-pod-autoscaler   SuccessfulRescale   New size: 1; reason: All \n                                                metrics below target\nNOTE\nThe output has been modified to make it more readable.\nTurn your focus to the table of events at the bottom of the listing. You see the horizon-\ntal pod autoscaler has successfully rescaled to one replica, because all metrics were\nbelow target. \nTRIGGERING A SCALE-UP\nYou\u2019ve already witnessed your first automatic rescale event (a scale-down). Now, you\u2019ll\nstart sending requests to your pod, thereby increasing its CPU usage, and you should\nsee the autoscaler detect this and start up additional pods.\n You\u2019ll need to expose the pods through a Service, so you can hit all of them through\na single URL. You may remember that the easiest way to do that is with kubectl expose:\n$ kubectl expose deployment kubia --port=80 --target-port=8080\nservice \"kubia\" exposed\nBefore you start hitting your pod(s) with requests, you may want to run the follow-\ning command in a separate terminal to keep an eye on what\u2019s happening with the\nHorizontalPodAutoscaler and the Deployment, as shown in the following listing.\n$ watch -n 1 kubectl get hpa,deployment\nEvery \n1.0s: \nkubectl \nget \nhpa,deployment \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \nNAME        REFERENCE          TARGETS    MINPODS   MAXPODS   REPLICAS  AGE\nhpa/kubia   Deployment/kubia   0% / 30%   1         5         1         45m\nNAME           DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE\ndeploy/kubia   1         1         1            1           56m\nTIP\nList multiple resource types with kubectl get by delimiting them with\na comma. \nIf you\u2019re using OSX, you\u2019ll have to replace the watch command with a loop, manually\nrun kubectl get periodically, or use kubectl\u2019s --watch option. But although a plain\nkubectl get can show multiple types of resources at once, that\u2019s not the case when\nusing the aforementioned --watch option, so you\u2019ll need to use two terminals if you\nwant to watch both the HPA and the Deployment objects. \n Keep an eye on the state of those two objects while you run a load-generating pod.\nYou\u2019ll run the following command in another terminal:\n$ kubectl run -it --rm --restart=Never loadgenerator --image=busybox \n\u27a5 -- sh -c \"while true; do wget -O - -q http://kubia.default; done\"\nListing 15.4\nWatching multiple resources in parallel\n \n", "shape": "dot", "size": 10, "title": "445\nHorizontal pod autoscaling\nEvents:\nFrom                        Reason              Message\n----                        ------              ---\nhorizontal-pod-autoscaler   SuccessfulRescale   New size: 1; reason: All \n                                                metrics below target\nNOTE\nThe output has been modified to make it more readable.\nTurn your focus to the table of events at the bottom of the listing. You see the horizon-\ntal pod autoscaler has successfully rescaled to one replica, because all metrics were\nbelow target. \nTRIGGERING A SCALE-UP\nYou\u2019ve already witnessed your first automatic rescale event (a scale-down). Now, you\u2019ll\nstart sending requests to your pod, thereby increasing its CPU usage, and you should\nsee the autoscaler detect this and start up additional pods.\n You\u2019ll need to expose the pods through a Service, so you can hit all of them through\na single URL. You may remember that the easiest way to do that is with kubectl expose:\n$ kubectl expose deployment kubia --port=80 --target-port=8080\nservice \"kubia\" exposed\nBefore you start hitting your pod(s) with requests, you may want to run the follow-\ning command in a separate terminal to keep an eye on what\u2019s happening with the\nHorizontalPodAutoscaler and the Deployment, as shown in the following listing.\n$ watch -n 1 kubectl get hpa,deployment\nEvery \n1.0s: \nkubectl \nget \nhpa,deployment \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \nNAME        REFERENCE          TARGETS    MINPODS   MAXPODS   REPLICAS  AGE\nhpa/kubia   Deployment/kubia   0% / 30%   1         5         1         45m\nNAME           DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE\ndeploy/kubia   1         1         1            1           56m\nTIP\nList multiple resource types with kubectl get by delimiting them with\na comma. \nIf you\u2019re using OSX, you\u2019ll have to replace the watch command with a loop, manually\nrun kubectl get periodically, or use kubectl\u2019s --watch option. But although a plain\nkubectl get can show multiple types of resources at once, that\u2019s not the case when\nusing the aforementioned --watch option, so you\u2019ll need to use two terminals if you\nwant to watch both the HPA and the Deployment objects. \n Keep an eye on the state of those two objects while you run a load-generating pod.\nYou\u2019ll run the following command in another terminal:\n$ kubectl run -it --rm --restart=Never loadgenerator --image=busybox \n\u27a5 -- sh -c \"while true; do wget -O - -q http://kubia.default; done\"\nListing 15.4\nWatching multiple resources in parallel\n \n"}, {"color": "green", "id": "text_389", "label": "446\nCHAPTER 15\nAutomatic scaling of pods and cluster nodes\nThis will run a pod which repeatedly hits the kubia Service. You\u2019ve seen the -it\noption a few times when running the kubectl exec command. As you can see, it can\nalso be used with kubectl run. It allows you to attach the console to the process,\nwhich will not only show you the process\u2019 output directly, but will also terminate the\nprocess as soon as you press CTRL+C. The --rm option causes the pod to be deleted\nafterward, and the --restart=Never option causes kubectl run to create an unman-\naged pod directly instead of through a Deployment object, which you don\u2019t need.\nThis combination of options is useful for running commands inside the cluster with-\nout having to piggyback on an existing pod. It not only behaves the same as if you\nwere running the command locally, it even cleans up everything when the command\nterminates. \nSEEING THE AUTOSCALER SCALE UP THE DEPLOYMENT\nAs the load-generator pod runs, you\u2019ll see it initially hitting the single pod. As before,\nit takes time for the metrics to be updated, but when they are, you\u2019ll see the autoscaler\nincrease the number of replicas. In my case, the pod\u2019s CPU utilization initially jumped\nto 108%, which caused the autoscaler to increase the number of pods to four. The\nutilization on the individual pods then decreased to 74% and then stabilized at\naround 26%. \nNOTE\nIf the CPU load in your case doesn\u2019t exceed 30%, try running addi-\ntional load-generators.\nAgain, you can inspect autoscaler events with kubectl describe to see what the\nautoscaler has done (only the most important information is shown in the following\nlisting).\nFrom    Reason              Message\n----    ------              -------\nh-p-a   SuccessfulRescale   New size: 1; reason: All metrics below target\nh-p-a   SuccessfulRescale   New size: 4; reason: cpu resource utilization \n                            (percentage of request) above target\nDoes it strike you as odd that the initial average CPU utilization in my case, when I\nonly had one pod, was 108%, which is more than 100%? Remember, a container\u2019s\nCPU utilization is the container\u2019s actual CPU usage divided by its requested CPU. The\nrequested CPU defines the minimum, not maximum amount of CPU available to the\ncontainer, so a container may consume more than the requested CPU, bringing the\npercentage over 100. \n Before we go on, let\u2019s do a little math and see how the autoscaler concluded that\nfour replicas are needed. Initially, there was one replica handling requests and its\nCPU usage spiked to 108%. Dividing 108 by 30 (the target CPU utilization percent-\nage) gives 3.6, which the autoscaler then rounded up to 4. If you divide 108 by 4, you\nListing 15.5\nEvents of a HorizontalPodAutoscaler\n \n", "shape": "dot", "size": 10, "title": "446\nCHAPTER 15\nAutomatic scaling of pods and cluster nodes\nThis will run a pod which repeatedly hits the kubia Service. You\u2019ve seen the -it\noption a few times when running the kubectl exec command. As you can see, it can\nalso be used with kubectl run. It allows you to attach the console to the process,\nwhich will not only show you the process\u2019 output directly, but will also terminate the\nprocess as soon as you press CTRL+C. The --rm option causes the pod to be deleted\nafterward, and the --restart=Never option causes kubectl run to create an unman-\naged pod directly instead of through a Deployment object, which you don\u2019t need.\nThis combination of options is useful for running commands inside the cluster with-\nout having to piggyback on an existing pod. It not only behaves the same as if you\nwere running the command locally, it even cleans up everything when the command\nterminates. \nSEEING THE AUTOSCALER SCALE UP THE DEPLOYMENT\nAs the load-generator pod runs, you\u2019ll see it initially hitting the single pod. As before,\nit takes time for the metrics to be updated, but when they are, you\u2019ll see the autoscaler\nincrease the number of replicas. In my case, the pod\u2019s CPU utilization initially jumped\nto 108%, which caused the autoscaler to increase the number of pods to four. The\nutilization on the individual pods then decreased to 74% and then stabilized at\naround 26%. \nNOTE\nIf the CPU load in your case doesn\u2019t exceed 30%, try running addi-\ntional load-generators.\nAgain, you can inspect autoscaler events with kubectl describe to see what the\nautoscaler has done (only the most important information is shown in the following\nlisting).\nFrom    Reason              Message\n----    ------              -------\nh-p-a   SuccessfulRescale   New size: 1; reason: All metrics below target\nh-p-a   SuccessfulRescale   New size: 4; reason: cpu resource utilization \n                            (percentage of request) above target\nDoes it strike you as odd that the initial average CPU utilization in my case, when I\nonly had one pod, was 108%, which is more than 100%? Remember, a container\u2019s\nCPU utilization is the container\u2019s actual CPU usage divided by its requested CPU. The\nrequested CPU defines the minimum, not maximum amount of CPU available to the\ncontainer, so a container may consume more than the requested CPU, bringing the\npercentage over 100. \n Before we go on, let\u2019s do a little math and see how the autoscaler concluded that\nfour replicas are needed. Initially, there was one replica handling requests and its\nCPU usage spiked to 108%. Dividing 108 by 30 (the target CPU utilization percent-\nage) gives 3.6, which the autoscaler then rounded up to 4. If you divide 108 by 4, you\nListing 15.5\nEvents of a HorizontalPodAutoscaler\n \n"}, {"color": "green", "id": "text_390", "label": "447\nHorizontal pod autoscaling\nget 27%. If the autoscaler scales up to four pods, their average CPU utilization is\nexpected to be somewhere in the neighborhood of 27%, which is close to the target\nvalue of 30% and almost exactly what the observed CPU utilization was.\nUNDERSTANDING THE MAXIMUM RATE OF SCALING\nIn my case, the CPU usage shot up to 108%, but in general, the initial CPU usage\ncould spike even higher. Even if the initial average CPU utilization was higher (say\n150%), requiring five replicas to achieve the 30% target, the autoscaler would still\nonly scale up to four pods in the first step, because it has a limit on how many repli-\ncas can be added in a single scale-up operation. The autoscaler will at most double\nthe number of replicas in a single operation, if more than two current replicas\nexist. If only one or two exist, it will scale up to a maximum of four replicas in a sin-\ngle step. \n Additionally, it has a limit on how soon a subsequent autoscale operation can\noccur after the previous one. Currently, a scale-up will occur only if no rescaling\nevent occurred in the last three minutes. A scale-down event is performed even less\nfrequently\u2014every five minutes. Keep this in mind so you don\u2019t wonder why the\nautoscaler refuses to perform a rescale operation even if the metrics clearly show\nthat it should.\nMODIFYING THE TARGET METRIC VALUE ON AN EXISTING HPA OBJECT\nTo wrap up this section, let\u2019s do one last exercise. Maybe your initial CPU utilization\ntarget of 30% was a bit too low, so increase it to 60%. You do this by editing the HPA\nresource with the kubectl edit command. When the text editor opens, change the\ntargetAverageUtilization field to 60, as shown in the following listing.\n...\nspec:\n  maxReplicas: 5\n  metrics:\n  - resource:\n      name: cpu\n      targetAverageUtilization: 60    \n    type: Resource\n...\nAs with most other resources, after you modify the resource, your changes will be\ndetected by the autoscaler controller and acted upon. You could also delete the\nresource and recreate it with different target values, because by deleting the HPA\nresource, you only disable autoscaling of the target resource (a Deployment in this\ncase) and leave it at the scale it is at that time. The automatic scaling will resume after\nyou create a new HPA resource for the Deployment.\nListing 15.6\nIncreasing the target CPU utilization by editing the HPA resource\nChange this \nfrom 30 to 60.\n \n", "shape": "dot", "size": 10, "title": "447\nHorizontal pod autoscaling\nget 27%. If the autoscaler scales up to four pods, their average CPU utilization is\nexpected to be somewhere in the neighborhood of 27%, which is close to the target\nvalue of 30% and almost exactly what the observed CPU utilization was.\nUNDERSTANDING THE MAXIMUM RATE OF SCALING\nIn my case, the CPU usage shot up to 108%, but in general, the initial CPU usage\ncould spike even higher. Even if the initial average CPU utilization was higher (say\n150%), requiring five replicas to achieve the 30% target, the autoscaler would still\nonly scale up to four pods in the first step, because it has a limit on how many repli-\ncas can be added in a single scale-up operation. The autoscaler will at most double\nthe number of replicas in a single operation, if more than two current replicas\nexist. If only one or two exist, it will scale up to a maximum of four replicas in a sin-\ngle step. \n Additionally, it has a limit on how soon a subsequent autoscale operation can\noccur after the previous one. Currently, a scale-up will occur only if no rescaling\nevent occurred in the last three minutes. A scale-down event is performed even less\nfrequently\u2014every five minutes. Keep this in mind so you don\u2019t wonder why the\nautoscaler refuses to perform a rescale operation even if the metrics clearly show\nthat it should.\nMODIFYING THE TARGET METRIC VALUE ON AN EXISTING HPA OBJECT\nTo wrap up this section, let\u2019s do one last exercise. Maybe your initial CPU utilization\ntarget of 30% was a bit too low, so increase it to 60%. You do this by editing the HPA\nresource with the kubectl edit command. When the text editor opens, change the\ntargetAverageUtilization field to 60, as shown in the following listing.\n...\nspec:\n  maxReplicas: 5\n  metrics:\n  - resource:\n      name: cpu\n      targetAverageUtilization: 60    \n    type: Resource\n...\nAs with most other resources, after you modify the resource, your changes will be\ndetected by the autoscaler controller and acted upon. You could also delete the\nresource and recreate it with different target values, because by deleting the HPA\nresource, you only disable autoscaling of the target resource (a Deployment in this\ncase) and leave it at the scale it is at that time. The automatic scaling will resume after\nyou create a new HPA resource for the Deployment.\nListing 15.6\nIncreasing the target CPU utilization by editing the HPA resource\nChange this \nfrom 30 to 60.\n \n"}, {"color": "green", "id": "text_391", "label": "448\nCHAPTER 15\nAutomatic scaling of pods and cluster nodes\n15.1.3 Scaling based on memory consumption\nYou\u2019ve seen how easily the horizontal Autoscaler can be configured to keep CPU uti-\nlization at the target level. But what about autoscaling based on the pods\u2019 memory\nusage? \n Memory-based autoscaling is much more problematic than CPU-based autoscal-\ning. The main reason is because after scaling up, the old pods would somehow need to\nbe forced to release memory. This needs to be done by the app itself\u2014it can\u2019t be done\nby the system. All the system could do is kill and restart the app, hoping it would use\nless memory than before. But if the app then uses the same amount as before, the\nAutoscaler would scale it up again. And again, and again, until it reaches the maxi-\nmum number of pods configured on the HPA resource. Obviously, this isn\u2019t what any-\none wants. Memory-based autoscaling was introduced in Kubernetes version 1.8, and\nis configured exactly like CPU-based autoscaling. Exploring it is left up to the reader.\n15.1.4 Scaling based on other and custom metrics\nYou\u2019ve seen how easy it is to scale pods based on their CPU usage. Initially, this was the\nonly autoscaling option that was usable in practice. To have the autoscaler use custom,\napp-defined metrics to drive its autoscaling decisions was fairly complicated. The ini-\ntial design of the autoscaler didn\u2019t make it easy to move beyond simple CPU-based\nscaling. This prompted the Kubernetes Autoscaling Special Interest Group (SIG) to\nredesign the autoscaler completely. \n If you\u2019re interested in learning how complicated it was to use the initial autoscaler\nwith custom metrics, I invite you to read my blog post entitled \u201cKubernetes autoscal-\ning based on custom metrics without using a host port,\u201d which you\u2019ll find online at\nhttp:/\n/medium.com/@marko.luksa. You\u2019ll learn about all the other problems I\nencountered when trying to set up autoscaling based on custom metrics. Luckily,\nnewer versions of Kubernetes don\u2019t have those problems. I\u2019ll cover the subject in a\nnew blog post. \n Instead of going through a complete example here, let\u2019s quickly go over how to\nconfigure the autoscaler to use different metrics sources. We\u2019ll start by examining how\nwe defined what metric to use in our previous example. The following listing shows\nhow your previous HPA object was configured to use the CPU usage metric.\n...\nspec:\n  maxReplicas: 5\n  metrics:\n  - type: Resource      \n    resource:\n      name: cpu                      \n      targetAverageUtilization: 30    \n...\nListing 15.7\nHorizontalPodAutoscaler definition for CPU-based autoscaling\nDefines the type \nof metric\nThe resource, whose \nutilization will be monitored\nThe target utilization \nof this resource\n \n", "shape": "dot", "size": 10, "title": "448\nCHAPTER 15\nAutomatic scaling of pods and cluster nodes\n15.1.3 Scaling based on memory consumption\nYou\u2019ve seen how easily the horizontal Autoscaler can be configured to keep CPU uti-\nlization at the target level. But what about autoscaling based on the pods\u2019 memory\nusage? \n Memory-based autoscaling is much more problematic than CPU-based autoscal-\ning. The main reason is because after scaling up, the old pods would somehow need to\nbe forced to release memory. This needs to be done by the app itself\u2014it can\u2019t be done\nby the system. All the system could do is kill and restart the app, hoping it would use\nless memory than before. But if the app then uses the same amount as before, the\nAutoscaler would scale it up again. And again, and again, until it reaches the maxi-\nmum number of pods configured on the HPA resource. Obviously, this isn\u2019t what any-\none wants. Memory-based autoscaling was introduced in Kubernetes version 1.8, and\nis configured exactly like CPU-based autoscaling. Exploring it is left up to the reader.\n15.1.4 Scaling based on other and custom metrics\nYou\u2019ve seen how easy it is to scale pods based on their CPU usage. Initially, this was the\nonly autoscaling option that was usable in practice. To have the autoscaler use custom,\napp-defined metrics to drive its autoscaling decisions was fairly complicated. The ini-\ntial design of the autoscaler didn\u2019t make it easy to move beyond simple CPU-based\nscaling. This prompted the Kubernetes Autoscaling Special Interest Group (SIG) to\nredesign the autoscaler completely. \n If you\u2019re interested in learning how complicated it was to use the initial autoscaler\nwith custom metrics, I invite you to read my blog post entitled \u201cKubernetes autoscal-\ning based on custom metrics without using a host port,\u201d which you\u2019ll find online at\nhttp:/\n/medium.com/@marko.luksa. You\u2019ll learn about all the other problems I\nencountered when trying to set up autoscaling based on custom metrics. Luckily,\nnewer versions of Kubernetes don\u2019t have those problems. I\u2019ll cover the subject in a\nnew blog post. \n Instead of going through a complete example here, let\u2019s quickly go over how to\nconfigure the autoscaler to use different metrics sources. We\u2019ll start by examining how\nwe defined what metric to use in our previous example. The following listing shows\nhow your previous HPA object was configured to use the CPU usage metric.\n...\nspec:\n  maxReplicas: 5\n  metrics:\n  - type: Resource      \n    resource:\n      name: cpu                      \n      targetAverageUtilization: 30    \n...\nListing 15.7\nHorizontalPodAutoscaler definition for CPU-based autoscaling\nDefines the type \nof metric\nThe resource, whose \nutilization will be monitored\nThe target utilization \nof this resource\n \n"}, {"color": "green", "id": "text_392", "label": "449\nHorizontal pod autoscaling\nAs you can see, the metrics field allows you to define more than one metric to use.\nIn the listing, you\u2019re using a single metric. Each entry defines the type of metric\u2014\nin this case, a Resource metric. You have three types of metrics you can use in an\nHPA object:\n\uf0a1\nResource\n\uf0a1\nPods\n\uf0a1\nObject\nUNDERSTANDING THE RESOURCE METRIC TYPE\nThe Resource type makes the autoscaler base its autoscaling decisions on a resource\nmetric, like the ones specified in a container\u2019s resource requests. We\u2019ve already seen\nhow to do that, so let\u2019s focus on the other two types.\nUNDERSTANDING THE PODS METRIC TYPE\nThe Pods type is used to refer to any other (including custom) metric related to the\npod directly. An example of such a metric could be the already mentioned Queries-\nPer-Second (QPS) or the number of messages in a message broker\u2019s queue (when the\nmessage broker is running as a pod). To configure the autoscaler to use the pod\u2019s QPS\nmetric, the HPA object would need to include the entry shown in the following listing\nunder its metrics field.\n...\nspec:\n  metrics:\n  - type: Pods              \n    resource:\n      metricName: qps             \n      targetAverageValue: 100    \n...\nThe example in the listing configures the autoscaler to keep the average QPS of all\nthe pods managed by the ReplicaSet (or other) controller targeted by this HPA\nresource at 100. \nUNDERSTANDING THE OBJECT METRIC TYPE\nThe Object metric type is used when you want to make the autoscaler scale pods\nbased on a metric that doesn\u2019t pertain directly to those pods. For example, you may\nwant to scale pods according to a metric of another cluster object, such as an Ingress\nobject. The metric could be QPS as in listing 15.8, the average request latency, or\nsomething else completely. \n Unlike in the previous case, where the autoscaler needed to obtain the metric for\nall targeted pods and then use the average of those values, when you use an Object\nmetric type, the autoscaler obtains a single metric from the single object. In the HPA\nListing 15.8\nReferring to a custom pod metric in the HPA\nDefines a pod metric\nThe name of \nthe metric\nThe target average value \nacross all targeted pods\n \n", "shape": "dot", "size": 10, "title": "449\nHorizontal pod autoscaling\nAs you can see, the metrics field allows you to define more than one metric to use.\nIn the listing, you\u2019re using a single metric. Each entry defines the type of metric\u2014\nin this case, a Resource metric. You have three types of metrics you can use in an\nHPA object:\n\uf0a1\nResource\n\uf0a1\nPods\n\uf0a1\nObject\nUNDERSTANDING THE RESOURCE METRIC TYPE\nThe Resource type makes the autoscaler base its autoscaling decisions on a resource\nmetric, like the ones specified in a container\u2019s resource requests. We\u2019ve already seen\nhow to do that, so let\u2019s focus on the other two types.\nUNDERSTANDING THE PODS METRIC TYPE\nThe Pods type is used to refer to any other (including custom) metric related to the\npod directly. An example of such a metric could be the already mentioned Queries-\nPer-Second (QPS) or the number of messages in a message broker\u2019s queue (when the\nmessage broker is running as a pod). To configure the autoscaler to use the pod\u2019s QPS\nmetric, the HPA object would need to include the entry shown in the following listing\nunder its metrics field.\n...\nspec:\n  metrics:\n  - type: Pods              \n    resource:\n      metricName: qps             \n      targetAverageValue: 100    \n...\nThe example in the listing configures the autoscaler to keep the average QPS of all\nthe pods managed by the ReplicaSet (or other) controller targeted by this HPA\nresource at 100. \nUNDERSTANDING THE OBJECT METRIC TYPE\nThe Object metric type is used when you want to make the autoscaler scale pods\nbased on a metric that doesn\u2019t pertain directly to those pods. For example, you may\nwant to scale pods according to a metric of another cluster object, such as an Ingress\nobject. The metric could be QPS as in listing 15.8, the average request latency, or\nsomething else completely. \n Unlike in the previous case, where the autoscaler needed to obtain the metric for\nall targeted pods and then use the average of those values, when you use an Object\nmetric type, the autoscaler obtains a single metric from the single object. In the HPA\nListing 15.8\nReferring to a custom pod metric in the HPA\nDefines a pod metric\nThe name of \nthe metric\nThe target average value \nacross all targeted pods\n \n"}, {"color": "green", "id": "text_393", "label": "450\nCHAPTER 15\nAutomatic scaling of pods and cluster nodes\ndefinition, you need to specify the target object and the target value. The following\nlisting shows an example.\n...\nspec:\n  metrics:\n  - type: Object                   \n    resource:\n      metricName: latencyMillis           \n      target: \n        apiVersion: extensions/v1beta1     \n        kind: Ingress                      \n        name: frontend                     \n      targetValue: 20                   \n  scaleTargetRef:                          \n    apiVersion: extensions/v1beta1         \n    kind: Deployment                       \n    name: kubia                            \n...\nIn this example, the HPA is configured to use the latencyMillis metric of the\nfrontend Ingress object. The target value for the metric is 20. The horizontal pod\nautoscaler will monitor the Ingress\u2019 metric and if it rises too far above the target value,\nthe autoscaler will scale the kubia Deployment resource. \n15.1.5 Determining which metrics are appropriate for autoscaling\nYou need to understand that not all metrics are appropriate for use as the basis of\nautoscaling. As mentioned previously, the pods\u2019 containers\u2019 memory consumption isn\u2019t\na good metric for autoscaling. The autoscaler won\u2019t function properly if increasing\nthe number of replicas doesn\u2019t result in a linear decrease of the average value of the\nobserved metric (or at least close to linear). \n For example, if you have only a single pod instance and the value of the metric is X\nand the autoscaler scales up to two replicas, the metric needs to fall to somewhere\nclose to X/2. An example of such a custom metric is Queries per Second (QPS),\nwhich in the case of web applications reports the number of requests the application\nis receiving per second. Increasing the number of replicas will always result in a pro-\nportionate decrease of QPS, because a greater number of pods will be handling the\nsame total number of requests. \n Before you decide to base the autoscaler on your app\u2019s own custom metric, be sure\nto think about how its value will behave when the number of pods increases or\ndecreases.\n15.1.6 Scaling down to zero replicas\nThe horizontal pod autoscaler currently doesn\u2019t allow setting the minReplicas field\nto 0, so the autoscaler will never scale down to zero, even if the pods aren\u2019t doing\nListing 15.9\nReferring to a metric of a different object in the HPA\nUse metric of a \nspecific object\nThe name of \nthe metric\nThe specific object whose metric \nthe autoscaler should obtain\nThe\nAutoscaler\nshould\nscale so\nthe value\nof the\nmetric\nstays close\nto this.\nThe scalable resource the \nautoscaler will scale\n \n", "shape": "dot", "size": 10, "title": "450\nCHAPTER 15\nAutomatic scaling of pods and cluster nodes\ndefinition, you need to specify the target object and the target value. The following\nlisting shows an example.\n...\nspec:\n  metrics:\n  - type: Object                   \n    resource:\n      metricName: latencyMillis           \n      target: \n        apiVersion: extensions/v1beta1     \n        kind: Ingress                      \n        name: frontend                     \n      targetValue: 20                   \n  scaleTargetRef:                          \n    apiVersion: extensions/v1beta1         \n    kind: Deployment                       \n    name: kubia                            \n...\nIn this example, the HPA is configured to use the latencyMillis metric of the\nfrontend Ingress object. The target value for the metric is 20. The horizontal pod\nautoscaler will monitor the Ingress\u2019 metric and if it rises too far above the target value,\nthe autoscaler will scale the kubia Deployment resource. \n15.1.5 Determining which metrics are appropriate for autoscaling\nYou need to understand that not all metrics are appropriate for use as the basis of\nautoscaling. As mentioned previously, the pods\u2019 containers\u2019 memory consumption isn\u2019t\na good metric for autoscaling. The autoscaler won\u2019t function properly if increasing\nthe number of replicas doesn\u2019t result in a linear decrease of the average value of the\nobserved metric (or at least close to linear). \n For example, if you have only a single pod instance and the value of the metric is X\nand the autoscaler scales up to two replicas, the metric needs to fall to somewhere\nclose to X/2. An example of such a custom metric is Queries per Second (QPS),\nwhich in the case of web applications reports the number of requests the application\nis receiving per second. Increasing the number of replicas will always result in a pro-\nportionate decrease of QPS, because a greater number of pods will be handling the\nsame total number of requests. \n Before you decide to base the autoscaler on your app\u2019s own custom metric, be sure\nto think about how its value will behave when the number of pods increases or\ndecreases.\n15.1.6 Scaling down to zero replicas\nThe horizontal pod autoscaler currently doesn\u2019t allow setting the minReplicas field\nto 0, so the autoscaler will never scale down to zero, even if the pods aren\u2019t doing\nListing 15.9\nReferring to a metric of a different object in the HPA\nUse metric of a \nspecific object\nThe name of \nthe metric\nThe specific object whose metric \nthe autoscaler should obtain\nThe\nAutoscaler\nshould\nscale so\nthe value\nof the\nmetric\nstays close\nto this.\nThe scalable resource the \nautoscaler will scale\n \n"}, {"color": "green", "id": "text_394", "label": "451\nVertical pod autoscaling\nanything. Allowing the number of pods to be scaled down to zero can dramatically\nincrease the utilization of your hardware. When you run services that get requests only\nonce every few hours or even days, it doesn\u2019t make sense to have them running all the\ntime, eating up resources that could be used by other pods. But you still want to have\nthose services available immediately when a client request comes in. \n This is known as idling and un-idling. It allows pods that provide a certain service\nto be scaled down to zero. When a new request comes in, the request is blocked until\nthe pod is brought up and then the request is finally forwarded to the pod. \n Kubernetes currently doesn\u2019t provide this feature yet, but it will eventually. Check\nthe documentation to see if idling has been implemented yet. \n15.2\nVertical pod autoscaling\nHorizontal scaling is great, but not every application can be scaled horizontally. For\nsuch applications, the only option is to scale them vertically\u2014give them more CPU\nand/or memory. Because a node usually has more resources than a single pod\nrequests, it should almost always be possible to scale a pod vertically, right? \n Because a pod\u2019s resource requests are configured through fields in the pod\nmanifest, vertically scaling a pod would be performed by changing those fields. I\nsay \u201cwould\u201d because it\u2019s currently not possible to change either resource requests\nor limits of existing pods. Before I started writing the book (well over a year ago), I\nwas sure that by the time I wrote this chapter, Kubernetes would already support\nproper vertical pod autoscaling, so I included it in my proposal for the table of con-\ntents. Sadly, what seems like a lifetime later, vertical pod autoscaling is still not\navailable yet. \n15.2.1 Automatically configuring resource requests\nAn experimental feature sets the CPU and memory requests on newly created pods, if\ntheir containers don\u2019t have them set explicitly. The feature is provided by an Admission\nControl plugin called InitialResources. When a new pod without resource requests is\ncreated, the plugin looks at historical resource usage data of the pod\u2019s containers (per\nthe underlying container image and tag) and sets the requests accordingly. \n You can deploy pods without specifying resource requests and rely on Kubernetes\nto eventually figure out what each container\u2019s resource needs are. Effectively, Kuber-\nnetes is vertically scaling the pod. For example, if a container keeps running out of\nmemory, the next time a pod with that container image is created, its resource request\nfor memory will be set higher automatically.\n15.2.2 Modifying resource requests while a pod is running\nEventually, the same mechanism will be used to modify an existing pod\u2019s resource\nrequests, which means it will vertically scale the pod while it\u2019s running. As I\u2019m writing\nthis, a new vertical pod autoscaling proposal is being finalized. Please refer to the\n \n", "shape": "dot", "size": 10, "title": "451\nVertical pod autoscaling\nanything. Allowing the number of pods to be scaled down to zero can dramatically\nincrease the utilization of your hardware. When you run services that get requests only\nonce every few hours or even days, it doesn\u2019t make sense to have them running all the\ntime, eating up resources that could be used by other pods. But you still want to have\nthose services available immediately when a client request comes in. \n This is known as idling and un-idling. It allows pods that provide a certain service\nto be scaled down to zero. When a new request comes in, the request is blocked until\nthe pod is brought up and then the request is finally forwarded to the pod. \n Kubernetes currently doesn\u2019t provide this feature yet, but it will eventually. Check\nthe documentation to see if idling has been implemented yet. \n15.2\nVertical pod autoscaling\nHorizontal scaling is great, but not every application can be scaled horizontally. For\nsuch applications, the only option is to scale them vertically\u2014give them more CPU\nand/or memory. Because a node usually has more resources than a single pod\nrequests, it should almost always be possible to scale a pod vertically, right? \n Because a pod\u2019s resource requests are configured through fields in the pod\nmanifest, vertically scaling a pod would be performed by changing those fields. I\nsay \u201cwould\u201d because it\u2019s currently not possible to change either resource requests\nor limits of existing pods. Before I started writing the book (well over a year ago), I\nwas sure that by the time I wrote this chapter, Kubernetes would already support\nproper vertical pod autoscaling, so I included it in my proposal for the table of con-\ntents. Sadly, what seems like a lifetime later, vertical pod autoscaling is still not\navailable yet. \n15.2.1 Automatically configuring resource requests\nAn experimental feature sets the CPU and memory requests on newly created pods, if\ntheir containers don\u2019t have them set explicitly. The feature is provided by an Admission\nControl plugin called InitialResources. When a new pod without resource requests is\ncreated, the plugin looks at historical resource usage data of the pod\u2019s containers (per\nthe underlying container image and tag) and sets the requests accordingly. \n You can deploy pods without specifying resource requests and rely on Kubernetes\nto eventually figure out what each container\u2019s resource needs are. Effectively, Kuber-\nnetes is vertically scaling the pod. For example, if a container keeps running out of\nmemory, the next time a pod with that container image is created, its resource request\nfor memory will be set higher automatically.\n15.2.2 Modifying resource requests while a pod is running\nEventually, the same mechanism will be used to modify an existing pod\u2019s resource\nrequests, which means it will vertically scale the pod while it\u2019s running. As I\u2019m writing\nthis, a new vertical pod autoscaling proposal is being finalized. Please refer to the\n \n"}, {"color": "green", "id": "text_395", "label": "452\nCHAPTER 15\nAutomatic scaling of pods and cluster nodes\nKubernetes documentation to find out whether vertical pod autoscaling is already\nimplemented or not.\n15.3\nHorizontal scaling of cluster nodes\nThe Horizontal Pod Autoscaler creates additional pod instances when the need for\nthem arises. But what about when all your nodes are at capacity and can\u2019t run any\nmore pods? Obviously, this problem isn\u2019t limited only to when new pod instances are\ncreated by the Autoscaler. Even when creating pods manually, you may encounter the\nproblem where none of the nodes can accept the new pods, because the node\u2019s\nresources are used up by existing pods. \n In that case, you\u2019d need to delete several of those existing pods, scale them down\nvertically, or add additional nodes to your cluster. If your Kubernetes cluster is run-\nning on premises, you\u2019d need to physically add a new machine and make it part of the\nKubernetes cluster. But if your cluster is running on a cloud infrastructure, adding\nadditional nodes is usually a matter of a few clicks or an API call to the cloud infra-\nstructure. This can be done automatically, right?\n Kubernetes includes the feature to automatically request additional nodes from\nthe cloud provider as soon as it detects additional nodes are needed. This is per-\nformed by the Cluster Autoscaler.\n15.3.1 Introducing the Cluster Autoscaler\nThe Cluster Autoscaler takes care of automatically provisioning additional nodes\nwhen it notices a pod that can\u2019t be scheduled to existing nodes because of a lack of\nresources on those nodes. It also de-provisions nodes when they\u2019re underutilized for\nlonger periods of time. \nREQUESTING ADDITIONAL NODES FROM THE CLOUD INFRASTRUCTURE\nA new node will be provisioned if, after a new pod is created, the Scheduler can\u2019t\nschedule it to any of the existing nodes. The Cluster Autoscaler looks out for such\npods and asks the cloud provider to start up an additional node. But before doing\nthat, it checks whether the new node can even accommodate the pod. After all, if\nthat\u2019s not the case, it makes no sense to start up such a node.\n Cloud providers usually group nodes into groups (or pools) of same-sized nodes\n(or nodes having the same features). The Cluster Autoscaler thus can\u2019t simply say\n\u201cGive me an additional node.\u201d It needs to also specify the node type.\n The Cluster Autoscaler does this by examining the available node groups to see if\nat least one node type would be able to fit the unscheduled pod. If exactly one such\nnode group exists, the Autoscaler can increase the size of the node group to have the\ncloud provider add another node to the group. If more than one option is available,\nthe Autoscaler must pick the best one. The exact meaning of \u201cbest\u201d will obviously\nneed to be configurable. In the worst case, it selects a random one. A simple overview\nof how the cluster Autoscaler reacts to an unschedulable pod is shown in figure 15.5.\n \n", "shape": "dot", "size": 10, "title": "452\nCHAPTER 15\nAutomatic scaling of pods and cluster nodes\nKubernetes documentation to find out whether vertical pod autoscaling is already\nimplemented or not.\n15.3\nHorizontal scaling of cluster nodes\nThe Horizontal Pod Autoscaler creates additional pod instances when the need for\nthem arises. But what about when all your nodes are at capacity and can\u2019t run any\nmore pods? Obviously, this problem isn\u2019t limited only to when new pod instances are\ncreated by the Autoscaler. Even when creating pods manually, you may encounter the\nproblem where none of the nodes can accept the new pods, because the node\u2019s\nresources are used up by existing pods. \n In that case, you\u2019d need to delete several of those existing pods, scale them down\nvertically, or add additional nodes to your cluster. If your Kubernetes cluster is run-\nning on premises, you\u2019d need to physically add a new machine and make it part of the\nKubernetes cluster. But if your cluster is running on a cloud infrastructure, adding\nadditional nodes is usually a matter of a few clicks or an API call to the cloud infra-\nstructure. This can be done automatically, right?\n Kubernetes includes the feature to automatically request additional nodes from\nthe cloud provider as soon as it detects additional nodes are needed. This is per-\nformed by the Cluster Autoscaler.\n15.3.1 Introducing the Cluster Autoscaler\nThe Cluster Autoscaler takes care of automatically provisioning additional nodes\nwhen it notices a pod that can\u2019t be scheduled to existing nodes because of a lack of\nresources on those nodes. It also de-provisions nodes when they\u2019re underutilized for\nlonger periods of time. \nREQUESTING ADDITIONAL NODES FROM THE CLOUD INFRASTRUCTURE\nA new node will be provisioned if, after a new pod is created, the Scheduler can\u2019t\nschedule it to any of the existing nodes. The Cluster Autoscaler looks out for such\npods and asks the cloud provider to start up an additional node. But before doing\nthat, it checks whether the new node can even accommodate the pod. After all, if\nthat\u2019s not the case, it makes no sense to start up such a node.\n Cloud providers usually group nodes into groups (or pools) of same-sized nodes\n(or nodes having the same features). The Cluster Autoscaler thus can\u2019t simply say\n\u201cGive me an additional node.\u201d It needs to also specify the node type.\n The Cluster Autoscaler does this by examining the available node groups to see if\nat least one node type would be able to fit the unscheduled pod. If exactly one such\nnode group exists, the Autoscaler can increase the size of the node group to have the\ncloud provider add another node to the group. If more than one option is available,\nthe Autoscaler must pick the best one. The exact meaning of \u201cbest\u201d will obviously\nneed to be configurable. In the worst case, it selects a random one. A simple overview\nof how the cluster Autoscaler reacts to an unschedulable pod is shown in figure 15.5.\n \n"}, {"color": "green", "id": "text_396", "label": "453\nHorizontal scaling of cluster nodes\nWhen the new node starts up, the Kubelet on that node contacts the API server and\nregisters the node by creating a Node resource. From then on, the node is part of the\nKubernetes cluster and pods can be scheduled to it.\n Simple, right? What about scaling down?\nRELINQUISHING NODES\nThe Cluster Autoscaler also needs to scale down the number of nodes when they\naren\u2019t being utilized enough. The Autoscaler does this by monitoring the requested\nCPU and memory on all the nodes. If the CPU and memory requests of all the pods\nrunning on a given node are below 50%, the node is considered unnecessary. \n That\u2019s not the only determining factor in deciding whether to bring a node down.\nThe Autoscaler also checks to see if any system pods are running (only) on that node\n(apart from those that are run on every node, because they\u2019re deployed by a Daemon-\nSet, for example). If a system pod is running on a node, the node won\u2019t be relinquished.\nThe same is also true if an unmanaged pod or a pod with local storage is running on the\nnode, because that would cause disruption to the service the pod is providing. In other\nwords, a node will only be returned to the cloud provider if the Cluster Autoscaler\nknows the pods running on the node will be rescheduled to other nodes.\n When a node is selected to be shut down, the node is first marked as unschedula-\nble and then all the pods running on the node are evicted. Because all those pods\nbelong to ReplicaSets or other controllers, their replacements are created and sched-\nuled to the remaining nodes (that\u2019s why the node that\u2019s being shut down is first\nmarked as unschedulable).\nNode group X\nNode X1\n1. Autoscaler notices a\nPod can\u2019t be scheduled\nto existing nodes\n3. Autoscaler scales up the\nnode group selected in\nprevious step\n2. Autoscaler determines which node\ntype (if any) would be able to \ufb01t the\npod. If multiple types could \ufb01t the\npod, it selects one of them.\nCluster\nAutoscaler\nPods\nNode X2\nPods\nNode group Y\nNode Y1\nPods\nUnschedulable\npod\nFigure 15.5\nThe Cluster Autoscaler scales up when it finds a pod that can\u2019t be scheduled to \nexisting nodes.\n \n", "shape": "dot", "size": 10, "title": "453\nHorizontal scaling of cluster nodes\nWhen the new node starts up, the Kubelet on that node contacts the API server and\nregisters the node by creating a Node resource. From then on, the node is part of the\nKubernetes cluster and pods can be scheduled to it.\n Simple, right? What about scaling down?\nRELINQUISHING NODES\nThe Cluster Autoscaler also needs to scale down the number of nodes when they\naren\u2019t being utilized enough. The Autoscaler does this by monitoring the requested\nCPU and memory on all the nodes. If the CPU and memory requests of all the pods\nrunning on a given node are below 50%, the node is considered unnecessary. \n That\u2019s not the only determining factor in deciding whether to bring a node down.\nThe Autoscaler also checks to see if any system pods are running (only) on that node\n(apart from those that are run on every node, because they\u2019re deployed by a Daemon-\nSet, for example). If a system pod is running on a node, the node won\u2019t be relinquished.\nThe same is also true if an unmanaged pod or a pod with local storage is running on the\nnode, because that would cause disruption to the service the pod is providing. In other\nwords, a node will only be returned to the cloud provider if the Cluster Autoscaler\nknows the pods running on the node will be rescheduled to other nodes.\n When a node is selected to be shut down, the node is first marked as unschedula-\nble and then all the pods running on the node are evicted. Because all those pods\nbelong to ReplicaSets or other controllers, their replacements are created and sched-\nuled to the remaining nodes (that\u2019s why the node that\u2019s being shut down is first\nmarked as unschedulable).\nNode group X\nNode X1\n1. Autoscaler notices a\nPod can\u2019t be scheduled\nto existing nodes\n3. Autoscaler scales up the\nnode group selected in\nprevious step\n2. Autoscaler determines which node\ntype (if any) would be able to \ufb01t the\npod. If multiple types could \ufb01t the\npod, it selects one of them.\nCluster\nAutoscaler\nPods\nNode X2\nPods\nNode group Y\nNode Y1\nPods\nUnschedulable\npod\nFigure 15.5\nThe Cluster Autoscaler scales up when it finds a pod that can\u2019t be scheduled to \nexisting nodes.\n \n"}, {"color": "green", "id": "text_397", "label": "454\nCHAPTER 15\nAutomatic scaling of pods and cluster nodes\n15.3.2 Enabling the Cluster Autoscaler\nCluster autoscaling is currently available on\n\uf0a1Google Kubernetes Engine (GKE)\n\uf0a1Google Compute Engine (GCE)\n\uf0a1Amazon Web Services (AWS)\n\uf0a1Microsoft Azure\nHow you start the Autoscaler depends on where your Kubernetes cluster is running.\nFor your kubia cluster running on GKE, you can enable the Cluster Autoscaler like\nthis:\n$ gcloud container clusters update kubia --enable-autoscaling \\\n  --min-nodes=3 --max-nodes=5\nIf your cluster is running on GCE, you need to set three environment variables before\nrunning kube-up.sh: \n\uf0a1\nKUBE_ENABLE_CLUSTER_AUTOSCALER=true\n\uf0a1\nKUBE_AUTOSCALER_MIN_NODES=3\n\uf0a1\nKUBE_AUTOSCALER_MAX_NODES=5\nRefer to the Cluster Autoscaler GitHub repo at https:/\n/github.com/kubernetes/auto-\nscaler/tree/master/cluster-autoscaler for information on how to enable it on other\nplatforms. \nNOTE\nThe Cluster Autoscaler publishes its status to the cluster-autoscaler-\nstatus ConfigMap in the kube-system namespace.\n15.3.3 Limiting service disruption during cluster scale-down\nWhen a node fails unexpectedly, nothing you can do will prevent its pods from becom-\ning unavailable. But when a node is shut down voluntarily, either by the Cluster Auto-\nscaler or by a human operator, you can make sure the operation doesn\u2019t disrupt the\nservice provided by the pods running on that node through an additional feature.\nManually cordoning and draining nodes\nA node can also be marked as unschedulable and drained manually. Without going\ninto specifics, this is done with the following kubectl commands:\n\uf0a1\nkubectl cordon \u003cnode\u003e marks the node as unschedulable (but doesn\u2019t do\nanything with pods running on that node).\n\uf0a1\nkubectl drain \u003cnode\u003e marks the node as unschedulable and then evicts all\nthe pods from the node.\nIn both cases, no new pods are scheduled to the node until you uncordon it again\nwith kubectl uncordon \u003cnode\u003e.\n \n", "shape": "dot", "size": 10, "title": "454\nCHAPTER 15\nAutomatic scaling of pods and cluster nodes\n15.3.2 Enabling the Cluster Autoscaler\nCluster autoscaling is currently available on\n\uf0a1Google Kubernetes Engine (GKE)\n\uf0a1Google Compute Engine (GCE)\n\uf0a1Amazon Web Services (AWS)\n\uf0a1Microsoft Azure\nHow you start the Autoscaler depends on where your Kubernetes cluster is running.\nFor your kubia cluster running on GKE, you can enable the Cluster Autoscaler like\nthis:\n$ gcloud container clusters update kubia --enable-autoscaling \\\n  --min-nodes=3 --max-nodes=5\nIf your cluster is running on GCE, you need to set three environment variables before\nrunning kube-up.sh: \n\uf0a1\nKUBE_ENABLE_CLUSTER_AUTOSCALER=true\n\uf0a1\nKUBE_AUTOSCALER_MIN_NODES=3\n\uf0a1\nKUBE_AUTOSCALER_MAX_NODES=5\nRefer to the Cluster Autoscaler GitHub repo at https:/\n/github.com/kubernetes/auto-\nscaler/tree/master/cluster-autoscaler for information on how to enable it on other\nplatforms. \nNOTE\nThe Cluster Autoscaler publishes its status to the cluster-autoscaler-\nstatus ConfigMap in the kube-system namespace.\n15.3.3 Limiting service disruption during cluster scale-down\nWhen a node fails unexpectedly, nothing you can do will prevent its pods from becom-\ning unavailable. But when a node is shut down voluntarily, either by the Cluster Auto-\nscaler or by a human operator, you can make sure the operation doesn\u2019t disrupt the\nservice provided by the pods running on that node through an additional feature.\nManually cordoning and draining nodes\nA node can also be marked as unschedulable and drained manually. Without going\ninto specifics, this is done with the following kubectl commands:\n\uf0a1\nkubectl cordon \u003cnode\u003e marks the node as unschedulable (but doesn\u2019t do\nanything with pods running on that node).\n\uf0a1\nkubectl drain \u003cnode\u003e marks the node as unschedulable and then evicts all\nthe pods from the node.\nIn both cases, no new pods are scheduled to the node until you uncordon it again\nwith kubectl uncordon \u003cnode\u003e.\n \n"}, {"color": "green", "id": "text_398", "label": "455\nHorizontal scaling of cluster nodes\n Certain services require that a minimum number of pods always keeps running;\nthis is especially true for quorum-based clustered applications. For this reason, Kuber-\nnetes provides a way of specifying the minimum number of pods that need to keep\nrunning while performing these types of operations. This is done by creating a Pod-\nDisruptionBudget resource.\n Even though the name of the resource sounds complex, it\u2019s one of the simplest\nKubernetes resources available. It contains only a pod label selector and a number\nspecifying the minimum number of pods that must always be available or, starting\nfrom Kubernetes version 1.7, the maximum number of pods that can be unavailable.\nWe\u2019ll look at what a PodDisruptionBudget (PDB) resource manifest looks like, but\ninstead of creating it from a YAML file, you\u2019ll create it with kubectl create pod-\ndisruptionbudget and then obtain and examine the YAML later.\n If you want to ensure three instances of your kubia pod are always running (they\nhave the label app=kubia), create the PodDisruptionBudget resource like this:\n$ kubectl create pdb kubia-pdb --selector=app=kubia --min-available=3\npoddisruptionbudget \"kubia-pdb\" created\nSimple, right? Now, retrieve the PDB\u2019s YAML. It\u2019s shown in the next listing.\n$ kubectl get pdb kubia-pdb -o yaml\napiVersion: policy/v1beta1\nkind: PodDisruptionBudget\nmetadata:\n  name: kubia-pdb\nspec:\n  minAvailable: 3         \n  selector:                \n    matchLabels:           \n      app: kubia           \nstatus:\n  ...\nYou can also use a percentage instead of an absolute number in the minAvailable\nfield. For example, you could state that 60% of all pods with the app=kubia label need\nto be running at all times.\nNOTE\nStarting with Kubernetes 1.7, the PodDisruptionBudget resource also\nsupports the maxUnavailable field, which you can use instead of min-\nAvailable if you want to block evictions when more than that many pods are\nunavailable. \nWe don\u2019t have much more to say about this resource. As long as it exists, both the\nCluster Autoscaler and the kubectl drain command will adhere to it and will never\nevict a pod with the app=kubia label if that would bring the number of such pods\nbelow three. \nListing 15.10\nA PodDisruptionBudget definition\nHow many pods should \nalways be available\nThe label selector that \ndetermines which pods \nthis budget applies to\n \n", "shape": "dot", "size": 10, "title": "455\nHorizontal scaling of cluster nodes\n Certain services require that a minimum number of pods always keeps running;\nthis is especially true for quorum-based clustered applications. For this reason, Kuber-\nnetes provides a way of specifying the minimum number of pods that need to keep\nrunning while performing these types of operations. This is done by creating a Pod-\nDisruptionBudget resource.\n Even though the name of the resource sounds complex, it\u2019s one of the simplest\nKubernetes resources available. It contains only a pod label selector and a number\nspecifying the minimum number of pods that must always be available or, starting\nfrom Kubernetes version 1.7, the maximum number of pods that can be unavailable.\nWe\u2019ll look at what a PodDisruptionBudget (PDB) resource manifest looks like, but\ninstead of creating it from a YAML file, you\u2019ll create it with kubectl create pod-\ndisruptionbudget and then obtain and examine the YAML later.\n If you want to ensure three instances of your kubia pod are always running (they\nhave the label app=kubia), create the PodDisruptionBudget resource like this:\n$ kubectl create pdb kubia-pdb --selector=app=kubia --min-available=3\npoddisruptionbudget \"kubia-pdb\" created\nSimple, right? Now, retrieve the PDB\u2019s YAML. It\u2019s shown in the next listing.\n$ kubectl get pdb kubia-pdb -o yaml\napiVersion: policy/v1beta1\nkind: PodDisruptionBudget\nmetadata:\n  name: kubia-pdb\nspec:\n  minAvailable: 3         \n  selector:                \n    matchLabels:           \n      app: kubia           \nstatus:\n  ...\nYou can also use a percentage instead of an absolute number in the minAvailable\nfield. For example, you could state that 60% of all pods with the app=kubia label need\nto be running at all times.\nNOTE\nStarting with Kubernetes 1.7, the PodDisruptionBudget resource also\nsupports the maxUnavailable field, which you can use instead of min-\nAvailable if you want to block evictions when more than that many pods are\nunavailable. \nWe don\u2019t have much more to say about this resource. As long as it exists, both the\nCluster Autoscaler and the kubectl drain command will adhere to it and will never\nevict a pod with the app=kubia label if that would bring the number of such pods\nbelow three. \nListing 15.10\nA PodDisruptionBudget definition\nHow many pods should \nalways be available\nThe label selector that \ndetermines which pods \nthis budget applies to\n \n"}, {"color": "green", "id": "text_399", "label": "456\nCHAPTER 15\nAutomatic scaling of pods and cluster nodes\n For example, if there were four pods altogether and minAvailable was set to three\nas in the example, the pod eviction process would evict pods one by one, waiting for\nthe evicted pod to be replaced with a new one by the ReplicaSet controller, before\nevicting another pod. \n15.4\nSummary\nThis chapter has shown you how Kubernetes can scale not only your pods, but also\nyour nodes. You\u2019ve learned that\n\uf0a1Configuring the automatic horizontal scaling of pods is as easy as creating a\nHorizontalPodAutoscaler object and pointing it to a Deployment, ReplicaSet,\nor ReplicationController and specifying the target CPU utilization for the pods.\n\uf0a1Besides having the Horizontal Pod Autoscaler perform scaling operations based\non the pods\u2019 CPU utilization, you can also configure it to scale based on your\nown application-provided custom metrics or metrics related to other objects\ndeployed in the cluster.\n\uf0a1Vertical pod autoscaling isn\u2019t possible yet.\n\uf0a1Even cluster nodes can be scaled automatically if your Kubernetes cluster runs\non a supported cloud provider.\n\uf0a1You can run one-off processes in a pod and have the pod stopped and deleted\nautomatically as soon you press CTRL+C by using kubectl run with the -it and\n--rm options.\nIn the next chapter, you\u2019ll explore advanced scheduling features, such as how to keep\ncertain pods away from certain nodes and how to schedule pods either close together\nor apart.\n \n", "shape": "dot", "size": 10, "title": "456\nCHAPTER 15\nAutomatic scaling of pods and cluster nodes\n For example, if there were four pods altogether and minAvailable was set to three\nas in the example, the pod eviction process would evict pods one by one, waiting for\nthe evicted pod to be replaced with a new one by the ReplicaSet controller, before\nevicting another pod. \n15.4\nSummary\nThis chapter has shown you how Kubernetes can scale not only your pods, but also\nyour nodes. You\u2019ve learned that\n\uf0a1Configuring the automatic horizontal scaling of pods is as easy as creating a\nHorizontalPodAutoscaler object and pointing it to a Deployment, ReplicaSet,\nor ReplicationController and specifying the target CPU utilization for the pods.\n\uf0a1Besides having the Horizontal Pod Autoscaler perform scaling operations based\non the pods\u2019 CPU utilization, you can also configure it to scale based on your\nown application-provided custom metrics or metrics related to other objects\ndeployed in the cluster.\n\uf0a1Vertical pod autoscaling isn\u2019t possible yet.\n\uf0a1Even cluster nodes can be scaled automatically if your Kubernetes cluster runs\non a supported cloud provider.\n\uf0a1You can run one-off processes in a pod and have the pod stopped and deleted\nautomatically as soon you press CTRL+C by using kubectl run with the -it and\n--rm options.\nIn the next chapter, you\u2019ll explore advanced scheduling features, such as how to keep\ncertain pods away from certain nodes and how to schedule pods either close together\nor apart.\n \n"}, {"color": "green", "id": "text_400", "label": "457\nAdvanced scheduling\nKubernetes allows you to affect where pods are scheduled. Initially, this was only\ndone by specifying a node selector in the pod specification, but additional mech-\nanisms were later added that expanded this functionality. They\u2019re covered in this\nchapter.\n16.1\nUsing taints and tolerations to repel pods from \ncertain nodes\nThe first two features related to advanced scheduling that we\u2019ll explore here are\nthe node taints and pods\u2019 tolerations of those taints. They\u2019re used for restricting\nThis chapter covers\n\uf0a1Using node taints and pod tolerations to keep \npods away from certain nodes\n\uf0a1Defining node affinity rules as an alternative to \nnode selectors\n\uf0a1Co-locating pods using pod affinity \n\uf0a1Keeping pods away from each other using pod \nanti-affinity\n \n", "shape": "dot", "size": 10, "title": "457\nAdvanced scheduling\nKubernetes allows you to affect where pods are scheduled. Initially, this was only\ndone by specifying a node selector in the pod specification, but additional mech-\nanisms were later added that expanded this functionality. They\u2019re covered in this\nchapter.\n16.1\nUsing taints and tolerations to repel pods from \ncertain nodes\nThe first two features related to advanced scheduling that we\u2019ll explore here are\nthe node taints and pods\u2019 tolerations of those taints. They\u2019re used for restricting\nThis chapter covers\n\uf0a1Using node taints and pod tolerations to keep \npods away from certain nodes\n\uf0a1Defining node affinity rules as an alternative to \nnode selectors\n\uf0a1Co-locating pods using pod affinity \n\uf0a1Keeping pods away from each other using pod \nanti-affinity\n \n"}, {"color": "green", "id": "text_401", "label": "458\nCHAPTER 16\nAdvanced scheduling\nwhich pods can use a certain node. A pod can only be scheduled to a node if it toler-\nates the node\u2019s taints.\n This is somewhat different from using node selectors and node affinity, which\nyou\u2019ll learn about later in this chapter. Node selectors and node affinity rules make\nit possible to select which nodes a pod can or can\u2019t be scheduled to by specifically\nadding that information to the pod, whereas taints allow rejecting deployment of\npods to certain nodes by only adding taints to the node without having to modify\nexisting pods. Pods that you want deployed on a tainted node need to opt in to use\nthe node, whereas with node selectors, pods explicitly specify which node(s) they\nwant to be deployed to.\n16.1.1 Introducing taints and tolerations\nThe best path to learn about node taints is to see an existing taint. Appendix B shows\nhow to set up a multi-node cluster with the kubeadm tool. By default, the master node\nin such a cluster is tainted, so only Control Plane pods can be deployed on it. \nDISPLAYING A NODE\u2019S TAINTS\nYou can see the node\u2019s taints using kubectl describe node, as shown in the follow-\ning listing.\n$ kubectl describe node master.k8s\nName:         master.k8s\nRole:\nLabels:       beta.kubernetes.io/arch=amd64\n              beta.kubernetes.io/os=linux\n              kubernetes.io/hostname=master.k8s\n              node-role.kubernetes.io/master=\nAnnotations:  node.alpha.kubernetes.io/ttl=0\n              volumes.kubernetes.io/controller-managed-attach-detach=true\nTaints:       node-role.kubernetes.io/master:NoSchedule      \n...\nThe master node has a single taint. Taints have a key, value, and an effect, and are repre-\nsented as \u003ckey\u003e=\u003cvalue\u003e:\u003ceffect\u003e. The master node\u2019s taint shown in the previous\nlisting has the key node-role.kubernetes.io/master, a null value (not shown in the\ntaint), and the effect of NoSchedule. \n This taint prevents pods from being scheduled to the master node, unless those pods\ntolerate this taint. The pods that tolerate it are usually system pods (see figure 16.1).\n \n \n \n \nListing 16.1\nDescribing the master node in a cluster created with kubeadm\nThe master node \nhas one taint.\n \n", "shape": "dot", "size": 10, "title": "458\nCHAPTER 16\nAdvanced scheduling\nwhich pods can use a certain node. A pod can only be scheduled to a node if it toler-\nates the node\u2019s taints.\n This is somewhat different from using node selectors and node affinity, which\nyou\u2019ll learn about later in this chapter. Node selectors and node affinity rules make\nit possible to select which nodes a pod can or can\u2019t be scheduled to by specifically\nadding that information to the pod, whereas taints allow rejecting deployment of\npods to certain nodes by only adding taints to the node without having to modify\nexisting pods. Pods that you want deployed on a tainted node need to opt in to use\nthe node, whereas with node selectors, pods explicitly specify which node(s) they\nwant to be deployed to.\n16.1.1 Introducing taints and tolerations\nThe best path to learn about node taints is to see an existing taint. Appendix B shows\nhow to set up a multi-node cluster with the kubeadm tool. By default, the master node\nin such a cluster is tainted, so only Control Plane pods can be deployed on it. \nDISPLAYING A NODE\u2019S TAINTS\nYou can see the node\u2019s taints using kubectl describe node, as shown in the follow-\ning listing.\n$ kubectl describe node master.k8s\nName:         master.k8s\nRole:\nLabels:       beta.kubernetes.io/arch=amd64\n              beta.kubernetes.io/os=linux\n              kubernetes.io/hostname=master.k8s\n              node-role.kubernetes.io/master=\nAnnotations:  node.alpha.kubernetes.io/ttl=0\n              volumes.kubernetes.io/controller-managed-attach-detach=true\nTaints:       node-role.kubernetes.io/master:NoSchedule      \n...\nThe master node has a single taint. Taints have a key, value, and an effect, and are repre-\nsented as \u003ckey\u003e=\u003cvalue\u003e:\u003ceffect\u003e. The master node\u2019s taint shown in the previous\nlisting has the key node-role.kubernetes.io/master, a null value (not shown in the\ntaint), and the effect of NoSchedule. \n This taint prevents pods from being scheduled to the master node, unless those pods\ntolerate this taint. The pods that tolerate it are usually system pods (see figure 16.1).\n \n \n \n \nListing 16.1\nDescribing the master node in a cluster created with kubeadm\nThe master node \nhas one taint.\n \n"}, {"color": "green", "id": "text_402", "label": "459\nUsing taints and tolerations to repel pods from certain nodes\nDISPLAYING A POD\u2019S TOLERATIONS\nIn a cluster installed with kubeadm, the kube-proxy cluster component runs as a pod\non every node, including the master node, because master components that run as\npods may also need to access Kubernetes Services. To make sure the kube-proxy pod\nalso runs on the master node, it includes the appropriate toleration. In total, the pod\nhas three tolerations, which are shown in the following listing.\n$ kubectl describe po kube-proxy-80wqm -n kube-system\n...\nTolerations:    node-role.kubernetes.io/master=:NoSchedule\n                node.alpha.kubernetes.io/notReady=:Exists:NoExecute\n                node.alpha.kubernetes.io/unreachable=:Exists:NoExecute\n...\nAs you can see, the first toleration matches the master node\u2019s taint, allowing this kube-\nproxy pod to be scheduled to the master node. \nNOTE\nDisregard the equal sign, which is shown in the pod\u2019s tolerations, but\nnot in the node\u2019s taints. Kubectl apparently displays taints and tolerations dif-\nferently when the taint\u2019s/toleration\u2019s value is null.\nUNDERSTANDING TAINT EFFECTS\nThe two other tolerations on the kube-proxy pod define how long the pod is allowed\nto run on nodes that aren\u2019t ready or are unreachable (the time in seconds isn\u2019t shown,\nListing 16.2\nA pod\u2019s tolerations\nSystem pod may be\nscheduled to master\nnode because its\ntoleration matches\nthe node\u2019s taint.\nSystem pod\nMaster node\nTaint:\nnode-role.kubernetes.io\n/master:NoSchedule\nToleration:\nnode-role.kubernetes.io\n/master:NoSchedule\nRegular pod\nRegular node\nNo taints\nNo tolerations\nPods with no tolerations\nmay only be scheduled\nto nodes without taints.\nFigure 16.1\nA pod is only scheduled to a node if it tolerates the node\u2019s taints.\n \n", "shape": "dot", "size": 10, "title": "459\nUsing taints and tolerations to repel pods from certain nodes\nDISPLAYING A POD\u2019S TOLERATIONS\nIn a cluster installed with kubeadm, the kube-proxy cluster component runs as a pod\non every node, including the master node, because master components that run as\npods may also need to access Kubernetes Services. To make sure the kube-proxy pod\nalso runs on the master node, it includes the appropriate toleration. In total, the pod\nhas three tolerations, which are shown in the following listing.\n$ kubectl describe po kube-proxy-80wqm -n kube-system\n...\nTolerations:    node-role.kubernetes.io/master=:NoSchedule\n                node.alpha.kubernetes.io/notReady=:Exists:NoExecute\n                node.alpha.kubernetes.io/unreachable=:Exists:NoExecute\n...\nAs you can see, the first toleration matches the master node\u2019s taint, allowing this kube-\nproxy pod to be scheduled to the master node. \nNOTE\nDisregard the equal sign, which is shown in the pod\u2019s tolerations, but\nnot in the node\u2019s taints. Kubectl apparently displays taints and tolerations dif-\nferently when the taint\u2019s/toleration\u2019s value is null.\nUNDERSTANDING TAINT EFFECTS\nThe two other tolerations on the kube-proxy pod define how long the pod is allowed\nto run on nodes that aren\u2019t ready or are unreachable (the time in seconds isn\u2019t shown,\nListing 16.2\nA pod\u2019s tolerations\nSystem pod may be\nscheduled to master\nnode because its\ntoleration matches\nthe node\u2019s taint.\nSystem pod\nMaster node\nTaint:\nnode-role.kubernetes.io\n/master:NoSchedule\nToleration:\nnode-role.kubernetes.io\n/master:NoSchedule\nRegular pod\nRegular node\nNo taints\nNo tolerations\nPods with no tolerations\nmay only be scheduled\nto nodes without taints.\nFigure 16.1\nA pod is only scheduled to a node if it tolerates the node\u2019s taints.\n \n"}, {"color": "green", "id": "text_403", "label": "460\nCHAPTER 16\nAdvanced scheduling\nbut can be seen in the pod\u2019s YAML). Those two tolerations refer to the NoExecute\ninstead of the NoSchedule effect. \n Each taint has an effect associated with it. Three possible effects exist:\n\uf0a1\nNoSchedule, which means pods won\u2019t be scheduled to the node if they don\u2019t tol-\nerate the taint.\n\uf0a1\nPreferNoSchedule is a soft version of NoSchedule, meaning the scheduler will\ntry to avoid scheduling the pod to the node, but will schedule it to the node if it\ncan\u2019t schedule it somewhere else. \n\uf0a1\nNoExecute, unlike NoSchedule and PreferNoSchedule that only affect schedul-\ning, also affects pods already running on the node. If you add a NoExecute taint\nto a node, pods that are already running on that node and don\u2019t tolerate the\nNoExecute taint will be evicted from the node. \n16.1.2 Adding custom taints to a node\nImagine having a single Kubernetes cluster where you run both production and non-\nproduction workloads. It\u2019s of the utmost importance that non-production pods never\nrun on the production nodes. This can be achieved by adding a taint to your produc-\ntion nodes. To add a taint, you use the kubectl taint command:\n$ kubectl taint node node1.k8s node-type=production:NoSchedule\nnode \"node1.k8s\" tainted\nThis adds a taint with key node-type, value production and the NoSchedule effect. If\nyou now deploy multiple replicas of a regular pod, you\u2019ll see none of them are sched-\nuled to the node you tainted, as shown in the following listing.\n$ kubectl run test --image busybox --replicas 5 -- sleep 99999\ndeployment \"test\" created\n$ kubectl get po -o wide\nNAME                READY  STATUS    RESTARTS   AGE   IP          NODE\ntest-196686-46ngl   1/1    Running   0          12s   10.47.0.1   node2.k8s\ntest-196686-73p89   1/1    Running   0          12s   10.47.0.7   node2.k8s\ntest-196686-77280   1/1    Running   0          12s   10.47.0.6   node2.k8s\ntest-196686-h9m8f   1/1    Running   0          12s   10.47.0.5   node2.k8s\ntest-196686-p85ll   1/1    Running   0          12s   10.47.0.4   node2.k8s\nNow, no one can inadvertently deploy pods onto the production nodes. \n16.1.3 Adding tolerations to pods\nTo deploy production pods to the production nodes, they need to tolerate the taint\nyou added to the nodes. The manifests of your production pods need to include the\nYAML snippet shown in the following listing.\n \nListing 16.3\nDeploying pods without a toleration\n \n", "shape": "dot", "size": 10, "title": "460\nCHAPTER 16\nAdvanced scheduling\nbut can be seen in the pod\u2019s YAML). Those two tolerations refer to the NoExecute\ninstead of the NoSchedule effect. \n Each taint has an effect associated with it. Three possible effects exist:\n\uf0a1\nNoSchedule, which means pods won\u2019t be scheduled to the node if they don\u2019t tol-\nerate the taint.\n\uf0a1\nPreferNoSchedule is a soft version of NoSchedule, meaning the scheduler will\ntry to avoid scheduling the pod to the node, but will schedule it to the node if it\ncan\u2019t schedule it somewhere else. \n\uf0a1\nNoExecute, unlike NoSchedule and PreferNoSchedule that only affect schedul-\ning, also affects pods already running on the node. If you add a NoExecute taint\nto a node, pods that are already running on that node and don\u2019t tolerate the\nNoExecute taint will be evicted from the node. \n16.1.2 Adding custom taints to a node\nImagine having a single Kubernetes cluster where you run both production and non-\nproduction workloads. It\u2019s of the utmost importance that non-production pods never\nrun on the production nodes. This can be achieved by adding a taint to your produc-\ntion nodes. To add a taint, you use the kubectl taint command:\n$ kubectl taint node node1.k8s node-type=production:NoSchedule\nnode \"node1.k8s\" tainted\nThis adds a taint with key node-type, value production and the NoSchedule effect. If\nyou now deploy multiple replicas of a regular pod, you\u2019ll see none of them are sched-\nuled to the node you tainted, as shown in the following listing.\n$ kubectl run test --image busybox --replicas 5 -- sleep 99999\ndeployment \"test\" created\n$ kubectl get po -o wide\nNAME                READY  STATUS    RESTARTS   AGE   IP          NODE\ntest-196686-46ngl   1/1    Running   0          12s   10.47.0.1   node2.k8s\ntest-196686-73p89   1/1    Running   0          12s   10.47.0.7   node2.k8s\ntest-196686-77280   1/1    Running   0          12s   10.47.0.6   node2.k8s\ntest-196686-h9m8f   1/1    Running   0          12s   10.47.0.5   node2.k8s\ntest-196686-p85ll   1/1    Running   0          12s   10.47.0.4   node2.k8s\nNow, no one can inadvertently deploy pods onto the production nodes. \n16.1.3 Adding tolerations to pods\nTo deploy production pods to the production nodes, they need to tolerate the taint\nyou added to the nodes. The manifests of your production pods need to include the\nYAML snippet shown in the following listing.\n \nListing 16.3\nDeploying pods without a toleration\n \n"}, {"color": "green", "id": "text_404", "label": "461\nUsing taints and tolerations to repel pods from certain nodes\napiVersion: extensions/v1beta1\nkind: Deployment\nmetadata:\n  name: prod\nspec:\n  replicas: 5\n  template:\n    spec:\n      ...\n      tolerations:\n      - key: node-type         \n        Operator: Equal        \n        value: production      \n        effect: NoSchedule     \nIf you deploy this Deployment, you\u2019ll see its pods get deployed to the production\nnode, as shown in the next listing.\n$ kubectl get po -o wide\nNAME                READY  STATUS    RESTARTS   AGE   IP          NODE\nprod-350605-1ph5h   0/1    Running   0          16s   10.44.0.3   node1.k8s\nprod-350605-ctqcr   1/1    Running   0          16s   10.47.0.4   node2.k8s\nprod-350605-f7pcc   0/1    Running   0          17s   10.44.0.6   node1.k8s\nprod-350605-k7c8g   1/1    Running   0          17s   10.47.0.9   node2.k8s\nprod-350605-rp1nv   0/1    Running   0          17s   10.44.0.4   node1.k8s\nAs you can see in the listing, production pods were also deployed to node2, which isn\u2019t\na production node. To prevent that from happening, you\u2019d also need to taint the non-\nproduction nodes with a taint such as node-type=non-production:NoSchedule. Then\nyou\u2019d also need to add the matching toleration to all your non-production pods.\n16.1.4 Understanding what taints and tolerations can be used for\nNodes can have more than one taint and pods can have more than one toleration. As\nyou\u2019ve seen, taints can only have a key and an effect and don\u2019t require a value. Tolera-\ntions can tolerate a specific value by specifying the Equal operator (that\u2019s also the\ndefault operator if you don\u2019t specify one), or they can tolerate any value for a specific\ntaint key if you use the Exists operator.\nUSING TAINTS AND TOLERATIONS DURING SCHEDULING\nTaints can be used to prevent scheduling of new pods (NoSchedule effect) and to\ndefine unpreferred nodes (PreferNoSchedule effect) and even evict existing pods\nfrom a node (NoExecute).\n You can set up taints and tolerations any way you see fit. For example, you could\npartition your cluster into multiple partitions, allowing your development teams to\nschedule pods only to their respective nodes. You can also use taints and tolerations\nListing 16.4\nA production Deployment with a toleration: production-deployment.yaml\nListing 16.5\nPods with the toleration are deployed on production node1\nThis toleration allows the \npod to be scheduled to \nproduction nodes.\n \n", "shape": "dot", "size": 10, "title": "461\nUsing taints and tolerations to repel pods from certain nodes\napiVersion: extensions/v1beta1\nkind: Deployment\nmetadata:\n  name: prod\nspec:\n  replicas: 5\n  template:\n    spec:\n      ...\n      tolerations:\n      - key: node-type         \n        Operator: Equal        \n        value: production      \n        effect: NoSchedule     \nIf you deploy this Deployment, you\u2019ll see its pods get deployed to the production\nnode, as shown in the next listing.\n$ kubectl get po -o wide\nNAME                READY  STATUS    RESTARTS   AGE   IP          NODE\nprod-350605-1ph5h   0/1    Running   0          16s   10.44.0.3   node1.k8s\nprod-350605-ctqcr   1/1    Running   0          16s   10.47.0.4   node2.k8s\nprod-350605-f7pcc   0/1    Running   0          17s   10.44.0.6   node1.k8s\nprod-350605-k7c8g   1/1    Running   0          17s   10.47.0.9   node2.k8s\nprod-350605-rp1nv   0/1    Running   0          17s   10.44.0.4   node1.k8s\nAs you can see in the listing, production pods were also deployed to node2, which isn\u2019t\na production node. To prevent that from happening, you\u2019d also need to taint the non-\nproduction nodes with a taint such as node-type=non-production:NoSchedule. Then\nyou\u2019d also need to add the matching toleration to all your non-production pods.\n16.1.4 Understanding what taints and tolerations can be used for\nNodes can have more than one taint and pods can have more than one toleration. As\nyou\u2019ve seen, taints can only have a key and an effect and don\u2019t require a value. Tolera-\ntions can tolerate a specific value by specifying the Equal operator (that\u2019s also the\ndefault operator if you don\u2019t specify one), or they can tolerate any value for a specific\ntaint key if you use the Exists operator.\nUSING TAINTS AND TOLERATIONS DURING SCHEDULING\nTaints can be used to prevent scheduling of new pods (NoSchedule effect) and to\ndefine unpreferred nodes (PreferNoSchedule effect) and even evict existing pods\nfrom a node (NoExecute).\n You can set up taints and tolerations any way you see fit. For example, you could\npartition your cluster into multiple partitions, allowing your development teams to\nschedule pods only to their respective nodes. You can also use taints and tolerations\nListing 16.4\nA production Deployment with a toleration: production-deployment.yaml\nListing 16.5\nPods with the toleration are deployed on production node1\nThis toleration allows the \npod to be scheduled to \nproduction nodes.\n \n"}, {"color": "green", "id": "text_405", "label": "462\nCHAPTER 16\nAdvanced scheduling\nwhen several of your nodes provide special hardware and only part of your pods need\nto use it.\nCONFIGURING HOW LONG AFTER A NODE FAILURE A POD IS RESCHEDULED\nYou can also use a toleration to specify how long Kubernetes should wait before\nrescheduling a pod to another node if the node the pod is running on becomes\nunready or unreachable. If you look at the tolerations of one of your pods, you\u2019ll see\ntwo tolerations, which are shown in the following listing.\n$ kubectl get po prod-350605-1ph5h -o yaml\n...\n  tolerations:\n  - effect: NoExecute                            \n    key: node.alpha.kubernetes.io/notReady       \n    operator: Exists                             \n    tolerationSeconds: 300                       \n  - effect: NoExecute                              \n    key: node.alpha.kubernetes.io/unreachable      \n    operator: Exists                               \n    tolerationSeconds: 300                         \nThese two tolerations say that this pod tolerates a node being notReady or unreach-\nable for 300 seconds. The Kubernetes Control Plane, when it detects that a node is no\nlonger ready or no longer reachable, will wait for 300 seconds before it deletes the\npod and reschedules it to another node.\n These two tolerations are automatically added to pods that don\u2019t define them. If\nthat five-minute delay is too long for your pods, you can make the delay shorter by\nadding those two tolerations to the pod\u2019s spec.\nNOTE\nThis is currently an alpha feature, so it may change in future versions\nof Kubernetes. Taint-based evictions also aren\u2019t enabled by default. You enable\nthem by running the Controller Manager with the --feature-gates=Taint-\nBasedEvictions=true option.\n16.2\nUsing node affinity to attract pods to certain nodes\nAs you\u2019ve learned, taints are used to keep pods away from certain nodes. Now you\u2019ll\nlearn about a newer mechanism called node affinity, which allows you to tell Kuberne-\ntes to schedule pods only to specific subsets of nodes.\nCOMPARING NODE AFFINITY TO NODE SELECTORS\nThe initial node affinity mechanism in early versions of Kubernetes was the node-\nSelector field in the pod specification. The node had to include all the labels speci-\nfied in that field to be eligible to become the target for the pod. \n Node selectors get the job done and are simple, but they don\u2019t offer everything\nthat you may need. Because of that, a more powerful mechanism was introduced.\nListing 16.6\nPod with default tolerations\nThe pod tolerates the node being \nnotReady for 300 seconds, before \nit needs to be rescheduled.\nThe same applies to the \nnode being unreachable.\n \n", "shape": "dot", "size": 10, "title": "462\nCHAPTER 16\nAdvanced scheduling\nwhen several of your nodes provide special hardware and only part of your pods need\nto use it.\nCONFIGURING HOW LONG AFTER A NODE FAILURE A POD IS RESCHEDULED\nYou can also use a toleration to specify how long Kubernetes should wait before\nrescheduling a pod to another node if the node the pod is running on becomes\nunready or unreachable. If you look at the tolerations of one of your pods, you\u2019ll see\ntwo tolerations, which are shown in the following listing.\n$ kubectl get po prod-350605-1ph5h -o yaml\n...\n  tolerations:\n  - effect: NoExecute                            \n    key: node.alpha.kubernetes.io/notReady       \n    operator: Exists                             \n    tolerationSeconds: 300                       \n  - effect: NoExecute                              \n    key: node.alpha.kubernetes.io/unreachable      \n    operator: Exists                               \n    tolerationSeconds: 300                         \nThese two tolerations say that this pod tolerates a node being notReady or unreach-\nable for 300 seconds. The Kubernetes Control Plane, when it detects that a node is no\nlonger ready or no longer reachable, will wait for 300 seconds before it deletes the\npod and reschedules it to another node.\n These two tolerations are automatically added to pods that don\u2019t define them. If\nthat five-minute delay is too long for your pods, you can make the delay shorter by\nadding those two tolerations to the pod\u2019s spec.\nNOTE\nThis is currently an alpha feature, so it may change in future versions\nof Kubernetes. Taint-based evictions also aren\u2019t enabled by default. You enable\nthem by running the Controller Manager with the --feature-gates=Taint-\nBasedEvictions=true option.\n16.2\nUsing node affinity to attract pods to certain nodes\nAs you\u2019ve learned, taints are used to keep pods away from certain nodes. Now you\u2019ll\nlearn about a newer mechanism called node affinity, which allows you to tell Kuberne-\ntes to schedule pods only to specific subsets of nodes.\nCOMPARING NODE AFFINITY TO NODE SELECTORS\nThe initial node affinity mechanism in early versions of Kubernetes was the node-\nSelector field in the pod specification. The node had to include all the labels speci-\nfied in that field to be eligible to become the target for the pod. \n Node selectors get the job done and are simple, but they don\u2019t offer everything\nthat you may need. Because of that, a more powerful mechanism was introduced.\nListing 16.6\nPod with default tolerations\nThe pod tolerates the node being \nnotReady for 300 seconds, before \nit needs to be rescheduled.\nThe same applies to the \nnode being unreachable.\n \n"}, {"color": "green", "id": "text_406", "label": "463\nUsing node affinity to attract pods to certain nodes\nNode selectors will eventually be deprecated, so it\u2019s important you understand the\nnew node affinity rules.\n Similar to node selectors, each pod can define its own node affinity rules. These\nallow you to specify either hard requirements or preferences. By specifying a prefer-\nence, you tell Kubernetes which nodes you prefer for a specific pod, and Kubernetes\nwill try to schedule the pod to one of those nodes. If that\u2019s not possible, it will choose\none of the other nodes. \nEXAMINING THE DEFAULT NODE LABELS\nNode affinity selects nodes based on their labels, the same way node selectors do.\nBefore you see how to use node affinity, let\u2019s examine the labels of one of the nodes in\na Google Kubernetes Engine cluster (GKE) to see what the default node labels are.\nThey\u2019re shown in the following listing.\n$ kubectl describe node gke-kubia-default-pool-db274c5a-mjnf\nName:     gke-kubia-default-pool-db274c5a-mjnf\nRole:\nLabels:   beta.kubernetes.io/arch=amd64\n          beta.kubernetes.io/fluentd-ds-ready=true\n          beta.kubernetes.io/instance-type=f1-micro\n          beta.kubernetes.io/os=linux\n          cloud.google.com/gke-nodepool=default-pool\n          failure-domain.beta.kubernetes.io/region=europe-west1         \n          failure-domain.beta.kubernetes.io/zone=europe-west1-d         \n          kubernetes.io/hostname=gke-kubia-default-pool-db274c5a-mjnf   \nThe node has many labels, but the last three are the most important when it comes to\nnode affinity and pod affinity, which you\u2019ll learn about later. The meaning of those\nthree labels is as follows:\n\uf0a1\nfailure-domain.beta.kubernetes.io/region specifies the geographical region\nthe node is located in.\n\uf0a1\nfailure-domain.beta.kubernetes.io/zone specifies the availability zone the\nnode is in.\n\uf0a1\nkubernetes.io/hostname is obviously the node\u2019s hostname.\nThese and other labels can be used in pod affinity rules. In chapter 3, you already\nlearned how you can add a custom label to nodes and use it in a pod\u2019s node selector.\nYou used the custom label to deploy pods only to nodes with that label by adding a node\nselector to the pods. Now, you\u2019ll see how to do the same using node affinity rules.\n16.2.1 Specifying hard node affinity rules\nIn the example in chapter 3, you used the node selector to deploy a pod that requires\na GPU only to nodes that have a GPU. The pod spec included the nodeSelector field\nshown in the following listing.\nListing 16.7\nDefault labels of a node in GKE\nThese three\nlabels are the\nmost important\nones related to\nnode affinity.\n \n", "shape": "dot", "size": 10, "title": "463\nUsing node affinity to attract pods to certain nodes\nNode selectors will eventually be deprecated, so it\u2019s important you understand the\nnew node affinity rules.\n Similar to node selectors, each pod can define its own node affinity rules. These\nallow you to specify either hard requirements or preferences. By specifying a prefer-\nence, you tell Kubernetes which nodes you prefer for a specific pod, and Kubernetes\nwill try to schedule the pod to one of those nodes. If that\u2019s not possible, it will choose\none of the other nodes. \nEXAMINING THE DEFAULT NODE LABELS\nNode affinity selects nodes based on their labels, the same way node selectors do.\nBefore you see how to use node affinity, let\u2019s examine the labels of one of the nodes in\na Google Kubernetes Engine cluster (GKE) to see what the default node labels are.\nThey\u2019re shown in the following listing.\n$ kubectl describe node gke-kubia-default-pool-db274c5a-mjnf\nName:     gke-kubia-default-pool-db274c5a-mjnf\nRole:\nLabels:   beta.kubernetes.io/arch=amd64\n          beta.kubernetes.io/fluentd-ds-ready=true\n          beta.kubernetes.io/instance-type=f1-micro\n          beta.kubernetes.io/os=linux\n          cloud.google.com/gke-nodepool=default-pool\n          failure-domain.beta.kubernetes.io/region=europe-west1         \n          failure-domain.beta.kubernetes.io/zone=europe-west1-d         \n          kubernetes.io/hostname=gke-kubia-default-pool-db274c5a-mjnf   \nThe node has many labels, but the last three are the most important when it comes to\nnode affinity and pod affinity, which you\u2019ll learn about later. The meaning of those\nthree labels is as follows:\n\uf0a1\nfailure-domain.beta.kubernetes.io/region specifies the geographical region\nthe node is located in.\n\uf0a1\nfailure-domain.beta.kubernetes.io/zone specifies the availability zone the\nnode is in.\n\uf0a1\nkubernetes.io/hostname is obviously the node\u2019s hostname.\nThese and other labels can be used in pod affinity rules. In chapter 3, you already\nlearned how you can add a custom label to nodes and use it in a pod\u2019s node selector.\nYou used the custom label to deploy pods only to nodes with that label by adding a node\nselector to the pods. Now, you\u2019ll see how to do the same using node affinity rules.\n16.2.1 Specifying hard node affinity rules\nIn the example in chapter 3, you used the node selector to deploy a pod that requires\na GPU only to nodes that have a GPU. The pod spec included the nodeSelector field\nshown in the following listing.\nListing 16.7\nDefault labels of a node in GKE\nThese three\nlabels are the\nmost important\nones related to\nnode affinity.\n \n"}, {"color": "green", "id": "text_407", "label": "464\nCHAPTER 16\nAdvanced scheduling\napiVersion: v1\nkind: Pod\nmetadata:\n  name: kubia-gpu\nspec:\n  nodeSelector:          \n    gpu: \"true\"          \n  ...\nThe nodeSelector field specifies that the pod should only be deployed on nodes that\ninclude the gpu=true label. If you replace the node selector with a node affinity rule,\nthe pod definition will look like the following listing.\napiVersion: v1\nkind: Pod\nmetadata:\n  name: kubia-gpu\nspec:\n  affinity:\n    nodeAffinity:\n      requiredDuringSchedulingIgnoredDuringExecution:\n        nodeSelectorTerms:\n        - matchExpressions:\n          - key: gpu\n            operator: In\n            values:\n            - \"true\"\nThe first thing you\u2019ll notice is that this is much more complicated than a simple node\nselector. But that\u2019s because it\u2019s much more expressive. Let\u2019s examine the rule in detail. \nMAKING SENSE OF THE LONG NODEAFFINITY ATTRIBUTE NAME\nAs you can see, the pod\u2019s spec section contains an affinity field that contains a node-\nAffinity field, which contains a field with an extremely long name, so let\u2019s focus on\nthat first.\n Let\u2019s break it down into two parts and examine what they mean:\n\uf0a1\nrequiredDuringScheduling... means the rules defined under this field spec-\nify the labels the node must have for the pod to be scheduled to the node.\n\uf0a1\n...IgnoredDuringExecution means the rules defined under the field don\u2019t\naffect pods already executing on the node. \nAt this point, let me make things easier for you by letting you know that affinity cur-\nrently only affects pod scheduling and never causes a pod to be evicted from a node.\nThat\u2019s why all the rules right now always end with IgnoredDuringExecution. Eventu-\nally, Kubernetes will also support RequiredDuringExecution, which means that if you\nListing 16.8\nA pod using a node selector: kubia-gpu-nodeselector.yaml\nListing 16.9\nA pod using a nodeAffinity rule: kubia-gpu-nodeaffinity.yaml\nThis pod is only scheduled \nto nodes that have the \ngpu=true label.\n \n", "shape": "dot", "size": 10, "title": "464\nCHAPTER 16\nAdvanced scheduling\napiVersion: v1\nkind: Pod\nmetadata:\n  name: kubia-gpu\nspec:\n  nodeSelector:          \n    gpu: \"true\"          \n  ...\nThe nodeSelector field specifies that the pod should only be deployed on nodes that\ninclude the gpu=true label. If you replace the node selector with a node affinity rule,\nthe pod definition will look like the following listing.\napiVersion: v1\nkind: Pod\nmetadata:\n  name: kubia-gpu\nspec:\n  affinity:\n    nodeAffinity:\n      requiredDuringSchedulingIgnoredDuringExecution:\n        nodeSelectorTerms:\n        - matchExpressions:\n          - key: gpu\n            operator: In\n            values:\n            - \"true\"\nThe first thing you\u2019ll notice is that this is much more complicated than a simple node\nselector. But that\u2019s because it\u2019s much more expressive. Let\u2019s examine the rule in detail. \nMAKING SENSE OF THE LONG NODEAFFINITY ATTRIBUTE NAME\nAs you can see, the pod\u2019s spec section contains an affinity field that contains a node-\nAffinity field, which contains a field with an extremely long name, so let\u2019s focus on\nthat first.\n Let\u2019s break it down into two parts and examine what they mean:\n\uf0a1\nrequiredDuringScheduling... means the rules defined under this field spec-\nify the labels the node must have for the pod to be scheduled to the node.\n\uf0a1\n...IgnoredDuringExecution means the rules defined under the field don\u2019t\naffect pods already executing on the node. \nAt this point, let me make things easier for you by letting you know that affinity cur-\nrently only affects pod scheduling and never causes a pod to be evicted from a node.\nThat\u2019s why all the rules right now always end with IgnoredDuringExecution. Eventu-\nally, Kubernetes will also support RequiredDuringExecution, which means that if you\nListing 16.8\nA pod using a node selector: kubia-gpu-nodeselector.yaml\nListing 16.9\nA pod using a nodeAffinity rule: kubia-gpu-nodeaffinity.yaml\nThis pod is only scheduled \nto nodes that have the \ngpu=true label.\n \n"}, {"color": "green", "id": "text_408", "label": "465\nUsing node affinity to attract pods to certain nodes\nremove a label from a node, pods that require the node to have that label will be\nevicted from such a node. As I\u2019ve said, that\u2019s not yet supported in Kubernetes, so let\u2019s\nnot concern ourselves with the second part of that long field any longer.\nUNDERSTANDING NODESELECTORTERMS\nBy keeping what was explained in the previous section in mind, it\u2019s easy to understand\nthat the nodeSelectorTerms field and the matchExpressions field define which\nexpressions the node\u2019s labels must match for the pod to be scheduled to the node.\nThe single expression in the example is simple to understand. The node must have a\ngpu label whose value is set to true. \n This pod will therefore only be scheduled to nodes that have the gpu=true label, as\nshown in figure 16.2.\nNow comes the more interesting part. Node also affinity allows you to prioritize nodes\nduring scheduling. We\u2019ll look at that next.\n16.2.2 Prioritizing nodes when scheduling a pod\nThe biggest benefit of the newly introduced node affinity feature is the ability to spec-\nify which nodes the Scheduler should prefer when scheduling a specific pod. This is\ndone through the preferredDuringSchedulingIgnoredDuringExecution field.\n Imagine having multiple datacenters across different countries. Each datacenter\nrepresents a separate availability zone. In each zone, you have certain machines meant\nonly for your own use and others that your partner companies can use. You now want\nto deploy a few pods and you\u2019d prefer them to be scheduled to zone1 and to the\nNode with a GPU\nPod\nNode af\ufb01nity\nRequired label:\ngpu=true\nPod\nNo node af\ufb01nity\ngpu: true\nNode with a GPU\nNode without a GPU\nNode without a GPU\ngpu: true\nThis pod may be scheduled only\nto nodes with gpu=true label\nThis pod may be\nscheduled to any node\nFigure 16.2\nA pod\u2019s node affinity specifies which labels a node must have for the pod to be \nscheduled to it.\n \n", "shape": "dot", "size": 10, "title": "465\nUsing node affinity to attract pods to certain nodes\nremove a label from a node, pods that require the node to have that label will be\nevicted from such a node. As I\u2019ve said, that\u2019s not yet supported in Kubernetes, so let\u2019s\nnot concern ourselves with the second part of that long field any longer.\nUNDERSTANDING NODESELECTORTERMS\nBy keeping what was explained in the previous section in mind, it\u2019s easy to understand\nthat the nodeSelectorTerms field and the matchExpressions field define which\nexpressions the node\u2019s labels must match for the pod to be scheduled to the node.\nThe single expression in the example is simple to understand. The node must have a\ngpu label whose value is set to true. \n This pod will therefore only be scheduled to nodes that have the gpu=true label, as\nshown in figure 16.2.\nNow comes the more interesting part. Node also affinity allows you to prioritize nodes\nduring scheduling. We\u2019ll look at that next.\n16.2.2 Prioritizing nodes when scheduling a pod\nThe biggest benefit of the newly introduced node affinity feature is the ability to spec-\nify which nodes the Scheduler should prefer when scheduling a specific pod. This is\ndone through the preferredDuringSchedulingIgnoredDuringExecution field.\n Imagine having multiple datacenters across different countries. Each datacenter\nrepresents a separate availability zone. In each zone, you have certain machines meant\nonly for your own use and others that your partner companies can use. You now want\nto deploy a few pods and you\u2019d prefer them to be scheduled to zone1 and to the\nNode with a GPU\nPod\nNode af\ufb01nity\nRequired label:\ngpu=true\nPod\nNo node af\ufb01nity\ngpu: true\nNode with a GPU\nNode without a GPU\nNode without a GPU\ngpu: true\nThis pod may be scheduled only\nto nodes with gpu=true label\nThis pod may be\nscheduled to any node\nFigure 16.2\nA pod\u2019s node affinity specifies which labels a node must have for the pod to be \nscheduled to it.\n \n"}, {"color": "green", "id": "text_409", "label": "466\nCHAPTER 16\nAdvanced scheduling\nmachines reserved for your company\u2019s deployments. If those machines don\u2019t have\nenough room for the pods or if other important reasons exist that prevent them from\nbeing scheduled there, you\u2019re okay with them being scheduled to the machines your\npartners use and to the other zones. Node affinity allows you to do that.\nLABELING NODES\nFirst, the nodes need to be labeled appropriately. Each node needs to have a label that\ndesignates the availability zone the node belongs to and a label marking it as either a\ndedicated or a shared node.\n Appendix B explains how to set up a three-node cluster (one master and two\nworker nodes) in VMs running locally. In the following examples, I\u2019ll use the two worker\nnodes in that cluster, but you can also use Google Kubernetes Engine or any other\nmulti-node cluster. \nNOTE\nMinikube isn\u2019t the best choice for running these examples, because it\nruns only one node.\nFirst, label the nodes, as shown in the next listing.\n$ kubectl label node node1.k8s availability-zone=zone1\nnode \"node1.k8s\" labeled\n$ kubectl label node node1.k8s share-type=dedicated\nnode \"node1.k8s\" labeled\n$ kubectl label node node2.k8s availability-zone=zone2\nnode \"node2.k8s\" labeled\n$ kubectl label node node2.k8s share-type=shared\nnode \"node2.k8s\" labeled\n$ kubectl get node -L availability-zone -L share-type\nNAME         STATUS    AGE       VERSION   AVAILABILITY-ZONE   SHARE-TYPE\nmaster.k8s   Ready     4d        v1.6.4    \u003cnone\u003e              \u003cnone\u003e\nnode1.k8s    Ready     4d        v1.6.4    zone1               dedicated\nnode2.k8s    Ready     4d        v1.6.4    zone2               shared\nSPECIFYING PREFERENTIAL NODE AFFINITY RULES\nWith the node labels set up, you can now create a Deployment that prefers dedicated\nnodes in zone1. The following listing shows the Deployment manifest.\napiVersion: extensions/v1beta1\nkind: Deployment\nmetadata:\n  name: pref\nspec:\n  template:\n    ...\n    spec:\n      affinity:\n        nodeAffinity:\nListing 16.10\nLabeling nodes\nListing 16.11\nDeployment with preferred node affinity: preferred-deployment.yaml\n \n", "shape": "dot", "size": 10, "title": "466\nCHAPTER 16\nAdvanced scheduling\nmachines reserved for your company\u2019s deployments. If those machines don\u2019t have\nenough room for the pods or if other important reasons exist that prevent them from\nbeing scheduled there, you\u2019re okay with them being scheduled to the machines your\npartners use and to the other zones. Node affinity allows you to do that.\nLABELING NODES\nFirst, the nodes need to be labeled appropriately. Each node needs to have a label that\ndesignates the availability zone the node belongs to and a label marking it as either a\ndedicated or a shared node.\n Appendix B explains how to set up a three-node cluster (one master and two\nworker nodes) in VMs running locally. In the following examples, I\u2019ll use the two worker\nnodes in that cluster, but you can also use Google Kubernetes Engine or any other\nmulti-node cluster. \nNOTE\nMinikube isn\u2019t the best choice for running these examples, because it\nruns only one node.\nFirst, label the nodes, as shown in the next listing.\n$ kubectl label node node1.k8s availability-zone=zone1\nnode \"node1.k8s\" labeled\n$ kubectl label node node1.k8s share-type=dedicated\nnode \"node1.k8s\" labeled\n$ kubectl label node node2.k8s availability-zone=zone2\nnode \"node2.k8s\" labeled\n$ kubectl label node node2.k8s share-type=shared\nnode \"node2.k8s\" labeled\n$ kubectl get node -L availability-zone -L share-type\nNAME         STATUS    AGE       VERSION   AVAILABILITY-ZONE   SHARE-TYPE\nmaster.k8s   Ready     4d        v1.6.4    \u003cnone\u003e              \u003cnone\u003e\nnode1.k8s    Ready     4d        v1.6.4    zone1               dedicated\nnode2.k8s    Ready     4d        v1.6.4    zone2               shared\nSPECIFYING PREFERENTIAL NODE AFFINITY RULES\nWith the node labels set up, you can now create a Deployment that prefers dedicated\nnodes in zone1. The following listing shows the Deployment manifest.\napiVersion: extensions/v1beta1\nkind: Deployment\nmetadata:\n  name: pref\nspec:\n  template:\n    ...\n    spec:\n      affinity:\n        nodeAffinity:\nListing 16.10\nLabeling nodes\nListing 16.11\nDeployment with preferred node affinity: preferred-deployment.yaml\n \n"}, {"color": "green", "id": "text_410", "label": "467\nUsing node affinity to attract pods to certain nodes\n          preferredDuringSchedulingIgnoredDuringExecution:    \n          - weight: 80                               \n            preference:                              \n              matchExpressions:                      \n              - key: availability-zone               \n                operator: In                         \n                values:                              \n                - zone1                              \n          - weight: 20                     \n            preference:                    \n              matchExpressions:            \n              - key: share-type            \n                operator: In               \n                values:                    \n                - dedicated                \n      ...\nLet\u2019s examine the listing closely. You\u2019re defining a node affinity preference, instead of\na hard requirement. You want the pods scheduled to nodes that include the labels\navailability-zone=zone1 and share-type=dedicated. You\u2019re saying that the first\npreference rule is important by setting its weight to 80, whereas the second one is\nmuch less important (weight is set to 20).\nUNDERSTANDING HOW NODE PREFERENCES WORK\nIf your cluster had many nodes, when scheduling the pods of the Deployment in the\nprevious listing, the nodes would be split into four groups, as shown in figure 16.3.\nNodes whose availability-zone and share-type labels match the pod\u2019s node affin-\nity are ranked the highest. Then, because of how the weights in the pod\u2019s node affinity\nrules are configured, next come the shared nodes in zone1, then come the dedicated\nnodes in the other zones, and at the lowest priority are all the other nodes.\nYou\u2019re\nspecifying\npreferences,\nnot hard\nrequirements.\nYou prefer the pod to be \nscheduled to zone1. This \nis your most important \npreference.\nYou also prefer that your \npods be scheduled to \ndedicated nodes, but this is \nfour times less important \nthan your zone preference.\nNode\nTop priority\nAvailability zone 1\nPod\nPriority: 2\nPriority: 3\nPriority: 4\nNode af\ufb01nity\nPreferred labels:\navail-zone: zone1 (weight 80)\nshare: dedicated (weight 20)\navail-zone: zone1\nshare: dedicated\nNode\navail-zone: zone1\nshare: shared\nNode\nAvailability zone 2\navail-zone: zone2\nshare: dedicated\nNode\navail-zone: zone2\nshare: shared\nThis pod may be scheduled to\nany node, but certain nodes are\npreferred based on their labels.\nFigure 16.3\nPrioritizing nodes based on a pod\u2019s node affinity preferences\n \n", "shape": "dot", "size": 10, "title": "467\nUsing node affinity to attract pods to certain nodes\n          preferredDuringSchedulingIgnoredDuringExecution:    \n          - weight: 80                               \n            preference:                              \n              matchExpressions:                      \n              - key: availability-zone               \n                operator: In                         \n                values:                              \n                - zone1                              \n          - weight: 20                     \n            preference:                    \n              matchExpressions:            \n              - key: share-type            \n                operator: In               \n                values:                    \n                - dedicated                \n      ...\nLet\u2019s examine the listing closely. You\u2019re defining a node affinity preference, instead of\na hard requirement. You want the pods scheduled to nodes that include the labels\navailability-zone=zone1 and share-type=dedicated. You\u2019re saying that the first\npreference rule is important by setting its weight to 80, whereas the second one is\nmuch less important (weight is set to 20).\nUNDERSTANDING HOW NODE PREFERENCES WORK\nIf your cluster had many nodes, when scheduling the pods of the Deployment in the\nprevious listing, the nodes would be split into four groups, as shown in figure 16.3.\nNodes whose availability-zone and share-type labels match the pod\u2019s node affin-\nity are ranked the highest. Then, because of how the weights in the pod\u2019s node affinity\nrules are configured, next come the shared nodes in zone1, then come the dedicated\nnodes in the other zones, and at the lowest priority are all the other nodes.\nYou\u2019re\nspecifying\npreferences,\nnot hard\nrequirements.\nYou prefer the pod to be \nscheduled to zone1. This \nis your most important \npreference.\nYou also prefer that your \npods be scheduled to \ndedicated nodes, but this is \nfour times less important \nthan your zone preference.\nNode\nTop priority\nAvailability zone 1\nPod\nPriority: 2\nPriority: 3\nPriority: 4\nNode af\ufb01nity\nPreferred labels:\navail-zone: zone1 (weight 80)\nshare: dedicated (weight 20)\navail-zone: zone1\nshare: dedicated\nNode\navail-zone: zone1\nshare: shared\nNode\nAvailability zone 2\navail-zone: zone2\nshare: dedicated\nNode\navail-zone: zone2\nshare: shared\nThis pod may be scheduled to\nany node, but certain nodes are\npreferred based on their labels.\nFigure 16.3\nPrioritizing nodes based on a pod\u2019s node affinity preferences\n \n"}, {"color": "green", "id": "text_411", "label": "468\nCHAPTER 16\nAdvanced scheduling\nDEPLOYING THE PODS IN THE TWO-NODE CLUSTER\nIf you create this Deployment in your two-node cluster, you should see most (if not\nall) of your pods deployed to node1. Examine the following listing to see if that\u2019s true.\n$ kubectl get po -o wide\nNAME                READY   STATUS    RESTARTS  AGE   IP          NODE\npref-607515-1rnwv   1/1     Running   0         4m    10.47.0.1   node2.k8s\npref-607515-27wp0   1/1     Running   0         4m    10.44.0.8   node1.k8s\npref-607515-5xd0z   1/1     Running   0         4m    10.44.0.5   node1.k8s\npref-607515-jx9wt   1/1     Running   0         4m    10.44.0.4   node1.k8s\npref-607515-mlgqm   1/1     Running   0         4m    10.44.0.6   node1.k8s\nOut of the five pods that were created, four of them landed on node1 and only one\nlanded on node2. Why did one of them land on node2 instead of node1? The reason is\nthat besides the node affinity prioritization function, the Scheduler also uses other pri-\noritization functions to decide where to schedule a pod. One of those is the Selector-\nSpreadPriority function, which makes sure pods belonging to the same ReplicaSet or\nService are spread around different nodes so a node failure won\u2019t bring the whole ser-\nvice down. That\u2019s most likely what caused one of the pods to be scheduled to node2.\n You can try scaling the Deployment up to 20 or more and you\u2019ll see the majority of\npods will be scheduled to node1. In my test, only two out of the 20 were scheduled to\nnode2. If you hadn\u2019t defined any node affinity preferences, the pods would have been\nspread around the two nodes evenly.\n16.3\nCo-locating pods with pod affinity and anti-affinity\nYou\u2019ve seen how node affinity rules are used to influence which node a pod is scheduled\nto. But these rules only affect the affinity between a pod and a node, whereas sometimes\nyou\u2019d like to have the ability to specify the affinity between pods themselves. \n For example, imagine having a frontend and a backend pod. Having those pods\ndeployed near to each other reduces latency and improves the performance of the\napp. You could use node affinity rules to ensure both are deployed to the same node,\nrack, or datacenter, but then you\u2019d have to specify exactly which node, rack, or data-\ncenter to schedule them to, which is not the best solution. It\u2019s better to let Kubernetes\ndeploy your pods anywhere it sees fit, while keeping the frontend and backend pods\nclose together. This can be achieved using pod affinity. Let\u2019s learn more about it with\nan example.\n16.3.1 Using inter-pod affinity to deploy pods on the same node\nYou\u2019ll deploy a backend pod and five frontend pod replicas with pod affinity config-\nured so that they\u2019re all deployed on the same node as the backend pod.\n First, deploy the backend pod:\n$ kubectl run backend -l app=backend --image busybox -- sleep 999999\ndeployment \"backend\" created\nListing 16.12\nSeeing where pods were scheduled\n \n", "shape": "dot", "size": 10, "title": "468\nCHAPTER 16\nAdvanced scheduling\nDEPLOYING THE PODS IN THE TWO-NODE CLUSTER\nIf you create this Deployment in your two-node cluster, you should see most (if not\nall) of your pods deployed to node1. Examine the following listing to see if that\u2019s true.\n$ kubectl get po -o wide\nNAME                READY   STATUS    RESTARTS  AGE   IP          NODE\npref-607515-1rnwv   1/1     Running   0         4m    10.47.0.1   node2.k8s\npref-607515-27wp0   1/1     Running   0         4m    10.44.0.8   node1.k8s\npref-607515-5xd0z   1/1     Running   0         4m    10.44.0.5   node1.k8s\npref-607515-jx9wt   1/1     Running   0         4m    10.44.0.4   node1.k8s\npref-607515-mlgqm   1/1     Running   0         4m    10.44.0.6   node1.k8s\nOut of the five pods that were created, four of them landed on node1 and only one\nlanded on node2. Why did one of them land on node2 instead of node1? The reason is\nthat besides the node affinity prioritization function, the Scheduler also uses other pri-\noritization functions to decide where to schedule a pod. One of those is the Selector-\nSpreadPriority function, which makes sure pods belonging to the same ReplicaSet or\nService are spread around different nodes so a node failure won\u2019t bring the whole ser-\nvice down. That\u2019s most likely what caused one of the pods to be scheduled to node2.\n You can try scaling the Deployment up to 20 or more and you\u2019ll see the majority of\npods will be scheduled to node1. In my test, only two out of the 20 were scheduled to\nnode2. If you hadn\u2019t defined any node affinity preferences, the pods would have been\nspread around the two nodes evenly.\n16.3\nCo-locating pods with pod affinity and anti-affinity\nYou\u2019ve seen how node affinity rules are used to influence which node a pod is scheduled\nto. But these rules only affect the affinity between a pod and a node, whereas sometimes\nyou\u2019d like to have the ability to specify the affinity between pods themselves. \n For example, imagine having a frontend and a backend pod. Having those pods\ndeployed near to each other reduces latency and improves the performance of the\napp. You could use node affinity rules to ensure both are deployed to the same node,\nrack, or datacenter, but then you\u2019d have to specify exactly which node, rack, or data-\ncenter to schedule them to, which is not the best solution. It\u2019s better to let Kubernetes\ndeploy your pods anywhere it sees fit, while keeping the frontend and backend pods\nclose together. This can be achieved using pod affinity. Let\u2019s learn more about it with\nan example.\n16.3.1 Using inter-pod affinity to deploy pods on the same node\nYou\u2019ll deploy a backend pod and five frontend pod replicas with pod affinity config-\nured so that they\u2019re all deployed on the same node as the backend pod.\n First, deploy the backend pod:\n$ kubectl run backend -l app=backend --image busybox -- sleep 999999\ndeployment \"backend\" created\nListing 16.12\nSeeing where pods were scheduled\n \n"}, {"color": "green", "id": "text_412", "label": "469\nCo-locating pods with pod affinity and anti-affinity\nThis Deployment is not special in any way. The only thing you need to note is the\napp=backend label you added to the pod using the -l option. This label is what you\u2019ll\nuse in the frontend pod\u2019s podAffinity configuration. \nSPECIFYING POD AFFINITY IN A POD DEFINITION\nThe frontend pod\u2019s definition is shown in the following listing.\napiVersion: extensions/v1beta1\nkind: Deployment\nmetadata:\n  name: frontend\nspec:\n  replicas: 5\n  template:\n    ...\n    spec:\n      affinity:\n        podAffinity:                                 \n          requiredDuringSchedulingIgnoredDuringExecution:   \n          - topologyKey: kubernetes.io/hostname           \n            labelSelector:                                \n              matchLabels:                                \n                app: backend                              \n      ...\nThe listing shows that this Deployment will create pods that have a hard requirement\nto be deployed on the same node (specified by the topologyKey field) as pods that\nhave the app=backend label (see figure 16.4).\nListing 16.13\nPod using podAffinity: frontend-podaffinity-host.yaml\nDefining \npodAffinity rules\nDefining a hard \nrequirement, not \na preference\nThe pods of this Deployment \nmust be deployed on the \nsame node as the pods that \nmatch the selector.\nAll frontend pods will\nbe scheduled only to\nthe node the backend\npod was scheduled to.\nSome node\nOther nodes\nFrontend pods\nBackend\npod\nPod af\ufb01nity\nLabel selector: app=backend\nTopology key: hostname\napp: backend\nFigure 16.4\nPod affinity allows scheduling pods to the node where other pods \nwith a specific label are.\n \n", "shape": "dot", "size": 10, "title": "469\nCo-locating pods with pod affinity and anti-affinity\nThis Deployment is not special in any way. The only thing you need to note is the\napp=backend label you added to the pod using the -l option. This label is what you\u2019ll\nuse in the frontend pod\u2019s podAffinity configuration. \nSPECIFYING POD AFFINITY IN A POD DEFINITION\nThe frontend pod\u2019s definition is shown in the following listing.\napiVersion: extensions/v1beta1\nkind: Deployment\nmetadata:\n  name: frontend\nspec:\n  replicas: 5\n  template:\n    ...\n    spec:\n      affinity:\n        podAffinity:                                 \n          requiredDuringSchedulingIgnoredDuringExecution:   \n          - topologyKey: kubernetes.io/hostname           \n            labelSelector:                                \n              matchLabels:                                \n                app: backend                              \n      ...\nThe listing shows that this Deployment will create pods that have a hard requirement\nto be deployed on the same node (specified by the topologyKey field) as pods that\nhave the app=backend label (see figure 16.4).\nListing 16.13\nPod using podAffinity: frontend-podaffinity-host.yaml\nDefining \npodAffinity rules\nDefining a hard \nrequirement, not \na preference\nThe pods of this Deployment \nmust be deployed on the \nsame node as the pods that \nmatch the selector.\nAll frontend pods will\nbe scheduled only to\nthe node the backend\npod was scheduled to.\nSome node\nOther nodes\nFrontend pods\nBackend\npod\nPod af\ufb01nity\nLabel selector: app=backend\nTopology key: hostname\napp: backend\nFigure 16.4\nPod affinity allows scheduling pods to the node where other pods \nwith a specific label are.\n \n"}, {"color": "green", "id": "text_413", "label": "470\nCHAPTER 16\nAdvanced scheduling\nNOTE\nInstead of the simpler matchLabels field, you could also use the more\nexpressive matchExpressions field.\nDEPLOYING A POD WITH POD AFFINITY\nBefore you create this Deployment, let\u2019s see which node the backend pod was sched-\nuled to earlier:\n$ kubectl get po -o wide\nNAME                   READY  STATUS   RESTARTS  AGE  IP         NODE\nbackend-257820-qhqj6   1/1    Running  0         8m   10.47.0.1  node2.k8s\nWhen you create the frontend pods, they should be deployed to node2 as well. You\u2019re\ngoing to create the Deployment and see where the pods are deployed. This is shown\nin the next listing.\n$ kubectl create -f frontend-podaffinity-host.yaml\ndeployment \"frontend\" created\n$ kubectl get po -o wide\nNAME                   READY  STATUS    RESTARTS  AGE  IP         NODE\nbackend-257820-qhqj6   1/1    Running   0         8m   10.47.0.1  node2.k8s\nfrontend-121895-2c1ts  1/1    Running   0         13s  10.47.0.6  node2.k8s\nfrontend-121895-776m7  1/1    Running   0         13s  10.47.0.4  node2.k8s\nfrontend-121895-7ffsm  1/1    Running   0         13s  10.47.0.8  node2.k8s\nfrontend-121895-fpgm6  1/1    Running   0         13s  10.47.0.7  node2.k8s\nfrontend-121895-vb9ll  1/1    Running   0         13s  10.47.0.5  node2.k8s\nAll the frontend pods were indeed scheduled to the same node as the backend pod.\nWhen scheduling the frontend pod, the Scheduler first found all the pods that match\nthe labelSelector defined in the frontend pod\u2019s podAffinity configuration and\nthen scheduled the frontend pod to the same node.\nUNDERSTANDING HOW THE SCHEDULER USES POD AFFINITY RULES\nWhat\u2019s interesting is that if you now delete the backend pod, the Scheduler will sched-\nule the pod to node2 even though it doesn\u2019t define any pod affinity rules itself (the\nrules are only on the frontend pods). This makes sense, because otherwise if the back-\nend pod were to be deleted by accident and rescheduled to a different node, the fron-\ntend pods\u2019 affinity rules would be broken. \n You can confirm the Scheduler takes other pods\u2019 pod affinity rules into account, if\nyou increase the Scheduler\u2019s logging level and then check its log. The following listing\nshows the relevant log lines.\n... Attempting to schedule pod: default/backend-257820-qhqj6\n... ...\n... backend-qhqj6 -\u003e node2.k8s: Taint Toleration Priority, Score: (10)\nListing 16.14\nDeploying frontend pods and seeing which node they\u2019re scheduled to\nListing 16.15\nScheduler log showing why the backend pod is scheduled to node2\n \n", "shape": "dot", "size": 10, "title": "470\nCHAPTER 16\nAdvanced scheduling\nNOTE\nInstead of the simpler matchLabels field, you could also use the more\nexpressive matchExpressions field.\nDEPLOYING A POD WITH POD AFFINITY\nBefore you create this Deployment, let\u2019s see which node the backend pod was sched-\nuled to earlier:\n$ kubectl get po -o wide\nNAME                   READY  STATUS   RESTARTS  AGE  IP         NODE\nbackend-257820-qhqj6   1/1    Running  0         8m   10.47.0.1  node2.k8s\nWhen you create the frontend pods, they should be deployed to node2 as well. You\u2019re\ngoing to create the Deployment and see where the pods are deployed. This is shown\nin the next listing.\n$ kubectl create -f frontend-podaffinity-host.yaml\ndeployment \"frontend\" created\n$ kubectl get po -o wide\nNAME                   READY  STATUS    RESTARTS  AGE  IP         NODE\nbackend-257820-qhqj6   1/1    Running   0         8m   10.47.0.1  node2.k8s\nfrontend-121895-2c1ts  1/1    Running   0         13s  10.47.0.6  node2.k8s\nfrontend-121895-776m7  1/1    Running   0         13s  10.47.0.4  node2.k8s\nfrontend-121895-7ffsm  1/1    Running   0         13s  10.47.0.8  node2.k8s\nfrontend-121895-fpgm6  1/1    Running   0         13s  10.47.0.7  node2.k8s\nfrontend-121895-vb9ll  1/1    Running   0         13s  10.47.0.5  node2.k8s\nAll the frontend pods were indeed scheduled to the same node as the backend pod.\nWhen scheduling the frontend pod, the Scheduler first found all the pods that match\nthe labelSelector defined in the frontend pod\u2019s podAffinity configuration and\nthen scheduled the frontend pod to the same node.\nUNDERSTANDING HOW THE SCHEDULER USES POD AFFINITY RULES\nWhat\u2019s interesting is that if you now delete the backend pod, the Scheduler will sched-\nule the pod to node2 even though it doesn\u2019t define any pod affinity rules itself (the\nrules are only on the frontend pods). This makes sense, because otherwise if the back-\nend pod were to be deleted by accident and rescheduled to a different node, the fron-\ntend pods\u2019 affinity rules would be broken. \n You can confirm the Scheduler takes other pods\u2019 pod affinity rules into account, if\nyou increase the Scheduler\u2019s logging level and then check its log. The following listing\nshows the relevant log lines.\n... Attempting to schedule pod: default/backend-257820-qhqj6\n... ...\n... backend-qhqj6 -\u003e node2.k8s: Taint Toleration Priority, Score: (10)\nListing 16.14\nDeploying frontend pods and seeing which node they\u2019re scheduled to\nListing 16.15\nScheduler log showing why the backend pod is scheduled to node2\n \n"}, {"color": "green", "id": "text_414", "label": "471\nCo-locating pods with pod affinity and anti-affinity\n... backend-qhqj6 -\u003e node1.k8s: Taint Toleration Priority, Score: (10)\n... backend-qhqj6 -\u003e node2.k8s: InterPodAffinityPriority, Score: (10)\n... backend-qhqj6 -\u003e node1.k8s: InterPodAffinityPriority, Score: (0)\n... backend-qhqj6 -\u003e node2.k8s: SelectorSpreadPriority, Score: (10)\n... backend-qhqj6 -\u003e node1.k8s: SelectorSpreadPriority, Score: (10)\n... backend-qhqj6 -\u003e node2.k8s: NodeAffinityPriority, Score: (0)\n... backend-qhqj6 -\u003e node1.k8s: NodeAffinityPriority, Score: (0)\n... Host node2.k8s =\u003e Score 100030\n... Host node1.k8s =\u003e Score 100022\n... Attempting to bind backend-257820-qhqj6 to node2.k8s\nIf you focus on the two lines in bold, you\u2019ll see that during the scheduling of the back-\nend pod, node2 received a higher score than node1 because of inter-pod affinity. \n16.3.2 Deploying pods in the same rack, availability zone, or \ngeographic region\nIn the previous example, you used podAffinity to deploy frontend pods onto the\nsame node as the backend pods. You probably don\u2019t want all your frontend pods to\nrun on the same machine, but you\u2019d still like to keep them close to the backend\npod\u2014for example, run them in the same availability zone. \nCO-LOCATING PODS IN THE SAME AVAILABILITY ZONE\nThe cluster I\u2019m using runs in three VMs on my local machine, so all the nodes are in\nthe same availability zone, so to speak. But if the nodes were in different zones, all I\u2019d\nneed to do to run the frontend pods in the same zone as the backend pod would be to\nchange the topologyKey property to failure-domain.beta.kubernetes.io/zone. \nCO-LOCATING PODS IN THE SAME GEOGRAPHICAL REGION\nTo allow the pods to be deployed in the same region instead of the same zone (cloud\nproviders usually have datacenters located in different geographical regions and split\ninto multiple availability zones in each region), the topologyKey would be set to\nfailure-domain.beta.kubernetes.io/region.\nUNDERSTANDING HOW TOPOLOGYKEY WORKS\nThe way topologyKey works is simple. The three keys we\u2019ve mentioned so far aren\u2019t\nspecial. If you want, you can easily use your own topologyKey, such as rack, to have\nthe pods scheduled to the same server rack. The only prerequisite is to add a rack\nlabel to your nodes. This scenario is shown in figure 16.5.\n For example, if you had 20 nodes, with 10 in each rack, you\u2019d label the first ten as\nrack=rack1 and the others as rack=rack2. Then, when defining a pod\u2019s podAffinity,\nyou\u2019d set the toplogyKey to rack. \n When the Scheduler is deciding where to deploy a pod, it checks the pod\u2019s pod-\nAffinity config, finds the pods that match the label selector, and looks up the nodes\nthey\u2019re running on. Specifically, it looks up the nodes\u2019 label whose key matches the\ntopologyKey field specified in podAffinity. Then it selects all the nodes whose label\n \n", "shape": "dot", "size": 10, "title": "471\nCo-locating pods with pod affinity and anti-affinity\n... backend-qhqj6 -\u003e node1.k8s: Taint Toleration Priority, Score: (10)\n... backend-qhqj6 -\u003e node2.k8s: InterPodAffinityPriority, Score: (10)\n... backend-qhqj6 -\u003e node1.k8s: InterPodAffinityPriority, Score: (0)\n... backend-qhqj6 -\u003e node2.k8s: SelectorSpreadPriority, Score: (10)\n... backend-qhqj6 -\u003e node1.k8s: SelectorSpreadPriority, Score: (10)\n... backend-qhqj6 -\u003e node2.k8s: NodeAffinityPriority, Score: (0)\n... backend-qhqj6 -\u003e node1.k8s: NodeAffinityPriority, Score: (0)\n... Host node2.k8s =\u003e Score 100030\n... Host node1.k8s =\u003e Score 100022\n... Attempting to bind backend-257820-qhqj6 to node2.k8s\nIf you focus on the two lines in bold, you\u2019ll see that during the scheduling of the back-\nend pod, node2 received a higher score than node1 because of inter-pod affinity. \n16.3.2 Deploying pods in the same rack, availability zone, or \ngeographic region\nIn the previous example, you used podAffinity to deploy frontend pods onto the\nsame node as the backend pods. You probably don\u2019t want all your frontend pods to\nrun on the same machine, but you\u2019d still like to keep them close to the backend\npod\u2014for example, run them in the same availability zone. \nCO-LOCATING PODS IN THE SAME AVAILABILITY ZONE\nThe cluster I\u2019m using runs in three VMs on my local machine, so all the nodes are in\nthe same availability zone, so to speak. But if the nodes were in different zones, all I\u2019d\nneed to do to run the frontend pods in the same zone as the backend pod would be to\nchange the topologyKey property to failure-domain.beta.kubernetes.io/zone. \nCO-LOCATING PODS IN THE SAME GEOGRAPHICAL REGION\nTo allow the pods to be deployed in the same region instead of the same zone (cloud\nproviders usually have datacenters located in different geographical regions and split\ninto multiple availability zones in each region), the topologyKey would be set to\nfailure-domain.beta.kubernetes.io/region.\nUNDERSTANDING HOW TOPOLOGYKEY WORKS\nThe way topologyKey works is simple. The three keys we\u2019ve mentioned so far aren\u2019t\nspecial. If you want, you can easily use your own topologyKey, such as rack, to have\nthe pods scheduled to the same server rack. The only prerequisite is to add a rack\nlabel to your nodes. This scenario is shown in figure 16.5.\n For example, if you had 20 nodes, with 10 in each rack, you\u2019d label the first ten as\nrack=rack1 and the others as rack=rack2. Then, when defining a pod\u2019s podAffinity,\nyou\u2019d set the toplogyKey to rack. \n When the Scheduler is deciding where to deploy a pod, it checks the pod\u2019s pod-\nAffinity config, finds the pods that match the label selector, and looks up the nodes\nthey\u2019re running on. Specifically, it looks up the nodes\u2019 label whose key matches the\ntopologyKey field specified in podAffinity. Then it selects all the nodes whose label\n \n"}, {"color": "green", "id": "text_415", "label": "472\nCHAPTER 16\nAdvanced scheduling\nmatches the values of the pods it found earlier. In figure 16.5, the label selector\nmatched the backend pod, which runs on Node 12. The value of the rack label on\nthat node equals rack2, so when scheduling a frontend pod, the Scheduler will only\nselect among the nodes that have the rack=rack2 label.\nNOTE\nBy default, the label selector only matches pods in the same name-\nspace as the pod that\u2019s being scheduled. But you can also select pods from\nother namespaces by adding a namespaces field at the same level as label-\nSelector.\n16.3.3 Expressing pod affinity preferences instead of hard requirements\nEarlier, when we talked about node affinity, you saw that nodeAffinity can be used to\nexpress a hard requirement, which means a pod is only scheduled to nodes that match\nthe node affinity rules. It can also be used to specify node preferences, to instruct the\nScheduler to schedule the pod to certain nodes, while allowing it to schedule it any-\nwhere else if those nodes can\u2019t fit the pod for any reason.\n The same also applies to podAffinity. You can tell the Scheduler you\u2019d prefer to\nhave your frontend pods scheduled onto the same node as your backend pod, but if\nthat\u2019s not possible, you\u2019re okay with them being scheduled elsewhere. An example of\na Deployment using the preferredDuringSchedulingIgnoredDuringExecution pod\naffinity rule is shown in the next listing.\nFrontend pods will be\nscheduled to nodes in\nthe same rack as the\nbackend pod.\nNode 1\nRack 1\nrack: rack1\nNode 2\nrack: rack1\nNode 3\n...\nrack: rack1\nNode 10\nrack: rack1\nNode 11\nRack 2\nrack: rack2\nNode 12\nrack: rack2\n...\nNode 20\nrack: rack2\nBackend\npod\napp: backend\nFrontend pods\nPod af\ufb01nity (required)\nLabel selector: app=backend\nTopology key: rack\nFigure 16.5\nThe topologyKey in podAffinity determines the scope of where the pod \nshould be scheduled to.\n \n", "shape": "dot", "size": 10, "title": "472\nCHAPTER 16\nAdvanced scheduling\nmatches the values of the pods it found earlier. In figure 16.5, the label selector\nmatched the backend pod, which runs on Node 12. The value of the rack label on\nthat node equals rack2, so when scheduling a frontend pod, the Scheduler will only\nselect among the nodes that have the rack=rack2 label.\nNOTE\nBy default, the label selector only matches pods in the same name-\nspace as the pod that\u2019s being scheduled. But you can also select pods from\nother namespaces by adding a namespaces field at the same level as label-\nSelector.\n16.3.3 Expressing pod affinity preferences instead of hard requirements\nEarlier, when we talked about node affinity, you saw that nodeAffinity can be used to\nexpress a hard requirement, which means a pod is only scheduled to nodes that match\nthe node affinity rules. It can also be used to specify node preferences, to instruct the\nScheduler to schedule the pod to certain nodes, while allowing it to schedule it any-\nwhere else if those nodes can\u2019t fit the pod for any reason.\n The same also applies to podAffinity. You can tell the Scheduler you\u2019d prefer to\nhave your frontend pods scheduled onto the same node as your backend pod, but if\nthat\u2019s not possible, you\u2019re okay with them being scheduled elsewhere. An example of\na Deployment using the preferredDuringSchedulingIgnoredDuringExecution pod\naffinity rule is shown in the next listing.\nFrontend pods will be\nscheduled to nodes in\nthe same rack as the\nbackend pod.\nNode 1\nRack 1\nrack: rack1\nNode 2\nrack: rack1\nNode 3\n...\nrack: rack1\nNode 10\nrack: rack1\nNode 11\nRack 2\nrack: rack2\nNode 12\nrack: rack2\n...\nNode 20\nrack: rack2\nBackend\npod\napp: backend\nFrontend pods\nPod af\ufb01nity (required)\nLabel selector: app=backend\nTopology key: rack\nFigure 16.5\nThe topologyKey in podAffinity determines the scope of where the pod \nshould be scheduled to.\n \n"}, {"color": "green", "id": "text_416", "label": "473\nCo-locating pods with pod affinity and anti-affinity\napiVersion: extensions/v1beta1\nkind: Deployment\nmetadata:\n  name: frontend\nspec:\n  replicas: 5\n  template:\n    ...\n    spec:\n      affinity:\n        podAffinity:\n          preferredDuringSchedulingIgnoredDuringExecution:  \n          - weight: 80                                        \n            podAffinityTerm:                                  \n              topologyKey: kubernetes.io/hostname             \n              labelSelector:                                  \n                matchLabels:                                  \n                  app: backend                                \n      containers: ...\nAs in nodeAffinity preference rules, you need to define a weight for each rule. You\nalso need to specify the topologyKey and labelSelector, as in the hard-requirement\npodAffinity rules. Figure 16.6 shows this scenario.\nDeploying this pod, as with your nodeAffinity example, deploys four pods on the same\nnode as the backend pod, and one pod on the other node (see the following listing).\nListing 16.16\nPod affinity preference\nPreferred \ninstead of \nRequired\nA weight and a \npodAffinity term is \nspecified as in the \nprevious example\nThe Scheduler will prefer\nNode 2 for frontend pods,\nbut may schedule pods\nto Node 1 as well.\nNode 1\nNode 2\nBackend\npod\napp: backend\nFrontend pod\nPod af\ufb01nity (preferred)\nLabel selector: app=backend\nTopology key: hostname\nhostname: node2\nhostname: node1\nFigure 16.6\nPod affinity can be used to make the Scheduler prefer nodes where \npods with a certain label are running. \n \n", "shape": "dot", "size": 10, "title": "473\nCo-locating pods with pod affinity and anti-affinity\napiVersion: extensions/v1beta1\nkind: Deployment\nmetadata:\n  name: frontend\nspec:\n  replicas: 5\n  template:\n    ...\n    spec:\n      affinity:\n        podAffinity:\n          preferredDuringSchedulingIgnoredDuringExecution:  \n          - weight: 80                                        \n            podAffinityTerm:                                  \n              topologyKey: kubernetes.io/hostname             \n              labelSelector:                                  \n                matchLabels:                                  \n                  app: backend                                \n      containers: ...\nAs in nodeAffinity preference rules, you need to define a weight for each rule. You\nalso need to specify the topologyKey and labelSelector, as in the hard-requirement\npodAffinity rules. Figure 16.6 shows this scenario.\nDeploying this pod, as with your nodeAffinity example, deploys four pods on the same\nnode as the backend pod, and one pod on the other node (see the following listing).\nListing 16.16\nPod affinity preference\nPreferred \ninstead of \nRequired\nA weight and a \npodAffinity term is \nspecified as in the \nprevious example\nThe Scheduler will prefer\nNode 2 for frontend pods,\nbut may schedule pods\nto Node 1 as well.\nNode 1\nNode 2\nBackend\npod\napp: backend\nFrontend pod\nPod af\ufb01nity (preferred)\nLabel selector: app=backend\nTopology key: hostname\nhostname: node2\nhostname: node1\nFigure 16.6\nPod affinity can be used to make the Scheduler prefer nodes where \npods with a certain label are running. \n \n"}, {"color": "green", "id": "text_417", "label": "474\nCHAPTER 16\nAdvanced scheduling\n$ kubectl get po -o wide\nNAME                   READY  STATUS   RESTARTS  AGE  IP          NODE\nbackend-257820-ssrgj   1/1    Running  0         1h   10.47.0.9   node2.k8s\nfrontend-941083-3mff9  1/1    Running  0         8m   10.44.0.4   node1.k8s\nfrontend-941083-7fp7d  1/1    Running  0         8m   10.47.0.6   node2.k8s\nfrontend-941083-cq23b  1/1    Running  0         8m   10.47.0.1   node2.k8s\nfrontend-941083-m70sw  1/1    Running  0         8m   10.47.0.5   node2.k8s\nfrontend-941083-wsjv8  1/1    Running  0         8m   10.47.0.4   node2.k8s\n16.3.4 Scheduling pods away from each other with pod anti-affinity\nYou\u2019ve seen how to tell the Scheduler to co-locate pods, but sometimes you may want\nthe exact opposite. You may want to keep pods away from each other. This is called\npod anti-affinity. It\u2019s specified the same way as pod affinity, except that you use the\npodAntiAffinity property instead of podAffinity, which results in the Scheduler\nnever choosing nodes where pods matching the podAntiAffinity\u2019s label selector are\nrunning, as shown in figure 16.7.\nAn example of why you\u2019d want to use pod anti-affinity is when two sets of pods inter-\nfere with each other\u2019s performance if they run on the same node. In that case, you\nwant to tell the Scheduler to never schedule those pods on the same node. Another\nexample would be to force the Scheduler to spread pods of the same group across dif-\nferent availability zones or regions, so that a failure of a whole zone (or region) never\nbrings the service down completely. \nListing 16.17\nPods deployed with podAffinity preferences\nThese pods will NOT be scheduled\nto the same node(s) where pods\nwith app=foo label are running.\nSome node\nOther nodes\nPods\nPod: foo\nPod\n(required)\nanti-af\ufb01nity\nLabel selector: app=foo\nTopology key: hostname\napp: foo\nFigure 16.7\nUsing pod anti-affinity to keep pods away from nodes that run pods \nwith a certain label.\n \n", "shape": "dot", "size": 10, "title": "474\nCHAPTER 16\nAdvanced scheduling\n$ kubectl get po -o wide\nNAME                   READY  STATUS   RESTARTS  AGE  IP          NODE\nbackend-257820-ssrgj   1/1    Running  0         1h   10.47.0.9   node2.k8s\nfrontend-941083-3mff9  1/1    Running  0         8m   10.44.0.4   node1.k8s\nfrontend-941083-7fp7d  1/1    Running  0         8m   10.47.0.6   node2.k8s\nfrontend-941083-cq23b  1/1    Running  0         8m   10.47.0.1   node2.k8s\nfrontend-941083-m70sw  1/1    Running  0         8m   10.47.0.5   node2.k8s\nfrontend-941083-wsjv8  1/1    Running  0         8m   10.47.0.4   node2.k8s\n16.3.4 Scheduling pods away from each other with pod anti-affinity\nYou\u2019ve seen how to tell the Scheduler to co-locate pods, but sometimes you may want\nthe exact opposite. You may want to keep pods away from each other. This is called\npod anti-affinity. It\u2019s specified the same way as pod affinity, except that you use the\npodAntiAffinity property instead of podAffinity, which results in the Scheduler\nnever choosing nodes where pods matching the podAntiAffinity\u2019s label selector are\nrunning, as shown in figure 16.7.\nAn example of why you\u2019d want to use pod anti-affinity is when two sets of pods inter-\nfere with each other\u2019s performance if they run on the same node. In that case, you\nwant to tell the Scheduler to never schedule those pods on the same node. Another\nexample would be to force the Scheduler to spread pods of the same group across dif-\nferent availability zones or regions, so that a failure of a whole zone (or region) never\nbrings the service down completely. \nListing 16.17\nPods deployed with podAffinity preferences\nThese pods will NOT be scheduled\nto the same node(s) where pods\nwith app=foo label are running.\nSome node\nOther nodes\nPods\nPod: foo\nPod\n(required)\nanti-af\ufb01nity\nLabel selector: app=foo\nTopology key: hostname\napp: foo\nFigure 16.7\nUsing pod anti-affinity to keep pods away from nodes that run pods \nwith a certain label.\n \n"}, {"color": "green", "id": "text_418", "label": "475\nCo-locating pods with pod affinity and anti-affinity\nUSING ANTI-AFFINITY TO SPREAD APART PODS OF THE SAME DEPLOYMENT\nLet\u2019s see how to force your frontend pods to be scheduled to different nodes. The fol-\nlowing listing shows how the pods\u2019 anti-affinity is configured.\napiVersion: extensions/v1beta1\nkind: Deployment\nmetadata:\n  name: frontend\nspec:\n  replicas: 5\n  template:\n    metadata:\n      labels:                  \n        app: frontend          \n    spec:\n      affinity:\n        podAntiAffinity:                                      \n          requiredDuringSchedulingIgnoredDuringExecution:     \n          - topologyKey: kubernetes.io/hostname            \n            labelSelector:                                 \n              matchLabels:                                 \n                app: frontend                              \n      containers: ...\nThis time, you\u2019re defining podAntiAffinity instead of podAffinity, and you\u2019re mak-\ning the labelSelector match the same pods that the Deployment creates. Let\u2019s see\nwhat happens when you create this Deployment. The pods created by it are shown in\nthe following listing.\n$ kubectl get po -l app=frontend -o wide\nNAME                    READY  STATUS   RESTARTS  AGE  IP         NODE\nfrontend-286632-0lffz   0/1    Pending  0         1m   \u003cnone\u003e\nfrontend-286632-2rkcz   1/1    Running  0         1m   10.47.0.1  node2.k8s\nfrontend-286632-4nwhp   0/1    Pending  0         1m   \u003cnone\u003e\nfrontend-286632-h4686   0/1    Pending  0         1m   \u003cnone\u003e\nfrontend-286632-st222   1/1    Running  0         1m   10.44.0.4  node1.k8s\nAs you can see, only two pods were scheduled\u2014one to node1, the other to node2. The\nthree remaining pods are all Pending, because the Scheduler isn\u2019t allowed to schedule\nthem to the same nodes.\nUSING PREFERENTIAL POD ANTI-AFFINITY\nIn this case, you probably should have specified a soft requirement instead (using the\npreferredDuringSchedulingIgnoredDuringExecution property). After all, it\u2019s not\nsuch a big problem if two frontend pods run on the same node. But in scenarios where\nthat\u2019s a problem, using requiredDuringScheduling is appropriate. \nListing 16.18\nPods with anti-affinity: frontend-podantiaffinity-host.yaml\nListing 16.19\nPods created by the Deployment\nThe frontend pods have \nthe app=frontend label.\nDefining hard-\nrequirements for \npod anti-affinity\nA frontend pod must not \nbe scheduled to the same \nmachine as a pod with \napp=frontend label.\n \n", "shape": "dot", "size": 10, "title": "475\nCo-locating pods with pod affinity and anti-affinity\nUSING ANTI-AFFINITY TO SPREAD APART PODS OF THE SAME DEPLOYMENT\nLet\u2019s see how to force your frontend pods to be scheduled to different nodes. The fol-\nlowing listing shows how the pods\u2019 anti-affinity is configured.\napiVersion: extensions/v1beta1\nkind: Deployment\nmetadata:\n  name: frontend\nspec:\n  replicas: 5\n  template:\n    metadata:\n      labels:                  \n        app: frontend          \n    spec:\n      affinity:\n        podAntiAffinity:                                      \n          requiredDuringSchedulingIgnoredDuringExecution:     \n          - topologyKey: kubernetes.io/hostname            \n            labelSelector:                                 \n              matchLabels:                                 \n                app: frontend                              \n      containers: ...\nThis time, you\u2019re defining podAntiAffinity instead of podAffinity, and you\u2019re mak-\ning the labelSelector match the same pods that the Deployment creates. Let\u2019s see\nwhat happens when you create this Deployment. The pods created by it are shown in\nthe following listing.\n$ kubectl get po -l app=frontend -o wide\nNAME                    READY  STATUS   RESTARTS  AGE  IP         NODE\nfrontend-286632-0lffz   0/1    Pending  0         1m   \u003cnone\u003e\nfrontend-286632-2rkcz   1/1    Running  0         1m   10.47.0.1  node2.k8s\nfrontend-286632-4nwhp   0/1    Pending  0         1m   \u003cnone\u003e\nfrontend-286632-h4686   0/1    Pending  0         1m   \u003cnone\u003e\nfrontend-286632-st222   1/1    Running  0         1m   10.44.0.4  node1.k8s\nAs you can see, only two pods were scheduled\u2014one to node1, the other to node2. The\nthree remaining pods are all Pending, because the Scheduler isn\u2019t allowed to schedule\nthem to the same nodes.\nUSING PREFERENTIAL POD ANTI-AFFINITY\nIn this case, you probably should have specified a soft requirement instead (using the\npreferredDuringSchedulingIgnoredDuringExecution property). After all, it\u2019s not\nsuch a big problem if two frontend pods run on the same node. But in scenarios where\nthat\u2019s a problem, using requiredDuringScheduling is appropriate. \nListing 16.18\nPods with anti-affinity: frontend-podantiaffinity-host.yaml\nListing 16.19\nPods created by the Deployment\nThe frontend pods have \nthe app=frontend label.\nDefining hard-\nrequirements for \npod anti-affinity\nA frontend pod must not \nbe scheduled to the same \nmachine as a pod with \napp=frontend label.\n \n"}, {"color": "green", "id": "text_419", "label": "476\nCHAPTER 16\nAdvanced scheduling\n As with pod affinity, the topologyKey property determines the scope of where the\npod shouldn\u2019t be deployed to. You can use it to ensure pods aren\u2019t deployed to the\nsame rack, availability zone, region, or any custom scope you create using custom\nnode labels.\n16.4\nSummary\nIn this chapter, we looked at how to ensure pods aren\u2019t scheduled to certain nodes or\nare only scheduled to specific nodes, either because of the node\u2019s labels or because of\nthe pods running on them.\n You learned that\n\uf0a1If you add a taint to a node, pods won\u2019t be scheduled to that node unless they\ntolerate that taint.\n\uf0a1Three types of taints exist: NoSchedule completely prevents scheduling, Prefer-\nNoSchedule isn\u2019t as strict, and NoExecute even evicts existing pods from a node.\n\uf0a1The NoExecute taint is also used to specify how long the Control Plane should\nwait before rescheduling the pod when the node it runs on becomes unreach-\nable or unready.\n\uf0a1Node affinity allows you to specify which nodes a pod should be scheduled to. It\ncan be used to specify a hard requirement or to only express a node preference.\n\uf0a1Pod affinity is used to make the Scheduler deploy pods to the same node where\nanother pod is running (based on the pod\u2019s labels). \n\uf0a1Pod affinity\u2019s topologyKey specifies how close the pod should be deployed to\nthe other pod (onto the same node or onto a node in the same rack, availability\nzone, or availability region).\n\uf0a1Pod anti-affinity can be used to keep certain pods away from each other. \n\uf0a1Both pod affinity and anti-affinity, like node affinity, can either specify hard\nrequirements or preferences.\nIn the next chapter, you\u2019ll learn about best practices for developing apps and how to\nmake them run smoothly in a Kubernetes environment.\n \n", "shape": "dot", "size": 10, "title": "476\nCHAPTER 16\nAdvanced scheduling\n As with pod affinity, the topologyKey property determines the scope of where the\npod shouldn\u2019t be deployed to. You can use it to ensure pods aren\u2019t deployed to the\nsame rack, availability zone, region, or any custom scope you create using custom\nnode labels.\n16.4\nSummary\nIn this chapter, we looked at how to ensure pods aren\u2019t scheduled to certain nodes or\nare only scheduled to specific nodes, either because of the node\u2019s labels or because of\nthe pods running on them.\n You learned that\n\uf0a1If you add a taint to a node, pods won\u2019t be scheduled to that node unless they\ntolerate that taint.\n\uf0a1Three types of taints exist: NoSchedule completely prevents scheduling, Prefer-\nNoSchedule isn\u2019t as strict, and NoExecute even evicts existing pods from a node.\n\uf0a1The NoExecute taint is also used to specify how long the Control Plane should\nwait before rescheduling the pod when the node it runs on becomes unreach-\nable or unready.\n\uf0a1Node affinity allows you to specify which nodes a pod should be scheduled to. It\ncan be used to specify a hard requirement or to only express a node preference.\n\uf0a1Pod affinity is used to make the Scheduler deploy pods to the same node where\nanother pod is running (based on the pod\u2019s labels). \n\uf0a1Pod affinity\u2019s topologyKey specifies how close the pod should be deployed to\nthe other pod (onto the same node or onto a node in the same rack, availability\nzone, or availability region).\n\uf0a1Pod anti-affinity can be used to keep certain pods away from each other. \n\uf0a1Both pod affinity and anti-affinity, like node affinity, can either specify hard\nrequirements or preferences.\nIn the next chapter, you\u2019ll learn about best practices for developing apps and how to\nmake them run smoothly in a Kubernetes environment.\n \n"}, {"color": "green", "id": "text_420", "label": "477\nBest practices\nfor developing apps\nWe\u2019ve now covered most of what you need to know to run your apps in Kubernetes.\nWe\u2019ve explored what each individual resource does and how it\u2019s used. Now we\u2019ll see\nhow to combine them in a typical application running on Kubernetes. We\u2019ll also\nlook at how to make an application run smoothly. After all, that\u2019s the whole point\nof using Kubernetes, isn\u2019t it? \n Hopefully, this chapter will help to clear up any misunderstandings and explain\nthings that weren\u2019t explained clearly yet. Along the way, we\u2019ll also introduce a few\nadditional concepts that haven\u2019t been mentioned up to this point.\nThis chapter covers\n\uf0a1Understanding which Kubernetes resources \nappear in a typical application\n\uf0a1Adding post-start and pre-stop pod lifecycle hooks\n\uf0a1Properly terminating an app without breaking \nclient requests\n\uf0a1Making apps easy to manage in Kubernetes\n\uf0a1Using init containers in a pod\n\uf0a1Developing locally with Minikube\n \n", "shape": "dot", "size": 10, "title": "477\nBest practices\nfor developing apps\nWe\u2019ve now covered most of what you need to know to run your apps in Kubernetes.\nWe\u2019ve explored what each individual resource does and how it\u2019s used. Now we\u2019ll see\nhow to combine them in a typical application running on Kubernetes. We\u2019ll also\nlook at how to make an application run smoothly. After all, that\u2019s the whole point\nof using Kubernetes, isn\u2019t it? \n Hopefully, this chapter will help to clear up any misunderstandings and explain\nthings that weren\u2019t explained clearly yet. Along the way, we\u2019ll also introduce a few\nadditional concepts that haven\u2019t been mentioned up to this point.\nThis chapter covers\n\uf0a1Understanding which Kubernetes resources \nappear in a typical application\n\uf0a1Adding post-start and pre-stop pod lifecycle hooks\n\uf0a1Properly terminating an app without breaking \nclient requests\n\uf0a1Making apps easy to manage in Kubernetes\n\uf0a1Using init containers in a pod\n\uf0a1Developing locally with Minikube\n \n"}, {"color": "green", "id": "text_421", "label": "478\nCHAPTER 17\nBest practices for developing apps\n17.1\nBringing everything together\nLet\u2019s start by looking at what an actual application consists of. This will also give you a\nchance to see if you remember everything you\u2019ve learned so far and look at the big\npicture. Figure 17.1 shows the Kubernetes components used in a typical application.\nA typical application manifest contains one or more Deployment and/or StatefulSet\nobjects. Those include a pod template containing one or more containers, with a live-\nness probe for each of them and a readiness probe for the service(s) the container\nprovides (if any). Pods that provide services to others are exposed through one or\nmore Services. When they need to be reachable from outside the cluster, the Services\nare either configured to be LoadBalancer or NodePort-type Services, or exposed\nthrough an Ingress resource. \n The pod templates (and the pods created from them) usually reference two types\nof Secrets\u2014those for pulling container images from private image registries and those\nused directly by the process running inside the pods. The Secrets themselves are\nusually not part of the application manifest, because they aren\u2019t configured by the\napplication developers but by the operations team. Secrets are usually assigned to\nServiceAccounts, which are assigned to individual pods. \nDe\ufb01ned in the app manifest by the developer\nPod template\nDeployment\nlabels\nPod(s)\nLabel selector\nlabels\nCreated automatically at runtime\nCreated by a cluster admin beforehand\nContainer(s)\nVolume(s)\nReplicaSet(s)\nEndpoints\n\u2022 Health probes\n\u2022 Environment variables\n\u2022 Volume mounts\n\u2022 Resource reqs/limits\nHorizontal\nPodAutoscaler\nStatefulSet\nDaemonSet\nJob\nCronJob\nPersistent\nVolume\nCon\ufb01gMap\nService\nPersistent\nVolume\nClaim\nSecret(s)\nService\naccount\nStorage\nClass\nLimitRange\nResourceQuota\nIngress\nimagePullSecret\nFigure 17.1\nResources in a typical application\n \n", "shape": "dot", "size": 10, "title": "478\nCHAPTER 17\nBest practices for developing apps\n17.1\nBringing everything together\nLet\u2019s start by looking at what an actual application consists of. This will also give you a\nchance to see if you remember everything you\u2019ve learned so far and look at the big\npicture. Figure 17.1 shows the Kubernetes components used in a typical application.\nA typical application manifest contains one or more Deployment and/or StatefulSet\nobjects. Those include a pod template containing one or more containers, with a live-\nness probe for each of them and a readiness probe for the service(s) the container\nprovides (if any). Pods that provide services to others are exposed through one or\nmore Services. When they need to be reachable from outside the cluster, the Services\nare either configured to be LoadBalancer or NodePort-type Services, or exposed\nthrough an Ingress resource. \n The pod templates (and the pods created from them) usually reference two types\nof Secrets\u2014those for pulling container images from private image registries and those\nused directly by the process running inside the pods. The Secrets themselves are\nusually not part of the application manifest, because they aren\u2019t configured by the\napplication developers but by the operations team. Secrets are usually assigned to\nServiceAccounts, which are assigned to individual pods. \nDe\ufb01ned in the app manifest by the developer\nPod template\nDeployment\nlabels\nPod(s)\nLabel selector\nlabels\nCreated automatically at runtime\nCreated by a cluster admin beforehand\nContainer(s)\nVolume(s)\nReplicaSet(s)\nEndpoints\n\u2022 Health probes\n\u2022 Environment variables\n\u2022 Volume mounts\n\u2022 Resource reqs/limits\nHorizontal\nPodAutoscaler\nStatefulSet\nDaemonSet\nJob\nCronJob\nPersistent\nVolume\nCon\ufb01gMap\nService\nPersistent\nVolume\nClaim\nSecret(s)\nService\naccount\nStorage\nClass\nLimitRange\nResourceQuota\nIngress\nimagePullSecret\nFigure 17.1\nResources in a typical application\n \n"}, {"color": "green", "id": "text_422", "label": "479\nUnderstanding the pod\u2019s lifecycle\n The application also contains one or more ConfigMaps, which are either used to\ninitialize environment variables or mounted as a configMap volume in the pod. Cer-\ntain pods use additional volumes, such as an emptyDir or a gitRepo volume, whereas\npods requiring persistent storage use persistentVolumeClaim volumes. The Persistent-\nVolumeClaims are also part of the application manifest, whereas StorageClasses refer-\nenced by them are created by system administrators upfront. \n In certain cases, an application also requires the use of Jobs or CronJobs. Daemon-\nSets aren\u2019t normally part of application deployments, but are usually created by sysad-\nmins to run system services on all or a subset of nodes. HorizontalPodAutoscalers\nare either included in the manifest by the developers or added to the system later by\nthe ops team. The cluster administrator also creates LimitRange and ResourceQuota\nobjects to keep compute resource usage of individual pods and all the pods (as a\nwhole) under control.\n After the application is deployed, additional objects are created automatically by\nthe various Kubernetes controllers. These include service Endpoints objects created\nby the Endpoints controller, ReplicaSets created by the Deployment controller, and\nthe actual pods created by the ReplicaSet (or Job, CronJob, StatefulSet, or DaemonSet)\ncontrollers.\n Resources are often labeled with one or more labels to keep them organized. This\ndoesn\u2019t apply only to pods but to all other resources as well. In addition to labels, most\nresources also contain annotations that describe each resource, list the contact infor-\nmation of the person or team responsible for it, or provide additional metadata for\nmanagement and other tools. \n At the center of all this is the Pod, which arguably is the most important Kuberne-\ntes resource. After all, each of your applications runs inside it. To make sure you know\nhow to develop apps that make the most out of their environment, let\u2019s take one last\nclose look at pods\u2014this time from the application\u2019s perspective. \n17.2\nUnderstanding the pod\u2019s lifecycle\nWe\u2019ve said that pods can be compared to VMs dedicated to running only a single\napplication. Although an application running inside a pod is not unlike an application\nrunning in a VM, significant differences do exist. One example is that apps running in\na pod can be killed any time, because Kubernetes needs to relocate the pod to\nanother node for a reason or because of a scale-down request. We\u2019ll explore this\naspect next.\n17.2.1 Applications must expect to be killed and relocated\nOutside Kubernetes, apps running in VMs are seldom moved from one machine to\nanother. When an operator moves the app, they can also reconfigure the app and\nmanually check that the app is running fine in the new location. With Kubernetes,\napps are relocated much more frequently and automatically\u2014no human operator\n \n", "shape": "dot", "size": 10, "title": "479\nUnderstanding the pod\u2019s lifecycle\n The application also contains one or more ConfigMaps, which are either used to\ninitialize environment variables or mounted as a configMap volume in the pod. Cer-\ntain pods use additional volumes, such as an emptyDir or a gitRepo volume, whereas\npods requiring persistent storage use persistentVolumeClaim volumes. The Persistent-\nVolumeClaims are also part of the application manifest, whereas StorageClasses refer-\nenced by them are created by system administrators upfront. \n In certain cases, an application also requires the use of Jobs or CronJobs. Daemon-\nSets aren\u2019t normally part of application deployments, but are usually created by sysad-\nmins to run system services on all or a subset of nodes. HorizontalPodAutoscalers\nare either included in the manifest by the developers or added to the system later by\nthe ops team. The cluster administrator also creates LimitRange and ResourceQuota\nobjects to keep compute resource usage of individual pods and all the pods (as a\nwhole) under control.\n After the application is deployed, additional objects are created automatically by\nthe various Kubernetes controllers. These include service Endpoints objects created\nby the Endpoints controller, ReplicaSets created by the Deployment controller, and\nthe actual pods created by the ReplicaSet (or Job, CronJob, StatefulSet, or DaemonSet)\ncontrollers.\n Resources are often labeled with one or more labels to keep them organized. This\ndoesn\u2019t apply only to pods but to all other resources as well. In addition to labels, most\nresources also contain annotations that describe each resource, list the contact infor-\nmation of the person or team responsible for it, or provide additional metadata for\nmanagement and other tools. \n At the center of all this is the Pod, which arguably is the most important Kuberne-\ntes resource. After all, each of your applications runs inside it. To make sure you know\nhow to develop apps that make the most out of their environment, let\u2019s take one last\nclose look at pods\u2014this time from the application\u2019s perspective. \n17.2\nUnderstanding the pod\u2019s lifecycle\nWe\u2019ve said that pods can be compared to VMs dedicated to running only a single\napplication. Although an application running inside a pod is not unlike an application\nrunning in a VM, significant differences do exist. One example is that apps running in\na pod can be killed any time, because Kubernetes needs to relocate the pod to\nanother node for a reason or because of a scale-down request. We\u2019ll explore this\naspect next.\n17.2.1 Applications must expect to be killed and relocated\nOutside Kubernetes, apps running in VMs are seldom moved from one machine to\nanother. When an operator moves the app, they can also reconfigure the app and\nmanually check that the app is running fine in the new location. With Kubernetes,\napps are relocated much more frequently and automatically\u2014no human operator\n \n"}, {"color": "green", "id": "text_423", "label": "480\nCHAPTER 17\nBest practices for developing apps\nreconfigures them and makes sure they still run properly after the move. This means\napplication developers need to make sure their apps allow being moved relatively\noften. \nEXPECTING THE LOCAL IP AND HOSTNAME TO CHANGE\nWhen a pod is killed and run elsewhere (technically, it\u2019s a new pod instance replac-\ning the old one; the pod isn\u2019t relocated), it not only has a new IP address but also a\nnew name and hostname. Most stateless apps can usually handle this without any\nadverse effects, but stateful apps usually can\u2019t. We\u2019ve learned that stateful apps can\nbe run through a StatefulSet, which ensures that when the app starts up on a new\nnode after being rescheduled, it will still see the same host name and persistent state\nas before. The pod\u2019s IP will change nevertheless. Apps need to be prepared for that\nto happen. The application developer therefore should never base membership in a\nclustered app on the member\u2019s IP address, and if basing it on the hostname, should\nalways use a StatefulSet.\nEXPECTING THE DATA WRITTEN TO DISK TO DISAPPEAR\nAnother thing to keep in mind is that if the app writes data to disk, that data may not be\navailable after the app is started inside a new pod, unless you mount persistent storage at\nthe location the app is writing to. It should be clear this happens when the pod is\nrescheduled, but files written to disk will disappear even in scenarios that don\u2019t involve\nany rescheduling. Even during the lifetime of a single pod, the files written to disk by\nthe app running in the pod may disappear. Let me explain this with an example.\n Imagine an app that has a long and computationally intensive initial startup proce-\ndure. To help the app come up faster on subsequent startups, the developers make\nthe app cache the results of the initial startup on disk (an example of this would be\nthe scanning of all Java classes for annotations at startup and then writing the results\nto an index file). Because apps in Kubernetes run in containers by default, these files\nare written to the container\u2019s filesystem. If the container is then restarted, they\u2019re all\nlost, because the new container starts off with a completely new writable layer (see fig-\nure 17.2).\n Don\u2019t forget that individual containers may be restarted for several reasons, such\nas because the process crashes, because the liveness probe returned a failure, or\nbecause the node started running out of memory and the process was killed by the\nOOMKiller. When this happens, the pod is still the same, but the container itself is\ncompletely new. The Kubelet doesn\u2019t run the same container again; it always creates a\nnew container. \nUSING VOLUMES TO PRESERVE DATA ACROSS CONTAINER RESTARTS\nWhen its container is restarted, the app in the example will need to perform the\nintensive startup procedure again. This may or may not be desired. To make sure data\nlike this isn\u2019t lost, you need to use at least a pod-scoped volume. Because volumes live\nand die together with the pod, the new container will be able to reuse the data written\nto the volume by the previous container (figure 17.3).\n \n", "shape": "dot", "size": 10, "title": "480\nCHAPTER 17\nBest practices for developing apps\nreconfigures them and makes sure they still run properly after the move. This means\napplication developers need to make sure their apps allow being moved relatively\noften. \nEXPECTING THE LOCAL IP AND HOSTNAME TO CHANGE\nWhen a pod is killed and run elsewhere (technically, it\u2019s a new pod instance replac-\ning the old one; the pod isn\u2019t relocated), it not only has a new IP address but also a\nnew name and hostname. Most stateless apps can usually handle this without any\nadverse effects, but stateful apps usually can\u2019t. We\u2019ve learned that stateful apps can\nbe run through a StatefulSet, which ensures that when the app starts up on a new\nnode after being rescheduled, it will still see the same host name and persistent state\nas before. The pod\u2019s IP will change nevertheless. Apps need to be prepared for that\nto happen. The application developer therefore should never base membership in a\nclustered app on the member\u2019s IP address, and if basing it on the hostname, should\nalways use a StatefulSet.\nEXPECTING THE DATA WRITTEN TO DISK TO DISAPPEAR\nAnother thing to keep in mind is that if the app writes data to disk, that data may not be\navailable after the app is started inside a new pod, unless you mount persistent storage at\nthe location the app is writing to. It should be clear this happens when the pod is\nrescheduled, but files written to disk will disappear even in scenarios that don\u2019t involve\nany rescheduling. Even during the lifetime of a single pod, the files written to disk by\nthe app running in the pod may disappear. Let me explain this with an example.\n Imagine an app that has a long and computationally intensive initial startup proce-\ndure. To help the app come up faster on subsequent startups, the developers make\nthe app cache the results of the initial startup on disk (an example of this would be\nthe scanning of all Java classes for annotations at startup and then writing the results\nto an index file). Because apps in Kubernetes run in containers by default, these files\nare written to the container\u2019s filesystem. If the container is then restarted, they\u2019re all\nlost, because the new container starts off with a completely new writable layer (see fig-\nure 17.2).\n Don\u2019t forget that individual containers may be restarted for several reasons, such\nas because the process crashes, because the liveness probe returned a failure, or\nbecause the node started running out of memory and the process was killed by the\nOOMKiller. When this happens, the pod is still the same, but the container itself is\ncompletely new. The Kubelet doesn\u2019t run the same container again; it always creates a\nnew container. \nUSING VOLUMES TO PRESERVE DATA ACROSS CONTAINER RESTARTS\nWhen its container is restarted, the app in the example will need to perform the\nintensive startup procedure again. This may or may not be desired. To make sure data\nlike this isn\u2019t lost, you need to use at least a pod-scoped volume. Because volumes live\nand die together with the pod, the new container will be able to reuse the data written\nto the volume by the previous container (figure 17.3).\n \n"}, {"color": "green", "id": "text_424", "label": "481\nUnderstanding the pod\u2019s lifecycle\nContainer\nProcess\nWrites to\nFilesystem\nWritable layer\nRead-only layer\nRead-only layer\nImage layers\nContainer crashes\nor is killed\nPod\nNew container\nNew process\nFilesystem\nNew writable layer\nRead-only layer\nRead-only layer\nImage layers\nNew container started\n(part of the same pod)\nNew container\nstarts with new\nwriteable layer:\nall \ufb01les are lost\nFigure 17.2\nFiles written to the container\u2019s filesystem are lost when the container is restarted.\nContainer\nProcess\nWrites to\nCan read\nthe same \ufb01les\nFilesystem\nvolumeMount\nContainer crashes\nor is killed\nPod\nNew container\nNew process\nFilesystem\nvolumeMount\nNew container started\n(part of the same pod)\nNew process can\nuse data preserved\nin the volume\nVolume\nFigure 17.3\nUsing a volume to persist data across container restarts\n \n", "shape": "dot", "size": 10, "title": "481\nUnderstanding the pod\u2019s lifecycle\nContainer\nProcess\nWrites to\nFilesystem\nWritable layer\nRead-only layer\nRead-only layer\nImage layers\nContainer crashes\nor is killed\nPod\nNew container\nNew process\nFilesystem\nNew writable layer\nRead-only layer\nRead-only layer\nImage layers\nNew container started\n(part of the same pod)\nNew container\nstarts with new\nwriteable layer:\nall \ufb01les are lost\nFigure 17.2\nFiles written to the container\u2019s filesystem are lost when the container is restarted.\nContainer\nProcess\nWrites to\nCan read\nthe same \ufb01les\nFilesystem\nvolumeMount\nContainer crashes\nor is killed\nPod\nNew container\nNew process\nFilesystem\nvolumeMount\nNew container started\n(part of the same pod)\nNew process can\nuse data preserved\nin the volume\nVolume\nFigure 17.3\nUsing a volume to persist data across container restarts\n \n"}, {"color": "green", "id": "text_425", "label": "482\nCHAPTER 17\nBest practices for developing apps\nUsing a volume to preserve files across container restarts is a great idea sometimes,\nbut not always. What if the data gets corrupted and causes the newly created process\nto crash again? This will result in a continuous crash loop (the pod will show the\nCrashLoopBackOff status). If you hadn\u2019t used a volume, the new container would start\nfrom scratch and most likely not crash. Using volumes to preserve files across con-\ntainer restarts like this is a double-edged sword. You need to think carefully about\nwhether to use them or not.\n17.2.2 Rescheduling of dead or partially dead pods\nIf a pod\u2019s container keeps crashing, the Kubelet will keep restarting it indefinitely.\nThe time between restarts will be increased exponentially until it reaches five minutes.\nDuring those five minute intervals, the pod is essentially dead, because its container\u2019s\nprocess isn\u2019t running. To be fair, if it\u2019s a multi-container pod, certain containers may\nbe running normally, so the pod is only partially dead. But if a pod contains only a sin-\ngle container, the pod is effectively dead and completely useless, because no process is\nrunning in it anymore.\n You may find it surprising to learn that such pods aren\u2019t automatically removed\nand rescheduled, even if they\u2019re part of a ReplicaSet or similar controller. If you cre-\nate a ReplicaSet with a desired replica count of three, and then one of the containers\nin one of those pods starts crashing, Kubernetes will not delete and replace the pod.\nThe end result is a ReplicaSet with only two properly running replicas instead of the\ndesired three (figure 17.4).\nYou\u2019d probably expect the pod to be deleted and replaced with another pod instance\nthat might run successfully on another node. After all, the container may be crashing\nbecause of a node-related problem that doesn\u2019t manifest itself on other nodes. Sadly,\nthat isn\u2019t the case. The ReplicaSet controller doesn\u2019t care if the pods are dead\u2014all it\nReplicaSet\nDesired replicas: 3\nActual replicas: 3\nOnly two pods are actually\nperforming their jobs\nThird pod\u2019s status is Running,\nbut its container keeps crashing,\nwith signi\ufb01cant delays between\nrestarts (CrashLoopBackOff)\nWe want\nthree pods\nPod\nRunning\ncontainer\nPod\nRunning\ncontainer\nPod\nDead\ncontainer\nFigure 17.4\nA ReplicaSet controller doesn\u2019t reschedule dead pods.\n \n", "shape": "dot", "size": 10, "title": "482\nCHAPTER 17\nBest practices for developing apps\nUsing a volume to preserve files across container restarts is a great idea sometimes,\nbut not always. What if the data gets corrupted and causes the newly created process\nto crash again? This will result in a continuous crash loop (the pod will show the\nCrashLoopBackOff status). If you hadn\u2019t used a volume, the new container would start\nfrom scratch and most likely not crash. Using volumes to preserve files across con-\ntainer restarts like this is a double-edged sword. You need to think carefully about\nwhether to use them or not.\n17.2.2 Rescheduling of dead or partially dead pods\nIf a pod\u2019s container keeps crashing, the Kubelet will keep restarting it indefinitely.\nThe time between restarts will be increased exponentially until it reaches five minutes.\nDuring those five minute intervals, the pod is essentially dead, because its container\u2019s\nprocess isn\u2019t running. To be fair, if it\u2019s a multi-container pod, certain containers may\nbe running normally, so the pod is only partially dead. But if a pod contains only a sin-\ngle container, the pod is effectively dead and completely useless, because no process is\nrunning in it anymore.\n You may find it surprising to learn that such pods aren\u2019t automatically removed\nand rescheduled, even if they\u2019re part of a ReplicaSet or similar controller. If you cre-\nate a ReplicaSet with a desired replica count of three, and then one of the containers\nin one of those pods starts crashing, Kubernetes will not delete and replace the pod.\nThe end result is a ReplicaSet with only two properly running replicas instead of the\ndesired three (figure 17.4).\nYou\u2019d probably expect the pod to be deleted and replaced with another pod instance\nthat might run successfully on another node. After all, the container may be crashing\nbecause of a node-related problem that doesn\u2019t manifest itself on other nodes. Sadly,\nthat isn\u2019t the case. The ReplicaSet controller doesn\u2019t care if the pods are dead\u2014all it\nReplicaSet\nDesired replicas: 3\nActual replicas: 3\nOnly two pods are actually\nperforming their jobs\nThird pod\u2019s status is Running,\nbut its container keeps crashing,\nwith signi\ufb01cant delays between\nrestarts (CrashLoopBackOff)\nWe want\nthree pods\nPod\nRunning\ncontainer\nPod\nRunning\ncontainer\nPod\nDead\ncontainer\nFigure 17.4\nA ReplicaSet controller doesn\u2019t reschedule dead pods.\n \n"}, {"color": "green", "id": "text_426", "label": "483\nUnderstanding the pod\u2019s lifecycle\ncares about is that the number of pods matches the desired replica count, which in\nthis case, it does.\n If you\u2019d like to see for yourself, I\u2019ve included a YAML manifest for a ReplicaSet\nwhose pods will keep crashing (see file replicaset-crashingpods.yaml in the code\narchive). If you create the ReplicaSet and inspect the pods that are created, the follow-\ning listing is what you\u2019ll see.\n$ kubectl get po\nNAME                  READY     STATUS             RESTARTS   AGE\ncrashing-pods-f1tcd   0/1       CrashLoopBackOff   5          6m     \ncrashing-pods-k7l6k   0/1       CrashLoopBackOff   5          6m\ncrashing-pods-z7l3v   0/1       CrashLoopBackOff   5          6m\n$ kubectl describe rs crashing-pods\nName:           crashing-pods\nReplicas:       3 current / 3 desired                       \nPods Status:    3 Running / 0 Waiting / 0 Succeeded / 0 Failed      \n$ kubectl describe po crashing-pods-f1tcd\nName:           crashing-pods-f1tcd\nNamespace:      default\nNode:           minikube/192.168.99.102\nStart Time:     Thu, 02 Mar 2017 14:02:23 +0100\nLabels:         app=crashing-pods\nStatus:         Running                      \nIn a way, it\u2019s understandable that Kubernetes behaves this way. The container will be\nrestarted every five minutes in the hope that the underlying cause of the crash will be\nresolved. The rationale is that rescheduling the pod to another node most likely\nwouldn\u2019t fix the problem anyway, because the app is running inside a container and\nall the nodes should be mostly equivalent. That\u2019s not always the case, but it is most of\nthe time. \n17.2.3 Starting pods in a specific order\nOne other difference between apps running in pods and those managed manually is\nthat the ops person deploying those apps knows about the dependencies between\nthem. This allows them to start the apps in order. \nUNDERSTANDING HOW PODS ARE STARTED\nWhen you use Kubernetes to run your multi-pod applications, you don\u2019t have a built-\nin way to tell Kubernetes to run certain pods first and the rest only when the first pods\nare already up and ready to serve. Sure, you could post the manifest for the first app\nand then wait for the pod(s) to be ready before you post the second manifest, but your\nListing 17.1\nReplicaSet and pods that keep crashing\nThe pod\u2019s status shows the Kubelet is\ndelaying the restart because the\ncontainer keeps crashing.\nNo action taken \nby the controller, \nbecause current \nreplicas match \ndesired replicas\nThree \nreplicas are \nshown as \nrunning.\nkubectl describe \nalso shows pod\u2019s \nstatus as running\n \n", "shape": "dot", "size": 10, "title": "483\nUnderstanding the pod\u2019s lifecycle\ncares about is that the number of pods matches the desired replica count, which in\nthis case, it does.\n If you\u2019d like to see for yourself, I\u2019ve included a YAML manifest for a ReplicaSet\nwhose pods will keep crashing (see file replicaset-crashingpods.yaml in the code\narchive). If you create the ReplicaSet and inspect the pods that are created, the follow-\ning listing is what you\u2019ll see.\n$ kubectl get po\nNAME                  READY     STATUS             RESTARTS   AGE\ncrashing-pods-f1tcd   0/1       CrashLoopBackOff   5          6m     \ncrashing-pods-k7l6k   0/1       CrashLoopBackOff   5          6m\ncrashing-pods-z7l3v   0/1       CrashLoopBackOff   5          6m\n$ kubectl describe rs crashing-pods\nName:           crashing-pods\nReplicas:       3 current / 3 desired                       \nPods Status:    3 Running / 0 Waiting / 0 Succeeded / 0 Failed      \n$ kubectl describe po crashing-pods-f1tcd\nName:           crashing-pods-f1tcd\nNamespace:      default\nNode:           minikube/192.168.99.102\nStart Time:     Thu, 02 Mar 2017 14:02:23 +0100\nLabels:         app=crashing-pods\nStatus:         Running                      \nIn a way, it\u2019s understandable that Kubernetes behaves this way. The container will be\nrestarted every five minutes in the hope that the underlying cause of the crash will be\nresolved. The rationale is that rescheduling the pod to another node most likely\nwouldn\u2019t fix the problem anyway, because the app is running inside a container and\nall the nodes should be mostly equivalent. That\u2019s not always the case, but it is most of\nthe time. \n17.2.3 Starting pods in a specific order\nOne other difference between apps running in pods and those managed manually is\nthat the ops person deploying those apps knows about the dependencies between\nthem. This allows them to start the apps in order. \nUNDERSTANDING HOW PODS ARE STARTED\nWhen you use Kubernetes to run your multi-pod applications, you don\u2019t have a built-\nin way to tell Kubernetes to run certain pods first and the rest only when the first pods\nare already up and ready to serve. Sure, you could post the manifest for the first app\nand then wait for the pod(s) to be ready before you post the second manifest, but your\nListing 17.1\nReplicaSet and pods that keep crashing\nThe pod\u2019s status shows the Kubelet is\ndelaying the restart because the\ncontainer keeps crashing.\nNo action taken \nby the controller, \nbecause current \nreplicas match \ndesired replicas\nThree \nreplicas are \nshown as \nrunning.\nkubectl describe \nalso shows pod\u2019s \nstatus as running\n \n"}, {"color": "green", "id": "text_427", "label": "484\nCHAPTER 17\nBest practices for developing apps\nwhole system is usually defined in a single YAML or JSON containing multiple Pods,\nServices, and other objects. \n The Kubernetes API server does process the objects in the YAML/JSON in the\norder they\u2019re listed, but this only means they\u2019re written to etcd in that order. You have\nno guarantee that pods will also be started in that order. \n But you can prevent a pod\u2019s main container from starting until a precondition is\nmet. This is done by including an init containers in the pod. \nINTRODUCING INIT CONTAINERS\nIn addition to regular containers, pods can also include init containers. As the name\nsuggests, they can be used to initialize the pod\u2014this often means writing data to the\npod\u2019s volumes, which are then mounted into the pod\u2019s main container(s).\n A pod may have any number of init containers. They\u2019re executed sequentially and\nonly after the last one completes are the pod\u2019s main containers started. This means\ninit containers can also be used to delay the start of the pod\u2019s main container(s)\u2014for\nexample, until a certain precondition is met. An init container could wait for a service\nrequired by the pod\u2019s main container to be up and ready. When it is, the init container\nterminates and allows the main container(s) to be started. This way, the main con-\ntainer wouldn\u2019t use the service before it\u2019s ready.\n Let\u2019s look at an example of a pod using an init container to delay the start of the\nmain container. Remember the fortune pod you created in chapter 7? It\u2019s a web\nserver that returns a fortune quote as a response to client requests. Now, let\u2019s imagine\nyou have a fortune-client pod that requires the fortune Service to be up and run-\nning before its main container starts. You can add an init container, which checks\nwhether the Service is responding to requests. Until that\u2019s the case, the init container\nkeeps retrying. Once it gets a response, the init container terminates and lets the main\ncontainer start.\nADDING AN INIT CONTAINER TO A POD\nInit containers can be defined in the pod spec like main containers but through the\nspec.initContainers field. You\u2019ll find the complete YAML for the fortune-client pod\nin the book\u2019s code archive. The following listing shows the part where the init con-\ntainer is defined.\nspec:\n  initContainers:      \n  - name: init\n    image: busybox\n    command:\n    - sh\n    - -c\n    - \u0027while true; do echo \"Waiting for fortune service to come up...\";  \n    \u27a5 wget http://fortune -q -T 1 -O /dev/null \u003e/dev/null 2\u003e/dev/null   \n    \u27a5 \u0026\u0026 break; sleep 1; done; echo \"Service is up! Starting main       \n    \u27a5 container.\"\u0027\nListing 17.2\nAn init container defined in a pod: fortune-client.yaml\nYou\u2019re defining \nan init container, \nnot a regular \ncontainer.\nThe init container runs a\nloop that runs until the\nfortune Service is up.\n \n", "shape": "dot", "size": 10, "title": "484\nCHAPTER 17\nBest practices for developing apps\nwhole system is usually defined in a single YAML or JSON containing multiple Pods,\nServices, and other objects. \n The Kubernetes API server does process the objects in the YAML/JSON in the\norder they\u2019re listed, but this only means they\u2019re written to etcd in that order. You have\nno guarantee that pods will also be started in that order. \n But you can prevent a pod\u2019s main container from starting until a precondition is\nmet. This is done by including an init containers in the pod. \nINTRODUCING INIT CONTAINERS\nIn addition to regular containers, pods can also include init containers. As the name\nsuggests, they can be used to initialize the pod\u2014this often means writing data to the\npod\u2019s volumes, which are then mounted into the pod\u2019s main container(s).\n A pod may have any number of init containers. They\u2019re executed sequentially and\nonly after the last one completes are the pod\u2019s main containers started. This means\ninit containers can also be used to delay the start of the pod\u2019s main container(s)\u2014for\nexample, until a certain precondition is met. An init container could wait for a service\nrequired by the pod\u2019s main container to be up and ready. When it is, the init container\nterminates and allows the main container(s) to be started. This way, the main con-\ntainer wouldn\u2019t use the service before it\u2019s ready.\n Let\u2019s look at an example of a pod using an init container to delay the start of the\nmain container. Remember the fortune pod you created in chapter 7? It\u2019s a web\nserver that returns a fortune quote as a response to client requests. Now, let\u2019s imagine\nyou have a fortune-client pod that requires the fortune Service to be up and run-\nning before its main container starts. You can add an init container, which checks\nwhether the Service is responding to requests. Until that\u2019s the case, the init container\nkeeps retrying. Once it gets a response, the init container terminates and lets the main\ncontainer start.\nADDING AN INIT CONTAINER TO A POD\nInit containers can be defined in the pod spec like main containers but through the\nspec.initContainers field. You\u2019ll find the complete YAML for the fortune-client pod\nin the book\u2019s code archive. The following listing shows the part where the init con-\ntainer is defined.\nspec:\n  initContainers:      \n  - name: init\n    image: busybox\n    command:\n    - sh\n    - -c\n    - \u0027while true; do echo \"Waiting for fortune service to come up...\";  \n    \u27a5 wget http://fortune -q -T 1 -O /dev/null \u003e/dev/null 2\u003e/dev/null   \n    \u27a5 \u0026\u0026 break; sleep 1; done; echo \"Service is up! Starting main       \n    \u27a5 container.\"\u0027\nListing 17.2\nAn init container defined in a pod: fortune-client.yaml\nYou\u2019re defining \nan init container, \nnot a regular \ncontainer.\nThe init container runs a\nloop that runs until the\nfortune Service is up.\n \n"}, {"color": "green", "id": "text_428", "label": "485\nUnderstanding the pod\u2019s lifecycle\nWhen you deploy this pod, only its init container is started. This is shown in the pod\u2019s\nstatus when you list pods with kubectl get:\n$ kubectl get po\nNAME             READY     STATUS     RESTARTS   AGE\nfortune-client   0/1       Init:0/1   0          1m\nThe STATUS column shows that zero of one init containers have finished. You can see\nthe log of the init container with kubectl logs:\n$ kubectl logs fortune-client -c init\nWaiting for fortune service to come up...\nWhen running the kubectl logs command, you need to specify the name of the init\ncontainer with the -c switch (in the example, the name of the pod\u2019s init container is\ninit, as you can see in listing 17.2).\n The main container won\u2019t run until you deploy the fortune Service and the\nfortune-server pod. You\u2019ll find them in the fortune-server.yaml file. \nBEST PRACTICES FOR HANDLING INTER-POD DEPENDENCIES\nYou\u2019ve seen how an init container can be used to delay starting the pod\u2019s main con-\ntainer(s) until a precondition is met (making sure the Service the pod depends on is\nready, for example), but it\u2019s much better to write apps that don\u2019t require every service\nthey rely on to be ready before the app starts up. After all, the service may also go\noffline later, while the app is already running.\n The application needs to handle internally the possibility that its dependencies\naren\u2019t ready. And don\u2019t forget readiness probes. If an app can\u2019t do its job because one\nof its dependencies is missing, it should signal that through its readiness probe, so\nKubernetes knows it, too, isn\u2019t ready. You\u2019ll want to do this not only because it pre-\nvents the app from being added as a service endpoint, but also because the app\u2019s read-\niness is also used by the Deployment controller when performing a rolling update,\nthereby preventing a rollout of a bad version. \n17.2.4 Adding lifecycle hooks\nWe\u2019ve talked about how init containers can be used to hook into the startup of the\npod, but pods also allow you to define two lifecycle hooks:\n\uf0a1Post-start hooks\n\uf0a1Pre-stop hooks\nThese lifecycle hooks are specified per container, unlike init containers, which apply\nto the whole pod. As their names suggest, they\u2019re executed when the container starts\nand before it stops. \n Lifecycle hooks are similar to liveness and readiness probes in that they can either\n\uf0a1Execute a command inside the container\n\uf0a1Perform an HTTP GET request against a URL\n \n", "shape": "dot", "size": 10, "title": "485\nUnderstanding the pod\u2019s lifecycle\nWhen you deploy this pod, only its init container is started. This is shown in the pod\u2019s\nstatus when you list pods with kubectl get:\n$ kubectl get po\nNAME             READY     STATUS     RESTARTS   AGE\nfortune-client   0/1       Init:0/1   0          1m\nThe STATUS column shows that zero of one init containers have finished. You can see\nthe log of the init container with kubectl logs:\n$ kubectl logs fortune-client -c init\nWaiting for fortune service to come up...\nWhen running the kubectl logs command, you need to specify the name of the init\ncontainer with the -c switch (in the example, the name of the pod\u2019s init container is\ninit, as you can see in listing 17.2).\n The main container won\u2019t run until you deploy the fortune Service and the\nfortune-server pod. You\u2019ll find them in the fortune-server.yaml file. \nBEST PRACTICES FOR HANDLING INTER-POD DEPENDENCIES\nYou\u2019ve seen how an init container can be used to delay starting the pod\u2019s main con-\ntainer(s) until a precondition is met (making sure the Service the pod depends on is\nready, for example), but it\u2019s much better to write apps that don\u2019t require every service\nthey rely on to be ready before the app starts up. After all, the service may also go\noffline later, while the app is already running.\n The application needs to handle internally the possibility that its dependencies\naren\u2019t ready. And don\u2019t forget readiness probes. If an app can\u2019t do its job because one\nof its dependencies is missing, it should signal that through its readiness probe, so\nKubernetes knows it, too, isn\u2019t ready. You\u2019ll want to do this not only because it pre-\nvents the app from being added as a service endpoint, but also because the app\u2019s read-\niness is also used by the Deployment controller when performing a rolling update,\nthereby preventing a rollout of a bad version. \n17.2.4 Adding lifecycle hooks\nWe\u2019ve talked about how init containers can be used to hook into the startup of the\npod, but pods also allow you to define two lifecycle hooks:\n\uf0a1Post-start hooks\n\uf0a1Pre-stop hooks\nThese lifecycle hooks are specified per container, unlike init containers, which apply\nto the whole pod. As their names suggest, they\u2019re executed when the container starts\nand before it stops. \n Lifecycle hooks are similar to liveness and readiness probes in that they can either\n\uf0a1Execute a command inside the container\n\uf0a1Perform an HTTP GET request against a URL\n \n"}, {"color": "green", "id": "text_429", "label": "486\nCHAPTER 17\nBest practices for developing apps\nLet\u2019s look at the two hooks individually to see what effect they have on the container\nlifecycle.\nUSING A POST-START CONTAINER LIFECYCLE HOOK\nA post-start hook is executed immediately after the container\u2019s main process is started.\nYou use it to perform additional operations when the application starts. Sure, if you\u2019re\nthe author of the application running in the container, you can always perform those\noperations inside the application code itself. But when you\u2019re running an application\ndeveloped by someone else, you mostly don\u2019t want to (or can\u2019t) modify its source\ncode. Post-start hooks allow you to run additional commands without having to touch\nthe app. These may signal to an external listener that the app is starting, or they may\ninitialize the application so it can start doing its job.\n The hook is run in parallel with the main process. The name might be somewhat\nmisleading, because it doesn\u2019t wait for the main process to start up fully (if the process\nhas an initialization procedure, the Kubelet obviously can\u2019t wait for the procedure to\ncomplete, because it has no way of knowing when that is). \n But even though the hook runs asynchronously, it does affect the container in two\nways. Until the hook completes, the container will stay in the Waiting state with the\nreason ContainerCreating. Because of this, the pod\u2019s status will be Pending instead of\nRunning. If the hook fails to run or returns a non-zero exit code, the main container\nwill be killed. \n A pod manifest containing a post-start hook looks like the following listing.\napiVersion: v1\nkind: Pod\nmetadata:\n  name: pod-with-poststart-hook\nspec:\n  containers:\n  - image: luksa/kubia\n    name: kubia\n    lifecycle:          \n      postStart:        \n        exec:                                                               \n          command:                                                          \n          - sh                                                              \n          - -c                                                              \n          - \"echo \u0027hook will fail with exit code 15\u0027; sleep 5; exit 15\"     \nIn the example, the echo, sleep, and exit commands are executed along with the\ncontainer\u2019s main process as soon as the container is created. Rather than run a com-\nmand like this, you\u2019d typically run a shell script or a binary executable file stored in\nthe container image. \n Sadly, if the process started by the hook logs to the standard output, you can\u2019t see\nthe output anywhere. This makes debugging lifecycle hooks painful. If the hook fails,\nListing 17.3\nA pod with a post-start lifecycle hook: post-start-hook.yaml\nThe hook is executed as \nthe container starts.\nIt executes the\npostStart.sh\nscript in the /bin\ndirectory inside\nthe container.\n \n", "shape": "dot", "size": 10, "title": "486\nCHAPTER 17\nBest practices for developing apps\nLet\u2019s look at the two hooks individually to see what effect they have on the container\nlifecycle.\nUSING A POST-START CONTAINER LIFECYCLE HOOK\nA post-start hook is executed immediately after the container\u2019s main process is started.\nYou use it to perform additional operations when the application starts. Sure, if you\u2019re\nthe author of the application running in the container, you can always perform those\noperations inside the application code itself. But when you\u2019re running an application\ndeveloped by someone else, you mostly don\u2019t want to (or can\u2019t) modify its source\ncode. Post-start hooks allow you to run additional commands without having to touch\nthe app. These may signal to an external listener that the app is starting, or they may\ninitialize the application so it can start doing its job.\n The hook is run in parallel with the main process. The name might be somewhat\nmisleading, because it doesn\u2019t wait for the main process to start up fully (if the process\nhas an initialization procedure, the Kubelet obviously can\u2019t wait for the procedure to\ncomplete, because it has no way of knowing when that is). \n But even though the hook runs asynchronously, it does affect the container in two\nways. Until the hook completes, the container will stay in the Waiting state with the\nreason ContainerCreating. Because of this, the pod\u2019s status will be Pending instead of\nRunning. If the hook fails to run or returns a non-zero exit code, the main container\nwill be killed. \n A pod manifest containing a post-start hook looks like the following listing.\napiVersion: v1\nkind: Pod\nmetadata:\n  name: pod-with-poststart-hook\nspec:\n  containers:\n  - image: luksa/kubia\n    name: kubia\n    lifecycle:          \n      postStart:        \n        exec:                                                               \n          command:                                                          \n          - sh                                                              \n          - -c                                                              \n          - \"echo \u0027hook will fail with exit code 15\u0027; sleep 5; exit 15\"     \nIn the example, the echo, sleep, and exit commands are executed along with the\ncontainer\u2019s main process as soon as the container is created. Rather than run a com-\nmand like this, you\u2019d typically run a shell script or a binary executable file stored in\nthe container image. \n Sadly, if the process started by the hook logs to the standard output, you can\u2019t see\nthe output anywhere. This makes debugging lifecycle hooks painful. If the hook fails,\nListing 17.3\nA pod with a post-start lifecycle hook: post-start-hook.yaml\nThe hook is executed as \nthe container starts.\nIt executes the\npostStart.sh\nscript in the /bin\ndirectory inside\nthe container.\n \n"}, {"color": "green", "id": "text_430", "label": "487\nUnderstanding the pod\u2019s lifecycle\nyou\u2019ll only see a FailedPostStartHook warning among the pod\u2019s events (you can see\nthem using kubectl describe pod). A while later, you\u2019ll see more information on why\nthe hook failed, as shown in the following listing.\nFailedSync   Error syncing pod, skipping: failed to \"StartContainer\" for \n             \"kubia\" with PostStart handler: command \u0027sh -c echo \u0027hook \n             will fail with exit code 15\u0027; sleep 5 ; exit 15\u0027 exited \n             with 15: : \"PostStart Hook Failed\" \nThe number 15 in the last line is the exit code of the command. When using an HTTP\nGET hook handler, the reason may look like the following listing (you can try this by\ndeploying the post-start-hook-httpget.yaml file from the book\u2019s code archive).\nFailedSync   Error syncing pod, skipping: failed to \"StartContainer\" for \n             \"kubia\" with PostStart handler: Get \n             http://10.32.0.2:9090/postStart: dial tcp 10.32.0.2:9090: \n             getsockopt: connection refused: \"PostStart Hook Failed\" \nNOTE\nThe post-start hook is intentionally misconfigured to use port 9090\ninstead of the correct port 8080, to show what happens when the hook fails.\nThe standard and error outputs of command-based post-start hooks aren\u2019t logged any-\nwhere, so you may want to have the process the hook invokes log to a file in the con-\ntainer\u2019s filesystem, which will allow you to examine the contents of the file with\nsomething like this:\n$ kubectl exec my-pod cat logfile.txt \nIf the container gets restarted for whatever reason (including because the hook failed),\nthe file may be gone before you can examine it. You can work around that by mount-\ning an emptyDir volume into the container and having the hook write to it.\nUSING A PRE-STOP CONTAINER LIFECYCLE HOOK\nA pre-stop hook is executed immediately before a container is terminated. When a\ncontainer needs to be terminated, the Kubelet will run the pre-stop hook, if config-\nured, and only then send a SIGTERM to the process (and later kill the process if it\ndoesn\u2019t terminate gracefully). \n A pre-stop hook can be used to initiate a graceful shutdown of the container, if it\ndoesn\u2019t shut down gracefully upon receipt of a SIGTERM signal. They can also be used\nto perform arbitrary operations before shutdown without having to implement those\noperations in the application itself (this is useful when you\u2019re running a third-party\napp, whose source code you don\u2019t have access to and/or can\u2019t modify). \n Configuring a pre-stop hook in a pod manifest isn\u2019t very different from adding a\npost-start hook. The previous example showed a post-start hook that executes a com-\nListing 17.4\nPod\u2019s events showing the exit code of the failed command-based hook\nListing 17.5\nPod\u2019s events showing the reason why an HTTP GET hook failed\n \n", "shape": "dot", "size": 10, "title": "487\nUnderstanding the pod\u2019s lifecycle\nyou\u2019ll only see a FailedPostStartHook warning among the pod\u2019s events (you can see\nthem using kubectl describe pod). A while later, you\u2019ll see more information on why\nthe hook failed, as shown in the following listing.\nFailedSync   Error syncing pod, skipping: failed to \"StartContainer\" for \n             \"kubia\" with PostStart handler: command \u0027sh -c echo \u0027hook \n             will fail with exit code 15\u0027; sleep 5 ; exit 15\u0027 exited \n             with 15: : \"PostStart Hook Failed\" \nThe number 15 in the last line is the exit code of the command. When using an HTTP\nGET hook handler, the reason may look like the following listing (you can try this by\ndeploying the post-start-hook-httpget.yaml file from the book\u2019s code archive).\nFailedSync   Error syncing pod, skipping: failed to \"StartContainer\" for \n             \"kubia\" with PostStart handler: Get \n             http://10.32.0.2:9090/postStart: dial tcp 10.32.0.2:9090: \n             getsockopt: connection refused: \"PostStart Hook Failed\" \nNOTE\nThe post-start hook is intentionally misconfigured to use port 9090\ninstead of the correct port 8080, to show what happens when the hook fails.\nThe standard and error outputs of command-based post-start hooks aren\u2019t logged any-\nwhere, so you may want to have the process the hook invokes log to a file in the con-\ntainer\u2019s filesystem, which will allow you to examine the contents of the file with\nsomething like this:\n$ kubectl exec my-pod cat logfile.txt \nIf the container gets restarted for whatever reason (including because the hook failed),\nthe file may be gone before you can examine it. You can work around that by mount-\ning an emptyDir volume into the container and having the hook write to it.\nUSING A PRE-STOP CONTAINER LIFECYCLE HOOK\nA pre-stop hook is executed immediately before a container is terminated. When a\ncontainer needs to be terminated, the Kubelet will run the pre-stop hook, if config-\nured, and only then send a SIGTERM to the process (and later kill the process if it\ndoesn\u2019t terminate gracefully). \n A pre-stop hook can be used to initiate a graceful shutdown of the container, if it\ndoesn\u2019t shut down gracefully upon receipt of a SIGTERM signal. They can also be used\nto perform arbitrary operations before shutdown without having to implement those\noperations in the application itself (this is useful when you\u2019re running a third-party\napp, whose source code you don\u2019t have access to and/or can\u2019t modify). \n Configuring a pre-stop hook in a pod manifest isn\u2019t very different from adding a\npost-start hook. The previous example showed a post-start hook that executes a com-\nListing 17.4\nPod\u2019s events showing the exit code of the failed command-based hook\nListing 17.5\nPod\u2019s events showing the reason why an HTTP GET hook failed\n \n"}, {"color": "green", "id": "text_431", "label": "488\nCHAPTER 17\nBest practices for developing apps\nmand, so we\u2019ll look at a pre-stop hook that performs an HTTP GET request now. The\nfollowing listing shows how to define a pre-stop HTTP GET hook in a pod.\n    lifecycle:\n      preStop:            \n        httpGet:          \n          port: 8080          \n          path: shutdown      \nThe pre-stop hook defined in this listing performs an HTTP GET request to http:/\n/\nPOD_IP:8080/shutdown as soon as the Kubelet starts terminating the container.\nApart from the port and path shown in the listing, you can also set the fields scheme\n(HTTP or HTTPS) and host, as well as httpHeaders that should be sent in the\nrequest. The host field defaults to the pod IP. Be sure not to set it to localhost,\nbecause localhost would refer to the node, not the pod.\n In contrast to the post-start hook, the container will be terminated regardless of\nthe result of the hook\u2014an error HTTP response code or a non-zero exit code when\nusing a command-based hook will not prevent the container from being terminated.\nIf the pre-stop hook fails, you\u2019ll see a FailedPreStopHook warning event among the\npod\u2019s events, but because the pod is deleted soon afterward (after all, the pod\u2019s dele-\ntion is what triggered the pre-stop hook in the first place), you may not even notice\nthat the pre-stop hook failed to run properly. \nTIP\nIf the successful completion of the pre-stop hook is critical to the proper\noperation of your system, verify whether it\u2019s being executed at all. I\u2019ve wit-\nnessed situations where the pre-stop hook didn\u2019t run and the developer\nwasn\u2019t even aware of that.\nUSING A PRE-STOP HOOK BECAUSE YOUR APP DOESN\u2019T RECEIVE THE SIGTERM SIGNAL\nMany developers make the mistake of defining a pre-stop hook solely to send a SIGTERM\nsignal to their apps in the pre-stop hook. They do this because they don\u2019t see their appli-\ncation receive the SIGTERM signal sent by the Kubelet. The reason why the signal isn\u2019t\nreceived by the application isn\u2019t because Kubernetes isn\u2019t sending it, but because the sig-\nnal isn\u2019t being passed to the app process inside the container itself. If your container\nimage is configured to run a shell, which in turn runs the app process, the signal may be\neaten up by the shell itself, instead of being passed down to the child process.\n In such cases, instead of adding a pre-stop hook to send the signal directly to your\napp, the proper fix is to make sure the shell passes the signal to the app. This can be\nachieved by handling the signal in the shell script running as the main container pro-\ncess and then passing it on to the app. Or you could not configure the container image\nto run a shell at all and instead run the application binary directly. You do this by using\nthe exec form of ENTRYPOINT or CMD in the Dockerfile: ENTRYPOINT [\"/mybinary\"]\ninstead of ENTRYPOINT /mybinary.\nListing 17.6\nA pre-stop hook YAML snippet: pre-stop-hook-httpget.yaml\nThis is a pre-stop hook that \nperforms an HTTP GET request.\nThe request is sent to \nhttp://POD_IP:8080/shutdown.\n \n", "shape": "dot", "size": 10, "title": "488\nCHAPTER 17\nBest practices for developing apps\nmand, so we\u2019ll look at a pre-stop hook that performs an HTTP GET request now. The\nfollowing listing shows how to define a pre-stop HTTP GET hook in a pod.\n    lifecycle:\n      preStop:            \n        httpGet:          \n          port: 8080          \n          path: shutdown      \nThe pre-stop hook defined in this listing performs an HTTP GET request to http:/\n/\nPOD_IP:8080/shutdown as soon as the Kubelet starts terminating the container.\nApart from the port and path shown in the listing, you can also set the fields scheme\n(HTTP or HTTPS) and host, as well as httpHeaders that should be sent in the\nrequest. The host field defaults to the pod IP. Be sure not to set it to localhost,\nbecause localhost would refer to the node, not the pod.\n In contrast to the post-start hook, the container will be terminated regardless of\nthe result of the hook\u2014an error HTTP response code or a non-zero exit code when\nusing a command-based hook will not prevent the container from being terminated.\nIf the pre-stop hook fails, you\u2019ll see a FailedPreStopHook warning event among the\npod\u2019s events, but because the pod is deleted soon afterward (after all, the pod\u2019s dele-\ntion is what triggered the pre-stop hook in the first place), you may not even notice\nthat the pre-stop hook failed to run properly. \nTIP\nIf the successful completion of the pre-stop hook is critical to the proper\noperation of your system, verify whether it\u2019s being executed at all. I\u2019ve wit-\nnessed situations where the pre-stop hook didn\u2019t run and the developer\nwasn\u2019t even aware of that.\nUSING A PRE-STOP HOOK BECAUSE YOUR APP DOESN\u2019T RECEIVE THE SIGTERM SIGNAL\nMany developers make the mistake of defining a pre-stop hook solely to send a SIGTERM\nsignal to their apps in the pre-stop hook. They do this because they don\u2019t see their appli-\ncation receive the SIGTERM signal sent by the Kubelet. The reason why the signal isn\u2019t\nreceived by the application isn\u2019t because Kubernetes isn\u2019t sending it, but because the sig-\nnal isn\u2019t being passed to the app process inside the container itself. If your container\nimage is configured to run a shell, which in turn runs the app process, the signal may be\neaten up by the shell itself, instead of being passed down to the child process.\n In such cases, instead of adding a pre-stop hook to send the signal directly to your\napp, the proper fix is to make sure the shell passes the signal to the app. This can be\nachieved by handling the signal in the shell script running as the main container pro-\ncess and then passing it on to the app. Or you could not configure the container image\nto run a shell at all and instead run the application binary directly. You do this by using\nthe exec form of ENTRYPOINT or CMD in the Dockerfile: ENTRYPOINT [\"/mybinary\"]\ninstead of ENTRYPOINT /mybinary.\nListing 17.6\nA pre-stop hook YAML snippet: pre-stop-hook-httpget.yaml\nThis is a pre-stop hook that \nperforms an HTTP GET request.\nThe request is sent to \nhttp://POD_IP:8080/shutdown.\n \n"}, {"color": "green", "id": "text_432", "label": "489\nUnderstanding the pod\u2019s lifecycle\n A container using the first form runs the mybinary executable as its main process,\nwhereas the second form runs a shell as the main process with the mybinary process\nexecuted as a child of the shell process.\nUNDERSTANDING THAT LIFECYCLE HOOKS TARGET CONTAINERS, NOT PODS\nAs a final thought on post-start and pre-stop hooks, let me emphasize that these lifecy-\ncle hooks relate to containers, not pods. You shouldn\u2019t use a pre-stop hook for run-\nning actions that need to be performed when the pod is terminating. The reason is\nthat the pre-stop hook gets called when the container is being terminated (most likely\nbecause of a failed liveness probe). This may happen multiple times in the pod\u2019s life-\ntime, not only when the pod is in the process of being shut down. \n17.2.5 Understanding pod shutdown\nWe\u2019ve touched on the subject of pod termination, so let\u2019s explore this subject in more\ndetail and go over exactly what happens during pod shutdown. This is important for\nunderstanding how to cleanly shut down an application running in a pod.\n Let\u2019s start at the beginning. A pod\u2019s shut-down is triggered by the deletion of the\nPod object through the API server. Upon receiving an HTTP DELETE request, the\nAPI server doesn\u2019t delete the object yet, but only sets a deletionTimestamp field in it.\nPods that have the deletionTimestamp field set are terminating. \n Once the Kubelet notices the pod needs to be terminated, it starts terminating\neach of the pod\u2019s containers. It gives each container time to shut down gracefully, but\nthe time is limited. That time is called the termination grace period and is configu-\nrable per pod. The timer starts as soon as the termination process starts. Then the fol-\nlowing sequence of events is performed:\n1\nRun the pre-stop hook, if one is configured, and wait for it to finish.\n2\nSend the SIGTERM signal to the main process of the container.\n3\nWait until the container shuts down cleanly or until the termination grace\nperiod runs out.\n4\nForcibly kill the process with SIGKILL, if it hasn\u2019t terminated gracefully yet.\nThe sequence of events is illustrated in figure 17.5.\nPre-stop hook process\nTermination grace period\nMain container process\nContainer shutdown\ninitiated\nContainer killed\nif still running\nTime\nSIGTERM\nSIGKILL\nFigure 17.5\nThe container termination sequence\n \n", "shape": "dot", "size": 10, "title": "489\nUnderstanding the pod\u2019s lifecycle\n A container using the first form runs the mybinary executable as its main process,\nwhereas the second form runs a shell as the main process with the mybinary process\nexecuted as a child of the shell process.\nUNDERSTANDING THAT LIFECYCLE HOOKS TARGET CONTAINERS, NOT PODS\nAs a final thought on post-start and pre-stop hooks, let me emphasize that these lifecy-\ncle hooks relate to containers, not pods. You shouldn\u2019t use a pre-stop hook for run-\nning actions that need to be performed when the pod is terminating. The reason is\nthat the pre-stop hook gets called when the container is being terminated (most likely\nbecause of a failed liveness probe). This may happen multiple times in the pod\u2019s life-\ntime, not only when the pod is in the process of being shut down. \n17.2.5 Understanding pod shutdown\nWe\u2019ve touched on the subject of pod termination, so let\u2019s explore this subject in more\ndetail and go over exactly what happens during pod shutdown. This is important for\nunderstanding how to cleanly shut down an application running in a pod.\n Let\u2019s start at the beginning. A pod\u2019s shut-down is triggered by the deletion of the\nPod object through the API server. Upon receiving an HTTP DELETE request, the\nAPI server doesn\u2019t delete the object yet, but only sets a deletionTimestamp field in it.\nPods that have the deletionTimestamp field set are terminating. \n Once the Kubelet notices the pod needs to be terminated, it starts terminating\neach of the pod\u2019s containers. It gives each container time to shut down gracefully, but\nthe time is limited. That time is called the termination grace period and is configu-\nrable per pod. The timer starts as soon as the termination process starts. Then the fol-\nlowing sequence of events is performed:\n1\nRun the pre-stop hook, if one is configured, and wait for it to finish.\n2\nSend the SIGTERM signal to the main process of the container.\n3\nWait until the container shuts down cleanly or until the termination grace\nperiod runs out.\n4\nForcibly kill the process with SIGKILL, if it hasn\u2019t terminated gracefully yet.\nThe sequence of events is illustrated in figure 17.5.\nPre-stop hook process\nTermination grace period\nMain container process\nContainer shutdown\ninitiated\nContainer killed\nif still running\nTime\nSIGTERM\nSIGKILL\nFigure 17.5\nThe container termination sequence\n \n"}, {"color": "green", "id": "text_433", "label": "490\nCHAPTER 17\nBest practices for developing apps\nSPECIFYING THE TERMINATION GRACE PERIOD\nThe termination grace period can be configured in the pod spec by setting the spec.\nterminationGracePeriodSeconds field. It defaults to 30, which means the pod\u2019s con-\ntainers will be given 30 seconds to terminate gracefully before they\u2019re killed forcibly. \nTIP\nYou should set the grace period to long enough so your process can fin-\nish cleaning up in that time. \nThe grace period specified in the pod spec can also be overridden when deleting the\npod like this:\n$ kubectl delete po mypod --grace-period=5\nThis will make the Kubelet wait five seconds for the pod to shut down cleanly. When\nall the pod\u2019s containers stop, the Kubelet notifies the API server and the Pod resource\nis finally deleted. You can force the API server to delete the resource immediately,\nwithout waiting for confirmation, by setting the grace period to zero and adding the\n--force option like this:\n$ kubectl delete po mypod --grace-period=0 --force\nBe careful when using this option, especially with pods of a StatefulSet. The Stateful-\nSet controller takes great care to never run two instances of the same pod at the same\ntime (two pods with the same ordinal index and name and attached to the same\nPersistentVolume). By force-deleting a pod, you\u2019ll cause the controller to create a\nreplacement pod without waiting for the containers of the deleted pod to shut\ndown. In other words, two instances of the same pod might be running at the same\ntime, which may cause your stateful cluster to malfunction. Only delete stateful pods\nforcibly when you\u2019re absolutely sure the pod isn\u2019t running anymore or can\u2019t talk to\nthe other members of the cluster (you can be sure of this when you confirm that the\nnode that hosted the pod has failed or has been disconnected from the network and\ncan\u2019t reconnect). \n Now that you understand how containers are shut down, let\u2019s look at it from the\napplication\u2019s perspective and go over how applications should handle the shutdown\nprocedure.\nIMPLEMENTING THE PROPER SHUTDOWN HANDLER IN YOUR APPLICATION\nApplications should react to a SIGTERM signal by starting their shut-down procedure\nand terminating when it finishes. Instead of handling the SIGTERM signal, the applica-\ntion can be notified to shut down through a pre-stop hook. In both cases, the app\nthen only has a fixed amount of time to terminate cleanly. \n But what if you can\u2019t predict how long the app will take to shut down cleanly? For\nexample, imagine your app is a distributed data store. On scale-down, one of the pod\ninstances will be deleted and therefore shut down. In the shut-down procedure, the\n \n", "shape": "dot", "size": 10, "title": "490\nCHAPTER 17\nBest practices for developing apps\nSPECIFYING THE TERMINATION GRACE PERIOD\nThe termination grace period can be configured in the pod spec by setting the spec.\nterminationGracePeriodSeconds field. It defaults to 30, which means the pod\u2019s con-\ntainers will be given 30 seconds to terminate gracefully before they\u2019re killed forcibly. \nTIP\nYou should set the grace period to long enough so your process can fin-\nish cleaning up in that time. \nThe grace period specified in the pod spec can also be overridden when deleting the\npod like this:\n$ kubectl delete po mypod --grace-period=5\nThis will make the Kubelet wait five seconds for the pod to shut down cleanly. When\nall the pod\u2019s containers stop, the Kubelet notifies the API server and the Pod resource\nis finally deleted. You can force the API server to delete the resource immediately,\nwithout waiting for confirmation, by setting the grace period to zero and adding the\n--force option like this:\n$ kubectl delete po mypod --grace-period=0 --force\nBe careful when using this option, especially with pods of a StatefulSet. The Stateful-\nSet controller takes great care to never run two instances of the same pod at the same\ntime (two pods with the same ordinal index and name and attached to the same\nPersistentVolume). By force-deleting a pod, you\u2019ll cause the controller to create a\nreplacement pod without waiting for the containers of the deleted pod to shut\ndown. In other words, two instances of the same pod might be running at the same\ntime, which may cause your stateful cluster to malfunction. Only delete stateful pods\nforcibly when you\u2019re absolutely sure the pod isn\u2019t running anymore or can\u2019t talk to\nthe other members of the cluster (you can be sure of this when you confirm that the\nnode that hosted the pod has failed or has been disconnected from the network and\ncan\u2019t reconnect). \n Now that you understand how containers are shut down, let\u2019s look at it from the\napplication\u2019s perspective and go over how applications should handle the shutdown\nprocedure.\nIMPLEMENTING THE PROPER SHUTDOWN HANDLER IN YOUR APPLICATION\nApplications should react to a SIGTERM signal by starting their shut-down procedure\nand terminating when it finishes. Instead of handling the SIGTERM signal, the applica-\ntion can be notified to shut down through a pre-stop hook. In both cases, the app\nthen only has a fixed amount of time to terminate cleanly. \n But what if you can\u2019t predict how long the app will take to shut down cleanly? For\nexample, imagine your app is a distributed data store. On scale-down, one of the pod\ninstances will be deleted and therefore shut down. In the shut-down procedure, the\n \n"}, {"color": "green", "id": "text_434", "label": "491\nUnderstanding the pod\u2019s lifecycle\npod needs to migrate all its data to the remaining pods to make sure it\u2019s not lost.\nShould the pod start migrating the data upon receiving a termination signal (through\neither the SIGTERM signal or through a pre-stop hook)? \n Absolutely not! This is not recommended for at least the following two reasons:\n\uf0a1A container terminating doesn\u2019t necessarily mean the whole pod is being\nterminated.\n\uf0a1You have no guarantee the shut-down procedure will finish before the process\nis killed.\nThis second scenario doesn\u2019t happen only when the grace period runs out before the\napplication has finished shutting down gracefully, but also when the node running\nthe pod fails in the middle of the container shut-down sequence. Even if the node\nthen starts up again, the Kubelet will not restart the shut-down procedure (it won\u2019t\neven start up the container again). There are absolutely no guarantees that the pod\nwill be allowed to complete its whole shut-down procedure.\nREPLACING CRITICAL SHUT-DOWN PROCEDURES WITH DEDICATED SHUT-DOWN PROCEDURE PODS\nHow do you ensure that a critical shut-down procedure that absolutely must run to\ncompletion does run to completion (for example, to ensure that a pod\u2019s data is\nmigrated to other pods)?\n One solution is for the app (upon receipt of a termination signal) to create a new\nJob resource that would run a new pod, whose sole job is to migrate the deleted pod\u2019s\ndata to the remaining pods. But if you\u2019ve been paying attention, you\u2019ll know that you\nhave no guarantee the app will indeed manage to create the Job object every single\ntime. What if the node fails exactly when the app tries to do that? \n The proper way to handle this problem is by having a dedicated, constantly run-\nning pod that keeps checking for the existence of orphaned data. When this pod finds\nthe orphaned data, it can migrate it to the remaining pods. Rather than a constantly\nrunning pod, you can also use a CronJob resource and run the pod periodically. \n You may think StatefulSets could help here, but they don\u2019t. As you\u2019ll remember,\nscaling down a StatefulSet leaves PersistentVolumeClaims orphaned, leaving the data\nstored on the PersistentVolume stranded. Yes, upon a subsequent scale-up, the Persistent-\nVolume will be reattached to the new pod instance, but what if that scale-up never\nhappens (or happens after a long time)? For this reason, you may want to run a\ndata-migrating pod also when using StatefulSets (this scenario is shown in figure 17.6).\nTo prevent the migration from occurring during an application upgrade, the data-\nmigrating pod could be configured to wait a while to give the stateful pod time to\ncome up again before performing the migration.\n \n \n \n", "shape": "dot", "size": 10, "title": "491\nUnderstanding the pod\u2019s lifecycle\npod needs to migrate all its data to the remaining pods to make sure it\u2019s not lost.\nShould the pod start migrating the data upon receiving a termination signal (through\neither the SIGTERM signal or through a pre-stop hook)? \n Absolutely not! This is not recommended for at least the following two reasons:\n\uf0a1A container terminating doesn\u2019t necessarily mean the whole pod is being\nterminated.\n\uf0a1You have no guarantee the shut-down procedure will finish before the process\nis killed.\nThis second scenario doesn\u2019t happen only when the grace period runs out before the\napplication has finished shutting down gracefully, but also when the node running\nthe pod fails in the middle of the container shut-down sequence. Even if the node\nthen starts up again, the Kubelet will not restart the shut-down procedure (it won\u2019t\neven start up the container again). There are absolutely no guarantees that the pod\nwill be allowed to complete its whole shut-down procedure.\nREPLACING CRITICAL SHUT-DOWN PROCEDURES WITH DEDICATED SHUT-DOWN PROCEDURE PODS\nHow do you ensure that a critical shut-down procedure that absolutely must run to\ncompletion does run to completion (for example, to ensure that a pod\u2019s data is\nmigrated to other pods)?\n One solution is for the app (upon receipt of a termination signal) to create a new\nJob resource that would run a new pod, whose sole job is to migrate the deleted pod\u2019s\ndata to the remaining pods. But if you\u2019ve been paying attention, you\u2019ll know that you\nhave no guarantee the app will indeed manage to create the Job object every single\ntime. What if the node fails exactly when the app tries to do that? \n The proper way to handle this problem is by having a dedicated, constantly run-\nning pod that keeps checking for the existence of orphaned data. When this pod finds\nthe orphaned data, it can migrate it to the remaining pods. Rather than a constantly\nrunning pod, you can also use a CronJob resource and run the pod periodically. \n You may think StatefulSets could help here, but they don\u2019t. As you\u2019ll remember,\nscaling down a StatefulSet leaves PersistentVolumeClaims orphaned, leaving the data\nstored on the PersistentVolume stranded. Yes, upon a subsequent scale-up, the Persistent-\nVolume will be reattached to the new pod instance, but what if that scale-up never\nhappens (or happens after a long time)? For this reason, you may want to run a\ndata-migrating pod also when using StatefulSets (this scenario is shown in figure 17.6).\nTo prevent the migration from occurring during an application upgrade, the data-\nmigrating pod could be configured to wait a while to give the stateful pod time to\ncome up again before performing the migration.\n \n \n \n"}, {"color": "green", "id": "text_435", "label": "492\nCHAPTER 17\nBest practices for developing apps\n17.3\nEnsuring all client requests are handled properly\nYou now have a good sense of how to make pods shut down cleanly. Now, we\u2019ll look at\nthe pod\u2019s lifecycle from the perspective of the pod\u2019s clients (clients consuming the ser-\nvice the pod is providing). This is important to understand if you don\u2019t want clients to\nrun into problems when you scale pods up or down.\n It goes without saying that you want all client requests to be handled properly. You\nobviously don\u2019t want to see broken connections when pods are starting up or shutting\ndown. By itself, Kubernetes doesn\u2019t prevent this from happening. Your app needs to\nfollow a few rules to prevent broken connections. First, let\u2019s focus on making sure all\nconnections are handled properly when the pod starts up.\n17.3.1 Preventing broken client connections when a pod is starting up\nEnsuring each connection is handled properly at pod startup is simple if you under-\nstand how Services and service Endpoints work. When a pod is started, it\u2019s added as an\nendpoint to all the Services, whose label selector matches the pod\u2019s labels. As you may\nremember from chapter 5, the pod also needs to signal to Kubernetes that it\u2019s ready.\nUntil it is, it won\u2019t become a service endpoint and therefore won\u2019t receive any requests\nfrom clients. \n If you don\u2019t specify a readiness probe in your pod spec, the pod is always considered\nready. It will start receiving requests almost immediately\u2014as soon as the first kube-proxy\nupdates the iptables rules on its node and the first client pod tries to connect to the\nservice. If your app isn\u2019t ready to accept connections by then, clients will see \u201cconnec-\ntion refused\u201d types of errors.\n All you need to do is make sure that your readiness probe returns success only\nwhen your app is ready to properly handle incoming requests. A good first step is to\nadd an HTTP GET readiness probe and point it to the base URL of your app. In many\nPod\nA-0\nPod\nA-1\nStatefulSet A\nReplicas: 2\nScale\ndown\nPVC\nA-0\nPV\nPVC\nA-1\nPV\nPod\nA-0\nStatefulSet A\nReplicas: 1\nTransfers data to\nremaining pod(s)\nConnects to\norphaned PVC\nData-migrating\nPod\nJob\nPVC\nA-0\nPV\nPVC\nA-1\nPV\nFigure 17.6\nUsing a dedicated pod to migrate data \n \n", "shape": "dot", "size": 10, "title": "492\nCHAPTER 17\nBest practices for developing apps\n17.3\nEnsuring all client requests are handled properly\nYou now have a good sense of how to make pods shut down cleanly. Now, we\u2019ll look at\nthe pod\u2019s lifecycle from the perspective of the pod\u2019s clients (clients consuming the ser-\nvice the pod is providing). This is important to understand if you don\u2019t want clients to\nrun into problems when you scale pods up or down.\n It goes without saying that you want all client requests to be handled properly. You\nobviously don\u2019t want to see broken connections when pods are starting up or shutting\ndown. By itself, Kubernetes doesn\u2019t prevent this from happening. Your app needs to\nfollow a few rules to prevent broken connections. First, let\u2019s focus on making sure all\nconnections are handled properly when the pod starts up.\n17.3.1 Preventing broken client connections when a pod is starting up\nEnsuring each connection is handled properly at pod startup is simple if you under-\nstand how Services and service Endpoints work. When a pod is started, it\u2019s added as an\nendpoint to all the Services, whose label selector matches the pod\u2019s labels. As you may\nremember from chapter 5, the pod also needs to signal to Kubernetes that it\u2019s ready.\nUntil it is, it won\u2019t become a service endpoint and therefore won\u2019t receive any requests\nfrom clients. \n If you don\u2019t specify a readiness probe in your pod spec, the pod is always considered\nready. It will start receiving requests almost immediately\u2014as soon as the first kube-proxy\nupdates the iptables rules on its node and the first client pod tries to connect to the\nservice. If your app isn\u2019t ready to accept connections by then, clients will see \u201cconnec-\ntion refused\u201d types of errors.\n All you need to do is make sure that your readiness probe returns success only\nwhen your app is ready to properly handle incoming requests. A good first step is to\nadd an HTTP GET readiness probe and point it to the base URL of your app. In many\nPod\nA-0\nPod\nA-1\nStatefulSet A\nReplicas: 2\nScale\ndown\nPVC\nA-0\nPV\nPVC\nA-1\nPV\nPod\nA-0\nStatefulSet A\nReplicas: 1\nTransfers data to\nremaining pod(s)\nConnects to\norphaned PVC\nData-migrating\nPod\nJob\nPVC\nA-0\nPV\nPVC\nA-1\nPV\nFigure 17.6\nUsing a dedicated pod to migrate data \n \n"}, {"color": "green", "id": "text_436", "label": "493\nEnsuring all client requests are handled properly\ncases that gets you far enough and saves you from having to implement a special read-\niness endpoint in your app. \n17.3.2 Preventing broken connections during pod shut-down\nNow let\u2019s see what happens at the other end of a pod\u2019s life\u2014when the pod is deleted and\nits containers are terminated. We\u2019ve already talked about how the pod\u2019s containers\nshould start shutting down cleanly as soon they receive the SIGTERM signal (or when its\npre-stop hook is executed). But does that ensure all client requests are handled properly? \n How should the app behave when it receives a termination signal? Should it con-\ntinue to accept requests? What about requests that have already been received but\nhaven\u2019t completed yet? What about persistent HTTP connections, which may be in\nbetween requests, but are open (when no active request exists on the connection)?\nBefore we can answer those questions, we need to take a detailed look at the chain of\nevents that unfolds across the cluster when a Pod is deleted. \nUNDERSTANDING THE SEQUENCE OF EVENTS OCCURRING AT POD DELETION\nIn chapter 11 we took an in-depth look at what components make up a Kubernetes clus-\nter. You need to always keep in mind that those components run as separate processes on\nmultiple machines. They aren\u2019t all part of a single big monolithic process. It takes time\nfor all the components to be on the same page regarding the state of the cluster. Let\u2019s\nexplore this fact by looking at what happens across the cluster when a Pod is deleted.\n When a request for a pod deletion is received by the API server, it first modifies the\nstate in etcd and then notifies its watchers of the deletion. Among those watchers are\nthe Kubelet and the Endpoints controller. The two sequences of events, which happen\nin parallel (marked with either A or B), are shown in figure 17.7.\nA2. Stop\ncontainers\nAPI server\nkube-proxy\nKubelet\nWorker node\nEndpoints\ncontroller\nkube-proxy\nPod\n(containers)\nClient\nDelete\npod\nB1. Pod deletion\nnoti\ufb01cation\nB2. Remove pod\nas endpoint\nA1. Pod deletion\nnoti\ufb01cation\nB3. Endpoint\nmodi\ufb01cation\nnoti\ufb01cation\nB4. Remove pod\nfrom iptables\nB4. Remove pod\nfrom iptables\niptables\niptables\nWorker node\nFigure 17.7\nSequence of events that occurs when a Pod is deleted\n \n", "shape": "dot", "size": 10, "title": "493\nEnsuring all client requests are handled properly\ncases that gets you far enough and saves you from having to implement a special read-\niness endpoint in your app. \n17.3.2 Preventing broken connections during pod shut-down\nNow let\u2019s see what happens at the other end of a pod\u2019s life\u2014when the pod is deleted and\nits containers are terminated. We\u2019ve already talked about how the pod\u2019s containers\nshould start shutting down cleanly as soon they receive the SIGTERM signal (or when its\npre-stop hook is executed). But does that ensure all client requests are handled properly? \n How should the app behave when it receives a termination signal? Should it con-\ntinue to accept requests? What about requests that have already been received but\nhaven\u2019t completed yet? What about persistent HTTP connections, which may be in\nbetween requests, but are open (when no active request exists on the connection)?\nBefore we can answer those questions, we need to take a detailed look at the chain of\nevents that unfolds across the cluster when a Pod is deleted. \nUNDERSTANDING THE SEQUENCE OF EVENTS OCCURRING AT POD DELETION\nIn chapter 11 we took an in-depth look at what components make up a Kubernetes clus-\nter. You need to always keep in mind that those components run as separate processes on\nmultiple machines. They aren\u2019t all part of a single big monolithic process. It takes time\nfor all the components to be on the same page regarding the state of the cluster. Let\u2019s\nexplore this fact by looking at what happens across the cluster when a Pod is deleted.\n When a request for a pod deletion is received by the API server, it first modifies the\nstate in etcd and then notifies its watchers of the deletion. Among those watchers are\nthe Kubelet and the Endpoints controller. The two sequences of events, which happen\nin parallel (marked with either A or B), are shown in figure 17.7.\nA2. Stop\ncontainers\nAPI server\nkube-proxy\nKubelet\nWorker node\nEndpoints\ncontroller\nkube-proxy\nPod\n(containers)\nClient\nDelete\npod\nB1. Pod deletion\nnoti\ufb01cation\nB2. Remove pod\nas endpoint\nA1. Pod deletion\nnoti\ufb01cation\nB3. Endpoint\nmodi\ufb01cation\nnoti\ufb01cation\nB4. Remove pod\nfrom iptables\nB4. Remove pod\nfrom iptables\niptables\niptables\nWorker node\nFigure 17.7\nSequence of events that occurs when a Pod is deleted\n \n"}, {"color": "green", "id": "text_437", "label": "494\nCHAPTER 17\nBest practices for developing apps\nIn the A sequence of events, you\u2019ll see that as soon as the Kubelet receives the notifica-\ntion that the pod should be terminated, it initiates the shutdown sequence as explained\nin section 17.2.5 (run the pre-stop hook, send SIGTERM, wait for a period of time, and\nthen forcibly kill the container if it hasn\u2019t yet terminated on its own). If the app\nresponds to the SIGTERM by immediately ceasing to receive client requests, any client\ntrying to connect to it will receive a Connection Refused error. The time it takes for\nthis to happen from the time the pod is deleted is relatively short because of the direct\npath from the API server to the Kubelet.\n Now, let\u2019s look at what happens in the other sequence of events\u2014the one leading\nup to the pod being removed from the iptables rules (sequence B in the figure).\nWhen the Endpoints controller (which runs in the Controller Manager in the Kuber-\nnetes Control Plane) receives the notification of the Pod being deleted, it removes\nthe pod as an endpoint in all services that the pod is a part of. It does this by modify-\ning the Endpoints API object by sending a REST request to the API server. The API\nserver then notifies all clients watching the Endpoints object. Among those watchers\nare all the kube-proxies running on the worker nodes. Each of these proxies then\nupdates the iptables rules on its node, which is what prevents new connections\nfrom being forwarded to the terminating pod. An important detail here is that\nremoving the iptables rules has no effect on existing connections\u2014clients who are\nalready connected to the pod will still send additional requests to the pod through\nthose existing connections.\n Both of these sequences of events happen in parallel. Most likely, the time it takes\nto shut down the app\u2019s process in the pod is slightly shorter than the time required for\nthe iptables rules to be updated. The chain of events that leads to iptables rules\nbeing updated is considerably longer (see figure 17.8), because the event must first\nreach the Endpoints controller, which then sends a new request to the API server, and\nA2. Send\nSIGTERM\nAPI server\nAPI server\nKubelet\nEndpoints\ncontroller\nContainer(s)\nA1. Watch\nnoti\ufb01cation\n(pod modi\ufb01ed)\nB1. Watch\nnoti\ufb01cation\n(pod modi\ufb01ed)\nB2. Remove pod\u2019s IP\nfrom endpoints\nkube-proxy\nB4. Update\niptables\nrules\niptables\nkube-proxy\niptables\nTime\nB3. Watch noti\ufb01cation\n(endpoints changed)\nFigure 17.8\nTimeline of events when pod is deleted\n \n", "shape": "dot", "size": 10, "title": "494\nCHAPTER 17\nBest practices for developing apps\nIn the A sequence of events, you\u2019ll see that as soon as the Kubelet receives the notifica-\ntion that the pod should be terminated, it initiates the shutdown sequence as explained\nin section 17.2.5 (run the pre-stop hook, send SIGTERM, wait for a period of time, and\nthen forcibly kill the container if it hasn\u2019t yet terminated on its own). If the app\nresponds to the SIGTERM by immediately ceasing to receive client requests, any client\ntrying to connect to it will receive a Connection Refused error. The time it takes for\nthis to happen from the time the pod is deleted is relatively short because of the direct\npath from the API server to the Kubelet.\n Now, let\u2019s look at what happens in the other sequence of events\u2014the one leading\nup to the pod being removed from the iptables rules (sequence B in the figure).\nWhen the Endpoints controller (which runs in the Controller Manager in the Kuber-\nnetes Control Plane) receives the notification of the Pod being deleted, it removes\nthe pod as an endpoint in all services that the pod is a part of. It does this by modify-\ning the Endpoints API object by sending a REST request to the API server. The API\nserver then notifies all clients watching the Endpoints object. Among those watchers\nare all the kube-proxies running on the worker nodes. Each of these proxies then\nupdates the iptables rules on its node, which is what prevents new connections\nfrom being forwarded to the terminating pod. An important detail here is that\nremoving the iptables rules has no effect on existing connections\u2014clients who are\nalready connected to the pod will still send additional requests to the pod through\nthose existing connections.\n Both of these sequences of events happen in parallel. Most likely, the time it takes\nto shut down the app\u2019s process in the pod is slightly shorter than the time required for\nthe iptables rules to be updated. The chain of events that leads to iptables rules\nbeing updated is considerably longer (see figure 17.8), because the event must first\nreach the Endpoints controller, which then sends a new request to the API server, and\nA2. Send\nSIGTERM\nAPI server\nAPI server\nKubelet\nEndpoints\ncontroller\nContainer(s)\nA1. Watch\nnoti\ufb01cation\n(pod modi\ufb01ed)\nB1. Watch\nnoti\ufb01cation\n(pod modi\ufb01ed)\nB2. Remove pod\u2019s IP\nfrom endpoints\nkube-proxy\nB4. Update\niptables\nrules\niptables\nkube-proxy\niptables\nTime\nB3. Watch noti\ufb01cation\n(endpoints changed)\nFigure 17.8\nTimeline of events when pod is deleted\n \n"}, {"color": "green", "id": "text_438", "label": "495\nEnsuring all client requests are handled properly\nthen the API server must notify the kube-proxy before the proxy finally modifies the\niptables rules. A high probability exists that the SIGTERM signal will be sent well\nbefore the iptables rules are updated on all nodes.\n The end result is that the pod may still receive client requests after it was sent the\ntermination signal. If the app closes the server socket and stops accepting connections\nimmediately, this will cause clients to receive \u201cConnection Refused\u201d types of errors\n(similar to what happens at pod startup if your app isn\u2019t capable of accepting connec-\ntions immediately and you don\u2019t define a readiness probe for it). \nSOLVING THE PROBLEM\nGoogling solutions to this problem makes it seem as though adding a readiness probe\nto your pod will solve the problem. Supposedly, all you need to do is make the readi-\nness probe start failing as soon as the pod receives the SIGTERM. This is supposed to\ncause the pod to be removed as the endpoint of the service. But the removal would\nhappen only after the readiness probe fails for a few consecutive times (this is configu-\nrable in the readiness probe spec). And, obviously, the removal then still needs to\nreach the kube-proxy before the pod is removed from iptables rules. \n In reality, the readiness probe has absolutely no bearing on the whole process at\nall. The Endpoints controller removes the pod from the service Endpoints as soon as\nit receives notice of the pod being deleted (when the deletionTimestamp field in the\npod\u2019s spec is no longer null). From that point on, the result of the readiness probe\nis irrelevant.\n What\u2019s the proper solution to the problem? How can you make sure all requests\nare handled fully?\n It\u2019s clear the pod needs to keep accepting connections even after it receives the ter-\nmination signal up until all the kube-proxies have finished updating the iptables\nrules. Well, it\u2019s not only the kube-proxies. There may also be Ingress controllers or\nload balancers forwarding connections to the pod directly, without going through the\nService (iptables). This also includes clients using client-side load-balancing. To\nensure none of the clients experience broken connections, you\u2019d have to wait until all\nof them somehow notify you they\u2019ll no longer forward connections to the pod. \n That\u2019s impossible, because all those components are distributed across many dif-\nferent computers. Even if you knew the location of every one of them and could wait\nuntil all of them say it\u2019s okay to shut down the pod, what do you do if one of them\ndoesn\u2019t respond? How long do you wait for the response? Remember, during that\ntime, you\u2019re holding up the shut-down process. \n The only reasonable thing you can do is wait for a long-enough time to ensure all\nthe proxies have done their job. But how long is long enough? A few seconds should\nbe enough in most situations, but there\u2019s no guarantee it will suffice every time. When\nthe API server or the Endpoints controller is overloaded, it may take longer for the\nnotification to reach the kube-proxy. It\u2019s important to understand that you can\u2019t solve\nthe problem perfectly, but even adding a 5- or 10-second delay should improve the\nuser experience considerably. You can use a longer delay, but don\u2019t go overboard,\n \n", "shape": "dot", "size": 10, "title": "495\nEnsuring all client requests are handled properly\nthen the API server must notify the kube-proxy before the proxy finally modifies the\niptables rules. A high probability exists that the SIGTERM signal will be sent well\nbefore the iptables rules are updated on all nodes.\n The end result is that the pod may still receive client requests after it was sent the\ntermination signal. If the app closes the server socket and stops accepting connections\nimmediately, this will cause clients to receive \u201cConnection Refused\u201d types of errors\n(similar to what happens at pod startup if your app isn\u2019t capable of accepting connec-\ntions immediately and you don\u2019t define a readiness probe for it). \nSOLVING THE PROBLEM\nGoogling solutions to this problem makes it seem as though adding a readiness probe\nto your pod will solve the problem. Supposedly, all you need to do is make the readi-\nness probe start failing as soon as the pod receives the SIGTERM. This is supposed to\ncause the pod to be removed as the endpoint of the service. But the removal would\nhappen only after the readiness probe fails for a few consecutive times (this is configu-\nrable in the readiness probe spec). And, obviously, the removal then still needs to\nreach the kube-proxy before the pod is removed from iptables rules. \n In reality, the readiness probe has absolutely no bearing on the whole process at\nall. The Endpoints controller removes the pod from the service Endpoints as soon as\nit receives notice of the pod being deleted (when the deletionTimestamp field in the\npod\u2019s spec is no longer null). From that point on, the result of the readiness probe\nis irrelevant.\n What\u2019s the proper solution to the problem? How can you make sure all requests\nare handled fully?\n It\u2019s clear the pod needs to keep accepting connections even after it receives the ter-\nmination signal up until all the kube-proxies have finished updating the iptables\nrules. Well, it\u2019s not only the kube-proxies. There may also be Ingress controllers or\nload balancers forwarding connections to the pod directly, without going through the\nService (iptables). This also includes clients using client-side load-balancing. To\nensure none of the clients experience broken connections, you\u2019d have to wait until all\nof them somehow notify you they\u2019ll no longer forward connections to the pod. \n That\u2019s impossible, because all those components are distributed across many dif-\nferent computers. Even if you knew the location of every one of them and could wait\nuntil all of them say it\u2019s okay to shut down the pod, what do you do if one of them\ndoesn\u2019t respond? How long do you wait for the response? Remember, during that\ntime, you\u2019re holding up the shut-down process. \n The only reasonable thing you can do is wait for a long-enough time to ensure all\nthe proxies have done their job. But how long is long enough? A few seconds should\nbe enough in most situations, but there\u2019s no guarantee it will suffice every time. When\nthe API server or the Endpoints controller is overloaded, it may take longer for the\nnotification to reach the kube-proxy. It\u2019s important to understand that you can\u2019t solve\nthe problem perfectly, but even adding a 5- or 10-second delay should improve the\nuser experience considerably. You can use a longer delay, but don\u2019t go overboard,\n \n"}, {"color": "green", "id": "text_439", "label": "496\nCHAPTER 17\nBest practices for developing apps\nbecause the delay will prevent the container from shutting down promptly and will\ncause the pod to be shown in lists long after it has been deleted, which is always frus-\ntrating to the user deleting the pod.\nWRAPPING UP THIS SECTION\nTo recap\u2014properly shutting down an application includes these steps:\n\uf0a1Wait for a few seconds, then stop accepting new connections. \n\uf0a1Close all keep-alive connections not in the middle of a request.\n\uf0a1Wait for all active requests to finish.\n\uf0a1Then shut down completely.\nTo understand what\u2019s happening with the connections and requests during this pro-\ncess, examine figure 17.9 carefully.\nNot as simple as exiting the process immediately upon receiving the termination sig-\nnal, right? Is it worth going through all this? That\u2019s for you to decide. But the least you\ncan do is add a pre-stop hook that waits a few seconds, like the one in the following\nlisting, perhaps.\n    lifecycle:                    \n      preStop:                    \n        exec:                     \n          command:                \n          - sh\n          - -c\n          - \"sleep 5\"\nListing 17.7\nA pre-stop hook for preventing broken connections\nDelay (few seconds)\nKey:\nConnection\nRequest\niptables rules\nupdated on all nodes\n(no new connections\nafter this point)\nStop\naccepting new\nconnections\nClose inactive\nkeep-alive\nconnections\nand wait for\nactive requests\nto \ufb01nish\nWhen last\nactive request\ncompletes,\nshut down\ncompletely\nTime\nSIGTERM\nFigure 17.9\nProperly handling existing and new connections after receiving a termination signal\n \n", "shape": "dot", "size": 10, "title": "496\nCHAPTER 17\nBest practices for developing apps\nbecause the delay will prevent the container from shutting down promptly and will\ncause the pod to be shown in lists long after it has been deleted, which is always frus-\ntrating to the user deleting the pod.\nWRAPPING UP THIS SECTION\nTo recap\u2014properly shutting down an application includes these steps:\n\uf0a1Wait for a few seconds, then stop accepting new connections. \n\uf0a1Close all keep-alive connections not in the middle of a request.\n\uf0a1Wait for all active requests to finish.\n\uf0a1Then shut down completely.\nTo understand what\u2019s happening with the connections and requests during this pro-\ncess, examine figure 17.9 carefully.\nNot as simple as exiting the process immediately upon receiving the termination sig-\nnal, right? Is it worth going through all this? That\u2019s for you to decide. But the least you\ncan do is add a pre-stop hook that waits a few seconds, like the one in the following\nlisting, perhaps.\n    lifecycle:                    \n      preStop:                    \n        exec:                     \n          command:                \n          - sh\n          - -c\n          - \"sleep 5\"\nListing 17.7\nA pre-stop hook for preventing broken connections\nDelay (few seconds)\nKey:\nConnection\nRequest\niptables rules\nupdated on all nodes\n(no new connections\nafter this point)\nStop\naccepting new\nconnections\nClose inactive\nkeep-alive\nconnections\nand wait for\nactive requests\nto \ufb01nish\nWhen last\nactive request\ncompletes,\nshut down\ncompletely\nTime\nSIGTERM\nFigure 17.9\nProperly handling existing and new connections after receiving a termination signal\n \n"}, {"color": "green", "id": "text_440", "label": "497\nMaking your apps easy to run and manage in Kubernetes\nThis way, you don\u2019t need to modify the code of your app at all. If your app already\nensures all in-flight requests are processed completely, this pre-stop delay may be all\nyou need.\n17.4\nMaking your apps easy to run and manage in Kubernetes\nI hope you now have a better sense of how to make your apps handle clients nicely.\nNow we\u2019ll look at other aspects of how an app should be built to make it easier to man-\nage in Kubernetes.\n17.4.1 Making manageable container images\nWhen you package your app into an image, you can choose to include the app\u2019s\nbinary executable and any additional libraries it needs, or you can package up a whole\nOS filesystem along with the app. Way too many people do this, even though it\u2019s usu-\nally unnecessary.\n Do you need every single file from an OS distribution in your image? Probably not.\nMost of the files will never be used and will make your image larger than it needs to\nbe. Sure, the layering of images makes sure each individual layer is downloaded only\nonce, but even having to wait longer than necessary the first time a pod is scheduled\nto a node is undesirable.\n Deploying new pods and scaling them should be fast. This demands having small\nimages without unnecessary cruft. If you\u2019re building apps using the Go language, your\nimages don\u2019t need to include anything else apart from the app\u2019s single binary execut-\nable file. This makes Go-based container images extremely small and perfect for\nKubernetes.\nTIP\nUse the FROM scratch directive in the Dockerfile for these images.\nBut in practice, you\u2019ll soon see these minimal images are extremely difficult to debug.\nThe first time you need to run a tool such as ping, dig, curl, or something similar\ninside the container, you\u2019ll realize how important it is for container images to also\ninclude at least a limited set of these tools. I can\u2019t tell you what to include and what\nnot to include in your images, because it depends on how you do things, so you\u2019ll\nneed to find the sweet spot yourself.\n17.4.2 Properly tagging your images and using imagePullPolicy wisely\nYou\u2019ll also soon learn that referring to the latest image tag in your pod manifests will\ncause problems, because you can\u2019t tell which version of the image each individual pod\nreplica is running. Even if initially all your pod replicas run the same image version, if\nyou push a new version of the image under the latest tag, and then pods are resched-\nuled (or you scale up your Deployment), the new pods will run the new version,\nwhereas the old ones will still be running the old one. Also, using the latest tag\nmakes it impossible to roll back to a previous version (unless you push the old version\nof the image again).\n \n", "shape": "dot", "size": 10, "title": "497\nMaking your apps easy to run and manage in Kubernetes\nThis way, you don\u2019t need to modify the code of your app at all. If your app already\nensures all in-flight requests are processed completely, this pre-stop delay may be all\nyou need.\n17.4\nMaking your apps easy to run and manage in Kubernetes\nI hope you now have a better sense of how to make your apps handle clients nicely.\nNow we\u2019ll look at other aspects of how an app should be built to make it easier to man-\nage in Kubernetes.\n17.4.1 Making manageable container images\nWhen you package your app into an image, you can choose to include the app\u2019s\nbinary executable and any additional libraries it needs, or you can package up a whole\nOS filesystem along with the app. Way too many people do this, even though it\u2019s usu-\nally unnecessary.\n Do you need every single file from an OS distribution in your image? Probably not.\nMost of the files will never be used and will make your image larger than it needs to\nbe. Sure, the layering of images makes sure each individual layer is downloaded only\nonce, but even having to wait longer than necessary the first time a pod is scheduled\nto a node is undesirable.\n Deploying new pods and scaling them should be fast. This demands having small\nimages without unnecessary cruft. If you\u2019re building apps using the Go language, your\nimages don\u2019t need to include anything else apart from the app\u2019s single binary execut-\nable file. This makes Go-based container images extremely small and perfect for\nKubernetes.\nTIP\nUse the FROM scratch directive in the Dockerfile for these images.\nBut in practice, you\u2019ll soon see these minimal images are extremely difficult to debug.\nThe first time you need to run a tool such as ping, dig, curl, or something similar\ninside the container, you\u2019ll realize how important it is for container images to also\ninclude at least a limited set of these tools. I can\u2019t tell you what to include and what\nnot to include in your images, because it depends on how you do things, so you\u2019ll\nneed to find the sweet spot yourself.\n17.4.2 Properly tagging your images and using imagePullPolicy wisely\nYou\u2019ll also soon learn that referring to the latest image tag in your pod manifests will\ncause problems, because you can\u2019t tell which version of the image each individual pod\nreplica is running. Even if initially all your pod replicas run the same image version, if\nyou push a new version of the image under the latest tag, and then pods are resched-\nuled (or you scale up your Deployment), the new pods will run the new version,\nwhereas the old ones will still be running the old one. Also, using the latest tag\nmakes it impossible to roll back to a previous version (unless you push the old version\nof the image again).\n \n"}, {"color": "green", "id": "text_441", "label": "498\nCHAPTER 17\nBest practices for developing apps\n It\u2019s almost mandatory to use tags containing a proper version designator instead\nof latest, except maybe in development. Keep in mind that if you use mutable tags\n(you push changes to the same tag), you\u2019ll need to set the imagePullPolicy field in\nthe pod spec to Always. But if you use that in production pods, be aware of the big\ncaveat associated with it. If the image pull policy is set to Always, the container run-\ntime will contact the image registry every time a new pod is deployed. This slows\ndown pod startup a bit, because the node needs to check if the image has been mod-\nified. Worse yet, this policy prevents the pod from starting up when the registry can-\nnot be contacted.\n17.4.3 Using multi-dimensional instead of single-dimensional labels\nDon\u2019t forget to label all your resources, not only Pods. Make sure you add multiple\nlabels to each resource, so they can be selected across each individual dimension. You\n(or the ops team) will be grateful you did it when the number of resources increases.\n Labels may include things like\n\uf0a1The name of the application (or perhaps microservice) the resource belongs to\n\uf0a1Application tier (front-end, back-end, and so on)\n\uf0a1Environment (development, QA, staging, production, and so on)\n\uf0a1Version\n\uf0a1Type of release (stable, canary, green or blue for green/blue deployments, and\nso on)\n\uf0a1Tenant (if you\u2019re running separate pods for each tenant instead of using name-\nspaces)\n\uf0a1Shard for sharded systems\nThis will allow you to manage resources in groups instead of individually and make it\neasy to see where each resource belongs.\n17.4.4 Describing each resource through annotations\nTo add additional information to your resources use annotations. At the least,\nresources should contain an annotation describing the resource and an annotation\nwith contact information of the person responsible for it. \n In a microservices architecture, pods could contain an annotation that lists the\nnames of the other services the pod is using. This makes it possible to show dependen-\ncies between pods. Other annotations could include build and version information\nand metadata used by tooling or graphical user interfaces (icon names, and so on).\n Both labels and annotations make managing running applications much easier, but\nnothing is worse than when an application starts crashing and you don\u2019t know why.\n17.4.5 Providing information on why the process terminated\nNothing is more frustrating than having to figure out why a container terminated\n(or is even terminating continuously), especially if it happens at the worst possible\n \n", "shape": "dot", "size": 10, "title": "498\nCHAPTER 17\nBest practices for developing apps\n It\u2019s almost mandatory to use tags containing a proper version designator instead\nof latest, except maybe in development. Keep in mind that if you use mutable tags\n(you push changes to the same tag), you\u2019ll need to set the imagePullPolicy field in\nthe pod spec to Always. But if you use that in production pods, be aware of the big\ncaveat associated with it. If the image pull policy is set to Always, the container run-\ntime will contact the image registry every time a new pod is deployed. This slows\ndown pod startup a bit, because the node needs to check if the image has been mod-\nified. Worse yet, this policy prevents the pod from starting up when the registry can-\nnot be contacted.\n17.4.3 Using multi-dimensional instead of single-dimensional labels\nDon\u2019t forget to label all your resources, not only Pods. Make sure you add multiple\nlabels to each resource, so they can be selected across each individual dimension. You\n(or the ops team) will be grateful you did it when the number of resources increases.\n Labels may include things like\n\uf0a1The name of the application (or perhaps microservice) the resource belongs to\n\uf0a1Application tier (front-end, back-end, and so on)\n\uf0a1Environment (development, QA, staging, production, and so on)\n\uf0a1Version\n\uf0a1Type of release (stable, canary, green or blue for green/blue deployments, and\nso on)\n\uf0a1Tenant (if you\u2019re running separate pods for each tenant instead of using name-\nspaces)\n\uf0a1Shard for sharded systems\nThis will allow you to manage resources in groups instead of individually and make it\neasy to see where each resource belongs.\n17.4.4 Describing each resource through annotations\nTo add additional information to your resources use annotations. At the least,\nresources should contain an annotation describing the resource and an annotation\nwith contact information of the person responsible for it. \n In a microservices architecture, pods could contain an annotation that lists the\nnames of the other services the pod is using. This makes it possible to show dependen-\ncies between pods. Other annotations could include build and version information\nand metadata used by tooling or graphical user interfaces (icon names, and so on).\n Both labels and annotations make managing running applications much easier, but\nnothing is worse than when an application starts crashing and you don\u2019t know why.\n17.4.5 Providing information on why the process terminated\nNothing is more frustrating than having to figure out why a container terminated\n(or is even terminating continuously), especially if it happens at the worst possible\n \n"}, {"color": "green", "id": "text_442", "label": "499\nMaking your apps easy to run and manage in Kubernetes\nmoment. Be nice to the ops people and make their lives easier by including all the\nnecessary debug information in your log files. \n But to make triage even easier, you can use one other Kubernetes feature that\nmakes it possible to show the reason why a container terminated in the pod\u2019s status.\nYou do this by having the process write a termination message to a specific file in the\ncontainer\u2019s filesystem. The contents of this file are read by the Kubelet when the con-\ntainer terminates and are shown in the output of kubectl describe pod. If an applica-\ntion uses this mechanism, an operator can quickly see why the app terminated without\neven having to look at the container logs. \n The default file the process needs to write the message to is /dev/termination-log,\nbut it can be changed by setting the terminationMessagePath field in the container\ndefinition in the pod spec. \n You can see this in action by running a pod whose container dies immediately, as\nshown in the following listing.\napiVersion: v1\nkind: Pod\nmetadata:\n  name: pod-with-termination-message\nspec:\n  containers:\n  - image: busybox\n    name: main\n    terminationMessagePath: /var/termination-reason         \n    command:\n    - sh\n    - -c\n    - \u0027echo \"I\u0027\u0027ve had enough\" \u003e /var/termination-reason ; exit 1\u0027   \nWhen running this pod, you\u2019ll soon see the pod\u2019s status shown as CrashLoopBackOff.\nIf you then use kubectl describe, you can see why the container died, without having\nto dig down into its logs, as shown in the following listing.\n$ kubectl describe po\nName:           pod-with-termination-message\n...\nContainers:\n...\n    State:      Waiting\n      Reason:   CrashLoopBackOff\n    Last State: Terminated\n      Reason:   Error\n      Message:  I\u0027ve had enough          \n      Exit Code:        1\n      Started:          Tue, 21 Feb 2017 21:38:31 +0100\n      Finished:         Tue, 21 Feb 2017 21:38:31 +0100\nListing 17.8\nPod writing a termination message: termination-message.yaml\nListing 17.9\nSeeing the container\u2019s termination message with kubectl describe\nYou\u2019re overriding the \ndefault path of the \ntermination message file.\nThe container\nwill write the\nmessage to\nthe file just\nbefore exiting.\nYou can see the reason \nwhy the container died \nwithout having to \ninspect its logs.\n \n", "shape": "dot", "size": 10, "title": "499\nMaking your apps easy to run and manage in Kubernetes\nmoment. Be nice to the ops people and make their lives easier by including all the\nnecessary debug information in your log files. \n But to make triage even easier, you can use one other Kubernetes feature that\nmakes it possible to show the reason why a container terminated in the pod\u2019s status.\nYou do this by having the process write a termination message to a specific file in the\ncontainer\u2019s filesystem. The contents of this file are read by the Kubelet when the con-\ntainer terminates and are shown in the output of kubectl describe pod. If an applica-\ntion uses this mechanism, an operator can quickly see why the app terminated without\neven having to look at the container logs. \n The default file the process needs to write the message to is /dev/termination-log,\nbut it can be changed by setting the terminationMessagePath field in the container\ndefinition in the pod spec. \n You can see this in action by running a pod whose container dies immediately, as\nshown in the following listing.\napiVersion: v1\nkind: Pod\nmetadata:\n  name: pod-with-termination-message\nspec:\n  containers:\n  - image: busybox\n    name: main\n    terminationMessagePath: /var/termination-reason         \n    command:\n    - sh\n    - -c\n    - \u0027echo \"I\u0027\u0027ve had enough\" \u003e /var/termination-reason ; exit 1\u0027   \nWhen running this pod, you\u2019ll soon see the pod\u2019s status shown as CrashLoopBackOff.\nIf you then use kubectl describe, you can see why the container died, without having\nto dig down into its logs, as shown in the following listing.\n$ kubectl describe po\nName:           pod-with-termination-message\n...\nContainers:\n...\n    State:      Waiting\n      Reason:   CrashLoopBackOff\n    Last State: Terminated\n      Reason:   Error\n      Message:  I\u0027ve had enough          \n      Exit Code:        1\n      Started:          Tue, 21 Feb 2017 21:38:31 +0100\n      Finished:         Tue, 21 Feb 2017 21:38:31 +0100\nListing 17.8\nPod writing a termination message: termination-message.yaml\nListing 17.9\nSeeing the container\u2019s termination message with kubectl describe\nYou\u2019re overriding the \ndefault path of the \ntermination message file.\nThe container\nwill write the\nmessage to\nthe file just\nbefore exiting.\nYou can see the reason \nwhy the container died \nwithout having to \ninspect its logs.\n \n"}, {"color": "green", "id": "text_443", "label": "500\nCHAPTER 17\nBest practices for developing apps\n    Ready:              False\n    Restart Count:      6\nAs you can see, the \u201cI\u2019ve had enough\u201d message the process wrote to the file /var/ter-\nmination-reason is shown in the container\u2019s Last State section. Note that this mecha-\nnism isn\u2019t limited only to containers that crash. It can also be used in pods that run a\ncompletable task and terminate successfully (you\u2019ll find an example in the file termi-\nnation-message-success.yaml). \n This mechanism is great for terminated containers, but you\u2019ll probably agree that\na similar mechanism would also be useful for showing app-specific status messages of\nrunning, not only terminated, containers. Kubernetes currently doesn\u2019t provide any\nsuch functionality and I\u2019m not aware of any plans to introduce it.\nNOTE\nIf the container doesn\u2019t write the message to any file, you can set the\nterminationMessagePolicy field to FallbackToLogsOnError. In that case,\nthe last few lines of the container\u2019s log are used as its termination message\n(but only when the container terminates unsuccessfully).\n17.4.6 Handling application logs\nWhile we\u2019re on the subject of application logging, let\u2019s reiterate that apps should write\nto the standard output instead of files. This makes it easy to view logs with the kubectl\nlogs command. \nTIP\nIf a container crashes and is replaced with a new one, you\u2019ll see the new\ncontainer\u2019s log. To see the previous container\u2019s logs, use the --previous\noption with kubectl logs.\nIf the application logs to a file instead of the standard output, you can display the log\nfile using an alternative approach: \n$ kubectl exec \u003cpod\u003e cat \u003clogfile\u003e\nThis executes the cat command inside the container and streams the logs back to\nkubectl, which prints them out in your terminal. \nCOPYING LOG AND OTHER FILES TO AND FROM A CONTAINER\nYou can also copy the log file to your local machine using the kubectl cp command,\nwhich we haven\u2019t looked at yet. It allows you to copy files from and into a container. For\nexample, if a pod called foo-pod and its single container contains a file at /var/log/\nfoo.log, you can transfer it to your local machine with the following command:\n$ kubectl cp foo-pod:/var/log/foo.log foo.log\nTo copy a file from your local machine into the pod, specify the pod\u2019s name in the sec-\nond argument:\n$ kubectl cp localfile foo-pod:/etc/remotefile\n \n", "shape": "dot", "size": 10, "title": "500\nCHAPTER 17\nBest practices for developing apps\n    Ready:              False\n    Restart Count:      6\nAs you can see, the \u201cI\u2019ve had enough\u201d message the process wrote to the file /var/ter-\nmination-reason is shown in the container\u2019s Last State section. Note that this mecha-\nnism isn\u2019t limited only to containers that crash. It can also be used in pods that run a\ncompletable task and terminate successfully (you\u2019ll find an example in the file termi-\nnation-message-success.yaml). \n This mechanism is great for terminated containers, but you\u2019ll probably agree that\na similar mechanism would also be useful for showing app-specific status messages of\nrunning, not only terminated, containers. Kubernetes currently doesn\u2019t provide any\nsuch functionality and I\u2019m not aware of any plans to introduce it.\nNOTE\nIf the container doesn\u2019t write the message to any file, you can set the\nterminationMessagePolicy field to FallbackToLogsOnError. In that case,\nthe last few lines of the container\u2019s log are used as its termination message\n(but only when the container terminates unsuccessfully).\n17.4.6 Handling application logs\nWhile we\u2019re on the subject of application logging, let\u2019s reiterate that apps should write\nto the standard output instead of files. This makes it easy to view logs with the kubectl\nlogs command. \nTIP\nIf a container crashes and is replaced with a new one, you\u2019ll see the new\ncontainer\u2019s log. To see the previous container\u2019s logs, use the --previous\noption with kubectl logs.\nIf the application logs to a file instead of the standard output, you can display the log\nfile using an alternative approach: \n$ kubectl exec \u003cpod\u003e cat \u003clogfile\u003e\nThis executes the cat command inside the container and streams the logs back to\nkubectl, which prints them out in your terminal. \nCOPYING LOG AND OTHER FILES TO AND FROM A CONTAINER\nYou can also copy the log file to your local machine using the kubectl cp command,\nwhich we haven\u2019t looked at yet. It allows you to copy files from and into a container. For\nexample, if a pod called foo-pod and its single container contains a file at /var/log/\nfoo.log, you can transfer it to your local machine with the following command:\n$ kubectl cp foo-pod:/var/log/foo.log foo.log\nTo copy a file from your local machine into the pod, specify the pod\u2019s name in the sec-\nond argument:\n$ kubectl cp localfile foo-pod:/etc/remotefile\n \n"}, {"color": "green", "id": "text_444", "label": "501\nMaking your apps easy to run and manage in Kubernetes\nThis copies the file localfile to /etc/remotefile inside the pod\u2019s container. If the pod has\nmore than one container, you specify the container using the -c containerName option.\nUSING CENTRALIZED LOGGING\nIn a production system, you\u2019ll want to use a centralized, cluster-wide logging solution,\nso all your logs are collected and (permanently) stored in a central location. This\nallows you to examine historical logs and analyze trends. Without such a system, a\npod\u2019s logs are only available while the pod exists. As soon as it\u2019s deleted, its logs are\ndeleted also. \n Kubernetes by itself doesn\u2019t provide any kind of centralized logging. The compo-\nnents necessary for providing a centralized storage and analysis of all the container\nlogs must be provided by additional components, which usually run as regular pods in\nthe cluster. \n Deploying centralized logging solutions is easy. All you need to do is deploy a few\nYAML/JSON manifests and you\u2019re good to go. On Google Kubernetes Engine, it\u2019s\neven easier. Check the Enable Stackdriver Logging checkbox when setting up the clus-\nter. Setting up centralized logging on an on-premises Kubernetes cluster is beyond the\nscope of this book, but I\u2019ll give you a quick overview of how it\u2019s usually done.\n You may have already heard of the ELK stack composed of ElasticSearch, Logstash,\nand Kibana. A slightly modified variation is the EFK stack, where Logstash is replaced\nwith FluentD. \n When using the EFK stack for centralized logging, each Kubernetes cluster node\nruns a FluentD agent (usually as a pod deployed through a DaemonSet), which is\nresponsible for gathering the logs from the containers, tagging them with pod-specific\ninformation, and delivering them to ElasticSearch, which stores them persistently.\nElasticSearch is also deployed as a pod somewhere in the cluster. The logs can then be\nviewed and analyzed in a web browser through Kibana, which is a web tool for visualiz-\ning ElasticSearch data. It also usually runs as a pod and is exposed through a Service.\nThe three components of the EFK stack are shown in the following figure.\nNOTE\nIn the next chapter, you\u2019ll learn about Helm charts. You can use charts\ncreated by the Kubernetes community to deploy the EFK stack instead of cre-\nating your own YAML manifests. \nNode 1\nContainer logs\nKibana\nWeb\nbrowser\nFluentD\nNode 2\nContainer logs\nFluentD\nNode 3\nContainer logs\nFluentD\nElasticSearch\nFigure 17.10\nCentralized logging with FluentD, ElasticSearch, and Kibana\n \n", "shape": "dot", "size": 10, "title": "501\nMaking your apps easy to run and manage in Kubernetes\nThis copies the file localfile to /etc/remotefile inside the pod\u2019s container. If the pod has\nmore than one container, you specify the container using the -c containerName option.\nUSING CENTRALIZED LOGGING\nIn a production system, you\u2019ll want to use a centralized, cluster-wide logging solution,\nso all your logs are collected and (permanently) stored in a central location. This\nallows you to examine historical logs and analyze trends. Without such a system, a\npod\u2019s logs are only available while the pod exists. As soon as it\u2019s deleted, its logs are\ndeleted also. \n Kubernetes by itself doesn\u2019t provide any kind of centralized logging. The compo-\nnents necessary for providing a centralized storage and analysis of all the container\nlogs must be provided by additional components, which usually run as regular pods in\nthe cluster. \n Deploying centralized logging solutions is easy. All you need to do is deploy a few\nYAML/JSON manifests and you\u2019re good to go. On Google Kubernetes Engine, it\u2019s\neven easier. Check the Enable Stackdriver Logging checkbox when setting up the clus-\nter. Setting up centralized logging on an on-premises Kubernetes cluster is beyond the\nscope of this book, but I\u2019ll give you a quick overview of how it\u2019s usually done.\n You may have already heard of the ELK stack composed of ElasticSearch, Logstash,\nand Kibana. A slightly modified variation is the EFK stack, where Logstash is replaced\nwith FluentD. \n When using the EFK stack for centralized logging, each Kubernetes cluster node\nruns a FluentD agent (usually as a pod deployed through a DaemonSet), which is\nresponsible for gathering the logs from the containers, tagging them with pod-specific\ninformation, and delivering them to ElasticSearch, which stores them persistently.\nElasticSearch is also deployed as a pod somewhere in the cluster. The logs can then be\nviewed and analyzed in a web browser through Kibana, which is a web tool for visualiz-\ning ElasticSearch data. It also usually runs as a pod and is exposed through a Service.\nThe three components of the EFK stack are shown in the following figure.\nNOTE\nIn the next chapter, you\u2019ll learn about Helm charts. You can use charts\ncreated by the Kubernetes community to deploy the EFK stack instead of cre-\nating your own YAML manifests. \nNode 1\nContainer logs\nKibana\nWeb\nbrowser\nFluentD\nNode 2\nContainer logs\nFluentD\nNode 3\nContainer logs\nFluentD\nElasticSearch\nFigure 17.10\nCentralized logging with FluentD, ElasticSearch, and Kibana\n \n"}, {"color": "green", "id": "text_445", "label": "502\nCHAPTER 17\nBest practices for developing apps\nHANDLING MULTI-LINE LOG STATEMENTS\nThe FluentD agent stores each line of the log file as an entry in the ElasticSearch\ndata store. There\u2019s one problem with that. Log statements spanning multiple lines,\nsuch as exception stack traces in Java, appear as separate entries in the centralized\nlogging system. \n To solve this problem, you can have the apps output JSON instead of plain text.\nThis way, a multiline log statement can be stored and shown in Kibana as a single\nentry. But that makes viewing logs with kubectl logs much less human-friendly. \n The solution may be to keep outputting human-readable logs to standard output,\nwhile writing JSON logs to a file and having them processed by FluentD. This requires\nconfiguring the node-level FluentD agent appropriately or adding a logging sidecar\ncontainer to every pod. \n17.5\nBest practices for development and testing\nWe\u2019ve talked about what to be mindful of when developing apps, but we haven\u2019t\ntalked about the development and testing workflows that will help you streamline\nthose processes. I don\u2019t want to go into too much detail here, because everyone needs\nto find what works best for them, but here are a few starting points.\n17.5.1 Running apps outside of Kubernetes during development\nWhen you\u2019re developing an app that will run in a production Kubernetes cluster, does\nthat mean you also need to run it in Kubernetes during development? Not really. Hav-\ning to build the app after each minor change, then build the container image, push it\nto a registry, and then re-deploy the pods would make development slow and painful.\nLuckily, you don\u2019t need to go through all that trouble.\n You can always develop and run apps on your local machine, the way you\u2019re used\nto. After all, an app running in Kubernetes is a regular (although isolated) process\nrunning on one of the cluster nodes. If the app depends on certain features the\nKubernetes environment provides, you can easily replicate that environment on your\ndevelopment machine.\n I\u2019m not even talking about running the app in a container. Most of the time, you\ndon\u2019t need that\u2014you can usually run the app directly from your IDE. \nCONNECTING TO BACKEND SERVICES\nIn production, if the app connects to a backend Service and uses the BACKEND_SERVICE\n_HOST and BACKEND_SERVICE_PORT environment variables to find the Service\u2019s coordi-\nnates, you can obviously set those environment variables on your local machine manu-\nally and point them to the backend Service, regardless of if it\u2019s running outside or\ninside a Kubernetes cluster. If it\u2019s running inside Kubernetes, you can always (at least\ntemporarily) make the Service accessible externally by changing it to a NodePort or a\nLoadBalancer-type Service. \n \n", "shape": "dot", "size": 10, "title": "502\nCHAPTER 17\nBest practices for developing apps\nHANDLING MULTI-LINE LOG STATEMENTS\nThe FluentD agent stores each line of the log file as an entry in the ElasticSearch\ndata store. There\u2019s one problem with that. Log statements spanning multiple lines,\nsuch as exception stack traces in Java, appear as separate entries in the centralized\nlogging system. \n To solve this problem, you can have the apps output JSON instead of plain text.\nThis way, a multiline log statement can be stored and shown in Kibana as a single\nentry. But that makes viewing logs with kubectl logs much less human-friendly. \n The solution may be to keep outputting human-readable logs to standard output,\nwhile writing JSON logs to a file and having them processed by FluentD. This requires\nconfiguring the node-level FluentD agent appropriately or adding a logging sidecar\ncontainer to every pod. \n17.5\nBest practices for development and testing\nWe\u2019ve talked about what to be mindful of when developing apps, but we haven\u2019t\ntalked about the development and testing workflows that will help you streamline\nthose processes. I don\u2019t want to go into too much detail here, because everyone needs\nto find what works best for them, but here are a few starting points.\n17.5.1 Running apps outside of Kubernetes during development\nWhen you\u2019re developing an app that will run in a production Kubernetes cluster, does\nthat mean you also need to run it in Kubernetes during development? Not really. Hav-\ning to build the app after each minor change, then build the container image, push it\nto a registry, and then re-deploy the pods would make development slow and painful.\nLuckily, you don\u2019t need to go through all that trouble.\n You can always develop and run apps on your local machine, the way you\u2019re used\nto. After all, an app running in Kubernetes is a regular (although isolated) process\nrunning on one of the cluster nodes. If the app depends on certain features the\nKubernetes environment provides, you can easily replicate that environment on your\ndevelopment machine.\n I\u2019m not even talking about running the app in a container. Most of the time, you\ndon\u2019t need that\u2014you can usually run the app directly from your IDE. \nCONNECTING TO BACKEND SERVICES\nIn production, if the app connects to a backend Service and uses the BACKEND_SERVICE\n_HOST and BACKEND_SERVICE_PORT environment variables to find the Service\u2019s coordi-\nnates, you can obviously set those environment variables on your local machine manu-\nally and point them to the backend Service, regardless of if it\u2019s running outside or\ninside a Kubernetes cluster. If it\u2019s running inside Kubernetes, you can always (at least\ntemporarily) make the Service accessible externally by changing it to a NodePort or a\nLoadBalancer-type Service. \n \n"}, {"color": "green", "id": "text_446", "label": "503\nBest practices for development and testing\nCONNECTING TO THE API SERVER\nSimilarly, if your app requires access to the Kubernetes API server when running\ninside a Kubernetes cluster, it can easily talk to the API server from outside the cluster\nduring development. If it uses the ServiceAccount\u2019s token to authenticate itself, you\ncan always copy the ServiceAccount\u2019s Secret\u2019s files to your local machine with kubectl\ncp. The API server doesn\u2019t care if the client accessing it is inside or outside the cluster. \n If the app uses an ambassador container like the one described in chapter 8, you\ndon\u2019t even need those Secret files. Run kubectl proxy on your local machine, run\nyour app locally, and it should be ready to talk to your local kubectl proxy (as long as\nit and the ambassador container bind the proxy to the same port).\n In this case, you\u2019ll need to make sure the user account your local kubectl is using\nhas the same privileges as the ServiceAccount the app will run under.\nRUNNING INSIDE A CONTAINER EVEN DURING DEVELOPMENT\nWhen during development you absolutely have to run the app in a container for what-\never reason, there is a way of avoiding having to build the container image every time.\nInstead of baking the binaries into the image, you can always mount your local filesys-\ntem into the container through Docker volumes, for example. This way, after you\nbuild a new version of the app\u2019s binaries, all you need to do is restart the container (or\nnot even that, if hot-redeploy is supported). No need to rebuild the image.\n17.5.2 Using Minikube in development\nAs you can see, nothing forces you to run your app inside Kubernetes during develop-\nment. But you may do that anyway to see how the app behaves in a true Kubernetes\nenvironment.\n You may have used Minikube to run examples in this book. Although a Minikube\ncluster runs only a single worker node, it\u2019s nevertheless a valuable method of trying\nout your app in Kubernetes (and, of course, developing all the resource manifests that\nmake up your complete application). Minikube doesn\u2019t offer everything that a proper\nmulti-node Kubernetes cluster usually provides, but in most cases, that doesn\u2019t matter.\nMOUNTING LOCAL FILES INTO THE MINIKUBE VM AND THEN INTO YOUR CONTAINERS\nWhen you\u2019re developing with Minikube and you\u2019d like to try out every change to your\napp in your Kubernetes cluster, you can mount your local filesystem into the Minikube\nVM using the minikube mount command and then mount it into your containers\nthrough a hostPath volume. You\u2019ll find additional instructions on how to do that\nin the Minikube documentation at https:/\n/github.com/kubernetes/minikube/tree/\nmaster/docs.\nUSING THE DOCKER DAEMON INSIDE THE MINIKUBE VM TO BUILD YOUR IMAGES\nIf you\u2019re developing your app with Minikube and planning to build the container\nimage after every change, you can use the Docker daemon inside the Minikube VM to\ndo the building, instead of having to build the image through your local Docker dae-\nmon, push it to a registry, and then have it pulled by the daemon in the VM. To use\n \n", "shape": "dot", "size": 10, "title": "503\nBest practices for development and testing\nCONNECTING TO THE API SERVER\nSimilarly, if your app requires access to the Kubernetes API server when running\ninside a Kubernetes cluster, it can easily talk to the API server from outside the cluster\nduring development. If it uses the ServiceAccount\u2019s token to authenticate itself, you\ncan always copy the ServiceAccount\u2019s Secret\u2019s files to your local machine with kubectl\ncp. The API server doesn\u2019t care if the client accessing it is inside or outside the cluster. \n If the app uses an ambassador container like the one described in chapter 8, you\ndon\u2019t even need those Secret files. Run kubectl proxy on your local machine, run\nyour app locally, and it should be ready to talk to your local kubectl proxy (as long as\nit and the ambassador container bind the proxy to the same port).\n In this case, you\u2019ll need to make sure the user account your local kubectl is using\nhas the same privileges as the ServiceAccount the app will run under.\nRUNNING INSIDE A CONTAINER EVEN DURING DEVELOPMENT\nWhen during development you absolutely have to run the app in a container for what-\never reason, there is a way of avoiding having to build the container image every time.\nInstead of baking the binaries into the image, you can always mount your local filesys-\ntem into the container through Docker volumes, for example. This way, after you\nbuild a new version of the app\u2019s binaries, all you need to do is restart the container (or\nnot even that, if hot-redeploy is supported). No need to rebuild the image.\n17.5.2 Using Minikube in development\nAs you can see, nothing forces you to run your app inside Kubernetes during develop-\nment. But you may do that anyway to see how the app behaves in a true Kubernetes\nenvironment.\n You may have used Minikube to run examples in this book. Although a Minikube\ncluster runs only a single worker node, it\u2019s nevertheless a valuable method of trying\nout your app in Kubernetes (and, of course, developing all the resource manifests that\nmake up your complete application). Minikube doesn\u2019t offer everything that a proper\nmulti-node Kubernetes cluster usually provides, but in most cases, that doesn\u2019t matter.\nMOUNTING LOCAL FILES INTO THE MINIKUBE VM AND THEN INTO YOUR CONTAINERS\nWhen you\u2019re developing with Minikube and you\u2019d like to try out every change to your\napp in your Kubernetes cluster, you can mount your local filesystem into the Minikube\nVM using the minikube mount command and then mount it into your containers\nthrough a hostPath volume. You\u2019ll find additional instructions on how to do that\nin the Minikube documentation at https:/\n/github.com/kubernetes/minikube/tree/\nmaster/docs.\nUSING THE DOCKER DAEMON INSIDE THE MINIKUBE VM TO BUILD YOUR IMAGES\nIf you\u2019re developing your app with Minikube and planning to build the container\nimage after every change, you can use the Docker daemon inside the Minikube VM to\ndo the building, instead of having to build the image through your local Docker dae-\nmon, push it to a registry, and then have it pulled by the daemon in the VM. To use\n \n"}, {"color": "green", "id": "text_447", "label": "504\nCHAPTER 17\nBest practices for developing apps\nMinikube\u2019s Docker daemon, all you need to do is point your DOCKER_HOST environ-\nment variable to it. Luckily, this is much easier than it sounds. All you need to do is\nrun the following command on your local machine:\n$ eval $(minikube docker-env)\nThis will set all the required environment variables for you. You then build your\nimages the same way as if the Docker daemon was running on your local machine.\nAfter you build the image, you don\u2019t need to push it anywhere, because it\u2019s already\nstored locally on the Minikube VM, which means new pods can use the image immedi-\nately. If your pods are already running, you either need to delete them or kill their\ncontainers so they\u2019re restarted.\nBUILDING IMAGES LOCALLY AND COPYING THEM OVER TO THE MINIKUBE VM DIRECTLY\nIf you can\u2019t use the daemon inside the VM to build the images, you still have a way to\navoid having to push the image to a registry and have the Kubelet running in the\nMinikube VM pull it. If you build the image on your local machine, you can copy it\nover to the Minikube VM with the following command:\n$ docker save \u003cimage\u003e | (eval $(minikube docker-env) \u0026\u0026 docker load)\nAs before, the image is immediately ready to be used in a pod. But make sure the\nimagePullPolicy in your pod spec isn\u2019t set to Always, because that would cause the\nimage to be pulled from the external registry again and you\u2019d lose the changes you\u2019ve\ncopied over.\nCOMBINING MINIKUBE WITH A PROPER KUBERNETES CLUSTER\nYou have virtually no limit when developing apps with Minikube. You can even com-\nbine a Minikube cluster with a proper Kubernetes cluster. I sometimes run my devel-\nopment workloads in my local Minikube cluster and have them talk to my other\nworkloads that are deployed in a remote multi-node Kubernetes cluster thousands of\nmiles away. \n Once I\u2019m finished with development, I can move my local workloads to the remote\ncluster with no modifications and with absolutely no problems thanks to how Kuber-\nnetes abstracts away the underlying infrastructure from the app.\n17.5.3 Versioning and auto-deploying resource manifests\nBecause Kubernetes uses a declarative model, you never have to figure out the current\nstate of your deployed resources and issue imperative commands to bring that state to\nwhat you desire. All you need to do is tell Kubernetes your desired state and it will take\nall the necessary actions to reconcile the cluster state with the desired state.\n You can store your collection of resource manifests in a Version Control System,\nenabling you to perform code reviews, keep an audit trail, and roll back changes\nwhenever necessary. After each commit, you can run the kubectl apply command to\nhave your changes reflected in your deployed resources. \n \n", "shape": "dot", "size": 10, "title": "504\nCHAPTER 17\nBest practices for developing apps\nMinikube\u2019s Docker daemon, all you need to do is point your DOCKER_HOST environ-\nment variable to it. Luckily, this is much easier than it sounds. All you need to do is\nrun the following command on your local machine:\n$ eval $(minikube docker-env)\nThis will set all the required environment variables for you. You then build your\nimages the same way as if the Docker daemon was running on your local machine.\nAfter you build the image, you don\u2019t need to push it anywhere, because it\u2019s already\nstored locally on the Minikube VM, which means new pods can use the image immedi-\nately. If your pods are already running, you either need to delete them or kill their\ncontainers so they\u2019re restarted.\nBUILDING IMAGES LOCALLY AND COPYING THEM OVER TO THE MINIKUBE VM DIRECTLY\nIf you can\u2019t use the daemon inside the VM to build the images, you still have a way to\navoid having to push the image to a registry and have the Kubelet running in the\nMinikube VM pull it. If you build the image on your local machine, you can copy it\nover to the Minikube VM with the following command:\n$ docker save \u003cimage\u003e | (eval $(minikube docker-env) \u0026\u0026 docker load)\nAs before, the image is immediately ready to be used in a pod. But make sure the\nimagePullPolicy in your pod spec isn\u2019t set to Always, because that would cause the\nimage to be pulled from the external registry again and you\u2019d lose the changes you\u2019ve\ncopied over.\nCOMBINING MINIKUBE WITH A PROPER KUBERNETES CLUSTER\nYou have virtually no limit when developing apps with Minikube. You can even com-\nbine a Minikube cluster with a proper Kubernetes cluster. I sometimes run my devel-\nopment workloads in my local Minikube cluster and have them talk to my other\nworkloads that are deployed in a remote multi-node Kubernetes cluster thousands of\nmiles away. \n Once I\u2019m finished with development, I can move my local workloads to the remote\ncluster with no modifications and with absolutely no problems thanks to how Kuber-\nnetes abstracts away the underlying infrastructure from the app.\n17.5.3 Versioning and auto-deploying resource manifests\nBecause Kubernetes uses a declarative model, you never have to figure out the current\nstate of your deployed resources and issue imperative commands to bring that state to\nwhat you desire. All you need to do is tell Kubernetes your desired state and it will take\nall the necessary actions to reconcile the cluster state with the desired state.\n You can store your collection of resource manifests in a Version Control System,\nenabling you to perform code reviews, keep an audit trail, and roll back changes\nwhenever necessary. After each commit, you can run the kubectl apply command to\nhave your changes reflected in your deployed resources. \n \n"}, {"color": "green", "id": "text_448", "label": "505\nBest practices for development and testing\n If you run an agent that periodically (or when it detects a new commit) checks out\nyour manifests from the Version Control System (VCS), and then runs the apply com-\nmand, you can manage your running apps simply by committing changes to the VCS\nwithout having to manually talk to the Kubernetes API server. Luckily, the people at\nBox (which coincidently was used to host this book\u2019s manuscript and other materials)\ndeveloped and released a tool called kube-applier, which does exactly what I described.\nYou\u2019ll find the tool\u2019s source code at https:/\n/github.com/box/kube-applier.\n You can use multiple branches to deploy the manifests to a development, QA, stag-\ning, and production cluster (or in different namespaces in the same cluster).\n17.5.4 Introducing Ksonnet as an alternative to writing YAML/JSON \nmanifests\nWe\u2019ve seen a number of YAML manifests throughout the book. I don\u2019t see writing\nYAML as too big of a problem, especially once you learn how to use kubectl explain\nto see the available options, but some people do. \n Just as I was finalizing the manuscript for this book, a new tool called Ksonnet was\nannounced. It\u2019s a library built on top of Jsonnet, which is a data templating language\nfor building JSON data structures. Instead of writing the complete JSON by hand, it\nlets you define parameterized JSON fragments, give them a name, and then build a\nfull JSON manifest by referencing those fragments by name, instead of repeating the\nsame JSON code in multiple locations\u2014much like you use functions or methods in a\nprogramming language. \n Ksonnet defines the fragments you\u2019d find in Kubernetes resource manifests, allow-\ning you to quickly build a complete Kubernetes resource JSON manifest with much\nless code. The following listing shows an example.\nlocal k = import \"../ksonnet-lib/ksonnet.beta.1/k.libsonnet\";\nlocal container = k.core.v1.container;\nlocal deployment = k.apps.v1beta1.deployment;\nlocal kubiaContainer =                              \n  container.default(\"kubia\", \"luksa/kubia:v1\") +    \n  container.helpers.namedPort(\"http\", 8080);        \ndeployment.default(\"kubia\", kubiaContainer) +    \ndeployment.mixin.spec.replicas(3)                \nThe kubia.ksonnet file shown in the listing is converted to a full JSON Deployment\nmanifest when you run the following command:\n$ jsonnet kubia.ksonnet\nListing 17.10\nThe kubia Deployment written with Ksonnet: kubia.ksonnet\nThis defines a container called kubia, \nwhich uses the luksa/kubia:v1 image \nand includes a port called http.\nThis will be expanded into a full \nDeployment resource. The kubiaContainer \ndefined here will be included in the \nDeployment\u2019s pod template.\n \n", "shape": "dot", "size": 10, "title": "505\nBest practices for development and testing\n If you run an agent that periodically (or when it detects a new commit) checks out\nyour manifests from the Version Control System (VCS), and then runs the apply com-\nmand, you can manage your running apps simply by committing changes to the VCS\nwithout having to manually talk to the Kubernetes API server. Luckily, the people at\nBox (which coincidently was used to host this book\u2019s manuscript and other materials)\ndeveloped and released a tool called kube-applier, which does exactly what I described.\nYou\u2019ll find the tool\u2019s source code at https:/\n/github.com/box/kube-applier.\n You can use multiple branches to deploy the manifests to a development, QA, stag-\ning, and production cluster (or in different namespaces in the same cluster).\n17.5.4 Introducing Ksonnet as an alternative to writing YAML/JSON \nmanifests\nWe\u2019ve seen a number of YAML manifests throughout the book. I don\u2019t see writing\nYAML as too big of a problem, especially once you learn how to use kubectl explain\nto see the available options, but some people do. \n Just as I was finalizing the manuscript for this book, a new tool called Ksonnet was\nannounced. It\u2019s a library built on top of Jsonnet, which is a data templating language\nfor building JSON data structures. Instead of writing the complete JSON by hand, it\nlets you define parameterized JSON fragments, give them a name, and then build a\nfull JSON manifest by referencing those fragments by name, instead of repeating the\nsame JSON code in multiple locations\u2014much like you use functions or methods in a\nprogramming language. \n Ksonnet defines the fragments you\u2019d find in Kubernetes resource manifests, allow-\ning you to quickly build a complete Kubernetes resource JSON manifest with much\nless code. The following listing shows an example.\nlocal k = import \"../ksonnet-lib/ksonnet.beta.1/k.libsonnet\";\nlocal container = k.core.v1.container;\nlocal deployment = k.apps.v1beta1.deployment;\nlocal kubiaContainer =                              \n  container.default(\"kubia\", \"luksa/kubia:v1\") +    \n  container.helpers.namedPort(\"http\", 8080);        \ndeployment.default(\"kubia\", kubiaContainer) +    \ndeployment.mixin.spec.replicas(3)                \nThe kubia.ksonnet file shown in the listing is converted to a full JSON Deployment\nmanifest when you run the following command:\n$ jsonnet kubia.ksonnet\nListing 17.10\nThe kubia Deployment written with Ksonnet: kubia.ksonnet\nThis defines a container called kubia, \nwhich uses the luksa/kubia:v1 image \nand includes a port called http.\nThis will be expanded into a full \nDeployment resource. The kubiaContainer \ndefined here will be included in the \nDeployment\u2019s pod template.\n \n"}, {"color": "green", "id": "text_449", "label": "506\nCHAPTER 17\nBest practices for developing apps\nThe power of Ksonnet and Jsonnet becomes apparent when you realize you can define\nyour own higher-level fragments and make all your manifests consistent and duplica-\ntion-free. You\u2019ll find more information on using and installing Ksonnet and Jsonnet at\nhttps:/\n/github.com/ksonnet/ksonnet-lib.\n17.5.5 Employing Continuous Integration and Continuous Delivery \n(CI/CD)\nWe\u2019ve touched on automating the deployment of Kubernetes resources two sections\nback, but you may want to set up a complete CI/CD pipeline for building your appli-\ncation binaries, container images, and resource manifests and then deploying them in\none or more Kubernetes clusters.\n You\u2019ll find many online resources talking about this subject. Here, I\u2019d like to point\nyou specifically to the Fabric8 project (http:/\n/fabric8.io), which is an integrated\ndevelopment platform for Kubernetes. It includes Jenkins, the well-known, open-\nsource automation system, and various other tools to deliver a full CI/CD pipeline\nfor DevOps-style development, deployment, and management of microservices on\nKubernetes.\n If you\u2019d like to build your own solution, I also suggest looking at one of the Google\nCloud Platform\u2019s online labs that talks about this subject. It\u2019s available at https:/\n/\ngithub.com/GoogleCloudPlatform/continuous-deployment-on-kubernetes.\n17.6\nSummary\nHopefully, the information in this chapter has given you an even deeper insight into\nhow Kubernetes works and will help you build apps that feel right at home when\ndeployed to a Kubernetes cluster. The aim of this chapter was to\n\uf0a1Show you how all the resources covered in this book come together to repre-\nsent a typical application running in Kubernetes.\n\uf0a1Make you think about the difference between apps that are rarely moved\nbetween machines and apps running as pods, which are relocated much more\nfrequently.\n\uf0a1Help you understand that your multi-component apps (or microservices, if you\nwill) shouldn\u2019t rely on a specific start-up order.\n\uf0a1Introduce init containers, which can be used to initialize a pod or delay the start\nof the pod\u2019s main containers until a precondition is met.\n\uf0a1Teach you about container lifecycle hooks and when to use them.\n\uf0a1Gain a deeper insight into the consequences of the distributed nature of\nKubernetes components and its eventual consistency model.\n\uf0a1Learn how to make your apps shut down properly without breaking client\nconnections.\n \n", "shape": "dot", "size": 10, "title": "506\nCHAPTER 17\nBest practices for developing apps\nThe power of Ksonnet and Jsonnet becomes apparent when you realize you can define\nyour own higher-level fragments and make all your manifests consistent and duplica-\ntion-free. You\u2019ll find more information on using and installing Ksonnet and Jsonnet at\nhttps:/\n/github.com/ksonnet/ksonnet-lib.\n17.5.5 Employing Continuous Integration and Continuous Delivery \n(CI/CD)\nWe\u2019ve touched on automating the deployment of Kubernetes resources two sections\nback, but you may want to set up a complete CI/CD pipeline for building your appli-\ncation binaries, container images, and resource manifests and then deploying them in\none or more Kubernetes clusters.\n You\u2019ll find many online resources talking about this subject. Here, I\u2019d like to point\nyou specifically to the Fabric8 project (http:/\n/fabric8.io), which is an integrated\ndevelopment platform for Kubernetes. It includes Jenkins, the well-known, open-\nsource automation system, and various other tools to deliver a full CI/CD pipeline\nfor DevOps-style development, deployment, and management of microservices on\nKubernetes.\n If you\u2019d like to build your own solution, I also suggest looking at one of the Google\nCloud Platform\u2019s online labs that talks about this subject. It\u2019s available at https:/\n/\ngithub.com/GoogleCloudPlatform/continuous-deployment-on-kubernetes.\n17.6\nSummary\nHopefully, the information in this chapter has given you an even deeper insight into\nhow Kubernetes works and will help you build apps that feel right at home when\ndeployed to a Kubernetes cluster. The aim of this chapter was to\n\uf0a1Show you how all the resources covered in this book come together to repre-\nsent a typical application running in Kubernetes.\n\uf0a1Make you think about the difference between apps that are rarely moved\nbetween machines and apps running as pods, which are relocated much more\nfrequently.\n\uf0a1Help you understand that your multi-component apps (or microservices, if you\nwill) shouldn\u2019t rely on a specific start-up order.\n\uf0a1Introduce init containers, which can be used to initialize a pod or delay the start\nof the pod\u2019s main containers until a precondition is met.\n\uf0a1Teach you about container lifecycle hooks and when to use them.\n\uf0a1Gain a deeper insight into the consequences of the distributed nature of\nKubernetes components and its eventual consistency model.\n\uf0a1Learn how to make your apps shut down properly without breaking client\nconnections.\n \n"}, {"color": "green", "id": "text_450", "label": "507\nSummary\n\uf0a1Give you a few small tips on how to make your apps easier to manage by keep-\ning image sizes small, adding annotations and multi-dimensional labels to all\nyour resources, and making it easier to see why an application terminated.\n\uf0a1Teach you how to develop Kubernetes apps and run them locally or in Mini-\nkube before deploying them on a proper multi-node cluster.\nIn the next and final chapter, we\u2019ll learn how you can extend Kubernetes with your\nown custom API objects and controllers and how others have done it to create com-\nplete Platform-as-a-Service solutions on top of Kubernetes.\n \n", "shape": "dot", "size": 10, "title": "507\nSummary\n\uf0a1Give you a few small tips on how to make your apps easier to manage by keep-\ning image sizes small, adding annotations and multi-dimensional labels to all\nyour resources, and making it easier to see why an application terminated.\n\uf0a1Teach you how to develop Kubernetes apps and run them locally or in Mini-\nkube before deploying them on a proper multi-node cluster.\nIn the next and final chapter, we\u2019ll learn how you can extend Kubernetes with your\nown custom API objects and controllers and how others have done it to create com-\nplete Platform-as-a-Service solutions on top of Kubernetes.\n \n"}, {"color": "green", "id": "text_451", "label": "508\nExtending Kubernetes\nYou\u2019re almost done. To wrap up, we\u2019ll look at how you can define your own API\nobjects and create controllers for those objects. We\u2019ll also look at how others have\nextended Kubernetes and built Platform-as-a-Service solutions on top of it.\n18.1\nDefining custom API objects\nThroughout the book, you\u2019ve learned about the API objects that Kubernetes pro-\nvides and how they\u2019re used to build application systems. Currently, Kubernetes\nusers mostly use only these objects even though they represent relatively low-level,\ngeneric concepts. \nThis chapter covers\n\uf0a1Adding custom objects to Kubernetes\n\uf0a1Creating a controller for the custom object\n\uf0a1Adding custom API servers\n\uf0a1Self-provisioning of services with the Kubernetes \nService Catalog\n\uf0a1Red Hat\u2019s OpenShift Container Platform\n\uf0a1Deis Workflow and Helm\n \n", "shape": "dot", "size": 10, "title": "508\nExtending Kubernetes\nYou\u2019re almost done. To wrap up, we\u2019ll look at how you can define your own API\nobjects and create controllers for those objects. We\u2019ll also look at how others have\nextended Kubernetes and built Platform-as-a-Service solutions on top of it.\n18.1\nDefining custom API objects\nThroughout the book, you\u2019ve learned about the API objects that Kubernetes pro-\nvides and how they\u2019re used to build application systems. Currently, Kubernetes\nusers mostly use only these objects even though they represent relatively low-level,\ngeneric concepts. \nThis chapter covers\n\uf0a1Adding custom objects to Kubernetes\n\uf0a1Creating a controller for the custom object\n\uf0a1Adding custom API servers\n\uf0a1Self-provisioning of services with the Kubernetes \nService Catalog\n\uf0a1Red Hat\u2019s OpenShift Container Platform\n\uf0a1Deis Workflow and Helm\n \n"}, {"color": "green", "id": "text_452", "label": "509\nDefining custom API objects\n As the Kubernetes ecosystem evolves, you\u2019ll see more and more high-level objects,\nwhich will be much more specialized than the resources Kubernetes supports today.\nInstead of dealing with Deployments, Services, ConfigMaps, and the like, you\u2019ll create\nand manage objects that represent whole applications or software services. A custom\ncontroller will observe those high-level objects and create low-level objects based on\nthem. For example, to run a messaging broker inside a Kubernetes cluster, all you\u2019ll\nneed to do is create an instance of a Queue resource and all the necessary Secrets,\nDeployments, and Services will be created by a custom Queue controller. Kubernetes\nalready provides ways of adding custom resources like this. \n18.1.1 Introducing CustomResourceDefinitions\nTo define a new resource type, all you need to do is post a CustomResourceDefinition\nobject (CRD) to the Kubernetes API server. The CustomResourceDefinition object is\nthe description of the custom resource type. Once the CRD is posted, users can then\ncreate instances of the custom resource by posting JSON or YAML manifests to the\nAPI server, the same as with any other Kubernetes resource.\nNOTE\nPrior to Kubernetes 1.7, custom resources were defined through Third-\nPartyResource objects, which were similar to CustomResourceDefinitions, but\nwere removed in version 1.8.\nCreating a CRD so that users can create objects of the new type isn\u2019t a useful feature if\nthose objects don\u2019t make something tangible happen in the cluster. Each CRD will\nusually also have an associated controller (an active component doing something\nbased on the custom objects), the same way that all the core Kubernetes resources\nhave an associated controller, as was explained in chapter 11. For this reason, to prop-\nerly show what CustomResourceDefinitions allow you to do other than adding\ninstances of a custom object, a controller must be deployed as well. You\u2019ll do that in\nthe next example.\nINTRODUCING THE EXAMPLE CUSTOMRESOURCEDEFINITION\nLet\u2019s imagine you want to allow users of your Kubernetes cluster to run static websites\nas easily as possible, without having to deal with Pods, Services, and other Kubernetes\nresources. What you want to achieve is for users to create objects of type Website that\ncontain nothing more than the website\u2019s name and the source from which the web-\nsite\u2019s files (HTML, CSS, PNG, and others) should be obtained. You\u2019ll use a Git reposi-\ntory as the source of those files. When a user creates an instance of the Website\nresource, you want Kubernetes to spin up a new web server pod and expose it through\na Service, as shown in figure 18.1.\n To create the Website resource, you want users to post manifests along the lines of\nthe one shown in the following listing.\n \n \n \n \n", "shape": "dot", "size": 10, "title": "509\nDefining custom API objects\n As the Kubernetes ecosystem evolves, you\u2019ll see more and more high-level objects,\nwhich will be much more specialized than the resources Kubernetes supports today.\nInstead of dealing with Deployments, Services, ConfigMaps, and the like, you\u2019ll create\nand manage objects that represent whole applications or software services. A custom\ncontroller will observe those high-level objects and create low-level objects based on\nthem. For example, to run a messaging broker inside a Kubernetes cluster, all you\u2019ll\nneed to do is create an instance of a Queue resource and all the necessary Secrets,\nDeployments, and Services will be created by a custom Queue controller. Kubernetes\nalready provides ways of adding custom resources like this. \n18.1.1 Introducing CustomResourceDefinitions\nTo define a new resource type, all you need to do is post a CustomResourceDefinition\nobject (CRD) to the Kubernetes API server. The CustomResourceDefinition object is\nthe description of the custom resource type. Once the CRD is posted, users can then\ncreate instances of the custom resource by posting JSON or YAML manifests to the\nAPI server, the same as with any other Kubernetes resource.\nNOTE\nPrior to Kubernetes 1.7, custom resources were defined through Third-\nPartyResource objects, which were similar to CustomResourceDefinitions, but\nwere removed in version 1.8.\nCreating a CRD so that users can create objects of the new type isn\u2019t a useful feature if\nthose objects don\u2019t make something tangible happen in the cluster. Each CRD will\nusually also have an associated controller (an active component doing something\nbased on the custom objects), the same way that all the core Kubernetes resources\nhave an associated controller, as was explained in chapter 11. For this reason, to prop-\nerly show what CustomResourceDefinitions allow you to do other than adding\ninstances of a custom object, a controller must be deployed as well. You\u2019ll do that in\nthe next example.\nINTRODUCING THE EXAMPLE CUSTOMRESOURCEDEFINITION\nLet\u2019s imagine you want to allow users of your Kubernetes cluster to run static websites\nas easily as possible, without having to deal with Pods, Services, and other Kubernetes\nresources. What you want to achieve is for users to create objects of type Website that\ncontain nothing more than the website\u2019s name and the source from which the web-\nsite\u2019s files (HTML, CSS, PNG, and others) should be obtained. You\u2019ll use a Git reposi-\ntory as the source of those files. When a user creates an instance of the Website\nresource, you want Kubernetes to spin up a new web server pod and expose it through\na Service, as shown in figure 18.1.\n To create the Website resource, you want users to post manifests along the lines of\nthe one shown in the following listing.\n \n \n \n \n"}, {"color": "green", "id": "text_453", "label": "510\nCHAPTER 18\nExtending Kubernetes\nkind: Website        \nmetadata:\n  name: kubia             \nspec:\n  gitRepo: https://github.com/luksa/kubia-website-example.git   \nLike all other resources, your resource contains a kind and a metadata.name field,\nand like most resources, it also contains a spec section. It contains a single field called\ngitRepo (you can choose the name)\u2014it specifies the Git repository containing the\nwebsite\u2019s files. You\u2019ll also need to include an apiVersion field, but you don\u2019t know yet\nwhat its value must be for custom resources.\n If you try posting this resource to Kubernetes, you\u2019ll receive an error because\nKubernetes doesn\u2019t know what a Website object is yet:\n$ kubectl create -f imaginary-kubia-website.yaml\nerror: unable to recognize \"imaginary-kubia-website.yaml\": no matches for \n\u27a5 /, Kind=Website\nBefore you can create instances of your custom object, you need to make Kubernetes\nrecognize them.\nCREATING A CUSTOMRESOURCEDEFINITION OBJECT\nTo make Kubernetes accept your custom Website resource instances, you need to post\nthe CustomResourceDefinition shown in the following listing to the API server.\napiVersion: apiextensions.k8s.io/v1beta1       \nkind: CustomResourceDefinition                 \nmetadata:\n  name: websites.extensions.example.com      \nspec:\n  scope: Namespaced                          \nListing 18.1\nAn imaginary custom resource: imaginary-kubia-website.yaml\nListing 18.2\nA CustomResourceDefinition manifest: website-crd.yaml\nWebsite\nkind: Website\nmetadata:\nname: kubia\nspec:\ngitRepo:\ngithub.com/.../kubia.git\nPod:\nkubia-website\nService:\nkubia-website\nFigure 18.1\nEach Website object should result in the creation of a Service and an HTTP \nserver Pod.\nA custom \nobject kind\nThe name of the website \n(used for naming the \nresulting Service and Pod)\nThe Git \nrepository \nholding the \nwebsite\u2019s files\nCustomResourceDefinitions belong \nto this API group and version.\nThe full\nname of\nyour\ncustom\nobject\nYou want Website resources \nto be namespaced.\n \n", "shape": "dot", "size": 10, "title": "510\nCHAPTER 18\nExtending Kubernetes\nkind: Website        \nmetadata:\n  name: kubia             \nspec:\n  gitRepo: https://github.com/luksa/kubia-website-example.git   \nLike all other resources, your resource contains a kind and a metadata.name field,\nand like most resources, it also contains a spec section. It contains a single field called\ngitRepo (you can choose the name)\u2014it specifies the Git repository containing the\nwebsite\u2019s files. You\u2019ll also need to include an apiVersion field, but you don\u2019t know yet\nwhat its value must be for custom resources.\n If you try posting this resource to Kubernetes, you\u2019ll receive an error because\nKubernetes doesn\u2019t know what a Website object is yet:\n$ kubectl create -f imaginary-kubia-website.yaml\nerror: unable to recognize \"imaginary-kubia-website.yaml\": no matches for \n\u27a5 /, Kind=Website\nBefore you can create instances of your custom object, you need to make Kubernetes\nrecognize them.\nCREATING A CUSTOMRESOURCEDEFINITION OBJECT\nTo make Kubernetes accept your custom Website resource instances, you need to post\nthe CustomResourceDefinition shown in the following listing to the API server.\napiVersion: apiextensions.k8s.io/v1beta1       \nkind: CustomResourceDefinition                 \nmetadata:\n  name: websites.extensions.example.com      \nspec:\n  scope: Namespaced                          \nListing 18.1\nAn imaginary custom resource: imaginary-kubia-website.yaml\nListing 18.2\nA CustomResourceDefinition manifest: website-crd.yaml\nWebsite\nkind: Website\nmetadata:\nname: kubia\nspec:\ngitRepo:\ngithub.com/.../kubia.git\nPod:\nkubia-website\nService:\nkubia-website\nFigure 18.1\nEach Website object should result in the creation of a Service and an HTTP \nserver Pod.\nA custom \nobject kind\nThe name of the website \n(used for naming the \nresulting Service and Pod)\nThe Git \nrepository \nholding the \nwebsite\u2019s files\nCustomResourceDefinitions belong \nto this API group and version.\nThe full\nname of\nyour\ncustom\nobject\nYou want Website resources \nto be namespaced.\n \n"}, {"color": "green", "id": "text_454", "label": "511\nDefining custom API objects\n  group: extensions.example.com                \n  version: v1                                  \n  names:                                    \n    kind: Website                           \n    singular: website                       \n    plural: websites                        \nAfter you post the descriptor to Kubernetes, it will allow you to create any number of\ninstances of the custom Website resource. \n You can create the CRD from the website-crd.yaml file available in the code archive:\n$ kubectl create -f website-crd-definition.yaml\ncustomresourcedefinition \"websites.extensions.example.com\" created\nI\u2019m sure you\u2019re wondering about the long name of the CRD. Why not call it Website?\nThe reason is to prevent name clashes. By adding a suffix to the name of the CRD\n(which will usually include the name of the organization that created the CRD), you\nkeep CRD names unique. Luckily, the long name doesn\u2019t mean you\u2019ll need to create\nyour Website resources with kind: websites.extensions.example.com, but as kind:\nWebsite, as specified in the names.kind property of the CRD. The extensions.exam-\nple.com part is the API group of your resource. \n You\u2019ve seen how creating Deployment objects requires you to set apiVersion to\napps/v1beta1 instead of v1. The part before the slash is the API group (Deployments\nbelong to the apps API group), and the part after it is the version name (v1beta1 in\nthe case of Deployments). When creating instances of the custom Website resource,\nthe apiVersion property will need to be set to extensions.example.com/v1.\nCREATING AN INSTANCE OF A CUSTOM RESOURCE\nConsidering what you learned, you\u2019ll now create a proper YAML for your Website\nresource instance. The YAML manifest is shown in the following listing.\napiVersion: extensions.example.com/v1       \nkind: Website                               \nmetadata:\n  name: kubia                                \nspec:\n  gitRepo: https://github.com/luksa/kubia-website-example.git\nThe kind of your resource is Website, and the apiVersion is composed of the API\ngroup and the version number you defined in the CustomResourceDefinition.\n Create your Website object now:\n$ kubectl create -f kubia-website.yaml\nwebsite \"kubia\" created\nListing 18.3\nA custom Website resource: kubia-website.yaml\nDefine an API group and version \nof the Website resource.\nYou need to specify the various \nforms of the custom object\u2019s name.\nYour custom API\ngroup and version\nThis manifest \ndescribes a Website \nresource instance.\nThe name of the \nWebsite instance\n \n", "shape": "dot", "size": 10, "title": "511\nDefining custom API objects\n  group: extensions.example.com                \n  version: v1                                  \n  names:                                    \n    kind: Website                           \n    singular: website                       \n    plural: websites                        \nAfter you post the descriptor to Kubernetes, it will allow you to create any number of\ninstances of the custom Website resource. \n You can create the CRD from the website-crd.yaml file available in the code archive:\n$ kubectl create -f website-crd-definition.yaml\ncustomresourcedefinition \"websites.extensions.example.com\" created\nI\u2019m sure you\u2019re wondering about the long name of the CRD. Why not call it Website?\nThe reason is to prevent name clashes. By adding a suffix to the name of the CRD\n(which will usually include the name of the organization that created the CRD), you\nkeep CRD names unique. Luckily, the long name doesn\u2019t mean you\u2019ll need to create\nyour Website resources with kind: websites.extensions.example.com, but as kind:\nWebsite, as specified in the names.kind property of the CRD. The extensions.exam-\nple.com part is the API group of your resource. \n You\u2019ve seen how creating Deployment objects requires you to set apiVersion to\napps/v1beta1 instead of v1. The part before the slash is the API group (Deployments\nbelong to the apps API group), and the part after it is the version name (v1beta1 in\nthe case of Deployments). When creating instances of the custom Website resource,\nthe apiVersion property will need to be set to extensions.example.com/v1.\nCREATING AN INSTANCE OF A CUSTOM RESOURCE\nConsidering what you learned, you\u2019ll now create a proper YAML for your Website\nresource instance. The YAML manifest is shown in the following listing.\napiVersion: extensions.example.com/v1       \nkind: Website                               \nmetadata:\n  name: kubia                                \nspec:\n  gitRepo: https://github.com/luksa/kubia-website-example.git\nThe kind of your resource is Website, and the apiVersion is composed of the API\ngroup and the version number you defined in the CustomResourceDefinition.\n Create your Website object now:\n$ kubectl create -f kubia-website.yaml\nwebsite \"kubia\" created\nListing 18.3\nA custom Website resource: kubia-website.yaml\nDefine an API group and version \nof the Website resource.\nYou need to specify the various \nforms of the custom object\u2019s name.\nYour custom API\ngroup and version\nThis manifest \ndescribes a Website \nresource instance.\nThe name of the \nWebsite instance\n \n"}, {"color": "green", "id": "text_455", "label": "512\nCHAPTER 18\nExtending Kubernetes\nThe response tells you that the API server has accepted and stored your custom\nWebsite object. Let\u2019s see if you can now retrieve it. \nRETRIEVING INSTANCES OF A CUSTOM RESOURCE\nList all the websites in your cluster:\n$ kubectl get websites\nNAME      KIND\nkubia     Website.v1.extensions.example.com\nAs with existing Kubernetes resources, you can create and then list instances of cus-\ntom resources. You can also use kubectl describe to see the details of your custom\nobject, or retrieve the whole YAML with kubectl get, as in the following listing.\n$ kubectl get website kubia -o yaml\napiVersion: extensions.example.com/v1\nkind: Website\nmetadata:\n  creationTimestamp: 2017-02-26T15:53:21Z\n  name: kubia\n  namespace: default\n  resourceVersion: \"57047\"\n  selfLink: /apis/extensions.example.com/v1/.../default/websites/kubia\n  uid: b2eb6d99-fc3b-11e6-bd71-0800270a1c50\nspec:\n  gitRepo: https://github.com/luksa/kubia-website-example.git\nNote that the resource includes everything that was in the original YAML definition,\nand that Kubernetes has initialized additional metadata fields the way it does with all\nother resources. \nDELETING AN INSTANCE OF A CUSTOM OBJECT\nObviously, in addition to creating and retrieving custom object instances, you can also\ndelete them:\n$ kubectl delete website kubia\nwebsite \"kubia\" deleted\nNOTE\nYou\u2019re deleting an instance of a Website, not the Website CRD\nresource. You could also delete the CRD object itself, but let\u2019s hold off on that\nfor a while, because you\u2019ll be creating additional Website instances in the\nnext section. \nLet\u2019s go over everything you\u2019ve done. By creating a CustomResourceDefinition object,\nyou can now store, retrieve, and delete custom objects through the Kubernetes API\nserver. These objects don\u2019t do anything yet. You\u2019ll need to create a controller to make\nthem do something. \nListing 18.4\nFull Website resource definition retrieved from the API server\n \n", "shape": "dot", "size": 10, "title": "512\nCHAPTER 18\nExtending Kubernetes\nThe response tells you that the API server has accepted and stored your custom\nWebsite object. Let\u2019s see if you can now retrieve it. \nRETRIEVING INSTANCES OF A CUSTOM RESOURCE\nList all the websites in your cluster:\n$ kubectl get websites\nNAME      KIND\nkubia     Website.v1.extensions.example.com\nAs with existing Kubernetes resources, you can create and then list instances of cus-\ntom resources. You can also use kubectl describe to see the details of your custom\nobject, or retrieve the whole YAML with kubectl get, as in the following listing.\n$ kubectl get website kubia -o yaml\napiVersion: extensions.example.com/v1\nkind: Website\nmetadata:\n  creationTimestamp: 2017-02-26T15:53:21Z\n  name: kubia\n  namespace: default\n  resourceVersion: \"57047\"\n  selfLink: /apis/extensions.example.com/v1/.../default/websites/kubia\n  uid: b2eb6d99-fc3b-11e6-bd71-0800270a1c50\nspec:\n  gitRepo: https://github.com/luksa/kubia-website-example.git\nNote that the resource includes everything that was in the original YAML definition,\nand that Kubernetes has initialized additional metadata fields the way it does with all\nother resources. \nDELETING AN INSTANCE OF A CUSTOM OBJECT\nObviously, in addition to creating and retrieving custom object instances, you can also\ndelete them:\n$ kubectl delete website kubia\nwebsite \"kubia\" deleted\nNOTE\nYou\u2019re deleting an instance of a Website, not the Website CRD\nresource. You could also delete the CRD object itself, but let\u2019s hold off on that\nfor a while, because you\u2019ll be creating additional Website instances in the\nnext section. \nLet\u2019s go over everything you\u2019ve done. By creating a CustomResourceDefinition object,\nyou can now store, retrieve, and delete custom objects through the Kubernetes API\nserver. These objects don\u2019t do anything yet. You\u2019ll need to create a controller to make\nthem do something. \nListing 18.4\nFull Website resource definition retrieved from the API server\n \n"}, {"color": "green", "id": "text_456", "label": "513\nDefining custom API objects\n In general, the point of creating custom objects like this isn\u2019t always to make some-\nthing happen when the object is created. Certain custom objects are used to store data\ninstead of using a more generic mechanism such as a ConfigMap. Applications run-\nning inside pods can query the API server for those objects and read whatever is\nstored in them. \n But in this case, we said you wanted the existence of a Website object to result in\nthe spinning up of a web server serving the contents of the Git repository referenced\nin the object. We\u2019ll look at how to do that next.\n18.1.2 Automating custom resources with custom controllers\nTo make your Website objects run a web server pod exposed through a Service, you\u2019ll\nneed to build and deploy a Website controller, which will watch the API server for the\ncreation of Website objects and then create the Service and the web server Pod for\neach of them. \n To make sure the Pod is managed and survives node failures, the controller will\ncreate a Deployment resource instead of an unmanaged Pod directly. The controller\u2019s\noperation is summarized in figure 18.2.\nI\u2019ve written a simple initial version of the controller, which works well enough to\nshow CRDs and the controller in action, but it\u2019s far from being production-ready,\nbecause it\u2019s overly simplified. The container image is available at docker.io/luksa/\nwebsite-controller:latest, and the source code is at https:/\n/github.com/luksa/k8s-\nwebsite-controller. Instead of going through its source code, I\u2019ll explain what the con-\ntroller does.\nAPI server\nWebsites\nWebsite:\nkubia\nDeployments\nDeployment:\nkubia-website\nServices\nService:\nkubia-website\nWebsite\ncontroller\nWatches\nCreates\nFigure 18.2\nThe Website controller \nwatches for Website objects and \ncreates a Deployment and a Service.\n \n", "shape": "dot", "size": 10, "title": "513\nDefining custom API objects\n In general, the point of creating custom objects like this isn\u2019t always to make some-\nthing happen when the object is created. Certain custom objects are used to store data\ninstead of using a more generic mechanism such as a ConfigMap. Applications run-\nning inside pods can query the API server for those objects and read whatever is\nstored in them. \n But in this case, we said you wanted the existence of a Website object to result in\nthe spinning up of a web server serving the contents of the Git repository referenced\nin the object. We\u2019ll look at how to do that next.\n18.1.2 Automating custom resources with custom controllers\nTo make your Website objects run a web server pod exposed through a Service, you\u2019ll\nneed to build and deploy a Website controller, which will watch the API server for the\ncreation of Website objects and then create the Service and the web server Pod for\neach of them. \n To make sure the Pod is managed and survives node failures, the controller will\ncreate a Deployment resource instead of an unmanaged Pod directly. The controller\u2019s\noperation is summarized in figure 18.2.\nI\u2019ve written a simple initial version of the controller, which works well enough to\nshow CRDs and the controller in action, but it\u2019s far from being production-ready,\nbecause it\u2019s overly simplified. The container image is available at docker.io/luksa/\nwebsite-controller:latest, and the source code is at https:/\n/github.com/luksa/k8s-\nwebsite-controller. Instead of going through its source code, I\u2019ll explain what the con-\ntroller does.\nAPI server\nWebsites\nWebsite:\nkubia\nDeployments\nDeployment:\nkubia-website\nServices\nService:\nkubia-website\nWebsite\ncontroller\nWatches\nCreates\nFigure 18.2\nThe Website controller \nwatches for Website objects and \ncreates a Deployment and a Service.\n \n"}, {"color": "green", "id": "text_457", "label": "514\nCHAPTER 18\nExtending Kubernetes\nUNDERSTANDING WHAT THE WEBSITE CONTROLLER DOES\nImmediately upon startup, the controller starts to watch Website objects by requesting\nthe following URL:\nhttp://localhost:8001/apis/extensions.example.com/v1/websites?watch=true\nYou may recognize the hostname and port\u2014the controller isn\u2019t connecting to the\nAPI server directly, but is instead connecting to the kubectl proxy process, which\nruns in a sidecar container in the same pod and acts as the ambassador to the API\nserver (we examined the ambassador pattern in chapter 8). The proxy forwards the\nrequest to the API server, taking care of both TLS encryption and authentication\n(see figure 18.3).\nThrough the connection opened by this HTTP GET request, the API server will send\nwatch events for every change to any Website object.\n The API server sends the ADDED watch event every time a new Website object is cre-\nated. When the controller receives such an event, it extracts the Website\u2019s name and\nthe URL of the Git repository from the Website object it received in the watch event\nand creates a Deployment and a Service object by posting their JSON manifests to the\nAPI server. \n The Deployment resource contains a template for a pod with two containers\n(shown in figure 18.4): one running an nginx server and another one running a git-\nsync process, which keeps a local directory synced with the contents of a Git repo.\nThe local directory is shared with the nginx container through an emptyDir volume\n(you did something similar to that in chapter 6, but instead of keeping the local\ndirectory synced with a Git repo, you used a gitRepo volume to download the Git\nrepo\u2019s contents at pod startup; the volume\u2019s contents weren\u2019t kept in sync with the\nGit repo afterward). The Service is a NodePort Service, which exposes your web\nserver pod through a random port on each node (the same port is used on all\nnodes). When a pod is created by the Deployment object, clients can access the web-\nsite through the node port.\nPod: website-controller\nContainer: main\nWebsite controller\nGET http://localhost:8001/apis/extensions.\nexample.com/v1/websites?watch=true\nGET https://kubernetes:443/apis/extensions.\nexample.com/v1/websites?watch=true\nAuthorization: Bearer \u003ctoken\u003e\nContainer: proxy\nkubectl proxy\nAPI server\nFigure 18.3\nThe Website controller talks to the API server through a proxy (in the ambassador container).\n \n", "shape": "dot", "size": 10, "title": "514\nCHAPTER 18\nExtending Kubernetes\nUNDERSTANDING WHAT THE WEBSITE CONTROLLER DOES\nImmediately upon startup, the controller starts to watch Website objects by requesting\nthe following URL:\nhttp://localhost:8001/apis/extensions.example.com/v1/websites?watch=true\nYou may recognize the hostname and port\u2014the controller isn\u2019t connecting to the\nAPI server directly, but is instead connecting to the kubectl proxy process, which\nruns in a sidecar container in the same pod and acts as the ambassador to the API\nserver (we examined the ambassador pattern in chapter 8). The proxy forwards the\nrequest to the API server, taking care of both TLS encryption and authentication\n(see figure 18.3).\nThrough the connection opened by this HTTP GET request, the API server will send\nwatch events for every change to any Website object.\n The API server sends the ADDED watch event every time a new Website object is cre-\nated. When the controller receives such an event, it extracts the Website\u2019s name and\nthe URL of the Git repository from the Website object it received in the watch event\nand creates a Deployment and a Service object by posting their JSON manifests to the\nAPI server. \n The Deployment resource contains a template for a pod with two containers\n(shown in figure 18.4): one running an nginx server and another one running a git-\nsync process, which keeps a local directory synced with the contents of a Git repo.\nThe local directory is shared with the nginx container through an emptyDir volume\n(you did something similar to that in chapter 6, but instead of keeping the local\ndirectory synced with a Git repo, you used a gitRepo volume to download the Git\nrepo\u2019s contents at pod startup; the volume\u2019s contents weren\u2019t kept in sync with the\nGit repo afterward). The Service is a NodePort Service, which exposes your web\nserver pod through a random port on each node (the same port is used on all\nnodes). When a pod is created by the Deployment object, clients can access the web-\nsite through the node port.\nPod: website-controller\nContainer: main\nWebsite controller\nGET http://localhost:8001/apis/extensions.\nexample.com/v1/websites?watch=true\nGET https://kubernetes:443/apis/extensions.\nexample.com/v1/websites?watch=true\nAuthorization: Bearer \u003ctoken\u003e\nContainer: proxy\nkubectl proxy\nAPI server\nFigure 18.3\nThe Website controller talks to the API server through a proxy (in the ambassador container).\n \n"}, {"color": "green", "id": "text_458", "label": "515\nDefining custom API objects\nThe API server also sends a DELETED watch event when a Website resource instance is\ndeleted. Upon receiving the event, the controller deletes the Deployment and the Ser-\nvice resources it created earlier. As soon as a user deletes the Website instance, the\ncontroller will shut down and remove the web server serving that website.\nNOTE\nMy oversimplified controller isn\u2019t implemented properly. The way it\nwatches the API objects doesn\u2019t guarantee it won\u2019t miss individual watch\nevents. The proper way to watch objects through the API server is to not only\nwatch them, but also periodically re-list all objects in case any watch events\nwere missed. \nRUNNING THE CONTROLLER AS A POD\nDuring development, I ran the controller on my local development laptop and used a\nlocally running kubectl proxy process (not running as a pod) as the ambassador to\nthe Kubernetes API server. This allowed me to develop quickly, because I didn\u2019t need\nto build a container image after every change to the source code and then run it\ninside Kubernetes. \n When I\u2019m ready to deploy the controller into production, the best way is to run the\ncontroller inside Kubernetes itself, the way you do with all the other core controllers.\nTo run the controller in Kubernetes, you can deploy it through a Deployment resource.\nThe following listing shows an example of such a Deployment.\napiVersion: apps/v1beta1\nkind: Deployment\nmetadata:\n  name: website-controller\nspec:\n  replicas: 1                      \n  template:\nListing 18.5\nA Website controller Deployment: website-controller.yaml\nPod\nWebserver\ncontainer\nWeb client\ngit-sync\ncontainer\nServes website to\nweb client through\na random port\nClones Git repo\ninto volume and\nkeeps it synced\nemptyDir\nvolume\nFigure 18.4\nThe pod serving \nthe website specified in the \nWebsite object\nYou\u2019ll run a single \nreplica of the \ncontroller.\n \n", "shape": "dot", "size": 10, "title": "515\nDefining custom API objects\nThe API server also sends a DELETED watch event when a Website resource instance is\ndeleted. Upon receiving the event, the controller deletes the Deployment and the Ser-\nvice resources it created earlier. As soon as a user deletes the Website instance, the\ncontroller will shut down and remove the web server serving that website.\nNOTE\nMy oversimplified controller isn\u2019t implemented properly. The way it\nwatches the API objects doesn\u2019t guarantee it won\u2019t miss individual watch\nevents. The proper way to watch objects through the API server is to not only\nwatch them, but also periodically re-list all objects in case any watch events\nwere missed. \nRUNNING THE CONTROLLER AS A POD\nDuring development, I ran the controller on my local development laptop and used a\nlocally running kubectl proxy process (not running as a pod) as the ambassador to\nthe Kubernetes API server. This allowed me to develop quickly, because I didn\u2019t need\nto build a container image after every change to the source code and then run it\ninside Kubernetes. \n When I\u2019m ready to deploy the controller into production, the best way is to run the\ncontroller inside Kubernetes itself, the way you do with all the other core controllers.\nTo run the controller in Kubernetes, you can deploy it through a Deployment resource.\nThe following listing shows an example of such a Deployment.\napiVersion: apps/v1beta1\nkind: Deployment\nmetadata:\n  name: website-controller\nspec:\n  replicas: 1                      \n  template:\nListing 18.5\nA Website controller Deployment: website-controller.yaml\nPod\nWebserver\ncontainer\nWeb client\ngit-sync\ncontainer\nServes website to\nweb client through\na random port\nClones Git repo\ninto volume and\nkeeps it synced\nemptyDir\nvolume\nFigure 18.4\nThe pod serving \nthe website specified in the \nWebsite object\nYou\u2019ll run a single \nreplica of the \ncontroller.\n \n"}, {"color": "green", "id": "text_459", "label": "516\nCHAPTER 18\nExtending Kubernetes\n    metadata:\n      name: website-controller\n      labels:\n        app: website-controller\n    spec:\n      serviceAccountName: website-controller    \n      containers:                                    \n      - name: main                                   \n        image: luksa/website-controller              \n      - name: proxy                                  \n        image: luksa/kubectl-proxy:1.6.2             \nAs you can see, the Deployment deploys a single replica of a two-container pod. One\ncontainer runs your controller, whereas the other one is the ambassador container\nused for simpler communication with the API server. The pod runs under its own spe-\ncial ServiceAccount, so you\u2019ll need to create it before you deploy the controller:\n$ kubectl create serviceaccount website-controller\nserviceaccount \"website-controller\" created\nIf Role Based Access Control (RBAC) is enabled in your cluster, Kubernetes will not\nallow the controller to watch Website resources or create Deployments or Services. To\nallow it to do that, you\u2019ll need to bind the website-controller ServiceAccount to the\ncluster-admin ClusterRole, by creating a ClusterRoleBinding like this:\n$ kubectl create clusterrolebinding website-controller \n\u27a5 --clusterrole=cluster-admin \n\u27a5 --serviceaccount=default:website-controller\nclusterrolebinding \"website-controller\" created\nOnce you have the ServiceAccount and ClusterRoleBinding in place, you can deploy\nthe controller\u2019s Deployment. \nSEEING THE CONTROLLER IN ACTION\nWith the controller now running, create the kubia Website resource again:\n$ kubectl create -f kubia-website.yaml\nwebsite \"kubia\" created\nNow, let\u2019s check the controller\u2019s logs (shown in the following listing) to see if it has\nreceived the watch event.\n$ kubectl logs website-controller-2429717411-q43zs -c main\n2017/02/26 16:54:41 website-controller started.\n2017/02/26 16:54:47 Received watch event: ADDED: kubia: https://github.c...\n2017/02/26 16:54:47 Creating services with name kubia-website in namespa... \n2017/02/26 16:54:47 Response status: 201 Created\n2017/02/26 16:54:47 Creating deployments with name kubia-website in name... \n2017/02/26 16:54:47 Response status: 201 Created\nListing 18.6\nDisplaying logs of the Website controller\nIt will run \nunder a special \nServiceAccount.\nTwo containers: the \nmain container and \nthe proxy sidecar\n \n", "shape": "dot", "size": 10, "title": "516\nCHAPTER 18\nExtending Kubernetes\n    metadata:\n      name: website-controller\n      labels:\n        app: website-controller\n    spec:\n      serviceAccountName: website-controller    \n      containers:                                    \n      - name: main                                   \n        image: luksa/website-controller              \n      - name: proxy                                  \n        image: luksa/kubectl-proxy:1.6.2             \nAs you can see, the Deployment deploys a single replica of a two-container pod. One\ncontainer runs your controller, whereas the other one is the ambassador container\nused for simpler communication with the API server. The pod runs under its own spe-\ncial ServiceAccount, so you\u2019ll need to create it before you deploy the controller:\n$ kubectl create serviceaccount website-controller\nserviceaccount \"website-controller\" created\nIf Role Based Access Control (RBAC) is enabled in your cluster, Kubernetes will not\nallow the controller to watch Website resources or create Deployments or Services. To\nallow it to do that, you\u2019ll need to bind the website-controller ServiceAccount to the\ncluster-admin ClusterRole, by creating a ClusterRoleBinding like this:\n$ kubectl create clusterrolebinding website-controller \n\u27a5 --clusterrole=cluster-admin \n\u27a5 --serviceaccount=default:website-controller\nclusterrolebinding \"website-controller\" created\nOnce you have the ServiceAccount and ClusterRoleBinding in place, you can deploy\nthe controller\u2019s Deployment. \nSEEING THE CONTROLLER IN ACTION\nWith the controller now running, create the kubia Website resource again:\n$ kubectl create -f kubia-website.yaml\nwebsite \"kubia\" created\nNow, let\u2019s check the controller\u2019s logs (shown in the following listing) to see if it has\nreceived the watch event.\n$ kubectl logs website-controller-2429717411-q43zs -c main\n2017/02/26 16:54:41 website-controller started.\n2017/02/26 16:54:47 Received watch event: ADDED: kubia: https://github.c...\n2017/02/26 16:54:47 Creating services with name kubia-website in namespa... \n2017/02/26 16:54:47 Response status: 201 Created\n2017/02/26 16:54:47 Creating deployments with name kubia-website in name... \n2017/02/26 16:54:47 Response status: 201 Created\nListing 18.6\nDisplaying logs of the Website controller\nIt will run \nunder a special \nServiceAccount.\nTwo containers: the \nmain container and \nthe proxy sidecar\n \n"}, {"color": "green", "id": "text_460", "label": "517\nDefining custom API objects\nThe logs show that the controller received the ADDED event and that it created a Service\nand a Deployment for the kubia-website Website. The API server responded with a\n201 Created response, which means the two resources should now exist. Let\u2019s verify\nthat the Deployment, Service and the resulting Pod were created. The following list-\ning lists all Deployments, Services and Pods.\n$ kubectl get deploy,svc,po\nNAME                        DESIRED   CURRENT   UP-TO-DATE   AVAILABLE  AGE\ndeploy/kubia-website        1         1         1            1          4s\ndeploy/website-controller   1         1         1            1          5m\nNAME                CLUSTER-IP     EXTERNAL-IP   PORT(S)        AGE\nsvc/kubernetes      10.96.0.1      \u003cnone\u003e        443/TCP        38d\nsvc/kubia-website   10.101.48.23   \u003cnodes\u003e       80:32589/TCP   4s\nNAME                                     READY     STATUS    RESTARTS   AGE\npo/kubia-website-1029415133-rs715        2/2       Running   0          4s\npo/website-controller-1571685839-qzmg6   2/2       Running   1          5m\nThere they are. The kubia-website Service, through which you can access your web-\nsite, is available on port 32589 on all cluster nodes. You can access it with your browser.\nAwesome, right? \n Users of your Kubernetes cluster can now deploy static websites in seconds, with-\nout knowing anything about Pods, Services, or any other Kubernetes resources, except\nyour custom Website resource. \n Obviously, you still have room for improvement. The controller could, for exam-\nple, watch for Service objects and as soon as the node port is assigned, write the URL\nthe website is accessible at into the status section of the Website resource instance\nitself. Or it could also create an Ingress object for each website. I\u2019ll leave the imple-\nmentation of these additional features to you as an exercise.\n18.1.3 Validating custom objects\nYou may have noticed that you didn\u2019t specify any kind of validation schema in the Web-\nsite CustomResourceDefinition. Users can include any field they want in the YAML of\ntheir Website object. The API server doesn\u2019t validate the contents of the YAML (except\nthe usual fields like apiVersion, kind, and metadata), so users can create invalid\nWebsite objects (without a gitRepo field, for example). \n Is it possible to add validation to the controller and prevent invalid objects from\nbeing accepted by the API server? It isn\u2019t, because the API server first stores the object,\nthen returns a success response to the client (kubectl), and only then notifies all the\nwatchers (the controller is one of them). All the controller can really do is validate\nthe object when it receives it in a watch event, and if the object is invalid, write the\nerror message to the Website object (by updating the object through a new request to\nthe API server). The user wouldn\u2019t be notified of the error automatically. They\u2019d have\nListing 18.7\nThe Deployment, Service, and Pod created for the kubia-website\n \n", "shape": "dot", "size": 10, "title": "517\nDefining custom API objects\nThe logs show that the controller received the ADDED event and that it created a Service\nand a Deployment for the kubia-website Website. The API server responded with a\n201 Created response, which means the two resources should now exist. Let\u2019s verify\nthat the Deployment, Service and the resulting Pod were created. The following list-\ning lists all Deployments, Services and Pods.\n$ kubectl get deploy,svc,po\nNAME                        DESIRED   CURRENT   UP-TO-DATE   AVAILABLE  AGE\ndeploy/kubia-website        1         1         1            1          4s\ndeploy/website-controller   1         1         1            1          5m\nNAME                CLUSTER-IP     EXTERNAL-IP   PORT(S)        AGE\nsvc/kubernetes      10.96.0.1      \u003cnone\u003e        443/TCP        38d\nsvc/kubia-website   10.101.48.23   \u003cnodes\u003e       80:32589/TCP   4s\nNAME                                     READY     STATUS    RESTARTS   AGE\npo/kubia-website-1029415133-rs715        2/2       Running   0          4s\npo/website-controller-1571685839-qzmg6   2/2       Running   1          5m\nThere they are. The kubia-website Service, through which you can access your web-\nsite, is available on port 32589 on all cluster nodes. You can access it with your browser.\nAwesome, right? \n Users of your Kubernetes cluster can now deploy static websites in seconds, with-\nout knowing anything about Pods, Services, or any other Kubernetes resources, except\nyour custom Website resource. \n Obviously, you still have room for improvement. The controller could, for exam-\nple, watch for Service objects and as soon as the node port is assigned, write the URL\nthe website is accessible at into the status section of the Website resource instance\nitself. Or it could also create an Ingress object for each website. I\u2019ll leave the imple-\nmentation of these additional features to you as an exercise.\n18.1.3 Validating custom objects\nYou may have noticed that you didn\u2019t specify any kind of validation schema in the Web-\nsite CustomResourceDefinition. Users can include any field they want in the YAML of\ntheir Website object. The API server doesn\u2019t validate the contents of the YAML (except\nthe usual fields like apiVersion, kind, and metadata), so users can create invalid\nWebsite objects (without a gitRepo field, for example). \n Is it possible to add validation to the controller and prevent invalid objects from\nbeing accepted by the API server? It isn\u2019t, because the API server first stores the object,\nthen returns a success response to the client (kubectl), and only then notifies all the\nwatchers (the controller is one of them). All the controller can really do is validate\nthe object when it receives it in a watch event, and if the object is invalid, write the\nerror message to the Website object (by updating the object through a new request to\nthe API server). The user wouldn\u2019t be notified of the error automatically. They\u2019d have\nListing 18.7\nThe Deployment, Service, and Pod created for the kubia-website\n \n"}, {"color": "green", "id": "text_461", "label": "518\nCHAPTER 18\nExtending Kubernetes\nto notice the error message by querying the API server for the Website object. Unless\nthe user does this, they have no way of knowing whether the object is valid or not.\n This obviously isn\u2019t ideal. You\u2019d want the API server to validate the object and\nreject invalid objects immediately. Validation of custom objects was introduced in\nKubernetes version 1.8 as an alpha feature. To have the API server validate your cus-\ntom objects, you need to enable the CustomResourceValidation feature gate in the\nAPI server and specify a JSON schema in the CRD.\n18.1.4 Providing a custom API server for your custom objects\nA better way of adding support for custom objects in Kubernetes is to implement your\nown API server and have the clients talk directly to it. \nINTRODUCING API SERVER AGGREGATION\nIn Kubernetes version 1.7, you can integrate your custom API server with the main\nKubernetes API server, through API server aggregation. Initially, the Kubernetes API\nserver was a single monolithic component. From Kubernetes version 1.7, multiple\naggregated API servers will be exposed at a single location. Clients can connect to the\naggregated API and have their requests transparently forwarded to the appropriate\nAPI server. This way, the client wouldn\u2019t even be aware that multiple API servers han-\ndle different objects behind the scenes. Even the core Kubernetes API server may\neventually end up being split into multiple smaller API servers and exposed as a single\nserver through the aggregator, as shown in figure 18.5.\nIn your case, you could create an API server responsible for handling your Website\nobjects. It could validate those objects the way the core Kubernetes API server validates\nthem. You\u2019d no longer need to create a CRD to represent those objects, because you\u2019d\nimplement the Website object type into the custom API server directly. \n Generally, each API server is responsible for storing their own resources. As shown\nin figure 18.5, it can either run its own instance of etcd (or a whole etcd cluster), or it\nMain\nAPI server\nCustom\nAPI server Y\nCustom\nAPI server X\nkubectl\nUses its own etcd instance\nfor storing its resources\nUses CustomResourceDe\ufb01nitions\nin main API server as storage\nmechanism\netcd\netcd\nFigure 18.5\nAPI server aggregation\n \n", "shape": "dot", "size": 10, "title": "518\nCHAPTER 18\nExtending Kubernetes\nto notice the error message by querying the API server for the Website object. Unless\nthe user does this, they have no way of knowing whether the object is valid or not.\n This obviously isn\u2019t ideal. You\u2019d want the API server to validate the object and\nreject invalid objects immediately. Validation of custom objects was introduced in\nKubernetes version 1.8 as an alpha feature. To have the API server validate your cus-\ntom objects, you need to enable the CustomResourceValidation feature gate in the\nAPI server and specify a JSON schema in the CRD.\n18.1.4 Providing a custom API server for your custom objects\nA better way of adding support for custom objects in Kubernetes is to implement your\nown API server and have the clients talk directly to it. \nINTRODUCING API SERVER AGGREGATION\nIn Kubernetes version 1.7, you can integrate your custom API server with the main\nKubernetes API server, through API server aggregation. Initially, the Kubernetes API\nserver was a single monolithic component. From Kubernetes version 1.7, multiple\naggregated API servers will be exposed at a single location. Clients can connect to the\naggregated API and have their requests transparently forwarded to the appropriate\nAPI server. This way, the client wouldn\u2019t even be aware that multiple API servers han-\ndle different objects behind the scenes. Even the core Kubernetes API server may\neventually end up being split into multiple smaller API servers and exposed as a single\nserver through the aggregator, as shown in figure 18.5.\nIn your case, you could create an API server responsible for handling your Website\nobjects. It could validate those objects the way the core Kubernetes API server validates\nthem. You\u2019d no longer need to create a CRD to represent those objects, because you\u2019d\nimplement the Website object type into the custom API server directly. \n Generally, each API server is responsible for storing their own resources. As shown\nin figure 18.5, it can either run its own instance of etcd (or a whole etcd cluster), or it\nMain\nAPI server\nCustom\nAPI server Y\nCustom\nAPI server X\nkubectl\nUses its own etcd instance\nfor storing its resources\nUses CustomResourceDe\ufb01nitions\nin main API server as storage\nmechanism\netcd\netcd\nFigure 18.5\nAPI server aggregation\n \n"}, {"color": "green", "id": "text_462", "label": "519\nExtending Kubernetes with the Kubernetes Service Catalog\ncan store its resources in the core API server\u2019s etcd store by creating CRD instances in\nthe core API server. In that case, it needs to create a CRD object first, before creating\ninstances of the CRD, the way you did in the example.\nREGISTERING A CUSTOM API SERVER\nTo add a custom API server to your cluster, you\u2019d deploy it as a pod and expose it\nthrough a Service. Then, to integrate it into the main API server, you\u2019d deploy a YAML\nmanifest describing an APIService resource like the one in the following listing.\napiVersion: apiregistration.k8s.io/v1beta1   \nkind: APIService                             \nmetadata:\n  name: v1alpha1.extensions.example.com\nspec:\n  group: extensions.example.com           \n  version: v1alpha1                      \n  priority: 150\n  service:                    \n    name: website-api         \n    namespace: default        \nAfter creating the APIService resource from the previous listing, client requests sent\nto the main API server that contain any resource from the extensions.example.com\nAPI group and version v1alpha1 would be forwarded to the custom API server pod(s)\nexposed through the website-api Service. \nCREATING CUSTOM CLIENTS\nWhile you can create custom resources from YAML files using the regular kubectl cli-\nent, to make deployment of custom objects even easier, in addition to providing a cus-\ntom API server, you can also build a custom CLI tool. This will allow you to add\ndedicated commands for manipulating those objects, similar to how kubectl allows\ncreating Secrets, Deployments, and other resources through resource-specific com-\nmands like kubectl create secret or kubectl create deployment.\n As I\u2019ve already mentioned, custom API servers, API server aggregation, and other\nfeatures related to extending Kubernetes are currently being worked on intensively, so\nthey may change after the book is published. To get up-to-date information on the\nsubject, refer to the Kubernetes GitHub repos at http:/\n/github.com/kubernetes.\n18.2\nExtending Kubernetes with the Kubernetes Service \nCatalog\nOne of the first additional API servers that will be added to Kubernetes through API\nserver aggregation is the Service Catalog API server. The Service Catalog is a hot topic\nin the Kubernetes community, so you may want to know about it. \n Currently, for a pod to consume a service (here I use the term generally, not in\nrelation to Service resources; for example, a database service includes everything\nListing 18.8\nAn APIService YAML definition \nThis is an APIService \nresource.\nThe API group this API \nserver is responsible for\nThe supported API version\nThe Service the custom API \nserver is exposed through\n \n", "shape": "dot", "size": 10, "title": "519\nExtending Kubernetes with the Kubernetes Service Catalog\ncan store its resources in the core API server\u2019s etcd store by creating CRD instances in\nthe core API server. In that case, it needs to create a CRD object first, before creating\ninstances of the CRD, the way you did in the example.\nREGISTERING A CUSTOM API SERVER\nTo add a custom API server to your cluster, you\u2019d deploy it as a pod and expose it\nthrough a Service. Then, to integrate it into the main API server, you\u2019d deploy a YAML\nmanifest describing an APIService resource like the one in the following listing.\napiVersion: apiregistration.k8s.io/v1beta1   \nkind: APIService                             \nmetadata:\n  name: v1alpha1.extensions.example.com\nspec:\n  group: extensions.example.com           \n  version: v1alpha1                      \n  priority: 150\n  service:                    \n    name: website-api         \n    namespace: default        \nAfter creating the APIService resource from the previous listing, client requests sent\nto the main API server that contain any resource from the extensions.example.com\nAPI group and version v1alpha1 would be forwarded to the custom API server pod(s)\nexposed through the website-api Service. \nCREATING CUSTOM CLIENTS\nWhile you can create custom resources from YAML files using the regular kubectl cli-\nent, to make deployment of custom objects even easier, in addition to providing a cus-\ntom API server, you can also build a custom CLI tool. This will allow you to add\ndedicated commands for manipulating those objects, similar to how kubectl allows\ncreating Secrets, Deployments, and other resources through resource-specific com-\nmands like kubectl create secret or kubectl create deployment.\n As I\u2019ve already mentioned, custom API servers, API server aggregation, and other\nfeatures related to extending Kubernetes are currently being worked on intensively, so\nthey may change after the book is published. To get up-to-date information on the\nsubject, refer to the Kubernetes GitHub repos at http:/\n/github.com/kubernetes.\n18.2\nExtending Kubernetes with the Kubernetes Service \nCatalog\nOne of the first additional API servers that will be added to Kubernetes through API\nserver aggregation is the Service Catalog API server. The Service Catalog is a hot topic\nin the Kubernetes community, so you may want to know about it. \n Currently, for a pod to consume a service (here I use the term generally, not in\nrelation to Service resources; for example, a database service includes everything\nListing 18.8\nAn APIService YAML definition \nThis is an APIService \nresource.\nThe API group this API \nserver is responsible for\nThe supported API version\nThe Service the custom API \nserver is exposed through\n \n"}, {"color": "green", "id": "text_463", "label": "520\nCHAPTER 18\nExtending Kubernetes\nrequired to allow users to use a database in their app), someone needs to deploy the\npods providing the service, a Service resource, and possibly a Secret so the client pod\ncan use it to authenticate with the service. That someone is usually the same user\ndeploying the client pod or, if a team is dedicated to deploying these types of general\nservices, the user needs to file a ticket and wait for the team to provision the service.\nThis means the user needs to either create the manifests for all the components of the\nservice, know where to find an existing set of manifests, know how to configure it\nproperly, and deploy it manually, or wait for the other team to do it. \n But Kubernetes is supposed to be an easy-to-use, self-service system. Ideally, users\nwhose apps require a certain service (for example, a web application requiring a back-\nend database), should be able to say to Kubernetes. \u201cHey, I need a PostgreSQL data-\nbase. Please provision one and tell me where and how I can connect to it.\u201d This will\nsoon be possible through the Kubernetes Service Catalog. \n18.2.1 Introducing the Service Catalog\nAs the name suggests, the Service Catalog is a catalog of services. Users can browse\nthrough the catalog and provision instances of the services listed in the catalog by\nthemselves without having to deal with Pods, Services, ConfigMaps, and other resources\nrequired for the service to run. You\u2019ll recognize that this is similar to what you did\nwith the Website custom resource.\n Instead of adding custom resources to the API server for each type of service, the\nService Catalog introduces the following four generic API resources:\n\uf0a1A ClusterServiceBroker, which describes an (external) system that can provision\nservices\n\uf0a1A ClusterServiceClass, which describes a type of service that can be provisioned\n\uf0a1A ServiceInstance, which is one instance of a service that has been provisioned\n\uf0a1A ServiceBinding, which represents a binding between a set of clients (pods)\nand a ServiceInstance\nThe relationships between those four resources are shown in the figure 18.6 and\nexplained in the following paragraphs.\nIn a nutshell, a cluster admin creates a ClusterServiceBroker resource for each service\nbroker whose services they\u2019d like to make available in the cluster. Kubernetes then asks\nthe broker for a list of services that it can provide and creates a ClusterServiceClass\nresource for each of them. When a user requires a service to be provisioned, they create\nan ServiceInstance resource and then a ServiceBinding to bind that ServiceInstance to\nClient pods\nServiceBinding\nServiceInstance\nClusterServiceClass(es)\nClusterServiceBroker\nFigure 18.6\nThe relationships between Service Catalog API resources. \n \n", "shape": "dot", "size": 10, "title": "520\nCHAPTER 18\nExtending Kubernetes\nrequired to allow users to use a database in their app), someone needs to deploy the\npods providing the service, a Service resource, and possibly a Secret so the client pod\ncan use it to authenticate with the service. That someone is usually the same user\ndeploying the client pod or, if a team is dedicated to deploying these types of general\nservices, the user needs to file a ticket and wait for the team to provision the service.\nThis means the user needs to either create the manifests for all the components of the\nservice, know where to find an existing set of manifests, know how to configure it\nproperly, and deploy it manually, or wait for the other team to do it. \n But Kubernetes is supposed to be an easy-to-use, self-service system. Ideally, users\nwhose apps require a certain service (for example, a web application requiring a back-\nend database), should be able to say to Kubernetes. \u201cHey, I need a PostgreSQL data-\nbase. Please provision one and tell me where and how I can connect to it.\u201d This will\nsoon be possible through the Kubernetes Service Catalog. \n18.2.1 Introducing the Service Catalog\nAs the name suggests, the Service Catalog is a catalog of services. Users can browse\nthrough the catalog and provision instances of the services listed in the catalog by\nthemselves without having to deal with Pods, Services, ConfigMaps, and other resources\nrequired for the service to run. You\u2019ll recognize that this is similar to what you did\nwith the Website custom resource.\n Instead of adding custom resources to the API server for each type of service, the\nService Catalog introduces the following four generic API resources:\n\uf0a1A ClusterServiceBroker, which describes an (external) system that can provision\nservices\n\uf0a1A ClusterServiceClass, which describes a type of service that can be provisioned\n\uf0a1A ServiceInstance, which is one instance of a service that has been provisioned\n\uf0a1A ServiceBinding, which represents a binding between a set of clients (pods)\nand a ServiceInstance\nThe relationships between those four resources are shown in the figure 18.6 and\nexplained in the following paragraphs.\nIn a nutshell, a cluster admin creates a ClusterServiceBroker resource for each service\nbroker whose services they\u2019d like to make available in the cluster. Kubernetes then asks\nthe broker for a list of services that it can provide and creates a ClusterServiceClass\nresource for each of them. When a user requires a service to be provisioned, they create\nan ServiceInstance resource and then a ServiceBinding to bind that ServiceInstance to\nClient pods\nServiceBinding\nServiceInstance\nClusterServiceClass(es)\nClusterServiceBroker\nFigure 18.6\nThe relationships between Service Catalog API resources. \n \n"}, {"color": "green", "id": "text_464", "label": "521\nExtending Kubernetes with the Kubernetes Service Catalog\ntheir pods. Those pods are then injected with a Secret that holds all the necessary cre-\ndentials and other data required to connect to the provisioned ServiceInstance.\n The Service Catalog system architecture is shown in figure 18.7.\nThe components shown in the figure are explained in the following sections.\n18.2.2 Introducing the Service Catalog API server and Controller \nManager\nSimilar to core Kubernetes, the Service Catalog is a distributed system composed of\nthree components:\n\uf0a1Service Catalog API Server\n\uf0a1etcd as the storage\n\uf0a1Controller Manager, where all the controllers run\nThe four Service Catalog\u2013related resources we introduced earlier are created by post-\ning YAML/JSON manifests to the API server. It then stores them into its own etcd\ninstance or uses CustomResourceDefinitions in the main API server as an alternative\nstorage mechanism (in that case, no additional etcd instance is required). \n The controllers running in the Controller Manager are the ones doing some-\nthing with those resources. They obviously talk to the Service Catalog API server, the\nway other core Kubernetes controllers talk to the core API server. Those controllers\ndon\u2019t provision the requested services themselves. They leave that up to external\nservice brokers, which are registered by creating ServiceBroker resources in the Ser-\nvice Catalog API.\nKubernetes cluster\nExternal system(s)\nKubernetes Service Catalog\nClient pods\nProvisioned\nservices\nBroker A\nBroker B\netcd\nService\nCatalog\nAPI server\nController\nManager\nkubectl\nProvisioned\nservices\nClient pods use the\nprovisioned services\nFigure 18.7\nThe architecture of the Service Catalog\n \n", "shape": "dot", "size": 10, "title": "521\nExtending Kubernetes with the Kubernetes Service Catalog\ntheir pods. Those pods are then injected with a Secret that holds all the necessary cre-\ndentials and other data required to connect to the provisioned ServiceInstance.\n The Service Catalog system architecture is shown in figure 18.7.\nThe components shown in the figure are explained in the following sections.\n18.2.2 Introducing the Service Catalog API server and Controller \nManager\nSimilar to core Kubernetes, the Service Catalog is a distributed system composed of\nthree components:\n\uf0a1Service Catalog API Server\n\uf0a1etcd as the storage\n\uf0a1Controller Manager, where all the controllers run\nThe four Service Catalog\u2013related resources we introduced earlier are created by post-\ning YAML/JSON manifests to the API server. It then stores them into its own etcd\ninstance or uses CustomResourceDefinitions in the main API server as an alternative\nstorage mechanism (in that case, no additional etcd instance is required). \n The controllers running in the Controller Manager are the ones doing some-\nthing with those resources. They obviously talk to the Service Catalog API server, the\nway other core Kubernetes controllers talk to the core API server. Those controllers\ndon\u2019t provision the requested services themselves. They leave that up to external\nservice brokers, which are registered by creating ServiceBroker resources in the Ser-\nvice Catalog API.\nKubernetes cluster\nExternal system(s)\nKubernetes Service Catalog\nClient pods\nProvisioned\nservices\nBroker A\nBroker B\netcd\nService\nCatalog\nAPI server\nController\nManager\nkubectl\nProvisioned\nservices\nClient pods use the\nprovisioned services\nFigure 18.7\nThe architecture of the Service Catalog\n \n"}, {"color": "green", "id": "text_465", "label": "522\nCHAPTER 18\nExtending Kubernetes\n18.2.3 Introducing Service Brokers and the OpenServiceBroker API\nA cluster administrator can register one or more external ServiceBrokers in the Ser-\nvice Catalog. Every broker must implement the OpenServiceBroker API.\nINTRODUCING THE OPENSERVICEBROKER API\nThe Service Catalog talks to the broker through that API. The API is relatively simple.\nIt\u2019s a REST API providing the following operations:\n\uf0a1Retrieving the list of services with GET /v2/catalog\n\uf0a1Provisioning a service instance (PUT /v2/service_instances/:id)\n\uf0a1Updating a service instance (PATCH /v2/service_instances/:id)\n\uf0a1Binding a service instance (PUT /v2/service_instances/:id/service_bind-\nings/:binding_id)\n\uf0a1Unbinding an instance (DELETE /v2/service_instances/:id/service_bind-\nings/:binding_id)\n\uf0a1Deprovisioning a service instance (DELETE /v2/service_instances/:id)\nYou\u2019ll find the OpenServiceBroker API spec at https:/\n/github.com/openservicebro-\nkerapi/servicebroker.\nREGISTERING BROKERS IN THE SERVICE CATALOG\nThe cluster administrator registers a broker by posting a ServiceBroker resource man-\nifest to the Service Catalog API, like the one shown in the following listing.\napiVersion: servicecatalog.k8s.io/v1alpha1    \nkind: ClusterServiceBroker                                  \nmetadata:\n  name: database-broker                          \nspec:\n  url: http://database-osbapi.myorganization.org  \nThe listing describes an imaginary broker that can provision databases of different\ntypes. After the administrator creates the ClusterServiceBroker resource, a controller\nin the Service Catalog Controller Manager connects to the URL specified in the\nresource to retrieve the list of services this broker can provision.\n After the Service Catalog retrieves the list of services, it creates a ClusterService-\nClass resource for each of them. Each ClusterServiceClass resource describes a sin-\ngle type of service that can be provisioned (an example of a ClusterServiceClass is\n\u201cPostgreSQL database\u201d). Each ClusterServiceClass has one or more service plans asso-\nciated with it. These allow the user to choose the level of service they need (for exam-\nple, a database ClusterServiceClass could provide a \u201cFree\u201d plan, where the size of the\nListing 18.9\nA ClusterServiceBroker manifest: database-broker.yaml\nThe resource kind and \nthe API group and version\nThe name of this broker\nWhere the Service Catalog\ncan contact the broker\n(its OpenServiceBroker [OSB] API URL)\n \n", "shape": "dot", "size": 10, "title": "522\nCHAPTER 18\nExtending Kubernetes\n18.2.3 Introducing Service Brokers and the OpenServiceBroker API\nA cluster administrator can register one or more external ServiceBrokers in the Ser-\nvice Catalog. Every broker must implement the OpenServiceBroker API.\nINTRODUCING THE OPENSERVICEBROKER API\nThe Service Catalog talks to the broker through that API. The API is relatively simple.\nIt\u2019s a REST API providing the following operations:\n\uf0a1Retrieving the list of services with GET /v2/catalog\n\uf0a1Provisioning a service instance (PUT /v2/service_instances/:id)\n\uf0a1Updating a service instance (PATCH /v2/service_instances/:id)\n\uf0a1Binding a service instance (PUT /v2/service_instances/:id/service_bind-\nings/:binding_id)\n\uf0a1Unbinding an instance (DELETE /v2/service_instances/:id/service_bind-\nings/:binding_id)\n\uf0a1Deprovisioning a service instance (DELETE /v2/service_instances/:id)\nYou\u2019ll find the OpenServiceBroker API spec at https:/\n/github.com/openservicebro-\nkerapi/servicebroker.\nREGISTERING BROKERS IN THE SERVICE CATALOG\nThe cluster administrator registers a broker by posting a ServiceBroker resource man-\nifest to the Service Catalog API, like the one shown in the following listing.\napiVersion: servicecatalog.k8s.io/v1alpha1    \nkind: ClusterServiceBroker                                  \nmetadata:\n  name: database-broker                          \nspec:\n  url: http://database-osbapi.myorganization.org  \nThe listing describes an imaginary broker that can provision databases of different\ntypes. After the administrator creates the ClusterServiceBroker resource, a controller\nin the Service Catalog Controller Manager connects to the URL specified in the\nresource to retrieve the list of services this broker can provision.\n After the Service Catalog retrieves the list of services, it creates a ClusterService-\nClass resource for each of them. Each ClusterServiceClass resource describes a sin-\ngle type of service that can be provisioned (an example of a ClusterServiceClass is\n\u201cPostgreSQL database\u201d). Each ClusterServiceClass has one or more service plans asso-\nciated with it. These allow the user to choose the level of service they need (for exam-\nple, a database ClusterServiceClass could provide a \u201cFree\u201d plan, where the size of the\nListing 18.9\nA ClusterServiceBroker manifest: database-broker.yaml\nThe resource kind and \nthe API group and version\nThe name of this broker\nWhere the Service Catalog\ncan contact the broker\n(its OpenServiceBroker [OSB] API URL)\n \n"}, {"color": "green", "id": "text_466", "label": "523\nExtending Kubernetes with the Kubernetes Service Catalog\ndatabase is limited and the underlying storage is a spinning disk, and a \u201cPremium\u201d\nplan, with unlimited size and SSD storage). \nLISTING THE AVAILABLE SERVICES IN A CLUSTER\nUsers of the Kubernetes cluster can retrieve a list of all services that can be provi-\nsioned in the cluster with kubectl get serviceclasses, as shown in the following\nlisting.\n$ kubectl get clusterserviceclasses\nNAME                KIND\npostgres-database   ClusterServiceClass.v1alpha1.servicecatalog.k8s.io\nmysql-database      ServiceClass.v1alpha1.servicecatalog.k8s.io\nmongodb-database    ServiceClass.v1alpha1.servicecatalog.k8s.io\nThe listing shows ClusterServiceClasses for services that your imaginary database bro-\nker could provide. You can compare ClusterServiceClasses to StorageClasses, which we\ndiscussed in chapter 6. StorageClasses allow you to select the type of storage you\u2019d like\nto use in your pods, while ClusterServiceClasses allow you to select the type of service.\n You can see details of one of the ClusterServiceClasses by retrieving its YAML. An\nexample is shown in the following listing.\n$ kubectl get serviceclass postgres-database -o yaml\napiVersion: servicecatalog.k8s.io/v1alpha1\nbindable: true\nbrokerName: database-broker                     \ndescription: A PostgreSQL database\nkind: ClusterServiceClass\nmetadata:\n  name: postgres-database\n  ...\nplanUpdatable: false\nplans:\n- description: A free (but slow) PostgreSQL instance        \n  name: free                                                \n  osbFree: true                                             \n  ...\n- description: A paid (very fast) PostgreSQL instance      \n  name: premium                                            \n  osbFree: false                                           \n  ...\nThe ClusterServiceClass in the listing contains two plans\u2014a free plan, and a premium\nplan. You can see that this ClusterServiceClass is provided by the database-broker\nbroker.\nListing 18.10\nList of ClusterServiceClasses in a cluster\nListing 18.11\nA ClusterServiceClass definition\nThis ClusterServiceClass \nis provided by the \ndatabase-broker.\nA free plan for \nthis service\nA paid plan\n \n", "shape": "dot", "size": 10, "title": "523\nExtending Kubernetes with the Kubernetes Service Catalog\ndatabase is limited and the underlying storage is a spinning disk, and a \u201cPremium\u201d\nplan, with unlimited size and SSD storage). \nLISTING THE AVAILABLE SERVICES IN A CLUSTER\nUsers of the Kubernetes cluster can retrieve a list of all services that can be provi-\nsioned in the cluster with kubectl get serviceclasses, as shown in the following\nlisting.\n$ kubectl get clusterserviceclasses\nNAME                KIND\npostgres-database   ClusterServiceClass.v1alpha1.servicecatalog.k8s.io\nmysql-database      ServiceClass.v1alpha1.servicecatalog.k8s.io\nmongodb-database    ServiceClass.v1alpha1.servicecatalog.k8s.io\nThe listing shows ClusterServiceClasses for services that your imaginary database bro-\nker could provide. You can compare ClusterServiceClasses to StorageClasses, which we\ndiscussed in chapter 6. StorageClasses allow you to select the type of storage you\u2019d like\nto use in your pods, while ClusterServiceClasses allow you to select the type of service.\n You can see details of one of the ClusterServiceClasses by retrieving its YAML. An\nexample is shown in the following listing.\n$ kubectl get serviceclass postgres-database -o yaml\napiVersion: servicecatalog.k8s.io/v1alpha1\nbindable: true\nbrokerName: database-broker                     \ndescription: A PostgreSQL database\nkind: ClusterServiceClass\nmetadata:\n  name: postgres-database\n  ...\nplanUpdatable: false\nplans:\n- description: A free (but slow) PostgreSQL instance        \n  name: free                                                \n  osbFree: true                                             \n  ...\n- description: A paid (very fast) PostgreSQL instance      \n  name: premium                                            \n  osbFree: false                                           \n  ...\nThe ClusterServiceClass in the listing contains two plans\u2014a free plan, and a premium\nplan. You can see that this ClusterServiceClass is provided by the database-broker\nbroker.\nListing 18.10\nList of ClusterServiceClasses in a cluster\nListing 18.11\nA ClusterServiceClass definition\nThis ClusterServiceClass \nis provided by the \ndatabase-broker.\nA free plan for \nthis service\nA paid plan\n \n"}, {"color": "green", "id": "text_467", "label": "524\nCHAPTER 18\nExtending Kubernetes\n18.2.4 Provisioning and using a service\nLet\u2019s imagine the pods you\u2019re deploying need to use a database. You\u2019ve inspected the\nlist of available ClusterServiceClasses and have chosen to use the free plan of the\npostgres-database ClusterServiceClass. \nPROVISIONING A SERVICEINSTANCE\nTo have the database provisioned for you, all you need to do is create a Service-\nInstance resource, as shown in the following listing.\napiVersion: servicecatalog.k8s.io/v1alpha1\nkind: ServiceInstance\nmetadata:\n  name: my-postgres-db                     \nspec:\n  clusterServiceClassName: postgres-database        \n  clusterServicePlanName: free                             \n  parameters:\n    init-db-args: --data-checksums         \nYou created a ServiceInstance called my-postgres-db (that will be the name of the\nresource you\u2019re deploying) and specified the ClusterServiceClass and the chosen\nplan. You\u2019re also specifying a parameter, which is specific for each broker and Cluster-\nServiceClass. Let\u2019s imagine you looked up the possible parameters in the broker\u2019s doc-\numentation.\n As soon as you create this resource, the Service Catalog will contact the broker the\nClusterServiceClass belongs to and ask it to provision the service. It will pass on the\nchosen ClusterServiceClass and plan names, as well as all the parameters you specified.\n It\u2019s then completely up to the broker to know what to do with this information. In\nyour case, your database broker will probably spin up a new instance of a PostgreSQL\ndatabase somewhere\u2014not necessarily in the same Kubernetes cluster or even in\nKubernetes at all. It could run a Virtual Machine and run the database in there. The\nService Catalog doesn\u2019t care, and neither does the user requesting the service. \n You can check if the service has been provisioned successfully by inspecting the\nstatus section of the my-postgres-db ServiceInstance you created, as shown in the\nfollowing listing.\n$ kubectl get instance my-postgres-db -o yaml\napiVersion: servicecatalog.k8s.io/v1alpha1\nkind: ServiceInstance\n...\nstatus:\n  asyncOpInProgress: false\n  conditions:\nListing 18.12\nA ServiceInstance manifest: database-instance.yaml\nListing 18.13\nInspecting the status of a ServiceInstance\nYou\u2019re giving this \nInstance a name.\nThe ServiceClass \nand Plan you want\nAdditional parameters \npassed to the broker\n \n", "shape": "dot", "size": 10, "title": "524\nCHAPTER 18\nExtending Kubernetes\n18.2.4 Provisioning and using a service\nLet\u2019s imagine the pods you\u2019re deploying need to use a database. You\u2019ve inspected the\nlist of available ClusterServiceClasses and have chosen to use the free plan of the\npostgres-database ClusterServiceClass. \nPROVISIONING A SERVICEINSTANCE\nTo have the database provisioned for you, all you need to do is create a Service-\nInstance resource, as shown in the following listing.\napiVersion: servicecatalog.k8s.io/v1alpha1\nkind: ServiceInstance\nmetadata:\n  name: my-postgres-db                     \nspec:\n  clusterServiceClassName: postgres-database        \n  clusterServicePlanName: free                             \n  parameters:\n    init-db-args: --data-checksums         \nYou created a ServiceInstance called my-postgres-db (that will be the name of the\nresource you\u2019re deploying) and specified the ClusterServiceClass and the chosen\nplan. You\u2019re also specifying a parameter, which is specific for each broker and Cluster-\nServiceClass. Let\u2019s imagine you looked up the possible parameters in the broker\u2019s doc-\numentation.\n As soon as you create this resource, the Service Catalog will contact the broker the\nClusterServiceClass belongs to and ask it to provision the service. It will pass on the\nchosen ClusterServiceClass and plan names, as well as all the parameters you specified.\n It\u2019s then completely up to the broker to know what to do with this information. In\nyour case, your database broker will probably spin up a new instance of a PostgreSQL\ndatabase somewhere\u2014not necessarily in the same Kubernetes cluster or even in\nKubernetes at all. It could run a Virtual Machine and run the database in there. The\nService Catalog doesn\u2019t care, and neither does the user requesting the service. \n You can check if the service has been provisioned successfully by inspecting the\nstatus section of the my-postgres-db ServiceInstance you created, as shown in the\nfollowing listing.\n$ kubectl get instance my-postgres-db -o yaml\napiVersion: servicecatalog.k8s.io/v1alpha1\nkind: ServiceInstance\n...\nstatus:\n  asyncOpInProgress: false\n  conditions:\nListing 18.12\nA ServiceInstance manifest: database-instance.yaml\nListing 18.13\nInspecting the status of a ServiceInstance\nYou\u2019re giving this \nInstance a name.\nThe ServiceClass \nand Plan you want\nAdditional parameters \npassed to the broker\n \n"}, {"color": "green", "id": "text_468", "label": "525\nExtending Kubernetes with the Kubernetes Service Catalog\n  - lastTransitionTime: 2017-05-17T13:57:22Z\n    message: The instance was provisioned successfully    \n    reason: ProvisionedSuccessfully                       \n    status: \"True\"\n    type: Ready                   \nA database instance is now running somewhere, but how do you use it in your pods?\nTo do that, you need to bind it.\nBINDING A SERVICEINSTANCE\nTo use a provisioned ServiceInstance in your pods, you create a ServiceBinding\nresource, as shown in the following listing.\napiVersion: servicecatalog.k8s.io/v1alpha1\nkind: ServiceBinding\nmetadata:\n  name: my-postgres-db-binding\nspec:\n  instanceRef:                          \n    name: my-postgres-db                \n  secretName: postgres-secret           \nThe listing shows that you\u2019re defining a ServiceBinding resource called my-postgres-\ndb-binding, in which you\u2019re referencing the my-postgres-db service instance you\ncreated earlier. You\u2019re also specifying a name of a Secret. You want the Service Catalog\nto put all the necessary credentials for accessing the service instance into a Secret\ncalled postgres-secret. But where are you binding the ServiceInstance to your pods?\nNowhere, actually.\n Currently, the Service Catalog doesn\u2019t yet make it possible to inject pods with the\nServiceInstance\u2019s credentials. This will be possible when a new Kubernetes feature\ncalled PodPresets is available. Until then, you can choose a name for the Secret\nwhere you want the credentials to be stored in and mount that Secret into your pods\nmanually.\n When you submit the ServiceBinding resource from the previous listing to the Ser-\nvice Catalog API server, the controller will contact the Database broker once again\nand create a binding for the ServiceInstance you provisioned earlier. The broker\nresponds with a list of credentials and other data necessary for connecting to the data-\nbase. The Service Catalog creates a new Secret with the name you specified in the\nServiceBinding resource and stores all that data in the Secret. \nUSING THE NEWLY CREATED SECRET IN CLIENT PODS\nThe Secret created by the Service Catalog system can be mounted into pods, so they\ncan read its contents and use them to connect to the provisioned service instance (a\nPostgreSQL database in the example). The Secret could look like the one in the fol-\nlowing listing.\nListing 18.14\nA ServiceBinding: my-postgres-db-binding.yaml\nThe database was \nprovisioned successfully.\nIt\u2019s ready to be used.\nYou\u2019re referencing the \ninstance you created \nearlier.\nYou\u2019d like the credentials \nfor accessing the service \nstored in this Secret.\n \n", "shape": "dot", "size": 10, "title": "525\nExtending Kubernetes with the Kubernetes Service Catalog\n  - lastTransitionTime: 2017-05-17T13:57:22Z\n    message: The instance was provisioned successfully    \n    reason: ProvisionedSuccessfully                       \n    status: \"True\"\n    type: Ready                   \nA database instance is now running somewhere, but how do you use it in your pods?\nTo do that, you need to bind it.\nBINDING A SERVICEINSTANCE\nTo use a provisioned ServiceInstance in your pods, you create a ServiceBinding\nresource, as shown in the following listing.\napiVersion: servicecatalog.k8s.io/v1alpha1\nkind: ServiceBinding\nmetadata:\n  name: my-postgres-db-binding\nspec:\n  instanceRef:                          \n    name: my-postgres-db                \n  secretName: postgres-secret           \nThe listing shows that you\u2019re defining a ServiceBinding resource called my-postgres-\ndb-binding, in which you\u2019re referencing the my-postgres-db service instance you\ncreated earlier. You\u2019re also specifying a name of a Secret. You want the Service Catalog\nto put all the necessary credentials for accessing the service instance into a Secret\ncalled postgres-secret. But where are you binding the ServiceInstance to your pods?\nNowhere, actually.\n Currently, the Service Catalog doesn\u2019t yet make it possible to inject pods with the\nServiceInstance\u2019s credentials. This will be possible when a new Kubernetes feature\ncalled PodPresets is available. Until then, you can choose a name for the Secret\nwhere you want the credentials to be stored in and mount that Secret into your pods\nmanually.\n When you submit the ServiceBinding resource from the previous listing to the Ser-\nvice Catalog API server, the controller will contact the Database broker once again\nand create a binding for the ServiceInstance you provisioned earlier. The broker\nresponds with a list of credentials and other data necessary for connecting to the data-\nbase. The Service Catalog creates a new Secret with the name you specified in the\nServiceBinding resource and stores all that data in the Secret. \nUSING THE NEWLY CREATED SECRET IN CLIENT PODS\nThe Secret created by the Service Catalog system can be mounted into pods, so they\ncan read its contents and use them to connect to the provisioned service instance (a\nPostgreSQL database in the example). The Secret could look like the one in the fol-\nlowing listing.\nListing 18.14\nA ServiceBinding: my-postgres-db-binding.yaml\nThe database was \nprovisioned successfully.\nIt\u2019s ready to be used.\nYou\u2019re referencing the \ninstance you created \nearlier.\nYou\u2019d like the credentials \nfor accessing the service \nstored in this Secret.\n \n"}, {"color": "green", "id": "text_469", "label": "526\nCHAPTER 18\nExtending Kubernetes\n$ kubectl get secret postgres-secret -o yaml\napiVersion: v1\ndata:\n  host: \u003cbase64-encoded hostname of the database\u003e     \n  username: \u003cbase64-encoded username\u003e                 \n  password: \u003cbase64-encoded password\u003e                 \nkind: Secret\nmetadata:\n  name: postgres-secret\n  namespace: default\n  ...\ntype: Opaque\nBecause you can choose the name of the Secret yourself, you can deploy pods before\nprovisioning or binding the service. As you learned in chapter 7, the pods won\u2019t be\nstarted until such a Secret exists. \n If necessary, multiple bindings can be created for different pods. The service bro-\nker can choose to use the same set of credentials in every binding, but it\u2019s better to\ncreate a new set of credentials for every binding instance. This way, pods can be pre-\nvented from using the service by deleting the ServiceBinding resource.\n18.2.5 Unbinding and deprovisioning\nOnce you no longer need a ServiceBinding, you can delete it the way you delete other\nresources:\n$ kubectl delete servicebinding my-postgres-db-binding\nservicebinding \"my-postgres-db-binding\" deleted\nWhen you do this, the Service Catalog controller will delete the Secret and call the bro-\nker to perform an unbinding operation. The service instance (in your case a PostgreSQL\ndatabase) is still running. You can therefore create a new ServiceBinding if you want.\n But if you don\u2019t need the database instance anymore, you should delete the Service-\nInstance resource also:\n$ kubectl delete serviceinstance my-postgres-db\nserviceinstance \"my-postgres-db \" deleted\nDeleting the ServiceInstance resource causes the Service Catalog to perform a depro-\nvisioning operation on the service broker. Again, exactly what that means is up to the\nservice broker, but in your case, the broker should shut down the PostgreSQL data-\nbase instance that it created when we provisioned the service instance.\n18.2.6 Understanding what the Service Catalog brings\nAs you\u2019ve learned, the Service Catalog enables service providers make it possible to\nexpose those services in any Kubernetes cluster by registering the broker in that cluster.\nListing 18.15\nA Secret holding the credentials for connecting to the service instance\nThis is what the pod \nshould use to connect to \nthe database service.\n \n", "shape": "dot", "size": 10, "title": "526\nCHAPTER 18\nExtending Kubernetes\n$ kubectl get secret postgres-secret -o yaml\napiVersion: v1\ndata:\n  host: \u003cbase64-encoded hostname of the database\u003e     \n  username: \u003cbase64-encoded username\u003e                 \n  password: \u003cbase64-encoded password\u003e                 \nkind: Secret\nmetadata:\n  name: postgres-secret\n  namespace: default\n  ...\ntype: Opaque\nBecause you can choose the name of the Secret yourself, you can deploy pods before\nprovisioning or binding the service. As you learned in chapter 7, the pods won\u2019t be\nstarted until such a Secret exists. \n If necessary, multiple bindings can be created for different pods. The service bro-\nker can choose to use the same set of credentials in every binding, but it\u2019s better to\ncreate a new set of credentials for every binding instance. This way, pods can be pre-\nvented from using the service by deleting the ServiceBinding resource.\n18.2.5 Unbinding and deprovisioning\nOnce you no longer need a ServiceBinding, you can delete it the way you delete other\nresources:\n$ kubectl delete servicebinding my-postgres-db-binding\nservicebinding \"my-postgres-db-binding\" deleted\nWhen you do this, the Service Catalog controller will delete the Secret and call the bro-\nker to perform an unbinding operation. The service instance (in your case a PostgreSQL\ndatabase) is still running. You can therefore create a new ServiceBinding if you want.\n But if you don\u2019t need the database instance anymore, you should delete the Service-\nInstance resource also:\n$ kubectl delete serviceinstance my-postgres-db\nserviceinstance \"my-postgres-db \" deleted\nDeleting the ServiceInstance resource causes the Service Catalog to perform a depro-\nvisioning operation on the service broker. Again, exactly what that means is up to the\nservice broker, but in your case, the broker should shut down the PostgreSQL data-\nbase instance that it created when we provisioned the service instance.\n18.2.6 Understanding what the Service Catalog brings\nAs you\u2019ve learned, the Service Catalog enables service providers make it possible to\nexpose those services in any Kubernetes cluster by registering the broker in that cluster.\nListing 18.15\nA Secret holding the credentials for connecting to the service instance\nThis is what the pod \nshould use to connect to \nthe database service.\n \n"}, {"color": "green", "id": "text_470", "label": "527\nPlatforms built on top of Kubernetes\nFor example, I\u2019ve been involved with the Service Catalog since early on and have\nimplemented a broker, which makes it trivial to provision messaging systems and\nexpose them to pods in a Kubernetes cluster. Another team has implemented a broker\nthat makes it easy to provision Amazon Web Services. \n In general, service brokers allow easy provisioning and exposing of services in\nKubernetes and will make Kubernetes an even more awesome platform for deploying\nyour applications. \n18.3\nPlatforms built on top of Kubernetes\nI\u2019m sure you\u2019ll agree that Kubernetes is a great system by itself. Given that it\u2019s easily\nextensible across all its components, it\u2019s no wonder companies that had previously\ndeveloped their own custom platforms are now re-implementing them on top of\nKubernetes. Kubernetes is, in fact, becoming a widely accepted foundation for the\nnew generation of Platform-as-a-Service offerings.\n Among the best-known PaaS systems built on Kubernetes are Deis Workflow and\nRed Hat\u2019s OpenShift. We\u2019ll do a quick overview of both systems to give you a sense of\nwhat they offer on top of all the awesome stuff Kubernetes already offers.\n18.3.1 Red Hat OpenShift Container Platform\nRed Hat OpenShift is a Platform-as-a-Service and as such, it has a strong focus on\ndeveloper experience. Among its goals are enabling rapid development of applica-\ntions, as well as easy deployment, scaling, and long-term maintenance of those apps.\nOpenShift has been around much longer than Kubernetes. Versions 1 and 2 were\nbuilt from the ground up and had nothing to do with Kubernetes, but when Kuberne-\ntes was announced, Red Hat decided to rebuild OpenShift version 3 from scratch\u2014\nthis time on top of Kubernetes. When a company such as Red Hat decides to throw\naway an old version of their software and build a new one on top of an existing tech-\nnology like Kubernetes, it should be clear to everyone how great Kubernetes is.\n Kubernetes automates rollouts and application scaling, whereas OpenShift also auto-\nmates the actual building of application images and their automatic deployment with-\nout requiring you to integrate a Continuous Integration solution into your cluster. \n OpenShift also provides user and group management, which allows you to run a\nproperly secured multi-tenant Kubernetes cluster, where individual users are only\nallowed to access their own Kubernetes namespaces and the apps running in those\nnamespaces are also fully network-isolated from each other by default. \nINTRODUCING ADDITIONAL RESOURCES AVAILABLE IN OPENSHIFT\nOpenShift provides some additional API objects in addition to all those available in\nKubernetes. We\u2019ll explain them in the next few paragraphs to give you a good over-\nview of what OpenShift does and what it provides.\n The additional resources include\n\uf0a1Users \u0026 Groups\n\uf0a1Projects\n \n", "shape": "dot", "size": 10, "title": "527\nPlatforms built on top of Kubernetes\nFor example, I\u2019ve been involved with the Service Catalog since early on and have\nimplemented a broker, which makes it trivial to provision messaging systems and\nexpose them to pods in a Kubernetes cluster. Another team has implemented a broker\nthat makes it easy to provision Amazon Web Services. \n In general, service brokers allow easy provisioning and exposing of services in\nKubernetes and will make Kubernetes an even more awesome platform for deploying\nyour applications. \n18.3\nPlatforms built on top of Kubernetes\nI\u2019m sure you\u2019ll agree that Kubernetes is a great system by itself. Given that it\u2019s easily\nextensible across all its components, it\u2019s no wonder companies that had previously\ndeveloped their own custom platforms are now re-implementing them on top of\nKubernetes. Kubernetes is, in fact, becoming a widely accepted foundation for the\nnew generation of Platform-as-a-Service offerings.\n Among the best-known PaaS systems built on Kubernetes are Deis Workflow and\nRed Hat\u2019s OpenShift. We\u2019ll do a quick overview of both systems to give you a sense of\nwhat they offer on top of all the awesome stuff Kubernetes already offers.\n18.3.1 Red Hat OpenShift Container Platform\nRed Hat OpenShift is a Platform-as-a-Service and as such, it has a strong focus on\ndeveloper experience. Among its goals are enabling rapid development of applica-\ntions, as well as easy deployment, scaling, and long-term maintenance of those apps.\nOpenShift has been around much longer than Kubernetes. Versions 1 and 2 were\nbuilt from the ground up and had nothing to do with Kubernetes, but when Kuberne-\ntes was announced, Red Hat decided to rebuild OpenShift version 3 from scratch\u2014\nthis time on top of Kubernetes. When a company such as Red Hat decides to throw\naway an old version of their software and build a new one on top of an existing tech-\nnology like Kubernetes, it should be clear to everyone how great Kubernetes is.\n Kubernetes automates rollouts and application scaling, whereas OpenShift also auto-\nmates the actual building of application images and their automatic deployment with-\nout requiring you to integrate a Continuous Integration solution into your cluster. \n OpenShift also provides user and group management, which allows you to run a\nproperly secured multi-tenant Kubernetes cluster, where individual users are only\nallowed to access their own Kubernetes namespaces and the apps running in those\nnamespaces are also fully network-isolated from each other by default. \nINTRODUCING ADDITIONAL RESOURCES AVAILABLE IN OPENSHIFT\nOpenShift provides some additional API objects in addition to all those available in\nKubernetes. We\u2019ll explain them in the next few paragraphs to give you a good over-\nview of what OpenShift does and what it provides.\n The additional resources include\n\uf0a1Users \u0026 Groups\n\uf0a1Projects\n \n"}, {"color": "green", "id": "text_471", "label": "528\nCHAPTER 18\nExtending Kubernetes\n\uf0a1Templates\n\uf0a1BuildConfigs\n\uf0a1DeploymentConfigs\n\uf0a1ImageStreams\n\uf0a1Routes\n\uf0a1And others\nUNDERSTANDING USERS, GROUPS, AND PROJECTS\nWe\u2019ve said that OpenShift provides a proper multi-tenant environment to its users.\nUnlike Kubernetes, which doesn\u2019t have an API object for representing an individual\nuser of the cluster (but does have ServiceAccounts that represent services running in\nit), OpenShift provides powerful user management features, which make it possible to\nspecify what each user can do and what they cannot. These features pre-date the Role-\nBased Access Control, which is now the standard in vanilla Kubernetes.\n Each user has access to certain Projects, which are nothing more than Kubernetes\nNamespaces with additional annotations. Users can only act on resources that reside\nin the projects the user has access to. Access to the project is granted by a cluster\nadministrator. \nINTRODUCING APPLICATION TEMPLATES\nKubernetes makes it possible to deploy a set of resources through a single JSON or\nYAML manifest. OpenShift takes this a step further by allowing that manifest to be\nparameterizable. A parameterizable list in OpenShift is called a Template; it\u2019s a list of\nobjects whose definitions can include placeholders that get replaced with parameter\nvalues when you process and then instantiate a template (see figure 18.8).\nThe template itself is a JSON or YAML file containing a list of parameters that are ref-\nerenced in resources defined in that same JSON/YAML. The template can be stored\nin the API server like any other object. Before a template can be instantiated, it needs\nTemplate\nParameters\nAPP_NAME=\"kubia\"\nVOL_CAPACITY=\"5 Gi\"\n...\nPod\nname: $(APP_NAME)\nService\nname: $(APP_NAME)\nTemplate\nPod\nname: kubia\nService\nname: kubia\nPod\nname: kubia\nService\nname: kubia\nProcess\nCreate\nFigure 18.8\nOpenShift templates\n \n", "shape": "dot", "size": 10, "title": "528\nCHAPTER 18\nExtending Kubernetes\n\uf0a1Templates\n\uf0a1BuildConfigs\n\uf0a1DeploymentConfigs\n\uf0a1ImageStreams\n\uf0a1Routes\n\uf0a1And others\nUNDERSTANDING USERS, GROUPS, AND PROJECTS\nWe\u2019ve said that OpenShift provides a proper multi-tenant environment to its users.\nUnlike Kubernetes, which doesn\u2019t have an API object for representing an individual\nuser of the cluster (but does have ServiceAccounts that represent services running in\nit), OpenShift provides powerful user management features, which make it possible to\nspecify what each user can do and what they cannot. These features pre-date the Role-\nBased Access Control, which is now the standard in vanilla Kubernetes.\n Each user has access to certain Projects, which are nothing more than Kubernetes\nNamespaces with additional annotations. Users can only act on resources that reside\nin the projects the user has access to. Access to the project is granted by a cluster\nadministrator. \nINTRODUCING APPLICATION TEMPLATES\nKubernetes makes it possible to deploy a set of resources through a single JSON or\nYAML manifest. OpenShift takes this a step further by allowing that manifest to be\nparameterizable. A parameterizable list in OpenShift is called a Template; it\u2019s a list of\nobjects whose definitions can include placeholders that get replaced with parameter\nvalues when you process and then instantiate a template (see figure 18.8).\nThe template itself is a JSON or YAML file containing a list of parameters that are ref-\nerenced in resources defined in that same JSON/YAML. The template can be stored\nin the API server like any other object. Before a template can be instantiated, it needs\nTemplate\nParameters\nAPP_NAME=\"kubia\"\nVOL_CAPACITY=\"5 Gi\"\n...\nPod\nname: $(APP_NAME)\nService\nname: $(APP_NAME)\nTemplate\nPod\nname: kubia\nService\nname: kubia\nPod\nname: kubia\nService\nname: kubia\nProcess\nCreate\nFigure 18.8\nOpenShift templates\n \n"}, {"color": "green", "id": "text_472", "label": "529\nPlatforms built on top of Kubernetes\nto be processed. To process a template, you supply the values for the template\u2019s\nparameters and then OpenShift replaces the references to the parameters with those\nvalues. The result is a processed template, which is exactly like a Kubernetes resource\nlist that can then be created with a single POST request.\n OpenShift provides a long list of pre-fabricated templates that allow users to\nquickly run complex applications by specifying a few arguments (or none at all, if the\ntemplate provides good defaults for those arguments). For example, a template can\nenable the creation of all the Kubernetes resources necessary to run a Java EE appli-\ncation inside an Application Server, which connects to a back-end database, also\ndeployed as part of that same template. All those components can be deployed with a\nsingle command.\nBUILDING IMAGES FROM SOURCE USING BUILDCONFIGS\nOne of the best features of OpenShift is the ability to have OpenShift build and imme-\ndiately deploy an application in the OpenShift cluster by pointing it to a Git repository\nholding the application\u2019s source code. You don\u2019t need to build the container image at\nall\u2014OpenShift does that for you. This is done by creating a resource called Build-\nConfig, which can be configured to trigger builds of container images immediately\nafter a change is committed to the source Git repository. \n Although OpenShift doesn\u2019t monitor the Git repository itself, a hook in the repos-\nitory can notify OpenShift of the new commit. OpenShift will then pull the changes\nfrom the Git repository and start the build process. A build mechanism called Source\nTo Image can detect what type of application is in the Git repository and run the\nproper build procedure for it. For example, if it detects a pom.xml file, which is used\nin Java Maven-formatted projects, it runs a Maven build. The resulting artifacts are\npackaged into an appropriate container image, and are then pushed to an internal\ncontainer registry (provided by OpenShift). From there, they can be pulled and run\nin the cluster immediately. \n By creating a BuildConfig object, developers can thus point to a Git repo and not\nworry about building container images. Developers have almost no need to know\nanything about containers. Once the ops team deploys an OpenShift cluster and\ngives developers access to it, those developers can develop their code, commit, and\npush it to a Git repo, the same way they used to before we started packaging apps into\ncontainers. Then OpenShift takes care of building, deploying, and managing apps\nfrom that code.\nAUTOMATICALLY DEPLOYING NEWLY BUILT IMAGES WITH DEPLOYMENTCONFIGS\nOnce a new container image is built, it can also automatically be deployed in the clus-\nter. This is enabled by creating a DeploymentConfig object and pointing it to an\nImageStream. As the name suggests, an ImageStream is a stream of images. When an\nimage is built, it\u2019s added to the ImageStream. This enables the DeploymentConfig to\nnotice the newly built image and allows it to take action and initiate a rollout of the\nnew image (see figure 18.9).\n \n", "shape": "dot", "size": 10, "title": "529\nPlatforms built on top of Kubernetes\nto be processed. To process a template, you supply the values for the template\u2019s\nparameters and then OpenShift replaces the references to the parameters with those\nvalues. The result is a processed template, which is exactly like a Kubernetes resource\nlist that can then be created with a single POST request.\n OpenShift provides a long list of pre-fabricated templates that allow users to\nquickly run complex applications by specifying a few arguments (or none at all, if the\ntemplate provides good defaults for those arguments). For example, a template can\nenable the creation of all the Kubernetes resources necessary to run a Java EE appli-\ncation inside an Application Server, which connects to a back-end database, also\ndeployed as part of that same template. All those components can be deployed with a\nsingle command.\nBUILDING IMAGES FROM SOURCE USING BUILDCONFIGS\nOne of the best features of OpenShift is the ability to have OpenShift build and imme-\ndiately deploy an application in the OpenShift cluster by pointing it to a Git repository\nholding the application\u2019s source code. You don\u2019t need to build the container image at\nall\u2014OpenShift does that for you. This is done by creating a resource called Build-\nConfig, which can be configured to trigger builds of container images immediately\nafter a change is committed to the source Git repository. \n Although OpenShift doesn\u2019t monitor the Git repository itself, a hook in the repos-\nitory can notify OpenShift of the new commit. OpenShift will then pull the changes\nfrom the Git repository and start the build process. A build mechanism called Source\nTo Image can detect what type of application is in the Git repository and run the\nproper build procedure for it. For example, if it detects a pom.xml file, which is used\nin Java Maven-formatted projects, it runs a Maven build. The resulting artifacts are\npackaged into an appropriate container image, and are then pushed to an internal\ncontainer registry (provided by OpenShift). From there, they can be pulled and run\nin the cluster immediately. \n By creating a BuildConfig object, developers can thus point to a Git repo and not\nworry about building container images. Developers have almost no need to know\nanything about containers. Once the ops team deploys an OpenShift cluster and\ngives developers access to it, those developers can develop their code, commit, and\npush it to a Git repo, the same way they used to before we started packaging apps into\ncontainers. Then OpenShift takes care of building, deploying, and managing apps\nfrom that code.\nAUTOMATICALLY DEPLOYING NEWLY BUILT IMAGES WITH DEPLOYMENTCONFIGS\nOnce a new container image is built, it can also automatically be deployed in the clus-\nter. This is enabled by creating a DeploymentConfig object and pointing it to an\nImageStream. As the name suggests, an ImageStream is a stream of images. When an\nimage is built, it\u2019s added to the ImageStream. This enables the DeploymentConfig to\nnotice the newly built image and allows it to take action and initiate a rollout of the\nnew image (see figure 18.9).\n \n"}, {"color": "green", "id": "text_473", "label": "530\nCHAPTER 18\nExtending Kubernetes\nA DeploymentConfig is almost identical to the Deployment object in Kubernetes, but\nit pre-dates it. Like a Deployment object, it has a configurable strategy for transition-\ning between Deployments. It contains a pod template used to create the actual pods,\nbut it also allows you to configure pre- and post-deployment hooks. In contrast to a\nKubernetes Deployment, it creates ReplicationControllers instead of ReplicaSets and\nprovides a few additional features.\nEXPOSING SERVICES EXTERNALLY USING ROUTES\nEarly on, Kubernetes didn\u2019t provide Ingress objects. To expose Services to the outside\nworld, you needed to use NodePort or LoadBalancer-type Services. But at that time,\nOpenShift already provided a better option through a Route resource. A Route is sim-\nilar to an Ingress, but it provides additional configuration related to TLS termination\nand traffic splitting. \n Similar to an Ingress controller, a Route needs a Router, which is a controller that\nprovides the load balancer or proxy. In contrast to Kubernetes, the Router is available\nout of the box in OpenShift. \nTRYING OUT OPENSHIFT\nIf you\u2019re interested in trying out OpenShift, you can start by using Minishift, which is\nthe OpenShift equivalent of Minikube, or you can try OpenShift Online Starter at\nhttps:/\n/manage.openshift.com, which is a free multi-tenant, hosted solution provided\nto get you started with OpenShift. \n18.3.2 Deis Workflow and Helm\nA company called Deis, which has recently been acquired by Microsoft, also provides a\nPaaS called Workflow, which is also built on top of Kubernetes. Besides Workflow,\nPods\nBuilder pod\nReplication\nController\nBuildCon\ufb01g\nGit repo\nDeploymentCon\ufb01g\nImageStream\nBuild trigger\nClones Git repo, builds new\nimage from source, and adds\nit to the ImageStream\nWatches for new images in ImageStream\nand rolls out new version (similarly to a\nDeployment)\nFigure 18.9\nBuildConfigs and DeploymentConfigs in OpenShift\n \n", "shape": "dot", "size": 10, "title": "530\nCHAPTER 18\nExtending Kubernetes\nA DeploymentConfig is almost identical to the Deployment object in Kubernetes, but\nit pre-dates it. Like a Deployment object, it has a configurable strategy for transition-\ning between Deployments. It contains a pod template used to create the actual pods,\nbut it also allows you to configure pre- and post-deployment hooks. In contrast to a\nKubernetes Deployment, it creates ReplicationControllers instead of ReplicaSets and\nprovides a few additional features.\nEXPOSING SERVICES EXTERNALLY USING ROUTES\nEarly on, Kubernetes didn\u2019t provide Ingress objects. To expose Services to the outside\nworld, you needed to use NodePort or LoadBalancer-type Services. But at that time,\nOpenShift already provided a better option through a Route resource. A Route is sim-\nilar to an Ingress, but it provides additional configuration related to TLS termination\nand traffic splitting. \n Similar to an Ingress controller, a Route needs a Router, which is a controller that\nprovides the load balancer or proxy. In contrast to Kubernetes, the Router is available\nout of the box in OpenShift. \nTRYING OUT OPENSHIFT\nIf you\u2019re interested in trying out OpenShift, you can start by using Minishift, which is\nthe OpenShift equivalent of Minikube, or you can try OpenShift Online Starter at\nhttps:/\n/manage.openshift.com, which is a free multi-tenant, hosted solution provided\nto get you started with OpenShift. \n18.3.2 Deis Workflow and Helm\nA company called Deis, which has recently been acquired by Microsoft, also provides a\nPaaS called Workflow, which is also built on top of Kubernetes. Besides Workflow,\nPods\nBuilder pod\nReplication\nController\nBuildCon\ufb01g\nGit repo\nDeploymentCon\ufb01g\nImageStream\nBuild trigger\nClones Git repo, builds new\nimage from source, and adds\nit to the ImageStream\nWatches for new images in ImageStream\nand rolls out new version (similarly to a\nDeployment)\nFigure 18.9\nBuildConfigs and DeploymentConfigs in OpenShift\n \n"}, {"color": "green", "id": "text_474", "label": "531\nPlatforms built on top of Kubernetes\nthey\u2019ve also developed a tool called Helm, which is gaining traction in the Kubernetes\ncommunity as a standard way of deploying existing apps in Kubernetes. We\u2019ll take a\nbrief look at both.\nINTRODUCING DEIS WORKFLOW\nYou can deploy Deis Workflow to any existing Kubernetes cluster (unlike OpenShift,\nwhich is a complete cluster with a modified API server and other Kubernetes compo-\nnents). When you run Workflow, it creates a set of Services and ReplicationControllers,\nwhich then provide developers with a simple, developer-friendly environment. \n Deploying new versions of your app is triggered by pushing your changes with git\npush deis master and letting Workflow take care of the rest. Similar to OpenShift,\nWorkflow also provides a source to image mechanism, application rollouts and roll-\nbacks, edge routing, and also log aggregation, metrics, and alerting, which aren\u2019t\navailable in core Kubernetes. \n To run Workflow in your Kubernetes cluster, you first need to install the Deis Work-\nflow and Helm CLI tools and then install Workflow into your cluster. We won\u2019t go into\nhow to do that here, but if you\u2019d like to learn more, visit the website at https:/\n/deis\n.com/workflow. What we\u2019ll explore here is the Helm tool, which can be used without\nWorkflow and has gained popularity in the community.\nDEPLOYING RESOURCES THROUGH HELM\nHelm is a package manager for Kubernetes (similar to OS package managers like yum\nor apt in Linux or homebrew in MacOS). \n Helm is comprised of two things:\n\uf0a1A helm CLI tool (the client).\n\uf0a1Tiller, a server component running as a Pod inside the Kubernetes cluster.\nThose two components are used to deploy and manage application packages in a\nKubernetes cluster. Helm application packages are called Charts. They\u2019re combined\nwith a Config, which contains configuration information and is merged into a Chart\nto create a Release, which is a running instance of an application (a combined Chart\nand Config). You deploy and manage Releases using the helm CLI tool, which talks to\nthe Tiller server, which is the component that creates all the necessary Kubernetes\nresources defined in the Chart, as shown in figure 18.10.\n You can create charts yourself and keep them on your local disk, or you can use\nany existing chart, which is available in the growing list of helm charts maintained by\nthe community at https:/\n/github.com/kubernetes/charts. The list includes charts for\napplications such as PostgreSQL, MySQL, MariaDB, Magento, Memcached, MongoDB,\nOpenVPN, PHPBB, RabbitMQ, Redis, WordPress, and others.\n Similar to how you don\u2019t build and install apps developed by other people to your\nLinux system manually, you probably don\u2019t want to build and manage your own\nKubernetes manifests for such applications, right? That\u2019s why you\u2019ll want to use Helm\nand the charts available in the GitHub repository I mentioned. \n \n", "shape": "dot", "size": 10, "title": "531\nPlatforms built on top of Kubernetes\nthey\u2019ve also developed a tool called Helm, which is gaining traction in the Kubernetes\ncommunity as a standard way of deploying existing apps in Kubernetes. We\u2019ll take a\nbrief look at both.\nINTRODUCING DEIS WORKFLOW\nYou can deploy Deis Workflow to any existing Kubernetes cluster (unlike OpenShift,\nwhich is a complete cluster with a modified API server and other Kubernetes compo-\nnents). When you run Workflow, it creates a set of Services and ReplicationControllers,\nwhich then provide developers with a simple, developer-friendly environment. \n Deploying new versions of your app is triggered by pushing your changes with git\npush deis master and letting Workflow take care of the rest. Similar to OpenShift,\nWorkflow also provides a source to image mechanism, application rollouts and roll-\nbacks, edge routing, and also log aggregation, metrics, and alerting, which aren\u2019t\navailable in core Kubernetes. \n To run Workflow in your Kubernetes cluster, you first need to install the Deis Work-\nflow and Helm CLI tools and then install Workflow into your cluster. We won\u2019t go into\nhow to do that here, but if you\u2019d like to learn more, visit the website at https:/\n/deis\n.com/workflow. What we\u2019ll explore here is the Helm tool, which can be used without\nWorkflow and has gained popularity in the community.\nDEPLOYING RESOURCES THROUGH HELM\nHelm is a package manager for Kubernetes (similar to OS package managers like yum\nor apt in Linux or homebrew in MacOS). \n Helm is comprised of two things:\n\uf0a1A helm CLI tool (the client).\n\uf0a1Tiller, a server component running as a Pod inside the Kubernetes cluster.\nThose two components are used to deploy and manage application packages in a\nKubernetes cluster. Helm application packages are called Charts. They\u2019re combined\nwith a Config, which contains configuration information and is merged into a Chart\nto create a Release, which is a running instance of an application (a combined Chart\nand Config). You deploy and manage Releases using the helm CLI tool, which talks to\nthe Tiller server, which is the component that creates all the necessary Kubernetes\nresources defined in the Chart, as shown in figure 18.10.\n You can create charts yourself and keep them on your local disk, or you can use\nany existing chart, which is available in the growing list of helm charts maintained by\nthe community at https:/\n/github.com/kubernetes/charts. The list includes charts for\napplications such as PostgreSQL, MySQL, MariaDB, Magento, Memcached, MongoDB,\nOpenVPN, PHPBB, RabbitMQ, Redis, WordPress, and others.\n Similar to how you don\u2019t build and install apps developed by other people to your\nLinux system manually, you probably don\u2019t want to build and manage your own\nKubernetes manifests for such applications, right? That\u2019s why you\u2019ll want to use Helm\nand the charts available in the GitHub repository I mentioned. \n \n"}, {"color": "green", "id": "text_475", "label": "532\nCHAPTER 18\nExtending Kubernetes\nWhen you want to run a PostgreSQL or a MySQL database in your Kubernetes cluster,\ndon\u2019t start writing manifests for them. Instead, check if someone else has already gone\nthrough the trouble and prepared a Helm chart for it. \n Once someone prepares a Helm chart for a specific application and adds it to the\nHelm chart GitHub repo, installing the whole application takes a single one-line com-\nmand. For example, to run MySQL in your Kubernetes cluster, all you need to do is\nclone the charts Git repo to your local machine and run the following command (pro-\nvided you have Helm\u2019s CLI tool and Tiller running in your cluster):\n$ helm install --name my-database stable/mysql\nThis will create all the necessary Deployments, Services, Secrets, and PersistentVolu-\nmeClaims needed to run MySQL in your cluster. You don\u2019t need to concern yourself\nwith what components you need and how to configure them to run MySQL properly.\nI\u2019m sure you\u2019ll agree this is awesome.\nTIP\nOne of the most interesting charts available in the repo is an OpenVPN\nchart, which runs an OpenVPN server inside your Kubernetes cluster and\nallows you to enter the pod network through VPN and access Services as if\nyour local machine was a pod in the cluster. This is useful when you\u2019re devel-\noping apps and running them locally.\nThese were several examples of how Kubernetes can be extended and how companies\nlike Red Hat and Deis (now Microsoft) have extended it. Now go and start riding the\nKubernetes wave yourself!\nKubernetes cluster\nChart\nand\nCon\ufb01g\nHelm\nCharts\n(\ufb01les on\nlocal disk)\nTiller\n(pod)\nDeployments,\nServices, and\nother objects\nhelm\nCLI tool\nManages\ncharts\nCombines Chart and\nCon\ufb01g into a Release\nCreates Kubernetes objects\nde\ufb01ned in the Release\nFigure 18.10\nOverview of Helm\n \n", "shape": "dot", "size": 10, "title": "532\nCHAPTER 18\nExtending Kubernetes\nWhen you want to run a PostgreSQL or a MySQL database in your Kubernetes cluster,\ndon\u2019t start writing manifests for them. Instead, check if someone else has already gone\nthrough the trouble and prepared a Helm chart for it. \n Once someone prepares a Helm chart for a specific application and adds it to the\nHelm chart GitHub repo, installing the whole application takes a single one-line com-\nmand. For example, to run MySQL in your Kubernetes cluster, all you need to do is\nclone the charts Git repo to your local machine and run the following command (pro-\nvided you have Helm\u2019s CLI tool and Tiller running in your cluster):\n$ helm install --name my-database stable/mysql\nThis will create all the necessary Deployments, Services, Secrets, and PersistentVolu-\nmeClaims needed to run MySQL in your cluster. You don\u2019t need to concern yourself\nwith what components you need and how to configure them to run MySQL properly.\nI\u2019m sure you\u2019ll agree this is awesome.\nTIP\nOne of the most interesting charts available in the repo is an OpenVPN\nchart, which runs an OpenVPN server inside your Kubernetes cluster and\nallows you to enter the pod network through VPN and access Services as if\nyour local machine was a pod in the cluster. This is useful when you\u2019re devel-\noping apps and running them locally.\nThese were several examples of how Kubernetes can be extended and how companies\nlike Red Hat and Deis (now Microsoft) have extended it. Now go and start riding the\nKubernetes wave yourself!\nKubernetes cluster\nChart\nand\nCon\ufb01g\nHelm\nCharts\n(\ufb01les on\nlocal disk)\nTiller\n(pod)\nDeployments,\nServices, and\nother objects\nhelm\nCLI tool\nManages\ncharts\nCombines Chart and\nCon\ufb01g into a Release\nCreates Kubernetes objects\nde\ufb01ned in the Release\nFigure 18.10\nOverview of Helm\n \n"}, {"color": "green", "id": "text_476", "label": "533\nSummary\n18.4\nSummary\nThis final chapter has shown you how you can go beyond the existing functionalities\nKubernetes provides and how companies like Dies and Red Hat have done it. You\u2019ve\nlearned how\n\uf0a1Custom resources can be registered in the API server by creating a Custom-\nResourceDefinition object.\n\uf0a1Instances of custom objects can be stored, retrieved, updated, and deleted with-\nout having to change the API server code.\n\uf0a1A custom controller can be implemented to bring those objects to life.\n\uf0a1Kubernetes can be extended with custom API servers through API aggregation.\n\uf0a1Kubernetes Service Catalog makes it possible to self-provision external services\nand expose them to pods running in the Kubernetes cluster.\n\uf0a1Platforms-as-a-Service built on top of Kubernetes make it easy to build contain-\nerized applications inside the same Kubernetes cluster that then runs them. \n\uf0a1A package manager called Helm makes deploying existing apps without requir-\ning you to build resource manifests for them.\nThank you for taking the time to read through this long book. I hope you\u2019ve learned\nas much from reading it as I have from writing it.\n \n", "shape": "dot", "size": 10, "title": "533\nSummary\n18.4\nSummary\nThis final chapter has shown you how you can go beyond the existing functionalities\nKubernetes provides and how companies like Dies and Red Hat have done it. You\u2019ve\nlearned how\n\uf0a1Custom resources can be registered in the API server by creating a Custom-\nResourceDefinition object.\n\uf0a1Instances of custom objects can be stored, retrieved, updated, and deleted with-\nout having to change the API server code.\n\uf0a1A custom controller can be implemented to bring those objects to life.\n\uf0a1Kubernetes can be extended with custom API servers through API aggregation.\n\uf0a1Kubernetes Service Catalog makes it possible to self-provision external services\nand expose them to pods running in the Kubernetes cluster.\n\uf0a1Platforms-as-a-Service built on top of Kubernetes make it easy to build contain-\nerized applications inside the same Kubernetes cluster that then runs them. \n\uf0a1A package manager called Helm makes deploying existing apps without requir-\ning you to build resource manifests for them.\nThank you for taking the time to read through this long book. I hope you\u2019ve learned\nas much from reading it as I have from writing it.\n \n"}, {"color": "green", "id": "text_477", "label": "534\nappendix A\nUsing kubectl\nwith multiple clusters\nA.1\nSwitching between Minikube and Google Kubernetes \nEngine\nThe examples in this book can either be run in a cluster created with Minikube, or\none created with Google Kubernetes Engine (GKE). If you plan on using both, you\nneed to know how to switch between them. A detailed explanation of how to use\nkubectl with multiple clusters is described in the next section. Here we look at how\nto switch between Minikube and GKE.\nSWITCHING TO MINIKUBE\nLuckily, every time you start up a Minikube cluster with minikube start, it also\nreconfigures kubectl to use it:\n$ minikube start\nStarting local Kubernetes cluster...\n...\nSetting up kubeconfig...                            \nKubectl is now configured to use the cluster.       \nAfter switching from Minikube to GKE, you can switch back by stopping Minikube\nand starting it up again. kubectl will then be re-configured to use the Minikube clus-\nter again.\nSWITCHING TO GKE\nTo switch to using the GKE cluster, you can use the following command:\n$ gcloud container clusters get-credentials my-gke-cluster\nThis will configure kubectl to use the GKE cluster called my-gke-cluster.\nMinikube sets up kubectl every \ntime you start the cluster.\n \n", "shape": "dot", "size": 10, "title": "534\nappendix A\nUsing kubectl\nwith multiple clusters\nA.1\nSwitching between Minikube and Google Kubernetes \nEngine\nThe examples in this book can either be run in a cluster created with Minikube, or\none created with Google Kubernetes Engine (GKE). If you plan on using both, you\nneed to know how to switch between them. A detailed explanation of how to use\nkubectl with multiple clusters is described in the next section. Here we look at how\nto switch between Minikube and GKE.\nSWITCHING TO MINIKUBE\nLuckily, every time you start up a Minikube cluster with minikube start, it also\nreconfigures kubectl to use it:\n$ minikube start\nStarting local Kubernetes cluster...\n...\nSetting up kubeconfig...                            \nKubectl is now configured to use the cluster.       \nAfter switching from Minikube to GKE, you can switch back by stopping Minikube\nand starting it up again. kubectl will then be re-configured to use the Minikube clus-\nter again.\nSWITCHING TO GKE\nTo switch to using the GKE cluster, you can use the following command:\n$ gcloud container clusters get-credentials my-gke-cluster\nThis will configure kubectl to use the GKE cluster called my-gke-cluster.\nMinikube sets up kubectl every \ntime you start the cluster.\n \n"}, {"color": "green", "id": "text_478", "label": "535\nUsing kubectl with multiple clusters or namespaces\nGOING FURTHER\nThese two methods should be enough to get you started quickly, but to understand\nthe complete picture of using kubectl with multiple clusters, study the next section. \nA.2\nUsing kubectl with multiple clusters or namespaces\nIf you need to switch between different Kubernetes clusters, or if you want to work in a\ndifferent namespace than the default and don\u2019t want to specify the --namespace\noption every time you run kubectl, here\u2019s how to do it.\nA.2.1\nConfiguring the location of the kubeconfig file\nThe config used by kubectl is usually stored in the ~/.kube/config file. If it\u2019s stored\nsomewhere else, the KUBECONFIG environment variable needs to point to its location. \nNOTE\nYou can use multiple config files and have kubectl use them all at\nonce by specifying all of them in the KUBECONFIG environment variable (sepa-\nrate them with a colon).\nA.2.2\nUnderstanding the contents of the kubeconfig file\nAn example config file is shown in the following listing.\napiVersion: v1\nclusters:\n- cluster:                                                 \n    certificate-authority: /home/luksa/.minikube/ca.crt    \n    server: https://192.168.99.100:8443                    \n  name: minikube                                           \ncontexts:\n- context:                          \n    cluster: minikube               \n    user: minikube                  \n    namespace: default              \n  name: minikube                    \ncurrent-context: minikube             \nkind: Config\npreferences: {}\nusers:\n- name: minikube                                             \n  user:                                                      \n    client-certificate: /home/luksa/.minikube/apiserver.crt  \n    client-key: /home/luksa/.minikube/apiserver.key          \nThe kubeconfig file consists of four sections:\n\u25a0\nA list of clusters\n\u25a0\nA list of users\n\u25a0\nA list of contexts\n\u25a0\nThe name of the current context\nListing A.1\nExample kubeconfig file\nContains \ninformation about a \nKubernetes cluster\nDefines a \nkubectl \ncontext\nThe current context \nkubectl uses\nContains \na user\u2019s \ncredentials\n \n", "shape": "dot", "size": 10, "title": "535\nUsing kubectl with multiple clusters or namespaces\nGOING FURTHER\nThese two methods should be enough to get you started quickly, but to understand\nthe complete picture of using kubectl with multiple clusters, study the next section. \nA.2\nUsing kubectl with multiple clusters or namespaces\nIf you need to switch between different Kubernetes clusters, or if you want to work in a\ndifferent namespace than the default and don\u2019t want to specify the --namespace\noption every time you run kubectl, here\u2019s how to do it.\nA.2.1\nConfiguring the location of the kubeconfig file\nThe config used by kubectl is usually stored in the ~/.kube/config file. If it\u2019s stored\nsomewhere else, the KUBECONFIG environment variable needs to point to its location. \nNOTE\nYou can use multiple config files and have kubectl use them all at\nonce by specifying all of them in the KUBECONFIG environment variable (sepa-\nrate them with a colon).\nA.2.2\nUnderstanding the contents of the kubeconfig file\nAn example config file is shown in the following listing.\napiVersion: v1\nclusters:\n- cluster:                                                 \n    certificate-authority: /home/luksa/.minikube/ca.crt    \n    server: https://192.168.99.100:8443                    \n  name: minikube                                           \ncontexts:\n- context:                          \n    cluster: minikube               \n    user: minikube                  \n    namespace: default              \n  name: minikube                    \ncurrent-context: minikube             \nkind: Config\npreferences: {}\nusers:\n- name: minikube                                             \n  user:                                                      \n    client-certificate: /home/luksa/.minikube/apiserver.crt  \n    client-key: /home/luksa/.minikube/apiserver.key          \nThe kubeconfig file consists of four sections:\n\u25a0\nA list of clusters\n\u25a0\nA list of users\n\u25a0\nA list of contexts\n\u25a0\nThe name of the current context\nListing A.1\nExample kubeconfig file\nContains \ninformation about a \nKubernetes cluster\nDefines a \nkubectl \ncontext\nThe current context \nkubectl uses\nContains \na user\u2019s \ncredentials\n \n"}, {"category": "Cloud_Computing", "color": "red", "description": "this is the name of the book", "id": "Kubernetes_in_Action.pdf", "label": "Kubernetes_in_Action.pdf", "shape": "dot", "size": 10}]);
                  edges = new vis.DataSet([{"from": 89, "to": "text_0", "width": 1}, {"from": 1, "to": 89, "width": 1}, {"from": 1, "to": 90, "width": 1}, {"from": 1, "to": 91, "width": 1}, {"from": 1, "to": 92, "width": 1}, {"from": 1, "to": 93, "width": 1}, {"from": 1, "to": 94, "width": 1}, {"from": 1, "to": 95, "width": 1}, {"from": 1, "to": 96, "width": 1}, {"from": 1, "to": 97, "width": 1}, {"from": 1, "to": 98, "width": 1}, {"from": 1, "to": 99, "width": 1}, {"from": 1, "to": 100, "width": 1}, {"from": 1, "to": 101, "width": 1}, {"from": 1, "to": 102, "width": 1}, {"from": 1, "to": 103, "width": 1}, {"from": 1, "to": 104, "width": 1}, {"from": 1, "to": 105, "width": 1}, {"from": 1, "to": 106, "width": 1}, {"from": 1, "to": 107, "width": 1}, {"from": 1, "to": 108, "width": 1}, {"from": 1, "to": 109, "width": 1}, {"from": 1, "to": 110, "width": 1}, {"from": 1, "to": 111, "width": 1}, {"from": 1, "to": 112, "width": 1}, {"from": 1, "to": 113, "width": 1}, {"from": 1, "to": 114, "width": 1}, {"from": 1, "to": 115, "width": 1}, {"from": 1, "to": 116, "width": 1}, {"from": 1, "to": 117, "width": 1}, {"from": 1, "to": 118, "width": 1}, {"from": 1, "to": 119, "width": 1}, {"from": 1, "to": 120, "width": 1}, {"from": 1, "to": 121, "width": 1}, {"from": 1, "to": 122, "width": 1}, {"from": 1, "to": 123, "width": 1}, {"from": 1, "to": 124, "width": 1}, {"from": 1, "to": 125, "width": 1}, {"from": 1, "to": 126, "width": 1}, {"from": 1, "to": 127, "width": 1}, {"from": 1, "to": 128, "width": 1}, {"from": 1, "to": 129, "width": 1}, {"from": 1, "to": 130, "width": 1}, {"from": 1, "to": 131, "width": 1}, {"from": 1, "to": 132, "width": 1}, {"from": 1, "to": 133, "width": 1}, {"from": 1, "to": 134, "width": 1}, {"from": 1, "to": 135, "width": 1}, {"from": 1, "to": 136, "width": 1}, {"from": 1, "to": 137, "width": 1}, {"from": 1, "to": 138, "width": 1}, {"from": 1, "to": 139, "width": 1}, {"from": 1, "to": 140, "width": 1}, {"from": 1, "to": 141, "width": 1}, {"from": 1, "to": 142, "width": 1}, {"from": 1, "to": 143, "width": 1}, {"from": 1, "to": 144, "width": 1}, {"from": 1, "to": 145, "width": 1}, {"from": 1, "to": 146, "width": 1}, {"from": 1, "to": 147, "width": 1}, {"from": 1, "to": 148, "width": 1}, {"from": 1, "to": 149, "width": 1}, {"from": 1, "to": 150, "width": 1}, {"from": 1, "to": 151, "width": 1}, {"from": 1, "to": 152, "width": 1}, {"from": 1, "to": 153, "width": 1}, {"from": 1, "to": 154, "width": 1}, {"from": 1, "to": 155, "width": 1}, {"from": 1, "to": 156, "width": 1}, {"from": 1, "to": 157, "width": 1}, {"from": 1, "to": 158, "width": 1}, {"from": 1, "to": 159, "width": 1}, {"from": 1, "to": 160, "width": 1}, {"from": 1, "to": 161, "width": 1}, {"from": 1, "to": 162, "width": 1}, {"from": 1, "to": 163, "width": 1}, {"from": 1, "to": 164, "width": 1}, {"from": 1, "to": 165, "width": 1}, {"from": 1, "to": 166, "width": 1}, {"from": 1, "to": 167, "width": 1}, {"from": 1, "to": 168, "width": 1}, {"from": 1, "to": 169, "width": 1}, {"from": 1, "to": 170, "width": 1}, {"from": 1, "to": 171, "width": 1}, {"from": 1, "to": 172, "width": 1}, {"from": 1, "to": 173, "width": 1}, {"from": 1, "to": 174, "width": 1}, {"from": 1, "to": 175, "width": 1}, {"from": 1, "to": 176, "width": 1}, {"from": 1, "to": 177, "width": 1}, {"from": 1, "to": 178, "width": 1}, {"from": 1, "to": 179, "width": 1}, {"from": 1, "to": 180, "width": 1}, {"from": 1, "to": 181, "width": 1}, {"from": 1, "to": 182, "width": 1}, {"from": 1, "to": 183, "width": 1}, {"from": 1, "to": 184, "width": 1}, {"from": 1, "to": 185, "width": 1}, {"from": 1, "to": 186, "width": 1}, {"from": 1, "to": 187, "width": 1}, {"from": 1, "to": 188, "width": 1}, {"from": 1, "to": 189, "width": 1}, {"from": 1, "to": 190, "width": 1}, {"from": 1, "to": 191, "width": 1}, {"from": 1, "to": 192, "width": 1}, {"from": 1, "to": 193, "width": 1}, {"from": 1, "to": 194, "width": 1}, {"from": 1, "to": 195, "width": 1}, {"from": 1, "to": 196, "width": 1}, {"from": 1, "to": 197, "width": 1}, {"from": 1, "to": 198, "width": 1}, {"from": 1, "to": 199, "width": 1}, {"from": 1, "to": 200, "width": 1}, {"from": 1, "to": 201, "width": 1}, {"from": 1, "to": 202, "width": 1}, {"from": 1, "to": 203, "width": 1}, {"from": 1, "to": 204, "width": 1}, {"from": 1, "to": 205, "width": 1}, {"from": 1, "to": 206, "width": 1}, {"from": 1, "to": 207, "width": 1}, {"from": 1, "to": 208, "width": 1}, {"from": 1, "to": 209, "width": 1}, {"from": 1, "to": 210, "width": 1}, {"from": 1, "to": 211, "width": 1}, {"from": 1, "to": 212, "width": 1}, {"from": 1, "to": 213, "width": 1}, {"from": 1, "to": 214, "width": 1}, {"from": 1, "to": 215, "width": 1}, {"from": 1, "to": 216, "width": 1}, {"from": 1, "to": 217, "width": 1}, {"from": 1, "to": 218, "width": 1}, {"from": 1, "to": 219, "width": 1}, {"from": 1, "to": 220, "width": 1}, {"from": 1, "to": 221, "width": 1}, {"from": 1, "to": 222, "width": 1}, {"from": 1, "to": 223, "width": 1}, {"from": 1, "to": 224, "width": 1}, {"from": 1, "to": 225, "width": 1}, {"from": 1, "to": 226, "width": 1}, {"from": 1, "to": 227, "width": 1}, {"from": 1, "to": 228, "width": 1}, {"from": 1, "to": 229, "width": 1}, {"from": 1, "to": 230, "width": 1}, {"from": 1, "to": 231, "width": 1}, {"from": 1, "to": 232, "width": 1}, {"from": 1, "to": 233, "width": 1}, {"from": 1, "to": 234, "width": 1}, {"from": 1, "to": 235, "width": 1}, {"from": 1, "to": 236, "width": 1}, {"from": 1, "to": 237, "width": 1}, {"from": 1, "to": 238, "width": 1}, {"from": 1, "to": 239, "width": 1}, {"from": 1, "to": 240, "width": 1}, {"from": 1, "to": 241, "width": 1}, {"from": 1, "to": 242, "width": 1}, {"from": 1, "to": 243, "width": 1}, {"from": 1, "to": 244, "width": 1}, {"from": 1, "to": 245, "width": 1}, {"from": 1, "to": 246, "width": 1}, {"from": 1, "to": 247, "width": 1}, {"from": 1, "to": 248, "width": 1}, {"from": 1, "to": 249, "width": 1}, {"from": 1, "to": 250, "width": 1}, {"from": 1, "to": 251, "width": 1}, {"from": 1, "to": 252, "width": 1}, {"from": 1, "to": 253, "width": 1}, {"from": 1, "to": 254, "width": 1}, {"from": 1, "to": 255, "width": 1}, {"from": 1, "to": 256, "width": 1}, {"from": 1, "to": 257, "width": 1}, {"from": 1, "to": 258, "width": 1}, {"from": 1, "to": 259, "width": 1}, {"from": 1, "to": 260, "width": 1}, {"from": 1, "to": 261, "width": 1}, {"from": 1, "to": 262, "width": 1}, {"from": 1, "to": 263, "width": 1}, {"from": 1, "to": 264, "width": 1}, {"from": 1, "to": 265, "width": 1}, {"from": 1, "to": 266, "width": 1}, {"from": 1, "to": 267, "width": 1}, {"from": 1, "to": 268, "width": 1}, {"from": 1, "to": 269, "width": 1}, {"from": 1, "to": 270, "width": 1}, {"from": 1, "to": 271, "width": 1}, {"from": 1, "to": 272, "width": 1}, {"from": 1, "to": 273, "width": 1}, {"from": 1, "to": 274, "width": 1}, {"from": 1, "to": 275, "width": 1}, {"from": 1, "to": 276, "width": 1}, {"from": 1, "to": 277, "width": 1}, {"from": 1, "to": 278, "width": 1}, {"from": 1, "to": 279, "width": 1}, {"from": 1, "to": 280, "width": 1}, {"from": 1, "to": 281, "width": 1}, {"from": 1, "to": 282, "width": 1}, {"from": 1, "to": 283, "width": 1}, {"from": 1, "to": 284, "width": 1}, {"from": 1, "to": 285, "width": 1}, {"from": 1, "to": 286, "width": 1}, {"from": 1, "to": 287, "width": 1}, {"from": 1, "to": 288, "width": 1}, {"from": 1, "to": 289, "width": 1}, {"from": 1, "to": 290, "width": 1}, {"from": 1, "to": 291, "width": 1}, {"from": 1, "to": 292, "width": 1}, {"from": 1, "to": 293, "width": 1}, {"from": 1, "to": 294, "width": 1}, {"from": 1, "to": 295, "width": 1}, {"from": 1, "to": 296, "width": 1}, {"from": 1, "to": 297, "width": 1}, {"from": 1, "to": 298, "width": 1}, {"from": 1, "to": 299, "width": 1}, {"from": 1, "to": 300, "width": 1}, {"from": 1, "to": 301, "width": 1}, {"from": 1, "to": 302, "width": 1}, {"from": 1, "to": 303, "width": 1}, {"from": 1, "to": 304, "width": 1}, {"from": 1, "to": 305, "width": 1}, {"from": 1, "to": 306, "width": 1}, {"from": 1, "to": 307, "width": 1}, {"from": 1, "to": 308, "width": 1}, {"from": 1, "to": 309, "width": 1}, {"from": 1, "to": 310, "width": 1}, {"from": 1, "to": 311, "width": 1}, {"from": 1, "to": 312, "width": 1}, {"from": 1, "to": 313, "width": 1}, {"from": 1, "to": 314, "width": 1}, {"from": 1, "to": 315, "width": 1}, {"from": 1, "to": 316, "width": 1}, {"from": 1, "to": 317, "width": 1}, {"from": 1, "to": 318, "width": 1}, {"from": 1, "to": 319, "width": 1}, {"from": 1, "to": 320, "width": 1}, {"from": 1, "to": 321, "width": 1}, {"from": 1, "to": 322, "width": 1}, {"from": 1, "to": 323, "width": 1}, {"from": 1, "to": 324, "width": 1}, {"from": 1, "to": 325, "width": 1}, {"from": 1, "to": 326, "width": 1}, {"from": 1, "to": 327, "width": 1}, {"from": 1, "to": 328, "width": 1}, {"from": 1, "to": 329, "width": 1}, {"from": 1, "to": 330, "width": 1}, {"from": 1, "to": 331, "width": 1}, {"from": 1, "to": 332, "width": 1}, {"from": 1, "to": 333, "width": 1}, {"from": 1, "to": 334, "width": 1}, {"from": 1, "to": 335, "width": 1}, {"from": 1, "to": 336, "width": 1}, {"from": 1, "to": 337, "width": 1}, {"from": 1, "to": 338, "width": 1}, {"from": 1, "to": 339, "width": 1}, {"from": 1, "to": 340, "width": 1}, {"from": 1, "to": 341, "width": 1}, {"from": 1, "to": 342, "width": 1}, {"from": 1, "to": 343, "width": 1}, {"from": 1, "to": 344, "width": 1}, {"from": 1, "to": 345, "width": 1}, {"from": 1, "to": 346, "width": 1}, {"from": 1, "to": 347, "width": 1}, {"from": 1, "to": 348, "width": 1}, {"from": 1, "to": 349, "width": 1}, {"from": 1, "to": 350, "width": 1}, {"from": 1, "to": 351, "width": 1}, {"from": 1, "to": 352, "width": 1}, {"from": 1, "to": 353, "width": 1}, {"from": 1, "to": 354, "width": 1}, {"from": 1, "to": 355, "width": 1}, {"from": 1, "to": 356, "width": 1}, {"from": 1, "to": 357, "width": 1}, {"from": 1, "to": 358, "width": 1}, {"from": 1, "to": 359, "width": 1}, {"from": 1, "to": 360, "width": 1}, {"from": 1, "to": 361, "width": 1}, {"from": 1, "to": 362, "width": 1}, {"from": 1, "to": 363, "width": 1}, {"from": 1, "to": 364, "width": 1}, {"from": 1, "to": 365, "width": 1}, {"from": 1, "to": 366, "width": 1}, {"from": 1, "to": 367, "width": 1}, {"from": 1, "to": 368, "width": 1}, {"from": 1, "to": 369, "width": 1}, {"from": 1, "to": 370, "width": 1}, {"from": 1, "to": 371, "width": 1}, {"from": 1, "to": 372, "width": 1}, {"from": 1, "to": 373, "width": 1}, {"from": 1, "to": 374, "width": 1}, {"from": 1, "to": 375, "width": 1}, {"from": 1, "to": 376, "width": 1}, {"from": 1, "to": 377, "width": 1}, {"from": 1, "to": 378, "width": 1}, {"from": 1, "to": 379, "width": 1}, {"from": 1, "to": 380, "width": 1}, {"from": 1, "to": 381, "width": 1}, {"from": 1, "to": 382, "width": 1}, {"from": 1, "to": 383, "width": 1}, {"from": 1, "to": 384, "width": 1}, {"from": 1, "to": 385, "width": 1}, {"from": 1, "to": 386, "width": 1}, {"from": 1, "to": 387, "width": 1}, {"from": 1, "to": 388, "width": 1}, {"from": 1, "to": 389, "width": 1}, {"from": 1, "to": 390, "width": 1}, {"from": 1, "to": 391, "width": 1}, {"from": 1, "to": 392, "width": 1}, {"from": 1, "to": 393, "width": 1}, {"from": 1, "to": 394, "width": 1}, {"from": 1, "to": 395, "width": 1}, {"from": 1, "to": 396, "width": 1}, {"from": 1, "to": 397, "width": 1}, {"from": 1, "to": 398, "width": 1}, {"from": 1, "to": 399, "width": 1}, {"from": 1, "to": 400, "width": 1}, {"from": 1, "to": 401, "width": 1}, {"from": 1, "to": 402, "width": 1}, {"from": 1, "to": 403, "width": 1}, {"from": 1, "to": 404, "width": 1}, {"from": 1, "to": 405, "width": 1}, {"from": 1, "to": 406, "width": 1}, {"from": 1, "to": 407, "width": 1}, {"from": 1, "to": 408, "width": 1}, {"from": 1, "to": 409, "width": 1}, {"from": 1, "to": 410, "width": 1}, {"from": 1, "to": 411, "width": 1}, {"from": 1, "to": 412, "width": 1}, {"from": 1, "to": 413, "width": 1}, {"from": 1, "to": 414, "width": 1}, {"from": 1, "to": 415, "width": 1}, {"from": 1, "to": 416, "width": 1}, {"from": 1, "to": 417, "width": 1}, {"from": 1, "to": 418, "width": 1}, {"from": 1, "to": 419, "width": 1}, {"from": 1, "to": 420, "width": 1}, {"from": 1, "to": 421, "width": 1}, {"from": 1, "to": 422, "width": 1}, {"from": 1, "to": 423, "width": 1}, {"from": 1, "to": 424, "width": 1}, {"from": 1, "to": 425, "width": 1}, {"from": 1, "to": 426, "width": 1}, {"from": 1, "to": 427, "width": 1}, {"from": 1, "to": 428, "width": 1}, {"from": 1, "to": 429, "width": 1}, {"from": 1, "to": 430, "width": 1}, {"from": 1, "to": 431, "width": 1}, {"from": 1, "to": 432, "width": 1}, {"from": 1, "to": 433, "width": 1}, {"from": 1, "to": 434, "width": 1}, {"from": 1, "to": 435, "width": 1}, {"from": 1, "to": 436, "width": 1}, {"from": 1, "to": 437, "width": 1}, {"from": 1, "to": 438, "width": 1}, {"from": 1, "to": 439, "width": 1}, {"from": 1, "to": 440, "width": 1}, {"from": 1, "to": 441, "width": 1}, {"from": 1, "to": 442, "width": 1}, {"from": 1, "to": 443, "width": 1}, {"from": 1, "to": 444, "width": 1}, {"from": 1, "to": 445, "width": 1}, {"from": 1, "to": 446, "width": 1}, {"from": 1, "to": 447, "width": 1}, {"from": 1, "to": 448, "width": 1}, {"from": 1, "to": 449, "width": 1}, {"from": 1, "to": 450, "width": 1}, {"from": 1, "to": 451, "width": 1}, {"from": 1, "to": 452, "width": 1}, {"from": 1, "to": 453, "width": 1}, {"from": 1, "to": 454, "width": 1}, {"from": 1, "to": 455, "width": 1}, {"from": 1, "to": 456, "width": 1}, {"from": 1, "to": 457, "width": 1}, {"from": 1, "to": 458, "width": 1}, {"from": 1, "to": 459, "width": 1}, {"from": 1, "to": 460, "width": 1}, {"from": 1, "to": 461, "width": 1}, {"from": 1, "to": 462, "width": 1}, {"from": 1, "to": 463, "width": 1}, {"from": 1, "to": 464, "width": 1}, {"from": 1, "to": 465, "width": 1}, {"from": 1, "to": 466, "width": 1}, {"from": 1, "to": 467, "width": 1}, {"from": 1, "to": 468, "width": 1}, {"from": 1, "to": 469, "width": 1}, {"from": 1, "to": 470, "width": 1}, {"from": 1, "to": 471, "width": 1}, {"from": 1, "to": 472, "width": 1}, {"from": 1, "to": 473, "width": 1}, {"from": 1, "to": 474, "width": 1}, {"from": 1, "to": 475, "width": 1}, {"from": 1, "to": 476, "width": 1}, {"from": 1, "to": 477, "width": 1}, {"from": 1, "to": 478, "width": 1}, {"from": 1, "to": 479, "width": 1}, {"from": 1, "to": 480, "width": 1}, {"from": 1, "to": 481, "width": 1}, {"from": 1, "to": 482, "width": 1}, {"from": 1, "to": 483, "width": 1}, {"from": 1, "to": 484, "width": 1}, {"from": 1, "to": 485, "width": 1}, {"from": 1, "to": 486, "width": 1}, {"from": 1, "to": 487, "width": 1}, {"from": 1, "to": 488, "width": 1}, {"from": 1, "to": 489, "width": 1}, {"from": 1, "to": 490, "width": 1}, {"from": 1, "to": 491, "width": 1}, {"from": 1, "to": 492, "width": 1}, {"from": 1, "to": 493, "width": 1}, {"from": 1, "to": 494, "width": 1}, {"from": 1, "to": 495, "width": 1}, {"from": 1, "to": 496, "width": 1}, {"from": 1, "to": 497, "width": 1}, {"from": 1, "to": 498, "width": 1}, {"from": 1, "to": 499, "width": 1}, {"from": 1, "to": 500, "width": 1}, {"from": 1, "to": 501, "width": 1}, {"from": 1, "to": 502, "width": 1}, {"from": 1, "to": 503, "width": 1}, {"from": 1, "to": 504, "width": 1}, {"from": 1, "to": 505, "width": 1}, {"from": 1, "to": 506, "width": 1}, {"from": 1, "to": 507, "width": 1}, {"from": 1, "to": 508, "width": 1}, {"from": 1, "to": 509, "width": 1}, {"from": 1, "to": 510, "width": 1}, {"from": 1, "to": 511, "width": 1}, {"from": 1, "to": 512, "width": 1}, {"from": 1, "to": 513, "width": 1}, {"from": 1, "to": 514, "width": 1}, {"from": 1, "to": 515, "width": 1}, {"from": 1, "to": 516, "width": 1}, {"from": 1, "to": 517, "width": 1}, {"from": 1, "to": 518, "width": 1}, {"from": 1, "to": 519, "width": 1}, {"from": 1, "to": 520, "width": 1}, {"from": 1, "to": 521, "width": 1}, {"from": 1, "to": 522, "width": 1}, {"from": 1, "to": 523, "width": 1}, {"from": 1, "to": 524, "width": 1}, {"from": 1, "to": 525, "width": 1}, {"from": 1, "to": 526, "width": 1}, {"from": 1, "to": 527, "width": 1}, {"from": 1, "to": 528, "width": 1}, {"from": 1, "to": 529, "width": 1}, {"from": 1, "to": 530, "width": 1}, {"from": 1, "to": 531, "width": 1}, {"from": 1, "to": 532, "width": 1}, {"from": 1, "to": 533, "width": 1}, {"from": 1, "to": 534, "width": 1}, {"from": 1, "to": 535, "width": 1}, {"from": 1, "to": 536, "width": 1}, {"from": 1, "to": 537, "width": 1}, {"from": 1, "to": 538, "width": 1}, {"from": 1, "to": 539, "width": 1}, {"from": 1, "to": 540, "width": 1}, {"from": 1, "to": 541, "width": 1}, {"from": 1, "to": 542, "width": 1}, {"from": 1, "to": 543, "width": 1}, {"from": 1, "to": 544, "width": 1}, {"from": 1, "to": 545, "width": 1}, {"from": 1, "to": 546, "width": 1}, {"from": 1, "to": 547, "width": 1}, {"from": 1, "to": 548, "width": 1}, {"from": 1, "to": 549, "width": 1}, {"from": 1, "to": 550, "width": 1}, {"from": 1, "to": 551, "width": 1}, {"from": 1, "to": 552, "width": 1}, {"from": 1, "to": 553, "width": 1}, {"from": 1, "to": 554, "width": 1}, {"from": 1, "to": 555, "width": 1}, {"from": 1, "to": 556, "width": 1}, {"from": 1, "to": 557, "width": 1}, {"from": 1, "to": 558, "width": 1}, {"from": 1, "to": 559, "width": 1}, {"from": 1, "to": 560, "width": 1}, {"from": 1, "to": 561, "width": 1}, {"from": 1, "to": 562, "width": 1}, {"from": 1, "to": 563, "width": 1}, {"from": 1, "to": 564, "width": 1}, {"from": 1, "to": 565, "width": 1}, {"from": 1, "to": 566, "width": 1}, {"from": 1, "to": 567, "width": 1}, {"from": 90, "to": "text_1", "width": 1}, {"from": 91, "to": "text_2", "width": 1}, {"from": 92, "to": "text_3", "width": 1}, {"from": 93, "to": "text_4", "width": 1}, {"from": 94, "to": "text_5", "width": 1}, {"from": 95, "to": "text_6", "width": 1}, {"from": 96, "to": "text_7", "width": 1}, {"from": 97, "to": "text_8", "width": 1}, {"from": 98, "to": "text_9", "width": 1}, {"from": 99, "to": "text_10", "width": 1}, {"from": 100, "to": "text_11", "width": 1}, {"from": 101, "to": "text_12", "width": 1}, {"from": 102, "to": "text_13", "width": 1}, {"from": 103, "to": "text_14", "width": 1}, {"from": 104, "to": "text_15", "width": 1}, {"from": 105, "to": "text_16", "width": 1}, {"from": 106, "to": "text_17", "width": 1}, {"from": 107, "to": "text_18", "width": 1}, {"from": 108, "to": "text_19", "width": 1}, {"from": 109, "to": "text_20", "width": 1}, {"from": 110, "to": "text_21", "width": 1}, {"from": 111, "to": "text_22", "width": 1}, {"from": 112, "to": "text_23", "width": 1}, {"from": 113, "to": "text_24", "width": 1}, {"from": 114, "to": "text_25", "width": 1}, {"from": 115, "to": "text_26", "width": 1}, {"from": 116, "to": "text_27", "width": 1}, {"from": 117, "to": "text_28", "width": 1}, {"from": 118, "to": "text_29", "width": 1}, {"from": 119, "to": "text_30", "width": 1}, {"from": 120, "to": "text_31", "width": 1}, {"from": 121, "to": "text_32", "width": 1}, {"from": 122, "to": "text_33", "width": 1}, {"from": 123, "to": "text_34", "width": 1}, {"from": 124, "to": "text_35", "width": 1}, {"from": 125, "to": "text_36", "width": 1}, {"from": 126, "to": "text_37", "width": 1}, {"from": 127, "to": "text_38", "width": 1}, {"from": 128, "to": "text_39", "width": 1}, {"from": 129, "to": "text_40", "width": 1}, {"from": 130, "to": "text_41", "width": 1}, {"from": 131, "to": "text_42", "width": 1}, {"from": 132, "to": "text_43", "width": 1}, {"from": 133, "to": "text_44", "width": 1}, {"from": 134, "to": "text_45", "width": 1}, {"from": 135, "to": "text_46", "width": 1}, {"from": 136, "to": "text_47", "width": 1}, {"from": 137, "to": "text_48", "width": 1}, {"from": 138, "to": "text_49", "width": 1}, {"from": 139, "to": "text_50", "width": 1}, {"from": 140, "to": "text_51", "width": 1}, {"from": 141, "to": "text_52", "width": 1}, {"from": 142, "to": "text_53", "width": 1}, {"from": 143, "to": "text_54", "width": 1}, {"from": 144, "to": "text_55", "width": 1}, {"from": 145, "to": "text_56", "width": 1}, {"from": 146, "to": "text_57", "width": 1}, {"from": 147, "to": "text_58", "width": 1}, {"from": 148, "to": "text_59", "width": 1}, {"from": 149, "to": "text_60", "width": 1}, {"from": 150, "to": "text_61", "width": 1}, {"from": 151, "to": "text_62", "width": 1}, {"from": 152, "to": "text_63", "width": 1}, {"from": 153, "to": "text_64", "width": 1}, {"from": 154, "to": "text_65", "width": 1}, {"from": 155, "to": "text_66", "width": 1}, {"from": 156, "to": "text_67", "width": 1}, {"from": 157, "to": "text_68", "width": 1}, {"from": 158, "to": "text_69", "width": 1}, {"from": 159, "to": "text_70", "width": 1}, {"from": 160, "to": "text_71", "width": 1}, {"from": 161, "to": "text_72", "width": 1}, {"from": 162, "to": "text_73", "width": 1}, {"from": 163, "to": "text_74", "width": 1}, {"from": 164, "to": "text_75", "width": 1}, {"from": 165, "to": "text_76", "width": 1}, {"from": 166, "to": "text_77", "width": 1}, {"from": 167, "to": "text_78", "width": 1}, {"from": 168, "to": "text_79", "width": 1}, {"from": 169, "to": "text_80", "width": 1}, {"from": 170, "to": "text_81", "width": 1}, {"from": 171, "to": "text_82", "width": 1}, {"from": 172, "to": "text_83", "width": 1}, {"from": 173, "to": "text_84", "width": 1}, {"from": 174, "to": "text_85", "width": 1}, {"from": 175, "to": "text_86", "width": 1}, {"from": 176, "to": "text_87", "width": 1}, {"from": 177, "to": "text_88", "width": 1}, {"from": 178, "to": "text_89", "width": 1}, {"from": 179, "to": "text_90", "width": 1}, {"from": 180, "to": "text_91", "width": 1}, {"from": 181, "to": "text_92", "width": 1}, {"from": 182, "to": "text_93", "width": 1}, {"from": 183, "to": "text_94", "width": 1}, {"from": 184, "to": "text_95", "width": 1}, {"from": 185, "to": "text_96", "width": 1}, {"from": 186, "to": "text_97", "width": 1}, {"from": 187, "to": "text_98", "width": 1}, {"from": 188, "to": "text_99", "width": 1}, {"from": 189, "to": "text_100", "width": 1}, {"from": 190, "to": "text_101", "width": 1}, {"from": 191, "to": "text_102", "width": 1}, {"from": 192, "to": "text_103", "width": 1}, {"from": 193, "to": "text_104", "width": 1}, {"from": 194, "to": "text_105", "width": 1}, {"from": 195, "to": "text_106", "width": 1}, {"from": 196, "to": "text_107", "width": 1}, {"from": 197, "to": "text_108", "width": 1}, {"from": 198, "to": "text_109", "width": 1}, {"from": 199, "to": "text_110", "width": 1}, {"from": 200, "to": "text_111", "width": 1}, {"from": 201, "to": "text_112", "width": 1}, {"from": 202, "to": "text_113", "width": 1}, {"from": 203, "to": "text_114", "width": 1}, {"from": 204, "to": "text_115", "width": 1}, {"from": 205, "to": "text_116", "width": 1}, {"from": 206, "to": "text_117", "width": 1}, {"from": 207, "to": "text_118", "width": 1}, {"from": 208, "to": "text_119", "width": 1}, {"from": 209, "to": "text_120", "width": 1}, {"from": 210, "to": "text_121", "width": 1}, {"from": 211, "to": "text_122", "width": 1}, {"from": 212, "to": "text_123", "width": 1}, {"from": 213, "to": "text_124", "width": 1}, {"from": 214, "to": "text_125", "width": 1}, {"from": 215, "to": "text_126", "width": 1}, {"from": 216, "to": "text_127", "width": 1}, {"from": 217, "to": "text_128", "width": 1}, {"from": 218, "to": "text_129", "width": 1}, {"from": 219, "to": "text_130", "width": 1}, {"from": 220, "to": "text_131", "width": 1}, {"from": 221, "to": "text_132", "width": 1}, {"from": 222, "to": "text_133", "width": 1}, {"from": 223, "to": "text_134", "width": 1}, {"from": 224, "to": "text_135", "width": 1}, {"from": 225, "to": "text_136", "width": 1}, {"from": 226, "to": "text_137", "width": 1}, {"from": 227, "to": "text_138", "width": 1}, {"from": 228, "to": "text_139", "width": 1}, {"from": 229, "to": "text_140", "width": 1}, {"from": 230, "to": "text_141", "width": 1}, {"from": 231, "to": "text_142", "width": 1}, {"from": 232, "to": "text_143", "width": 1}, {"from": 233, "to": "text_144", "width": 1}, {"from": 234, "to": "text_145", "width": 1}, {"from": 235, "to": "text_146", "width": 1}, {"from": 236, "to": "text_147", "width": 1}, {"from": 237, "to": "text_148", "width": 1}, {"from": 238, "to": "text_149", "width": 1}, {"from": 239, "to": "text_150", "width": 1}, {"from": 240, "to": "text_151", "width": 1}, {"from": 241, "to": "text_152", "width": 1}, {"from": 242, "to": "text_153", "width": 1}, {"from": 243, "to": "text_154", "width": 1}, {"from": 244, "to": "text_155", "width": 1}, {"from": 245, "to": "text_156", "width": 1}, {"from": 246, "to": "text_157", "width": 1}, {"from": 247, "to": "text_158", "width": 1}, {"from": 248, "to": "text_159", "width": 1}, {"from": 249, "to": "text_160", "width": 1}, {"from": 250, "to": "text_161", "width": 1}, {"from": 251, "to": "text_162", "width": 1}, {"from": 252, "to": "text_163", "width": 1}, {"from": 253, "to": "text_164", "width": 1}, {"from": 254, "to": "text_165", "width": 1}, {"from": 255, "to": "text_166", "width": 1}, {"from": 256, "to": "text_167", "width": 1}, {"from": 257, "to": "text_168", "width": 1}, {"from": 258, "to": "text_169", "width": 1}, {"from": 259, "to": "text_170", "width": 1}, {"from": 260, "to": "text_171", "width": 1}, {"from": 261, "to": "text_172", "width": 1}, {"from": 262, "to": "text_173", "width": 1}, {"from": 263, "to": "text_174", "width": 1}, {"from": 264, "to": "text_175", "width": 1}, {"from": 265, "to": "text_176", "width": 1}, {"from": 266, "to": "text_177", "width": 1}, {"from": 267, "to": "text_178", "width": 1}, {"from": 268, "to": "text_179", "width": 1}, {"from": 269, "to": "text_180", "width": 1}, {"from": 270, "to": "text_181", "width": 1}, {"from": 271, "to": "text_182", "width": 1}, {"from": 272, "to": "text_183", "width": 1}, {"from": 273, "to": "text_184", "width": 1}, {"from": 274, "to": "text_185", "width": 1}, {"from": 275, "to": "text_186", "width": 1}, {"from": 276, "to": "text_187", "width": 1}, {"from": 277, "to": "text_188", "width": 1}, {"from": 278, "to": "text_189", "width": 1}, {"from": 279, "to": "text_190", "width": 1}, {"from": 280, "to": "text_191", "width": 1}, {"from": 281, "to": "text_192", "width": 1}, {"from": 282, "to": "text_193", "width": 1}, {"from": 283, "to": "text_194", "width": 1}, {"from": 284, "to": "text_195", "width": 1}, {"from": 285, "to": "text_196", "width": 1}, {"from": 286, "to": "text_197", "width": 1}, {"from": 287, "to": "text_198", "width": 1}, {"from": 288, "to": "text_199", "width": 1}, {"from": 289, "to": "text_200", "width": 1}, {"from": 290, "to": "text_201", "width": 1}, {"from": 291, "to": "text_202", "width": 1}, {"from": 292, "to": "text_203", "width": 1}, {"from": 293, "to": "text_204", "width": 1}, {"from": 294, "to": "text_205", "width": 1}, {"from": 295, "to": "text_206", "width": 1}, {"from": 296, "to": "text_207", "width": 1}, {"from": 297, "to": "text_208", "width": 1}, {"from": 298, "to": "text_209", "width": 1}, {"from": 299, "to": "text_210", "width": 1}, {"from": 300, "to": "text_211", "width": 1}, {"from": 301, "to": "text_212", "width": 1}, {"from": 302, "to": "text_213", "width": 1}, {"from": 303, "to": "text_214", "width": 1}, {"from": 304, "to": "text_215", "width": 1}, {"from": 305, "to": "text_216", "width": 1}, {"from": 306, "to": "text_217", "width": 1}, {"from": 307, "to": "text_218", "width": 1}, {"from": 308, "to": "text_219", "width": 1}, {"from": 309, "to": "text_220", "width": 1}, {"from": 310, "to": "text_221", "width": 1}, {"from": 311, "to": "text_222", "width": 1}, {"from": 312, "to": "text_223", "width": 1}, {"from": 313, "to": "text_224", "width": 1}, {"from": 314, "to": "text_225", "width": 1}, {"from": 315, "to": "text_226", "width": 1}, {"from": 316, "to": "text_227", "width": 1}, {"from": 317, "to": "text_228", "width": 1}, {"from": 318, "to": "text_229", "width": 1}, {"from": 319, "to": "text_230", "width": 1}, {"from": 320, "to": "text_231", "width": 1}, {"from": 321, "to": "text_232", "width": 1}, {"from": 322, "to": "text_233", "width": 1}, {"from": 323, "to": "text_234", "width": 1}, {"from": 324, "to": "text_235", "width": 1}, {"from": 325, "to": "text_236", "width": 1}, {"from": 326, "to": "text_237", "width": 1}, {"from": 327, "to": "text_238", "width": 1}, {"from": 328, "to": "text_239", "width": 1}, {"from": 329, "to": "text_240", "width": 1}, {"from": 330, "to": "text_241", "width": 1}, {"from": 331, "to": "text_242", "width": 1}, {"from": 332, "to": "text_243", "width": 1}, {"from": 333, "to": "text_244", "width": 1}, {"from": 334, "to": "text_245", "width": 1}, {"from": 335, "to": "text_246", "width": 1}, {"from": 336, "to": "text_247", "width": 1}, {"from": 337, "to": "text_248", "width": 1}, {"from": 338, "to": "text_249", "width": 1}, {"from": 339, "to": "text_250", "width": 1}, {"from": 340, "to": "text_251", "width": 1}, {"from": 341, "to": "text_252", "width": 1}, {"from": 342, "to": "text_253", "width": 1}, {"from": 343, "to": "text_254", "width": 1}, {"from": 344, "to": "text_255", "width": 1}, {"from": 345, "to": "text_256", "width": 1}, {"from": 346, "to": "text_257", "width": 1}, {"from": 347, "to": "text_258", "width": 1}, {"from": 348, "to": "text_259", "width": 1}, {"from": 349, "to": "text_260", "width": 1}, {"from": 350, "to": "text_261", "width": 1}, {"from": 351, "to": "text_262", "width": 1}, {"from": 352, "to": "text_263", "width": 1}, {"from": 353, "to": "text_264", "width": 1}, {"from": 354, "to": "text_265", "width": 1}, {"from": 355, "to": "text_266", "width": 1}, {"from": 356, "to": "text_267", "width": 1}, {"from": 357, "to": "text_268", "width": 1}, {"from": 358, "to": "text_269", "width": 1}, {"from": 359, "to": "text_270", "width": 1}, {"from": 360, "to": "text_271", "width": 1}, {"from": 361, "to": "text_272", "width": 1}, {"from": 362, "to": "text_273", "width": 1}, {"from": 363, "to": "text_274", "width": 1}, {"from": 364, "to": "text_275", "width": 1}, {"from": 365, "to": "text_276", "width": 1}, {"from": 366, "to": "text_277", "width": 1}, {"from": 367, "to": "text_278", "width": 1}, {"from": 368, "to": "text_279", "width": 1}, {"from": 369, "to": "text_280", "width": 1}, {"from": 370, "to": "text_281", "width": 1}, {"from": 371, "to": "text_282", "width": 1}, {"from": 372, "to": "text_283", "width": 1}, {"from": 373, "to": "text_284", "width": 1}, {"from": 374, "to": "text_285", "width": 1}, {"from": 375, "to": "text_286", "width": 1}, {"from": 376, "to": "text_287", "width": 1}, {"from": 377, "to": "text_288", "width": 1}, {"from": 378, "to": "text_289", "width": 1}, {"from": 379, "to": "text_290", "width": 1}, {"from": 380, "to": "text_291", "width": 1}, {"from": 381, "to": "text_292", "width": 1}, {"from": 382, "to": "text_293", "width": 1}, {"from": 383, "to": "text_294", "width": 1}, {"from": 384, "to": "text_295", "width": 1}, {"from": 385, "to": "text_296", "width": 1}, {"from": 386, "to": "text_297", "width": 1}, {"from": 387, "to": "text_298", "width": 1}, {"from": 388, "to": "text_299", "width": 1}, {"from": 389, "to": "text_300", "width": 1}, {"from": 390, "to": "text_301", "width": 1}, {"from": 391, "to": "text_302", "width": 1}, {"from": 392, "to": "text_303", "width": 1}, {"from": 393, "to": "text_304", "width": 1}, {"from": 394, "to": "text_305", "width": 1}, {"from": 395, "to": "text_306", "width": 1}, {"from": 396, "to": "text_307", "width": 1}, {"from": 397, "to": "text_308", "width": 1}, {"from": 398, "to": "text_309", "width": 1}, {"from": 399, "to": "text_310", "width": 1}, {"from": 400, "to": "text_311", "width": 1}, {"from": 401, "to": "text_312", "width": 1}, {"from": 402, "to": "text_313", "width": 1}, {"from": 403, "to": "text_314", "width": 1}, {"from": 404, "to": "text_315", "width": 1}, {"from": 405, "to": "text_316", "width": 1}, {"from": 406, "to": "text_317", "width": 1}, {"from": 407, "to": "text_318", "width": 1}, {"from": 408, "to": "text_319", "width": 1}, {"from": 409, "to": "text_320", "width": 1}, {"from": 410, "to": "text_321", "width": 1}, {"from": 411, "to": "text_322", "width": 1}, {"from": 412, "to": "text_323", "width": 1}, {"from": 413, "to": "text_324", "width": 1}, {"from": 414, "to": "text_325", "width": 1}, {"from": 415, "to": "text_326", "width": 1}, {"from": 416, "to": "text_327", "width": 1}, {"from": 417, "to": "text_328", "width": 1}, {"from": 418, "to": "text_329", "width": 1}, {"from": 419, "to": "text_330", "width": 1}, {"from": 420, "to": "text_331", "width": 1}, {"from": 421, "to": "text_332", "width": 1}, {"from": 422, "to": "text_333", "width": 1}, {"from": 423, "to": "text_334", "width": 1}, {"from": 424, "to": "text_335", "width": 1}, {"from": 425, "to": "text_336", "width": 1}, {"from": 426, "to": "text_337", "width": 1}, {"from": 427, "to": "text_338", "width": 1}, {"from": 428, "to": "text_339", "width": 1}, {"from": 429, "to": "text_340", "width": 1}, {"from": 430, "to": "text_341", "width": 1}, {"from": 431, "to": "text_342", "width": 1}, {"from": 432, "to": "text_343", "width": 1}, {"from": 433, "to": "text_344", "width": 1}, {"from": 434, "to": "text_345", "width": 1}, {"from": 435, "to": "text_346", "width": 1}, {"from": 436, "to": "text_347", "width": 1}, {"from": 437, "to": "text_348", "width": 1}, {"from": 438, "to": "text_349", "width": 1}, {"from": 439, "to": "text_350", "width": 1}, {"from": 440, "to": "text_351", "width": 1}, {"from": 441, "to": "text_352", "width": 1}, {"from": 442, "to": "text_353", "width": 1}, {"from": 443, "to": "text_354", "width": 1}, {"from": 444, "to": "text_355", "width": 1}, {"from": 445, "to": "text_356", "width": 1}, {"from": 446, "to": "text_357", "width": 1}, {"from": 447, "to": "text_358", "width": 1}, {"from": 448, "to": "text_359", "width": 1}, {"from": 449, "to": "text_360", "width": 1}, {"from": 450, "to": "text_361", "width": 1}, {"from": 451, "to": "text_362", "width": 1}, {"from": 452, "to": "text_363", "width": 1}, {"from": 453, "to": "text_364", "width": 1}, {"from": 454, "to": "text_365", "width": 1}, {"from": 455, "to": "text_366", "width": 1}, {"from": 456, "to": "text_367", "width": 1}, {"from": 457, "to": "text_368", "width": 1}, {"from": 458, "to": "text_369", "width": 1}, {"from": 459, "to": "text_370", "width": 1}, {"from": 460, "to": "text_371", "width": 1}, {"from": 461, "to": "text_372", "width": 1}, {"from": 462, "to": "text_373", "width": 1}, {"from": 463, "to": "text_374", "width": 1}, {"from": 464, "to": "text_375", "width": 1}, {"from": 465, "to": "text_376", "width": 1}, {"from": 466, "to": "text_377", "width": 1}, {"from": 467, "to": "text_378", "width": 1}, {"from": 468, "to": "text_379", "width": 1}, {"from": 469, "to": "text_380", "width": 1}, {"from": 470, "to": "text_381", "width": 1}, {"from": 471, "to": "text_382", "width": 1}, {"from": 472, "to": "text_383", "width": 1}, {"from": 473, "to": "text_384", "width": 1}, {"from": 474, "to": "text_385", "width": 1}, {"from": 475, "to": "text_386", "width": 1}, {"from": 476, "to": "text_387", "width": 1}, {"from": 477, "to": "text_388", "width": 1}, {"from": 478, "to": "text_389", "width": 1}, {"from": 479, "to": "text_390", "width": 1}, {"from": 480, "to": "text_391", "width": 1}, {"from": 481, "to": "text_392", "width": 1}, {"from": 482, "to": "text_393", "width": 1}, {"from": 483, "to": "text_394", "width": 1}, {"from": 484, "to": "text_395", "width": 1}, {"from": 485, "to": "text_396", "width": 1}, {"from": 486, "to": "text_397", "width": 1}, {"from": 487, "to": "text_398", "width": 1}, {"from": 488, "to": "text_399", "width": 1}, {"from": 489, "to": "text_400", "width": 1}, {"from": 490, "to": "text_401", "width": 1}, {"from": 491, "to": "text_402", "width": 1}, {"from": 492, "to": "text_403", "width": 1}, {"from": 493, "to": "text_404", "width": 1}, {"from": 494, "to": "text_405", "width": 1}, {"from": 495, "to": "text_406", "width": 1}, {"from": 496, "to": "text_407", "width": 1}, {"from": 497, "to": "text_408", "width": 1}, {"from": 498, "to": "text_409", "width": 1}, {"from": 499, "to": "text_410", "width": 1}, {"from": 500, "to": "text_411", "width": 1}, {"from": 501, "to": "text_412", "width": 1}, {"from": 502, "to": "text_413", "width": 1}, {"from": 503, "to": "text_414", "width": 1}, {"from": 504, "to": "text_415", "width": 1}, {"from": 505, "to": "text_416", "width": 1}, {"from": 506, "to": "text_417", "width": 1}, {"from": 507, "to": "text_418", "width": 1}, {"from": 508, "to": "text_419", "width": 1}, {"from": 509, "to": "text_420", "width": 1}, {"from": 510, "to": "text_421", "width": 1}, {"from": 511, "to": "text_422", "width": 1}, {"from": 512, "to": "text_423", "width": 1}, {"from": 513, "to": "text_424", "width": 1}, {"from": 514, "to": "text_425", "width": 1}, {"from": 515, "to": "text_426", "width": 1}, {"from": 516, "to": "text_427", "width": 1}, {"from": 517, "to": "text_428", "width": 1}, {"from": 518, "to": "text_429", "width": 1}, {"from": 519, "to": "text_430", "width": 1}, {"from": 520, "to": "text_431", "width": 1}, {"from": 521, "to": "text_432", "width": 1}, {"from": 522, "to": "text_433", "width": 1}, {"from": 523, "to": "text_434", "width": 1}, {"from": 524, "to": "text_435", "width": 1}, {"from": 525, "to": "text_436", "width": 1}, {"from": 526, "to": "text_437", "width": 1}, {"from": 527, "to": "text_438", "width": 1}, {"from": 528, "to": "text_439", "width": 1}, {"from": 529, "to": "text_440", "width": 1}, {"from": 530, "to": "text_441", "width": 1}, {"from": 531, "to": "text_442", "width": 1}, {"from": 532, "to": "text_443", "width": 1}, {"from": 533, "to": "text_444", "width": 1}, {"from": 534, "to": "text_445", "width": 1}, {"from": 535, "to": "text_446", "width": 1}, {"from": 536, "to": "text_447", "width": 1}, {"from": 537, "to": "text_448", "width": 1}, {"from": 538, "to": "text_449", "width": 1}, {"from": 539, "to": "text_450", "width": 1}, {"from": 540, "to": "text_451", "width": 1}, {"from": 541, "to": "text_452", "width": 1}, {"from": 542, "to": "text_453", "width": 1}, {"from": 543, "to": "text_454", "width": 1}, {"from": 544, "to": "text_455", "width": 1}, {"from": 545, "to": "text_456", "width": 1}, {"from": 546, "to": "text_457", "width": 1}, {"from": 547, "to": "text_458", "width": 1}, {"from": 548, "to": "text_459", "width": 1}, {"from": 549, "to": "text_460", "width": 1}, {"from": 550, "to": "text_461", "width": 1}, {"from": 551, "to": "text_462", "width": 1}, {"from": 552, "to": "text_463", "width": 1}, {"from": 553, "to": "text_464", "width": 1}, {"from": 554, "to": "text_465", "width": 1}, {"from": 555, "to": "text_466", "width": 1}, {"from": 556, "to": "text_467", "width": 1}, {"from": 557, "to": "text_468", "width": 1}, {"from": 558, "to": "text_469", "width": 1}, {"from": 559, "to": "text_470", "width": 1}, {"from": 560, "to": "text_471", "width": 1}, {"from": 561, "to": "text_472", "width": 1}, {"from": 562, "to": "text_473", "width": 1}, {"from": 563, "to": "text_474", "width": 1}, {"from": 564, "to": "text_475", "width": 1}, {"from": 565, "to": "text_476", "width": 1}, {"from": 566, "to": "text_477", "width": 1}, {"from": 567, "to": "text_478", "width": 1}]);

                  nodeColors = {};
                  allNodes = nodes.get({ returnType: "Object" });
                  for (nodeId in allNodes) {
                    nodeColors[nodeId] = allNodes[nodeId].color;
                  }
                  allEdges = edges.get({ returnType: "Object" });
                  // adding nodes and edges to the graph
                  data = {nodes: nodes, edges: edges};

                  var options = {
    "configure": {
        "enabled": false
    },
    "edges": {
        "color": {
            "inherit": true
        },
        "smooth": {
            "enabled": true,
            "type": "dynamic"
        }
    },
    "interaction": {
        "dragNodes": true,
        "hideEdgesOnDrag": false,
        "hideNodesOnDrag": false
    },
    "physics": {
        "enabled": true,
        "stabilization": {
            "enabled": true,
            "fit": true,
            "iterations": 1000,
            "onlyDynamicEdges": false,
            "updateInterval": 50
        }
    }
};

                  


                  

                  network = new vis.Network(container, data, options);

                  

                  

                  


                  
                      network.on("stabilizationProgress", function(params) {
                          document.getElementById('loadingBar').removeAttribute("style");
                          var maxWidth = 496;
                          var minWidth = 20;
                          var widthFactor = params.iterations/params.total;
                          var width = Math.max(minWidth,maxWidth * widthFactor);
                          document.getElementById('bar').style.width = width + 'px';
                          document.getElementById('text').innerHTML = Math.round(widthFactor*100) + '%';
                      });
                      network.once("stabilizationIterationsDone", function() {
                          document.getElementById('text').innerHTML = '100%';
                          document.getElementById('bar').style.width = '496px';
                          document.getElementById('loadingBar').style.opacity = 0;
                          // really clean the dom element
                          setTimeout(function () {document.getElementById('loadingBar').style.display = 'none';}, 500);
                      });
                  

                  return network;

              }
              drawGraph();
        </script>
    </body>
</html>